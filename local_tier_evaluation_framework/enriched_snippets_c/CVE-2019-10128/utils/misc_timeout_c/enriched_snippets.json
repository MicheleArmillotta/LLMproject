[
  {
    "function_name": "get_timeout_finish_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
    "lines": "666-670",
    "snippet": "TimestampTz\nget_timeout_finish_time(TimeoutId id)\n{\n\treturn all_timeouts[id].fin_time;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"storage/proc.h\"",
      "#include \"miscadmin.h\"",
      "#include <sys/time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static timeout_params all_timeouts[MAX_TIMEOUTS];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic timeout_params all_timeouts[MAX_TIMEOUTS];\n\nTimestampTz\nget_timeout_finish_time(TimeoutId id)\n{\n\treturn all_timeouts[id].fin_time;\n}"
  },
  {
    "function_name": "get_timeout_start_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
    "lines": "652-656",
    "snippet": "TimestampTz\nget_timeout_start_time(TimeoutId id)\n{\n\treturn all_timeouts[id].start_time;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"storage/proc.h\"",
      "#include \"miscadmin.h\"",
      "#include <sys/time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static timeout_params all_timeouts[MAX_TIMEOUTS];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic timeout_params all_timeouts[MAX_TIMEOUTS];\n\nTimestampTz\nget_timeout_start_time(TimeoutId id)\n{\n\treturn all_timeouts[id].start_time;\n}"
  },
  {
    "function_name": "get_timeout_indicator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
    "lines": "632-642",
    "snippet": "bool\nget_timeout_indicator(TimeoutId id, bool reset_indicator)\n{\n\tif (all_timeouts[id].indicator)\n\t{\n\t\tif (reset_indicator)\n\t\t\tall_timeouts[id].indicator = false;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"storage/proc.h\"",
      "#include \"miscadmin.h\"",
      "#include <sys/time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static timeout_params all_timeouts[MAX_TIMEOUTS];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic timeout_params all_timeouts[MAX_TIMEOUTS];\n\nbool\nget_timeout_indicator(TimeoutId id, bool reset_indicator)\n{\n\tif (all_timeouts[id].indicator)\n\t{\n\t\tif (reset_indicator)\n\t\t\tall_timeouts[id].indicator = false;\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "disable_all_timeouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
    "lines": "595-623",
    "snippet": "void\ndisable_all_timeouts(bool keep_indicators)\n{\n\tdisable_alarm();\n\n\t/*\n\t * Only bother to reset the timer if we think it's active.  We could just\n\t * let the interrupt happen anyway, but it's probably a bit cheaper to do\n\t * setitimer() than to let the useless interrupt happen.\n\t */\n\tif (num_active_timeouts > 0)\n\t{\n\t\tstruct itimerval timeval;\n\n\t\tMemSet(&timeval, 0, sizeof(struct itimerval));\n\t\tif (setitimer(ITIMER_REAL, &timeval, NULL) != 0)\n\t\t\telog(FATAL, \"could not disable SIGALRM timer: %m\");\n\t}\n\n\tnum_active_timeouts = 0;\n\n\tif (!keep_indicators)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < MAX_TIMEOUTS; i++)\n\t\t\tall_timeouts[i].indicator = false;\n\t}\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"storage/proc.h\"",
      "#include \"miscadmin.h\"",
      "#include <sys/time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static timeout_params all_timeouts[MAX_TIMEOUTS];",
      "static volatile int num_active_timeouts = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"could not disable SIGALRM timer: %m\""
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setitimer",
          "args": [
            "ITIMER_REAL",
            "&timeval",
            "NULL"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&timeval",
            "0",
            "sizeof(struct itimerval)"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_alarm",
          "args": [],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic timeout_params all_timeouts[MAX_TIMEOUTS];\nstatic volatile int num_active_timeouts = 0;\n\nvoid\ndisable_all_timeouts(bool keep_indicators)\n{\n\tdisable_alarm();\n\n\t/*\n\t * Only bother to reset the timer if we think it's active.  We could just\n\t * let the interrupt happen anyway, but it's probably a bit cheaper to do\n\t * setitimer() than to let the useless interrupt happen.\n\t */\n\tif (num_active_timeouts > 0)\n\t{\n\t\tstruct itimerval timeval;\n\n\t\tMemSet(&timeval, 0, sizeof(struct itimerval));\n\t\tif (setitimer(ITIMER_REAL, &timeval, NULL) != 0)\n\t\t\telog(FATAL, \"could not disable SIGALRM timer: %m\");\n\t}\n\n\tnum_active_timeouts = 0;\n\n\tif (!keep_indicators)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < MAX_TIMEOUTS; i++)\n\t\t\tall_timeouts[i].indicator = false;\n\t}\n}"
  },
  {
    "function_name": "disable_timeouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
    "lines": "560-589",
    "snippet": "void\ndisable_timeouts(const DisableTimeoutParams *timeouts, int count)\n{\n\tint\t\t\ti;\n\n\tAssert(all_timeouts_initialized);\n\n\t/* Disable timeout interrupts for safety. */\n\tdisable_alarm();\n\n\t/* Cancel the timeout(s). */\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tTimeoutId\tid = timeouts[i].id;\n\t\tint\t\t\tidx;\n\n\t\tAssert(all_timeouts[id].timeout_handler != NULL);\n\n\t\tidx = find_active_timeout(id);\n\t\tif (idx >= 0)\n\t\t\tremove_timeout_index(idx);\n\n\t\tif (!timeouts[i].keep_indicator)\n\t\t\tall_timeouts[id].indicator = false;\n\t}\n\n\t/* Reschedule the interrupt, if any timeouts remain active. */\n\tif (num_active_timeouts > 0)\n\t\tschedule_alarm(GetCurrentTimestamp());\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"storage/proc.h\"",
      "#include \"miscadmin.h\"",
      "#include <sys/time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static timeout_params all_timeouts[MAX_TIMEOUTS];",
      "static bool all_timeouts_initialized = false;",
      "static volatile int num_active_timeouts = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_alarm",
          "args": [
            "GetCurrentTimestamp()"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "184-245",
          "snippet": "static void\nschedule_alarm(TimestampTz now)\n{\n\tif (num_active_timeouts > 0)\n\t{\n\t\tstruct itimerval timeval;\n\t\tlong\t\tsecs;\n\t\tint\t\t\tusecs;\n\n\t\tMemSet(&timeval, 0, sizeof(struct itimerval));\n\n\t\t/* Get the time remaining till the nearest pending timeout */\n\t\tTimestampDifference(now, active_timeouts[0]->fin_time,\n\t\t\t\t\t\t\t&secs, &usecs);\n\n\t\t/*\n\t\t * It's possible that the difference is less than a microsecond;\n\t\t * ensure we don't cancel, rather than set, the interrupt.\n\t\t */\n\t\tif (secs == 0 && usecs == 0)\n\t\t\tusecs = 1;\n\n\t\ttimeval.it_value.tv_sec = secs;\n\t\ttimeval.it_value.tv_usec = usecs;\n\n\t\t/*\n\t\t * We must enable the signal handler before calling setitimer(); if we\n\t\t * did it in the other order, we'd have a race condition wherein the\n\t\t * interrupt could occur before we can set alarm_enabled, so that the\n\t\t * signal handler would fail to do anything.\n\t\t *\n\t\t * Because we didn't bother to reset the timer in disable_alarm(),\n\t\t * it's possible that a previously-set interrupt will fire between\n\t\t * enable_alarm() and setitimer().  This is safe, however.  There are\n\t\t * two possible outcomes:\n\t\t *\n\t\t * 1. The signal handler finds nothing to do (because the nearest\n\t\t * timeout event is still in the future).  It will re-set the timer\n\t\t * and return.  Then we'll overwrite the timer value with a new one.\n\t\t * This will mean that the timer fires a little later than we\n\t\t * intended, but only by the amount of time it takes for the signal\n\t\t * handler to do nothing useful, which shouldn't be much.\n\t\t *\n\t\t * 2. The signal handler executes and removes one or more timeout\n\t\t * events.  When it returns, either the queue is now empty or the\n\t\t * frontmost event is later than the one we looked at above.  So we'll\n\t\t * overwrite the timer value with one that is too soon (plus or minus\n\t\t * the signal handler's execution time), causing a useless interrupt\n\t\t * to occur.  But the handler will then re-set the timer and\n\t\t * everything will still work as expected.\n\t\t *\n\t\t * Since these cases are of very low probability (the window here\n\t\t * being quite narrow), it's not worth adding cycles to the mainline\n\t\t * code to prevent occasional wasted interrupts.\n\t\t */\n\t\tenable_alarm();\n\n\t\t/* Set the alarm timer */\n\t\tif (setitimer(ITIMER_REAL, &timeval, NULL) != 0)\n\t\t\telog(FATAL, \"could not enable SIGALRM timer: %m\");\n\t}\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile int num_active_timeouts = 0;",
            "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];",
            "static volatile sig_atomic_t alarm_enabled = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\nstatic volatile sig_atomic_t alarm_enabled = false;\n\nstatic void\nschedule_alarm(TimestampTz now)\n{\n\tif (num_active_timeouts > 0)\n\t{\n\t\tstruct itimerval timeval;\n\t\tlong\t\tsecs;\n\t\tint\t\t\tusecs;\n\n\t\tMemSet(&timeval, 0, sizeof(struct itimerval));\n\n\t\t/* Get the time remaining till the nearest pending timeout */\n\t\tTimestampDifference(now, active_timeouts[0]->fin_time,\n\t\t\t\t\t\t\t&secs, &usecs);\n\n\t\t/*\n\t\t * It's possible that the difference is less than a microsecond;\n\t\t * ensure we don't cancel, rather than set, the interrupt.\n\t\t */\n\t\tif (secs == 0 && usecs == 0)\n\t\t\tusecs = 1;\n\n\t\ttimeval.it_value.tv_sec = secs;\n\t\ttimeval.it_value.tv_usec = usecs;\n\n\t\t/*\n\t\t * We must enable the signal handler before calling setitimer(); if we\n\t\t * did it in the other order, we'd have a race condition wherein the\n\t\t * interrupt could occur before we can set alarm_enabled, so that the\n\t\t * signal handler would fail to do anything.\n\t\t *\n\t\t * Because we didn't bother to reset the timer in disable_alarm(),\n\t\t * it's possible that a previously-set interrupt will fire between\n\t\t * enable_alarm() and setitimer().  This is safe, however.  There are\n\t\t * two possible outcomes:\n\t\t *\n\t\t * 1. The signal handler finds nothing to do (because the nearest\n\t\t * timeout event is still in the future).  It will re-set the timer\n\t\t * and return.  Then we'll overwrite the timer value with a new one.\n\t\t * This will mean that the timer fires a little later than we\n\t\t * intended, but only by the amount of time it takes for the signal\n\t\t * handler to do nothing useful, which shouldn't be much.\n\t\t *\n\t\t * 2. The signal handler executes and removes one or more timeout\n\t\t * events.  When it returns, either the queue is now empty or the\n\t\t * frontmost event is later than the one we looked at above.  So we'll\n\t\t * overwrite the timer value with one that is too soon (plus or minus\n\t\t * the signal handler's execution time), causing a useless interrupt\n\t\t * to occur.  But the handler will then re-set the timer and\n\t\t * everything will still work as expected.\n\t\t *\n\t\t * Since these cases are of very low probability (the window here\n\t\t * being quite narrow), it's not worth adding cycles to the mainline\n\t\t * code to prevent occasional wasted interrupts.\n\t\t */\n\t\tenable_alarm();\n\n\t\t/* Set the alarm timer */\n\t\tif (setitimer(ITIMER_REAL, &timeval, NULL) != 0)\n\t\t\telog(FATAL, \"could not enable SIGALRM timer: %m\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentTimestamp",
          "args": [],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "GetCurrentTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1569-1582",
          "snippet": "TimestampTz\nGetCurrentTimestamp(void)\n{\n\tTimestampTz result;\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, NULL);\n\n\tresult = (TimestampTz) tp.tv_sec -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult = (result * USECS_PER_SEC) + tp.tv_usec;\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimestampTz\nGetCurrentTimestamp(void)\n{\n\tTimestampTz result;\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, NULL);\n\n\tresult = (TimestampTz) tp.tv_sec -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult = (result * USECS_PER_SEC) + tp.tv_usec;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_timeout_index",
          "args": [
            "idx"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "remove_timeout_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "119-132",
          "snippet": "static void\nremove_timeout_index(int index)\n{\n\tint\t\t\ti;\n\n\tif (index < 0 || index >= num_active_timeouts)\n\t\telog(FATAL, \"timeout index %d out of range 0..%d\", index,\n\t\t\t num_active_timeouts - 1);\n\n\tfor (i = index + 1; i < num_active_timeouts; i++)\n\t\tactive_timeouts[i - 1] = active_timeouts[i];\n\n\tnum_active_timeouts--;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile int num_active_timeouts = 0;",
            "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\n\nstatic void\nremove_timeout_index(int index)\n{\n\tint\t\t\ti;\n\n\tif (index < 0 || index >= num_active_timeouts)\n\t\telog(FATAL, \"timeout index %d out of range 0..%d\", index,\n\t\t\t num_active_timeouts - 1);\n\n\tfor (i = index + 1; i < num_active_timeouts; i++)\n\t\tactive_timeouts[i - 1] = active_timeouts[i];\n\n\tnum_active_timeouts--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_active_timeout",
          "args": [
            "id"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "find_active_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "81-93",
          "snippet": "static int\nfind_active_timeout(TimeoutId id)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < num_active_timeouts; i++)\n\t{\n\t\tif (active_timeouts[i]->index == id)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile int num_active_timeouts = 0;",
            "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\n\nstatic int\nfind_active_timeout(TimeoutId id)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < num_active_timeouts; i++)\n\t{\n\t\tif (active_timeouts[i]->index == id)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "all_timeouts[id].timeout_handler != NULL"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_alarm",
          "args": [],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "all_timeouts_initialized"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic timeout_params all_timeouts[MAX_TIMEOUTS];\nstatic bool all_timeouts_initialized = false;\nstatic volatile int num_active_timeouts = 0;\n\nvoid\ndisable_timeouts(const DisableTimeoutParams *timeouts, int count)\n{\n\tint\t\t\ti;\n\n\tAssert(all_timeouts_initialized);\n\n\t/* Disable timeout interrupts for safety. */\n\tdisable_alarm();\n\n\t/* Cancel the timeout(s). */\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tTimeoutId\tid = timeouts[i].id;\n\t\tint\t\t\tidx;\n\n\t\tAssert(all_timeouts[id].timeout_handler != NULL);\n\n\t\tidx = find_active_timeout(id);\n\t\tif (idx >= 0)\n\t\t\tremove_timeout_index(idx);\n\n\t\tif (!timeouts[i].keep_indicator)\n\t\t\tall_timeouts[id].indicator = false;\n\t}\n\n\t/* Reschedule the interrupt, if any timeouts remain active. */\n\tif (num_active_timeouts > 0)\n\t\tschedule_alarm(GetCurrentTimestamp());\n}"
  },
  {
    "function_name": "disable_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
    "lines": "524-548",
    "snippet": "void\ndisable_timeout(TimeoutId id, bool keep_indicator)\n{\n\tint\t\t\ti;\n\n\t/* Assert request is sane */\n\tAssert(all_timeouts_initialized);\n\tAssert(all_timeouts[id].timeout_handler != NULL);\n\n\t/* Disable timeout interrupts for safety. */\n\tdisable_alarm();\n\n\t/* Find the timeout and remove it from the active list. */\n\ti = find_active_timeout(id);\n\tif (i >= 0)\n\t\tremove_timeout_index(i);\n\n\t/* Mark it inactive, whether it was active or not. */\n\tif (!keep_indicator)\n\t\tall_timeouts[id].indicator = false;\n\n\t/* Reschedule the interrupt, if any timeouts remain active. */\n\tif (num_active_timeouts > 0)\n\t\tschedule_alarm(GetCurrentTimestamp());\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"storage/proc.h\"",
      "#include \"miscadmin.h\"",
      "#include <sys/time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static timeout_params all_timeouts[MAX_TIMEOUTS];",
      "static bool all_timeouts_initialized = false;",
      "static volatile int num_active_timeouts = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_alarm",
          "args": [
            "GetCurrentTimestamp()"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "184-245",
          "snippet": "static void\nschedule_alarm(TimestampTz now)\n{\n\tif (num_active_timeouts > 0)\n\t{\n\t\tstruct itimerval timeval;\n\t\tlong\t\tsecs;\n\t\tint\t\t\tusecs;\n\n\t\tMemSet(&timeval, 0, sizeof(struct itimerval));\n\n\t\t/* Get the time remaining till the nearest pending timeout */\n\t\tTimestampDifference(now, active_timeouts[0]->fin_time,\n\t\t\t\t\t\t\t&secs, &usecs);\n\n\t\t/*\n\t\t * It's possible that the difference is less than a microsecond;\n\t\t * ensure we don't cancel, rather than set, the interrupt.\n\t\t */\n\t\tif (secs == 0 && usecs == 0)\n\t\t\tusecs = 1;\n\n\t\ttimeval.it_value.tv_sec = secs;\n\t\ttimeval.it_value.tv_usec = usecs;\n\n\t\t/*\n\t\t * We must enable the signal handler before calling setitimer(); if we\n\t\t * did it in the other order, we'd have a race condition wherein the\n\t\t * interrupt could occur before we can set alarm_enabled, so that the\n\t\t * signal handler would fail to do anything.\n\t\t *\n\t\t * Because we didn't bother to reset the timer in disable_alarm(),\n\t\t * it's possible that a previously-set interrupt will fire between\n\t\t * enable_alarm() and setitimer().  This is safe, however.  There are\n\t\t * two possible outcomes:\n\t\t *\n\t\t * 1. The signal handler finds nothing to do (because the nearest\n\t\t * timeout event is still in the future).  It will re-set the timer\n\t\t * and return.  Then we'll overwrite the timer value with a new one.\n\t\t * This will mean that the timer fires a little later than we\n\t\t * intended, but only by the amount of time it takes for the signal\n\t\t * handler to do nothing useful, which shouldn't be much.\n\t\t *\n\t\t * 2. The signal handler executes and removes one or more timeout\n\t\t * events.  When it returns, either the queue is now empty or the\n\t\t * frontmost event is later than the one we looked at above.  So we'll\n\t\t * overwrite the timer value with one that is too soon (plus or minus\n\t\t * the signal handler's execution time), causing a useless interrupt\n\t\t * to occur.  But the handler will then re-set the timer and\n\t\t * everything will still work as expected.\n\t\t *\n\t\t * Since these cases are of very low probability (the window here\n\t\t * being quite narrow), it's not worth adding cycles to the mainline\n\t\t * code to prevent occasional wasted interrupts.\n\t\t */\n\t\tenable_alarm();\n\n\t\t/* Set the alarm timer */\n\t\tif (setitimer(ITIMER_REAL, &timeval, NULL) != 0)\n\t\t\telog(FATAL, \"could not enable SIGALRM timer: %m\");\n\t}\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile int num_active_timeouts = 0;",
            "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];",
            "static volatile sig_atomic_t alarm_enabled = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\nstatic volatile sig_atomic_t alarm_enabled = false;\n\nstatic void\nschedule_alarm(TimestampTz now)\n{\n\tif (num_active_timeouts > 0)\n\t{\n\t\tstruct itimerval timeval;\n\t\tlong\t\tsecs;\n\t\tint\t\t\tusecs;\n\n\t\tMemSet(&timeval, 0, sizeof(struct itimerval));\n\n\t\t/* Get the time remaining till the nearest pending timeout */\n\t\tTimestampDifference(now, active_timeouts[0]->fin_time,\n\t\t\t\t\t\t\t&secs, &usecs);\n\n\t\t/*\n\t\t * It's possible that the difference is less than a microsecond;\n\t\t * ensure we don't cancel, rather than set, the interrupt.\n\t\t */\n\t\tif (secs == 0 && usecs == 0)\n\t\t\tusecs = 1;\n\n\t\ttimeval.it_value.tv_sec = secs;\n\t\ttimeval.it_value.tv_usec = usecs;\n\n\t\t/*\n\t\t * We must enable the signal handler before calling setitimer(); if we\n\t\t * did it in the other order, we'd have a race condition wherein the\n\t\t * interrupt could occur before we can set alarm_enabled, so that the\n\t\t * signal handler would fail to do anything.\n\t\t *\n\t\t * Because we didn't bother to reset the timer in disable_alarm(),\n\t\t * it's possible that a previously-set interrupt will fire between\n\t\t * enable_alarm() and setitimer().  This is safe, however.  There are\n\t\t * two possible outcomes:\n\t\t *\n\t\t * 1. The signal handler finds nothing to do (because the nearest\n\t\t * timeout event is still in the future).  It will re-set the timer\n\t\t * and return.  Then we'll overwrite the timer value with a new one.\n\t\t * This will mean that the timer fires a little later than we\n\t\t * intended, but only by the amount of time it takes for the signal\n\t\t * handler to do nothing useful, which shouldn't be much.\n\t\t *\n\t\t * 2. The signal handler executes and removes one or more timeout\n\t\t * events.  When it returns, either the queue is now empty or the\n\t\t * frontmost event is later than the one we looked at above.  So we'll\n\t\t * overwrite the timer value with one that is too soon (plus or minus\n\t\t * the signal handler's execution time), causing a useless interrupt\n\t\t * to occur.  But the handler will then re-set the timer and\n\t\t * everything will still work as expected.\n\t\t *\n\t\t * Since these cases are of very low probability (the window here\n\t\t * being quite narrow), it's not worth adding cycles to the mainline\n\t\t * code to prevent occasional wasted interrupts.\n\t\t */\n\t\tenable_alarm();\n\n\t\t/* Set the alarm timer */\n\t\tif (setitimer(ITIMER_REAL, &timeval, NULL) != 0)\n\t\t\telog(FATAL, \"could not enable SIGALRM timer: %m\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentTimestamp",
          "args": [],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "GetCurrentTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1569-1582",
          "snippet": "TimestampTz\nGetCurrentTimestamp(void)\n{\n\tTimestampTz result;\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, NULL);\n\n\tresult = (TimestampTz) tp.tv_sec -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult = (result * USECS_PER_SEC) + tp.tv_usec;\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimestampTz\nGetCurrentTimestamp(void)\n{\n\tTimestampTz result;\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, NULL);\n\n\tresult = (TimestampTz) tp.tv_sec -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult = (result * USECS_PER_SEC) + tp.tv_usec;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_timeout_index",
          "args": [
            "i"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "remove_timeout_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "119-132",
          "snippet": "static void\nremove_timeout_index(int index)\n{\n\tint\t\t\ti;\n\n\tif (index < 0 || index >= num_active_timeouts)\n\t\telog(FATAL, \"timeout index %d out of range 0..%d\", index,\n\t\t\t num_active_timeouts - 1);\n\n\tfor (i = index + 1; i < num_active_timeouts; i++)\n\t\tactive_timeouts[i - 1] = active_timeouts[i];\n\n\tnum_active_timeouts--;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile int num_active_timeouts = 0;",
            "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\n\nstatic void\nremove_timeout_index(int index)\n{\n\tint\t\t\ti;\n\n\tif (index < 0 || index >= num_active_timeouts)\n\t\telog(FATAL, \"timeout index %d out of range 0..%d\", index,\n\t\t\t num_active_timeouts - 1);\n\n\tfor (i = index + 1; i < num_active_timeouts; i++)\n\t\tactive_timeouts[i - 1] = active_timeouts[i];\n\n\tnum_active_timeouts--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_active_timeout",
          "args": [
            "id"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "find_active_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "81-93",
          "snippet": "static int\nfind_active_timeout(TimeoutId id)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < num_active_timeouts; i++)\n\t{\n\t\tif (active_timeouts[i]->index == id)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile int num_active_timeouts = 0;",
            "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\n\nstatic int\nfind_active_timeout(TimeoutId id)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < num_active_timeouts; i++)\n\t{\n\t\tif (active_timeouts[i]->index == id)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_alarm",
          "args": [],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "all_timeouts[id].timeout_handler != NULL"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "all_timeouts_initialized"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic timeout_params all_timeouts[MAX_TIMEOUTS];\nstatic bool all_timeouts_initialized = false;\nstatic volatile int num_active_timeouts = 0;\n\nvoid\ndisable_timeout(TimeoutId id, bool keep_indicator)\n{\n\tint\t\t\ti;\n\n\t/* Assert request is sane */\n\tAssert(all_timeouts_initialized);\n\tAssert(all_timeouts[id].timeout_handler != NULL);\n\n\t/* Disable timeout interrupts for safety. */\n\tdisable_alarm();\n\n\t/* Find the timeout and remove it from the active list. */\n\ti = find_active_timeout(id);\n\tif (i >= 0)\n\t\tremove_timeout_index(i);\n\n\t/* Mark it inactive, whether it was active or not. */\n\tif (!keep_indicator)\n\t\tall_timeouts[id].indicator = false;\n\n\t/* Reschedule the interrupt, if any timeouts remain active. */\n\tif (num_active_timeouts > 0)\n\t\tschedule_alarm(GetCurrentTimestamp());\n}"
  },
  {
    "function_name": "enable_timeouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
    "lines": "475-513",
    "snippet": "void\nenable_timeouts(const EnableTimeoutParams *timeouts, int count)\n{\n\tTimestampTz now;\n\tint\t\t\ti;\n\n\t/* Disable timeout interrupts for safety. */\n\tdisable_alarm();\n\n\t/* Queue the timeout(s) at the appropriate times. */\n\tnow = GetCurrentTimestamp();\n\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tTimeoutId\tid = timeouts[i].id;\n\t\tTimestampTz fin_time;\n\n\t\tswitch (timeouts[i].type)\n\t\t{\n\t\t\tcase TMPARAM_AFTER:\n\t\t\t\tfin_time = TimestampTzPlusMilliseconds(now,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   timeouts[i].delay_ms);\n\t\t\t\tenable_timeout(id, now, fin_time);\n\t\t\t\tbreak;\n\n\t\t\tcase TMPARAM_AT:\n\t\t\t\tenable_timeout(id, now, timeouts[i].fin_time);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized timeout type %d\",\n\t\t\t\t\t (int) timeouts[i].type);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Set the timer interrupt. */\n\tschedule_alarm(now);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"storage/proc.h\"",
      "#include \"miscadmin.h\"",
      "#include <sys/time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_alarm",
          "args": [
            "now"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "184-245",
          "snippet": "static void\nschedule_alarm(TimestampTz now)\n{\n\tif (num_active_timeouts > 0)\n\t{\n\t\tstruct itimerval timeval;\n\t\tlong\t\tsecs;\n\t\tint\t\t\tusecs;\n\n\t\tMemSet(&timeval, 0, sizeof(struct itimerval));\n\n\t\t/* Get the time remaining till the nearest pending timeout */\n\t\tTimestampDifference(now, active_timeouts[0]->fin_time,\n\t\t\t\t\t\t\t&secs, &usecs);\n\n\t\t/*\n\t\t * It's possible that the difference is less than a microsecond;\n\t\t * ensure we don't cancel, rather than set, the interrupt.\n\t\t */\n\t\tif (secs == 0 && usecs == 0)\n\t\t\tusecs = 1;\n\n\t\ttimeval.it_value.tv_sec = secs;\n\t\ttimeval.it_value.tv_usec = usecs;\n\n\t\t/*\n\t\t * We must enable the signal handler before calling setitimer(); if we\n\t\t * did it in the other order, we'd have a race condition wherein the\n\t\t * interrupt could occur before we can set alarm_enabled, so that the\n\t\t * signal handler would fail to do anything.\n\t\t *\n\t\t * Because we didn't bother to reset the timer in disable_alarm(),\n\t\t * it's possible that a previously-set interrupt will fire between\n\t\t * enable_alarm() and setitimer().  This is safe, however.  There are\n\t\t * two possible outcomes:\n\t\t *\n\t\t * 1. The signal handler finds nothing to do (because the nearest\n\t\t * timeout event is still in the future).  It will re-set the timer\n\t\t * and return.  Then we'll overwrite the timer value with a new one.\n\t\t * This will mean that the timer fires a little later than we\n\t\t * intended, but only by the amount of time it takes for the signal\n\t\t * handler to do nothing useful, which shouldn't be much.\n\t\t *\n\t\t * 2. The signal handler executes and removes one or more timeout\n\t\t * events.  When it returns, either the queue is now empty or the\n\t\t * frontmost event is later than the one we looked at above.  So we'll\n\t\t * overwrite the timer value with one that is too soon (plus or minus\n\t\t * the signal handler's execution time), causing a useless interrupt\n\t\t * to occur.  But the handler will then re-set the timer and\n\t\t * everything will still work as expected.\n\t\t *\n\t\t * Since these cases are of very low probability (the window here\n\t\t * being quite narrow), it's not worth adding cycles to the mainline\n\t\t * code to prevent occasional wasted interrupts.\n\t\t */\n\t\tenable_alarm();\n\n\t\t/* Set the alarm timer */\n\t\tif (setitimer(ITIMER_REAL, &timeval, NULL) != 0)\n\t\t\telog(FATAL, \"could not enable SIGALRM timer: %m\");\n\t}\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile int num_active_timeouts = 0;",
            "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];",
            "static volatile sig_atomic_t alarm_enabled = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\nstatic volatile sig_atomic_t alarm_enabled = false;\n\nstatic void\nschedule_alarm(TimestampTz now)\n{\n\tif (num_active_timeouts > 0)\n\t{\n\t\tstruct itimerval timeval;\n\t\tlong\t\tsecs;\n\t\tint\t\t\tusecs;\n\n\t\tMemSet(&timeval, 0, sizeof(struct itimerval));\n\n\t\t/* Get the time remaining till the nearest pending timeout */\n\t\tTimestampDifference(now, active_timeouts[0]->fin_time,\n\t\t\t\t\t\t\t&secs, &usecs);\n\n\t\t/*\n\t\t * It's possible that the difference is less than a microsecond;\n\t\t * ensure we don't cancel, rather than set, the interrupt.\n\t\t */\n\t\tif (secs == 0 && usecs == 0)\n\t\t\tusecs = 1;\n\n\t\ttimeval.it_value.tv_sec = secs;\n\t\ttimeval.it_value.tv_usec = usecs;\n\n\t\t/*\n\t\t * We must enable the signal handler before calling setitimer(); if we\n\t\t * did it in the other order, we'd have a race condition wherein the\n\t\t * interrupt could occur before we can set alarm_enabled, so that the\n\t\t * signal handler would fail to do anything.\n\t\t *\n\t\t * Because we didn't bother to reset the timer in disable_alarm(),\n\t\t * it's possible that a previously-set interrupt will fire between\n\t\t * enable_alarm() and setitimer().  This is safe, however.  There are\n\t\t * two possible outcomes:\n\t\t *\n\t\t * 1. The signal handler finds nothing to do (because the nearest\n\t\t * timeout event is still in the future).  It will re-set the timer\n\t\t * and return.  Then we'll overwrite the timer value with a new one.\n\t\t * This will mean that the timer fires a little later than we\n\t\t * intended, but only by the amount of time it takes for the signal\n\t\t * handler to do nothing useful, which shouldn't be much.\n\t\t *\n\t\t * 2. The signal handler executes and removes one or more timeout\n\t\t * events.  When it returns, either the queue is now empty or the\n\t\t * frontmost event is later than the one we looked at above.  So we'll\n\t\t * overwrite the timer value with one that is too soon (plus or minus\n\t\t * the signal handler's execution time), causing a useless interrupt\n\t\t * to occur.  But the handler will then re-set the timer and\n\t\t * everything will still work as expected.\n\t\t *\n\t\t * Since these cases are of very low probability (the window here\n\t\t * being quite narrow), it's not worth adding cycles to the mainline\n\t\t * code to prevent occasional wasted interrupts.\n\t\t */\n\t\tenable_alarm();\n\n\t\t/* Set the alarm timer */\n\t\tif (setitimer(ITIMER_REAL, &timeval, NULL) != 0)\n\t\t\telog(FATAL, \"could not enable SIGALRM timer: %m\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized timeout type %d\"",
            "(int) timeouts[i].type"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enable_timeout",
          "args": [
            "id",
            "now",
            "timeouts[i].fin_time"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "enable_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "137-176",
          "snippet": "static void\nenable_timeout(TimeoutId id, TimestampTz now, TimestampTz fin_time)\n{\n\tint\t\t\ti;\n\n\t/* Assert request is sane */\n\tAssert(all_timeouts_initialized);\n\tAssert(all_timeouts[id].timeout_handler != NULL);\n\n\t/*\n\t * If this timeout was already active, momentarily disable it.  We\n\t * interpret the call as a directive to reschedule the timeout.\n\t */\n\ti = find_active_timeout(id);\n\tif (i >= 0)\n\t\tremove_timeout_index(i);\n\n\t/*\n\t * Find out the index where to insert the new timeout.  We sort by\n\t * fin_time, and for equal fin_time by priority.\n\t */\n\tfor (i = 0; i < num_active_timeouts; i++)\n\t{\n\t\ttimeout_params *old_timeout = active_timeouts[i];\n\n\t\tif (fin_time < old_timeout->fin_time)\n\t\t\tbreak;\n\t\tif (fin_time == old_timeout->fin_time && id < old_timeout->index)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Mark the timeout active, and insert it into the active list.\n\t */\n\tall_timeouts[id].indicator = false;\n\tall_timeouts[id].start_time = now;\n\tall_timeouts[id].fin_time = fin_time;\n\n\tinsert_timeout(id, i);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static timeout_params all_timeouts[MAX_TIMEOUTS];",
            "static bool all_timeouts_initialized = false;",
            "static volatile int num_active_timeouts = 0;",
            "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic timeout_params all_timeouts[MAX_TIMEOUTS];\nstatic bool all_timeouts_initialized = false;\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\n\nstatic void\nenable_timeout(TimeoutId id, TimestampTz now, TimestampTz fin_time)\n{\n\tint\t\t\ti;\n\n\t/* Assert request is sane */\n\tAssert(all_timeouts_initialized);\n\tAssert(all_timeouts[id].timeout_handler != NULL);\n\n\t/*\n\t * If this timeout was already active, momentarily disable it.  We\n\t * interpret the call as a directive to reschedule the timeout.\n\t */\n\ti = find_active_timeout(id);\n\tif (i >= 0)\n\t\tremove_timeout_index(i);\n\n\t/*\n\t * Find out the index where to insert the new timeout.  We sort by\n\t * fin_time, and for equal fin_time by priority.\n\t */\n\tfor (i = 0; i < num_active_timeouts; i++)\n\t{\n\t\ttimeout_params *old_timeout = active_timeouts[i];\n\n\t\tif (fin_time < old_timeout->fin_time)\n\t\t\tbreak;\n\t\tif (fin_time == old_timeout->fin_time && id < old_timeout->index)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Mark the timeout active, and insert it into the active list.\n\t */\n\tall_timeouts[id].indicator = false;\n\tall_timeouts[id].start_time = now;\n\tall_timeouts[id].fin_time = fin_time;\n\n\tinsert_timeout(id, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TimestampTzPlusMilliseconds",
          "args": [
            "now",
            "timeouts[i].delay_ms"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentTimestamp",
          "args": [],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "GetCurrentTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1569-1582",
          "snippet": "TimestampTz\nGetCurrentTimestamp(void)\n{\n\tTimestampTz result;\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, NULL);\n\n\tresult = (TimestampTz) tp.tv_sec -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult = (result * USECS_PER_SEC) + tp.tv_usec;\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimestampTz\nGetCurrentTimestamp(void)\n{\n\tTimestampTz result;\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, NULL);\n\n\tresult = (TimestampTz) tp.tv_sec -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult = (result * USECS_PER_SEC) + tp.tv_usec;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_alarm",
          "args": [],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nvoid\nenable_timeouts(const EnableTimeoutParams *timeouts, int count)\n{\n\tTimestampTz now;\n\tint\t\t\ti;\n\n\t/* Disable timeout interrupts for safety. */\n\tdisable_alarm();\n\n\t/* Queue the timeout(s) at the appropriate times. */\n\tnow = GetCurrentTimestamp();\n\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tTimeoutId\tid = timeouts[i].id;\n\t\tTimestampTz fin_time;\n\n\t\tswitch (timeouts[i].type)\n\t\t{\n\t\t\tcase TMPARAM_AFTER:\n\t\t\t\tfin_time = TimestampTzPlusMilliseconds(now,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   timeouts[i].delay_ms);\n\t\t\t\tenable_timeout(id, now, fin_time);\n\t\t\t\tbreak;\n\n\t\t\tcase TMPARAM_AT:\n\t\t\t\tenable_timeout(id, now, timeouts[i].fin_time);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized timeout type %d\",\n\t\t\t\t\t (int) timeouts[i].type);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Set the timer interrupt. */\n\tschedule_alarm(now);\n}"
  },
  {
    "function_name": "enable_timeout_at",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
    "lines": "452-466",
    "snippet": "void\nenable_timeout_at(TimeoutId id, TimestampTz fin_time)\n{\n\tTimestampTz now;\n\n\t/* Disable timeout interrupts for safety. */\n\tdisable_alarm();\n\n\t/* Queue the timeout at the appropriate time. */\n\tnow = GetCurrentTimestamp();\n\tenable_timeout(id, now, fin_time);\n\n\t/* Set the timer interrupt. */\n\tschedule_alarm(now);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"storage/proc.h\"",
      "#include \"miscadmin.h\"",
      "#include <sys/time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_alarm",
          "args": [
            "now"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "184-245",
          "snippet": "static void\nschedule_alarm(TimestampTz now)\n{\n\tif (num_active_timeouts > 0)\n\t{\n\t\tstruct itimerval timeval;\n\t\tlong\t\tsecs;\n\t\tint\t\t\tusecs;\n\n\t\tMemSet(&timeval, 0, sizeof(struct itimerval));\n\n\t\t/* Get the time remaining till the nearest pending timeout */\n\t\tTimestampDifference(now, active_timeouts[0]->fin_time,\n\t\t\t\t\t\t\t&secs, &usecs);\n\n\t\t/*\n\t\t * It's possible that the difference is less than a microsecond;\n\t\t * ensure we don't cancel, rather than set, the interrupt.\n\t\t */\n\t\tif (secs == 0 && usecs == 0)\n\t\t\tusecs = 1;\n\n\t\ttimeval.it_value.tv_sec = secs;\n\t\ttimeval.it_value.tv_usec = usecs;\n\n\t\t/*\n\t\t * We must enable the signal handler before calling setitimer(); if we\n\t\t * did it in the other order, we'd have a race condition wherein the\n\t\t * interrupt could occur before we can set alarm_enabled, so that the\n\t\t * signal handler would fail to do anything.\n\t\t *\n\t\t * Because we didn't bother to reset the timer in disable_alarm(),\n\t\t * it's possible that a previously-set interrupt will fire between\n\t\t * enable_alarm() and setitimer().  This is safe, however.  There are\n\t\t * two possible outcomes:\n\t\t *\n\t\t * 1. The signal handler finds nothing to do (because the nearest\n\t\t * timeout event is still in the future).  It will re-set the timer\n\t\t * and return.  Then we'll overwrite the timer value with a new one.\n\t\t * This will mean that the timer fires a little later than we\n\t\t * intended, but only by the amount of time it takes for the signal\n\t\t * handler to do nothing useful, which shouldn't be much.\n\t\t *\n\t\t * 2. The signal handler executes and removes one or more timeout\n\t\t * events.  When it returns, either the queue is now empty or the\n\t\t * frontmost event is later than the one we looked at above.  So we'll\n\t\t * overwrite the timer value with one that is too soon (plus or minus\n\t\t * the signal handler's execution time), causing a useless interrupt\n\t\t * to occur.  But the handler will then re-set the timer and\n\t\t * everything will still work as expected.\n\t\t *\n\t\t * Since these cases are of very low probability (the window here\n\t\t * being quite narrow), it's not worth adding cycles to the mainline\n\t\t * code to prevent occasional wasted interrupts.\n\t\t */\n\t\tenable_alarm();\n\n\t\t/* Set the alarm timer */\n\t\tif (setitimer(ITIMER_REAL, &timeval, NULL) != 0)\n\t\t\telog(FATAL, \"could not enable SIGALRM timer: %m\");\n\t}\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile int num_active_timeouts = 0;",
            "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];",
            "static volatile sig_atomic_t alarm_enabled = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\nstatic volatile sig_atomic_t alarm_enabled = false;\n\nstatic void\nschedule_alarm(TimestampTz now)\n{\n\tif (num_active_timeouts > 0)\n\t{\n\t\tstruct itimerval timeval;\n\t\tlong\t\tsecs;\n\t\tint\t\t\tusecs;\n\n\t\tMemSet(&timeval, 0, sizeof(struct itimerval));\n\n\t\t/* Get the time remaining till the nearest pending timeout */\n\t\tTimestampDifference(now, active_timeouts[0]->fin_time,\n\t\t\t\t\t\t\t&secs, &usecs);\n\n\t\t/*\n\t\t * It's possible that the difference is less than a microsecond;\n\t\t * ensure we don't cancel, rather than set, the interrupt.\n\t\t */\n\t\tif (secs == 0 && usecs == 0)\n\t\t\tusecs = 1;\n\n\t\ttimeval.it_value.tv_sec = secs;\n\t\ttimeval.it_value.tv_usec = usecs;\n\n\t\t/*\n\t\t * We must enable the signal handler before calling setitimer(); if we\n\t\t * did it in the other order, we'd have a race condition wherein the\n\t\t * interrupt could occur before we can set alarm_enabled, so that the\n\t\t * signal handler would fail to do anything.\n\t\t *\n\t\t * Because we didn't bother to reset the timer in disable_alarm(),\n\t\t * it's possible that a previously-set interrupt will fire between\n\t\t * enable_alarm() and setitimer().  This is safe, however.  There are\n\t\t * two possible outcomes:\n\t\t *\n\t\t * 1. The signal handler finds nothing to do (because the nearest\n\t\t * timeout event is still in the future).  It will re-set the timer\n\t\t * and return.  Then we'll overwrite the timer value with a new one.\n\t\t * This will mean that the timer fires a little later than we\n\t\t * intended, but only by the amount of time it takes for the signal\n\t\t * handler to do nothing useful, which shouldn't be much.\n\t\t *\n\t\t * 2. The signal handler executes and removes one or more timeout\n\t\t * events.  When it returns, either the queue is now empty or the\n\t\t * frontmost event is later than the one we looked at above.  So we'll\n\t\t * overwrite the timer value with one that is too soon (plus or minus\n\t\t * the signal handler's execution time), causing a useless interrupt\n\t\t * to occur.  But the handler will then re-set the timer and\n\t\t * everything will still work as expected.\n\t\t *\n\t\t * Since these cases are of very low probability (the window here\n\t\t * being quite narrow), it's not worth adding cycles to the mainline\n\t\t * code to prevent occasional wasted interrupts.\n\t\t */\n\t\tenable_alarm();\n\n\t\t/* Set the alarm timer */\n\t\tif (setitimer(ITIMER_REAL, &timeval, NULL) != 0)\n\t\t\telog(FATAL, \"could not enable SIGALRM timer: %m\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "enable_timeout",
          "args": [
            "id",
            "now",
            "fin_time"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "enable_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "137-176",
          "snippet": "static void\nenable_timeout(TimeoutId id, TimestampTz now, TimestampTz fin_time)\n{\n\tint\t\t\ti;\n\n\t/* Assert request is sane */\n\tAssert(all_timeouts_initialized);\n\tAssert(all_timeouts[id].timeout_handler != NULL);\n\n\t/*\n\t * If this timeout was already active, momentarily disable it.  We\n\t * interpret the call as a directive to reschedule the timeout.\n\t */\n\ti = find_active_timeout(id);\n\tif (i >= 0)\n\t\tremove_timeout_index(i);\n\n\t/*\n\t * Find out the index where to insert the new timeout.  We sort by\n\t * fin_time, and for equal fin_time by priority.\n\t */\n\tfor (i = 0; i < num_active_timeouts; i++)\n\t{\n\t\ttimeout_params *old_timeout = active_timeouts[i];\n\n\t\tif (fin_time < old_timeout->fin_time)\n\t\t\tbreak;\n\t\tif (fin_time == old_timeout->fin_time && id < old_timeout->index)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Mark the timeout active, and insert it into the active list.\n\t */\n\tall_timeouts[id].indicator = false;\n\tall_timeouts[id].start_time = now;\n\tall_timeouts[id].fin_time = fin_time;\n\n\tinsert_timeout(id, i);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static timeout_params all_timeouts[MAX_TIMEOUTS];",
            "static bool all_timeouts_initialized = false;",
            "static volatile int num_active_timeouts = 0;",
            "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic timeout_params all_timeouts[MAX_TIMEOUTS];\nstatic bool all_timeouts_initialized = false;\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\n\nstatic void\nenable_timeout(TimeoutId id, TimestampTz now, TimestampTz fin_time)\n{\n\tint\t\t\ti;\n\n\t/* Assert request is sane */\n\tAssert(all_timeouts_initialized);\n\tAssert(all_timeouts[id].timeout_handler != NULL);\n\n\t/*\n\t * If this timeout was already active, momentarily disable it.  We\n\t * interpret the call as a directive to reschedule the timeout.\n\t */\n\ti = find_active_timeout(id);\n\tif (i >= 0)\n\t\tremove_timeout_index(i);\n\n\t/*\n\t * Find out the index where to insert the new timeout.  We sort by\n\t * fin_time, and for equal fin_time by priority.\n\t */\n\tfor (i = 0; i < num_active_timeouts; i++)\n\t{\n\t\ttimeout_params *old_timeout = active_timeouts[i];\n\n\t\tif (fin_time < old_timeout->fin_time)\n\t\t\tbreak;\n\t\tif (fin_time == old_timeout->fin_time && id < old_timeout->index)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Mark the timeout active, and insert it into the active list.\n\t */\n\tall_timeouts[id].indicator = false;\n\tall_timeouts[id].start_time = now;\n\tall_timeouts[id].fin_time = fin_time;\n\n\tinsert_timeout(id, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentTimestamp",
          "args": [],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "GetCurrentTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1569-1582",
          "snippet": "TimestampTz\nGetCurrentTimestamp(void)\n{\n\tTimestampTz result;\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, NULL);\n\n\tresult = (TimestampTz) tp.tv_sec -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult = (result * USECS_PER_SEC) + tp.tv_usec;\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimestampTz\nGetCurrentTimestamp(void)\n{\n\tTimestampTz result;\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, NULL);\n\n\tresult = (TimestampTz) tp.tv_sec -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult = (result * USECS_PER_SEC) + tp.tv_usec;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_alarm",
          "args": [],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nvoid\nenable_timeout_at(TimeoutId id, TimestampTz fin_time)\n{\n\tTimestampTz now;\n\n\t/* Disable timeout interrupts for safety. */\n\tdisable_alarm();\n\n\t/* Queue the timeout at the appropriate time. */\n\tnow = GetCurrentTimestamp();\n\tenable_timeout(id, now, fin_time);\n\n\t/* Set the timer interrupt. */\n\tschedule_alarm(now);\n}"
  },
  {
    "function_name": "enable_timeout_after",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
    "lines": "427-443",
    "snippet": "void\nenable_timeout_after(TimeoutId id, int delay_ms)\n{\n\tTimestampTz now;\n\tTimestampTz fin_time;\n\n\t/* Disable timeout interrupts for safety. */\n\tdisable_alarm();\n\n\t/* Queue the timeout at the appropriate time. */\n\tnow = GetCurrentTimestamp();\n\tfin_time = TimestampTzPlusMilliseconds(now, delay_ms);\n\tenable_timeout(id, now, fin_time);\n\n\t/* Set the timer interrupt. */\n\tschedule_alarm(now);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"storage/proc.h\"",
      "#include \"miscadmin.h\"",
      "#include <sys/time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_alarm",
          "args": [
            "now"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "184-245",
          "snippet": "static void\nschedule_alarm(TimestampTz now)\n{\n\tif (num_active_timeouts > 0)\n\t{\n\t\tstruct itimerval timeval;\n\t\tlong\t\tsecs;\n\t\tint\t\t\tusecs;\n\n\t\tMemSet(&timeval, 0, sizeof(struct itimerval));\n\n\t\t/* Get the time remaining till the nearest pending timeout */\n\t\tTimestampDifference(now, active_timeouts[0]->fin_time,\n\t\t\t\t\t\t\t&secs, &usecs);\n\n\t\t/*\n\t\t * It's possible that the difference is less than a microsecond;\n\t\t * ensure we don't cancel, rather than set, the interrupt.\n\t\t */\n\t\tif (secs == 0 && usecs == 0)\n\t\t\tusecs = 1;\n\n\t\ttimeval.it_value.tv_sec = secs;\n\t\ttimeval.it_value.tv_usec = usecs;\n\n\t\t/*\n\t\t * We must enable the signal handler before calling setitimer(); if we\n\t\t * did it in the other order, we'd have a race condition wherein the\n\t\t * interrupt could occur before we can set alarm_enabled, so that the\n\t\t * signal handler would fail to do anything.\n\t\t *\n\t\t * Because we didn't bother to reset the timer in disable_alarm(),\n\t\t * it's possible that a previously-set interrupt will fire between\n\t\t * enable_alarm() and setitimer().  This is safe, however.  There are\n\t\t * two possible outcomes:\n\t\t *\n\t\t * 1. The signal handler finds nothing to do (because the nearest\n\t\t * timeout event is still in the future).  It will re-set the timer\n\t\t * and return.  Then we'll overwrite the timer value with a new one.\n\t\t * This will mean that the timer fires a little later than we\n\t\t * intended, but only by the amount of time it takes for the signal\n\t\t * handler to do nothing useful, which shouldn't be much.\n\t\t *\n\t\t * 2. The signal handler executes and removes one or more timeout\n\t\t * events.  When it returns, either the queue is now empty or the\n\t\t * frontmost event is later than the one we looked at above.  So we'll\n\t\t * overwrite the timer value with one that is too soon (plus or minus\n\t\t * the signal handler's execution time), causing a useless interrupt\n\t\t * to occur.  But the handler will then re-set the timer and\n\t\t * everything will still work as expected.\n\t\t *\n\t\t * Since these cases are of very low probability (the window here\n\t\t * being quite narrow), it's not worth adding cycles to the mainline\n\t\t * code to prevent occasional wasted interrupts.\n\t\t */\n\t\tenable_alarm();\n\n\t\t/* Set the alarm timer */\n\t\tif (setitimer(ITIMER_REAL, &timeval, NULL) != 0)\n\t\t\telog(FATAL, \"could not enable SIGALRM timer: %m\");\n\t}\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile int num_active_timeouts = 0;",
            "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];",
            "static volatile sig_atomic_t alarm_enabled = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\nstatic volatile sig_atomic_t alarm_enabled = false;\n\nstatic void\nschedule_alarm(TimestampTz now)\n{\n\tif (num_active_timeouts > 0)\n\t{\n\t\tstruct itimerval timeval;\n\t\tlong\t\tsecs;\n\t\tint\t\t\tusecs;\n\n\t\tMemSet(&timeval, 0, sizeof(struct itimerval));\n\n\t\t/* Get the time remaining till the nearest pending timeout */\n\t\tTimestampDifference(now, active_timeouts[0]->fin_time,\n\t\t\t\t\t\t\t&secs, &usecs);\n\n\t\t/*\n\t\t * It's possible that the difference is less than a microsecond;\n\t\t * ensure we don't cancel, rather than set, the interrupt.\n\t\t */\n\t\tif (secs == 0 && usecs == 0)\n\t\t\tusecs = 1;\n\n\t\ttimeval.it_value.tv_sec = secs;\n\t\ttimeval.it_value.tv_usec = usecs;\n\n\t\t/*\n\t\t * We must enable the signal handler before calling setitimer(); if we\n\t\t * did it in the other order, we'd have a race condition wherein the\n\t\t * interrupt could occur before we can set alarm_enabled, so that the\n\t\t * signal handler would fail to do anything.\n\t\t *\n\t\t * Because we didn't bother to reset the timer in disable_alarm(),\n\t\t * it's possible that a previously-set interrupt will fire between\n\t\t * enable_alarm() and setitimer().  This is safe, however.  There are\n\t\t * two possible outcomes:\n\t\t *\n\t\t * 1. The signal handler finds nothing to do (because the nearest\n\t\t * timeout event is still in the future).  It will re-set the timer\n\t\t * and return.  Then we'll overwrite the timer value with a new one.\n\t\t * This will mean that the timer fires a little later than we\n\t\t * intended, but only by the amount of time it takes for the signal\n\t\t * handler to do nothing useful, which shouldn't be much.\n\t\t *\n\t\t * 2. The signal handler executes and removes one or more timeout\n\t\t * events.  When it returns, either the queue is now empty or the\n\t\t * frontmost event is later than the one we looked at above.  So we'll\n\t\t * overwrite the timer value with one that is too soon (plus or minus\n\t\t * the signal handler's execution time), causing a useless interrupt\n\t\t * to occur.  But the handler will then re-set the timer and\n\t\t * everything will still work as expected.\n\t\t *\n\t\t * Since these cases are of very low probability (the window here\n\t\t * being quite narrow), it's not worth adding cycles to the mainline\n\t\t * code to prevent occasional wasted interrupts.\n\t\t */\n\t\tenable_alarm();\n\n\t\t/* Set the alarm timer */\n\t\tif (setitimer(ITIMER_REAL, &timeval, NULL) != 0)\n\t\t\telog(FATAL, \"could not enable SIGALRM timer: %m\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "enable_timeout",
          "args": [
            "id",
            "now",
            "fin_time"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "enable_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "137-176",
          "snippet": "static void\nenable_timeout(TimeoutId id, TimestampTz now, TimestampTz fin_time)\n{\n\tint\t\t\ti;\n\n\t/* Assert request is sane */\n\tAssert(all_timeouts_initialized);\n\tAssert(all_timeouts[id].timeout_handler != NULL);\n\n\t/*\n\t * If this timeout was already active, momentarily disable it.  We\n\t * interpret the call as a directive to reschedule the timeout.\n\t */\n\ti = find_active_timeout(id);\n\tif (i >= 0)\n\t\tremove_timeout_index(i);\n\n\t/*\n\t * Find out the index where to insert the new timeout.  We sort by\n\t * fin_time, and for equal fin_time by priority.\n\t */\n\tfor (i = 0; i < num_active_timeouts; i++)\n\t{\n\t\ttimeout_params *old_timeout = active_timeouts[i];\n\n\t\tif (fin_time < old_timeout->fin_time)\n\t\t\tbreak;\n\t\tif (fin_time == old_timeout->fin_time && id < old_timeout->index)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Mark the timeout active, and insert it into the active list.\n\t */\n\tall_timeouts[id].indicator = false;\n\tall_timeouts[id].start_time = now;\n\tall_timeouts[id].fin_time = fin_time;\n\n\tinsert_timeout(id, i);\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static timeout_params all_timeouts[MAX_TIMEOUTS];",
            "static bool all_timeouts_initialized = false;",
            "static volatile int num_active_timeouts = 0;",
            "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic timeout_params all_timeouts[MAX_TIMEOUTS];\nstatic bool all_timeouts_initialized = false;\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\n\nstatic void\nenable_timeout(TimeoutId id, TimestampTz now, TimestampTz fin_time)\n{\n\tint\t\t\ti;\n\n\t/* Assert request is sane */\n\tAssert(all_timeouts_initialized);\n\tAssert(all_timeouts[id].timeout_handler != NULL);\n\n\t/*\n\t * If this timeout was already active, momentarily disable it.  We\n\t * interpret the call as a directive to reschedule the timeout.\n\t */\n\ti = find_active_timeout(id);\n\tif (i >= 0)\n\t\tremove_timeout_index(i);\n\n\t/*\n\t * Find out the index where to insert the new timeout.  We sort by\n\t * fin_time, and for equal fin_time by priority.\n\t */\n\tfor (i = 0; i < num_active_timeouts; i++)\n\t{\n\t\ttimeout_params *old_timeout = active_timeouts[i];\n\n\t\tif (fin_time < old_timeout->fin_time)\n\t\t\tbreak;\n\t\tif (fin_time == old_timeout->fin_time && id < old_timeout->index)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Mark the timeout active, and insert it into the active list.\n\t */\n\tall_timeouts[id].indicator = false;\n\tall_timeouts[id].start_time = now;\n\tall_timeouts[id].fin_time = fin_time;\n\n\tinsert_timeout(id, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TimestampTzPlusMilliseconds",
          "args": [
            "now",
            "delay_ms"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentTimestamp",
          "args": [],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "GetCurrentTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1569-1582",
          "snippet": "TimestampTz\nGetCurrentTimestamp(void)\n{\n\tTimestampTz result;\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, NULL);\n\n\tresult = (TimestampTz) tp.tv_sec -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult = (result * USECS_PER_SEC) + tp.tv_usec;\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimestampTz\nGetCurrentTimestamp(void)\n{\n\tTimestampTz result;\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, NULL);\n\n\tresult = (TimestampTz) tp.tv_sec -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult = (result * USECS_PER_SEC) + tp.tv_usec;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_alarm",
          "args": [],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nvoid\nenable_timeout_after(TimeoutId id, int delay_ms)\n{\n\tTimestampTz now;\n\tTimestampTz fin_time;\n\n\t/* Disable timeout interrupts for safety. */\n\tdisable_alarm();\n\n\t/* Queue the timeout at the appropriate time. */\n\tnow = GetCurrentTimestamp();\n\tfin_time = TimestampTzPlusMilliseconds(now, delay_ms);\n\tenable_timeout(id, now, fin_time);\n\n\t/* Set the timer interrupt. */\n\tschedule_alarm(now);\n}"
  },
  {
    "function_name": "reschedule_timeouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
    "lines": "407-420",
    "snippet": "void\nreschedule_timeouts(void)\n{\n\t/* For flexibility, allow this to be called before we're initialized. */\n\tif (!all_timeouts_initialized)\n\t\treturn;\n\n\t/* Disable timeout interrupts for safety. */\n\tdisable_alarm();\n\n\t/* Reschedule the interrupt, if any timeouts remain active. */\n\tif (num_active_timeouts > 0)\n\t\tschedule_alarm(GetCurrentTimestamp());\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"storage/proc.h\"",
      "#include \"miscadmin.h\"",
      "#include <sys/time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool all_timeouts_initialized = false;",
      "static volatile int num_active_timeouts = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_alarm",
          "args": [
            "GetCurrentTimestamp()"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "184-245",
          "snippet": "static void\nschedule_alarm(TimestampTz now)\n{\n\tif (num_active_timeouts > 0)\n\t{\n\t\tstruct itimerval timeval;\n\t\tlong\t\tsecs;\n\t\tint\t\t\tusecs;\n\n\t\tMemSet(&timeval, 0, sizeof(struct itimerval));\n\n\t\t/* Get the time remaining till the nearest pending timeout */\n\t\tTimestampDifference(now, active_timeouts[0]->fin_time,\n\t\t\t\t\t\t\t&secs, &usecs);\n\n\t\t/*\n\t\t * It's possible that the difference is less than a microsecond;\n\t\t * ensure we don't cancel, rather than set, the interrupt.\n\t\t */\n\t\tif (secs == 0 && usecs == 0)\n\t\t\tusecs = 1;\n\n\t\ttimeval.it_value.tv_sec = secs;\n\t\ttimeval.it_value.tv_usec = usecs;\n\n\t\t/*\n\t\t * We must enable the signal handler before calling setitimer(); if we\n\t\t * did it in the other order, we'd have a race condition wherein the\n\t\t * interrupt could occur before we can set alarm_enabled, so that the\n\t\t * signal handler would fail to do anything.\n\t\t *\n\t\t * Because we didn't bother to reset the timer in disable_alarm(),\n\t\t * it's possible that a previously-set interrupt will fire between\n\t\t * enable_alarm() and setitimer().  This is safe, however.  There are\n\t\t * two possible outcomes:\n\t\t *\n\t\t * 1. The signal handler finds nothing to do (because the nearest\n\t\t * timeout event is still in the future).  It will re-set the timer\n\t\t * and return.  Then we'll overwrite the timer value with a new one.\n\t\t * This will mean that the timer fires a little later than we\n\t\t * intended, but only by the amount of time it takes for the signal\n\t\t * handler to do nothing useful, which shouldn't be much.\n\t\t *\n\t\t * 2. The signal handler executes and removes one or more timeout\n\t\t * events.  When it returns, either the queue is now empty or the\n\t\t * frontmost event is later than the one we looked at above.  So we'll\n\t\t * overwrite the timer value with one that is too soon (plus or minus\n\t\t * the signal handler's execution time), causing a useless interrupt\n\t\t * to occur.  But the handler will then re-set the timer and\n\t\t * everything will still work as expected.\n\t\t *\n\t\t * Since these cases are of very low probability (the window here\n\t\t * being quite narrow), it's not worth adding cycles to the mainline\n\t\t * code to prevent occasional wasted interrupts.\n\t\t */\n\t\tenable_alarm();\n\n\t\t/* Set the alarm timer */\n\t\tif (setitimer(ITIMER_REAL, &timeval, NULL) != 0)\n\t\t\telog(FATAL, \"could not enable SIGALRM timer: %m\");\n\t}\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile int num_active_timeouts = 0;",
            "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];",
            "static volatile sig_atomic_t alarm_enabled = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\nstatic volatile sig_atomic_t alarm_enabled = false;\n\nstatic void\nschedule_alarm(TimestampTz now)\n{\n\tif (num_active_timeouts > 0)\n\t{\n\t\tstruct itimerval timeval;\n\t\tlong\t\tsecs;\n\t\tint\t\t\tusecs;\n\n\t\tMemSet(&timeval, 0, sizeof(struct itimerval));\n\n\t\t/* Get the time remaining till the nearest pending timeout */\n\t\tTimestampDifference(now, active_timeouts[0]->fin_time,\n\t\t\t\t\t\t\t&secs, &usecs);\n\n\t\t/*\n\t\t * It's possible that the difference is less than a microsecond;\n\t\t * ensure we don't cancel, rather than set, the interrupt.\n\t\t */\n\t\tif (secs == 0 && usecs == 0)\n\t\t\tusecs = 1;\n\n\t\ttimeval.it_value.tv_sec = secs;\n\t\ttimeval.it_value.tv_usec = usecs;\n\n\t\t/*\n\t\t * We must enable the signal handler before calling setitimer(); if we\n\t\t * did it in the other order, we'd have a race condition wherein the\n\t\t * interrupt could occur before we can set alarm_enabled, so that the\n\t\t * signal handler would fail to do anything.\n\t\t *\n\t\t * Because we didn't bother to reset the timer in disable_alarm(),\n\t\t * it's possible that a previously-set interrupt will fire between\n\t\t * enable_alarm() and setitimer().  This is safe, however.  There are\n\t\t * two possible outcomes:\n\t\t *\n\t\t * 1. The signal handler finds nothing to do (because the nearest\n\t\t * timeout event is still in the future).  It will re-set the timer\n\t\t * and return.  Then we'll overwrite the timer value with a new one.\n\t\t * This will mean that the timer fires a little later than we\n\t\t * intended, but only by the amount of time it takes for the signal\n\t\t * handler to do nothing useful, which shouldn't be much.\n\t\t *\n\t\t * 2. The signal handler executes and removes one or more timeout\n\t\t * events.  When it returns, either the queue is now empty or the\n\t\t * frontmost event is later than the one we looked at above.  So we'll\n\t\t * overwrite the timer value with one that is too soon (plus or minus\n\t\t * the signal handler's execution time), causing a useless interrupt\n\t\t * to occur.  But the handler will then re-set the timer and\n\t\t * everything will still work as expected.\n\t\t *\n\t\t * Since these cases are of very low probability (the window here\n\t\t * being quite narrow), it's not worth adding cycles to the mainline\n\t\t * code to prevent occasional wasted interrupts.\n\t\t */\n\t\tenable_alarm();\n\n\t\t/* Set the alarm timer */\n\t\tif (setitimer(ITIMER_REAL, &timeval, NULL) != 0)\n\t\t\telog(FATAL, \"could not enable SIGALRM timer: %m\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentTimestamp",
          "args": [],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "GetCurrentTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1569-1582",
          "snippet": "TimestampTz\nGetCurrentTimestamp(void)\n{\n\tTimestampTz result;\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, NULL);\n\n\tresult = (TimestampTz) tp.tv_sec -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult = (result * USECS_PER_SEC) + tp.tv_usec;\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimestampTz\nGetCurrentTimestamp(void)\n{\n\tTimestampTz result;\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, NULL);\n\n\tresult = (TimestampTz) tp.tv_sec -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult = (result * USECS_PER_SEC) + tp.tv_usec;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_alarm",
          "args": [],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic bool all_timeouts_initialized = false;\nstatic volatile int num_active_timeouts = 0;\n\nvoid\nreschedule_timeouts(void)\n{\n\t/* For flexibility, allow this to be called before we're initialized. */\n\tif (!all_timeouts_initialized)\n\t\treturn;\n\n\t/* Disable timeout interrupts for safety. */\n\tdisable_alarm();\n\n\t/* Reschedule the interrupt, if any timeouts remain active. */\n\tif (num_active_timeouts > 0)\n\t\tschedule_alarm(GetCurrentTimestamp());\n}"
  },
  {
    "function_name": "RegisterTimeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
    "lines": "372-396",
    "snippet": "TimeoutId\nRegisterTimeout(TimeoutId id, timeout_handler_proc handler)\n{\n\tAssert(all_timeouts_initialized);\n\n\t/* There's no need to disable the signal handler here. */\n\n\tif (id >= USER_TIMEOUT)\n\t{\n\t\t/* Allocate a user-defined timeout reason */\n\t\tfor (id = USER_TIMEOUT; id < MAX_TIMEOUTS; id++)\n\t\t\tif (all_timeouts[id].timeout_handler == NULL)\n\t\t\t\tbreak;\n\t\tif (id >= MAX_TIMEOUTS)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"cannot add more timeout reasons\")));\n\t}\n\n\tAssert(all_timeouts[id].timeout_handler == NULL);\n\n\tall_timeouts[id].timeout_handler = handler;\n\n\treturn id;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"storage/proc.h\"",
      "#include \"miscadmin.h\"",
      "#include <sys/time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static timeout_params all_timeouts[MAX_TIMEOUTS];",
      "static bool all_timeouts_initialized = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "all_timeouts[id].timeout_handler == NULL"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"cannot add more timeout reasons\"))"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot add more timeout reasons\""
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_CONFIGURATION_LIMIT_EXCEEDED"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "GUC_check_errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/guc.c",
          "lines": "10064-10068",
          "snippet": "void\nGUC_check_errcode(int sqlerrcode)\n{\n\tGUC_check_errcode_value = sqlerrcode;\n}",
          "includes": [
            "#include \"guc-file.c\"",
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/tzparser.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/plancache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc_tables.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_cache.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/large_object.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/standby.h\"",
            "#include \"storage/dsm_impl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"replication/walreceiver.h\"",
            "#include \"replication/syncrep.h\"",
            "#include \"replication/slot.h\"",
            "#include \"replication/logicallauncher.h\"",
            "#include \"postmaster/walwriter.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/bgwriter.h\"",
            "#include \"postmaster/bgworker_internals.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"parser/parse_expr.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/geqo.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"jit/jit.h\"",
            "#include \"funcapi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/variable.h\"",
            "#include \"commands/vacuum.h\"",
            "#include \"commands/user.h\"",
            "#include \"commands/prepare.h\"",
            "#include \"commands/async.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/twophase.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/rmgr.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/commit_ts.h\"",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tGUC_check_errcode_value;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"guc-file.c\"\n#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/tzparser.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/plancache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc_tables.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_cache.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/predicate.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/large_object.h\"\n#include \"storage/fd.h\"\n#include \"storage/standby.h\"\n#include \"storage/dsm_impl.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"replication/walreceiver.h\"\n#include \"replication/syncrep.h\"\n#include \"replication/slot.h\"\n#include \"replication/logicallauncher.h\"\n#include \"postmaster/walwriter.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/bgwriter.h\"\n#include \"postmaster/bgworker_internals.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_type.h\"\n#include \"parser/parse_expr.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/geqo.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"libpq/auth.h\"\n#include \"jit/jit.h\"\n#include \"funcapi.h\"\n#include \"commands/trigger.h\"\n#include \"commands/variable.h\"\n#include \"commands/vacuum.h\"\n#include \"commands/user.h\"\n#include \"commands/prepare.h\"\n#include \"commands/async.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/xact.h\"\n#include \"access/twophase.h\"\n#include \"access/transam.h\"\n#include \"access/rmgr.h\"\n#include \"access/gin.h\"\n#include \"access/commit_ts.h\"\n#include <syslog.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tGUC_check_errcode_value;\n\nvoid\nGUC_check_errcode(int sqlerrcode)\n{\n\tGUC_check_errcode_value = sqlerrcode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "all_timeouts_initialized"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic timeout_params all_timeouts[MAX_TIMEOUTS];\nstatic bool all_timeouts_initialized = false;\n\nTimeoutId\nRegisterTimeout(TimeoutId id, timeout_handler_proc handler)\n{\n\tAssert(all_timeouts_initialized);\n\n\t/* There's no need to disable the signal handler here. */\n\n\tif (id >= USER_TIMEOUT)\n\t{\n\t\t/* Allocate a user-defined timeout reason */\n\t\tfor (id = USER_TIMEOUT; id < MAX_TIMEOUTS; id++)\n\t\t\tif (all_timeouts[id].timeout_handler == NULL)\n\t\t\t\tbreak;\n\t\tif (id >= MAX_TIMEOUTS)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"cannot add more timeout reasons\")));\n\t}\n\n\tAssert(all_timeouts[id].timeout_handler == NULL);\n\n\tall_timeouts[id].timeout_handler = handler;\n\n\treturn id;\n}"
  },
  {
    "function_name": "InitializeTimeouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
    "lines": "339-362",
    "snippet": "void\nInitializeTimeouts(void)\n{\n\tint\t\t\ti;\n\n\t/* Initialize, or re-initialize, all local state */\n\tdisable_alarm();\n\n\tnum_active_timeouts = 0;\n\n\tfor (i = 0; i < MAX_TIMEOUTS; i++)\n\t{\n\t\tall_timeouts[i].index = i;\n\t\tall_timeouts[i].indicator = false;\n\t\tall_timeouts[i].timeout_handler = NULL;\n\t\tall_timeouts[i].start_time = 0;\n\t\tall_timeouts[i].fin_time = 0;\n\t}\n\n\tall_timeouts_initialized = true;\n\n\t/* Now establish the signal handler */\n\tpqsignal(SIGALRM, handle_sig_alarm);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"storage/proc.h\"",
      "#include \"miscadmin.h\"",
      "#include <sys/time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static timeout_params all_timeouts[MAX_TIMEOUTS];",
      "static bool all_timeouts_initialized = false;",
      "static volatile int num_active_timeouts = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pqsignal",
          "args": [
            "SIGALRM",
            "handle_sig_alarm"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_alarm",
          "args": [],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic timeout_params all_timeouts[MAX_TIMEOUTS];\nstatic bool all_timeouts_initialized = false;\nstatic volatile int num_active_timeouts = 0;\n\nvoid\nInitializeTimeouts(void)\n{\n\tint\t\t\ti;\n\n\t/* Initialize, or re-initialize, all local state */\n\tdisable_alarm();\n\n\tnum_active_timeouts = 0;\n\n\tfor (i = 0; i < MAX_TIMEOUTS; i++)\n\t{\n\t\tall_timeouts[i].index = i;\n\t\tall_timeouts[i].indicator = false;\n\t\tall_timeouts[i].timeout_handler = NULL;\n\t\tall_timeouts[i].start_time = 0;\n\t\tall_timeouts[i].fin_time = 0;\n\t}\n\n\tall_timeouts_initialized = true;\n\n\t/* Now establish the signal handler */\n\tpqsignal(SIGALRM, handle_sig_alarm);\n}"
  },
  {
    "function_name": "handle_sig_alarm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
    "lines": "258-323",
    "snippet": "static void\nhandle_sig_alarm(SIGNAL_ARGS)\n{\n\tint\t\t\tsave_errno = errno;\n\n\t/*\n\t * Bump the holdoff counter, to make sure nothing we call will process\n\t * interrupts directly. No timeout handler should do that, but these\n\t * failures are hard to debug, so better be sure.\n\t */\n\tHOLD_INTERRUPTS();\n\n\t/*\n\t * SIGALRM is always cause for waking anything waiting on the process\n\t * latch.\n\t */\n\tSetLatch(MyLatch);\n\n\t/*\n\t * Fire any pending timeouts, but only if we're enabled to do so.\n\t */\n\tif (alarm_enabled)\n\t{\n\t\t/*\n\t\t * Disable alarms, just in case this platform allows signal handlers\n\t\t * to interrupt themselves.  schedule_alarm() will re-enable if\n\t\t * appropriate.\n\t\t */\n\t\tdisable_alarm();\n\n\t\tif (num_active_timeouts > 0)\n\t\t{\n\t\t\tTimestampTz now = GetCurrentTimestamp();\n\n\t\t\t/* While the first pending timeout has been reached ... */\n\t\t\twhile (num_active_timeouts > 0 &&\n\t\t\t\t   now >= active_timeouts[0]->fin_time)\n\t\t\t{\n\t\t\t\ttimeout_params *this_timeout = active_timeouts[0];\n\n\t\t\t\t/* Remove it from the active list */\n\t\t\t\tremove_timeout_index(0);\n\n\t\t\t\t/* Mark it as fired */\n\t\t\t\tthis_timeout->indicator = true;\n\n\t\t\t\t/* And call its handler function */\n\t\t\t\tthis_timeout->timeout_handler();\n\n\t\t\t\t/*\n\t\t\t\t * The handler might not take negligible time (CheckDeadLock\n\t\t\t\t * for instance isn't too cheap), so let's update our idea of\n\t\t\t\t * \"now\" after each one.\n\t\t\t\t */\n\t\t\t\tnow = GetCurrentTimestamp();\n\t\t\t}\n\n\t\t\t/* Done firing timeouts, so reschedule next interrupt if any */\n\t\t\tschedule_alarm(now);\n\t\t}\n\t}\n\n\tRESUME_INTERRUPTS();\n\n\terrno = save_errno;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"storage/proc.h\"",
      "#include \"miscadmin.h\"",
      "#include <sys/time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile int num_active_timeouts = 0;",
      "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];",
      "static volatile sig_atomic_t alarm_enabled = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RESUME_INTERRUPTS",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_alarm",
          "args": [
            "now"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_alarm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "184-245",
          "snippet": "static void\nschedule_alarm(TimestampTz now)\n{\n\tif (num_active_timeouts > 0)\n\t{\n\t\tstruct itimerval timeval;\n\t\tlong\t\tsecs;\n\t\tint\t\t\tusecs;\n\n\t\tMemSet(&timeval, 0, sizeof(struct itimerval));\n\n\t\t/* Get the time remaining till the nearest pending timeout */\n\t\tTimestampDifference(now, active_timeouts[0]->fin_time,\n\t\t\t\t\t\t\t&secs, &usecs);\n\n\t\t/*\n\t\t * It's possible that the difference is less than a microsecond;\n\t\t * ensure we don't cancel, rather than set, the interrupt.\n\t\t */\n\t\tif (secs == 0 && usecs == 0)\n\t\t\tusecs = 1;\n\n\t\ttimeval.it_value.tv_sec = secs;\n\t\ttimeval.it_value.tv_usec = usecs;\n\n\t\t/*\n\t\t * We must enable the signal handler before calling setitimer(); if we\n\t\t * did it in the other order, we'd have a race condition wherein the\n\t\t * interrupt could occur before we can set alarm_enabled, so that the\n\t\t * signal handler would fail to do anything.\n\t\t *\n\t\t * Because we didn't bother to reset the timer in disable_alarm(),\n\t\t * it's possible that a previously-set interrupt will fire between\n\t\t * enable_alarm() and setitimer().  This is safe, however.  There are\n\t\t * two possible outcomes:\n\t\t *\n\t\t * 1. The signal handler finds nothing to do (because the nearest\n\t\t * timeout event is still in the future).  It will re-set the timer\n\t\t * and return.  Then we'll overwrite the timer value with a new one.\n\t\t * This will mean that the timer fires a little later than we\n\t\t * intended, but only by the amount of time it takes for the signal\n\t\t * handler to do nothing useful, which shouldn't be much.\n\t\t *\n\t\t * 2. The signal handler executes and removes one or more timeout\n\t\t * events.  When it returns, either the queue is now empty or the\n\t\t * frontmost event is later than the one we looked at above.  So we'll\n\t\t * overwrite the timer value with one that is too soon (plus or minus\n\t\t * the signal handler's execution time), causing a useless interrupt\n\t\t * to occur.  But the handler will then re-set the timer and\n\t\t * everything will still work as expected.\n\t\t *\n\t\t * Since these cases are of very low probability (the window here\n\t\t * being quite narrow), it's not worth adding cycles to the mainline\n\t\t * code to prevent occasional wasted interrupts.\n\t\t */\n\t\tenable_alarm();\n\n\t\t/* Set the alarm timer */\n\t\tif (setitimer(ITIMER_REAL, &timeval, NULL) != 0)\n\t\t\telog(FATAL, \"could not enable SIGALRM timer: %m\");\n\t}\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile int num_active_timeouts = 0;",
            "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];",
            "static volatile sig_atomic_t alarm_enabled = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\nstatic volatile sig_atomic_t alarm_enabled = false;\n\nstatic void\nschedule_alarm(TimestampTz now)\n{\n\tif (num_active_timeouts > 0)\n\t{\n\t\tstruct itimerval timeval;\n\t\tlong\t\tsecs;\n\t\tint\t\t\tusecs;\n\n\t\tMemSet(&timeval, 0, sizeof(struct itimerval));\n\n\t\t/* Get the time remaining till the nearest pending timeout */\n\t\tTimestampDifference(now, active_timeouts[0]->fin_time,\n\t\t\t\t\t\t\t&secs, &usecs);\n\n\t\t/*\n\t\t * It's possible that the difference is less than a microsecond;\n\t\t * ensure we don't cancel, rather than set, the interrupt.\n\t\t */\n\t\tif (secs == 0 && usecs == 0)\n\t\t\tusecs = 1;\n\n\t\ttimeval.it_value.tv_sec = secs;\n\t\ttimeval.it_value.tv_usec = usecs;\n\n\t\t/*\n\t\t * We must enable the signal handler before calling setitimer(); if we\n\t\t * did it in the other order, we'd have a race condition wherein the\n\t\t * interrupt could occur before we can set alarm_enabled, so that the\n\t\t * signal handler would fail to do anything.\n\t\t *\n\t\t * Because we didn't bother to reset the timer in disable_alarm(),\n\t\t * it's possible that a previously-set interrupt will fire between\n\t\t * enable_alarm() and setitimer().  This is safe, however.  There are\n\t\t * two possible outcomes:\n\t\t *\n\t\t * 1. The signal handler finds nothing to do (because the nearest\n\t\t * timeout event is still in the future).  It will re-set the timer\n\t\t * and return.  Then we'll overwrite the timer value with a new one.\n\t\t * This will mean that the timer fires a little later than we\n\t\t * intended, but only by the amount of time it takes for the signal\n\t\t * handler to do nothing useful, which shouldn't be much.\n\t\t *\n\t\t * 2. The signal handler executes and removes one or more timeout\n\t\t * events.  When it returns, either the queue is now empty or the\n\t\t * frontmost event is later than the one we looked at above.  So we'll\n\t\t * overwrite the timer value with one that is too soon (plus or minus\n\t\t * the signal handler's execution time), causing a useless interrupt\n\t\t * to occur.  But the handler will then re-set the timer and\n\t\t * everything will still work as expected.\n\t\t *\n\t\t * Since these cases are of very low probability (the window here\n\t\t * being quite narrow), it's not worth adding cycles to the mainline\n\t\t * code to prevent occasional wasted interrupts.\n\t\t */\n\t\tenable_alarm();\n\n\t\t/* Set the alarm timer */\n\t\tif (setitimer(ITIMER_REAL, &timeval, NULL) != 0)\n\t\t\telog(FATAL, \"could not enable SIGALRM timer: %m\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentTimestamp",
          "args": [],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "GetCurrentTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1569-1582",
          "snippet": "TimestampTz\nGetCurrentTimestamp(void)\n{\n\tTimestampTz result;\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, NULL);\n\n\tresult = (TimestampTz) tp.tv_sec -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult = (result * USECS_PER_SEC) + tp.tv_usec;\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nTimestampTz\nGetCurrentTimestamp(void)\n{\n\tTimestampTz result;\n\tstruct timeval tp;\n\n\tgettimeofday(&tp, NULL);\n\n\tresult = (TimestampTz) tp.tv_sec -\n\t\t((POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY);\n\tresult = (result * USECS_PER_SEC) + tp.tv_usec;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_timeout->timeout_handler",
          "args": [],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_timeout_index",
          "args": [
            "0"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "remove_timeout_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "119-132",
          "snippet": "static void\nremove_timeout_index(int index)\n{\n\tint\t\t\ti;\n\n\tif (index < 0 || index >= num_active_timeouts)\n\t\telog(FATAL, \"timeout index %d out of range 0..%d\", index,\n\t\t\t num_active_timeouts - 1);\n\n\tfor (i = index + 1; i < num_active_timeouts; i++)\n\t\tactive_timeouts[i - 1] = active_timeouts[i];\n\n\tnum_active_timeouts--;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile int num_active_timeouts = 0;",
            "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\n\nstatic void\nremove_timeout_index(int index)\n{\n\tint\t\t\ti;\n\n\tif (index < 0 || index >= num_active_timeouts)\n\t\telog(FATAL, \"timeout index %d out of range 0..%d\", index,\n\t\t\t num_active_timeouts - 1);\n\n\tfor (i = index + 1; i < num_active_timeouts; i++)\n\t\tactive_timeouts[i - 1] = active_timeouts[i];\n\n\tnum_active_timeouts--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_alarm",
          "args": [],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetLatch",
          "args": [
            "MyLatch"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HOLD_INTERRUPTS",
          "args": [],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\nstatic volatile sig_atomic_t alarm_enabled = false;\n\nstatic void\nhandle_sig_alarm(SIGNAL_ARGS)\n{\n\tint\t\t\tsave_errno = errno;\n\n\t/*\n\t * Bump the holdoff counter, to make sure nothing we call will process\n\t * interrupts directly. No timeout handler should do that, but these\n\t * failures are hard to debug, so better be sure.\n\t */\n\tHOLD_INTERRUPTS();\n\n\t/*\n\t * SIGALRM is always cause for waking anything waiting on the process\n\t * latch.\n\t */\n\tSetLatch(MyLatch);\n\n\t/*\n\t * Fire any pending timeouts, but only if we're enabled to do so.\n\t */\n\tif (alarm_enabled)\n\t{\n\t\t/*\n\t\t * Disable alarms, just in case this platform allows signal handlers\n\t\t * to interrupt themselves.  schedule_alarm() will re-enable if\n\t\t * appropriate.\n\t\t */\n\t\tdisable_alarm();\n\n\t\tif (num_active_timeouts > 0)\n\t\t{\n\t\t\tTimestampTz now = GetCurrentTimestamp();\n\n\t\t\t/* While the first pending timeout has been reached ... */\n\t\t\twhile (num_active_timeouts > 0 &&\n\t\t\t\t   now >= active_timeouts[0]->fin_time)\n\t\t\t{\n\t\t\t\ttimeout_params *this_timeout = active_timeouts[0];\n\n\t\t\t\t/* Remove it from the active list */\n\t\t\t\tremove_timeout_index(0);\n\n\t\t\t\t/* Mark it as fired */\n\t\t\t\tthis_timeout->indicator = true;\n\n\t\t\t\t/* And call its handler function */\n\t\t\t\tthis_timeout->timeout_handler();\n\n\t\t\t\t/*\n\t\t\t\t * The handler might not take negligible time (CheckDeadLock\n\t\t\t\t * for instance isn't too cheap), so let's update our idea of\n\t\t\t\t * \"now\" after each one.\n\t\t\t\t */\n\t\t\t\tnow = GetCurrentTimestamp();\n\t\t\t}\n\n\t\t\t/* Done firing timeouts, so reschedule next interrupt if any */\n\t\t\tschedule_alarm(now);\n\t\t}\n\t}\n\n\tRESUME_INTERRUPTS();\n\n\terrno = save_errno;\n}"
  },
  {
    "function_name": "schedule_alarm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
    "lines": "184-245",
    "snippet": "static void\nschedule_alarm(TimestampTz now)\n{\n\tif (num_active_timeouts > 0)\n\t{\n\t\tstruct itimerval timeval;\n\t\tlong\t\tsecs;\n\t\tint\t\t\tusecs;\n\n\t\tMemSet(&timeval, 0, sizeof(struct itimerval));\n\n\t\t/* Get the time remaining till the nearest pending timeout */\n\t\tTimestampDifference(now, active_timeouts[0]->fin_time,\n\t\t\t\t\t\t\t&secs, &usecs);\n\n\t\t/*\n\t\t * It's possible that the difference is less than a microsecond;\n\t\t * ensure we don't cancel, rather than set, the interrupt.\n\t\t */\n\t\tif (secs == 0 && usecs == 0)\n\t\t\tusecs = 1;\n\n\t\ttimeval.it_value.tv_sec = secs;\n\t\ttimeval.it_value.tv_usec = usecs;\n\n\t\t/*\n\t\t * We must enable the signal handler before calling setitimer(); if we\n\t\t * did it in the other order, we'd have a race condition wherein the\n\t\t * interrupt could occur before we can set alarm_enabled, so that the\n\t\t * signal handler would fail to do anything.\n\t\t *\n\t\t * Because we didn't bother to reset the timer in disable_alarm(),\n\t\t * it's possible that a previously-set interrupt will fire between\n\t\t * enable_alarm() and setitimer().  This is safe, however.  There are\n\t\t * two possible outcomes:\n\t\t *\n\t\t * 1. The signal handler finds nothing to do (because the nearest\n\t\t * timeout event is still in the future).  It will re-set the timer\n\t\t * and return.  Then we'll overwrite the timer value with a new one.\n\t\t * This will mean that the timer fires a little later than we\n\t\t * intended, but only by the amount of time it takes for the signal\n\t\t * handler to do nothing useful, which shouldn't be much.\n\t\t *\n\t\t * 2. The signal handler executes and removes one or more timeout\n\t\t * events.  When it returns, either the queue is now empty or the\n\t\t * frontmost event is later than the one we looked at above.  So we'll\n\t\t * overwrite the timer value with one that is too soon (plus or minus\n\t\t * the signal handler's execution time), causing a useless interrupt\n\t\t * to occur.  But the handler will then re-set the timer and\n\t\t * everything will still work as expected.\n\t\t *\n\t\t * Since these cases are of very low probability (the window here\n\t\t * being quite narrow), it's not worth adding cycles to the mainline\n\t\t * code to prevent occasional wasted interrupts.\n\t\t */\n\t\tenable_alarm();\n\n\t\t/* Set the alarm timer */\n\t\tif (setitimer(ITIMER_REAL, &timeval, NULL) != 0)\n\t\t\telog(FATAL, \"could not enable SIGALRM timer: %m\");\n\t}\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"storage/proc.h\"",
      "#include \"miscadmin.h\"",
      "#include <sys/time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile int num_active_timeouts = 0;",
      "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];",
      "static volatile sig_atomic_t alarm_enabled = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"could not enable SIGALRM timer: %m\""
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setitimer",
          "args": [
            "ITIMER_REAL",
            "&timeval",
            "NULL"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enable_alarm",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimestampDifference",
          "args": [
            "now",
            "active_timeouts[0]->fin_time",
            "&secs",
            "&usecs"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "TimestampDifference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1623-1639",
          "snippet": "void\nTimestampDifference(TimestampTz start_time, TimestampTz stop_time,\n\t\t\t\t\tlong *secs, int *microsecs)\n{\n\tTimestampTz diff = stop_time - start_time;\n\n\tif (diff <= 0)\n\t{\n\t\t*secs = 0;\n\t\t*microsecs = 0;\n\t}\n\telse\n\t{\n\t\t*secs = (long) (diff / USECS_PER_SEC);\n\t\t*microsecs = (int) (diff % USECS_PER_SEC);\n\t}\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nTimestampDifference(TimestampTz start_time, TimestampTz stop_time,\n\t\t\t\t\tlong *secs, int *microsecs)\n{\n\tTimestampTz diff = stop_time - start_time;\n\n\tif (diff <= 0)\n\t{\n\t\t*secs = 0;\n\t\t*microsecs = 0;\n\t}\n\telse\n\t{\n\t\t*secs = (long) (diff / USECS_PER_SEC);\n\t\t*microsecs = (int) (diff % USECS_PER_SEC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&timeval",
            "0",
            "sizeof(struct itimerval)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\nstatic volatile sig_atomic_t alarm_enabled = false;\n\nstatic void\nschedule_alarm(TimestampTz now)\n{\n\tif (num_active_timeouts > 0)\n\t{\n\t\tstruct itimerval timeval;\n\t\tlong\t\tsecs;\n\t\tint\t\t\tusecs;\n\n\t\tMemSet(&timeval, 0, sizeof(struct itimerval));\n\n\t\t/* Get the time remaining till the nearest pending timeout */\n\t\tTimestampDifference(now, active_timeouts[0]->fin_time,\n\t\t\t\t\t\t\t&secs, &usecs);\n\n\t\t/*\n\t\t * It's possible that the difference is less than a microsecond;\n\t\t * ensure we don't cancel, rather than set, the interrupt.\n\t\t */\n\t\tif (secs == 0 && usecs == 0)\n\t\t\tusecs = 1;\n\n\t\ttimeval.it_value.tv_sec = secs;\n\t\ttimeval.it_value.tv_usec = usecs;\n\n\t\t/*\n\t\t * We must enable the signal handler before calling setitimer(); if we\n\t\t * did it in the other order, we'd have a race condition wherein the\n\t\t * interrupt could occur before we can set alarm_enabled, so that the\n\t\t * signal handler would fail to do anything.\n\t\t *\n\t\t * Because we didn't bother to reset the timer in disable_alarm(),\n\t\t * it's possible that a previously-set interrupt will fire between\n\t\t * enable_alarm() and setitimer().  This is safe, however.  There are\n\t\t * two possible outcomes:\n\t\t *\n\t\t * 1. The signal handler finds nothing to do (because the nearest\n\t\t * timeout event is still in the future).  It will re-set the timer\n\t\t * and return.  Then we'll overwrite the timer value with a new one.\n\t\t * This will mean that the timer fires a little later than we\n\t\t * intended, but only by the amount of time it takes for the signal\n\t\t * handler to do nothing useful, which shouldn't be much.\n\t\t *\n\t\t * 2. The signal handler executes and removes one or more timeout\n\t\t * events.  When it returns, either the queue is now empty or the\n\t\t * frontmost event is later than the one we looked at above.  So we'll\n\t\t * overwrite the timer value with one that is too soon (plus or minus\n\t\t * the signal handler's execution time), causing a useless interrupt\n\t\t * to occur.  But the handler will then re-set the timer and\n\t\t * everything will still work as expected.\n\t\t *\n\t\t * Since these cases are of very low probability (the window here\n\t\t * being quite narrow), it's not worth adding cycles to the mainline\n\t\t * code to prevent occasional wasted interrupts.\n\t\t */\n\t\tenable_alarm();\n\n\t\t/* Set the alarm timer */\n\t\tif (setitimer(ITIMER_REAL, &timeval, NULL) != 0)\n\t\t\telog(FATAL, \"could not enable SIGALRM timer: %m\");\n\t}\n}"
  },
  {
    "function_name": "enable_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
    "lines": "137-176",
    "snippet": "static void\nenable_timeout(TimeoutId id, TimestampTz now, TimestampTz fin_time)\n{\n\tint\t\t\ti;\n\n\t/* Assert request is sane */\n\tAssert(all_timeouts_initialized);\n\tAssert(all_timeouts[id].timeout_handler != NULL);\n\n\t/*\n\t * If this timeout was already active, momentarily disable it.  We\n\t * interpret the call as a directive to reschedule the timeout.\n\t */\n\ti = find_active_timeout(id);\n\tif (i >= 0)\n\t\tremove_timeout_index(i);\n\n\t/*\n\t * Find out the index where to insert the new timeout.  We sort by\n\t * fin_time, and for equal fin_time by priority.\n\t */\n\tfor (i = 0; i < num_active_timeouts; i++)\n\t{\n\t\ttimeout_params *old_timeout = active_timeouts[i];\n\n\t\tif (fin_time < old_timeout->fin_time)\n\t\t\tbreak;\n\t\tif (fin_time == old_timeout->fin_time && id < old_timeout->index)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Mark the timeout active, and insert it into the active list.\n\t */\n\tall_timeouts[id].indicator = false;\n\tall_timeouts[id].start_time = now;\n\tall_timeouts[id].fin_time = fin_time;\n\n\tinsert_timeout(id, i);\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"storage/proc.h\"",
      "#include \"miscadmin.h\"",
      "#include <sys/time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static timeout_params all_timeouts[MAX_TIMEOUTS];",
      "static bool all_timeouts_initialized = false;",
      "static volatile int num_active_timeouts = 0;",
      "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_timeout",
          "args": [
            "id",
            "i"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "insert_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "99-114",
          "snippet": "static void\ninsert_timeout(TimeoutId id, int index)\n{\n\tint\t\t\ti;\n\n\tif (index < 0 || index > num_active_timeouts)\n\t\telog(FATAL, \"timeout index %d out of range 0..%d\", index,\n\t\t\t num_active_timeouts);\n\n\tfor (i = num_active_timeouts - 1; i >= index; i--)\n\t\tactive_timeouts[i + 1] = active_timeouts[i];\n\n\tactive_timeouts[index] = &all_timeouts[id];\n\n\tnum_active_timeouts++;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static timeout_params all_timeouts[MAX_TIMEOUTS];",
            "static volatile int num_active_timeouts = 0;",
            "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic timeout_params all_timeouts[MAX_TIMEOUTS];\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\n\nstatic void\ninsert_timeout(TimeoutId id, int index)\n{\n\tint\t\t\ti;\n\n\tif (index < 0 || index > num_active_timeouts)\n\t\telog(FATAL, \"timeout index %d out of range 0..%d\", index,\n\t\t\t num_active_timeouts);\n\n\tfor (i = num_active_timeouts - 1; i >= index; i--)\n\t\tactive_timeouts[i + 1] = active_timeouts[i];\n\n\tactive_timeouts[index] = &all_timeouts[id];\n\n\tnum_active_timeouts++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_timeout_index",
          "args": [
            "i"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "remove_timeout_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "119-132",
          "snippet": "static void\nremove_timeout_index(int index)\n{\n\tint\t\t\ti;\n\n\tif (index < 0 || index >= num_active_timeouts)\n\t\telog(FATAL, \"timeout index %d out of range 0..%d\", index,\n\t\t\t num_active_timeouts - 1);\n\n\tfor (i = index + 1; i < num_active_timeouts; i++)\n\t\tactive_timeouts[i - 1] = active_timeouts[i];\n\n\tnum_active_timeouts--;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile int num_active_timeouts = 0;",
            "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\n\nstatic void\nremove_timeout_index(int index)\n{\n\tint\t\t\ti;\n\n\tif (index < 0 || index >= num_active_timeouts)\n\t\telog(FATAL, \"timeout index %d out of range 0..%d\", index,\n\t\t\t num_active_timeouts - 1);\n\n\tfor (i = index + 1; i < num_active_timeouts; i++)\n\t\tactive_timeouts[i - 1] = active_timeouts[i];\n\n\tnum_active_timeouts--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_active_timeout",
          "args": [
            "id"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "find_active_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
          "lines": "81-93",
          "snippet": "static int\nfind_active_timeout(TimeoutId id)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < num_active_timeouts; i++)\n\t{\n\t\tif (active_timeouts[i]->index == id)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/timeout.h\"",
            "#include \"storage/proc.h\"",
            "#include \"miscadmin.h\"",
            "#include <sys/time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static volatile int num_active_timeouts = 0;",
            "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\n\nstatic int\nfind_active_timeout(TimeoutId id)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < num_active_timeouts; i++)\n\t{\n\t\tif (active_timeouts[i]->index == id)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "all_timeouts[id].timeout_handler != NULL"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "all_timeouts_initialized"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic timeout_params all_timeouts[MAX_TIMEOUTS];\nstatic bool all_timeouts_initialized = false;\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\n\nstatic void\nenable_timeout(TimeoutId id, TimestampTz now, TimestampTz fin_time)\n{\n\tint\t\t\ti;\n\n\t/* Assert request is sane */\n\tAssert(all_timeouts_initialized);\n\tAssert(all_timeouts[id].timeout_handler != NULL);\n\n\t/*\n\t * If this timeout was already active, momentarily disable it.  We\n\t * interpret the call as a directive to reschedule the timeout.\n\t */\n\ti = find_active_timeout(id);\n\tif (i >= 0)\n\t\tremove_timeout_index(i);\n\n\t/*\n\t * Find out the index where to insert the new timeout.  We sort by\n\t * fin_time, and for equal fin_time by priority.\n\t */\n\tfor (i = 0; i < num_active_timeouts; i++)\n\t{\n\t\ttimeout_params *old_timeout = active_timeouts[i];\n\n\t\tif (fin_time < old_timeout->fin_time)\n\t\t\tbreak;\n\t\tif (fin_time == old_timeout->fin_time && id < old_timeout->index)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Mark the timeout active, and insert it into the active list.\n\t */\n\tall_timeouts[id].indicator = false;\n\tall_timeouts[id].start_time = now;\n\tall_timeouts[id].fin_time = fin_time;\n\n\tinsert_timeout(id, i);\n}"
  },
  {
    "function_name": "remove_timeout_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
    "lines": "119-132",
    "snippet": "static void\nremove_timeout_index(int index)\n{\n\tint\t\t\ti;\n\n\tif (index < 0 || index >= num_active_timeouts)\n\t\telog(FATAL, \"timeout index %d out of range 0..%d\", index,\n\t\t\t num_active_timeouts - 1);\n\n\tfor (i = index + 1; i < num_active_timeouts; i++)\n\t\tactive_timeouts[i - 1] = active_timeouts[i];\n\n\tnum_active_timeouts--;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"storage/proc.h\"",
      "#include \"miscadmin.h\"",
      "#include <sys/time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile int num_active_timeouts = 0;",
      "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"timeout index %d out of range 0..%d\"",
            "index",
            "num_active_timeouts - 1"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\n\nstatic void\nremove_timeout_index(int index)\n{\n\tint\t\t\ti;\n\n\tif (index < 0 || index >= num_active_timeouts)\n\t\telog(FATAL, \"timeout index %d out of range 0..%d\", index,\n\t\t\t num_active_timeouts - 1);\n\n\tfor (i = index + 1; i < num_active_timeouts; i++)\n\t\tactive_timeouts[i - 1] = active_timeouts[i];\n\n\tnum_active_timeouts--;\n}"
  },
  {
    "function_name": "insert_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
    "lines": "99-114",
    "snippet": "static void\ninsert_timeout(TimeoutId id, int index)\n{\n\tint\t\t\ti;\n\n\tif (index < 0 || index > num_active_timeouts)\n\t\telog(FATAL, \"timeout index %d out of range 0..%d\", index,\n\t\t\t num_active_timeouts);\n\n\tfor (i = num_active_timeouts - 1; i >= index; i--)\n\t\tactive_timeouts[i + 1] = active_timeouts[i];\n\n\tactive_timeouts[index] = &all_timeouts[id];\n\n\tnum_active_timeouts++;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"storage/proc.h\"",
      "#include \"miscadmin.h\"",
      "#include <sys/time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static timeout_params all_timeouts[MAX_TIMEOUTS];",
      "static volatile int num_active_timeouts = 0;",
      "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"timeout index %d out of range 0..%d\"",
            "index",
            "num_active_timeouts"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic timeout_params all_timeouts[MAX_TIMEOUTS];\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\n\nstatic void\ninsert_timeout(TimeoutId id, int index)\n{\n\tint\t\t\ti;\n\n\tif (index < 0 || index > num_active_timeouts)\n\t\telog(FATAL, \"timeout index %d out of range 0..%d\", index,\n\t\t\t num_active_timeouts);\n\n\tfor (i = num_active_timeouts - 1; i >= index; i--)\n\t\tactive_timeouts[i + 1] = active_timeouts[i];\n\n\tactive_timeouts[index] = &all_timeouts[id];\n\n\tnum_active_timeouts++;\n}"
  },
  {
    "function_name": "find_active_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/timeout.c",
    "lines": "81-93",
    "snippet": "static int\nfind_active_timeout(TimeoutId id)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < num_active_timeouts; i++)\n\t{\n\t\tif (active_timeouts[i]->index == id)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include \"utils/timestamp.h\"",
      "#include \"utils/timeout.h\"",
      "#include \"storage/proc.h\"",
      "#include \"miscadmin.h\"",
      "#include <sys/time.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile int num_active_timeouts = 0;",
      "static timeout_params *volatile active_timeouts[MAX_TIMEOUTS];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/timeout.h\"\n#include \"storage/proc.h\"\n#include \"miscadmin.h\"\n#include <sys/time.h>\n#include \"postgres.h\"\n\nstatic volatile int num_active_timeouts = 0;\nstatic timeout_params *volatile active_timeouts[MAX_TIMEOUTS];\n\nstatic int\nfind_active_timeout(TimeoutId id)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < num_active_timeouts; i++)\n\t{\n\t\tif (active_timeouts[i]->index == id)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}"
  }
]