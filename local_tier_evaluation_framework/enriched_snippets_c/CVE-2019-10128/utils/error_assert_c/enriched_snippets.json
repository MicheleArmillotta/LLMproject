[
  {
    "function_name": "ExceptionalCondition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/assert.c",
    "lines": "25-55",
    "snippet": "void\nExceptionalCondition(const char *conditionName,\n\t\t\t\t\t const char *errorType,\n\t\t\t\t\t const char *fileName,\n\t\t\t\t\t int lineNumber)\n{\n\tif (!PointerIsValid(conditionName)\n\t\t|| !PointerIsValid(fileName)\n\t\t|| !PointerIsValid(errorType))\n\t\twrite_stderr(\"TRAP: ExceptionalCondition: bad arguments\\n\");\n\telse\n\t{\n\t\twrite_stderr(\"TRAP: %s(\\\"%s\\\", File: \\\"%s\\\", Line: %d)\\n\",\n\t\t\t\t\t errorType, conditionName,\n\t\t\t\t\t fileName, lineNumber);\n\t}\n\n\t/* Usually this shouldn't be needed, but make sure the msg went out */\n\tfflush(stderr);\n\n#ifdef SLEEP_ON_ASSERT\n\n\t/*\n\t * It would be nice to use pg_usleep() here, but only does 2000 sec or 33\n\t * minutes, which seems too short.\n\t */\n\tsleep(1000000);\n#endif\n\n\tabort();\n}",
    "includes": [
      "#include <unistd.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1000000"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "pg_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/misc.c",
          "lines": "538-583",
          "snippet": "Datum\npg_sleep(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tsecs = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tendtime;\n\n\t/*\n\t * We sleep using WaitLatch, to ensure that we'll wake up promptly if an\n\t * important signal (such as SIGALRM or SIGINT) arrives.  Because\n\t * WaitLatch's upper limit of delay is INT_MAX milliseconds, and the user\n\t * might ask for more than that, we sleep for at most 10 minutes and then\n\t * loop.\n\t *\n\t * By computing the intended stop time initially, we avoid accumulation of\n\t * extra delay across multiple sleeps.  This also ensures we won't delay\n\t * less than the specified time when WaitLatch is terminated early by a\n\t * non-query-canceling signal such as SIGHUP.\n\t */\n#define GetNowFloat()\t((float8) GetCurrentTimestamp() / 1000000.0)\n\n\tendtime = GetNowFloat() + secs;\n\n\tfor (;;)\n\t{\n\t\tfloat8\t\tdelay;\n\t\tlong\t\tdelay_ms;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tdelay = endtime - GetNowFloat();\n\t\tif (delay >= 600.0)\n\t\t\tdelay_ms = 600000;\n\t\telse if (delay > 0.0)\n\t\t\tdelay_ms = (long) ceil(delay * 1000.0);\n\t\telse\n\t\t\tbreak;\n\n\t\t(void) WaitLatch(MyLatch,\n\t\t\t\t\t\t WL_LATCH_SET | WL_TIMEOUT,\n\t\t\t\t\t\t delay_ms,\n\t\t\t\t\t\t WAIT_EVENT_PG_SLEEP);\n\t\tResetLatch(MyLatch);\n\t}\n\n\tPG_RETURN_VOID();\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pmsignal.h\"",
            "#include \"storage/fd.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/sysattr.h\"",
            "#include <unistd.h>",
            "#include <math.h>",
            "#include <dirent.h>",
            "#include <signal.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"tcop/tcopprot.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pmsignal.h\"\n#include \"storage/fd.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"postmaster/syslogger.h\"\n#include \"parser/scansup.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/sysattr.h\"\n#include <unistd.h>\n#include <math.h>\n#include <dirent.h>\n#include <signal.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nDatum\npg_sleep(PG_FUNCTION_ARGS)\n{\n\tfloat8\t\tsecs = PG_GETARG_FLOAT8(0);\n\tfloat8\t\tendtime;\n\n\t/*\n\t * We sleep using WaitLatch, to ensure that we'll wake up promptly if an\n\t * important signal (such as SIGALRM or SIGINT) arrives.  Because\n\t * WaitLatch's upper limit of delay is INT_MAX milliseconds, and the user\n\t * might ask for more than that, we sleep for at most 10 minutes and then\n\t * loop.\n\t *\n\t * By computing the intended stop time initially, we avoid accumulation of\n\t * extra delay across multiple sleeps.  This also ensures we won't delay\n\t * less than the specified time when WaitLatch is terminated early by a\n\t * non-query-canceling signal such as SIGHUP.\n\t */\n#define GetNowFloat()\t((float8) GetCurrentTimestamp() / 1000000.0)\n\n\tendtime = GetNowFloat() + secs;\n\n\tfor (;;)\n\t{\n\t\tfloat8\t\tdelay;\n\t\tlong\t\tdelay_ms;\n\n\t\tCHECK_FOR_INTERRUPTS();\n\n\t\tdelay = endtime - GetNowFloat();\n\t\tif (delay >= 600.0)\n\t\t\tdelay_ms = 600000;\n\t\telse if (delay > 0.0)\n\t\t\tdelay_ms = (long) ceil(delay * 1000.0);\n\t\telse\n\t\t\tbreak;\n\n\t\t(void) WaitLatch(MyLatch,\n\t\t\t\t\t\t WL_LATCH_SET | WL_TIMEOUT,\n\t\t\t\t\t\t delay_ms,\n\t\t\t\t\t\t WAIT_EVENT_PG_SLEEP);\n\t\tResetLatch(MyLatch);\n\t}\n\n\tPG_RETURN_VOID();\n}"
        }
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_stderr",
          "args": [
            "\"TRAP: %s(\\\"%s\\\", File: \\\"%s\\\", Line: %d)\\n\"",
            "errorType",
            "conditionName",
            "fileName",
            "lineNumber"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "write_stderr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3668-3703",
          "snippet": "void\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nvoid\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "errorType"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "fileName"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "conditionName"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include \"postgres.h\"\n\nvoid\nExceptionalCondition(const char *conditionName,\n\t\t\t\t\t const char *errorType,\n\t\t\t\t\t const char *fileName,\n\t\t\t\t\t int lineNumber)\n{\n\tif (!PointerIsValid(conditionName)\n\t\t|| !PointerIsValid(fileName)\n\t\t|| !PointerIsValid(errorType))\n\t\twrite_stderr(\"TRAP: ExceptionalCondition: bad arguments\\n\");\n\telse\n\t{\n\t\twrite_stderr(\"TRAP: %s(\\\"%s\\\", File: \\\"%s\\\", Line: %d)\\n\",\n\t\t\t\t\t errorType, conditionName,\n\t\t\t\t\t fileName, lineNumber);\n\t}\n\n\t/* Usually this shouldn't be needed, but make sure the msg went out */\n\tfflush(stderr);\n\n#ifdef SLEEP_ON_ASSERT\n\n\t/*\n\t * It would be nice to use pg_usleep() here, but only does 2000 sec or 33\n\t * minutes, which seems too short.\n\t */\n\tsleep(1000000);\n#endif\n\n\tabort();\n}"
  }
]