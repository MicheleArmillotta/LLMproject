[
  {
    "function_name": "array_positions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_userfuncs.c",
    "lines": "783-903",
    "snippet": "Datum\narray_positions(PG_FUNCTION_ARGS)\n{\n\tArrayType  *array;\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tOid\t\t\telement_type;\n\tDatum\t\tsearched_element,\n\t\t\t\tvalue;\n\tbool\t\tisnull;\n\tint\t\t\tposition;\n\tTypeCacheEntry *typentry;\n\tArrayMetaState *my_extra;\n\tbool\t\tnull_search;\n\tArrayIterator array_iterator;\n\tArrayBuildState *astate = NULL;\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tarray = PG_GETARG_ARRAYTYPE_P(0);\n\telement_type = ARR_ELEMTYPE(array);\n\n\tposition = (ARR_LBOUND(array))[0] - 1;\n\n\t/*\n\t * We refuse to search for elements in multi-dimensional arrays, since we\n\t * have no good way to report the element's location in the array.\n\t */\n\tif (ARR_NDIM(array) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"searching for elements in multidimensional arrays is not supported\")));\n\n\tastate = initArrayResult(INT4OID, CurrentMemoryContext, false);\n\n\tif (PG_ARGISNULL(1))\n\t{\n\t\t/* fast return when the array doesn't have nulls */\n\t\tif (!array_contains_nulls(array))\n\t\t\tPG_RETURN_DATUM(makeArrayResult(astate, CurrentMemoryContext));\n\t\tsearched_element = (Datum) 0;\n\t\tnull_search = true;\n\t}\n\telse\n\t{\n\t\tsearched_element = PG_GETARG_DATUM(1);\n\t\tnull_search = false;\n\t}\n\n\t/*\n\t * We arrange to look up type info for array_create_iterator only once per\n\t * series of calls, assuming the element type doesn't change underneath\n\t * us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t\t &my_extra->typlen,\n\t\t\t\t\t\t\t &my_extra->typbyval,\n\t\t\t\t\t\t\t &my_extra->typalign);\n\n\t\ttypentry = lookup_type_cache(element_type, TYPECACHE_EQ_OPR_FINFO);\n\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\n\t\tmy_extra->element_type = element_type;\n\t\tfmgr_info_cxt(typentry->eq_opr_finfo.fn_oid, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t}\n\n\t/*\n\t * Accumulate each array position iff the element matches the given\n\t * element.\n\t */\n\tarray_iterator = array_create_iterator(array, 0, my_extra);\n\twhile (array_iterate(array_iterator, &value, &isnull))\n\t{\n\t\tposition += 1;\n\n\t\t/*\n\t\t * Can't look at the array element's value if it's null; but if we\n\t\t * search for null, we have a hit.\n\t\t */\n\t\tif (isnull || null_search)\n\t\t{\n\t\t\tif (isnull && null_search)\n\t\t\t\tastate =\n\t\t\t\t\taccumArrayResult(astate, Int32GetDatum(position), false,\n\t\t\t\t\t\t\t\t\t INT4OID, CurrentMemoryContext);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* not nulls, so run the operator */\n\t\tif (DatumGetBool(FunctionCall2Coll(&my_extra->proc, collation,\n\t\t\t\t\t\t\t\t\t\t   searched_element, value)))\n\t\t\tastate =\n\t\t\t\taccumArrayResult(astate, Int32GetDatum(position), false,\n\t\t\t\t\t\t\t\t INT4OID, CurrentMemoryContext);\n\t}\n\n\tarray_free_iterator(array_iterator);\n\n\t/* Avoid leaking memory when handed toasted input */\n\tPG_FREE_IF_COPY(array, 0);\n\n\tPG_RETURN_DATUM(makeArrayResult(astate, CurrentMemoryContext));\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_position_common(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "makeArrayResult(astate, CurrentMemoryContext)"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeArrayResult",
          "args": [
            "astate",
            "CurrentMemoryContext"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "makeArrayResult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5117-5132",
          "snippet": "Datum\nmakeArrayResult(ArrayBuildState *astate,\n\t\t\t\tMemoryContext rcontext)\n{\n\tint\t\t\tndims;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\t/* If no elements were presented, we want to create an empty array */\n\tndims = (astate->nelems > 0) ? 1 : 0;\n\tdims[0] = astate->nelems;\n\tlbs[0] = 1;\n\n\treturn makeMdArrayResult(astate, ndims, dims, lbs, rcontext,\n\t\t\t\t\t\t\t astate->private_cxt);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nmakeArrayResult(ArrayBuildState *astate,\n\t\t\t\tMemoryContext rcontext)\n{\n\tint\t\t\tndims;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\t/* If no elements were presented, we want to create an empty array */\n\tndims = (astate->nelems > 0) ? 1 : 0;\n\tdims[0] = astate->nelems;\n\tlbs[0] = 1;\n\n\treturn makeMdArrayResult(astate, ndims, dims, lbs, rcontext,\n\t\t\t\t\t\t\t astate->private_cxt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "array",
            "0"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_free_iterator",
          "args": [
            "array_iterator"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "array_free_iterator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4480-4489",
          "snippet": "void\narray_free_iterator(ArrayIterator iterator)\n{\n\tif (iterator->slice_ndim > 0)\n\t{\n\t\tpfree(iterator->slice_values);\n\t\tpfree(iterator->slice_nulls);\n\t}\n\tpfree(iterator);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\narray_free_iterator(ArrayIterator iterator)\n{\n\tif (iterator->slice_ndim > 0)\n\t{\n\t\tpfree(iterator->slice_values);\n\t\tpfree(iterator->slice_nulls);\n\t}\n\tpfree(iterator);\n}"
        }
      },
      {
        "call_info": {
          "callee": "accumArrayResult",
          "args": [
            "astate",
            "Int32GetDatum(position)",
            "false",
            "INT4OID",
            "CurrentMemoryContext"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "accumArrayResultAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5524-5543",
          "snippet": "ArrayBuildStateAny *\naccumArrayResultAny(ArrayBuildStateAny *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid input_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tif (astate == NULL)\n\t\tastate = initArrayResultAny(input_type, rcontext, true);\n\n\tif (astate->scalarstate)\n\t\t(void) accumArrayResult(astate->scalarstate,\n\t\t\t\t\t\t\t\tdvalue, disnull,\n\t\t\t\t\t\t\t\tinput_type, rcontext);\n\telse\n\t\t(void) accumArrayResultArr(astate->arraystate,\n\t\t\t\t\t\t\t\t   dvalue, disnull,\n\t\t\t\t\t\t\t\t   input_type, rcontext);\n\n\treturn astate;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nArrayBuildStateAny *\naccumArrayResultAny(ArrayBuildStateAny *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid input_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tif (astate == NULL)\n\t\tastate = initArrayResultAny(input_type, rcontext, true);\n\n\tif (astate->scalarstate)\n\t\t(void) accumArrayResult(astate->scalarstate,\n\t\t\t\t\t\t\t\tdvalue, disnull,\n\t\t\t\t\t\t\t\tinput_type, rcontext);\n\telse\n\t\t(void) accumArrayResultArr(astate->arraystate,\n\t\t\t\t\t\t\t\t   dvalue, disnull,\n\t\t\t\t\t\t\t\t   input_type, rcontext);\n\n\treturn astate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "position"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCall2Coll(&my_extra->proc, collation,\n\t\t\t\t\t\t\t\t\t\t   searched_element, value)"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "&my_extra->proc",
            "collation",
            "searched_element",
            "value"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "position"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_iterate",
          "args": [
            "array_iterator",
            "&value",
            "&isnull"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "array_iterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4397-4475",
          "snippet": "bool\narray_iterate(ArrayIterator iterator, Datum *value, bool *isnull)\n{\n\t/* Done if we have reached the end of the array */\n\tif (iterator->current_item >= iterator->nitems)\n\t\treturn false;\n\n\tif (iterator->slice_ndim == 0)\n\t{\n\t\t/*\n\t\t * Scalar case: return one element.\n\t\t */\n\t\tif (array_get_isnull(iterator->nullbitmap, iterator->current_item++))\n\t\t{\n\t\t\t*isnull = true;\n\t\t\t*value = (Datum) 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* non-NULL, so fetch the individual Datum to return */\n\t\t\tchar\t   *p = iterator->data_ptr;\n\n\t\t\t*isnull = false;\n\t\t\t*value = fetch_att(p, iterator->typbyval, iterator->typlen);\n\n\t\t\t/* Move our data pointer forward to the next element */\n\t\t\tp = att_addlength_pointer(p, iterator->typlen, p);\n\t\t\tp = (char *) att_align_nominal(p, iterator->typalign);\n\t\t\titerator->data_ptr = p;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Slice case: build and return an array of the requested size.\n\t\t */\n\t\tArrayType  *result;\n\t\tDatum\t   *values = iterator->slice_values;\n\t\tbool\t   *nulls = iterator->slice_nulls;\n\t\tchar\t   *p = iterator->data_ptr;\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < iterator->slice_len; i++)\n\t\t{\n\t\t\tif (array_get_isnull(iterator->nullbitmap,\n\t\t\t\t\t\t\t\t iterator->current_item++))\n\t\t\t{\n\t\t\t\tnulls[i] = true;\n\t\t\t\tvalues[i] = (Datum) 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnulls[i] = false;\n\t\t\t\tvalues[i] = fetch_att(p, iterator->typbyval, iterator->typlen);\n\n\t\t\t\t/* Move our data pointer forward to the next element */\n\t\t\t\tp = att_addlength_pointer(p, iterator->typlen, p);\n\t\t\t\tp = (char *) att_align_nominal(p, iterator->typalign);\n\t\t\t}\n\t\t}\n\n\t\titerator->data_ptr = p;\n\n\t\tresult = construct_md_array(values,\n\t\t\t\t\t\t\t\t\tnulls,\n\t\t\t\t\t\t\t\t\titerator->slice_ndim,\n\t\t\t\t\t\t\t\t\titerator->slice_dims,\n\t\t\t\t\t\t\t\t\titerator->slice_lbound,\n\t\t\t\t\t\t\t\t\tARR_ELEMTYPE(iterator->arr),\n\t\t\t\t\t\t\t\t\titerator->typlen,\n\t\t\t\t\t\t\t\t\titerator->typbyval,\n\t\t\t\t\t\t\t\t\titerator->typalign);\n\n\t\t*isnull = false;\n\t\t*value = PointerGetDatum(result);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nbool\narray_iterate(ArrayIterator iterator, Datum *value, bool *isnull)\n{\n\t/* Done if we have reached the end of the array */\n\tif (iterator->current_item >= iterator->nitems)\n\t\treturn false;\n\n\tif (iterator->slice_ndim == 0)\n\t{\n\t\t/*\n\t\t * Scalar case: return one element.\n\t\t */\n\t\tif (array_get_isnull(iterator->nullbitmap, iterator->current_item++))\n\t\t{\n\t\t\t*isnull = true;\n\t\t\t*value = (Datum) 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* non-NULL, so fetch the individual Datum to return */\n\t\t\tchar\t   *p = iterator->data_ptr;\n\n\t\t\t*isnull = false;\n\t\t\t*value = fetch_att(p, iterator->typbyval, iterator->typlen);\n\n\t\t\t/* Move our data pointer forward to the next element */\n\t\t\tp = att_addlength_pointer(p, iterator->typlen, p);\n\t\t\tp = (char *) att_align_nominal(p, iterator->typalign);\n\t\t\titerator->data_ptr = p;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Slice case: build and return an array of the requested size.\n\t\t */\n\t\tArrayType  *result;\n\t\tDatum\t   *values = iterator->slice_values;\n\t\tbool\t   *nulls = iterator->slice_nulls;\n\t\tchar\t   *p = iterator->data_ptr;\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < iterator->slice_len; i++)\n\t\t{\n\t\t\tif (array_get_isnull(iterator->nullbitmap,\n\t\t\t\t\t\t\t\t iterator->current_item++))\n\t\t\t{\n\t\t\t\tnulls[i] = true;\n\t\t\t\tvalues[i] = (Datum) 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnulls[i] = false;\n\t\t\t\tvalues[i] = fetch_att(p, iterator->typbyval, iterator->typlen);\n\n\t\t\t\t/* Move our data pointer forward to the next element */\n\t\t\t\tp = att_addlength_pointer(p, iterator->typlen, p);\n\t\t\t\tp = (char *) att_align_nominal(p, iterator->typalign);\n\t\t\t}\n\t\t}\n\n\t\titerator->data_ptr = p;\n\n\t\tresult = construct_md_array(values,\n\t\t\t\t\t\t\t\t\tnulls,\n\t\t\t\t\t\t\t\t\titerator->slice_ndim,\n\t\t\t\t\t\t\t\t\titerator->slice_dims,\n\t\t\t\t\t\t\t\t\titerator->slice_lbound,\n\t\t\t\t\t\t\t\t\tARR_ELEMTYPE(iterator->arr),\n\t\t\t\t\t\t\t\t\titerator->typlen,\n\t\t\t\t\t\t\t\t\titerator->typbyval,\n\t\t\t\t\t\t\t\t\titerator->typalign);\n\n\t\t*isnull = false;\n\t\t*value = PointerGetDatum(result);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_create_iterator",
          "args": [
            "array",
            "0",
            "my_extra"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "array_create_iterator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4318-4389",
          "snippet": "ArrayIterator\narray_create_iterator(ArrayType *arr, int slice_ndim, ArrayMetaState *mstate)\n{\n\tArrayIterator iterator = palloc0(sizeof(ArrayIteratorData));\n\n\t/*\n\t * Sanity-check inputs --- caller should have got this right already\n\t */\n\tAssert(PointerIsValid(arr));\n\tif (slice_ndim < 0 || slice_ndim > ARR_NDIM(arr))\n\t\telog(ERROR, \"invalid arguments to array_create_iterator\");\n\n\t/*\n\t * Remember basic info about the array and its element type\n\t */\n\titerator->arr = arr;\n\titerator->nullbitmap = ARR_NULLBITMAP(arr);\n\titerator->nitems = ArrayGetNItems(ARR_NDIM(arr), ARR_DIMS(arr));\n\n\tif (mstate != NULL)\n\t{\n\t\tAssert(mstate->element_type == ARR_ELEMTYPE(arr));\n\n\t\titerator->typlen = mstate->typlen;\n\t\titerator->typbyval = mstate->typbyval;\n\t\titerator->typalign = mstate->typalign;\n\t}\n\telse\n\t\tget_typlenbyvalalign(ARR_ELEMTYPE(arr),\n\t\t\t\t\t\t\t &iterator->typlen,\n\t\t\t\t\t\t\t &iterator->typbyval,\n\t\t\t\t\t\t\t &iterator->typalign);\n\n\t/*\n\t * Remember the slicing parameters.\n\t */\n\titerator->slice_ndim = slice_ndim;\n\n\tif (slice_ndim > 0)\n\t{\n\t\t/*\n\t\t * Get pointers into the array's dims and lbound arrays to represent\n\t\t * the dims/lbound arrays of a slice.  These are the same as the\n\t\t * rightmost N dimensions of the array.\n\t\t */\n\t\titerator->slice_dims = ARR_DIMS(arr) + ARR_NDIM(arr) - slice_ndim;\n\t\titerator->slice_lbound = ARR_LBOUND(arr) + ARR_NDIM(arr) - slice_ndim;\n\n\t\t/*\n\t\t * Compute number of elements in a slice.\n\t\t */\n\t\titerator->slice_len = ArrayGetNItems(slice_ndim,\n\t\t\t\t\t\t\t\t\t\t\t iterator->slice_dims);\n\n\t\t/*\n\t\t * Create workspace for building sub-arrays.\n\t\t */\n\t\titerator->slice_values = (Datum *)\n\t\t\tpalloc(iterator->slice_len * sizeof(Datum));\n\t\titerator->slice_nulls = (bool *)\n\t\t\tpalloc(iterator->slice_len * sizeof(bool));\n\t}\n\n\t/*\n\t * Initialize our data pointer and linear element number.  These will\n\t * advance through the array during array_iterate().\n\t */\n\titerator->data_ptr = ARR_DATA_PTR(arr);\n\titerator->current_item = 0;\n\n\treturn iterator;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nArrayIterator\narray_create_iterator(ArrayType *arr, int slice_ndim, ArrayMetaState *mstate)\n{\n\tArrayIterator iterator = palloc0(sizeof(ArrayIteratorData));\n\n\t/*\n\t * Sanity-check inputs --- caller should have got this right already\n\t */\n\tAssert(PointerIsValid(arr));\n\tif (slice_ndim < 0 || slice_ndim > ARR_NDIM(arr))\n\t\telog(ERROR, \"invalid arguments to array_create_iterator\");\n\n\t/*\n\t * Remember basic info about the array and its element type\n\t */\n\titerator->arr = arr;\n\titerator->nullbitmap = ARR_NULLBITMAP(arr);\n\titerator->nitems = ArrayGetNItems(ARR_NDIM(arr), ARR_DIMS(arr));\n\n\tif (mstate != NULL)\n\t{\n\t\tAssert(mstate->element_type == ARR_ELEMTYPE(arr));\n\n\t\titerator->typlen = mstate->typlen;\n\t\titerator->typbyval = mstate->typbyval;\n\t\titerator->typalign = mstate->typalign;\n\t}\n\telse\n\t\tget_typlenbyvalalign(ARR_ELEMTYPE(arr),\n\t\t\t\t\t\t\t &iterator->typlen,\n\t\t\t\t\t\t\t &iterator->typbyval,\n\t\t\t\t\t\t\t &iterator->typalign);\n\n\t/*\n\t * Remember the slicing parameters.\n\t */\n\titerator->slice_ndim = slice_ndim;\n\n\tif (slice_ndim > 0)\n\t{\n\t\t/*\n\t\t * Get pointers into the array's dims and lbound arrays to represent\n\t\t * the dims/lbound arrays of a slice.  These are the same as the\n\t\t * rightmost N dimensions of the array.\n\t\t */\n\t\titerator->slice_dims = ARR_DIMS(arr) + ARR_NDIM(arr) - slice_ndim;\n\t\titerator->slice_lbound = ARR_LBOUND(arr) + ARR_NDIM(arr) - slice_ndim;\n\n\t\t/*\n\t\t * Compute number of elements in a slice.\n\t\t */\n\t\titerator->slice_len = ArrayGetNItems(slice_ndim,\n\t\t\t\t\t\t\t\t\t\t\t iterator->slice_dims);\n\n\t\t/*\n\t\t * Create workspace for building sub-arrays.\n\t\t */\n\t\titerator->slice_values = (Datum *)\n\t\t\tpalloc(iterator->slice_len * sizeof(Datum));\n\t\titerator->slice_nulls = (bool *)\n\t\t\tpalloc(iterator->slice_len * sizeof(bool));\n\t}\n\n\t/*\n\t * Initialize our data pointer and linear element number.  These will\n\t * advance through the array during array_iterate().\n\t */\n\titerator->data_ptr = ARR_DATA_PTR(arr);\n\titerator->current_item = 0;\n\n\treturn iterator;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "typentry->eq_opr_finfo.fn_oid",
            "&my_extra->proc",
            "fcinfo->flinfo->fn_mcxt"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type)))"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not identify an equality operator for type %s\"",
            "format_type_be(element_type)"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "element_type"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_FUNCTION"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typentry->eq_opr_finfo.fn_oid"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "element_type",
            "TYPECACHE_EQ_OPR_FINFO"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_typlenbyvalalign",
          "args": [
            "element_type",
            "&my_extra->typlen",
            "&my_extra->typbyval",
            "&my_extra->typalign"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyvalalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2048-2063",
          "snippet": "void\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "sizeof(ArrayMetaState)"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "makeArrayResult(astate, CurrentMemoryContext)"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_contains_nulls",
          "args": [
            "array"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "array_contains_nulls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3527-3562",
          "snippet": "bool\narray_contains_nulls(ArrayType *array)\n{\n\tint\t\t\tnelems;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\n\t/* Easy answer if there's no null bitmap */\n\tif (!ARR_HASNULL(array))\n\t\treturn false;\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\n\tbitmap = ARR_NULLBITMAP(array);\n\n\t/* check whole bytes of the bitmap byte-at-a-time */\n\twhile (nelems >= 8)\n\t{\n\t\tif (*bitmap != 0xFF)\n\t\t\treturn true;\n\t\tbitmap++;\n\t\tnelems -= 8;\n\t}\n\n\t/* check last partial byte */\n\tbitmask = 1;\n\twhile (nelems > 0)\n\t{\n\t\tif ((*bitmap & bitmask) == 0)\n\t\t\treturn true;\n\t\tbitmask <<= 1;\n\t\tnelems--;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\narray_contains_nulls(ArrayType *array)\n{\n\tint\t\t\tnelems;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\n\t/* Easy answer if there's no null bitmap */\n\tif (!ARR_HASNULL(array))\n\t\treturn false;\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\n\tbitmap = ARR_NULLBITMAP(array);\n\n\t/* check whole bytes of the bitmap byte-at-a-time */\n\twhile (nelems >= 8)\n\t{\n\t\tif (*bitmap != 0xFF)\n\t\t\treturn true;\n\t\tbitmap++;\n\t\tnelems -= 8;\n\t}\n\n\t/* check last partial byte */\n\tbitmask = 1;\n\twhile (nelems > 0)\n\t{\n\t\tif ((*bitmap & bitmask) == 0)\n\t\t\treturn true;\n\t\tbitmask <<= 1;\n\t\tnelems--;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initArrayResult",
          "args": [
            "INT4OID",
            "CurrentMemoryContext",
            "false"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "initArrayResultAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5479-5514",
          "snippet": "ArrayBuildStateAny *\ninitArrayResultAny(Oid input_type, MemoryContext rcontext, bool subcontext)\n{\n\tArrayBuildStateAny *astate;\n\tOid\t\t\telement_type = get_element_type(input_type);\n\n\tif (OidIsValid(element_type))\n\t{\n\t\t/* Array case */\n\t\tArrayBuildStateArr *arraystate;\n\n\t\tarraystate = initArrayResultArr(input_type, InvalidOid, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(arraystate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = NULL;\n\t\tastate->arraystate = arraystate;\n\t}\n\telse\n\t{\n\t\t/* Scalar case */\n\t\tArrayBuildState *scalarstate;\n\n\t\t/* Let's just check that we have a type that can be put into arrays */\n\t\tAssert(OidIsValid(get_array_type(input_type)));\n\n\t\tscalarstate = initArrayResult(input_type, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(scalarstate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = scalarstate;\n\t\tastate->arraystate = NULL;\n\t}\n\n\treturn astate;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nArrayBuildStateAny *\ninitArrayResultAny(Oid input_type, MemoryContext rcontext, bool subcontext)\n{\n\tArrayBuildStateAny *astate;\n\tOid\t\t\telement_type = get_element_type(input_type);\n\n\tif (OidIsValid(element_type))\n\t{\n\t\t/* Array case */\n\t\tArrayBuildStateArr *arraystate;\n\n\t\tarraystate = initArrayResultArr(input_type, InvalidOid, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(arraystate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = NULL;\n\t\tastate->arraystate = arraystate;\n\t}\n\telse\n\t{\n\t\t/* Scalar case */\n\t\tArrayBuildState *scalarstate;\n\n\t\t/* Let's just check that we have a type that can be put into arrays */\n\t\tAssert(OidIsValid(get_array_type(input_type)));\n\n\t\tscalarstate = initArrayResult(input_type, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(scalarstate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = scalarstate;\n\t\tastate->arraystate = NULL;\n\t}\n\n\treturn astate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"searching for elements in multidimensional arrays is not supported\"))"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "array"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "array"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "array"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic Datum array_position_common(FunctionCallInfo fcinfo);\n\nDatum\narray_positions(PG_FUNCTION_ARGS)\n{\n\tArrayType  *array;\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tOid\t\t\telement_type;\n\tDatum\t\tsearched_element,\n\t\t\t\tvalue;\n\tbool\t\tisnull;\n\tint\t\t\tposition;\n\tTypeCacheEntry *typentry;\n\tArrayMetaState *my_extra;\n\tbool\t\tnull_search;\n\tArrayIterator array_iterator;\n\tArrayBuildState *astate = NULL;\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tarray = PG_GETARG_ARRAYTYPE_P(0);\n\telement_type = ARR_ELEMTYPE(array);\n\n\tposition = (ARR_LBOUND(array))[0] - 1;\n\n\t/*\n\t * We refuse to search for elements in multi-dimensional arrays, since we\n\t * have no good way to report the element's location in the array.\n\t */\n\tif (ARR_NDIM(array) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"searching for elements in multidimensional arrays is not supported\")));\n\n\tastate = initArrayResult(INT4OID, CurrentMemoryContext, false);\n\n\tif (PG_ARGISNULL(1))\n\t{\n\t\t/* fast return when the array doesn't have nulls */\n\t\tif (!array_contains_nulls(array))\n\t\t\tPG_RETURN_DATUM(makeArrayResult(astate, CurrentMemoryContext));\n\t\tsearched_element = (Datum) 0;\n\t\tnull_search = true;\n\t}\n\telse\n\t{\n\t\tsearched_element = PG_GETARG_DATUM(1);\n\t\tnull_search = false;\n\t}\n\n\t/*\n\t * We arrange to look up type info for array_create_iterator only once per\n\t * series of calls, assuming the element type doesn't change underneath\n\t * us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t\t &my_extra->typlen,\n\t\t\t\t\t\t\t &my_extra->typbyval,\n\t\t\t\t\t\t\t &my_extra->typalign);\n\n\t\ttypentry = lookup_type_cache(element_type, TYPECACHE_EQ_OPR_FINFO);\n\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\n\t\tmy_extra->element_type = element_type;\n\t\tfmgr_info_cxt(typentry->eq_opr_finfo.fn_oid, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t}\n\n\t/*\n\t * Accumulate each array position iff the element matches the given\n\t * element.\n\t */\n\tarray_iterator = array_create_iterator(array, 0, my_extra);\n\twhile (array_iterate(array_iterator, &value, &isnull))\n\t{\n\t\tposition += 1;\n\n\t\t/*\n\t\t * Can't look at the array element's value if it's null; but if we\n\t\t * search for null, we have a hit.\n\t\t */\n\t\tif (isnull || null_search)\n\t\t{\n\t\t\tif (isnull && null_search)\n\t\t\t\tastate =\n\t\t\t\t\taccumArrayResult(astate, Int32GetDatum(position), false,\n\t\t\t\t\t\t\t\t\t INT4OID, CurrentMemoryContext);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* not nulls, so run the operator */\n\t\tif (DatumGetBool(FunctionCall2Coll(&my_extra->proc, collation,\n\t\t\t\t\t\t\t\t\t\t   searched_element, value)))\n\t\t\tastate =\n\t\t\t\taccumArrayResult(astate, Int32GetDatum(position), false,\n\t\t\t\t\t\t\t\t INT4OID, CurrentMemoryContext);\n\t}\n\n\tarray_free_iterator(array_iterator);\n\n\t/* Avoid leaking memory when handed toasted input */\n\tPG_FREE_IF_COPY(array, 0);\n\n\tPG_RETURN_DATUM(makeArrayResult(astate, CurrentMemoryContext));\n}"
  },
  {
    "function_name": "array_position_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_userfuncs.c",
    "lines": "632-770",
    "snippet": "static Datum\narray_position_common(FunctionCallInfo fcinfo)\n{\n\tArrayType  *array;\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tOid\t\t\telement_type;\n\tDatum\t\tsearched_element,\n\t\t\t\tvalue;\n\tbool\t\tisnull;\n\tint\t\t\tposition,\n\t\t\t\tposition_min;\n\tbool\t\tfound = false;\n\tTypeCacheEntry *typentry;\n\tArrayMetaState *my_extra;\n\tbool\t\tnull_search;\n\tArrayIterator array_iterator;\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tarray = PG_GETARG_ARRAYTYPE_P(0);\n\telement_type = ARR_ELEMTYPE(array);\n\n\t/*\n\t * We refuse to search for elements in multi-dimensional arrays, since we\n\t * have no good way to report the element's location in the array.\n\t */\n\tif (ARR_NDIM(array) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"searching for elements in multidimensional arrays is not supported\")));\n\n\tif (PG_ARGISNULL(1))\n\t{\n\t\t/* fast return when the array doesn't have nulls */\n\t\tif (!array_contains_nulls(array))\n\t\t\tPG_RETURN_NULL();\n\t\tsearched_element = (Datum) 0;\n\t\tnull_search = true;\n\t}\n\telse\n\t{\n\t\tsearched_element = PG_GETARG_DATUM(1);\n\t\tnull_search = false;\n\t}\n\n\tposition = (ARR_LBOUND(array))[0] - 1;\n\n\t/* figure out where to start */\n\tif (PG_NARGS() == 3)\n\t{\n\t\tif (PG_ARGISNULL(2))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"initial position must not be null\")));\n\n\t\tposition_min = PG_GETARG_INT32(2);\n\t}\n\telse\n\t\tposition_min = (ARR_LBOUND(array))[0];\n\n\t/*\n\t * We arrange to look up type info for array_create_iterator only once per\n\t * series of calls, assuming the element type doesn't change underneath\n\t * us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t\t &my_extra->typlen,\n\t\t\t\t\t\t\t &my_extra->typbyval,\n\t\t\t\t\t\t\t &my_extra->typalign);\n\n\t\ttypentry = lookup_type_cache(element_type, TYPECACHE_EQ_OPR_FINFO);\n\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\n\t\tmy_extra->element_type = element_type;\n\t\tfmgr_info_cxt(typentry->eq_opr_finfo.fn_oid, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t}\n\n\t/* Examine each array element until we find a match. */\n\tarray_iterator = array_create_iterator(array, 0, my_extra);\n\twhile (array_iterate(array_iterator, &value, &isnull))\n\t{\n\t\tposition++;\n\n\t\t/* skip initial elements if caller requested so */\n\t\tif (position < position_min)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Can't look at the array element's value if it's null; but if we\n\t\t * search for null, we have a hit and are done.\n\t\t */\n\t\tif (isnull || null_search)\n\t\t{\n\t\t\tif (isnull && null_search)\n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* not nulls, so run the operator */\n\t\tif (DatumGetBool(FunctionCall2Coll(&my_extra->proc, collation,\n\t\t\t\t\t\t\t\t\t\t   searched_element, value)))\n\t\t{\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tarray_free_iterator(array_iterator);\n\n\t/* Avoid leaking memory when handed toasted input */\n\tPG_FREE_IF_COPY(array, 0);\n\n\tif (!found)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_INT32(position);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_position_common(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "position"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "array",
            "0"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_free_iterator",
          "args": [
            "array_iterator"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "array_free_iterator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4480-4489",
          "snippet": "void\narray_free_iterator(ArrayIterator iterator)\n{\n\tif (iterator->slice_ndim > 0)\n\t{\n\t\tpfree(iterator->slice_values);\n\t\tpfree(iterator->slice_nulls);\n\t}\n\tpfree(iterator);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\narray_free_iterator(ArrayIterator iterator)\n{\n\tif (iterator->slice_ndim > 0)\n\t{\n\t\tpfree(iterator->slice_values);\n\t\tpfree(iterator->slice_nulls);\n\t}\n\tpfree(iterator);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "FunctionCall2Coll(&my_extra->proc, collation,\n\t\t\t\t\t\t\t\t\t\t   searched_element, value)"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "&my_extra->proc",
            "collation",
            "searched_element",
            "value"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_iterate",
          "args": [
            "array_iterator",
            "&value",
            "&isnull"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "array_iterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4397-4475",
          "snippet": "bool\narray_iterate(ArrayIterator iterator, Datum *value, bool *isnull)\n{\n\t/* Done if we have reached the end of the array */\n\tif (iterator->current_item >= iterator->nitems)\n\t\treturn false;\n\n\tif (iterator->slice_ndim == 0)\n\t{\n\t\t/*\n\t\t * Scalar case: return one element.\n\t\t */\n\t\tif (array_get_isnull(iterator->nullbitmap, iterator->current_item++))\n\t\t{\n\t\t\t*isnull = true;\n\t\t\t*value = (Datum) 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* non-NULL, so fetch the individual Datum to return */\n\t\t\tchar\t   *p = iterator->data_ptr;\n\n\t\t\t*isnull = false;\n\t\t\t*value = fetch_att(p, iterator->typbyval, iterator->typlen);\n\n\t\t\t/* Move our data pointer forward to the next element */\n\t\t\tp = att_addlength_pointer(p, iterator->typlen, p);\n\t\t\tp = (char *) att_align_nominal(p, iterator->typalign);\n\t\t\titerator->data_ptr = p;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Slice case: build and return an array of the requested size.\n\t\t */\n\t\tArrayType  *result;\n\t\tDatum\t   *values = iterator->slice_values;\n\t\tbool\t   *nulls = iterator->slice_nulls;\n\t\tchar\t   *p = iterator->data_ptr;\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < iterator->slice_len; i++)\n\t\t{\n\t\t\tif (array_get_isnull(iterator->nullbitmap,\n\t\t\t\t\t\t\t\t iterator->current_item++))\n\t\t\t{\n\t\t\t\tnulls[i] = true;\n\t\t\t\tvalues[i] = (Datum) 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnulls[i] = false;\n\t\t\t\tvalues[i] = fetch_att(p, iterator->typbyval, iterator->typlen);\n\n\t\t\t\t/* Move our data pointer forward to the next element */\n\t\t\t\tp = att_addlength_pointer(p, iterator->typlen, p);\n\t\t\t\tp = (char *) att_align_nominal(p, iterator->typalign);\n\t\t\t}\n\t\t}\n\n\t\titerator->data_ptr = p;\n\n\t\tresult = construct_md_array(values,\n\t\t\t\t\t\t\t\t\tnulls,\n\t\t\t\t\t\t\t\t\titerator->slice_ndim,\n\t\t\t\t\t\t\t\t\titerator->slice_dims,\n\t\t\t\t\t\t\t\t\titerator->slice_lbound,\n\t\t\t\t\t\t\t\t\tARR_ELEMTYPE(iterator->arr),\n\t\t\t\t\t\t\t\t\titerator->typlen,\n\t\t\t\t\t\t\t\t\titerator->typbyval,\n\t\t\t\t\t\t\t\t\titerator->typalign);\n\n\t\t*isnull = false;\n\t\t*value = PointerGetDatum(result);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nbool\narray_iterate(ArrayIterator iterator, Datum *value, bool *isnull)\n{\n\t/* Done if we have reached the end of the array */\n\tif (iterator->current_item >= iterator->nitems)\n\t\treturn false;\n\n\tif (iterator->slice_ndim == 0)\n\t{\n\t\t/*\n\t\t * Scalar case: return one element.\n\t\t */\n\t\tif (array_get_isnull(iterator->nullbitmap, iterator->current_item++))\n\t\t{\n\t\t\t*isnull = true;\n\t\t\t*value = (Datum) 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* non-NULL, so fetch the individual Datum to return */\n\t\t\tchar\t   *p = iterator->data_ptr;\n\n\t\t\t*isnull = false;\n\t\t\t*value = fetch_att(p, iterator->typbyval, iterator->typlen);\n\n\t\t\t/* Move our data pointer forward to the next element */\n\t\t\tp = att_addlength_pointer(p, iterator->typlen, p);\n\t\t\tp = (char *) att_align_nominal(p, iterator->typalign);\n\t\t\titerator->data_ptr = p;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Slice case: build and return an array of the requested size.\n\t\t */\n\t\tArrayType  *result;\n\t\tDatum\t   *values = iterator->slice_values;\n\t\tbool\t   *nulls = iterator->slice_nulls;\n\t\tchar\t   *p = iterator->data_ptr;\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < iterator->slice_len; i++)\n\t\t{\n\t\t\tif (array_get_isnull(iterator->nullbitmap,\n\t\t\t\t\t\t\t\t iterator->current_item++))\n\t\t\t{\n\t\t\t\tnulls[i] = true;\n\t\t\t\tvalues[i] = (Datum) 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnulls[i] = false;\n\t\t\t\tvalues[i] = fetch_att(p, iterator->typbyval, iterator->typlen);\n\n\t\t\t\t/* Move our data pointer forward to the next element */\n\t\t\t\tp = att_addlength_pointer(p, iterator->typlen, p);\n\t\t\t\tp = (char *) att_align_nominal(p, iterator->typalign);\n\t\t\t}\n\t\t}\n\n\t\titerator->data_ptr = p;\n\n\t\tresult = construct_md_array(values,\n\t\t\t\t\t\t\t\t\tnulls,\n\t\t\t\t\t\t\t\t\titerator->slice_ndim,\n\t\t\t\t\t\t\t\t\titerator->slice_dims,\n\t\t\t\t\t\t\t\t\titerator->slice_lbound,\n\t\t\t\t\t\t\t\t\tARR_ELEMTYPE(iterator->arr),\n\t\t\t\t\t\t\t\t\titerator->typlen,\n\t\t\t\t\t\t\t\t\titerator->typbyval,\n\t\t\t\t\t\t\t\t\titerator->typalign);\n\n\t\t*isnull = false;\n\t\t*value = PointerGetDatum(result);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_create_iterator",
          "args": [
            "array",
            "0",
            "my_extra"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "array_create_iterator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4318-4389",
          "snippet": "ArrayIterator\narray_create_iterator(ArrayType *arr, int slice_ndim, ArrayMetaState *mstate)\n{\n\tArrayIterator iterator = palloc0(sizeof(ArrayIteratorData));\n\n\t/*\n\t * Sanity-check inputs --- caller should have got this right already\n\t */\n\tAssert(PointerIsValid(arr));\n\tif (slice_ndim < 0 || slice_ndim > ARR_NDIM(arr))\n\t\telog(ERROR, \"invalid arguments to array_create_iterator\");\n\n\t/*\n\t * Remember basic info about the array and its element type\n\t */\n\titerator->arr = arr;\n\titerator->nullbitmap = ARR_NULLBITMAP(arr);\n\titerator->nitems = ArrayGetNItems(ARR_NDIM(arr), ARR_DIMS(arr));\n\n\tif (mstate != NULL)\n\t{\n\t\tAssert(mstate->element_type == ARR_ELEMTYPE(arr));\n\n\t\titerator->typlen = mstate->typlen;\n\t\titerator->typbyval = mstate->typbyval;\n\t\titerator->typalign = mstate->typalign;\n\t}\n\telse\n\t\tget_typlenbyvalalign(ARR_ELEMTYPE(arr),\n\t\t\t\t\t\t\t &iterator->typlen,\n\t\t\t\t\t\t\t &iterator->typbyval,\n\t\t\t\t\t\t\t &iterator->typalign);\n\n\t/*\n\t * Remember the slicing parameters.\n\t */\n\titerator->slice_ndim = slice_ndim;\n\n\tif (slice_ndim > 0)\n\t{\n\t\t/*\n\t\t * Get pointers into the array's dims and lbound arrays to represent\n\t\t * the dims/lbound arrays of a slice.  These are the same as the\n\t\t * rightmost N dimensions of the array.\n\t\t */\n\t\titerator->slice_dims = ARR_DIMS(arr) + ARR_NDIM(arr) - slice_ndim;\n\t\titerator->slice_lbound = ARR_LBOUND(arr) + ARR_NDIM(arr) - slice_ndim;\n\n\t\t/*\n\t\t * Compute number of elements in a slice.\n\t\t */\n\t\titerator->slice_len = ArrayGetNItems(slice_ndim,\n\t\t\t\t\t\t\t\t\t\t\t iterator->slice_dims);\n\n\t\t/*\n\t\t * Create workspace for building sub-arrays.\n\t\t */\n\t\titerator->slice_values = (Datum *)\n\t\t\tpalloc(iterator->slice_len * sizeof(Datum));\n\t\titerator->slice_nulls = (bool *)\n\t\t\tpalloc(iterator->slice_len * sizeof(bool));\n\t}\n\n\t/*\n\t * Initialize our data pointer and linear element number.  These will\n\t * advance through the array during array_iterate().\n\t */\n\titerator->data_ptr = ARR_DATA_PTR(arr);\n\titerator->current_item = 0;\n\n\treturn iterator;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nArrayIterator\narray_create_iterator(ArrayType *arr, int slice_ndim, ArrayMetaState *mstate)\n{\n\tArrayIterator iterator = palloc0(sizeof(ArrayIteratorData));\n\n\t/*\n\t * Sanity-check inputs --- caller should have got this right already\n\t */\n\tAssert(PointerIsValid(arr));\n\tif (slice_ndim < 0 || slice_ndim > ARR_NDIM(arr))\n\t\telog(ERROR, \"invalid arguments to array_create_iterator\");\n\n\t/*\n\t * Remember basic info about the array and its element type\n\t */\n\titerator->arr = arr;\n\titerator->nullbitmap = ARR_NULLBITMAP(arr);\n\titerator->nitems = ArrayGetNItems(ARR_NDIM(arr), ARR_DIMS(arr));\n\n\tif (mstate != NULL)\n\t{\n\t\tAssert(mstate->element_type == ARR_ELEMTYPE(arr));\n\n\t\titerator->typlen = mstate->typlen;\n\t\titerator->typbyval = mstate->typbyval;\n\t\titerator->typalign = mstate->typalign;\n\t}\n\telse\n\t\tget_typlenbyvalalign(ARR_ELEMTYPE(arr),\n\t\t\t\t\t\t\t &iterator->typlen,\n\t\t\t\t\t\t\t &iterator->typbyval,\n\t\t\t\t\t\t\t &iterator->typalign);\n\n\t/*\n\t * Remember the slicing parameters.\n\t */\n\titerator->slice_ndim = slice_ndim;\n\n\tif (slice_ndim > 0)\n\t{\n\t\t/*\n\t\t * Get pointers into the array's dims and lbound arrays to represent\n\t\t * the dims/lbound arrays of a slice.  These are the same as the\n\t\t * rightmost N dimensions of the array.\n\t\t */\n\t\titerator->slice_dims = ARR_DIMS(arr) + ARR_NDIM(arr) - slice_ndim;\n\t\titerator->slice_lbound = ARR_LBOUND(arr) + ARR_NDIM(arr) - slice_ndim;\n\n\t\t/*\n\t\t * Compute number of elements in a slice.\n\t\t */\n\t\titerator->slice_len = ArrayGetNItems(slice_ndim,\n\t\t\t\t\t\t\t\t\t\t\t iterator->slice_dims);\n\n\t\t/*\n\t\t * Create workspace for building sub-arrays.\n\t\t */\n\t\titerator->slice_values = (Datum *)\n\t\t\tpalloc(iterator->slice_len * sizeof(Datum));\n\t\titerator->slice_nulls = (bool *)\n\t\t\tpalloc(iterator->slice_len * sizeof(bool));\n\t}\n\n\t/*\n\t * Initialize our data pointer and linear element number.  These will\n\t * advance through the array during array_iterate().\n\t */\n\titerator->data_ptr = ARR_DATA_PTR(arr);\n\titerator->current_item = 0;\n\n\treturn iterator;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "typentry->eq_opr_finfo.fn_oid",
            "&my_extra->proc",
            "fcinfo->flinfo->fn_mcxt"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type)))"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not identify an equality operator for type %s\"",
            "format_type_be(element_type)"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "element_type"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_FUNCTION"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typentry->eq_opr_finfo.fn_oid"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "element_type",
            "TYPECACHE_EQ_OPR_FINFO"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_typlenbyvalalign",
          "args": [
            "element_type",
            "&my_extra->typlen",
            "&my_extra->typbyval",
            "&my_extra->typalign"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "get_typlenbyvalalign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2048-2063",
          "snippet": "void\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nget_typlenbyvalalign(Oid typid, int16 *typlen, bool *typbyval,\n\t\t\t\t\t char *typalign)\n{\n\tHeapTuple\ttp;\n\tForm_pg_type typtup;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for type %u\", typid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t*typlen = typtup->typlen;\n\t*typbyval = typtup->typbyval;\n\t*typalign = typtup->typalign;\n\tReleaseSysCache(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "sizeof(ArrayMetaState)"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "array"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"initial position must not be null\"))"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "2"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_NARGS",
          "args": [],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "array"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_contains_nulls",
          "args": [
            "array"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "array_contains_nulls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3527-3562",
          "snippet": "bool\narray_contains_nulls(ArrayType *array)\n{\n\tint\t\t\tnelems;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\n\t/* Easy answer if there's no null bitmap */\n\tif (!ARR_HASNULL(array))\n\t\treturn false;\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\n\tbitmap = ARR_NULLBITMAP(array);\n\n\t/* check whole bytes of the bitmap byte-at-a-time */\n\twhile (nelems >= 8)\n\t{\n\t\tif (*bitmap != 0xFF)\n\t\t\treturn true;\n\t\tbitmap++;\n\t\tnelems -= 8;\n\t}\n\n\t/* check last partial byte */\n\tbitmask = 1;\n\twhile (nelems > 0)\n\t{\n\t\tif ((*bitmap & bitmask) == 0)\n\t\t\treturn true;\n\t\tbitmask <<= 1;\n\t\tnelems--;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\narray_contains_nulls(ArrayType *array)\n{\n\tint\t\t\tnelems;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\n\t/* Easy answer if there's no null bitmap */\n\tif (!ARR_HASNULL(array))\n\t\treturn false;\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\n\tbitmap = ARR_NULLBITMAP(array);\n\n\t/* check whole bytes of the bitmap byte-at-a-time */\n\twhile (nelems >= 8)\n\t{\n\t\tif (*bitmap != 0xFF)\n\t\t\treturn true;\n\t\tbitmap++;\n\t\tnelems -= 8;\n\t}\n\n\t/* check last partial byte */\n\tbitmask = 1;\n\twhile (nelems > 0)\n\t{\n\t\tif ((*bitmap & bitmask) == 0)\n\t\t\treturn true;\n\t\tbitmask <<= 1;\n\t\tnelems--;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"searching for elements in multidimensional arrays is not supported\"))"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "array"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "array"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic Datum array_position_common(FunctionCallInfo fcinfo);\n\nstatic Datum\narray_position_common(FunctionCallInfo fcinfo)\n{\n\tArrayType  *array;\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tOid\t\t\telement_type;\n\tDatum\t\tsearched_element,\n\t\t\t\tvalue;\n\tbool\t\tisnull;\n\tint\t\t\tposition,\n\t\t\t\tposition_min;\n\tbool\t\tfound = false;\n\tTypeCacheEntry *typentry;\n\tArrayMetaState *my_extra;\n\tbool\t\tnull_search;\n\tArrayIterator array_iterator;\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tarray = PG_GETARG_ARRAYTYPE_P(0);\n\telement_type = ARR_ELEMTYPE(array);\n\n\t/*\n\t * We refuse to search for elements in multi-dimensional arrays, since we\n\t * have no good way to report the element's location in the array.\n\t */\n\tif (ARR_NDIM(array) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"searching for elements in multidimensional arrays is not supported\")));\n\n\tif (PG_ARGISNULL(1))\n\t{\n\t\t/* fast return when the array doesn't have nulls */\n\t\tif (!array_contains_nulls(array))\n\t\t\tPG_RETURN_NULL();\n\t\tsearched_element = (Datum) 0;\n\t\tnull_search = true;\n\t}\n\telse\n\t{\n\t\tsearched_element = PG_GETARG_DATUM(1);\n\t\tnull_search = false;\n\t}\n\n\tposition = (ARR_LBOUND(array))[0] - 1;\n\n\t/* figure out where to start */\n\tif (PG_NARGS() == 3)\n\t{\n\t\tif (PG_ARGISNULL(2))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"initial position must not be null\")));\n\n\t\tposition_min = PG_GETARG_INT32(2);\n\t}\n\telse\n\t\tposition_min = (ARR_LBOUND(array))[0];\n\n\t/*\n\t * We arrange to look up type info for array_create_iterator only once per\n\t * series of calls, assuming the element type doesn't change underneath\n\t * us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t\t &my_extra->typlen,\n\t\t\t\t\t\t\t &my_extra->typbyval,\n\t\t\t\t\t\t\t &my_extra->typalign);\n\n\t\ttypentry = lookup_type_cache(element_type, TYPECACHE_EQ_OPR_FINFO);\n\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\n\t\tmy_extra->element_type = element_type;\n\t\tfmgr_info_cxt(typentry->eq_opr_finfo.fn_oid, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t}\n\n\t/* Examine each array element until we find a match. */\n\tarray_iterator = array_create_iterator(array, 0, my_extra);\n\twhile (array_iterate(array_iterator, &value, &isnull))\n\t{\n\t\tposition++;\n\n\t\t/* skip initial elements if caller requested so */\n\t\tif (position < position_min)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Can't look at the array element's value if it's null; but if we\n\t\t * search for null, we have a hit and are done.\n\t\t */\n\t\tif (isnull || null_search)\n\t\t{\n\t\t\tif (isnull && null_search)\n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* not nulls, so run the operator */\n\t\tif (DatumGetBool(FunctionCall2Coll(&my_extra->proc, collation,\n\t\t\t\t\t\t\t\t\t\t   searched_element, value)))\n\t\t{\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tarray_free_iterator(array_iterator);\n\n\t/* Avoid leaking memory when handed toasted input */\n\tPG_FREE_IF_COPY(array, 0);\n\n\tif (!found)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_INT32(position);\n}"
  },
  {
    "function_name": "array_position_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_userfuncs.c",
    "lines": "619-623",
    "snippet": "Datum\narray_position_start(PG_FUNCTION_ARGS)\n{\n\treturn array_position_common(fcinfo);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_position_common(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "array_position_common",
          "args": [
            "fcinfo"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "array_position_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_userfuncs.c",
          "lines": "632-770",
          "snippet": "static Datum\narray_position_common(FunctionCallInfo fcinfo)\n{\n\tArrayType  *array;\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tOid\t\t\telement_type;\n\tDatum\t\tsearched_element,\n\t\t\t\tvalue;\n\tbool\t\tisnull;\n\tint\t\t\tposition,\n\t\t\t\tposition_min;\n\tbool\t\tfound = false;\n\tTypeCacheEntry *typentry;\n\tArrayMetaState *my_extra;\n\tbool\t\tnull_search;\n\tArrayIterator array_iterator;\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tarray = PG_GETARG_ARRAYTYPE_P(0);\n\telement_type = ARR_ELEMTYPE(array);\n\n\t/*\n\t * We refuse to search for elements in multi-dimensional arrays, since we\n\t * have no good way to report the element's location in the array.\n\t */\n\tif (ARR_NDIM(array) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"searching for elements in multidimensional arrays is not supported\")));\n\n\tif (PG_ARGISNULL(1))\n\t{\n\t\t/* fast return when the array doesn't have nulls */\n\t\tif (!array_contains_nulls(array))\n\t\t\tPG_RETURN_NULL();\n\t\tsearched_element = (Datum) 0;\n\t\tnull_search = true;\n\t}\n\telse\n\t{\n\t\tsearched_element = PG_GETARG_DATUM(1);\n\t\tnull_search = false;\n\t}\n\n\tposition = (ARR_LBOUND(array))[0] - 1;\n\n\t/* figure out where to start */\n\tif (PG_NARGS() == 3)\n\t{\n\t\tif (PG_ARGISNULL(2))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"initial position must not be null\")));\n\n\t\tposition_min = PG_GETARG_INT32(2);\n\t}\n\telse\n\t\tposition_min = (ARR_LBOUND(array))[0];\n\n\t/*\n\t * We arrange to look up type info for array_create_iterator only once per\n\t * series of calls, assuming the element type doesn't change underneath\n\t * us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t\t &my_extra->typlen,\n\t\t\t\t\t\t\t &my_extra->typbyval,\n\t\t\t\t\t\t\t &my_extra->typalign);\n\n\t\ttypentry = lookup_type_cache(element_type, TYPECACHE_EQ_OPR_FINFO);\n\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\n\t\tmy_extra->element_type = element_type;\n\t\tfmgr_info_cxt(typentry->eq_opr_finfo.fn_oid, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t}\n\n\t/* Examine each array element until we find a match. */\n\tarray_iterator = array_create_iterator(array, 0, my_extra);\n\twhile (array_iterate(array_iterator, &value, &isnull))\n\t{\n\t\tposition++;\n\n\t\t/* skip initial elements if caller requested so */\n\t\tif (position < position_min)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Can't look at the array element's value if it's null; but if we\n\t\t * search for null, we have a hit and are done.\n\t\t */\n\t\tif (isnull || null_search)\n\t\t{\n\t\t\tif (isnull && null_search)\n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* not nulls, so run the operator */\n\t\tif (DatumGetBool(FunctionCall2Coll(&my_extra->proc, collation,\n\t\t\t\t\t\t\t\t\t\t   searched_element, value)))\n\t\t{\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tarray_free_iterator(array_iterator);\n\n\t/* Avoid leaking memory when handed toasted input */\n\tPG_FREE_IF_COPY(array, 0);\n\n\tif (!found)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_INT32(position);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_position_common(FunctionCallInfo fcinfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic Datum array_position_common(FunctionCallInfo fcinfo);\n\nstatic Datum\narray_position_common(FunctionCallInfo fcinfo)\n{\n\tArrayType  *array;\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tOid\t\t\telement_type;\n\tDatum\t\tsearched_element,\n\t\t\t\tvalue;\n\tbool\t\tisnull;\n\tint\t\t\tposition,\n\t\t\t\tposition_min;\n\tbool\t\tfound = false;\n\tTypeCacheEntry *typentry;\n\tArrayMetaState *my_extra;\n\tbool\t\tnull_search;\n\tArrayIterator array_iterator;\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tarray = PG_GETARG_ARRAYTYPE_P(0);\n\telement_type = ARR_ELEMTYPE(array);\n\n\t/*\n\t * We refuse to search for elements in multi-dimensional arrays, since we\n\t * have no good way to report the element's location in the array.\n\t */\n\tif (ARR_NDIM(array) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"searching for elements in multidimensional arrays is not supported\")));\n\n\tif (PG_ARGISNULL(1))\n\t{\n\t\t/* fast return when the array doesn't have nulls */\n\t\tif (!array_contains_nulls(array))\n\t\t\tPG_RETURN_NULL();\n\t\tsearched_element = (Datum) 0;\n\t\tnull_search = true;\n\t}\n\telse\n\t{\n\t\tsearched_element = PG_GETARG_DATUM(1);\n\t\tnull_search = false;\n\t}\n\n\tposition = (ARR_LBOUND(array))[0] - 1;\n\n\t/* figure out where to start */\n\tif (PG_NARGS() == 3)\n\t{\n\t\tif (PG_ARGISNULL(2))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"initial position must not be null\")));\n\n\t\tposition_min = PG_GETARG_INT32(2);\n\t}\n\telse\n\t\tposition_min = (ARR_LBOUND(array))[0];\n\n\t/*\n\t * We arrange to look up type info for array_create_iterator only once per\n\t * series of calls, assuming the element type doesn't change underneath\n\t * us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t\t &my_extra->typlen,\n\t\t\t\t\t\t\t &my_extra->typbyval,\n\t\t\t\t\t\t\t &my_extra->typalign);\n\n\t\ttypentry = lookup_type_cache(element_type, TYPECACHE_EQ_OPR_FINFO);\n\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\n\t\tmy_extra->element_type = element_type;\n\t\tfmgr_info_cxt(typentry->eq_opr_finfo.fn_oid, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t}\n\n\t/* Examine each array element until we find a match. */\n\tarray_iterator = array_create_iterator(array, 0, my_extra);\n\twhile (array_iterate(array_iterator, &value, &isnull))\n\t{\n\t\tposition++;\n\n\t\t/* skip initial elements if caller requested so */\n\t\tif (position < position_min)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Can't look at the array element's value if it's null; but if we\n\t\t * search for null, we have a hit and are done.\n\t\t */\n\t\tif (isnull || null_search)\n\t\t{\n\t\t\tif (isnull && null_search)\n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* not nulls, so run the operator */\n\t\tif (DatumGetBool(FunctionCall2Coll(&my_extra->proc, collation,\n\t\t\t\t\t\t\t\t\t\t   searched_element, value)))\n\t\t{\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tarray_free_iterator(array_iterator);\n\n\t/* Avoid leaking memory when handed toasted input */\n\tPG_FREE_IF_COPY(array, 0);\n\n\tif (!found)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_INT32(position);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic Datum array_position_common(FunctionCallInfo fcinfo);\n\nDatum\narray_position_start(PG_FUNCTION_ARGS)\n{\n\treturn array_position_common(fcinfo);\n}"
  },
  {
    "function_name": "array_position",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_userfuncs.c",
    "lines": "613-617",
    "snippet": "Datum\narray_position(PG_FUNCTION_ARGS)\n{\n\treturn array_position_common(fcinfo);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_position_common(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "array_position_common",
          "args": [
            "fcinfo"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "array_position_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_userfuncs.c",
          "lines": "632-770",
          "snippet": "static Datum\narray_position_common(FunctionCallInfo fcinfo)\n{\n\tArrayType  *array;\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tOid\t\t\telement_type;\n\tDatum\t\tsearched_element,\n\t\t\t\tvalue;\n\tbool\t\tisnull;\n\tint\t\t\tposition,\n\t\t\t\tposition_min;\n\tbool\t\tfound = false;\n\tTypeCacheEntry *typentry;\n\tArrayMetaState *my_extra;\n\tbool\t\tnull_search;\n\tArrayIterator array_iterator;\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tarray = PG_GETARG_ARRAYTYPE_P(0);\n\telement_type = ARR_ELEMTYPE(array);\n\n\t/*\n\t * We refuse to search for elements in multi-dimensional arrays, since we\n\t * have no good way to report the element's location in the array.\n\t */\n\tif (ARR_NDIM(array) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"searching for elements in multidimensional arrays is not supported\")));\n\n\tif (PG_ARGISNULL(1))\n\t{\n\t\t/* fast return when the array doesn't have nulls */\n\t\tif (!array_contains_nulls(array))\n\t\t\tPG_RETURN_NULL();\n\t\tsearched_element = (Datum) 0;\n\t\tnull_search = true;\n\t}\n\telse\n\t{\n\t\tsearched_element = PG_GETARG_DATUM(1);\n\t\tnull_search = false;\n\t}\n\n\tposition = (ARR_LBOUND(array))[0] - 1;\n\n\t/* figure out where to start */\n\tif (PG_NARGS() == 3)\n\t{\n\t\tif (PG_ARGISNULL(2))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"initial position must not be null\")));\n\n\t\tposition_min = PG_GETARG_INT32(2);\n\t}\n\telse\n\t\tposition_min = (ARR_LBOUND(array))[0];\n\n\t/*\n\t * We arrange to look up type info for array_create_iterator only once per\n\t * series of calls, assuming the element type doesn't change underneath\n\t * us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t\t &my_extra->typlen,\n\t\t\t\t\t\t\t &my_extra->typbyval,\n\t\t\t\t\t\t\t &my_extra->typalign);\n\n\t\ttypentry = lookup_type_cache(element_type, TYPECACHE_EQ_OPR_FINFO);\n\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\n\t\tmy_extra->element_type = element_type;\n\t\tfmgr_info_cxt(typentry->eq_opr_finfo.fn_oid, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t}\n\n\t/* Examine each array element until we find a match. */\n\tarray_iterator = array_create_iterator(array, 0, my_extra);\n\twhile (array_iterate(array_iterator, &value, &isnull))\n\t{\n\t\tposition++;\n\n\t\t/* skip initial elements if caller requested so */\n\t\tif (position < position_min)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Can't look at the array element's value if it's null; but if we\n\t\t * search for null, we have a hit and are done.\n\t\t */\n\t\tif (isnull || null_search)\n\t\t{\n\t\t\tif (isnull && null_search)\n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* not nulls, so run the operator */\n\t\tif (DatumGetBool(FunctionCall2Coll(&my_extra->proc, collation,\n\t\t\t\t\t\t\t\t\t\t   searched_element, value)))\n\t\t{\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tarray_free_iterator(array_iterator);\n\n\t/* Avoid leaking memory when handed toasted input */\n\tPG_FREE_IF_COPY(array, 0);\n\n\tif (!found)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_INT32(position);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_position_common(FunctionCallInfo fcinfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic Datum array_position_common(FunctionCallInfo fcinfo);\n\nstatic Datum\narray_position_common(FunctionCallInfo fcinfo)\n{\n\tArrayType  *array;\n\tOid\t\t\tcollation = PG_GET_COLLATION();\n\tOid\t\t\telement_type;\n\tDatum\t\tsearched_element,\n\t\t\t\tvalue;\n\tbool\t\tisnull;\n\tint\t\t\tposition,\n\t\t\t\tposition_min;\n\tbool\t\tfound = false;\n\tTypeCacheEntry *typentry;\n\tArrayMetaState *my_extra;\n\tbool\t\tnull_search;\n\tArrayIterator array_iterator;\n\n\tif (PG_ARGISNULL(0))\n\t\tPG_RETURN_NULL();\n\n\tarray = PG_GETARG_ARRAYTYPE_P(0);\n\telement_type = ARR_ELEMTYPE(array);\n\n\t/*\n\t * We refuse to search for elements in multi-dimensional arrays, since we\n\t * have no good way to report the element's location in the array.\n\t */\n\tif (ARR_NDIM(array) > 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"searching for elements in multidimensional arrays is not supported\")));\n\n\tif (PG_ARGISNULL(1))\n\t{\n\t\t/* fast return when the array doesn't have nulls */\n\t\tif (!array_contains_nulls(array))\n\t\t\tPG_RETURN_NULL();\n\t\tsearched_element = (Datum) 0;\n\t\tnull_search = true;\n\t}\n\telse\n\t{\n\t\tsearched_element = PG_GETARG_DATUM(1);\n\t\tnull_search = false;\n\t}\n\n\tposition = (ARR_LBOUND(array))[0] - 1;\n\n\t/* figure out where to start */\n\tif (PG_NARGS() == 3)\n\t{\n\t\tif (PG_ARGISNULL(2))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"initial position must not be null\")));\n\n\t\tposition_min = PG_GETARG_INT32(2);\n\t}\n\telse\n\t\tposition_min = (ARR_LBOUND(array))[0];\n\n\t/*\n\t * We arrange to look up type info for array_create_iterator only once per\n\t * series of calls, assuming the element type doesn't change underneath\n\t * us.\n\t */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tfcinfo->flinfo->fn_extra = MemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(ArrayMetaState));\n\t\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\t\tmy_extra->element_type = ~element_type;\n\t}\n\n\tif (my_extra->element_type != element_type)\n\t{\n\t\tget_typlenbyvalalign(element_type,\n\t\t\t\t\t\t\t &my_extra->typlen,\n\t\t\t\t\t\t\t &my_extra->typbyval,\n\t\t\t\t\t\t\t &my_extra->typalign);\n\n\t\ttypentry = lookup_type_cache(element_type, TYPECACHE_EQ_OPR_FINFO);\n\n\t\tif (!OidIsValid(typentry->eq_opr_finfo.fn_oid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t errmsg(\"could not identify an equality operator for type %s\",\n\t\t\t\t\t\t\tformat_type_be(element_type))));\n\n\t\tmy_extra->element_type = element_type;\n\t\tfmgr_info_cxt(typentry->eq_opr_finfo.fn_oid, &my_extra->proc,\n\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t}\n\n\t/* Examine each array element until we find a match. */\n\tarray_iterator = array_create_iterator(array, 0, my_extra);\n\twhile (array_iterate(array_iterator, &value, &isnull))\n\t{\n\t\tposition++;\n\n\t\t/* skip initial elements if caller requested so */\n\t\tif (position < position_min)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Can't look at the array element's value if it's null; but if we\n\t\t * search for null, we have a hit and are done.\n\t\t */\n\t\tif (isnull || null_search)\n\t\t{\n\t\t\tif (isnull && null_search)\n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* not nulls, so run the operator */\n\t\tif (DatumGetBool(FunctionCall2Coll(&my_extra->proc, collation,\n\t\t\t\t\t\t\t\t\t\t   searched_element, value)))\n\t\t{\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tarray_free_iterator(array_iterator);\n\n\t/* Avoid leaking memory when handed toasted input */\n\tPG_FREE_IF_COPY(array, 0);\n\n\tif (!found)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_INT32(position);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic Datum array_position_common(FunctionCallInfo fcinfo);\n\nDatum\narray_position(PG_FUNCTION_ARGS)\n{\n\treturn array_position_common(fcinfo);\n}"
  },
  {
    "function_name": "array_agg_array_finalfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_userfuncs.c",
    "lines": "580-603",
    "snippet": "Datum\narray_agg_array_finalfn(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tresult;\n\tArrayBuildStateArr *state;\n\n\t/* cannot be called directly because of internal-type argument */\n\tAssert(AggCheckCallContext(fcinfo, NULL));\n\n\tstate = PG_ARGISNULL(0) ? NULL : (ArrayBuildStateArr *) PG_GETARG_POINTER(0);\n\n\tif (state == NULL)\n\t\tPG_RETURN_NULL();\t\t/* returns null iff no input values */\n\n\t/*\n\t * Make the result.  We cannot release the ArrayBuildStateArr because\n\t * sometimes aggregate final functions are re-executed.  Rather, it is\n\t * nodeAgg.c's responsibility to reset the aggcontext when it's safe to do\n\t * so.\n\t */\n\tresult = makeArrayResultArr(state, CurrentMemoryContext, false);\n\n\tPG_RETURN_DATUM(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_position_common(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "result"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeArrayResultArr",
          "args": [
            "state",
            "CurrentMemoryContext",
            "false"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "makeArrayResultArr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5404-5464",
          "snippet": "Datum\nmakeArrayResultArr(ArrayBuildStateArr *astate,\n\t\t\t\t   MemoryContext rcontext,\n\t\t\t\t   bool release)\n{\n\tArrayType  *result;\n\tMemoryContext oldcontext;\n\n\t/* Build the final array result in rcontext */\n\toldcontext = MemoryContextSwitchTo(rcontext);\n\n\tif (astate->ndims == 0)\n\t{\n\t\t/* No inputs, return empty array */\n\t\tresult = construct_empty_array(astate->element_type);\n\t}\n\telse\n\t{\n\t\tint\t\t\tdataoffset,\n\t\t\t\t\tnbytes;\n\n\t\t/* Compute required space */\n\t\tnbytes = astate->nbytes;\n\t\tif (astate->nullbitmap != NULL)\n\t\t{\n\t\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(astate->ndims, astate->nitems);\n\t\t\tnbytes += dataoffset;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdataoffset = 0;\n\t\t\tnbytes += ARR_OVERHEAD_NONULLS(astate->ndims);\n\t\t}\n\n\t\tresult = (ArrayType *) palloc0(nbytes);\n\t\tSET_VARSIZE(result, nbytes);\n\t\tresult->ndim = astate->ndims;\n\t\tresult->dataoffset = dataoffset;\n\t\tresult->elemtype = astate->element_type;\n\n\t\tmemcpy(ARR_DIMS(result), astate->dims, astate->ndims * sizeof(int));\n\t\tmemcpy(ARR_LBOUND(result), astate->lbs, astate->ndims * sizeof(int));\n\t\tmemcpy(ARR_DATA_PTR(result), astate->data, astate->nbytes);\n\n\t\tif (astate->nullbitmap != NULL)\n\t\t\tarray_bitmap_copy(ARR_NULLBITMAP(result), 0,\n\t\t\t\t\t\t\t  astate->nullbitmap, 0,\n\t\t\t\t\t\t\t  astate->nitems);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Clean up all the junk */\n\tif (release)\n\t{\n\t\tAssert(astate->private_cxt);\n\t\tMemoryContextDelete(astate->mcontext);\n\t}\n\n\treturn PointerGetDatum(result);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);",
            "static ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\nstatic ArrayType *create_array_envelope(int ndims, int *dimv, int *lbv, int nbytes,\n\t\t\t\t\t  Oid elmtype, int dataoffset);\n\nDatum\nmakeArrayResultArr(ArrayBuildStateArr *astate,\n\t\t\t\t   MemoryContext rcontext,\n\t\t\t\t   bool release)\n{\n\tArrayType  *result;\n\tMemoryContext oldcontext;\n\n\t/* Build the final array result in rcontext */\n\toldcontext = MemoryContextSwitchTo(rcontext);\n\n\tif (astate->ndims == 0)\n\t{\n\t\t/* No inputs, return empty array */\n\t\tresult = construct_empty_array(astate->element_type);\n\t}\n\telse\n\t{\n\t\tint\t\t\tdataoffset,\n\t\t\t\t\tnbytes;\n\n\t\t/* Compute required space */\n\t\tnbytes = astate->nbytes;\n\t\tif (astate->nullbitmap != NULL)\n\t\t{\n\t\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(astate->ndims, astate->nitems);\n\t\t\tnbytes += dataoffset;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdataoffset = 0;\n\t\t\tnbytes += ARR_OVERHEAD_NONULLS(astate->ndims);\n\t\t}\n\n\t\tresult = (ArrayType *) palloc0(nbytes);\n\t\tSET_VARSIZE(result, nbytes);\n\t\tresult->ndim = astate->ndims;\n\t\tresult->dataoffset = dataoffset;\n\t\tresult->elemtype = astate->element_type;\n\n\t\tmemcpy(ARR_DIMS(result), astate->dims, astate->ndims * sizeof(int));\n\t\tmemcpy(ARR_LBOUND(result), astate->lbs, astate->ndims * sizeof(int));\n\t\tmemcpy(ARR_DATA_PTR(result), astate->data, astate->nbytes);\n\n\t\tif (astate->nullbitmap != NULL)\n\t\t\tarray_bitmap_copy(ARR_NULLBITMAP(result), 0,\n\t\t\t\t\t\t\t  astate->nullbitmap, 0,\n\t\t\t\t\t\t\t  astate->nitems);\n\t}\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Clean up all the junk */\n\tif (release)\n\t{\n\t\tAssert(astate->private_cxt);\n\t\tMemoryContextDelete(astate->mcontext);\n\t}\n\n\treturn PointerGetDatum(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "AggCheckCallContext(fcinfo, NULL)"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "NULL"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic Datum array_position_common(FunctionCallInfo fcinfo);\n\nDatum\narray_agg_array_finalfn(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tresult;\n\tArrayBuildStateArr *state;\n\n\t/* cannot be called directly because of internal-type argument */\n\tAssert(AggCheckCallContext(fcinfo, NULL));\n\n\tstate = PG_ARGISNULL(0) ? NULL : (ArrayBuildStateArr *) PG_GETARG_POINTER(0);\n\n\tif (state == NULL)\n\t\tPG_RETURN_NULL();\t\t/* returns null iff no input values */\n\n\t/*\n\t * Make the result.  We cannot release the ArrayBuildStateArr because\n\t * sometimes aggregate final functions are re-executed.  Rather, it is\n\t * nodeAgg.c's responsibility to reset the aggcontext when it's safe to do\n\t * so.\n\t */\n\tresult = makeArrayResultArr(state, CurrentMemoryContext, false);\n\n\tPG_RETURN_DATUM(result);\n}"
  },
  {
    "function_name": "array_agg_array_transfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_userfuncs.c",
    "lines": "536-578",
    "snippet": "Datum\narray_agg_array_transfn(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1_typeid = get_fn_expr_argtype(fcinfo->flinfo, 1);\n\tMemoryContext aggcontext;\n\tArrayBuildStateArr *state;\n\n\tif (arg1_typeid == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\t/*\n\t * Note: we do not need a run-time check about whether arg1_typeid is a\n\t * valid array type, because the parser would have verified that while\n\t * resolving the input/result types of this polymorphic aggregate.\n\t */\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"array_agg_array_transfn called in non-aggregate context\");\n\t}\n\n\n\tif (PG_ARGISNULL(0))\n\t\tstate = initArrayResultArr(arg1_typeid, InvalidOid, aggcontext, false);\n\telse\n\t\tstate = (ArrayBuildStateArr *) PG_GETARG_POINTER(0);\n\n\tstate = accumArrayResultArr(state,\n\t\t\t\t\t\t\t\tPG_GETARG_DATUM(1),\n\t\t\t\t\t\t\t\tPG_ARGISNULL(1),\n\t\t\t\t\t\t\t\targ1_typeid,\n\t\t\t\t\t\t\t\taggcontext);\n\n\t/*\n\t * The transition type for array_agg() is declared to be \"internal\", which\n\t * is a pass-by-value type the same size as a pointer.  So we can safely\n\t * pass the ArrayBuildStateArr pointer through nodeAgg.c's machinations.\n\t */\n\tPG_RETURN_POINTER(state);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_position_common(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "state"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accumArrayResultArr",
          "args": [
            "state",
            "PG_GETARG_DATUM(1)",
            "PG_ARGISNULL(1)",
            "arg1_typeid",
            "aggcontext"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "accumArrayResultArr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5247-5395",
          "snippet": "ArrayBuildStateArr *\naccumArrayResultArr(ArrayBuildStateArr *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid array_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tArrayType  *arg;\n\tMemoryContext oldcontext;\n\tint\t\t   *dims,\n\t\t\t   *lbs,\n\t\t\t\tndims,\n\t\t\t\tnitems,\n\t\t\t\tndatabytes;\n\tchar\t   *data;\n\tint\t\t\ti;\n\n\t/*\n\t * We disallow accumulating null subarrays.  Another plausible definition\n\t * is to ignore them, but callers that want that can just skip calling\n\t * this function.\n\t */\n\tif (disnull)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"cannot accumulate null arrays\")));\n\n\t/* Detoast input array in caller's context */\n\targ = DatumGetArrayTypeP(dvalue);\n\n\tif (astate == NULL)\n\t\tastate = initArrayResultArr(array_type, InvalidOid, rcontext, true);\n\telse\n\t\tAssert(astate->array_type == array_type);\n\n\toldcontext = MemoryContextSwitchTo(astate->mcontext);\n\n\t/* Collect this input's dimensions */\n\tndims = ARR_NDIM(arg);\n\tdims = ARR_DIMS(arg);\n\tlbs = ARR_LBOUND(arg);\n\tdata = ARR_DATA_PTR(arg);\n\tnitems = ArrayGetNItems(ndims, dims);\n\tndatabytes = ARR_SIZE(arg) - ARR_DATA_OFFSET(arg);\n\n\tif (astate->ndims == 0)\n\t{\n\t\t/* First input; check/save the dimensionality info */\n\n\t\t/* Should we allow empty inputs and just produce an empty output? */\n\t\tif (ndims == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"cannot accumulate empty arrays\")));\n\t\tif (ndims + 1 > MAXDIM)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\tndims + 1, MAXDIM)));\n\n\t\t/*\n\t\t * The output array will have n+1 dimensions, with the ones after the\n\t\t * first matching the input's dimensions.\n\t\t */\n\t\tastate->ndims = ndims + 1;\n\t\tastate->dims[0] = 0;\n\t\tmemcpy(&astate->dims[1], dims, ndims * sizeof(int));\n\t\tastate->lbs[0] = 1;\n\t\tmemcpy(&astate->lbs[1], lbs, ndims * sizeof(int));\n\n\t\t/* Allocate at least enough data space for this item */\n\t\tastate->abytes = 1024;\n\t\twhile (astate->abytes <= ndatabytes)\n\t\t\tastate->abytes *= 2;\n\t\tastate->data = (char *) palloc(astate->abytes);\n\t}\n\telse\n\t{\n\t\t/* Second or later input: must match first input's dimensionality */\n\t\tif (astate->ndims != ndims + 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"cannot accumulate arrays of different dimensionality\")));\n\t\tfor (i = 0; i < ndims; i++)\n\t\t{\n\t\t\tif (astate->dims[i + 1] != dims[i] || astate->lbs[i + 1] != lbs[i])\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot accumulate arrays of different dimensionality\")));\n\t\t}\n\n\t\t/* Enlarge data space if needed */\n\t\tif (astate->nbytes + ndatabytes > astate->abytes)\n\t\t{\n\t\t\tastate->abytes = Max(astate->abytes * 2,\n\t\t\t\t\t\t\t\t astate->nbytes + ndatabytes);\n\t\t\tastate->data = (char *) repalloc(astate->data, astate->abytes);\n\t\t}\n\t}\n\n\t/*\n\t * Copy the data portion of the sub-array.  Note we assume that the\n\t * advertised data length of the sub-array is properly aligned.  We do not\n\t * have to worry about detoasting elements since whatever's in the\n\t * sub-array should be OK already.\n\t */\n\tmemcpy(astate->data + astate->nbytes, data, ndatabytes);\n\tastate->nbytes += ndatabytes;\n\n\t/* Deal with null bitmap if needed */\n\tif (astate->nullbitmap || ARR_HASNULL(arg))\n\t{\n\t\tint\t\t\tnewnitems = astate->nitems + nitems;\n\n\t\tif (astate->nullbitmap == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * First input with nulls; we must retrospectively handle any\n\t\t\t * previous inputs by marking all their items non-null.\n\t\t\t */\n\t\t\tastate->aitems = 256;\n\t\t\twhile (astate->aitems <= newnitems)\n\t\t\t\tastate->aitems *= 2;\n\t\t\tastate->nullbitmap = (bits8 *) palloc((astate->aitems + 7) / 8);\n\t\t\tarray_bitmap_copy(astate->nullbitmap, 0,\n\t\t\t\t\t\t\t  NULL, 0,\n\t\t\t\t\t\t\t  astate->nitems);\n\t\t}\n\t\telse if (newnitems > astate->aitems)\n\t\t{\n\t\t\tastate->aitems = Max(astate->aitems * 2, newnitems);\n\t\t\tastate->nullbitmap = (bits8 *)\n\t\t\t\trepalloc(astate->nullbitmap, (astate->aitems + 7) / 8);\n\t\t}\n\t\tarray_bitmap_copy(astate->nullbitmap, astate->nitems,\n\t\t\t\t\t\t  ARR_NULLBITMAP(arg), 0,\n\t\t\t\t\t\t  nitems);\n\t}\n\n\tastate->nitems += nitems;\n\tastate->dims[0] += 1;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Release detoasted copy if any */\n\tif ((Pointer) arg != DatumGetPointer(dvalue))\n\t\tpfree(arg);\n\n\treturn astate;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);",
            "static void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void ReadArrayStr(char *arrayStr, const char *origStr,\n\t\t\t int nitems, int ndim, int *dim,\n\t\t\t FmgrInfo *inputproc, Oid typioparam, int32 typmod,\n\t\t\t char typdelim,\n\t\t\t int typlen, bool typbyval, char typalign,\n\t\t\t Datum *values, bool *nulls,\n\t\t\t bool *hasnulls, int32 *nbytes);\nstatic void ReadArrayBinary(StringInfo buf, int nitems,\n\t\t\t\tFmgrInfo *receiveproc, Oid typioparam, int32 typmod,\n\t\t\t\tint typlen, bool typbyval, char typalign,\n\t\t\t\tDatum *values, bool *nulls,\n\t\t\t\tbool *hasnulls, int32 *nbytes);\n\nArrayBuildStateArr *\naccumArrayResultArr(ArrayBuildStateArr *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid array_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tArrayType  *arg;\n\tMemoryContext oldcontext;\n\tint\t\t   *dims,\n\t\t\t   *lbs,\n\t\t\t\tndims,\n\t\t\t\tnitems,\n\t\t\t\tndatabytes;\n\tchar\t   *data;\n\tint\t\t\ti;\n\n\t/*\n\t * We disallow accumulating null subarrays.  Another plausible definition\n\t * is to ignore them, but callers that want that can just skip calling\n\t * this function.\n\t */\n\tif (disnull)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t errmsg(\"cannot accumulate null arrays\")));\n\n\t/* Detoast input array in caller's context */\n\targ = DatumGetArrayTypeP(dvalue);\n\n\tif (astate == NULL)\n\t\tastate = initArrayResultArr(array_type, InvalidOid, rcontext, true);\n\telse\n\t\tAssert(astate->array_type == array_type);\n\n\toldcontext = MemoryContextSwitchTo(astate->mcontext);\n\n\t/* Collect this input's dimensions */\n\tndims = ARR_NDIM(arg);\n\tdims = ARR_DIMS(arg);\n\tlbs = ARR_LBOUND(arg);\n\tdata = ARR_DATA_PTR(arg);\n\tnitems = ArrayGetNItems(ndims, dims);\n\tndatabytes = ARR_SIZE(arg) - ARR_DATA_OFFSET(arg);\n\n\tif (astate->ndims == 0)\n\t{\n\t\t/* First input; check/save the dimensionality info */\n\n\t\t/* Should we allow empty inputs and just produce an empty output? */\n\t\tif (ndims == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"cannot accumulate empty arrays\")));\n\t\tif (ndims + 1 > MAXDIM)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"number of array dimensions (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\tndims + 1, MAXDIM)));\n\n\t\t/*\n\t\t * The output array will have n+1 dimensions, with the ones after the\n\t\t * first matching the input's dimensions.\n\t\t */\n\t\tastate->ndims = ndims + 1;\n\t\tastate->dims[0] = 0;\n\t\tmemcpy(&astate->dims[1], dims, ndims * sizeof(int));\n\t\tastate->lbs[0] = 1;\n\t\tmemcpy(&astate->lbs[1], lbs, ndims * sizeof(int));\n\n\t\t/* Allocate at least enough data space for this item */\n\t\tastate->abytes = 1024;\n\t\twhile (astate->abytes <= ndatabytes)\n\t\t\tastate->abytes *= 2;\n\t\tastate->data = (char *) palloc(astate->abytes);\n\t}\n\telse\n\t{\n\t\t/* Second or later input: must match first input's dimensionality */\n\t\tif (astate->ndims != ndims + 1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t errmsg(\"cannot accumulate arrays of different dimensionality\")));\n\t\tfor (i = 0; i < ndims; i++)\n\t\t{\n\t\t\tif (astate->dims[i + 1] != dims[i] || astate->lbs[i + 1] != lbs[i])\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot accumulate arrays of different dimensionality\")));\n\t\t}\n\n\t\t/* Enlarge data space if needed */\n\t\tif (astate->nbytes + ndatabytes > astate->abytes)\n\t\t{\n\t\t\tastate->abytes = Max(astate->abytes * 2,\n\t\t\t\t\t\t\t\t astate->nbytes + ndatabytes);\n\t\t\tastate->data = (char *) repalloc(astate->data, astate->abytes);\n\t\t}\n\t}\n\n\t/*\n\t * Copy the data portion of the sub-array.  Note we assume that the\n\t * advertised data length of the sub-array is properly aligned.  We do not\n\t * have to worry about detoasting elements since whatever's in the\n\t * sub-array should be OK already.\n\t */\n\tmemcpy(astate->data + astate->nbytes, data, ndatabytes);\n\tastate->nbytes += ndatabytes;\n\n\t/* Deal with null bitmap if needed */\n\tif (astate->nullbitmap || ARR_HASNULL(arg))\n\t{\n\t\tint\t\t\tnewnitems = astate->nitems + nitems;\n\n\t\tif (astate->nullbitmap == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * First input with nulls; we must retrospectively handle any\n\t\t\t * previous inputs by marking all their items non-null.\n\t\t\t */\n\t\t\tastate->aitems = 256;\n\t\t\twhile (astate->aitems <= newnitems)\n\t\t\t\tastate->aitems *= 2;\n\t\t\tastate->nullbitmap = (bits8 *) palloc((astate->aitems + 7) / 8);\n\t\t\tarray_bitmap_copy(astate->nullbitmap, 0,\n\t\t\t\t\t\t\t  NULL, 0,\n\t\t\t\t\t\t\t  astate->nitems);\n\t\t}\n\t\telse if (newnitems > astate->aitems)\n\t\t{\n\t\t\tastate->aitems = Max(astate->aitems * 2, newnitems);\n\t\t\tastate->nullbitmap = (bits8 *)\n\t\t\t\trepalloc(astate->nullbitmap, (astate->aitems + 7) / 8);\n\t\t}\n\t\tarray_bitmap_copy(astate->nullbitmap, astate->nitems,\n\t\t\t\t\t\t  ARR_NULLBITMAP(arg), 0,\n\t\t\t\t\t\t  nitems);\n\t}\n\n\tastate->nitems += nitems;\n\tastate->dims[0] += 1;\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Release detoasted copy if any */\n\tif ((Pointer) arg != DatumGetPointer(dvalue))\n\t\tpfree(arg);\n\n\treturn astate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initArrayResultArr",
          "args": [
            "arg1_typeid",
            "InvalidOid",
            "aggcontext",
            "false"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "initArrayResultArr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5201-5237",
          "snippet": "ArrayBuildStateArr *\ninitArrayResultArr(Oid array_type, Oid element_type, MemoryContext rcontext,\n\t\t\t\t   bool subcontext)\n{\n\tArrayBuildStateArr *astate;\n\tMemoryContext arr_context = rcontext;\t/* by default use the parent ctx */\n\n\t/* Lookup element type, unless element_type already provided */\n\tif (!OidIsValid(element_type))\n\t{\n\t\telement_type = get_element_type(array_type);\n\n\t\tif (!OidIsValid(element_type))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"data type %s is not an array type\",\n\t\t\t\t\t\t\tformat_type_be(array_type))));\n\t}\n\n\t/* Make a temporary context to hold all the junk */\n\tif (subcontext)\n\t\tarr_context = AllocSetContextCreate(rcontext,\n\t\t\t\t\t\t\t\t\t\t\t\"accumArrayResultArr\",\n\t\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\t/* Note we initialize all fields to zero */\n\tastate = (ArrayBuildStateArr *)\n\t\tMemoryContextAllocZero(arr_context, sizeof(ArrayBuildStateArr));\n\tastate->mcontext = arr_context;\n\tastate->private_cxt = subcontext;\n\n\t/* Save relevant datatype information */\n\tastate->array_type = array_type;\n\tastate->element_type = element_type;\n\n\treturn astate;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nArrayBuildStateArr *\ninitArrayResultArr(Oid array_type, Oid element_type, MemoryContext rcontext,\n\t\t\t\t   bool subcontext)\n{\n\tArrayBuildStateArr *astate;\n\tMemoryContext arr_context = rcontext;\t/* by default use the parent ctx */\n\n\t/* Lookup element type, unless element_type already provided */\n\tif (!OidIsValid(element_type))\n\t{\n\t\telement_type = get_element_type(array_type);\n\n\t\tif (!OidIsValid(element_type))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"data type %s is not an array type\",\n\t\t\t\t\t\t\tformat_type_be(array_type))));\n\t}\n\n\t/* Make a temporary context to hold all the junk */\n\tif (subcontext)\n\t\tarr_context = AllocSetContextCreate(rcontext,\n\t\t\t\t\t\t\t\t\t\t\t\"accumArrayResultArr\",\n\t\t\t\t\t\t\t\t\t\t\tALLOCSET_DEFAULT_SIZES);\n\n\t/* Note we initialize all fields to zero */\n\tastate = (ArrayBuildStateArr *)\n\t\tMemoryContextAllocZero(arr_context, sizeof(ArrayBuildStateArr));\n\tastate->mcontext = arr_context;\n\tastate->private_cxt = subcontext;\n\n\t/* Save relevant datatype information */\n\tastate->array_type = array_type;\n\tastate->element_type = element_type;\n\n\treturn astate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"array_agg_array_transfn called in non-aggregate context\""
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "&aggcontext"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\"))"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not determine input data type\""
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "1"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic Datum array_position_common(FunctionCallInfo fcinfo);\n\nDatum\narray_agg_array_transfn(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1_typeid = get_fn_expr_argtype(fcinfo->flinfo, 1);\n\tMemoryContext aggcontext;\n\tArrayBuildStateArr *state;\n\n\tif (arg1_typeid == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\t/*\n\t * Note: we do not need a run-time check about whether arg1_typeid is a\n\t * valid array type, because the parser would have verified that while\n\t * resolving the input/result types of this polymorphic aggregate.\n\t */\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"array_agg_array_transfn called in non-aggregate context\");\n\t}\n\n\n\tif (PG_ARGISNULL(0))\n\t\tstate = initArrayResultArr(arg1_typeid, InvalidOid, aggcontext, false);\n\telse\n\t\tstate = (ArrayBuildStateArr *) PG_GETARG_POINTER(0);\n\n\tstate = accumArrayResultArr(state,\n\t\t\t\t\t\t\t\tPG_GETARG_DATUM(1),\n\t\t\t\t\t\t\t\tPG_ARGISNULL(1),\n\t\t\t\t\t\t\t\targ1_typeid,\n\t\t\t\t\t\t\t\taggcontext);\n\n\t/*\n\t * The transition type for array_agg() is declared to be \"internal\", which\n\t * is a pass-by-value type the same size as a pointer.  So we can safely\n\t * pass the ArrayBuildStateArr pointer through nodeAgg.c's machinations.\n\t */\n\tPG_RETURN_POINTER(state);\n}"
  },
  {
    "function_name": "array_agg_finalfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_userfuncs.c",
    "lines": "501-531",
    "snippet": "Datum\narray_agg_finalfn(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tresult;\n\tArrayBuildState *state;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\t/* cannot be called directly because of internal-type argument */\n\tAssert(AggCheckCallContext(fcinfo, NULL));\n\n\tstate = PG_ARGISNULL(0) ? NULL : (ArrayBuildState *) PG_GETARG_POINTER(0);\n\n\tif (state == NULL)\n\t\tPG_RETURN_NULL();\t\t/* returns null iff no input values */\n\n\tdims[0] = state->nelems;\n\tlbs[0] = 1;\n\n\t/*\n\t * Make the result.  We cannot release the ArrayBuildState because\n\t * sometimes aggregate final functions are re-executed.  Rather, it is\n\t * nodeAgg.c's responsibility to reset the aggcontext when it's safe to do\n\t * so.\n\t */\n\tresult = makeMdArrayResult(state, 1, dims, lbs,\n\t\t\t\t\t\t\t   CurrentMemoryContext,\n\t\t\t\t\t\t\t   false);\n\n\tPG_RETURN_DATUM(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_position_common(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "result"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeMdArrayResult",
          "args": [
            "state",
            "1",
            "dims",
            "lbs",
            "CurrentMemoryContext",
            "false"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "makeMdArrayResult",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5149-5183",
          "snippet": "Datum\nmakeMdArrayResult(ArrayBuildState *astate,\n\t\t\t\t  int ndims,\n\t\t\t\t  int *dims,\n\t\t\t\t  int *lbs,\n\t\t\t\t  MemoryContext rcontext,\n\t\t\t\t  bool release)\n{\n\tArrayType  *result;\n\tMemoryContext oldcontext;\n\n\t/* Build the final array result in rcontext */\n\toldcontext = MemoryContextSwitchTo(rcontext);\n\n\tresult = construct_md_array(astate->dvalues,\n\t\t\t\t\t\t\t\tastate->dnulls,\n\t\t\t\t\t\t\t\tndims,\n\t\t\t\t\t\t\t\tdims,\n\t\t\t\t\t\t\t\tlbs,\n\t\t\t\t\t\t\t\tastate->element_type,\n\t\t\t\t\t\t\t\tastate->typlen,\n\t\t\t\t\t\t\t\tastate->typbyval,\n\t\t\t\t\t\t\t\tastate->typalign);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Clean up all the junk */\n\tif (release)\n\t{\n\t\tAssert(astate->private_cxt);\n\t\tMemoryContextDelete(astate->mcontext);\n\t}\n\n\treturn PointerGetDatum(result);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nDatum\nmakeMdArrayResult(ArrayBuildState *astate,\n\t\t\t\t  int ndims,\n\t\t\t\t  int *dims,\n\t\t\t\t  int *lbs,\n\t\t\t\t  MemoryContext rcontext,\n\t\t\t\t  bool release)\n{\n\tArrayType  *result;\n\tMemoryContext oldcontext;\n\n\t/* Build the final array result in rcontext */\n\toldcontext = MemoryContextSwitchTo(rcontext);\n\n\tresult = construct_md_array(astate->dvalues,\n\t\t\t\t\t\t\t\tastate->dnulls,\n\t\t\t\t\t\t\t\tndims,\n\t\t\t\t\t\t\t\tdims,\n\t\t\t\t\t\t\t\tlbs,\n\t\t\t\t\t\t\t\tastate->element_type,\n\t\t\t\t\t\t\t\tastate->typlen,\n\t\t\t\t\t\t\t\tastate->typbyval,\n\t\t\t\t\t\t\t\tastate->typalign);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\t/* Clean up all the junk */\n\tif (release)\n\t{\n\t\tAssert(astate->private_cxt);\n\t\tMemoryContextDelete(astate->mcontext);\n\t}\n\n\treturn PointerGetDatum(result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "AggCheckCallContext(fcinfo, NULL)"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "NULL"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic Datum array_position_common(FunctionCallInfo fcinfo);\n\nDatum\narray_agg_finalfn(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tresult;\n\tArrayBuildState *state;\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\t/* cannot be called directly because of internal-type argument */\n\tAssert(AggCheckCallContext(fcinfo, NULL));\n\n\tstate = PG_ARGISNULL(0) ? NULL : (ArrayBuildState *) PG_GETARG_POINTER(0);\n\n\tif (state == NULL)\n\t\tPG_RETURN_NULL();\t\t/* returns null iff no input values */\n\n\tdims[0] = state->nelems;\n\tlbs[0] = 1;\n\n\t/*\n\t * Make the result.  We cannot release the ArrayBuildState because\n\t * sometimes aggregate final functions are re-executed.  Rather, it is\n\t * nodeAgg.c's responsibility to reset the aggcontext when it's safe to do\n\t * so.\n\t */\n\tresult = makeMdArrayResult(state, 1, dims, lbs,\n\t\t\t\t\t\t\t   CurrentMemoryContext,\n\t\t\t\t\t\t\t   false);\n\n\tPG_RETURN_DATUM(result);\n}"
  },
  {
    "function_name": "array_agg_transfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_userfuncs.c",
    "lines": "455-499",
    "snippet": "Datum\narray_agg_transfn(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1_typeid = get_fn_expr_argtype(fcinfo->flinfo, 1);\n\tMemoryContext aggcontext;\n\tArrayBuildState *state;\n\tDatum\t\telem;\n\n\tif (arg1_typeid == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\t/*\n\t * Note: we do not need a run-time check about whether arg1_typeid is a\n\t * valid array element type, because the parser would have verified that\n\t * while resolving the input/result types of this polymorphic aggregate.\n\t */\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"array_agg_transfn called in non-aggregate context\");\n\t}\n\n\tif (PG_ARGISNULL(0))\n\t\tstate = initArrayResult(arg1_typeid, aggcontext, false);\n\telse\n\t\tstate = (ArrayBuildState *) PG_GETARG_POINTER(0);\n\n\telem = PG_ARGISNULL(1) ? (Datum) 0 : PG_GETARG_DATUM(1);\n\n\tstate = accumArrayResult(state,\n\t\t\t\t\t\t\t elem,\n\t\t\t\t\t\t\t PG_ARGISNULL(1),\n\t\t\t\t\t\t\t arg1_typeid,\n\t\t\t\t\t\t\t aggcontext);\n\n\t/*\n\t * The transition type for array_agg() is declared to be \"internal\", which\n\t * is a pass-by-value type the same size as a pointer.  So we can safely\n\t * pass the ArrayBuildState pointer through nodeAgg.c's machinations.\n\t */\n\tPG_RETURN_POINTER(state);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_position_common(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "state"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accumArrayResult",
          "args": [
            "state",
            "elem",
            "PG_ARGISNULL(1)",
            "arg1_typeid",
            "aggcontext"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "accumArrayResultAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5524-5543",
          "snippet": "ArrayBuildStateAny *\naccumArrayResultAny(ArrayBuildStateAny *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid input_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tif (astate == NULL)\n\t\tastate = initArrayResultAny(input_type, rcontext, true);\n\n\tif (astate->scalarstate)\n\t\t(void) accumArrayResult(astate->scalarstate,\n\t\t\t\t\t\t\t\tdvalue, disnull,\n\t\t\t\t\t\t\t\tinput_type, rcontext);\n\telse\n\t\t(void) accumArrayResultArr(astate->arraystate,\n\t\t\t\t\t\t\t\t   dvalue, disnull,\n\t\t\t\t\t\t\t\t   input_type, rcontext);\n\n\treturn astate;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nArrayBuildStateAny *\naccumArrayResultAny(ArrayBuildStateAny *astate,\n\t\t\t\t\tDatum dvalue, bool disnull,\n\t\t\t\t\tOid input_type,\n\t\t\t\t\tMemoryContext rcontext)\n{\n\tif (astate == NULL)\n\t\tastate = initArrayResultAny(input_type, rcontext, true);\n\n\tif (astate->scalarstate)\n\t\t(void) accumArrayResult(astate->scalarstate,\n\t\t\t\t\t\t\t\tdvalue, disnull,\n\t\t\t\t\t\t\t\tinput_type, rcontext);\n\telse\n\t\t(void) accumArrayResultArr(astate->arraystate,\n\t\t\t\t\t\t\t\t   dvalue, disnull,\n\t\t\t\t\t\t\t\t   input_type, rcontext);\n\n\treturn astate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initArrayResult",
          "args": [
            "arg1_typeid",
            "aggcontext",
            "false"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "initArrayResultAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "5479-5514",
          "snippet": "ArrayBuildStateAny *\ninitArrayResultAny(Oid input_type, MemoryContext rcontext, bool subcontext)\n{\n\tArrayBuildStateAny *astate;\n\tOid\t\t\telement_type = get_element_type(input_type);\n\n\tif (OidIsValid(element_type))\n\t{\n\t\t/* Array case */\n\t\tArrayBuildStateArr *arraystate;\n\n\t\tarraystate = initArrayResultArr(input_type, InvalidOid, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(arraystate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = NULL;\n\t\tastate->arraystate = arraystate;\n\t}\n\telse\n\t{\n\t\t/* Scalar case */\n\t\tArrayBuildState *scalarstate;\n\n\t\t/* Let's just check that we have a type that can be put into arrays */\n\t\tAssert(OidIsValid(get_array_type(input_type)));\n\n\t\tscalarstate = initArrayResult(input_type, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(scalarstate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = scalarstate;\n\t\tastate->arraystate = NULL;\n\t}\n\n\treturn astate;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nArrayBuildStateAny *\ninitArrayResultAny(Oid input_type, MemoryContext rcontext, bool subcontext)\n{\n\tArrayBuildStateAny *astate;\n\tOid\t\t\telement_type = get_element_type(input_type);\n\n\tif (OidIsValid(element_type))\n\t{\n\t\t/* Array case */\n\t\tArrayBuildStateArr *arraystate;\n\n\t\tarraystate = initArrayResultArr(input_type, InvalidOid, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(arraystate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = NULL;\n\t\tastate->arraystate = arraystate;\n\t}\n\telse\n\t{\n\t\t/* Scalar case */\n\t\tArrayBuildState *scalarstate;\n\n\t\t/* Let's just check that we have a type that can be put into arrays */\n\t\tAssert(OidIsValid(get_array_type(input_type)));\n\n\t\tscalarstate = initArrayResult(input_type, rcontext, subcontext);\n\t\tastate = (ArrayBuildStateAny *)\n\t\t\tMemoryContextAlloc(scalarstate->mcontext,\n\t\t\t\t\t\t\t   sizeof(ArrayBuildStateAny));\n\t\tastate->scalarstate = scalarstate;\n\t\tastate->arraystate = NULL;\n\t}\n\n\treturn astate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"array_agg_transfn called in non-aggregate context\""
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "&aggcontext"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\"))"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not determine input data type\""
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "1"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic Datum array_position_common(FunctionCallInfo fcinfo);\n\nDatum\narray_agg_transfn(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1_typeid = get_fn_expr_argtype(fcinfo->flinfo, 1);\n\tMemoryContext aggcontext;\n\tArrayBuildState *state;\n\tDatum\t\telem;\n\n\tif (arg1_typeid == InvalidOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"could not determine input data type\")));\n\n\t/*\n\t * Note: we do not need a run-time check about whether arg1_typeid is a\n\t * valid array element type, because the parser would have verified that\n\t * while resolving the input/result types of this polymorphic aggregate.\n\t */\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"array_agg_transfn called in non-aggregate context\");\n\t}\n\n\tif (PG_ARGISNULL(0))\n\t\tstate = initArrayResult(arg1_typeid, aggcontext, false);\n\telse\n\t\tstate = (ArrayBuildState *) PG_GETARG_POINTER(0);\n\n\telem = PG_ARGISNULL(1) ? (Datum) 0 : PG_GETARG_DATUM(1);\n\n\tstate = accumArrayResult(state,\n\t\t\t\t\t\t\t elem,\n\t\t\t\t\t\t\t PG_ARGISNULL(1),\n\t\t\t\t\t\t\t arg1_typeid,\n\t\t\t\t\t\t\t aggcontext);\n\n\t/*\n\t * The transition type for array_agg() is declared to be \"internal\", which\n\t * is a pass-by-value type the same size as a pointer.  So we can safely\n\t * pass the ArrayBuildState pointer through nodeAgg.c's machinations.\n\t */\n\tPG_RETURN_POINTER(state);\n}"
  },
  {
    "function_name": "array_cat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_userfuncs.c",
    "lines": "217-449",
    "snippet": "Datum\narray_cat(PG_FUNCTION_ARGS)\n{\n\tArrayType  *v1,\n\t\t\t   *v2;\n\tArrayType  *result;\n\tint\t\t   *dims,\n\t\t\t   *lbs,\n\t\t\t\tndims,\n\t\t\t\tnitems,\n\t\t\t\tndatabytes,\n\t\t\t\tnbytes;\n\tint\t\t   *dims1,\n\t\t\t   *lbs1,\n\t\t\t\tndims1,\n\t\t\t\tnitems1,\n\t\t\t\tndatabytes1;\n\tint\t\t   *dims2,\n\t\t\t   *lbs2,\n\t\t\t\tndims2,\n\t\t\t\tnitems2,\n\t\t\t\tndatabytes2;\n\tint\t\t\ti;\n\tchar\t   *dat1,\n\t\t\t   *dat2;\n\tbits8\t   *bitmap1,\n\t\t\t   *bitmap2;\n\tOid\t\t\telement_type;\n\tOid\t\t\telement_type1;\n\tOid\t\t\telement_type2;\n\tint32\t\tdataoffset;\n\n\t/* Concatenating a null array is a no-op, just return the other input */\n\tif (PG_ARGISNULL(0))\n\t{\n\t\tif (PG_ARGISNULL(1))\n\t\t\tPG_RETURN_NULL();\n\t\tresult = PG_GETARG_ARRAYTYPE_P(1);\n\t\tPG_RETURN_ARRAYTYPE_P(result);\n\t}\n\tif (PG_ARGISNULL(1))\n\t{\n\t\tresult = PG_GETARG_ARRAYTYPE_P(0);\n\t\tPG_RETURN_ARRAYTYPE_P(result);\n\t}\n\n\tv1 = PG_GETARG_ARRAYTYPE_P(0);\n\tv2 = PG_GETARG_ARRAYTYPE_P(1);\n\n\telement_type1 = ARR_ELEMTYPE(v1);\n\telement_type2 = ARR_ELEMTYPE(v2);\n\n\t/* Check we have matching element types */\n\tif (element_type1 != element_type2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot concatenate incompatible arrays\"),\n\t\t\t\t errdetail(\"Arrays with element types %s and %s are not \"\n\t\t\t\t\t\t   \"compatible for concatenation.\",\n\t\t\t\t\t\t   format_type_be(element_type1),\n\t\t\t\t\t\t   format_type_be(element_type2))));\n\n\t/* OK, use it */\n\telement_type = element_type1;\n\n\t/*----------\n\t * We must have one of the following combinations of inputs:\n\t * 1) one empty array, and one non-empty array\n\t * 2) both arrays empty\n\t * 3) two arrays with ndims1 == ndims2\n\t * 4) ndims1 == ndims2 - 1\n\t * 5) ndims1 == ndims2 + 1\n\t *----------\n\t */\n\tndims1 = ARR_NDIM(v1);\n\tndims2 = ARR_NDIM(v2);\n\n\t/*\n\t * short circuit - if one input array is empty, and the other is not, we\n\t * return the non-empty one as the result\n\t *\n\t * if both are empty, return the first one\n\t */\n\tif (ndims1 == 0 && ndims2 > 0)\n\t\tPG_RETURN_ARRAYTYPE_P(v2);\n\n\tif (ndims2 == 0)\n\t\tPG_RETURN_ARRAYTYPE_P(v1);\n\n\t/* the rest fall under rule 3, 4, or 5 */\n\tif (ndims1 != ndims2 &&\n\t\tndims1 != ndims2 - 1 &&\n\t\tndims1 != ndims2 + 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"cannot concatenate incompatible arrays\"),\n\t\t\t\t errdetail(\"Arrays of %d and %d dimensions are not \"\n\t\t\t\t\t\t   \"compatible for concatenation.\",\n\t\t\t\t\t\t   ndims1, ndims2)));\n\n\t/* get argument array details */\n\tlbs1 = ARR_LBOUND(v1);\n\tlbs2 = ARR_LBOUND(v2);\n\tdims1 = ARR_DIMS(v1);\n\tdims2 = ARR_DIMS(v2);\n\tdat1 = ARR_DATA_PTR(v1);\n\tdat2 = ARR_DATA_PTR(v2);\n\tbitmap1 = ARR_NULLBITMAP(v1);\n\tbitmap2 = ARR_NULLBITMAP(v2);\n\tnitems1 = ArrayGetNItems(ndims1, dims1);\n\tnitems2 = ArrayGetNItems(ndims2, dims2);\n\tndatabytes1 = ARR_SIZE(v1) - ARR_DATA_OFFSET(v1);\n\tndatabytes2 = ARR_SIZE(v2) - ARR_DATA_OFFSET(v2);\n\n\tif (ndims1 == ndims2)\n\t{\n\t\t/*\n\t\t * resulting array is made up of the elements (possibly arrays\n\t\t * themselves) of the input argument arrays\n\t\t */\n\t\tndims = ndims1;\n\t\tdims = (int *) palloc(ndims * sizeof(int));\n\t\tlbs = (int *) palloc(ndims * sizeof(int));\n\n\t\tdims[0] = dims1[0] + dims2[0];\n\t\tlbs[0] = lbs1[0];\n\n\t\tfor (i = 1; i < ndims; i++)\n\t\t{\n\t\t\tif (dims1[i] != dims2[i] || lbs1[i] != lbs2[i])\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot concatenate incompatible arrays\"),\n\t\t\t\t\t\t errdetail(\"Arrays with differing element dimensions are \"\n\t\t\t\t\t\t\t\t   \"not compatible for concatenation.\")));\n\n\t\t\tdims[i] = dims1[i];\n\t\t\tlbs[i] = lbs1[i];\n\t\t}\n\t}\n\telse if (ndims1 == ndims2 - 1)\n\t{\n\t\t/*\n\t\t * resulting array has the second argument as the outer array, with\n\t\t * the first argument inserted at the front of the outer dimension\n\t\t */\n\t\tndims = ndims2;\n\t\tdims = (int *) palloc(ndims * sizeof(int));\n\t\tlbs = (int *) palloc(ndims * sizeof(int));\n\t\tmemcpy(dims, dims2, ndims * sizeof(int));\n\t\tmemcpy(lbs, lbs2, ndims * sizeof(int));\n\n\t\t/* increment number of elements in outer array */\n\t\tdims[0] += 1;\n\n\t\t/* make sure the added element matches our existing elements */\n\t\tfor (i = 0; i < ndims1; i++)\n\t\t{\n\t\t\tif (dims1[i] != dims[i + 1] || lbs1[i] != lbs[i + 1])\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot concatenate incompatible arrays\"),\n\t\t\t\t\t\t errdetail(\"Arrays with differing dimensions are not \"\n\t\t\t\t\t\t\t\t   \"compatible for concatenation.\")));\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * (ndims1 == ndims2 + 1)\n\t\t *\n\t\t * resulting array has the first argument as the outer array, with the\n\t\t * second argument appended to the end of the outer dimension\n\t\t */\n\t\tndims = ndims1;\n\t\tdims = (int *) palloc(ndims * sizeof(int));\n\t\tlbs = (int *) palloc(ndims * sizeof(int));\n\t\tmemcpy(dims, dims1, ndims * sizeof(int));\n\t\tmemcpy(lbs, lbs1, ndims * sizeof(int));\n\n\t\t/* increment number of elements in outer array */\n\t\tdims[0] += 1;\n\n\t\t/* make sure the added element matches our existing elements */\n\t\tfor (i = 0; i < ndims2; i++)\n\t\t{\n\t\t\tif (dims2[i] != dims[i + 1] || lbs2[i] != lbs[i + 1])\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot concatenate incompatible arrays\"),\n\t\t\t\t\t\t errdetail(\"Arrays with differing dimensions are not \"\n\t\t\t\t\t\t\t\t   \"compatible for concatenation.\")));\n\t\t}\n\t}\n\n\t/* Do this mainly for overflow checking */\n\tnitems = ArrayGetNItems(ndims, dims);\n\n\t/* build the result array */\n\tndatabytes = ndatabytes1 + ndatabytes2;\n\tif (ARR_HASNULL(v1) || ARR_HASNULL(v2))\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nitems);\n\t\tnbytes = ndatabytes + dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes = ndatabytes + ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = element_type;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\t/* data area is arg1 then arg2 */\n\tmemcpy(ARR_DATA_PTR(result), dat1, ndatabytes1);\n\tmemcpy(ARR_DATA_PTR(result) + ndatabytes1, dat2, ndatabytes2);\n\t/* handle the null bitmap if needed */\n\tif (ARR_HASNULL(result))\n\t{\n\t\tarray_bitmap_copy(ARR_NULLBITMAP(result), 0,\n\t\t\t\t\t\t  bitmap1, 0,\n\t\t\t\t\t\t  nitems1);\n\t\tarray_bitmap_copy(ARR_NULLBITMAP(result), nitems1,\n\t\t\t\t\t\t  bitmap2, 0,\n\t\t\t\t\t\t  nitems2);\n\t}\n\n\tPG_RETURN_ARRAYTYPE_P(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "result"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_bitmap_copy",
          "args": [
            "ARR_NULLBITMAP(result)",
            "nitems1",
            "bitmap2",
            "0",
            "nitems2"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "array_bitmap_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "4687-4751",
          "snippet": "void\narray_bitmap_copy(bits8 *destbitmap, int destoffset,\n\t\t\t\t  const bits8 *srcbitmap, int srcoffset,\n\t\t\t\t  int nitems)\n{\n\tint\t\t\tdestbitmask,\n\t\t\t\tdestbitval,\n\t\t\t\tsrcbitmask,\n\t\t\t\tsrcbitval;\n\n\tAssert(destbitmap);\n\tif (nitems <= 0)\n\t\treturn;\t\t\t\t\t/* don't risk fetch off end of memory */\n\tdestbitmap += destoffset / 8;\n\tdestbitmask = 1 << (destoffset % 8);\n\tdestbitval = *destbitmap;\n\tif (srcbitmap)\n\t{\n\t\tsrcbitmap += srcoffset / 8;\n\t\tsrcbitmask = 1 << (srcoffset % 8);\n\t\tsrcbitval = *srcbitmap;\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tif (srcbitval & srcbitmask)\n\t\t\t\tdestbitval |= destbitmask;\n\t\t\telse\n\t\t\t\tdestbitval &= ~destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t\tsrcbitmask <<= 1;\n\t\t\tif (srcbitmask == 0x100)\n\t\t\t{\n\t\t\t\tsrcbitmap++;\n\t\t\t\tsrcbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tsrcbitval = *srcbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n\telse\n\t{\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tdestbitval |= destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\narray_bitmap_copy(bits8 *destbitmap, int destoffset,\n\t\t\t\t  const bits8 *srcbitmap, int srcoffset,\n\t\t\t\t  int nitems)\n{\n\tint\t\t\tdestbitmask,\n\t\t\t\tdestbitval,\n\t\t\t\tsrcbitmask,\n\t\t\t\tsrcbitval;\n\n\tAssert(destbitmap);\n\tif (nitems <= 0)\n\t\treturn;\t\t\t\t\t/* don't risk fetch off end of memory */\n\tdestbitmap += destoffset / 8;\n\tdestbitmask = 1 << (destoffset % 8);\n\tdestbitval = *destbitmap;\n\tif (srcbitmap)\n\t{\n\t\tsrcbitmap += srcoffset / 8;\n\t\tsrcbitmask = 1 << (srcoffset % 8);\n\t\tsrcbitval = *srcbitmap;\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tif (srcbitval & srcbitmask)\n\t\t\t\tdestbitval |= destbitmask;\n\t\t\telse\n\t\t\t\tdestbitval &= ~destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t\tsrcbitmask <<= 1;\n\t\t\tif (srcbitmask == 0x100)\n\t\t\t{\n\t\t\t\tsrcbitmap++;\n\t\t\t\tsrcbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tsrcbitval = *srcbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n\telse\n\t{\n\t\twhile (nitems-- > 0)\n\t\t{\n\t\t\tdestbitval |= destbitmask;\n\t\t\tdestbitmask <<= 1;\n\t\t\tif (destbitmask == 0x100)\n\t\t\t{\n\t\t\t\t*destbitmap++ = destbitval;\n\t\t\t\tdestbitmask = 1;\n\t\t\t\tif (nitems > 0)\n\t\t\t\t\tdestbitval = *destbitmap;\n\t\t\t}\n\t\t}\n\t\tif (destbitmask != 1)\n\t\t\t*destbitmap = destbitval;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "result"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "result"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "result"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_DATA_PTR(result) + ndatabytes1",
            "dat2",
            "ndatabytes2"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "result"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_DATA_PTR(result)",
            "dat1",
            "ndatabytes1"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "result"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_LBOUND(result)",
            "lbs",
            "ndims * sizeof(int)"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "result"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ARR_DIMS(result)",
            "dims",
            "ndims * sizeof(int)"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "result"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "nbytes"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "nbytes"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_NONULLS",
          "args": [
            "ndims"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_OVERHEAD_WITHNULLS",
          "args": [
            "ndims",
            "nitems"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "v2"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "v1"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ArrayGetNItems",
          "args": [
            "ndims",
            "dims"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "ArrayGetNItems",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayutils.c",
          "lines": "74-112",
          "snippet": "int\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\nint\nArrayGetNItems(int ndim, const int *dims)\n{\n\tint32\t\tret;\n\tint\t\t\ti;\n\n#define MaxArraySize ((Size) (MaxAllocSize / sizeof(Datum)))\n\n\tif (ndim <= 0)\n\t\treturn 0;\n\tret = 1;\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tint64\t\tprod;\n\n\t\t/* A negative dimension implies that UB-LB overflowed ... */\n\t\tif (dims[i] < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\n\t\tprod = (int64) ret * (int64) dims[i];\n\n\t\tret = (int32) prod;\n\t\tif ((int64) ret != prod)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t\t(int) MaxArraySize)));\n\t}\n\tAssert(ret >= 0);\n\tif ((Size) ret > MaxArraySize)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"array size exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\t(int) MaxArraySize)));\n\treturn (int) ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot concatenate incompatible arrays\"),\n\t\t\t\t\t\t errdetail(\"Arrays with differing dimensions are not \"\n\t\t\t\t\t\t\t\t   \"compatible for concatenation.\"))"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Arrays with differing dimensions are not \"\n\t\t\t\t\t\t\t\t   \"compatible for concatenation.\""
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot concatenate incompatible arrays\""
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_ARRAY_SUBSCRIPT_ERROR"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "lbs",
            "lbs1",
            "ndims * sizeof(int)"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dims",
            "dims1",
            "ndims * sizeof(int)"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "ndims * sizeof(int)"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot concatenate incompatible arrays\"),\n\t\t\t\t\t\t errdetail(\"Arrays with differing dimensions are not \"\n\t\t\t\t\t\t\t\t   \"compatible for concatenation.\"))"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "lbs",
            "lbs2",
            "ndims * sizeof(int)"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dims",
            "dims2",
            "ndims * sizeof(int)"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot concatenate incompatible arrays\"),\n\t\t\t\t\t\t errdetail(\"Arrays with differing element dimensions are \"\n\t\t\t\t\t\t\t\t   \"not compatible for concatenation.\"))"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_OFFSET",
          "args": [
            "v2"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_SIZE",
          "args": [
            "v2"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_OFFSET",
          "args": [
            "v1"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_SIZE",
          "args": [
            "v1"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "v2"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NULLBITMAP",
          "args": [
            "v1"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "v2"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "v1"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "v2"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "v1"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "v2"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_LBOUND",
          "args": [
            "v1"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"cannot concatenate incompatible arrays\"),\n\t\t\t\t errdetail(\"Arrays of %d and %d dimensions are not \"\n\t\t\t\t\t\t   \"compatible for concatenation.\",\n\t\t\t\t\t\t   ndims1, ndims2))"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "v1"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "v2"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "v2"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "v1"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot concatenate incompatible arrays\"),\n\t\t\t\t errdetail(\"Arrays with element types %s and %s are not \"\n\t\t\t\t\t\t   \"compatible for concatenation.\",\n\t\t\t\t\t\t   format_type_be(element_type1),\n\t\t\t\t\t\t   format_type_be(element_type2)))"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "element_type2"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "v2"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "v1"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "result"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_ARRAYTYPE_P",
          "args": [
            "result"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\narray_cat(PG_FUNCTION_ARGS)\n{\n\tArrayType  *v1,\n\t\t\t   *v2;\n\tArrayType  *result;\n\tint\t\t   *dims,\n\t\t\t   *lbs,\n\t\t\t\tndims,\n\t\t\t\tnitems,\n\t\t\t\tndatabytes,\n\t\t\t\tnbytes;\n\tint\t\t   *dims1,\n\t\t\t   *lbs1,\n\t\t\t\tndims1,\n\t\t\t\tnitems1,\n\t\t\t\tndatabytes1;\n\tint\t\t   *dims2,\n\t\t\t   *lbs2,\n\t\t\t\tndims2,\n\t\t\t\tnitems2,\n\t\t\t\tndatabytes2;\n\tint\t\t\ti;\n\tchar\t   *dat1,\n\t\t\t   *dat2;\n\tbits8\t   *bitmap1,\n\t\t\t   *bitmap2;\n\tOid\t\t\telement_type;\n\tOid\t\t\telement_type1;\n\tOid\t\t\telement_type2;\n\tint32\t\tdataoffset;\n\n\t/* Concatenating a null array is a no-op, just return the other input */\n\tif (PG_ARGISNULL(0))\n\t{\n\t\tif (PG_ARGISNULL(1))\n\t\t\tPG_RETURN_NULL();\n\t\tresult = PG_GETARG_ARRAYTYPE_P(1);\n\t\tPG_RETURN_ARRAYTYPE_P(result);\n\t}\n\tif (PG_ARGISNULL(1))\n\t{\n\t\tresult = PG_GETARG_ARRAYTYPE_P(0);\n\t\tPG_RETURN_ARRAYTYPE_P(result);\n\t}\n\n\tv1 = PG_GETARG_ARRAYTYPE_P(0);\n\tv2 = PG_GETARG_ARRAYTYPE_P(1);\n\n\telement_type1 = ARR_ELEMTYPE(v1);\n\telement_type2 = ARR_ELEMTYPE(v2);\n\n\t/* Check we have matching element types */\n\tif (element_type1 != element_type2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"cannot concatenate incompatible arrays\"),\n\t\t\t\t errdetail(\"Arrays with element types %s and %s are not \"\n\t\t\t\t\t\t   \"compatible for concatenation.\",\n\t\t\t\t\t\t   format_type_be(element_type1),\n\t\t\t\t\t\t   format_type_be(element_type2))));\n\n\t/* OK, use it */\n\telement_type = element_type1;\n\n\t/*----------\n\t * We must have one of the following combinations of inputs:\n\t * 1) one empty array, and one non-empty array\n\t * 2) both arrays empty\n\t * 3) two arrays with ndims1 == ndims2\n\t * 4) ndims1 == ndims2 - 1\n\t * 5) ndims1 == ndims2 + 1\n\t *----------\n\t */\n\tndims1 = ARR_NDIM(v1);\n\tndims2 = ARR_NDIM(v2);\n\n\t/*\n\t * short circuit - if one input array is empty, and the other is not, we\n\t * return the non-empty one as the result\n\t *\n\t * if both are empty, return the first one\n\t */\n\tif (ndims1 == 0 && ndims2 > 0)\n\t\tPG_RETURN_ARRAYTYPE_P(v2);\n\n\tif (ndims2 == 0)\n\t\tPG_RETURN_ARRAYTYPE_P(v1);\n\n\t/* the rest fall under rule 3, 4, or 5 */\n\tif (ndims1 != ndims2 &&\n\t\tndims1 != ndims2 - 1 &&\n\t\tndims1 != ndims2 + 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"cannot concatenate incompatible arrays\"),\n\t\t\t\t errdetail(\"Arrays of %d and %d dimensions are not \"\n\t\t\t\t\t\t   \"compatible for concatenation.\",\n\t\t\t\t\t\t   ndims1, ndims2)));\n\n\t/* get argument array details */\n\tlbs1 = ARR_LBOUND(v1);\n\tlbs2 = ARR_LBOUND(v2);\n\tdims1 = ARR_DIMS(v1);\n\tdims2 = ARR_DIMS(v2);\n\tdat1 = ARR_DATA_PTR(v1);\n\tdat2 = ARR_DATA_PTR(v2);\n\tbitmap1 = ARR_NULLBITMAP(v1);\n\tbitmap2 = ARR_NULLBITMAP(v2);\n\tnitems1 = ArrayGetNItems(ndims1, dims1);\n\tnitems2 = ArrayGetNItems(ndims2, dims2);\n\tndatabytes1 = ARR_SIZE(v1) - ARR_DATA_OFFSET(v1);\n\tndatabytes2 = ARR_SIZE(v2) - ARR_DATA_OFFSET(v2);\n\n\tif (ndims1 == ndims2)\n\t{\n\t\t/*\n\t\t * resulting array is made up of the elements (possibly arrays\n\t\t * themselves) of the input argument arrays\n\t\t */\n\t\tndims = ndims1;\n\t\tdims = (int *) palloc(ndims * sizeof(int));\n\t\tlbs = (int *) palloc(ndims * sizeof(int));\n\n\t\tdims[0] = dims1[0] + dims2[0];\n\t\tlbs[0] = lbs1[0];\n\n\t\tfor (i = 1; i < ndims; i++)\n\t\t{\n\t\t\tif (dims1[i] != dims2[i] || lbs1[i] != lbs2[i])\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot concatenate incompatible arrays\"),\n\t\t\t\t\t\t errdetail(\"Arrays with differing element dimensions are \"\n\t\t\t\t\t\t\t\t   \"not compatible for concatenation.\")));\n\n\t\t\tdims[i] = dims1[i];\n\t\t\tlbs[i] = lbs1[i];\n\t\t}\n\t}\n\telse if (ndims1 == ndims2 - 1)\n\t{\n\t\t/*\n\t\t * resulting array has the second argument as the outer array, with\n\t\t * the first argument inserted at the front of the outer dimension\n\t\t */\n\t\tndims = ndims2;\n\t\tdims = (int *) palloc(ndims * sizeof(int));\n\t\tlbs = (int *) palloc(ndims * sizeof(int));\n\t\tmemcpy(dims, dims2, ndims * sizeof(int));\n\t\tmemcpy(lbs, lbs2, ndims * sizeof(int));\n\n\t\t/* increment number of elements in outer array */\n\t\tdims[0] += 1;\n\n\t\t/* make sure the added element matches our existing elements */\n\t\tfor (i = 0; i < ndims1; i++)\n\t\t{\n\t\t\tif (dims1[i] != dims[i + 1] || lbs1[i] != lbs[i + 1])\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot concatenate incompatible arrays\"),\n\t\t\t\t\t\t errdetail(\"Arrays with differing dimensions are not \"\n\t\t\t\t\t\t\t\t   \"compatible for concatenation.\")));\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * (ndims1 == ndims2 + 1)\n\t\t *\n\t\t * resulting array has the first argument as the outer array, with the\n\t\t * second argument appended to the end of the outer dimension\n\t\t */\n\t\tndims = ndims1;\n\t\tdims = (int *) palloc(ndims * sizeof(int));\n\t\tlbs = (int *) palloc(ndims * sizeof(int));\n\t\tmemcpy(dims, dims1, ndims * sizeof(int));\n\t\tmemcpy(lbs, lbs1, ndims * sizeof(int));\n\n\t\t/* increment number of elements in outer array */\n\t\tdims[0] += 1;\n\n\t\t/* make sure the added element matches our existing elements */\n\t\tfor (i = 0; i < ndims2; i++)\n\t\t{\n\t\t\tif (dims2[i] != dims[i + 1] || lbs2[i] != lbs[i + 1])\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"cannot concatenate incompatible arrays\"),\n\t\t\t\t\t\t errdetail(\"Arrays with differing dimensions are not \"\n\t\t\t\t\t\t\t\t   \"compatible for concatenation.\")));\n\t\t}\n\t}\n\n\t/* Do this mainly for overflow checking */\n\tnitems = ArrayGetNItems(ndims, dims);\n\n\t/* build the result array */\n\tndatabytes = ndatabytes1 + ndatabytes2;\n\tif (ARR_HASNULL(v1) || ARR_HASNULL(v2))\n\t{\n\t\tdataoffset = ARR_OVERHEAD_WITHNULLS(ndims, nitems);\n\t\tnbytes = ndatabytes + dataoffset;\n\t}\n\telse\n\t{\n\t\tdataoffset = 0;\t\t\t/* marker for no null bitmap */\n\t\tnbytes = ndatabytes + ARR_OVERHEAD_NONULLS(ndims);\n\t}\n\tresult = (ArrayType *) palloc0(nbytes);\n\tSET_VARSIZE(result, nbytes);\n\tresult->ndim = ndims;\n\tresult->dataoffset = dataoffset;\n\tresult->elemtype = element_type;\n\tmemcpy(ARR_DIMS(result), dims, ndims * sizeof(int));\n\tmemcpy(ARR_LBOUND(result), lbs, ndims * sizeof(int));\n\t/* data area is arg1 then arg2 */\n\tmemcpy(ARR_DATA_PTR(result), dat1, ndatabytes1);\n\tmemcpy(ARR_DATA_PTR(result) + ndatabytes1, dat2, ndatabytes2);\n\t/* handle the null bitmap if needed */\n\tif (ARR_HASNULL(result))\n\t{\n\t\tarray_bitmap_copy(ARR_NULLBITMAP(result), 0,\n\t\t\t\t\t\t  bitmap1, 0,\n\t\t\t\t\t\t  nitems1);\n\t\tarray_bitmap_copy(ARR_NULLBITMAP(result), nitems1,\n\t\t\t\t\t\t  bitmap2, 0,\n\t\t\t\t\t\t  nitems2);\n\t}\n\n\tPG_RETURN_ARRAYTYPE_P(result);\n}"
  },
  {
    "function_name": "array_prepend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_userfuncs.c",
    "lines": "153-209",
    "snippet": "Datum\narray_prepend(PG_FUNCTION_ARGS)\n{\n\tExpandedArrayHeader *eah;\n\tDatum\t\tnewelem;\n\tbool\t\tisNull;\n\tDatum\t\tresult;\n\tint\t\t   *lb;\n\tint\t\t\tindx;\n\tint\t\t\tlb0;\n\tArrayMetaState *my_extra;\n\n\tisNull = PG_ARGISNULL(0);\n\tif (isNull)\n\t\tnewelem = (Datum) 0;\n\telse\n\t\tnewelem = PG_GETARG_DATUM(0);\n\teah = fetch_array_arg_replace_nulls(fcinfo, 1);\n\n\tif (eah->ndims == 1)\n\t{\n\t\t/* prepend newelem */\n\t\tlb = eah->lbound;\n\t\tlb0 = lb[0];\n\n\t\tif (pg_sub_s32_overflow(lb0, 1, &indx))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"integer out of range\")));\n\t}\n\telse if (eah->ndims == 0)\n\t{\n\t\tindx = 1;\n\t\tlb0 = 1;\n\t}\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"argument must be empty or one-dimensional array\")));\n\n\t/* Perform element insertion */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\n\tresult = array_set_element(EOHPGetRWDatum(&eah->hdr),\n\t\t\t\t\t\t\t   1, &indx, newelem, isNull,\n\t\t\t\t\t\t\t   -1, my_extra->typlen, my_extra->typbyval, my_extra->typalign);\n\n\t/* Readjust result's LB to match the input's, as expected for prepend */\n\tAssert(result == EOHPGetRWDatum(&eah->hdr));\n\tif (eah->ndims == 1)\n\t{\n\t\t/* This is ok whether we've deconstructed or not */\n\t\teah->lbound[0] = lb0;\n\t}\n\n\tPG_RETURN_DATUM(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_position_common(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "result"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "result == EOHPGetRWDatum(&eah->hdr)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EOHPGetRWDatum",
          "args": [
            "&eah->hdr"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_set_element",
          "args": [
            "EOHPGetRWDatum(&eah->hdr)",
            "1",
            "&indx",
            "newelem",
            "isNull",
            "-1",
            "my_extra->typlen",
            "my_extra->typbyval",
            "my_extra->typalign"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "array_set_element_expanded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "2480-2716",
          "snippet": "static Datum\narray_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign)\n{\n\tExpandedArrayHeader *eah;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t\tdim[MAXDIM],\n\t\t\t\tlb[MAXDIM],\n\t\t\t\toffset;\n\tbool\t\tdimschanged,\n\t\t\t\tnewhasnulls;\n\tint\t\t\taddedbefore,\n\t\t\t\taddedafter;\n\tchar\t   *oldValue;\n\n\t/* Convert to R/W object if not so already */\n\teah = DatumGetExpandedArray(arraydatum);\n\n\t/* Sanity-check caller's info against object; we don't use it otherwise */\n\tAssert(arraytyplen == -1);\n\tAssert(elmlen == eah->typlen);\n\tAssert(elmbyval == eah->typbyval);\n\tAssert(elmalign == eah->typalign);\n\n\t/*\n\t * Copy dimension info into local storage.  This allows us to modify the\n\t * dimensions if needed, while not messing up the expanded value if we\n\t * fail partway through.\n\t */\n\tndim = eah->ndims;\n\tAssert(ndim >= 0 && ndim <= MAXDIM);\n\tmemcpy(dim, eah->dims, ndim * sizeof(int));\n\tmemcpy(lb, eah->lbound, ndim * sizeof(int));\n\tdimschanged = false;\n\n\t/*\n\t * if number of dims is zero, i.e. an empty array, create an array with\n\t * nSubscripts dimensions, and set the lower bounds to the supplied\n\t * subscripts.\n\t */\n\tif (ndim == 0)\n\t{\n\t\t/*\n\t\t * Allocate adequate space for new dimension info.  This is harmless\n\t\t * if we fail later.\n\t\t */\n\t\tAssert(nSubscripts > 0 && nSubscripts <= MAXDIM);\n\t\teah->dims = (int *) MemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t\t   nSubscripts * sizeof(int));\n\t\teah->lbound = (int *) MemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t\t\t nSubscripts * sizeof(int));\n\n\t\t/* Update local copies of dimension info */\n\t\tndim = nSubscripts;\n\t\tfor (i = 0; i < nSubscripts; i++)\n\t\t{\n\t\t\tdim[i] = 0;\n\t\t\tlb[i] = indx[i];\n\t\t}\n\t\tdimschanged = true;\n\t}\n\telse if (ndim != nSubscripts)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t/*\n\t * Deconstruct array if we didn't already.  (Someday maybe add a special\n\t * case path for fixed-length, no-nulls cases, where we can overwrite an\n\t * element in place without ever deconstructing.  But today is not that\n\t * day.)\n\t */\n\tdeconstruct_expanded_array(eah);\n\n\t/*\n\t * Copy new element into array's context, if needed (we assume it's\n\t * already detoasted, so no junk should be created).  If we fail further\n\t * down, this memory is leaked, but that's reasonably harmless.\n\t */\n\tif (!eah->typbyval && !isNull)\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(eah->hdr.eoh_context);\n\n\t\tdataValue = datumCopy(dataValue, false, eah->typlen);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\tdvalues = eah->dvalues;\n\tdnulls = eah->dnulls;\n\n\tnewhasnulls = ((dnulls != NULL) || isNull);\n\taddedbefore = addedafter = 0;\n\n\t/*\n\t * Check subscripts (this logic matches original array_set_element)\n\t */\n\tif (ndim == 1)\n\t{\n\t\tif (indx[0] < lb[0])\n\t\t{\n\t\t\taddedbefore = lb[0] - indx[0];\n\t\t\tdim[0] += addedbefore;\n\t\t\tlb[0] = indx[0];\n\t\t\tdimschanged = true;\n\t\t\tif (addedbefore > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t\tif (indx[0] >= (dim[0] + lb[0]))\n\t\t{\n\t\t\taddedafter = indx[0] - (dim[0] + lb[0]) + 1;\n\t\t\tdim[0] += addedafter;\n\t\t\tdimschanged = true;\n\t\t\tif (addedafter > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * XXX currently we do not support extending multi-dimensional arrays\n\t\t * during assignment\n\t\t */\n\t\tfor (i = 0; i < ndim; i++)\n\t\t{\n\t\t\tif (indx[i] < lb[i] ||\n\t\t\t\tindx[i] >= (dim[i] + lb[i]))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array subscript out of range\")));\n\t\t}\n\t}\n\n\t/* Now we can calculate linear offset of target item in array */\n\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\n\t/* Physically enlarge existing dvalues/dnulls arrays if needed */\n\tif (dim[0] > eah->dvalueslen)\n\t{\n\t\t/* We want some extra space if we're enlarging */\n\t\tint\t\t\tnewlen = dim[0] + dim[0] / 8;\n\n\t\tnewlen = Max(newlen, dim[0]);\t/* integer overflow guard */\n\t\teah->dvalues = dvalues = (Datum *)\n\t\t\trepalloc(dvalues, newlen * sizeof(Datum));\n\t\tif (dnulls)\n\t\t\teah->dnulls = dnulls = (bool *)\n\t\t\t\trepalloc(dnulls, newlen * sizeof(bool));\n\t\teah->dvalueslen = newlen;\n\t}\n\n\t/*\n\t * If we need a nulls bitmap and don't already have one, create it, being\n\t * sure to mark all existing entries as not null.\n\t */\n\tif (newhasnulls && dnulls == NULL)\n\t\teah->dnulls = dnulls = (bool *)\n\t\t\tMemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   eah->dvalueslen * sizeof(bool));\n\n\t/*\n\t * We now have all the needed space allocated, so we're ready to make\n\t * irreversible changes.  Be very wary of allowing failure below here.\n\t */\n\n\t/* Flattened value will no longer represent array accurately */\n\teah->fvalue = NULL;\n\t/* And we don't know the flattened size either */\n\teah->flat_size = 0;\n\n\t/* Update dimensionality info if needed */\n\tif (dimschanged)\n\t{\n\t\teah->ndims = ndim;\n\t\tmemcpy(eah->dims, dim, ndim * sizeof(int));\n\t\tmemcpy(eah->lbound, lb, ndim * sizeof(int));\n\t}\n\n\t/* Reposition items if needed, and fill addedbefore items with nulls */\n\tif (addedbefore > 0)\n\t{\n\t\tmemmove(dvalues + addedbefore, dvalues, eah->nelems * sizeof(Datum));\n\t\tfor (i = 0; i < addedbefore; i++)\n\t\t\tdvalues[i] = (Datum) 0;\n\t\tif (dnulls)\n\t\t{\n\t\t\tmemmove(dnulls + addedbefore, dnulls, eah->nelems * sizeof(bool));\n\t\t\tfor (i = 0; i < addedbefore; i++)\n\t\t\t\tdnulls[i] = true;\n\t\t}\n\t\teah->nelems += addedbefore;\n\t}\n\n\t/* fill addedafter items with nulls */\n\tif (addedafter > 0)\n\t{\n\t\tfor (i = 0; i < addedafter; i++)\n\t\t\tdvalues[eah->nelems + i] = (Datum) 0;\n\t\tif (dnulls)\n\t\t{\n\t\t\tfor (i = 0; i < addedafter; i++)\n\t\t\t\tdnulls[eah->nelems + i] = true;\n\t\t}\n\t\teah->nelems += addedafter;\n\t}\n\n\t/* Grab old element value for pfree'ing, if needed. */\n\tif (!eah->typbyval && (dnulls == NULL || !dnulls[offset]))\n\t\toldValue = (char *) DatumGetPointer(dvalues[offset]);\n\telse\n\t\toldValue = NULL;\n\n\t/* And finally we can insert the new element. */\n\tdvalues[offset] = dataValue;\n\tif (dnulls)\n\t\tdnulls[offset] = isNull;\n\n\t/*\n\t * Free old element if needed; this keeps repeated element replacements\n\t * from bloating the array's storage.  If the pfree somehow fails, it\n\t * won't corrupt the array.\n\t */\n\tif (oldValue)\n\t{\n\t\t/* Don't try to pfree a part of the original flat array */\n\t\tif (oldValue < eah->fstartptr || oldValue >= eah->fendptr)\n\t\t\tpfree(oldValue);\n\t}\n\n\t/* Done, return standard TOAST pointer for object */\n\treturn EOHPGetRWDatum(&eah->hdr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);",
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
            "static void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic Datum\narray_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign)\n{\n\tExpandedArrayHeader *eah;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t\tdim[MAXDIM],\n\t\t\t\tlb[MAXDIM],\n\t\t\t\toffset;\n\tbool\t\tdimschanged,\n\t\t\t\tnewhasnulls;\n\tint\t\t\taddedbefore,\n\t\t\t\taddedafter;\n\tchar\t   *oldValue;\n\n\t/* Convert to R/W object if not so already */\n\teah = DatumGetExpandedArray(arraydatum);\n\n\t/* Sanity-check caller's info against object; we don't use it otherwise */\n\tAssert(arraytyplen == -1);\n\tAssert(elmlen == eah->typlen);\n\tAssert(elmbyval == eah->typbyval);\n\tAssert(elmalign == eah->typalign);\n\n\t/*\n\t * Copy dimension info into local storage.  This allows us to modify the\n\t * dimensions if needed, while not messing up the expanded value if we\n\t * fail partway through.\n\t */\n\tndim = eah->ndims;\n\tAssert(ndim >= 0 && ndim <= MAXDIM);\n\tmemcpy(dim, eah->dims, ndim * sizeof(int));\n\tmemcpy(lb, eah->lbound, ndim * sizeof(int));\n\tdimschanged = false;\n\n\t/*\n\t * if number of dims is zero, i.e. an empty array, create an array with\n\t * nSubscripts dimensions, and set the lower bounds to the supplied\n\t * subscripts.\n\t */\n\tif (ndim == 0)\n\t{\n\t\t/*\n\t\t * Allocate adequate space for new dimension info.  This is harmless\n\t\t * if we fail later.\n\t\t */\n\t\tAssert(nSubscripts > 0 && nSubscripts <= MAXDIM);\n\t\teah->dims = (int *) MemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t\t   nSubscripts * sizeof(int));\n\t\teah->lbound = (int *) MemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t\t\t nSubscripts * sizeof(int));\n\n\t\t/* Update local copies of dimension info */\n\t\tndim = nSubscripts;\n\t\tfor (i = 0; i < nSubscripts; i++)\n\t\t{\n\t\t\tdim[i] = 0;\n\t\t\tlb[i] = indx[i];\n\t\t}\n\t\tdimschanged = true;\n\t}\n\telse if (ndim != nSubscripts)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t/*\n\t * Deconstruct array if we didn't already.  (Someday maybe add a special\n\t * case path for fixed-length, no-nulls cases, where we can overwrite an\n\t * element in place without ever deconstructing.  But today is not that\n\t * day.)\n\t */\n\tdeconstruct_expanded_array(eah);\n\n\t/*\n\t * Copy new element into array's context, if needed (we assume it's\n\t * already detoasted, so no junk should be created).  If we fail further\n\t * down, this memory is leaked, but that's reasonably harmless.\n\t */\n\tif (!eah->typbyval && !isNull)\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(eah->hdr.eoh_context);\n\n\t\tdataValue = datumCopy(dataValue, false, eah->typlen);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\tdvalues = eah->dvalues;\n\tdnulls = eah->dnulls;\n\n\tnewhasnulls = ((dnulls != NULL) || isNull);\n\taddedbefore = addedafter = 0;\n\n\t/*\n\t * Check subscripts (this logic matches original array_set_element)\n\t */\n\tif (ndim == 1)\n\t{\n\t\tif (indx[0] < lb[0])\n\t\t{\n\t\t\taddedbefore = lb[0] - indx[0];\n\t\t\tdim[0] += addedbefore;\n\t\t\tlb[0] = indx[0];\n\t\t\tdimschanged = true;\n\t\t\tif (addedbefore > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t\tif (indx[0] >= (dim[0] + lb[0]))\n\t\t{\n\t\t\taddedafter = indx[0] - (dim[0] + lb[0]) + 1;\n\t\t\tdim[0] += addedafter;\n\t\t\tdimschanged = true;\n\t\t\tif (addedafter > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * XXX currently we do not support extending multi-dimensional arrays\n\t\t * during assignment\n\t\t */\n\t\tfor (i = 0; i < ndim; i++)\n\t\t{\n\t\t\tif (indx[i] < lb[i] ||\n\t\t\t\tindx[i] >= (dim[i] + lb[i]))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array subscript out of range\")));\n\t\t}\n\t}\n\n\t/* Now we can calculate linear offset of target item in array */\n\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\n\t/* Physically enlarge existing dvalues/dnulls arrays if needed */\n\tif (dim[0] > eah->dvalueslen)\n\t{\n\t\t/* We want some extra space if we're enlarging */\n\t\tint\t\t\tnewlen = dim[0] + dim[0] / 8;\n\n\t\tnewlen = Max(newlen, dim[0]);\t/* integer overflow guard */\n\t\teah->dvalues = dvalues = (Datum *)\n\t\t\trepalloc(dvalues, newlen * sizeof(Datum));\n\t\tif (dnulls)\n\t\t\teah->dnulls = dnulls = (bool *)\n\t\t\t\trepalloc(dnulls, newlen * sizeof(bool));\n\t\teah->dvalueslen = newlen;\n\t}\n\n\t/*\n\t * If we need a nulls bitmap and don't already have one, create it, being\n\t * sure to mark all existing entries as not null.\n\t */\n\tif (newhasnulls && dnulls == NULL)\n\t\teah->dnulls = dnulls = (bool *)\n\t\t\tMemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   eah->dvalueslen * sizeof(bool));\n\n\t/*\n\t * We now have all the needed space allocated, so we're ready to make\n\t * irreversible changes.  Be very wary of allowing failure below here.\n\t */\n\n\t/* Flattened value will no longer represent array accurately */\n\teah->fvalue = NULL;\n\t/* And we don't know the flattened size either */\n\teah->flat_size = 0;\n\n\t/* Update dimensionality info if needed */\n\tif (dimschanged)\n\t{\n\t\teah->ndims = ndim;\n\t\tmemcpy(eah->dims, dim, ndim * sizeof(int));\n\t\tmemcpy(eah->lbound, lb, ndim * sizeof(int));\n\t}\n\n\t/* Reposition items if needed, and fill addedbefore items with nulls */\n\tif (addedbefore > 0)\n\t{\n\t\tmemmove(dvalues + addedbefore, dvalues, eah->nelems * sizeof(Datum));\n\t\tfor (i = 0; i < addedbefore; i++)\n\t\t\tdvalues[i] = (Datum) 0;\n\t\tif (dnulls)\n\t\t{\n\t\t\tmemmove(dnulls + addedbefore, dnulls, eah->nelems * sizeof(bool));\n\t\t\tfor (i = 0; i < addedbefore; i++)\n\t\t\t\tdnulls[i] = true;\n\t\t}\n\t\teah->nelems += addedbefore;\n\t}\n\n\t/* fill addedafter items with nulls */\n\tif (addedafter > 0)\n\t{\n\t\tfor (i = 0; i < addedafter; i++)\n\t\t\tdvalues[eah->nelems + i] = (Datum) 0;\n\t\tif (dnulls)\n\t\t{\n\t\t\tfor (i = 0; i < addedafter; i++)\n\t\t\t\tdnulls[eah->nelems + i] = true;\n\t\t}\n\t\teah->nelems += addedafter;\n\t}\n\n\t/* Grab old element value for pfree'ing, if needed. */\n\tif (!eah->typbyval && (dnulls == NULL || !dnulls[offset]))\n\t\toldValue = (char *) DatumGetPointer(dvalues[offset]);\n\telse\n\t\toldValue = NULL;\n\n\t/* And finally we can insert the new element. */\n\tdvalues[offset] = dataValue;\n\tif (dnulls)\n\t\tdnulls[offset] = isNull;\n\n\t/*\n\t * Free old element if needed; this keeps repeated element replacements\n\t * from bloating the array's storage.  If the pfree somehow fails, it\n\t * won't corrupt the array.\n\t */\n\tif (oldValue)\n\t{\n\t\t/* Don't try to pfree a part of the original flat array */\n\t\tif (oldValue < eah->fstartptr || oldValue >= eah->fendptr)\n\t\t\tpfree(oldValue);\n\t}\n\n\t/* Done, return standard TOAST pointer for object */\n\treturn EOHPGetRWDatum(&eah->hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EOHPGetRWDatum",
          "args": [
            "&eah->hdr"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"argument must be empty or one-dimensional array\"))"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"argument must be empty or one-dimensional array\""
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATA_EXCEPTION"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"integer out of range\"))"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_sub_s32_overflow",
          "args": [
            "lb0",
            "1",
            "&indx"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fetch_array_arg_replace_nulls",
          "args": [
            "fcinfo",
            "1"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_array_arg_replace_nulls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_userfuncs.c",
          "lines": "41-93",
          "snippet": "static ExpandedArrayHeader *\nfetch_array_arg_replace_nulls(FunctionCallInfo fcinfo, int argno)\n{\n\tExpandedArrayHeader *eah;\n\tOid\t\t\telement_type;\n\tArrayMetaState *my_extra;\n\tMemoryContext resultcxt;\n\n\t/* If first time through, create datatype cache struct */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tmy_extra = (ArrayMetaState *)\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   sizeof(ArrayMetaState));\n\t\tmy_extra->element_type = InvalidOid;\n\t\tfcinfo->flinfo->fn_extra = my_extra;\n\t}\n\n\t/* Figure out which context we want the result in */\n\tif (!AggCheckCallContext(fcinfo, &resultcxt))\n\t\tresultcxt = CurrentMemoryContext;\n\n\t/* Now collect the array value */\n\tif (!PG_ARGISNULL(argno))\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(resultcxt);\n\n\t\teah = PG_GETARG_EXPANDED_ARRAYX(argno, my_extra);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse\n\t{\n\t\t/* We have to look up the array type and element type */\n\t\tOid\t\t\tarr_typeid = get_fn_expr_argtype(fcinfo->flinfo, argno);\n\n\t\tif (!OidIsValid(arr_typeid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine input data type\")));\n\t\telement_type = get_element_type(arr_typeid);\n\t\tif (!OidIsValid(element_type))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"input data type is not an array\")));\n\n\t\teah = construct_empty_expanded_array(element_type,\n\t\t\t\t\t\t\t\t\t\t\t resultcxt,\n\t\t\t\t\t\t\t\t\t\t\t my_extra);\n\t}\n\n\treturn eah;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_position_common(FunctionCallInfo fcinfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic Datum array_position_common(FunctionCallInfo fcinfo);\n\nstatic ExpandedArrayHeader *\nfetch_array_arg_replace_nulls(FunctionCallInfo fcinfo, int argno)\n{\n\tExpandedArrayHeader *eah;\n\tOid\t\t\telement_type;\n\tArrayMetaState *my_extra;\n\tMemoryContext resultcxt;\n\n\t/* If first time through, create datatype cache struct */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tmy_extra = (ArrayMetaState *)\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   sizeof(ArrayMetaState));\n\t\tmy_extra->element_type = InvalidOid;\n\t\tfcinfo->flinfo->fn_extra = my_extra;\n\t}\n\n\t/* Figure out which context we want the result in */\n\tif (!AggCheckCallContext(fcinfo, &resultcxt))\n\t\tresultcxt = CurrentMemoryContext;\n\n\t/* Now collect the array value */\n\tif (!PG_ARGISNULL(argno))\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(resultcxt);\n\n\t\teah = PG_GETARG_EXPANDED_ARRAYX(argno, my_extra);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse\n\t{\n\t\t/* We have to look up the array type and element type */\n\t\tOid\t\t\tarr_typeid = get_fn_expr_argtype(fcinfo->flinfo, argno);\n\n\t\tif (!OidIsValid(arr_typeid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine input data type\")));\n\t\telement_type = get_element_type(arr_typeid);\n\t\tif (!OidIsValid(element_type))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"input data type is not an array\")));\n\n\t\teah = construct_empty_expanded_array(element_type,\n\t\t\t\t\t\t\t\t\t\t\t resultcxt,\n\t\t\t\t\t\t\t\t\t\t\t my_extra);\n\t}\n\n\treturn eah;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic Datum array_position_common(FunctionCallInfo fcinfo);\n\nDatum\narray_prepend(PG_FUNCTION_ARGS)\n{\n\tExpandedArrayHeader *eah;\n\tDatum\t\tnewelem;\n\tbool\t\tisNull;\n\tDatum\t\tresult;\n\tint\t\t   *lb;\n\tint\t\t\tindx;\n\tint\t\t\tlb0;\n\tArrayMetaState *my_extra;\n\n\tisNull = PG_ARGISNULL(0);\n\tif (isNull)\n\t\tnewelem = (Datum) 0;\n\telse\n\t\tnewelem = PG_GETARG_DATUM(0);\n\teah = fetch_array_arg_replace_nulls(fcinfo, 1);\n\n\tif (eah->ndims == 1)\n\t{\n\t\t/* prepend newelem */\n\t\tlb = eah->lbound;\n\t\tlb0 = lb[0];\n\n\t\tif (pg_sub_s32_overflow(lb0, 1, &indx))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"integer out of range\")));\n\t}\n\telse if (eah->ndims == 0)\n\t{\n\t\tindx = 1;\n\t\tlb0 = 1;\n\t}\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"argument must be empty or one-dimensional array\")));\n\n\t/* Perform element insertion */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\n\tresult = array_set_element(EOHPGetRWDatum(&eah->hdr),\n\t\t\t\t\t\t\t   1, &indx, newelem, isNull,\n\t\t\t\t\t\t\t   -1, my_extra->typlen, my_extra->typbyval, my_extra->typalign);\n\n\t/* Readjust result's LB to match the input's, as expected for prepend */\n\tAssert(result == EOHPGetRWDatum(&eah->hdr));\n\tif (eah->ndims == 1)\n\t{\n\t\t/* This is ok whether we've deconstructed or not */\n\t\teah->lbound[0] = lb0;\n\t}\n\n\tPG_RETURN_DATUM(result);\n}"
  },
  {
    "function_name": "array_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_userfuncs.c",
    "lines": "100-146",
    "snippet": "Datum\narray_append(PG_FUNCTION_ARGS)\n{\n\tExpandedArrayHeader *eah;\n\tDatum\t\tnewelem;\n\tbool\t\tisNull;\n\tDatum\t\tresult;\n\tint\t\t   *dimv,\n\t\t\t   *lb;\n\tint\t\t\tindx;\n\tArrayMetaState *my_extra;\n\n\teah = fetch_array_arg_replace_nulls(fcinfo, 0);\n\tisNull = PG_ARGISNULL(1);\n\tif (isNull)\n\t\tnewelem = (Datum) 0;\n\telse\n\t\tnewelem = PG_GETARG_DATUM(1);\n\n\tif (eah->ndims == 1)\n\t{\n\t\t/* append newelem */\n\t\tlb = eah->lbound;\n\t\tdimv = eah->dims;\n\n\t\t/* index of added elem is at lb[0] + (dimv[0] - 1) + 1 */\n\t\tif (pg_add_s32_overflow(lb[0], dimv[0], &indx))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"integer out of range\")));\n\t}\n\telse if (eah->ndims == 0)\n\t\tindx = 1;\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"argument must be empty or one-dimensional array\")));\n\n\t/* Perform element insertion */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\n\tresult = array_set_element(EOHPGetRWDatum(&eah->hdr),\n\t\t\t\t\t\t\t   1, &indx, newelem, isNull,\n\t\t\t\t\t\t\t   -1, my_extra->typlen, my_extra->typbyval, my_extra->typalign);\n\n\tPG_RETURN_DATUM(result);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_position_common(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "result"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_set_element",
          "args": [
            "EOHPGetRWDatum(&eah->hdr)",
            "1",
            "&indx",
            "newelem",
            "isNull",
            "-1",
            "my_extra->typlen",
            "my_extra->typbyval",
            "my_extra->typalign"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "array_set_element_expanded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "2480-2716",
          "snippet": "static Datum\narray_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign)\n{\n\tExpandedArrayHeader *eah;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t\tdim[MAXDIM],\n\t\t\t\tlb[MAXDIM],\n\t\t\t\toffset;\n\tbool\t\tdimschanged,\n\t\t\t\tnewhasnulls;\n\tint\t\t\taddedbefore,\n\t\t\t\taddedafter;\n\tchar\t   *oldValue;\n\n\t/* Convert to R/W object if not so already */\n\teah = DatumGetExpandedArray(arraydatum);\n\n\t/* Sanity-check caller's info against object; we don't use it otherwise */\n\tAssert(arraytyplen == -1);\n\tAssert(elmlen == eah->typlen);\n\tAssert(elmbyval == eah->typbyval);\n\tAssert(elmalign == eah->typalign);\n\n\t/*\n\t * Copy dimension info into local storage.  This allows us to modify the\n\t * dimensions if needed, while not messing up the expanded value if we\n\t * fail partway through.\n\t */\n\tndim = eah->ndims;\n\tAssert(ndim >= 0 && ndim <= MAXDIM);\n\tmemcpy(dim, eah->dims, ndim * sizeof(int));\n\tmemcpy(lb, eah->lbound, ndim * sizeof(int));\n\tdimschanged = false;\n\n\t/*\n\t * if number of dims is zero, i.e. an empty array, create an array with\n\t * nSubscripts dimensions, and set the lower bounds to the supplied\n\t * subscripts.\n\t */\n\tif (ndim == 0)\n\t{\n\t\t/*\n\t\t * Allocate adequate space for new dimension info.  This is harmless\n\t\t * if we fail later.\n\t\t */\n\t\tAssert(nSubscripts > 0 && nSubscripts <= MAXDIM);\n\t\teah->dims = (int *) MemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t\t   nSubscripts * sizeof(int));\n\t\teah->lbound = (int *) MemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t\t\t nSubscripts * sizeof(int));\n\n\t\t/* Update local copies of dimension info */\n\t\tndim = nSubscripts;\n\t\tfor (i = 0; i < nSubscripts; i++)\n\t\t{\n\t\t\tdim[i] = 0;\n\t\t\tlb[i] = indx[i];\n\t\t}\n\t\tdimschanged = true;\n\t}\n\telse if (ndim != nSubscripts)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t/*\n\t * Deconstruct array if we didn't already.  (Someday maybe add a special\n\t * case path for fixed-length, no-nulls cases, where we can overwrite an\n\t * element in place without ever deconstructing.  But today is not that\n\t * day.)\n\t */\n\tdeconstruct_expanded_array(eah);\n\n\t/*\n\t * Copy new element into array's context, if needed (we assume it's\n\t * already detoasted, so no junk should be created).  If we fail further\n\t * down, this memory is leaked, but that's reasonably harmless.\n\t */\n\tif (!eah->typbyval && !isNull)\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(eah->hdr.eoh_context);\n\n\t\tdataValue = datumCopy(dataValue, false, eah->typlen);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\tdvalues = eah->dvalues;\n\tdnulls = eah->dnulls;\n\n\tnewhasnulls = ((dnulls != NULL) || isNull);\n\taddedbefore = addedafter = 0;\n\n\t/*\n\t * Check subscripts (this logic matches original array_set_element)\n\t */\n\tif (ndim == 1)\n\t{\n\t\tif (indx[0] < lb[0])\n\t\t{\n\t\t\taddedbefore = lb[0] - indx[0];\n\t\t\tdim[0] += addedbefore;\n\t\t\tlb[0] = indx[0];\n\t\t\tdimschanged = true;\n\t\t\tif (addedbefore > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t\tif (indx[0] >= (dim[0] + lb[0]))\n\t\t{\n\t\t\taddedafter = indx[0] - (dim[0] + lb[0]) + 1;\n\t\t\tdim[0] += addedafter;\n\t\t\tdimschanged = true;\n\t\t\tif (addedafter > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * XXX currently we do not support extending multi-dimensional arrays\n\t\t * during assignment\n\t\t */\n\t\tfor (i = 0; i < ndim; i++)\n\t\t{\n\t\t\tif (indx[i] < lb[i] ||\n\t\t\t\tindx[i] >= (dim[i] + lb[i]))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array subscript out of range\")));\n\t\t}\n\t}\n\n\t/* Now we can calculate linear offset of target item in array */\n\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\n\t/* Physically enlarge existing dvalues/dnulls arrays if needed */\n\tif (dim[0] > eah->dvalueslen)\n\t{\n\t\t/* We want some extra space if we're enlarging */\n\t\tint\t\t\tnewlen = dim[0] + dim[0] / 8;\n\n\t\tnewlen = Max(newlen, dim[0]);\t/* integer overflow guard */\n\t\teah->dvalues = dvalues = (Datum *)\n\t\t\trepalloc(dvalues, newlen * sizeof(Datum));\n\t\tif (dnulls)\n\t\t\teah->dnulls = dnulls = (bool *)\n\t\t\t\trepalloc(dnulls, newlen * sizeof(bool));\n\t\teah->dvalueslen = newlen;\n\t}\n\n\t/*\n\t * If we need a nulls bitmap and don't already have one, create it, being\n\t * sure to mark all existing entries as not null.\n\t */\n\tif (newhasnulls && dnulls == NULL)\n\t\teah->dnulls = dnulls = (bool *)\n\t\t\tMemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   eah->dvalueslen * sizeof(bool));\n\n\t/*\n\t * We now have all the needed space allocated, so we're ready to make\n\t * irreversible changes.  Be very wary of allowing failure below here.\n\t */\n\n\t/* Flattened value will no longer represent array accurately */\n\teah->fvalue = NULL;\n\t/* And we don't know the flattened size either */\n\teah->flat_size = 0;\n\n\t/* Update dimensionality info if needed */\n\tif (dimschanged)\n\t{\n\t\teah->ndims = ndim;\n\t\tmemcpy(eah->dims, dim, ndim * sizeof(int));\n\t\tmemcpy(eah->lbound, lb, ndim * sizeof(int));\n\t}\n\n\t/* Reposition items if needed, and fill addedbefore items with nulls */\n\tif (addedbefore > 0)\n\t{\n\t\tmemmove(dvalues + addedbefore, dvalues, eah->nelems * sizeof(Datum));\n\t\tfor (i = 0; i < addedbefore; i++)\n\t\t\tdvalues[i] = (Datum) 0;\n\t\tif (dnulls)\n\t\t{\n\t\t\tmemmove(dnulls + addedbefore, dnulls, eah->nelems * sizeof(bool));\n\t\t\tfor (i = 0; i < addedbefore; i++)\n\t\t\t\tdnulls[i] = true;\n\t\t}\n\t\teah->nelems += addedbefore;\n\t}\n\n\t/* fill addedafter items with nulls */\n\tif (addedafter > 0)\n\t{\n\t\tfor (i = 0; i < addedafter; i++)\n\t\t\tdvalues[eah->nelems + i] = (Datum) 0;\n\t\tif (dnulls)\n\t\t{\n\t\t\tfor (i = 0; i < addedafter; i++)\n\t\t\t\tdnulls[eah->nelems + i] = true;\n\t\t}\n\t\teah->nelems += addedafter;\n\t}\n\n\t/* Grab old element value for pfree'ing, if needed. */\n\tif (!eah->typbyval && (dnulls == NULL || !dnulls[offset]))\n\t\toldValue = (char *) DatumGetPointer(dvalues[offset]);\n\telse\n\t\toldValue = NULL;\n\n\t/* And finally we can insert the new element. */\n\tdvalues[offset] = dataValue;\n\tif (dnulls)\n\t\tdnulls[offset] = isNull;\n\n\t/*\n\t * Free old element if needed; this keeps repeated element replacements\n\t * from bloating the array's storage.  If the pfree somehow fails, it\n\t * won't corrupt the array.\n\t */\n\tif (oldValue)\n\t{\n\t\t/* Don't try to pfree a part of the original flat array */\n\t\tif (oldValue < eah->fstartptr || oldValue >= eah->fendptr)\n\t\t\tpfree(oldValue);\n\t}\n\n\t/* Done, return standard TOAST pointer for object */\n\treturn EOHPGetRWDatum(&eah->hdr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);",
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
            "static void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic Datum\narray_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign)\n{\n\tExpandedArrayHeader *eah;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t\tdim[MAXDIM],\n\t\t\t\tlb[MAXDIM],\n\t\t\t\toffset;\n\tbool\t\tdimschanged,\n\t\t\t\tnewhasnulls;\n\tint\t\t\taddedbefore,\n\t\t\t\taddedafter;\n\tchar\t   *oldValue;\n\n\t/* Convert to R/W object if not so already */\n\teah = DatumGetExpandedArray(arraydatum);\n\n\t/* Sanity-check caller's info against object; we don't use it otherwise */\n\tAssert(arraytyplen == -1);\n\tAssert(elmlen == eah->typlen);\n\tAssert(elmbyval == eah->typbyval);\n\tAssert(elmalign == eah->typalign);\n\n\t/*\n\t * Copy dimension info into local storage.  This allows us to modify the\n\t * dimensions if needed, while not messing up the expanded value if we\n\t * fail partway through.\n\t */\n\tndim = eah->ndims;\n\tAssert(ndim >= 0 && ndim <= MAXDIM);\n\tmemcpy(dim, eah->dims, ndim * sizeof(int));\n\tmemcpy(lb, eah->lbound, ndim * sizeof(int));\n\tdimschanged = false;\n\n\t/*\n\t * if number of dims is zero, i.e. an empty array, create an array with\n\t * nSubscripts dimensions, and set the lower bounds to the supplied\n\t * subscripts.\n\t */\n\tif (ndim == 0)\n\t{\n\t\t/*\n\t\t * Allocate adequate space for new dimension info.  This is harmless\n\t\t * if we fail later.\n\t\t */\n\t\tAssert(nSubscripts > 0 && nSubscripts <= MAXDIM);\n\t\teah->dims = (int *) MemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t\t   nSubscripts * sizeof(int));\n\t\teah->lbound = (int *) MemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t\t\t\t\t\t nSubscripts * sizeof(int));\n\n\t\t/* Update local copies of dimension info */\n\t\tndim = nSubscripts;\n\t\tfor (i = 0; i < nSubscripts; i++)\n\t\t{\n\t\t\tdim[i] = 0;\n\t\t\tlb[i] = indx[i];\n\t\t}\n\t\tdimschanged = true;\n\t}\n\telse if (ndim != nSubscripts)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t errmsg(\"wrong number of array subscripts\")));\n\n\t/*\n\t * Deconstruct array if we didn't already.  (Someday maybe add a special\n\t * case path for fixed-length, no-nulls cases, where we can overwrite an\n\t * element in place without ever deconstructing.  But today is not that\n\t * day.)\n\t */\n\tdeconstruct_expanded_array(eah);\n\n\t/*\n\t * Copy new element into array's context, if needed (we assume it's\n\t * already detoasted, so no junk should be created).  If we fail further\n\t * down, this memory is leaked, but that's reasonably harmless.\n\t */\n\tif (!eah->typbyval && !isNull)\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(eah->hdr.eoh_context);\n\n\t\tdataValue = datumCopy(dataValue, false, eah->typlen);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\tdvalues = eah->dvalues;\n\tdnulls = eah->dnulls;\n\n\tnewhasnulls = ((dnulls != NULL) || isNull);\n\taddedbefore = addedafter = 0;\n\n\t/*\n\t * Check subscripts (this logic matches original array_set_element)\n\t */\n\tif (ndim == 1)\n\t{\n\t\tif (indx[0] < lb[0])\n\t\t{\n\t\t\taddedbefore = lb[0] - indx[0];\n\t\t\tdim[0] += addedbefore;\n\t\t\tlb[0] = indx[0];\n\t\t\tdimschanged = true;\n\t\t\tif (addedbefore > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t\tif (indx[0] >= (dim[0] + lb[0]))\n\t\t{\n\t\t\taddedafter = indx[0] - (dim[0] + lb[0]) + 1;\n\t\t\tdim[0] += addedafter;\n\t\t\tdimschanged = true;\n\t\t\tif (addedafter > 1)\n\t\t\t\tnewhasnulls = true; /* will insert nulls */\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * XXX currently we do not support extending multi-dimensional arrays\n\t\t * during assignment\n\t\t */\n\t\tfor (i = 0; i < ndim; i++)\n\t\t{\n\t\t\tif (indx[i] < lb[i] ||\n\t\t\t\tindx[i] >= (dim[i] + lb[i]))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_ARRAY_SUBSCRIPT_ERROR),\n\t\t\t\t\t\t errmsg(\"array subscript out of range\")));\n\t\t}\n\t}\n\n\t/* Now we can calculate linear offset of target item in array */\n\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\n\t/* Physically enlarge existing dvalues/dnulls arrays if needed */\n\tif (dim[0] > eah->dvalueslen)\n\t{\n\t\t/* We want some extra space if we're enlarging */\n\t\tint\t\t\tnewlen = dim[0] + dim[0] / 8;\n\n\t\tnewlen = Max(newlen, dim[0]);\t/* integer overflow guard */\n\t\teah->dvalues = dvalues = (Datum *)\n\t\t\trepalloc(dvalues, newlen * sizeof(Datum));\n\t\tif (dnulls)\n\t\t\teah->dnulls = dnulls = (bool *)\n\t\t\t\trepalloc(dnulls, newlen * sizeof(bool));\n\t\teah->dvalueslen = newlen;\n\t}\n\n\t/*\n\t * If we need a nulls bitmap and don't already have one, create it, being\n\t * sure to mark all existing entries as not null.\n\t */\n\tif (newhasnulls && dnulls == NULL)\n\t\teah->dnulls = dnulls = (bool *)\n\t\t\tMemoryContextAllocZero(eah->hdr.eoh_context,\n\t\t\t\t\t\t\t\t   eah->dvalueslen * sizeof(bool));\n\n\t/*\n\t * We now have all the needed space allocated, so we're ready to make\n\t * irreversible changes.  Be very wary of allowing failure below here.\n\t */\n\n\t/* Flattened value will no longer represent array accurately */\n\teah->fvalue = NULL;\n\t/* And we don't know the flattened size either */\n\teah->flat_size = 0;\n\n\t/* Update dimensionality info if needed */\n\tif (dimschanged)\n\t{\n\t\teah->ndims = ndim;\n\t\tmemcpy(eah->dims, dim, ndim * sizeof(int));\n\t\tmemcpy(eah->lbound, lb, ndim * sizeof(int));\n\t}\n\n\t/* Reposition items if needed, and fill addedbefore items with nulls */\n\tif (addedbefore > 0)\n\t{\n\t\tmemmove(dvalues + addedbefore, dvalues, eah->nelems * sizeof(Datum));\n\t\tfor (i = 0; i < addedbefore; i++)\n\t\t\tdvalues[i] = (Datum) 0;\n\t\tif (dnulls)\n\t\t{\n\t\t\tmemmove(dnulls + addedbefore, dnulls, eah->nelems * sizeof(bool));\n\t\t\tfor (i = 0; i < addedbefore; i++)\n\t\t\t\tdnulls[i] = true;\n\t\t}\n\t\teah->nelems += addedbefore;\n\t}\n\n\t/* fill addedafter items with nulls */\n\tif (addedafter > 0)\n\t{\n\t\tfor (i = 0; i < addedafter; i++)\n\t\t\tdvalues[eah->nelems + i] = (Datum) 0;\n\t\tif (dnulls)\n\t\t{\n\t\t\tfor (i = 0; i < addedafter; i++)\n\t\t\t\tdnulls[eah->nelems + i] = true;\n\t\t}\n\t\teah->nelems += addedafter;\n\t}\n\n\t/* Grab old element value for pfree'ing, if needed. */\n\tif (!eah->typbyval && (dnulls == NULL || !dnulls[offset]))\n\t\toldValue = (char *) DatumGetPointer(dvalues[offset]);\n\telse\n\t\toldValue = NULL;\n\n\t/* And finally we can insert the new element. */\n\tdvalues[offset] = dataValue;\n\tif (dnulls)\n\t\tdnulls[offset] = isNull;\n\n\t/*\n\t * Free old element if needed; this keeps repeated element replacements\n\t * from bloating the array's storage.  If the pfree somehow fails, it\n\t * won't corrupt the array.\n\t */\n\tif (oldValue)\n\t{\n\t\t/* Don't try to pfree a part of the original flat array */\n\t\tif (oldValue < eah->fstartptr || oldValue >= eah->fendptr)\n\t\t\tpfree(oldValue);\n\t}\n\n\t/* Done, return standard TOAST pointer for object */\n\treturn EOHPGetRWDatum(&eah->hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EOHPGetRWDatum",
          "args": [
            "&eah->hdr"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"argument must be empty or one-dimensional array\"))"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"argument must be empty or one-dimensional array\""
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATA_EXCEPTION"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"integer out of range\"))"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_add_s32_overflow",
          "args": [
            "lb[0]",
            "dimv[0]",
            "&indx"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fetch_array_arg_replace_nulls",
          "args": [
            "fcinfo",
            "0"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_array_arg_replace_nulls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_userfuncs.c",
          "lines": "41-93",
          "snippet": "static ExpandedArrayHeader *\nfetch_array_arg_replace_nulls(FunctionCallInfo fcinfo, int argno)\n{\n\tExpandedArrayHeader *eah;\n\tOid\t\t\telement_type;\n\tArrayMetaState *my_extra;\n\tMemoryContext resultcxt;\n\n\t/* If first time through, create datatype cache struct */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tmy_extra = (ArrayMetaState *)\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   sizeof(ArrayMetaState));\n\t\tmy_extra->element_type = InvalidOid;\n\t\tfcinfo->flinfo->fn_extra = my_extra;\n\t}\n\n\t/* Figure out which context we want the result in */\n\tif (!AggCheckCallContext(fcinfo, &resultcxt))\n\t\tresultcxt = CurrentMemoryContext;\n\n\t/* Now collect the array value */\n\tif (!PG_ARGISNULL(argno))\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(resultcxt);\n\n\t\teah = PG_GETARG_EXPANDED_ARRAYX(argno, my_extra);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse\n\t{\n\t\t/* We have to look up the array type and element type */\n\t\tOid\t\t\tarr_typeid = get_fn_expr_argtype(fcinfo->flinfo, argno);\n\n\t\tif (!OidIsValid(arr_typeid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine input data type\")));\n\t\telement_type = get_element_type(arr_typeid);\n\t\tif (!OidIsValid(element_type))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"input data type is not an array\")));\n\n\t\teah = construct_empty_expanded_array(element_type,\n\t\t\t\t\t\t\t\t\t\t\t resultcxt,\n\t\t\t\t\t\t\t\t\t\t\t my_extra);\n\t}\n\n\treturn eah;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_position_common(FunctionCallInfo fcinfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic Datum array_position_common(FunctionCallInfo fcinfo);\n\nstatic ExpandedArrayHeader *\nfetch_array_arg_replace_nulls(FunctionCallInfo fcinfo, int argno)\n{\n\tExpandedArrayHeader *eah;\n\tOid\t\t\telement_type;\n\tArrayMetaState *my_extra;\n\tMemoryContext resultcxt;\n\n\t/* If first time through, create datatype cache struct */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tmy_extra = (ArrayMetaState *)\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   sizeof(ArrayMetaState));\n\t\tmy_extra->element_type = InvalidOid;\n\t\tfcinfo->flinfo->fn_extra = my_extra;\n\t}\n\n\t/* Figure out which context we want the result in */\n\tif (!AggCheckCallContext(fcinfo, &resultcxt))\n\t\tresultcxt = CurrentMemoryContext;\n\n\t/* Now collect the array value */\n\tif (!PG_ARGISNULL(argno))\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(resultcxt);\n\n\t\teah = PG_GETARG_EXPANDED_ARRAYX(argno, my_extra);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse\n\t{\n\t\t/* We have to look up the array type and element type */\n\t\tOid\t\t\tarr_typeid = get_fn_expr_argtype(fcinfo->flinfo, argno);\n\n\t\tif (!OidIsValid(arr_typeid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine input data type\")));\n\t\telement_type = get_element_type(arr_typeid);\n\t\tif (!OidIsValid(element_type))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"input data type is not an array\")));\n\n\t\teah = construct_empty_expanded_array(element_type,\n\t\t\t\t\t\t\t\t\t\t\t resultcxt,\n\t\t\t\t\t\t\t\t\t\t\t my_extra);\n\t}\n\n\treturn eah;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic Datum array_position_common(FunctionCallInfo fcinfo);\n\nDatum\narray_append(PG_FUNCTION_ARGS)\n{\n\tExpandedArrayHeader *eah;\n\tDatum\t\tnewelem;\n\tbool\t\tisNull;\n\tDatum\t\tresult;\n\tint\t\t   *dimv,\n\t\t\t   *lb;\n\tint\t\t\tindx;\n\tArrayMetaState *my_extra;\n\n\teah = fetch_array_arg_replace_nulls(fcinfo, 0);\n\tisNull = PG_ARGISNULL(1);\n\tif (isNull)\n\t\tnewelem = (Datum) 0;\n\telse\n\t\tnewelem = PG_GETARG_DATUM(1);\n\n\tif (eah->ndims == 1)\n\t{\n\t\t/* append newelem */\n\t\tlb = eah->lbound;\n\t\tdimv = eah->dims;\n\n\t\t/* index of added elem is at lb[0] + (dimv[0] - 1) + 1 */\n\t\tif (pg_add_s32_overflow(lb[0], dimv[0], &indx))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t errmsg(\"integer out of range\")));\n\t}\n\telse if (eah->ndims == 0)\n\t\tindx = 1;\n\telse\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t errmsg(\"argument must be empty or one-dimensional array\")));\n\n\t/* Perform element insertion */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\n\tresult = array_set_element(EOHPGetRWDatum(&eah->hdr),\n\t\t\t\t\t\t\t   1, &indx, newelem, isNull,\n\t\t\t\t\t\t\t   -1, my_extra->typlen, my_extra->typbyval, my_extra->typalign);\n\n\tPG_RETURN_DATUM(result);\n}"
  },
  {
    "function_name": "fetch_array_arg_replace_nulls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/array_userfuncs.c",
    "lines": "41-93",
    "snippet": "static ExpandedArrayHeader *\nfetch_array_arg_replace_nulls(FunctionCallInfo fcinfo, int argno)\n{\n\tExpandedArrayHeader *eah;\n\tOid\t\t\telement_type;\n\tArrayMetaState *my_extra;\n\tMemoryContext resultcxt;\n\n\t/* If first time through, create datatype cache struct */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tmy_extra = (ArrayMetaState *)\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   sizeof(ArrayMetaState));\n\t\tmy_extra->element_type = InvalidOid;\n\t\tfcinfo->flinfo->fn_extra = my_extra;\n\t}\n\n\t/* Figure out which context we want the result in */\n\tif (!AggCheckCallContext(fcinfo, &resultcxt))\n\t\tresultcxt = CurrentMemoryContext;\n\n\t/* Now collect the array value */\n\tif (!PG_ARGISNULL(argno))\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(resultcxt);\n\n\t\teah = PG_GETARG_EXPANDED_ARRAYX(argno, my_extra);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse\n\t{\n\t\t/* We have to look up the array type and element type */\n\t\tOid\t\t\tarr_typeid = get_fn_expr_argtype(fcinfo->flinfo, argno);\n\n\t\tif (!OidIsValid(arr_typeid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine input data type\")));\n\t\telement_type = get_element_type(arr_typeid);\n\t\tif (!OidIsValid(element_type))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"input data type is not an array\")));\n\n\t\teah = construct_empty_expanded_array(element_type,\n\t\t\t\t\t\t\t\t\t\t\t resultcxt,\n\t\t\t\t\t\t\t\t\t\t\t my_extra);\n\t}\n\n\treturn eah;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"common/int.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum array_position_common(FunctionCallInfo fcinfo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "construct_empty_expanded_array",
          "args": [
            "element_type",
            "resultcxt",
            "my_extra"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "construct_empty_expanded_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3426-3437",
          "snippet": "ExpandedArrayHeader *\nconstruct_empty_expanded_array(Oid element_type,\n\t\t\t\t\t\t\t   MemoryContext parentcontext,\n\t\t\t\t\t\t\t   ArrayMetaState *metacache)\n{\n\tArrayType  *array = construct_empty_array(element_type);\n\tDatum\t\td;\n\n\td = expand_array(PointerGetDatum(array), parentcontext, metacache);\n\tpfree(array);\n\treturn (ExpandedArrayHeader *) DatumGetEOHP(d);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nExpandedArrayHeader *\nconstruct_empty_expanded_array(Oid element_type,\n\t\t\t\t\t\t\t   MemoryContext parentcontext,\n\t\t\t\t\t\t\t   ArrayMetaState *metacache)\n{\n\tArrayType  *array = construct_empty_array(element_type);\n\tDatum\t\td;\n\n\td = expand_array(PointerGetDatum(array), parentcontext, metacache);\n\tpfree(array);\n\treturn (ExpandedArrayHeader *) DatumGetEOHP(d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"input data type is not an array\"))"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"input data type is not an array\""
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATATYPE_MISMATCH"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "element_type"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_element_type",
          "args": [
            "arr_typeid"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "get_element_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2525-2545",
          "snippet": "Oid\nget_element_type(Oid typid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tif (typtup->typlen == -1)\n\t\t\tresult = typtup->typelem;\n\t\telse\n\t\t\tresult = InvalidOid;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_element_type(Oid typid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_type typtup = (Form_pg_type) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tif (typtup->typlen == -1)\n\t\t\tresult = typtup->typelem;\n\t\telse\n\t\t\tresult = InvalidOid;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine input data type\"))"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "arr_typeid"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fn_expr_argtype",
          "args": [
            "fcinfo->flinfo",
            "argno"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "get_fn_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1994-2005",
          "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_EXPANDED_ARRAYX",
          "args": [
            "argno",
            "my_extra"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "resultcxt"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "argno"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AggCheckCallContext",
          "args": [
            "fcinfo",
            "&resultcxt"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "sizeof(ArrayMetaState)"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nstatic Datum array_position_common(FunctionCallInfo fcinfo);\n\nstatic ExpandedArrayHeader *\nfetch_array_arg_replace_nulls(FunctionCallInfo fcinfo, int argno)\n{\n\tExpandedArrayHeader *eah;\n\tOid\t\t\telement_type;\n\tArrayMetaState *my_extra;\n\tMemoryContext resultcxt;\n\n\t/* If first time through, create datatype cache struct */\n\tmy_extra = (ArrayMetaState *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL)\n\t{\n\t\tmy_extra = (ArrayMetaState *)\n\t\t\tMemoryContextAlloc(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t   sizeof(ArrayMetaState));\n\t\tmy_extra->element_type = InvalidOid;\n\t\tfcinfo->flinfo->fn_extra = my_extra;\n\t}\n\n\t/* Figure out which context we want the result in */\n\tif (!AggCheckCallContext(fcinfo, &resultcxt))\n\t\tresultcxt = CurrentMemoryContext;\n\n\t/* Now collect the array value */\n\tif (!PG_ARGISNULL(argno))\n\t{\n\t\tMemoryContext oldcxt = MemoryContextSwitchTo(resultcxt);\n\n\t\teah = PG_GETARG_EXPANDED_ARRAYX(argno, my_extra);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse\n\t{\n\t\t/* We have to look up the array type and element type */\n\t\tOid\t\t\tarr_typeid = get_fn_expr_argtype(fcinfo->flinfo, argno);\n\n\t\tif (!OidIsValid(arr_typeid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"could not determine input data type\")));\n\t\telement_type = get_element_type(arr_typeid);\n\t\tif (!OidIsValid(element_type))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"input data type is not an array\")));\n\n\t\teah = construct_empty_expanded_array(element_type,\n\t\t\t\t\t\t\t\t\t\t\t resultcxt,\n\t\t\t\t\t\t\t\t\t\t\t my_extra);\n\t}\n\n\treturn eah;\n}"
  }
]