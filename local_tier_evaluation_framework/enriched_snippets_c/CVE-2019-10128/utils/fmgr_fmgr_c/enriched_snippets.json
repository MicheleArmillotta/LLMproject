[
  {
    "function_name": "CheckFunctionValidatorAccess",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "2178-2234",
    "snippet": "bool\nCheckFunctionValidatorAccess(Oid validatorOid, Oid functionOid)\n{\n\tHeapTuple\tprocTup;\n\tHeapTuple\tlangTup;\n\tForm_pg_proc procStruct;\n\tForm_pg_language langStruct;\n\tAclResult\taclresult;\n\n\t/*\n\t * Get the function's pg_proc entry.  Throw a user-facing error for bad\n\t * OID, because validators can be called with user-specified OIDs.\n\t */\n\tprocTup = SearchSysCache1(PROCOID, ObjectIdGetDatum(functionOid));\n\tif (!HeapTupleIsValid(procTup))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"function with OID %u does not exist\", functionOid)));\n\tprocStruct = (Form_pg_proc) GETSTRUCT(procTup);\n\n\t/*\n\t * Fetch pg_language entry to know if this is the correct validation\n\t * function for that pg_proc entry.\n\t */\n\tlangTup = SearchSysCache1(LANGOID, ObjectIdGetDatum(procStruct->prolang));\n\tif (!HeapTupleIsValid(langTup))\n\t\telog(ERROR, \"cache lookup failed for language %u\", procStruct->prolang);\n\tlangStruct = (Form_pg_language) GETSTRUCT(langTup);\n\n\tif (langStruct->lanvalidator != validatorOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"language validation function %u called for language %u instead of %u\",\n\t\t\t\t\t\tvalidatorOid, procStruct->prolang,\n\t\t\t\t\t\tlangStruct->lanvalidator)));\n\n\t/* first validate that we have permissions to use the language */\n\taclresult = pg_language_aclcheck(procStruct->prolang, GetUserId(),\n\t\t\t\t\t\t\t\t\t ACL_USAGE);\n\tif (aclresult != ACLCHECK_OK)\n\t\taclcheck_error(aclresult, OBJECT_LANGUAGE,\n\t\t\t\t\t   NameStr(langStruct->lanname));\n\n\t/*\n\t * Check whether we are allowed to execute the function itself. If we can\n\t * execute it, there should be no possible side-effect of\n\t * compiling/validation that execution can't have.\n\t */\n\taclresult = pg_proc_aclcheck(functionOid, GetUserId(), ACL_EXECUTE);\n\tif (aclresult != ACLCHECK_OK)\n\t\taclcheck_error(aclresult, OBJECT_FUNCTION, NameStr(procStruct->proname));\n\n\tReleaseSysCache(procTup);\n\tReleaseSysCache(langTup);\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "langTup"
          ],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aclcheck_error",
          "args": [
            "aclresult",
            "OBJECT_FUNCTION",
            "NameStr(procStruct->proname)"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "procStruct->proname"
          ],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_proc_aclcheck",
          "args": [
            "functionOid",
            "GetUserId()",
            "ACL_EXECUTE"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetUserId",
          "args": [],
          "line": 2226
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "386-391",
          "snippet": "Oid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\n\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aclcheck_error",
          "args": [
            "aclresult",
            "OBJECT_LANGUAGE",
            "NameStr(langStruct->lanname)"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "langStruct->lanname"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_language_aclcheck",
          "args": [
            "procStruct->prolang",
            "GetUserId()",
            "ACL_USAGE"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"language validation function %u called for language %u instead of %u\",\n\t\t\t\t\t\tvalidatorOid, procStruct->prolang,\n\t\t\t\t\t\tlangStruct->lanvalidator))"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"language validation function %u called for language %u instead of %u\"",
            "validatorOid",
            "procStruct->prolang",
            "langStruct->lanvalidator"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INSUFFICIENT_PRIVILEGE"
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "langTup"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for language %u\"",
            "procStruct->prolang"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "langTup"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "LANGOID",
            "ObjectIdGetDatum(procStruct->prolang)"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "procStruct->prolang"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "procTup"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"function with OID %u does not exist\", functionOid))"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "procTup"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "functionOid"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nbool\nCheckFunctionValidatorAccess(Oid validatorOid, Oid functionOid)\n{\n\tHeapTuple\tprocTup;\n\tHeapTuple\tlangTup;\n\tForm_pg_proc procStruct;\n\tForm_pg_language langStruct;\n\tAclResult\taclresult;\n\n\t/*\n\t * Get the function's pg_proc entry.  Throw a user-facing error for bad\n\t * OID, because validators can be called with user-specified OIDs.\n\t */\n\tprocTup = SearchSysCache1(PROCOID, ObjectIdGetDatum(functionOid));\n\tif (!HeapTupleIsValid(procTup))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"function with OID %u does not exist\", functionOid)));\n\tprocStruct = (Form_pg_proc) GETSTRUCT(procTup);\n\n\t/*\n\t * Fetch pg_language entry to know if this is the correct validation\n\t * function for that pg_proc entry.\n\t */\n\tlangTup = SearchSysCache1(LANGOID, ObjectIdGetDatum(procStruct->prolang));\n\tif (!HeapTupleIsValid(langTup))\n\t\telog(ERROR, \"cache lookup failed for language %u\", procStruct->prolang);\n\tlangStruct = (Form_pg_language) GETSTRUCT(langTup);\n\n\tif (langStruct->lanvalidator != validatorOid)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"language validation function %u called for language %u instead of %u\",\n\t\t\t\t\t\tvalidatorOid, procStruct->prolang,\n\t\t\t\t\t\tlangStruct->lanvalidator)));\n\n\t/* first validate that we have permissions to use the language */\n\taclresult = pg_language_aclcheck(procStruct->prolang, GetUserId(),\n\t\t\t\t\t\t\t\t\t ACL_USAGE);\n\tif (aclresult != ACLCHECK_OK)\n\t\taclcheck_error(aclresult, OBJECT_LANGUAGE,\n\t\t\t\t\t   NameStr(langStruct->lanname));\n\n\t/*\n\t * Check whether we are allowed to execute the function itself. If we can\n\t * execute it, there should be no possible side-effect of\n\t * compiling/validation that execution can't have.\n\t */\n\taclresult = pg_proc_aclcheck(functionOid, GetUserId(), ACL_EXECUTE);\n\tif (aclresult != ACLCHECK_OK)\n\t\taclcheck_error(aclresult, OBJECT_FUNCTION, NameStr(procStruct->proname));\n\n\tReleaseSysCache(procTup);\n\tReleaseSysCache(langTup);\n\n\treturn true;\n}"
  },
  {
    "function_name": "get_fn_expr_variadic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "2128-2146",
    "snippet": "bool\nget_fn_expr_variadic(FmgrInfo *flinfo)\n{\n\tNode\t   *expr;\n\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn false;\n\n\texpr = flinfo->fn_expr;\n\n\tif (IsA(expr, FuncExpr))\n\t\treturn ((FuncExpr *) expr)->funcvariadic;\n\telse\n\t\treturn false;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "expr",
            "FuncExpr"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nbool\nget_fn_expr_variadic(FmgrInfo *flinfo)\n{\n\tNode\t   *expr;\n\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn false;\n\n\texpr = flinfo->fn_expr;\n\n\tif (IsA(expr, FuncExpr))\n\t\treturn ((FuncExpr *) expr)->funcvariadic;\n\telse\n\t\treturn false;\n}"
  },
  {
    "function_name": "get_call_expr_arg_stable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "2078-2119",
    "snippet": "bool\nget_call_expr_arg_stable(Node *expr, int argnum)\n{\n\tList\t   *args;\n\tNode\t   *arg;\n\n\tif (expr == NULL)\n\t\treturn false;\n\n\tif (IsA(expr, FuncExpr))\n\t\targs = ((FuncExpr *) expr)->args;\n\telse if (IsA(expr, OpExpr))\n\t\targs = ((OpExpr *) expr)->args;\n\telse if (IsA(expr, DistinctExpr))\n\t\targs = ((DistinctExpr *) expr)->args;\n\telse if (IsA(expr, ScalarArrayOpExpr))\n\t\targs = ((ScalarArrayOpExpr *) expr)->args;\n\telse if (IsA(expr, NullIfExpr))\n\t\targs = ((NullIfExpr *) expr)->args;\n\telse if (IsA(expr, WindowFunc))\n\t\targs = ((WindowFunc *) expr)->args;\n\telse\n\t\treturn false;\n\n\tif (argnum < 0 || argnum >= list_length(args))\n\t\treturn false;\n\n\targ = (Node *) list_nth(args, argnum);\n\n\t/*\n\t * Either a true Const or an external Param will have a value that doesn't\n\t * change during the execution of the query.  In future we might want to\n\t * consider other cases too, e.g. now().\n\t */\n\tif (IsA(arg, Const))\n\t\treturn true;\n\tif (IsA(arg, Param) &&\n\t\t((Param *) arg)->paramkind == PARAM_EXTERN)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "arg",
            "Param"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "arg",
            "Const"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_nth",
          "args": [
            "args",
            "argnum"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "args"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "expr",
            "WindowFunc"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "expr",
            "NullIfExpr"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "expr",
            "ScalarArrayOpExpr"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "expr",
            "DistinctExpr"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "expr",
            "OpExpr"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "expr",
            "FuncExpr"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nbool\nget_call_expr_arg_stable(Node *expr, int argnum)\n{\n\tList\t   *args;\n\tNode\t   *arg;\n\n\tif (expr == NULL)\n\t\treturn false;\n\n\tif (IsA(expr, FuncExpr))\n\t\targs = ((FuncExpr *) expr)->args;\n\telse if (IsA(expr, OpExpr))\n\t\targs = ((OpExpr *) expr)->args;\n\telse if (IsA(expr, DistinctExpr))\n\t\targs = ((DistinctExpr *) expr)->args;\n\telse if (IsA(expr, ScalarArrayOpExpr))\n\t\targs = ((ScalarArrayOpExpr *) expr)->args;\n\telse if (IsA(expr, NullIfExpr))\n\t\targs = ((NullIfExpr *) expr)->args;\n\telse if (IsA(expr, WindowFunc))\n\t\targs = ((WindowFunc *) expr)->args;\n\telse\n\t\treturn false;\n\n\tif (argnum < 0 || argnum >= list_length(args))\n\t\treturn false;\n\n\targ = (Node *) list_nth(args, argnum);\n\n\t/*\n\t * Either a true Const or an external Param will have a value that doesn't\n\t * change during the execution of the query.  In future we might want to\n\t * consider other cases too, e.g. now().\n\t */\n\tif (IsA(arg, Const))\n\t\treturn true;\n\tif (IsA(arg, Param) &&\n\t\t((Param *) arg)->paramkind == PARAM_EXTERN)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "get_fn_expr_arg_stable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "2059-2070",
    "snippet": "bool\nget_fn_expr_arg_stable(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn false;\n\n\treturn get_call_expr_arg_stable(flinfo->fn_expr, argnum);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_call_expr_arg_stable",
          "args": [
            "flinfo->fn_expr",
            "argnum"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "get_call_expr_arg_stable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "2078-2119",
          "snippet": "bool\nget_call_expr_arg_stable(Node *expr, int argnum)\n{\n\tList\t   *args;\n\tNode\t   *arg;\n\n\tif (expr == NULL)\n\t\treturn false;\n\n\tif (IsA(expr, FuncExpr))\n\t\targs = ((FuncExpr *) expr)->args;\n\telse if (IsA(expr, OpExpr))\n\t\targs = ((OpExpr *) expr)->args;\n\telse if (IsA(expr, DistinctExpr))\n\t\targs = ((DistinctExpr *) expr)->args;\n\telse if (IsA(expr, ScalarArrayOpExpr))\n\t\targs = ((ScalarArrayOpExpr *) expr)->args;\n\telse if (IsA(expr, NullIfExpr))\n\t\targs = ((NullIfExpr *) expr)->args;\n\telse if (IsA(expr, WindowFunc))\n\t\targs = ((WindowFunc *) expr)->args;\n\telse\n\t\treturn false;\n\n\tif (argnum < 0 || argnum >= list_length(args))\n\t\treturn false;\n\n\targ = (Node *) list_nth(args, argnum);\n\n\t/*\n\t * Either a true Const or an external Param will have a value that doesn't\n\t * change during the execution of the query.  In future we might want to\n\t * consider other cases too, e.g. now().\n\t */\n\tif (IsA(arg, Const))\n\t\treturn true;\n\tif (IsA(arg, Param) &&\n\t\t((Param *) arg)->paramkind == PARAM_EXTERN)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nbool\nget_call_expr_arg_stable(Node *expr, int argnum)\n{\n\tList\t   *args;\n\tNode\t   *arg;\n\n\tif (expr == NULL)\n\t\treturn false;\n\n\tif (IsA(expr, FuncExpr))\n\t\targs = ((FuncExpr *) expr)->args;\n\telse if (IsA(expr, OpExpr))\n\t\targs = ((OpExpr *) expr)->args;\n\telse if (IsA(expr, DistinctExpr))\n\t\targs = ((DistinctExpr *) expr)->args;\n\telse if (IsA(expr, ScalarArrayOpExpr))\n\t\targs = ((ScalarArrayOpExpr *) expr)->args;\n\telse if (IsA(expr, NullIfExpr))\n\t\targs = ((NullIfExpr *) expr)->args;\n\telse if (IsA(expr, WindowFunc))\n\t\targs = ((WindowFunc *) expr)->args;\n\telse\n\t\treturn false;\n\n\tif (argnum < 0 || argnum >= list_length(args))\n\t\treturn false;\n\n\targ = (Node *) list_nth(args, argnum);\n\n\t/*\n\t * Either a true Const or an external Param will have a value that doesn't\n\t * change during the execution of the query.  In future we might want to\n\t * consider other cases too, e.g. now().\n\t */\n\tif (IsA(arg, Const))\n\t\treturn true;\n\tif (IsA(arg, Param) &&\n\t\t((Param *) arg)->paramkind == PARAM_EXTERN)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nbool\nget_fn_expr_arg_stable(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn false;\n\n\treturn get_call_expr_arg_stable(flinfo->fn_expr, argnum);\n}"
  },
  {
    "function_name": "get_call_expr_argtype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "2013-2051",
    "snippet": "Oid\nget_call_expr_argtype(Node *expr, int argnum)\n{\n\tList\t   *args;\n\tOid\t\t\targtype;\n\n\tif (expr == NULL)\n\t\treturn InvalidOid;\n\n\tif (IsA(expr, FuncExpr))\n\t\targs = ((FuncExpr *) expr)->args;\n\telse if (IsA(expr, OpExpr))\n\t\targs = ((OpExpr *) expr)->args;\n\telse if (IsA(expr, DistinctExpr))\n\t\targs = ((DistinctExpr *) expr)->args;\n\telse if (IsA(expr, ScalarArrayOpExpr))\n\t\targs = ((ScalarArrayOpExpr *) expr)->args;\n\telse if (IsA(expr, NullIfExpr))\n\t\targs = ((NullIfExpr *) expr)->args;\n\telse if (IsA(expr, WindowFunc))\n\t\targs = ((WindowFunc *) expr)->args;\n\telse\n\t\treturn InvalidOid;\n\n\tif (argnum < 0 || argnum >= list_length(args))\n\t\treturn InvalidOid;\n\n\targtype = exprType((Node *) list_nth(args, argnum));\n\n\t/*\n\t * special hack for ScalarArrayOpExpr: what the underlying function will\n\t * actually get passed is the element type of the array.\n\t */\n\tif (IsA(expr, ScalarArrayOpExpr) &&\n\t\targnum == 1)\n\t\targtype = get_base_element_type(argtype);\n\n\treturn argtype;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_base_element_type",
          "args": [
            "argtype"
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "get_base_element_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2598-2633",
          "snippet": "Oid\nget_base_element_type(Oid typid)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\tbreak;\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so stop descending */\n\t\t\tOid\t\t\tresult;\n\n\t\t\t/* This test must match get_element_type */\n\t\t\tif (typTup->typlen == -1)\n\t\t\t\tresult = typTup->typelem;\n\t\t\telse\n\t\t\t\tresult = InvalidOid;\n\t\t\tReleaseSysCache(tup);\n\t\t\treturn result;\n\t\t}\n\n\t\ttypid = typTup->typbasetype;\n\t\tReleaseSysCache(tup);\n\t}\n\n\t/* Like get_element_type, silently return InvalidOid for bogus input */\n\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_base_element_type(Oid typid)\n{\n\t/*\n\t * We loop to find the bottom base type in a stack of domains.\n\t */\n\tfor (;;)\n\t{\n\t\tHeapTuple\ttup;\n\t\tForm_pg_type typTup;\n\n\t\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\tbreak;\n\t\ttypTup = (Form_pg_type) GETSTRUCT(tup);\n\t\tif (typTup->typtype != TYPTYPE_DOMAIN)\n\t\t{\n\t\t\t/* Not a domain, so stop descending */\n\t\t\tOid\t\t\tresult;\n\n\t\t\t/* This test must match get_element_type */\n\t\t\tif (typTup->typlen == -1)\n\t\t\t\tresult = typTup->typelem;\n\t\t\telse\n\t\t\t\tresult = InvalidOid;\n\t\t\tReleaseSysCache(tup);\n\t\t\treturn result;\n\t\t}\n\n\t\ttypid = typTup->typbasetype;\n\t\tReleaseSysCache(tup);\n\t}\n\n\t/* Like get_element_type, silently return InvalidOid for bogus input */\n\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "expr",
            "ScalarArrayOpExpr"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exprType",
          "args": [
            "(Node *) list_nth(args, argnum)"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_nth",
          "args": [
            "args",
            "argnum"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "args"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "expr",
            "WindowFunc"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "expr",
            "NullIfExpr"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "expr",
            "ScalarArrayOpExpr"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "expr",
            "DistinctExpr"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "expr",
            "OpExpr"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "expr",
            "FuncExpr"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_call_expr_argtype(Node *expr, int argnum)\n{\n\tList\t   *args;\n\tOid\t\t\targtype;\n\n\tif (expr == NULL)\n\t\treturn InvalidOid;\n\n\tif (IsA(expr, FuncExpr))\n\t\targs = ((FuncExpr *) expr)->args;\n\telse if (IsA(expr, OpExpr))\n\t\targs = ((OpExpr *) expr)->args;\n\telse if (IsA(expr, DistinctExpr))\n\t\targs = ((DistinctExpr *) expr)->args;\n\telse if (IsA(expr, ScalarArrayOpExpr))\n\t\targs = ((ScalarArrayOpExpr *) expr)->args;\n\telse if (IsA(expr, NullIfExpr))\n\t\targs = ((NullIfExpr *) expr)->args;\n\telse if (IsA(expr, WindowFunc))\n\t\targs = ((WindowFunc *) expr)->args;\n\telse\n\t\treturn InvalidOid;\n\n\tif (argnum < 0 || argnum >= list_length(args))\n\t\treturn InvalidOid;\n\n\targtype = exprType((Node *) list_nth(args, argnum));\n\n\t/*\n\t * special hack for ScalarArrayOpExpr: what the underlying function will\n\t * actually get passed is the element type of the array.\n\t */\n\tif (IsA(expr, ScalarArrayOpExpr) &&\n\t\targnum == 1)\n\t\targtype = get_base_element_type(argtype);\n\n\treturn argtype;\n}"
  },
  {
    "function_name": "get_fn_expr_argtype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1994-2005",
    "snippet": "Oid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_call_expr_argtype",
          "args": [
            "flinfo->fn_expr",
            "argnum"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "get_call_expr_argtype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "2013-2051",
          "snippet": "Oid\nget_call_expr_argtype(Node *expr, int argnum)\n{\n\tList\t   *args;\n\tOid\t\t\targtype;\n\n\tif (expr == NULL)\n\t\treturn InvalidOid;\n\n\tif (IsA(expr, FuncExpr))\n\t\targs = ((FuncExpr *) expr)->args;\n\telse if (IsA(expr, OpExpr))\n\t\targs = ((OpExpr *) expr)->args;\n\telse if (IsA(expr, DistinctExpr))\n\t\targs = ((DistinctExpr *) expr)->args;\n\telse if (IsA(expr, ScalarArrayOpExpr))\n\t\targs = ((ScalarArrayOpExpr *) expr)->args;\n\telse if (IsA(expr, NullIfExpr))\n\t\targs = ((NullIfExpr *) expr)->args;\n\telse if (IsA(expr, WindowFunc))\n\t\targs = ((WindowFunc *) expr)->args;\n\telse\n\t\treturn InvalidOid;\n\n\tif (argnum < 0 || argnum >= list_length(args))\n\t\treturn InvalidOid;\n\n\targtype = exprType((Node *) list_nth(args, argnum));\n\n\t/*\n\t * special hack for ScalarArrayOpExpr: what the underlying function will\n\t * actually get passed is the element type of the array.\n\t */\n\tif (IsA(expr, ScalarArrayOpExpr) &&\n\t\targnum == 1)\n\t\targtype = get_base_element_type(argtype);\n\n\treturn argtype;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_call_expr_argtype(Node *expr, int argnum)\n{\n\tList\t   *args;\n\tOid\t\t\targtype;\n\n\tif (expr == NULL)\n\t\treturn InvalidOid;\n\n\tif (IsA(expr, FuncExpr))\n\t\targs = ((FuncExpr *) expr)->args;\n\telse if (IsA(expr, OpExpr))\n\t\targs = ((OpExpr *) expr)->args;\n\telse if (IsA(expr, DistinctExpr))\n\t\targs = ((DistinctExpr *) expr)->args;\n\telse if (IsA(expr, ScalarArrayOpExpr))\n\t\targs = ((ScalarArrayOpExpr *) expr)->args;\n\telse if (IsA(expr, NullIfExpr))\n\t\targs = ((NullIfExpr *) expr)->args;\n\telse if (IsA(expr, WindowFunc))\n\t\targs = ((WindowFunc *) expr)->args;\n\telse\n\t\treturn InvalidOid;\n\n\tif (argnum < 0 || argnum >= list_length(args))\n\t\treturn InvalidOid;\n\n\targtype = exprType((Node *) list_nth(args, argnum));\n\n\t/*\n\t * special hack for ScalarArrayOpExpr: what the underlying function will\n\t * actually get passed is the element type of the array.\n\t */\n\tif (IsA(expr, ScalarArrayOpExpr) &&\n\t\targnum == 1)\n\t\targtype = get_base_element_type(argtype);\n\n\treturn argtype;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_argtype(FmgrInfo *flinfo, int argnum)\n{\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\treturn get_call_expr_argtype(flinfo->fn_expr, argnum);\n}"
  },
  {
    "function_name": "get_fn_expr_rettype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1972-1987",
    "snippet": "Oid\nget_fn_expr_rettype(FmgrInfo *flinfo)\n{\n\tNode\t   *expr;\n\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\texpr = flinfo->fn_expr;\n\n\treturn exprType(expr);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exprType",
          "args": [
            "expr"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nget_fn_expr_rettype(FmgrInfo *flinfo)\n{\n\tNode\t   *expr;\n\n\t/*\n\t * can't return anything useful if we have no FmgrInfo or if its fn_expr\n\t * node has not been initialized\n\t */\n\tif (!flinfo || !flinfo->fn_expr)\n\t\treturn InvalidOid;\n\n\texpr = flinfo->fn_expr;\n\n\treturn exprType(expr);\n}"
  },
  {
    "function_name": "pg_detoast_datum_packed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1948-1955",
    "snippet": "struct varlena *\npg_detoast_datum_packed(struct varlena *datum)\n{\n\tif (VARATT_IS_COMPRESSED(datum) || VARATT_IS_EXTERNAL(datum))\n\t\treturn heap_tuple_untoast_attr(datum);\n\telse\n\t\treturn datum;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_tuple_untoast_attr",
          "args": [
            "datum"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTERNAL",
          "args": [
            "datum"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARATT_IS_COMPRESSED",
          "args": [
            "datum"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstruct varlena *\npg_detoast_datum_packed(struct varlena *datum)\n{\n\tif (VARATT_IS_COMPRESSED(datum) || VARATT_IS_EXTERNAL(datum))\n\t\treturn heap_tuple_untoast_attr(datum);\n\telse\n\t\treturn datum;\n}"
  },
  {
    "function_name": "pg_detoast_datum_slice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1941-1946",
    "snippet": "struct varlena *\npg_detoast_datum_slice(struct varlena *datum, int32 first, int32 count)\n{\n\t/* Only get the specified portion from the toast rel */\n\treturn heap_tuple_untoast_attr_slice(datum, first, count);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_tuple_untoast_attr_slice",
          "args": [
            "datum",
            "first",
            "count"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstruct varlena *\npg_detoast_datum_slice(struct varlena *datum, int32 first, int32 count)\n{\n\t/* Only get the specified portion from the toast rel */\n\treturn heap_tuple_untoast_attr_slice(datum, first, count);\n}"
  },
  {
    "function_name": "pg_detoast_datum_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1925-1939",
    "snippet": "struct varlena *\npg_detoast_datum_copy(struct varlena *datum)\n{\n\tif (VARATT_IS_EXTENDED(datum))\n\t\treturn heap_tuple_untoast_attr(datum);\n\telse\n\t{\n\t\t/* Make a modifiable copy of the varlena object */\n\t\tSize\t\tlen = VARSIZE(datum);\n\t\tstruct varlena *result = (struct varlena *) palloc(len);\n\n\t\tmemcpy(result, datum, len);\n\t\treturn result;\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "result",
            "datum",
            "len"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "datum"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_tuple_untoast_attr",
          "args": [
            "datum"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTENDED",
          "args": [
            "datum"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstruct varlena *\npg_detoast_datum_copy(struct varlena *datum)\n{\n\tif (VARATT_IS_EXTENDED(datum))\n\t\treturn heap_tuple_untoast_attr(datum);\n\telse\n\t{\n\t\t/* Make a modifiable copy of the varlena object */\n\t\tSize\t\tlen = VARSIZE(datum);\n\t\tstruct varlena *result = (struct varlena *) palloc(len);\n\n\t\tmemcpy(result, datum, len);\n\t\treturn result;\n\t}\n}"
  },
  {
    "function_name": "pg_detoast_datum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1916-1923",
    "snippet": "struct varlena *\npg_detoast_datum(struct varlena *datum)\n{\n\tif (VARATT_IS_EXTENDED(datum))\n\t\treturn heap_tuple_untoast_attr(datum);\n\telse\n\t\treturn datum;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_tuple_untoast_attr",
          "args": [
            "datum"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARATT_IS_EXTENDED",
          "args": [
            "datum"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstruct varlena *\npg_detoast_datum(struct varlena *datum)\n{\n\tif (VARATT_IS_EXTENDED(datum))\n\t\treturn heap_tuple_untoast_attr(datum);\n\telse\n\t\treturn datum;\n}"
  },
  {
    "function_name": "Float8GetDatum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1900-1907",
    "snippet": "Datum\nFloat8GetDatum(float8 X)\n{\n\tfloat8\t   *retval = (float8 *) palloc(sizeof(float8));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "retval"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(float8)"
          ],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nFloat8GetDatum(float8 X)\n{\n\tfloat8\t   *retval = (float8 *) palloc(sizeof(float8));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
  },
  {
    "function_name": "Float4GetDatum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1888-1895",
    "snippet": "Datum\nFloat4GetDatum(float4 X)\n{\n\tfloat4\t   *retval = (float4 *) palloc(sizeof(float4));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "retval"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(float4)"
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nFloat4GetDatum(float4 X)\n{\n\tfloat4\t   *retval = (float4 *) palloc(sizeof(float4));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
  },
  {
    "function_name": "Int64GetDatum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1876-1883",
    "snippet": "Datum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "retval"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(int64)"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nInt64GetDatum(int64 X)\n{\n\tint64\t   *retval = (int64 *) palloc(sizeof(int64));\n\n\t*retval = X;\n\treturn PointerGetDatum(retval);\n}"
  },
  {
    "function_name": "OidSendFunctionCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1851-1858",
    "snippet": "bytea *\nOidSendFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn SendFunctionCall(&flinfo, val);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SendFunctionCall",
          "args": [
            "&flinfo",
            "val"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "OidSendFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1851-1858",
          "snippet": "bytea *\nOidSendFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn SendFunctionCall(&flinfo, val);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "functionId",
            "&flinfo"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nbytea *\nOidSendFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn SendFunctionCall(&flinfo, val);\n}"
  },
  {
    "function_name": "OidReceiveFunctionCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1841-1849",
    "snippet": "Datum\nOidReceiveFunctionCall(Oid functionId, StringInfo buf,\n\t\t\t\t\t   Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn ReceiveFunctionCall(&flinfo, buf, typioparam, typmod);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReceiveFunctionCall",
          "args": [
            "&flinfo",
            "buf",
            "typioparam",
            "typmod"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "OidReceiveFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1841-1849",
          "snippet": "Datum\nOidReceiveFunctionCall(Oid functionId, StringInfo buf,\n\t\t\t\t\t   Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn ReceiveFunctionCall(&flinfo, buf, typioparam, typmod);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "functionId",
            "&flinfo"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidReceiveFunctionCall(Oid functionId, StringInfo buf,\n\t\t\t\t\t   Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn ReceiveFunctionCall(&flinfo, buf, typioparam, typmod);\n}"
  },
  {
    "function_name": "OidOutputFunctionCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1832-1839",
    "snippet": "char *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OutputFunctionCall",
          "args": [
            "&flinfo",
            "val"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "OidOutputFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1832-1839",
          "snippet": "char *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "functionId",
            "&flinfo"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nchar *\nOidOutputFunctionCall(Oid functionId, Datum val)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn OutputFunctionCall(&flinfo, val);\n}"
  },
  {
    "function_name": "OidInputFunctionCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1823-1830",
    "snippet": "Datum\nOidInputFunctionCall(Oid functionId, char *str, Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn InputFunctionCall(&flinfo, str, typioparam, typmod);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "InputFunctionCall",
          "args": [
            "&flinfo",
            "str",
            "typioparam",
            "typmod"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "OidInputFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1823-1830",
          "snippet": "Datum\nOidInputFunctionCall(Oid functionId, char *str, Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn InputFunctionCall(&flinfo, str, typioparam, typmod);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "functionId",
            "&flinfo"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidInputFunctionCall(Oid functionId, char *str, Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn InputFunctionCall(&flinfo, str, typioparam, typmod);\n}"
  },
  {
    "function_name": "SendFunctionCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1813-1817",
    "snippet": "bytea *\nSendFunctionCall(FmgrInfo *flinfo, Datum val)\n{\n\treturn DatumGetByteaP(FunctionCall1(flinfo, val));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetByteaP",
          "args": [
            "FunctionCall1(flinfo, val)"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall1",
          "args": [
            "flinfo",
            "val"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nbytea *\nSendFunctionCall(FmgrInfo *flinfo, Datum val)\n{\n\treturn DatumGetByteaP(FunctionCall1(flinfo, val));\n}"
  },
  {
    "function_name": "ReceiveFunctionCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1766-1802",
    "snippet": "Datum\nReceiveFunctionCall(FmgrInfo *flinfo, StringInfo buf,\n\t\t\t\t\tOid typioparam, int32 typmod)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tif (buf == NULL && flinfo->fn_strict)\n\t\treturn (Datum) 0;\t\t/* just return null result */\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 3, InvalidOid, NULL, NULL);\n\n\tfcinfo.arg[0] = PointerGetDatum(buf);\n\tfcinfo.arg[1] = ObjectIdGetDatum(typioparam);\n\tfcinfo.arg[2] = Int32GetDatum(typmod);\n\tfcinfo.argnull[0] = (buf == NULL);\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Should get null result if and only if buf is NULL */\n\tif (buf == NULL)\n\t{\n\t\tif (!fcinfo.isnull)\n\t\t\telog(ERROR, \"receive function %u returned non-NULL\",\n\t\t\t\t fcinfo.flinfo->fn_oid);\n\t}\n\telse\n\t{\n\t\tif (fcinfo.isnull)\n\t\t\telog(ERROR, \"receive function %u returned NULL\",\n\t\t\t\t fcinfo.flinfo->fn_oid);\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"receive function %u returned NULL\"",
            "fcinfo.flinfo->fn_oid"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "typmod"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "typioparam"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "buf"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "flinfo",
            "3",
            "InvalidOid",
            "NULL",
            "NULL"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nReceiveFunctionCall(FmgrInfo *flinfo, StringInfo buf,\n\t\t\t\t\tOid typioparam, int32 typmod)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tif (buf == NULL && flinfo->fn_strict)\n\t\treturn (Datum) 0;\t\t/* just return null result */\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 3, InvalidOid, NULL, NULL);\n\n\tfcinfo.arg[0] = PointerGetDatum(buf);\n\tfcinfo.arg[1] = ObjectIdGetDatum(typioparam);\n\tfcinfo.arg[2] = Int32GetDatum(typmod);\n\tfcinfo.argnull[0] = (buf == NULL);\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Should get null result if and only if buf is NULL */\n\tif (buf == NULL)\n\t{\n\t\tif (!fcinfo.isnull)\n\t\t\telog(ERROR, \"receive function %u returned non-NULL\",\n\t\t\t\t fcinfo.flinfo->fn_oid);\n\t}\n\telse\n\t{\n\t\tif (fcinfo.isnull)\n\t\t\telog(ERROR, \"receive function %u returned NULL\",\n\t\t\t\t fcinfo.flinfo->fn_oid);\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "OutputFunctionCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1752-1756",
    "snippet": "char *\nOutputFunctionCall(FmgrInfo *flinfo, Datum val)\n{\n\treturn DatumGetCString(FunctionCall1(flinfo, val));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "FunctionCall1(flinfo, val)"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall1",
          "args": [
            "flinfo",
            "val"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nchar *\nOutputFunctionCall(FmgrInfo *flinfo, Datum val)\n{\n\treturn DatumGetCString(FunctionCall1(flinfo, val));\n}"
  },
  {
    "function_name": "InputFunctionCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1708-1743",
    "snippet": "Datum\nInputFunctionCall(FmgrInfo *flinfo, char *str, Oid typioparam, int32 typmod)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tif (str == NULL && flinfo->fn_strict)\n\t\treturn (Datum) 0;\t\t/* just return null result */\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 3, InvalidOid, NULL, NULL);\n\n\tfcinfo.arg[0] = CStringGetDatum(str);\n\tfcinfo.arg[1] = ObjectIdGetDatum(typioparam);\n\tfcinfo.arg[2] = Int32GetDatum(typmod);\n\tfcinfo.argnull[0] = (str == NULL);\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Should get null result if and only if str is NULL */\n\tif (str == NULL)\n\t{\n\t\tif (!fcinfo.isnull)\n\t\t\telog(ERROR, \"input function %u returned non-NULL\",\n\t\t\t\t fcinfo.flinfo->fn_oid);\n\t}\n\telse\n\t{\n\t\tif (fcinfo.isnull)\n\t\t\telog(ERROR, \"input function %u returned NULL\",\n\t\t\t\t fcinfo.flinfo->fn_oid);\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"input function %u returned NULL\"",
            "fcinfo.flinfo->fn_oid"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "typmod"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "typioparam"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "str"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "flinfo",
            "3",
            "InvalidOid",
            "NULL",
            "NULL"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nInputFunctionCall(FmgrInfo *flinfo, char *str, Oid typioparam, int32 typmod)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tif (str == NULL && flinfo->fn_strict)\n\t\treturn (Datum) 0;\t\t/* just return null result */\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 3, InvalidOid, NULL, NULL);\n\n\tfcinfo.arg[0] = CStringGetDatum(str);\n\tfcinfo.arg[1] = ObjectIdGetDatum(typioparam);\n\tfcinfo.arg[2] = Int32GetDatum(typmod);\n\tfcinfo.argnull[0] = (str == NULL);\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Should get null result if and only if str is NULL */\n\tif (str == NULL)\n\t{\n\t\tif (!fcinfo.isnull)\n\t\t\telog(ERROR, \"input function %u returned non-NULL\",\n\t\t\t\t fcinfo.flinfo->fn_oid);\n\t}\n\telse\n\t{\n\t\tif (fcinfo.isnull)\n\t\t\telog(ERROR, \"input function %u returned NULL\",\n\t\t\t\t fcinfo.flinfo->fn_oid);\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "OidFunctionCall9Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1653-1693",
    "snippet": "Datum\nOidFunctionCall9Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t Datum arg6, Datum arg7, Datum arg8,\n\t\t\t\t\t Datum arg9)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 9, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.arg[6] = arg7;\n\tfcinfo.arg[7] = arg8;\n\tfcinfo.arg[8] = arg9;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\tfcinfo.argnull[6] = false;\n\tfcinfo.argnull[7] = false;\n\tfcinfo.argnull[8] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %u returned NULL\"",
            "flinfo.fn_oid"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "&flinfo",
            "9",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "functionId",
            "&flinfo"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall9Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t Datum arg6, Datum arg7, Datum arg8,\n\t\t\t\t\t Datum arg9)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 9, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.arg[6] = arg7;\n\tfcinfo.arg[7] = arg8;\n\tfcinfo.arg[8] = arg9;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\tfcinfo.argnull[6] = false;\n\tfcinfo.argnull[7] = false;\n\tfcinfo.argnull[8] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
  },
  {
    "function_name": "OidFunctionCall8Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1614-1651",
    "snippet": "Datum\nOidFunctionCall8Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t Datum arg6, Datum arg7, Datum arg8)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 8, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.arg[6] = arg7;\n\tfcinfo.arg[7] = arg8;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\tfcinfo.argnull[6] = false;\n\tfcinfo.argnull[7] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %u returned NULL\"",
            "flinfo.fn_oid"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "&flinfo",
            "8",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "functionId",
            "&flinfo"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall8Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t Datum arg6, Datum arg7, Datum arg8)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 8, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.arg[6] = arg7;\n\tfcinfo.arg[7] = arg8;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\tfcinfo.argnull[6] = false;\n\tfcinfo.argnull[7] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
  },
  {
    "function_name": "OidFunctionCall7Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1577-1612",
    "snippet": "Datum\nOidFunctionCall7Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t Datum arg6, Datum arg7)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 7, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.arg[6] = arg7;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\tfcinfo.argnull[6] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %u returned NULL\"",
            "flinfo.fn_oid"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "&flinfo",
            "7",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "functionId",
            "&flinfo"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall7Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t Datum arg6, Datum arg7)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 7, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.arg[6] = arg7;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\tfcinfo.argnull[6] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
  },
  {
    "function_name": "OidFunctionCall6Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1542-1575",
    "snippet": "Datum\nOidFunctionCall6Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t Datum arg6)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 6, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %u returned NULL\"",
            "flinfo.fn_oid"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "&flinfo",
            "6",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "functionId",
            "&flinfo"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall6Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t Datum arg6)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 6, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
  },
  {
    "function_name": "OidFunctionCall5Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1510-1540",
    "snippet": "Datum\nOidFunctionCall5Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4, Datum arg5)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 5, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %u returned NULL\"",
            "flinfo.fn_oid"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "&flinfo",
            "5",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "functionId",
            "&flinfo"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall5Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4, Datum arg5)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 5, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
  },
  {
    "function_name": "OidFunctionCall4Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1480-1508",
    "snippet": "Datum\nOidFunctionCall4Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 4, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %u returned NULL\"",
            "flinfo.fn_oid"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "&flinfo",
            "4",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "functionId",
            "&flinfo"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall4Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3, Datum arg4)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 4, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
  },
  {
    "function_name": "OidFunctionCall3Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1452-1478",
    "snippet": "Datum\nOidFunctionCall3Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 3, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %u returned NULL\"",
            "flinfo.fn_oid"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "&flinfo",
            "3",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "functionId",
            "&flinfo"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall3Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t Datum arg3)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 3, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
  },
  {
    "function_name": "OidFunctionCall2Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1427-1450",
    "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %u returned NULL\"",
            "flinfo.fn_oid"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "&flinfo",
            "2",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "functionId",
            "&flinfo"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
  },
  {
    "function_name": "OidFunctionCall1Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1404-1425",
    "snippet": "Datum\nOidFunctionCall1Coll(Oid functionId, Oid collation, Datum arg1)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 1, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.argnull[0] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %u returned NULL\"",
            "flinfo.fn_oid"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "&flinfo",
            "1",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "functionId",
            "&flinfo"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall1Coll(Oid functionId, Oid collation, Datum arg1)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 1, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.argnull[0] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
  },
  {
    "function_name": "OidFunctionCall0Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1384-1402",
    "snippet": "Datum\nOidFunctionCall0Coll(Oid functionId, Oid collation)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 0, collation, NULL, NULL);\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %u returned NULL\"",
            "flinfo.fn_oid"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "&flinfo",
            "0",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info",
          "args": [
            "functionId",
            "&flinfo"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "123-127",
          "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall0Coll(Oid functionId, Oid collation)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 0, collation, NULL, NULL);\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
  },
  {
    "function_name": "FunctionCall9Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1337-1374",
    "snippet": "Datum\nFunctionCall9Coll(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t  Datum arg6, Datum arg7, Datum arg8,\n\t\t\t\t  Datum arg9)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 9, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.arg[6] = arg7;\n\tfcinfo.arg[7] = arg8;\n\tfcinfo.arg[8] = arg9;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\tfcinfo.argnull[6] = false;\n\tfcinfo.argnull[7] = false;\n\tfcinfo.argnull[8] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", fcinfo.flinfo->fn_oid);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %u returned NULL\"",
            "fcinfo.flinfo->fn_oid"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "flinfo",
            "9",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nFunctionCall9Coll(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t  Datum arg6, Datum arg7, Datum arg8,\n\t\t\t\t  Datum arg9)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 9, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.arg[6] = arg7;\n\tfcinfo.arg[7] = arg8;\n\tfcinfo.arg[8] = arg9;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\tfcinfo.argnull[6] = false;\n\tfcinfo.argnull[7] = false;\n\tfcinfo.argnull[8] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", fcinfo.flinfo->fn_oid);\n\n\treturn result;\n}"
  },
  {
    "function_name": "FunctionCall8Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1301-1335",
    "snippet": "Datum\nFunctionCall8Coll(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t  Datum arg6, Datum arg7, Datum arg8)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 8, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.arg[6] = arg7;\n\tfcinfo.arg[7] = arg8;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\tfcinfo.argnull[6] = false;\n\tfcinfo.argnull[7] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", fcinfo.flinfo->fn_oid);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %u returned NULL\"",
            "fcinfo.flinfo->fn_oid"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "flinfo",
            "8",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nFunctionCall8Coll(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t  Datum arg6, Datum arg7, Datum arg8)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 8, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.arg[6] = arg7;\n\tfcinfo.arg[7] = arg8;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\tfcinfo.argnull[6] = false;\n\tfcinfo.argnull[7] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", fcinfo.flinfo->fn_oid);\n\n\treturn result;\n}"
  },
  {
    "function_name": "FunctionCall7Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1267-1299",
    "snippet": "Datum\nFunctionCall7Coll(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t  Datum arg6, Datum arg7)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 7, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.arg[6] = arg7;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\tfcinfo.argnull[6] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", fcinfo.flinfo->fn_oid);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %u returned NULL\"",
            "fcinfo.flinfo->fn_oid"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "flinfo",
            "7",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nFunctionCall7Coll(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t  Datum arg6, Datum arg7)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 7, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.arg[6] = arg7;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\tfcinfo.argnull[6] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", fcinfo.flinfo->fn_oid);\n\n\treturn result;\n}"
  },
  {
    "function_name": "FunctionCall6Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1235-1265",
    "snippet": "Datum\nFunctionCall6Coll(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t  Datum arg6)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 6, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", fcinfo.flinfo->fn_oid);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %u returned NULL\"",
            "fcinfo.flinfo->fn_oid"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "flinfo",
            "6",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nFunctionCall6Coll(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t  Datum arg6)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 6, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", fcinfo.flinfo->fn_oid);\n\n\treturn result;\n}"
  },
  {
    "function_name": "FunctionCall5Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1206-1233",
    "snippet": "Datum\nFunctionCall5Coll(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3, Datum arg4, Datum arg5)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 5, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", fcinfo.flinfo->fn_oid);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %u returned NULL\"",
            "fcinfo.flinfo->fn_oid"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "flinfo",
            "5",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nFunctionCall5Coll(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3, Datum arg4, Datum arg5)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 5, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", fcinfo.flinfo->fn_oid);\n\n\treturn result;\n}"
  },
  {
    "function_name": "FunctionCall4Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1179-1204",
    "snippet": "Datum\nFunctionCall4Coll(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3, Datum arg4)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 4, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", fcinfo.flinfo->fn_oid);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %u returned NULL\"",
            "fcinfo.flinfo->fn_oid"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "flinfo",
            "4",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nFunctionCall4Coll(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3, Datum arg4)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 4, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", fcinfo.flinfo->fn_oid);\n\n\treturn result;\n}"
  },
  {
    "function_name": "FunctionCall3Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1154-1177",
    "snippet": "Datum\nFunctionCall3Coll(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 3, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", fcinfo.flinfo->fn_oid);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %u returned NULL\"",
            "fcinfo.flinfo->fn_oid"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "flinfo",
            "3",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nFunctionCall3Coll(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t  Datum arg3)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 3, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", fcinfo.flinfo->fn_oid);\n\n\treturn result;\n}"
  },
  {
    "function_name": "FunctionCall2Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1132-1152",
    "snippet": "Datum\nFunctionCall2Coll(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", fcinfo.flinfo->fn_oid);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %u returned NULL\"",
            "fcinfo.flinfo->fn_oid"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "flinfo",
            "2",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nFunctionCall2Coll(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", fcinfo.flinfo->fn_oid);\n\n\treturn result;\n}"
  },
  {
    "function_name": "FunctionCall1Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1112-1130",
    "snippet": "Datum\nFunctionCall1Coll(FmgrInfo *flinfo, Oid collation, Datum arg1)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 1, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.argnull[0] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", fcinfo.flinfo->fn_oid);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %u returned NULL\"",
            "fcinfo.flinfo->fn_oid"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "&fcinfo"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "flinfo",
            "1",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nFunctionCall1Coll(FmgrInfo *flinfo, Oid collation, Datum arg1)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 1, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.argnull[0] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", fcinfo.flinfo->fn_oid);\n\n\treturn result;\n}"
  },
  {
    "function_name": "CallerFInfoFunctionCall2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1085-1105",
    "snippet": "Datum\nCallerFInfoFunctionCall2(PGFunction func, FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %p returned NULL\"",
            "(void *) func"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "&fcinfo"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "flinfo",
            "2",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nCallerFInfoFunctionCall2(PGFunction func, FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}"
  },
  {
    "function_name": "CallerFInfoFunctionCall1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1065-1083",
    "snippet": "Datum\nCallerFInfoFunctionCall1(PGFunction func, FmgrInfo *flinfo, Oid collation, Datum arg1)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 1, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.argnull[0] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %p returned NULL\"",
            "(void *) func"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "&fcinfo"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "flinfo",
            "1",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nCallerFInfoFunctionCall1(PGFunction func, FmgrInfo *flinfo, Oid collation, Datum arg1)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, flinfo, 1, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.argnull[0] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}"
  },
  {
    "function_name": "DirectFunctionCall9Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "1017-1054",
    "snippet": "Datum\nDirectFunctionCall9Coll(PGFunction func, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t\tDatum arg6, Datum arg7, Datum arg8,\n\t\t\t\t\t\tDatum arg9)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, NULL, 9, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.arg[6] = arg7;\n\tfcinfo.arg[7] = arg8;\n\tfcinfo.arg[8] = arg9;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\tfcinfo.argnull[6] = false;\n\tfcinfo.argnull[7] = false;\n\tfcinfo.argnull[8] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %p returned NULL\"",
            "(void *) func"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "&fcinfo"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "NULL",
            "9",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nDirectFunctionCall9Coll(PGFunction func, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t\tDatum arg6, Datum arg7, Datum arg8,\n\t\t\t\t\t\tDatum arg9)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, NULL, 9, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.arg[6] = arg7;\n\tfcinfo.arg[7] = arg8;\n\tfcinfo.arg[8] = arg9;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\tfcinfo.argnull[6] = false;\n\tfcinfo.argnull[7] = false;\n\tfcinfo.argnull[8] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}"
  },
  {
    "function_name": "DirectFunctionCall8Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "981-1015",
    "snippet": "Datum\nDirectFunctionCall8Coll(PGFunction func, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t\tDatum arg6, Datum arg7, Datum arg8)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, NULL, 8, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.arg[6] = arg7;\n\tfcinfo.arg[7] = arg8;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\tfcinfo.argnull[6] = false;\n\tfcinfo.argnull[7] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %p returned NULL\"",
            "(void *) func"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "&fcinfo"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "NULL",
            "8",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nDirectFunctionCall8Coll(PGFunction func, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t\tDatum arg6, Datum arg7, Datum arg8)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, NULL, 8, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.arg[6] = arg7;\n\tfcinfo.arg[7] = arg8;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\tfcinfo.argnull[6] = false;\n\tfcinfo.argnull[7] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}"
  },
  {
    "function_name": "DirectFunctionCall7Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "947-979",
    "snippet": "Datum\nDirectFunctionCall7Coll(PGFunction func, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t\tDatum arg6, Datum arg7)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, NULL, 7, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.arg[6] = arg7;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\tfcinfo.argnull[6] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %p returned NULL\"",
            "(void *) func"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "&fcinfo"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "NULL",
            "7",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nDirectFunctionCall7Coll(PGFunction func, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t\tDatum arg6, Datum arg7)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, NULL, 7, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.arg[6] = arg7;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\tfcinfo.argnull[6] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}"
  },
  {
    "function_name": "DirectFunctionCall6Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "915-945",
    "snippet": "Datum\nDirectFunctionCall6Coll(PGFunction func, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t\tDatum arg6)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, NULL, 6, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %p returned NULL\"",
            "(void *) func"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "&fcinfo"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "NULL",
            "6",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nDirectFunctionCall6Coll(PGFunction func, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\t\tDatum arg6)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, NULL, 6, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.arg[5] = arg6;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\tfcinfo.argnull[5] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}"
  },
  {
    "function_name": "DirectFunctionCall5Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "886-913",
    "snippet": "Datum\nDirectFunctionCall5Coll(PGFunction func, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3, Datum arg4, Datum arg5)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, NULL, 5, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %p returned NULL\"",
            "(void *) func"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "&fcinfo"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "NULL",
            "5",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nDirectFunctionCall5Coll(PGFunction func, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3, Datum arg4, Datum arg5)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, NULL, 5, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.arg[4] = arg5;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\tfcinfo.argnull[4] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}"
  },
  {
    "function_name": "DirectFunctionCall4Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "859-884",
    "snippet": "Datum\nDirectFunctionCall4Coll(PGFunction func, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3, Datum arg4)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, NULL, 4, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %p returned NULL\"",
            "(void *) func"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "&fcinfo"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "NULL",
            "4",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nDirectFunctionCall4Coll(PGFunction func, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3, Datum arg4)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, NULL, 4, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.arg[3] = arg4;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\tfcinfo.argnull[3] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}"
  },
  {
    "function_name": "DirectFunctionCall3Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "834-857",
    "snippet": "Datum\nDirectFunctionCall3Coll(PGFunction func, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, NULL, 3, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %p returned NULL\"",
            "(void *) func"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "&fcinfo"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "NULL",
            "3",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nDirectFunctionCall3Coll(PGFunction func, Oid collation, Datum arg1, Datum arg2,\n\t\t\t\t\t\tDatum arg3)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, NULL, 3, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.arg[2] = arg3;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\tfcinfo.argnull[2] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}"
  },
  {
    "function_name": "DirectFunctionCall2Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "812-832",
    "snippet": "Datum\nDirectFunctionCall2Coll(PGFunction func, Oid collation, Datum arg1, Datum arg2)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, NULL, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %p returned NULL\"",
            "(void *) func"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "&fcinfo"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "NULL",
            "2",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nDirectFunctionCall2Coll(PGFunction func, Oid collation, Datum arg1, Datum arg2)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, NULL, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}"
  },
  {
    "function_name": "DirectFunctionCall1Coll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "792-810",
    "snippet": "Datum\nDirectFunctionCall1Coll(PGFunction func, Oid collation, Datum arg1)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, NULL, 1, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.argnull[0] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"function %p returned NULL\"",
            "(void *) func"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "&fcinfo"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitFunctionCallInfoData",
          "args": [
            "fcinfo",
            "NULL",
            "1",
            "collation",
            "NULL",
            "NULL"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nDirectFunctionCall1Coll(PGFunction func, Oid collation, Datum arg1)\n{\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tInitFunctionCallInfoData(fcinfo, NULL, 1, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.argnull[0] = false;\n\n\tresult = (*func) (&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %p returned NULL\", (void *) func);\n\n\treturn result;\n}"
  },
  {
    "function_name": "fmgr_security_definer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "659-778",
    "snippet": "extern Datum\nfmgr_security_definer(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tresult;\n\tstruct fmgr_security_definer_cache *volatile fcache;\n\tFmgrInfo   *save_flinfo;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\tvolatile int save_nestlevel;\n\tPgStat_FunctionCallUsage fcusage;\n\n\tif (!fcinfo->flinfo->fn_extra)\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_proc procedureStruct;\n\t\tDatum\t\tdatum;\n\t\tbool\t\tisnull;\n\t\tMemoryContext oldcxt;\n\n\t\tfcache = MemoryContextAllocZero(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\tsizeof(*fcache));\n\n\t\tfmgr_info_cxt_security(fcinfo->flinfo->fn_oid, &fcache->flinfo,\n\t\t\t\t\t\t\t   fcinfo->flinfo->fn_mcxt, true);\n\t\tfcache->flinfo.fn_expr = fcinfo->flinfo->fn_expr;\n\n\t\ttuple = SearchSysCache1(PROCOID,\n\t\t\t\t\t\t\t\tObjectIdGetDatum(fcinfo->flinfo->fn_oid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for function %u\",\n\t\t\t\t fcinfo->flinfo->fn_oid);\n\t\tprocedureStruct = (Form_pg_proc) GETSTRUCT(tuple);\n\n\t\tif (procedureStruct->prosecdef)\n\t\t\tfcache->userid = procedureStruct->proowner;\n\n\t\tdatum = SysCacheGetAttr(PROCOID, tuple, Anum_pg_proc_proconfig,\n\t\t\t\t\t\t\t\t&isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\toldcxt = MemoryContextSwitchTo(fcinfo->flinfo->fn_mcxt);\n\t\t\tfcache->proconfig = DatumGetArrayTypePCopy(datum);\n\t\t\tMemoryContextSwitchTo(oldcxt);\n\t\t}\n\n\t\tReleaseSysCache(tuple);\n\n\t\tfcinfo->flinfo->fn_extra = fcache;\n\t}\n\telse\n\t\tfcache = fcinfo->flinfo->fn_extra;\n\n\t/* GetUserIdAndSecContext is cheap enough that no harm in a wasted call */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tif (fcache->proconfig)\t\t/* Need a new GUC nesting level */\n\t\tsave_nestlevel = NewGUCNestLevel();\n\telse\n\t\tsave_nestlevel = 0;\t\t/* keep compiler quiet */\n\n\tif (OidIsValid(fcache->userid))\n\t\tSetUserIdAndSecContext(fcache->userid,\n\t\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE);\n\n\tif (fcache->proconfig)\n\t{\n\t\tProcessGUCArray(fcache->proconfig,\n\t\t\t\t\t\t(superuser() ? PGC_SUSET : PGC_USERSET),\n\t\t\t\t\t\tPGC_S_SESSION,\n\t\t\t\t\t\tGUC_ACTION_SAVE);\n\t}\n\n\t/* function manager hook */\n\tif (fmgr_hook)\n\t\t(*fmgr_hook) (FHET_START, &fcache->flinfo, &fcache->arg);\n\n\t/*\n\t * We don't need to restore GUC or userid settings on error, because the\n\t * ensuing xact or subxact abort will do that.  The PG_TRY block is only\n\t * needed to clean up the flinfo link.\n\t */\n\tsave_flinfo = fcinfo->flinfo;\n\n\tPG_TRY();\n\t{\n\t\tfcinfo->flinfo = &fcache->flinfo;\n\n\t\t/* See notes in fmgr_info_cxt_security */\n\t\tpgstat_init_function_usage(fcinfo, &fcusage);\n\n\t\tresult = FunctionCallInvoke(fcinfo);\n\n\t\t/*\n\t\t * We could be calling either a regular or a set-returning function,\n\t\t * so we have to test to see what finalize flag to use.\n\t\t */\n\t\tpgstat_end_function_usage(&fcusage,\n\t\t\t\t\t\t\t\t  (fcinfo->resultinfo == NULL ||\n\t\t\t\t\t\t\t\t   !IsA(fcinfo->resultinfo, ReturnSetInfo) ||\n\t\t\t\t\t\t\t\t   ((ReturnSetInfo *) fcinfo->resultinfo)->isDone != ExprMultipleResult));\n\t}\n\tPG_CATCH();\n\t{\n\t\tfcinfo->flinfo = save_flinfo;\n\t\tif (fmgr_hook)\n\t\t\t(*fmgr_hook) (FHET_ABORT, &fcache->flinfo, &fcache->arg);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\tfcinfo->flinfo = save_flinfo;\n\n\tif (fcache->proconfig)\n\t\tAtEOXact_GUC(true, save_nestlevel);\n\tif (OidIsValid(fcache->userid))\n\t\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\tif (fmgr_hook)\n\t\t(*fmgr_hook) (FHET_END, &fcache->flinfo, &fcache->arg);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "PGDLLIMPORT fmgr_hook_type fmgr_hook = NULL;",
      "extern Datum fmgr_security_definer(PG_FUNCTION_ARGS);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "FHET_END",
            "&fcache->flinfo",
            "&fcache->arg"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetUserIdAndSecContext",
          "args": [
            "save_userid",
            "save_sec_context"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "SetUserIdAndSecContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "498-503",
          "snippet": "void\nSetUserIdAndSecContext(Oid userid, int sec_context)\n{\n\tCurrentUserId = userid;\n\tSecurityRestrictionContext = sec_context;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;",
            "static int\tSecurityRestrictionContext = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\nstatic int\tSecurityRestrictionContext = 0;\n\nvoid\nSetUserIdAndSecContext(Oid userid, int sec_context)\n{\n\tCurrentUserId = userid;\n\tSecurityRestrictionContext = sec_context;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "fcache->userid"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AtEOXact_GUC",
          "args": [
            "true",
            "save_nestlevel"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "AtEOXact_GUC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/guc.c",
          "lines": "5331-5606",
          "snippet": "void\nAtEOXact_GUC(bool isCommit, int nestLevel)\n{\n\tbool\t\tstill_dirty;\n\tint\t\t\ti;\n\n\t/*\n\t * Note: it's possible to get here with GUCNestLevel == nestLevel-1 during\n\t * abort, if there is a failure during transaction start before\n\t * AtStart_GUC is called.\n\t */\n\tAssert(nestLevel > 0 &&\n\t\t   (nestLevel <= GUCNestLevel ||\n\t\t\t(nestLevel == GUCNestLevel + 1 && !isCommit)));\n\n\t/* Quick exit if nothing's changed in this transaction */\n\tif (!guc_dirty)\n\t{\n\t\tGUCNestLevel = nestLevel - 1;\n\t\treturn;\n\t}\n\n\tstill_dirty = false;\n\tfor (i = 0; i < num_guc_variables; i++)\n\t{\n\t\tstruct config_generic *gconf = guc_variables[i];\n\t\tGucStack   *stack;\n\n\t\t/*\n\t\t * Process and pop each stack entry within the nest level. To simplify\n\t\t * fmgr_security_definer() and other places that use GUC_ACTION_SAVE,\n\t\t * we allow failure exit from code that uses a local nest level to be\n\t\t * recovered at the surrounding transaction or subtransaction abort;\n\t\t * so there could be more than one stack entry to pop.\n\t\t */\n\t\twhile ((stack = gconf->stack) != NULL &&\n\t\t\t   stack->nest_level >= nestLevel)\n\t\t{\n\t\t\tGucStack   *prev = stack->prev;\n\t\t\tbool\t\trestorePrior = false;\n\t\t\tbool\t\trestoreMasked = false;\n\t\t\tbool\t\tchanged;\n\n\t\t\t/*\n\t\t\t * In this next bit, if we don't set either restorePrior or\n\t\t\t * restoreMasked, we must \"discard\" any unwanted fields of the\n\t\t\t * stack entries to avoid leaking memory.  If we do set one of\n\t\t\t * those flags, unused fields will be cleaned up after restoring.\n\t\t\t */\n\t\t\tif (!isCommit)\t\t/* if abort, always restore prior value */\n\t\t\t\trestorePrior = true;\n\t\t\telse if (stack->state == GUC_SAVE)\n\t\t\t\trestorePrior = true;\n\t\t\telse if (stack->nest_level == 1)\n\t\t\t{\n\t\t\t\t/* transaction commit */\n\t\t\t\tif (stack->state == GUC_SET_LOCAL)\n\t\t\t\t\trestoreMasked = true;\n\t\t\t\telse if (stack->state == GUC_SET)\n\t\t\t\t{\n\t\t\t\t\t/* we keep the current active value */\n\t\t\t\t\tdiscard_stack_value(gconf, &stack->prior);\n\t\t\t\t}\n\t\t\t\telse\t\t\t/* must be GUC_LOCAL */\n\t\t\t\t\trestorePrior = true;\n\t\t\t}\n\t\t\telse if (prev == NULL ||\n\t\t\t\t\t prev->nest_level < stack->nest_level - 1)\n\t\t\t{\n\t\t\t\t/* decrement entry's level and do not pop it */\n\t\t\t\tstack->nest_level--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We have to merge this stack entry into prev. See README for\n\t\t\t\t * discussion of this bit.\n\t\t\t\t */\n\t\t\t\tswitch (stack->state)\n\t\t\t\t{\n\t\t\t\t\tcase GUC_SAVE:\n\t\t\t\t\t\tAssert(false);\t/* can't get here */\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase GUC_SET:\n\t\t\t\t\t\t/* next level always becomes SET */\n\t\t\t\t\t\tdiscard_stack_value(gconf, &stack->prior);\n\t\t\t\t\t\tif (prev->state == GUC_SET_LOCAL)\n\t\t\t\t\t\t\tdiscard_stack_value(gconf, &prev->masked);\n\t\t\t\t\t\tprev->state = GUC_SET;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase GUC_LOCAL:\n\t\t\t\t\t\tif (prev->state == GUC_SET)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* LOCAL migrates down */\n\t\t\t\t\t\t\tprev->masked_scontext = stack->scontext;\n\t\t\t\t\t\t\tprev->masked = stack->prior;\n\t\t\t\t\t\t\tprev->state = GUC_SET_LOCAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* else just forget this stack level */\n\t\t\t\t\t\t\tdiscard_stack_value(gconf, &stack->prior);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase GUC_SET_LOCAL:\n\t\t\t\t\t\t/* prior state at this level no longer wanted */\n\t\t\t\t\t\tdiscard_stack_value(gconf, &stack->prior);\n\t\t\t\t\t\t/* copy down the masked state */\n\t\t\t\t\t\tprev->masked_scontext = stack->masked_scontext;\n\t\t\t\t\t\tif (prev->state == GUC_SET_LOCAL)\n\t\t\t\t\t\t\tdiscard_stack_value(gconf, &prev->masked);\n\t\t\t\t\t\tprev->masked = stack->masked;\n\t\t\t\t\t\tprev->state = GUC_SET_LOCAL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchanged = false;\n\n\t\t\tif (restorePrior || restoreMasked)\n\t\t\t{\n\t\t\t\t/* Perform appropriate restoration of the stacked value */\n\t\t\t\tconfig_var_value newvalue;\n\t\t\t\tGucSource\tnewsource;\n\t\t\t\tGucContext\tnewscontext;\n\n\t\t\t\tif (restoreMasked)\n\t\t\t\t{\n\t\t\t\t\tnewvalue = stack->masked;\n\t\t\t\t\tnewsource = PGC_S_SESSION;\n\t\t\t\t\tnewscontext = stack->masked_scontext;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnewvalue = stack->prior;\n\t\t\t\t\tnewsource = stack->source;\n\t\t\t\t\tnewscontext = stack->scontext;\n\t\t\t\t}\n\n\t\t\t\tswitch (gconf->vartype)\n\t\t\t\t{\n\t\t\t\t\tcase PGC_BOOL:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct config_bool *conf = (struct config_bool *) gconf;\n\t\t\t\t\t\t\tbool\t\tnewval = newvalue.val.boolval;\n\t\t\t\t\t\t\tvoid\t   *newextra = newvalue.extra;\n\n\t\t\t\t\t\t\tif (*conf->variable != newval ||\n\t\t\t\t\t\t\t\tconf->gen.extra != newextra)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase PGC_INT:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct config_int *conf = (struct config_int *) gconf;\n\t\t\t\t\t\t\tint\t\t\tnewval = newvalue.val.intval;\n\t\t\t\t\t\t\tvoid\t   *newextra = newvalue.extra;\n\n\t\t\t\t\t\t\tif (*conf->variable != newval ||\n\t\t\t\t\t\t\t\tconf->gen.extra != newextra)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase PGC_REAL:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct config_real *conf = (struct config_real *) gconf;\n\t\t\t\t\t\t\tdouble\t\tnewval = newvalue.val.realval;\n\t\t\t\t\t\t\tvoid\t   *newextra = newvalue.extra;\n\n\t\t\t\t\t\t\tif (*conf->variable != newval ||\n\t\t\t\t\t\t\t\tconf->gen.extra != newextra)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase PGC_STRING:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct config_string *conf = (struct config_string *) gconf;\n\t\t\t\t\t\t\tchar\t   *newval = newvalue.val.stringval;\n\t\t\t\t\t\t\tvoid\t   *newextra = newvalue.extra;\n\n\t\t\t\t\t\t\tif (*conf->variable != newval ||\n\t\t\t\t\t\t\t\tconf->gen.extra != newextra)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t\t\t\tset_string_field(conf, conf->variable, newval);\n\t\t\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Release stacked values if not used anymore. We\n\t\t\t\t\t\t\t * could use discard_stack_value() here, but since\n\t\t\t\t\t\t\t * we have type-specific code anyway, might as\n\t\t\t\t\t\t\t * well inline it.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tset_string_field(conf, &stack->prior.val.stringval, NULL);\n\t\t\t\t\t\t\tset_string_field(conf, &stack->masked.val.stringval, NULL);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase PGC_ENUM:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct config_enum *conf = (struct config_enum *) gconf;\n\t\t\t\t\t\t\tint\t\t\tnewval = newvalue.val.enumval;\n\t\t\t\t\t\t\tvoid\t   *newextra = newvalue.extra;\n\n\t\t\t\t\t\t\tif (*conf->variable != newval ||\n\t\t\t\t\t\t\t\tconf->gen.extra != newextra)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Release stacked extra values if not used anymore.\n\t\t\t\t */\n\t\t\t\tset_extra_field(gconf, &(stack->prior.extra), NULL);\n\t\t\t\tset_extra_field(gconf, &(stack->masked.extra), NULL);\n\n\t\t\t\t/* And restore source information */\n\t\t\t\tgconf->source = newsource;\n\t\t\t\tgconf->scontext = newscontext;\n\t\t\t}\n\n\t\t\t/* Finish popping the state stack */\n\t\t\tgconf->stack = prev;\n\t\t\tpfree(stack);\n\n\t\t\t/* Report new value if we changed it */\n\t\t\tif (changed && (gconf->flags & GUC_REPORT))\n\t\t\t\tReportGUCOption(gconf);\n\t\t}\t\t\t\t\t\t/* end of stack-popping loop */\n\n\t\tif (stack != NULL)\n\t\t\tstill_dirty = true;\n\t}\n\n\t/* If there are no remaining stack entries, we can reset guc_dirty */\n\tguc_dirty = still_dirty;\n\n\t/* Update nesting level */\n\tGUCNestLevel = nestLevel - 1;\n}",
          "includes": [
            "#include \"guc-file.c\"",
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/tzparser.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/plancache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc_tables.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_cache.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/large_object.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/standby.h\"",
            "#include \"storage/dsm_impl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"replication/walreceiver.h\"",
            "#include \"replication/syncrep.h\"",
            "#include \"replication/slot.h\"",
            "#include \"replication/logicallauncher.h\"",
            "#include \"postmaster/walwriter.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/bgwriter.h\"",
            "#include \"postmaster/bgworker_internals.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"parser/parse_expr.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/geqo.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"jit/jit.h\"",
            "#include \"funcapi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/variable.h\"",
            "#include \"commands/vacuum.h\"",
            "#include \"commands/user.h\"",
            "#include \"commands/prepare.h\"",
            "#include \"commands/async.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/twophase.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/rmgr.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/commit_ts.h\"",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define newval (newval_union.enumval)",
            "#define newval (newval_union.stringval)",
            "#define newval (newval_union.realval)",
            "#define newval (newval_union.intval)",
            "#define newval (newval_union.boolval)"
          ],
          "globals_used": [
            "static bool check_log_destination(char **newval, void **extra, GucSource source);",
            "static void assign_log_destination(const char *newval, void *extra);",
            "static bool check_wal_consistency_checking(char **newval, void **extra,\n\t\t\t\t\t\t\t   GucSource source);",
            "static void assign_wal_consistency_checking(const char *newval, void *extra);",
            "static void assign_syslog_facility(int newval, void *extra);",
            "static void assign_syslog_ident(const char *newval, void *extra);",
            "static void assign_session_replication_role(int newval, void *extra);",
            "static bool check_client_min_messages(int *newval, void **extra, GucSource source);",
            "static bool check_temp_buffers(int *newval, void **extra, GucSource source);",
            "static bool check_bonjour(bool *newval, void **extra, GucSource source);",
            "static bool check_ssl(bool *newval, void **extra, GucSource source);",
            "static bool check_stage_log_stats(bool *newval, void **extra, GucSource source);",
            "static bool check_log_stats(bool *newval, void **extra, GucSource source);",
            "static bool check_canonical_path(char **newval, void **extra, GucSource source);",
            "static bool check_timezone_abbreviations(char **newval, void **extra, GucSource source);",
            "static void assign_timezone_abbreviations(const char *newval, void *extra);",
            "static void assign_tcp_keepalives_idle(int newval, void *extra);",
            "static void assign_tcp_keepalives_interval(int newval, void *extra);",
            "static void assign_tcp_keepalives_count(int newval, void *extra);",
            "static bool check_maxconnections(int *newval, void **extra, GucSource source);",
            "static bool check_max_worker_processes(int *newval, void **extra, GucSource source);",
            "static bool check_autovacuum_max_workers(int *newval, void **extra, GucSource source);",
            "static bool check_autovacuum_work_mem(int *newval, void **extra, GucSource source);",
            "static bool check_effective_io_concurrency(int *newval, void **extra, GucSource source);",
            "static void assign_effective_io_concurrency(int newval, void *extra);",
            "static void assign_pgstat_temp_directory(const char *newval, void *extra);",
            "static bool check_application_name(char **newval, void **extra, GucSource source);",
            "static void assign_application_name(const char *newval, void *extra);",
            "static bool check_cluster_name(char **newval, void **extra, GucSource source);",
            "static struct config_generic **guc_variables;",
            "static int\tnum_guc_variables;",
            "static bool guc_dirty;",
            "static int\tGUCNestLevel = 0;",
            "static void InitializeOneGUCOption(struct config_generic *gconf);",
            "static void replace_auto_config_value(ConfigVariable **head_p, ConfigVariable **tail_p,\n\t\t\t\t\t\t  const char *name, const char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"guc-file.c\"\n#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/tzparser.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/plancache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc_tables.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_cache.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/predicate.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/large_object.h\"\n#include \"storage/fd.h\"\n#include \"storage/standby.h\"\n#include \"storage/dsm_impl.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"replication/walreceiver.h\"\n#include \"replication/syncrep.h\"\n#include \"replication/slot.h\"\n#include \"replication/logicallauncher.h\"\n#include \"postmaster/walwriter.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/bgwriter.h\"\n#include \"postmaster/bgworker_internals.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_type.h\"\n#include \"parser/parse_expr.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/geqo.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"libpq/auth.h\"\n#include \"jit/jit.h\"\n#include \"funcapi.h\"\n#include \"commands/trigger.h\"\n#include \"commands/variable.h\"\n#include \"commands/vacuum.h\"\n#include \"commands/user.h\"\n#include \"commands/prepare.h\"\n#include \"commands/async.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/xact.h\"\n#include \"access/twophase.h\"\n#include \"access/transam.h\"\n#include \"access/rmgr.h\"\n#include \"access/gin.h\"\n#include \"access/commit_ts.h\"\n#include <syslog.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define newval (newval_union.enumval)\n#define newval (newval_union.stringval)\n#define newval (newval_union.realval)\n#define newval (newval_union.intval)\n#define newval (newval_union.boolval)\n\nstatic bool check_log_destination(char **newval, void **extra, GucSource source);\nstatic void assign_log_destination(const char *newval, void *extra);\nstatic bool check_wal_consistency_checking(char **newval, void **extra,\n\t\t\t\t\t\t\t   GucSource source);\nstatic void assign_wal_consistency_checking(const char *newval, void *extra);\nstatic void assign_syslog_facility(int newval, void *extra);\nstatic void assign_syslog_ident(const char *newval, void *extra);\nstatic void assign_session_replication_role(int newval, void *extra);\nstatic bool check_client_min_messages(int *newval, void **extra, GucSource source);\nstatic bool check_temp_buffers(int *newval, void **extra, GucSource source);\nstatic bool check_bonjour(bool *newval, void **extra, GucSource source);\nstatic bool check_ssl(bool *newval, void **extra, GucSource source);\nstatic bool check_stage_log_stats(bool *newval, void **extra, GucSource source);\nstatic bool check_log_stats(bool *newval, void **extra, GucSource source);\nstatic bool check_canonical_path(char **newval, void **extra, GucSource source);\nstatic bool check_timezone_abbreviations(char **newval, void **extra, GucSource source);\nstatic void assign_timezone_abbreviations(const char *newval, void *extra);\nstatic void assign_tcp_keepalives_idle(int newval, void *extra);\nstatic void assign_tcp_keepalives_interval(int newval, void *extra);\nstatic void assign_tcp_keepalives_count(int newval, void *extra);\nstatic bool check_maxconnections(int *newval, void **extra, GucSource source);\nstatic bool check_max_worker_processes(int *newval, void **extra, GucSource source);\nstatic bool check_autovacuum_max_workers(int *newval, void **extra, GucSource source);\nstatic bool check_autovacuum_work_mem(int *newval, void **extra, GucSource source);\nstatic bool check_effective_io_concurrency(int *newval, void **extra, GucSource source);\nstatic void assign_effective_io_concurrency(int newval, void *extra);\nstatic void assign_pgstat_temp_directory(const char *newval, void *extra);\nstatic bool check_application_name(char **newval, void **extra, GucSource source);\nstatic void assign_application_name(const char *newval, void *extra);\nstatic bool check_cluster_name(char **newval, void **extra, GucSource source);\nstatic struct config_generic **guc_variables;\nstatic int\tnum_guc_variables;\nstatic bool guc_dirty;\nstatic int\tGUCNestLevel = 0;\nstatic void InitializeOneGUCOption(struct config_generic *gconf);\nstatic void replace_auto_config_value(ConfigVariable **head_p, ConfigVariable **tail_p,\n\t\t\t\t\t\t  const char *name, const char *value);\n\nvoid\nAtEOXact_GUC(bool isCommit, int nestLevel)\n{\n\tbool\t\tstill_dirty;\n\tint\t\t\ti;\n\n\t/*\n\t * Note: it's possible to get here with GUCNestLevel == nestLevel-1 during\n\t * abort, if there is a failure during transaction start before\n\t * AtStart_GUC is called.\n\t */\n\tAssert(nestLevel > 0 &&\n\t\t   (nestLevel <= GUCNestLevel ||\n\t\t\t(nestLevel == GUCNestLevel + 1 && !isCommit)));\n\n\t/* Quick exit if nothing's changed in this transaction */\n\tif (!guc_dirty)\n\t{\n\t\tGUCNestLevel = nestLevel - 1;\n\t\treturn;\n\t}\n\n\tstill_dirty = false;\n\tfor (i = 0; i < num_guc_variables; i++)\n\t{\n\t\tstruct config_generic *gconf = guc_variables[i];\n\t\tGucStack   *stack;\n\n\t\t/*\n\t\t * Process and pop each stack entry within the nest level. To simplify\n\t\t * fmgr_security_definer() and other places that use GUC_ACTION_SAVE,\n\t\t * we allow failure exit from code that uses a local nest level to be\n\t\t * recovered at the surrounding transaction or subtransaction abort;\n\t\t * so there could be more than one stack entry to pop.\n\t\t */\n\t\twhile ((stack = gconf->stack) != NULL &&\n\t\t\t   stack->nest_level >= nestLevel)\n\t\t{\n\t\t\tGucStack   *prev = stack->prev;\n\t\t\tbool\t\trestorePrior = false;\n\t\t\tbool\t\trestoreMasked = false;\n\t\t\tbool\t\tchanged;\n\n\t\t\t/*\n\t\t\t * In this next bit, if we don't set either restorePrior or\n\t\t\t * restoreMasked, we must \"discard\" any unwanted fields of the\n\t\t\t * stack entries to avoid leaking memory.  If we do set one of\n\t\t\t * those flags, unused fields will be cleaned up after restoring.\n\t\t\t */\n\t\t\tif (!isCommit)\t\t/* if abort, always restore prior value */\n\t\t\t\trestorePrior = true;\n\t\t\telse if (stack->state == GUC_SAVE)\n\t\t\t\trestorePrior = true;\n\t\t\telse if (stack->nest_level == 1)\n\t\t\t{\n\t\t\t\t/* transaction commit */\n\t\t\t\tif (stack->state == GUC_SET_LOCAL)\n\t\t\t\t\trestoreMasked = true;\n\t\t\t\telse if (stack->state == GUC_SET)\n\t\t\t\t{\n\t\t\t\t\t/* we keep the current active value */\n\t\t\t\t\tdiscard_stack_value(gconf, &stack->prior);\n\t\t\t\t}\n\t\t\t\telse\t\t\t/* must be GUC_LOCAL */\n\t\t\t\t\trestorePrior = true;\n\t\t\t}\n\t\t\telse if (prev == NULL ||\n\t\t\t\t\t prev->nest_level < stack->nest_level - 1)\n\t\t\t{\n\t\t\t\t/* decrement entry's level and do not pop it */\n\t\t\t\tstack->nest_level--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We have to merge this stack entry into prev. See README for\n\t\t\t\t * discussion of this bit.\n\t\t\t\t */\n\t\t\t\tswitch (stack->state)\n\t\t\t\t{\n\t\t\t\t\tcase GUC_SAVE:\n\t\t\t\t\t\tAssert(false);\t/* can't get here */\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase GUC_SET:\n\t\t\t\t\t\t/* next level always becomes SET */\n\t\t\t\t\t\tdiscard_stack_value(gconf, &stack->prior);\n\t\t\t\t\t\tif (prev->state == GUC_SET_LOCAL)\n\t\t\t\t\t\t\tdiscard_stack_value(gconf, &prev->masked);\n\t\t\t\t\t\tprev->state = GUC_SET;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase GUC_LOCAL:\n\t\t\t\t\t\tif (prev->state == GUC_SET)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* LOCAL migrates down */\n\t\t\t\t\t\t\tprev->masked_scontext = stack->scontext;\n\t\t\t\t\t\t\tprev->masked = stack->prior;\n\t\t\t\t\t\t\tprev->state = GUC_SET_LOCAL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* else just forget this stack level */\n\t\t\t\t\t\t\tdiscard_stack_value(gconf, &stack->prior);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase GUC_SET_LOCAL:\n\t\t\t\t\t\t/* prior state at this level no longer wanted */\n\t\t\t\t\t\tdiscard_stack_value(gconf, &stack->prior);\n\t\t\t\t\t\t/* copy down the masked state */\n\t\t\t\t\t\tprev->masked_scontext = stack->masked_scontext;\n\t\t\t\t\t\tif (prev->state == GUC_SET_LOCAL)\n\t\t\t\t\t\t\tdiscard_stack_value(gconf, &prev->masked);\n\t\t\t\t\t\tprev->masked = stack->masked;\n\t\t\t\t\t\tprev->state = GUC_SET_LOCAL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchanged = false;\n\n\t\t\tif (restorePrior || restoreMasked)\n\t\t\t{\n\t\t\t\t/* Perform appropriate restoration of the stacked value */\n\t\t\t\tconfig_var_value newvalue;\n\t\t\t\tGucSource\tnewsource;\n\t\t\t\tGucContext\tnewscontext;\n\n\t\t\t\tif (restoreMasked)\n\t\t\t\t{\n\t\t\t\t\tnewvalue = stack->masked;\n\t\t\t\t\tnewsource = PGC_S_SESSION;\n\t\t\t\t\tnewscontext = stack->masked_scontext;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnewvalue = stack->prior;\n\t\t\t\t\tnewsource = stack->source;\n\t\t\t\t\tnewscontext = stack->scontext;\n\t\t\t\t}\n\n\t\t\t\tswitch (gconf->vartype)\n\t\t\t\t{\n\t\t\t\t\tcase PGC_BOOL:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct config_bool *conf = (struct config_bool *) gconf;\n\t\t\t\t\t\t\tbool\t\tnewval = newvalue.val.boolval;\n\t\t\t\t\t\t\tvoid\t   *newextra = newvalue.extra;\n\n\t\t\t\t\t\t\tif (*conf->variable != newval ||\n\t\t\t\t\t\t\t\tconf->gen.extra != newextra)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase PGC_INT:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct config_int *conf = (struct config_int *) gconf;\n\t\t\t\t\t\t\tint\t\t\tnewval = newvalue.val.intval;\n\t\t\t\t\t\t\tvoid\t   *newextra = newvalue.extra;\n\n\t\t\t\t\t\t\tif (*conf->variable != newval ||\n\t\t\t\t\t\t\t\tconf->gen.extra != newextra)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase PGC_REAL:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct config_real *conf = (struct config_real *) gconf;\n\t\t\t\t\t\t\tdouble\t\tnewval = newvalue.val.realval;\n\t\t\t\t\t\t\tvoid\t   *newextra = newvalue.extra;\n\n\t\t\t\t\t\t\tif (*conf->variable != newval ||\n\t\t\t\t\t\t\t\tconf->gen.extra != newextra)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase PGC_STRING:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct config_string *conf = (struct config_string *) gconf;\n\t\t\t\t\t\t\tchar\t   *newval = newvalue.val.stringval;\n\t\t\t\t\t\t\tvoid\t   *newextra = newvalue.extra;\n\n\t\t\t\t\t\t\tif (*conf->variable != newval ||\n\t\t\t\t\t\t\t\tconf->gen.extra != newextra)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t\t\t\tset_string_field(conf, conf->variable, newval);\n\t\t\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * Release stacked values if not used anymore. We\n\t\t\t\t\t\t\t * could use discard_stack_value() here, but since\n\t\t\t\t\t\t\t * we have type-specific code anyway, might as\n\t\t\t\t\t\t\t * well inline it.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tset_string_field(conf, &stack->prior.val.stringval, NULL);\n\t\t\t\t\t\t\tset_string_field(conf, &stack->masked.val.stringval, NULL);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase PGC_ENUM:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstruct config_enum *conf = (struct config_enum *) gconf;\n\t\t\t\t\t\t\tint\t\t\tnewval = newvalue.val.enumval;\n\t\t\t\t\t\t\tvoid\t   *newextra = newvalue.extra;\n\n\t\t\t\t\t\t\tif (*conf->variable != newval ||\n\t\t\t\t\t\t\t\tconf->gen.extra != newextra)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (conf->assign_hook)\n\t\t\t\t\t\t\t\t\tconf->assign_hook(newval, newextra);\n\t\t\t\t\t\t\t\t*conf->variable = newval;\n\t\t\t\t\t\t\t\tset_extra_field(&conf->gen, &conf->gen.extra,\n\t\t\t\t\t\t\t\t\t\t\t\tnewextra);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Release stacked extra values if not used anymore.\n\t\t\t\t */\n\t\t\t\tset_extra_field(gconf, &(stack->prior.extra), NULL);\n\t\t\t\tset_extra_field(gconf, &(stack->masked.extra), NULL);\n\n\t\t\t\t/* And restore source information */\n\t\t\t\tgconf->source = newsource;\n\t\t\t\tgconf->scontext = newscontext;\n\t\t\t}\n\n\t\t\t/* Finish popping the state stack */\n\t\t\tgconf->stack = prev;\n\t\t\tpfree(stack);\n\n\t\t\t/* Report new value if we changed it */\n\t\t\tif (changed && (gconf->flags & GUC_REPORT))\n\t\t\t\tReportGUCOption(gconf);\n\t\t}\t\t\t\t\t\t/* end of stack-popping loop */\n\n\t\tif (stack != NULL)\n\t\t\tstill_dirty = true;\n\t}\n\n\t/* If there are no remaining stack entries, we can reset guc_dirty */\n\tguc_dirty = still_dirty;\n\n\t/* Update nesting level */\n\tGUCNestLevel = nestLevel - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_END_TRY",
          "args": [],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RE_THROW",
          "args": [],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "FHET_ABORT",
            "&fcache->flinfo",
            "&fcache->arg"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_CATCH",
          "args": [],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgstat_end_function_usage",
          "args": [
            "&fcusage",
            "(fcinfo->resultinfo == NULL ||\n\t\t\t\t\t\t\t\t   !IsA(fcinfo->resultinfo, ReturnSetInfo) ||\n\t\t\t\t\t\t\t\t   ((ReturnSetInfo *) fcinfo->resultinfo)->isDone != ExprMultipleResult)"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "fcinfo->resultinfo",
            "ReturnSetInfo"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCallInvoke",
          "args": [
            "fcinfo"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgstat_init_function_usage",
          "args": [
            "fcinfo",
            "&fcusage"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_TRY",
          "args": [],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "FHET_START",
            "&fcache->flinfo",
            "&fcache->arg"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ProcessGUCArray",
          "args": [
            "fcache->proconfig",
            "(superuser() ? PGC_SUSET : PGC_USERSET)",
            "PGC_S_SESSION",
            "GUC_ACTION_SAVE"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessGUCArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/guc.c",
          "lines": "9703-9754",
          "snippet": "void\nProcessGUCArray(ArrayType *array,\n\t\t\t\tGucContext context, GucSource source, GucAction action)\n{\n\tint\t\t\ti;\n\n\tAssert(array != NULL);\n\tAssert(ARR_ELEMTYPE(array) == TEXTOID);\n\tAssert(ARR_NDIM(array) == 1);\n\tAssert(ARR_LBOUND(array)[0] == 1);\n\n\tfor (i = 1; i <= ARR_DIMS(array)[0]; i++)\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\tchar\t   *s;\n\t\tchar\t   *name;\n\t\tchar\t   *value;\n\n\t\td = array_ref(array, 1, &i,\n\t\t\t\t\t  -1 /* varlenarray */ ,\n\t\t\t\t\t  -1 /* TEXT's typlen */ ,\n\t\t\t\t\t  false /* TEXT's typbyval */ ,\n\t\t\t\t\t  'i' /* TEXT's typalign */ ,\n\t\t\t\t\t  &isnull);\n\n\t\tif (isnull)\n\t\t\tcontinue;\n\n\t\ts = TextDatumGetCString(d);\n\n\t\tParseLongOption(s, &name, &value);\n\t\tif (!value)\n\t\t{\n\t\t\tereport(WARNING,\n\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t errmsg(\"could not parse setting for parameter \\\"%s\\\"\",\n\t\t\t\t\t\t\tname)));\n\t\t\tfree(name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t(void) set_config_option(name, value,\n\t\t\t\t\t\t\t\t context, source,\n\t\t\t\t\t\t\t\t action, true, 0, false);\n\n\t\tfree(name);\n\t\tif (value)\n\t\t\tfree(value);\n\t\tpfree(s);\n\t}\n}",
          "includes": [
            "#include \"guc-file.c\"",
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/tzparser.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/plancache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc_tables.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_cache.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/large_object.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/standby.h\"",
            "#include \"storage/dsm_impl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"replication/walreceiver.h\"",
            "#include \"replication/syncrep.h\"",
            "#include \"replication/slot.h\"",
            "#include \"replication/logicallauncher.h\"",
            "#include \"postmaster/walwriter.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/bgwriter.h\"",
            "#include \"postmaster/bgworker_internals.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"parser/parse_expr.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/geqo.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"jit/jit.h\"",
            "#include \"funcapi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/variable.h\"",
            "#include \"commands/vacuum.h\"",
            "#include \"commands/user.h\"",
            "#include \"commands/prepare.h\"",
            "#include \"commands/async.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/twophase.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/rmgr.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/commit_ts.h\"",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool check_log_destination(char **newval, void **extra, GucSource source);",
            "static bool check_wal_consistency_checking(char **newval, void **extra,\n\t\t\t\t\t\t\t   GucSource source);",
            "static bool check_client_min_messages(int *newval, void **extra, GucSource source);",
            "static bool check_temp_buffers(int *newval, void **extra, GucSource source);",
            "static bool check_bonjour(bool *newval, void **extra, GucSource source);",
            "static bool check_ssl(bool *newval, void **extra, GucSource source);",
            "static bool check_stage_log_stats(bool *newval, void **extra, GucSource source);",
            "static bool check_log_stats(bool *newval, void **extra, GucSource source);",
            "static bool check_canonical_path(char **newval, void **extra, GucSource source);",
            "static bool check_timezone_abbreviations(char **newval, void **extra, GucSource source);",
            "static bool check_maxconnections(int *newval, void **extra, GucSource source);",
            "static bool check_max_worker_processes(int *newval, void **extra, GucSource source);",
            "static bool check_autovacuum_max_workers(int *newval, void **extra, GucSource source);",
            "static bool check_autovacuum_work_mem(int *newval, void **extra, GucSource source);",
            "static bool check_effective_io_concurrency(int *newval, void **extra, GucSource source);",
            "static bool check_application_name(char **newval, void **extra, GucSource source);",
            "static bool check_cluster_name(char **newval, void **extra, GucSource source);",
            "static void push_old_value(struct config_generic *gconf, GucAction action);",
            "static void replace_auto_config_value(ConfigVariable **head_p, ConfigVariable **tail_p,\n\t\t\t\t\t\t  const char *name, const char *value);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"guc-file.c\"\n#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/tzparser.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/plancache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc_tables.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_cache.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/predicate.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/large_object.h\"\n#include \"storage/fd.h\"\n#include \"storage/standby.h\"\n#include \"storage/dsm_impl.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"replication/walreceiver.h\"\n#include \"replication/syncrep.h\"\n#include \"replication/slot.h\"\n#include \"replication/logicallauncher.h\"\n#include \"postmaster/walwriter.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/bgwriter.h\"\n#include \"postmaster/bgworker_internals.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_type.h\"\n#include \"parser/parse_expr.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/geqo.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"libpq/auth.h\"\n#include \"jit/jit.h\"\n#include \"funcapi.h\"\n#include \"commands/trigger.h\"\n#include \"commands/variable.h\"\n#include \"commands/vacuum.h\"\n#include \"commands/user.h\"\n#include \"commands/prepare.h\"\n#include \"commands/async.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/xact.h\"\n#include \"access/twophase.h\"\n#include \"access/transam.h\"\n#include \"access/rmgr.h\"\n#include \"access/gin.h\"\n#include \"access/commit_ts.h\"\n#include <syslog.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool check_log_destination(char **newval, void **extra, GucSource source);\nstatic bool check_wal_consistency_checking(char **newval, void **extra,\n\t\t\t\t\t\t\t   GucSource source);\nstatic bool check_client_min_messages(int *newval, void **extra, GucSource source);\nstatic bool check_temp_buffers(int *newval, void **extra, GucSource source);\nstatic bool check_bonjour(bool *newval, void **extra, GucSource source);\nstatic bool check_ssl(bool *newval, void **extra, GucSource source);\nstatic bool check_stage_log_stats(bool *newval, void **extra, GucSource source);\nstatic bool check_log_stats(bool *newval, void **extra, GucSource source);\nstatic bool check_canonical_path(char **newval, void **extra, GucSource source);\nstatic bool check_timezone_abbreviations(char **newval, void **extra, GucSource source);\nstatic bool check_maxconnections(int *newval, void **extra, GucSource source);\nstatic bool check_max_worker_processes(int *newval, void **extra, GucSource source);\nstatic bool check_autovacuum_max_workers(int *newval, void **extra, GucSource source);\nstatic bool check_autovacuum_work_mem(int *newval, void **extra, GucSource source);\nstatic bool check_effective_io_concurrency(int *newval, void **extra, GucSource source);\nstatic bool check_application_name(char **newval, void **extra, GucSource source);\nstatic bool check_cluster_name(char **newval, void **extra, GucSource source);\nstatic void push_old_value(struct config_generic *gconf, GucAction action);\nstatic void replace_auto_config_value(ConfigVariable **head_p, ConfigVariable **tail_p,\n\t\t\t\t\t\t  const char *name, const char *value);\n\nvoid\nProcessGUCArray(ArrayType *array,\n\t\t\t\tGucContext context, GucSource source, GucAction action)\n{\n\tint\t\t\ti;\n\n\tAssert(array != NULL);\n\tAssert(ARR_ELEMTYPE(array) == TEXTOID);\n\tAssert(ARR_NDIM(array) == 1);\n\tAssert(ARR_LBOUND(array)[0] == 1);\n\n\tfor (i = 1; i <= ARR_DIMS(array)[0]; i++)\n\t{\n\t\tDatum\t\td;\n\t\tbool\t\tisnull;\n\t\tchar\t   *s;\n\t\tchar\t   *name;\n\t\tchar\t   *value;\n\n\t\td = array_ref(array, 1, &i,\n\t\t\t\t\t  -1 /* varlenarray */ ,\n\t\t\t\t\t  -1 /* TEXT's typlen */ ,\n\t\t\t\t\t  false /* TEXT's typbyval */ ,\n\t\t\t\t\t  'i' /* TEXT's typalign */ ,\n\t\t\t\t\t  &isnull);\n\n\t\tif (isnull)\n\t\t\tcontinue;\n\n\t\ts = TextDatumGetCString(d);\n\n\t\tParseLongOption(s, &name, &value);\n\t\tif (!value)\n\t\t{\n\t\t\tereport(WARNING,\n\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t errmsg(\"could not parse setting for parameter \\\"%s\\\"\",\n\t\t\t\t\t\t\tname)));\n\t\t\tfree(name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t(void) set_config_option(name, value,\n\t\t\t\t\t\t\t\t context, source,\n\t\t\t\t\t\t\t\t action, true, 0, false);\n\n\t\tfree(name);\n\t\tif (value)\n\t\t\tfree(value);\n\t\tpfree(s);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "superuser",
          "args": [],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "superuser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/superuser.c",
          "lines": "46-50",
          "snippet": "bool\nsuperuser(void)\n{\n\treturn superuser_arg(GetUserId());\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"utils/syscache.h\"\n#include \"utils/inval.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nbool\nsuperuser(void)\n{\n\treturn superuser_arg(GetUserId());\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "fcache->userid"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NewGUCNestLevel",
          "args": [],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "NewGUCNestLevel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/guc.c",
          "lines": "5317-5321",
          "snippet": "int\nNewGUCNestLevel(void)\n{\n\treturn ++GUCNestLevel;\n}",
          "includes": [
            "#include \"guc-file.c\"",
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/tzparser.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/plancache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc_tables.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_cache.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/large_object.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/standby.h\"",
            "#include \"storage/dsm_impl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"replication/walreceiver.h\"",
            "#include \"replication/syncrep.h\"",
            "#include \"replication/slot.h\"",
            "#include \"replication/logicallauncher.h\"",
            "#include \"postmaster/walwriter.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/bgwriter.h\"",
            "#include \"postmaster/bgworker_internals.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"parser/parse_expr.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/geqo.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"jit/jit.h\"",
            "#include \"funcapi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/variable.h\"",
            "#include \"commands/vacuum.h\"",
            "#include \"commands/user.h\"",
            "#include \"commands/prepare.h\"",
            "#include \"commands/async.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/twophase.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/rmgr.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/commit_ts.h\"",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tGUCNestLevel = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"guc-file.c\"\n#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/tzparser.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/plancache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc_tables.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_cache.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/predicate.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/large_object.h\"\n#include \"storage/fd.h\"\n#include \"storage/standby.h\"\n#include \"storage/dsm_impl.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"replication/walreceiver.h\"\n#include \"replication/syncrep.h\"\n#include \"replication/slot.h\"\n#include \"replication/logicallauncher.h\"\n#include \"postmaster/walwriter.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/bgwriter.h\"\n#include \"postmaster/bgworker_internals.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_type.h\"\n#include \"parser/parse_expr.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/geqo.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"libpq/auth.h\"\n#include \"jit/jit.h\"\n#include \"funcapi.h\"\n#include \"commands/trigger.h\"\n#include \"commands/variable.h\"\n#include \"commands/vacuum.h\"\n#include \"commands/user.h\"\n#include \"commands/prepare.h\"\n#include \"commands/async.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/xact.h\"\n#include \"access/twophase.h\"\n#include \"access/transam.h\"\n#include \"access/rmgr.h\"\n#include \"access/gin.h\"\n#include \"access/commit_ts.h\"\n#include <syslog.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tGUCNestLevel = 0;\n\nint\nNewGUCNestLevel(void)\n{\n\treturn ++GUCNestLevel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetUserIdAndSecContext",
          "args": [
            "&save_userid",
            "&save_sec_context"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserIdAndSecContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "491-496",
          "snippet": "void\nGetUserIdAndSecContext(Oid *userid, int *sec_context)\n{\n\t*userid = CurrentUserId;\n\t*sec_context = SecurityRestrictionContext;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tCurrentUserId = InvalidOid;",
            "static int\tSecurityRestrictionContext = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nstatic Oid\tCurrentUserId = InvalidOid;\nstatic int\tSecurityRestrictionContext = 0;\n\nvoid\nGetUserIdAndSecContext(Oid *userid, int *sec_context)\n{\n\t*userid = CurrentUserId;\n\t*sec_context = SecurityRestrictionContext;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tuple"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypePCopy",
          "args": [
            "datum"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "fcinfo->flinfo->fn_mcxt"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SysCacheGetAttr",
          "args": [
            "PROCOID",
            "tuple",
            "Anum_pg_proc_proconfig",
            "&isnull"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "SysCacheGetAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1367-1390",
          "snippet": "Datum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nDatum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for function %u\"",
            "fcinfo->flinfo->fn_oid"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "PROCOID",
            "ObjectIdGetDatum(fcinfo->flinfo->fn_oid)"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "fcinfo->flinfo->fn_oid"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt_security",
          "args": [
            "fcinfo->flinfo->fn_oid",
            "&fcache->flinfo",
            "fcinfo->flinfo->fn_mcxt",
            "true"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt_security",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "143-263",
          "snippet": "static void\nfmgr_info_cxt_security(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,\n\t\t\t\t\t   bool ignore_security)\n{\n\tconst FmgrBuiltin *fbp;\n\tHeapTuple\tprocedureTuple;\n\tForm_pg_proc procedureStruct;\n\tDatum\t\tprosrcdatum;\n\tbool\t\tisnull;\n\tchar\t   *prosrc;\n\n\t/*\n\t * fn_oid *must* be filled in last.  Some code assumes that if fn_oid is\n\t * valid, the whole struct is valid.  Some FmgrInfo struct's do survive\n\t * elogs.\n\t */\n\tfinfo->fn_oid = InvalidOid;\n\tfinfo->fn_extra = NULL;\n\tfinfo->fn_mcxt = mcxt;\n\tfinfo->fn_expr = NULL;\t\t/* caller may set this later */\n\n\tif ((fbp = fmgr_isbuiltin(functionId)) != NULL)\n\t{\n\t\t/*\n\t\t * Fast path for builtin functions: don't bother consulting pg_proc\n\t\t */\n\t\tfinfo->fn_nargs = fbp->nargs;\n\t\tfinfo->fn_strict = fbp->strict;\n\t\tfinfo->fn_retset = fbp->retset;\n\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\tfinfo->fn_addr = fbp->func;\n\t\tfinfo->fn_oid = functionId;\n\t\treturn;\n\t}\n\n\t/* Otherwise we need the pg_proc entry */\n\tprocedureTuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(functionId));\n\tif (!HeapTupleIsValid(procedureTuple))\n\t\telog(ERROR, \"cache lookup failed for function %u\", functionId);\n\tprocedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);\n\n\tfinfo->fn_nargs = procedureStruct->pronargs;\n\tfinfo->fn_strict = procedureStruct->proisstrict;\n\tfinfo->fn_retset = procedureStruct->proretset;\n\n\t/*\n\t * If it has prosecdef set, non-null proconfig, or if a plugin wants to\n\t * hook function entry/exit, use fmgr_security_definer call handler ---\n\t * unless we are being called again by fmgr_security_definer or\n\t * fmgr_info_other_lang.\n\t *\n\t * When using fmgr_security_definer, function stats tracking is always\n\t * disabled at the outer level, and instead we set the flag properly in\n\t * fmgr_security_definer's private flinfo and implement the tracking\n\t * inside fmgr_security_definer.  This loses the ability to charge the\n\t * overhead of fmgr_security_definer to the function, but gains the\n\t * ability to set the track_functions GUC as a local GUC parameter of an\n\t * interesting function and have the right things happen.\n\t */\n\tif (!ignore_security &&\n\t\t(procedureStruct->prosecdef ||\n\t\t !heap_attisnull(procedureTuple, Anum_pg_proc_proconfig, NULL) ||\n\t\t FmgrHookIsNeeded(functionId)))\n\t{\n\t\tfinfo->fn_addr = fmgr_security_definer;\n\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\tfinfo->fn_oid = functionId;\n\t\tReleaseSysCache(procedureTuple);\n\t\treturn;\n\t}\n\n\tswitch (procedureStruct->prolang)\n\t{\n\t\tcase INTERNALlanguageId:\n\n\t\t\t/*\n\t\t\t * For an ordinary builtin function, we should never get here\n\t\t\t * because the isbuiltin() search above will have succeeded.\n\t\t\t * However, if the user has done a CREATE FUNCTION to create an\n\t\t\t * alias for a builtin function, we can end up here.  In that case\n\t\t\t * we have to look up the function by name.  The name of the\n\t\t\t * internal function is stored in prosrc (it doesn't have to be\n\t\t\t * the same as the name of the alias!)\n\t\t\t */\n\t\t\tprosrcdatum = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t\t  Anum_pg_proc_prosrc, &isnull);\n\t\t\tif (isnull)\n\t\t\t\telog(ERROR, \"null prosrc\");\n\t\t\tprosrc = TextDatumGetCString(prosrcdatum);\n\t\t\tfbp = fmgr_lookupByName(prosrc);\n\t\t\tif (fbp == NULL)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"internal function \\\"%s\\\" is not in internal lookup table\",\n\t\t\t\t\t\t\t\tprosrc)));\n\t\t\tpfree(prosrc);\n\t\t\t/* Should we check that nargs, strict, retset match the table? */\n\t\t\tfinfo->fn_addr = fbp->func;\n\t\t\t/* note this policy is also assumed in fast path above */\n\t\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\t\tbreak;\n\n\t\tcase ClanguageId:\n\t\t\tfmgr_info_C_lang(functionId, finfo, procedureTuple);\n\t\t\tfinfo->fn_stats = TRACK_FUNC_PL;\t/* ie, track if ALL */\n\t\t\tbreak;\n\n\t\tcase SQLlanguageId:\n\t\t\tfinfo->fn_addr = fmgr_sql;\n\t\t\tfinfo->fn_stats = TRACK_FUNC_PL;\t/* ie, track if ALL */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmgr_info_other_lang(functionId, finfo, procedureTuple);\n\t\t\tfinfo->fn_stats = TRACK_FUNC_OFF;\t/* ie, track if not OFF */\n\t\t\tbreak;\n\t}\n\n\tfinfo->fn_oid = functionId;\n\tReleaseSysCache(procedureTuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fmgr_info_cxt_security(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,\n\t\t\t\t\t   bool ignore_security);",
            "static void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
            "static void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
            "static CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic void fmgr_info_cxt_security(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,\n\t\t\t\t\t   bool ignore_security);\nstatic void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);\n\nstatic void\nfmgr_info_cxt_security(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,\n\t\t\t\t\t   bool ignore_security)\n{\n\tconst FmgrBuiltin *fbp;\n\tHeapTuple\tprocedureTuple;\n\tForm_pg_proc procedureStruct;\n\tDatum\t\tprosrcdatum;\n\tbool\t\tisnull;\n\tchar\t   *prosrc;\n\n\t/*\n\t * fn_oid *must* be filled in last.  Some code assumes that if fn_oid is\n\t * valid, the whole struct is valid.  Some FmgrInfo struct's do survive\n\t * elogs.\n\t */\n\tfinfo->fn_oid = InvalidOid;\n\tfinfo->fn_extra = NULL;\n\tfinfo->fn_mcxt = mcxt;\n\tfinfo->fn_expr = NULL;\t\t/* caller may set this later */\n\n\tif ((fbp = fmgr_isbuiltin(functionId)) != NULL)\n\t{\n\t\t/*\n\t\t * Fast path for builtin functions: don't bother consulting pg_proc\n\t\t */\n\t\tfinfo->fn_nargs = fbp->nargs;\n\t\tfinfo->fn_strict = fbp->strict;\n\t\tfinfo->fn_retset = fbp->retset;\n\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\tfinfo->fn_addr = fbp->func;\n\t\tfinfo->fn_oid = functionId;\n\t\treturn;\n\t}\n\n\t/* Otherwise we need the pg_proc entry */\n\tprocedureTuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(functionId));\n\tif (!HeapTupleIsValid(procedureTuple))\n\t\telog(ERROR, \"cache lookup failed for function %u\", functionId);\n\tprocedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);\n\n\tfinfo->fn_nargs = procedureStruct->pronargs;\n\tfinfo->fn_strict = procedureStruct->proisstrict;\n\tfinfo->fn_retset = procedureStruct->proretset;\n\n\t/*\n\t * If it has prosecdef set, non-null proconfig, or if a plugin wants to\n\t * hook function entry/exit, use fmgr_security_definer call handler ---\n\t * unless we are being called again by fmgr_security_definer or\n\t * fmgr_info_other_lang.\n\t *\n\t * When using fmgr_security_definer, function stats tracking is always\n\t * disabled at the outer level, and instead we set the flag properly in\n\t * fmgr_security_definer's private flinfo and implement the tracking\n\t * inside fmgr_security_definer.  This loses the ability to charge the\n\t * overhead of fmgr_security_definer to the function, but gains the\n\t * ability to set the track_functions GUC as a local GUC parameter of an\n\t * interesting function and have the right things happen.\n\t */\n\tif (!ignore_security &&\n\t\t(procedureStruct->prosecdef ||\n\t\t !heap_attisnull(procedureTuple, Anum_pg_proc_proconfig, NULL) ||\n\t\t FmgrHookIsNeeded(functionId)))\n\t{\n\t\tfinfo->fn_addr = fmgr_security_definer;\n\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\tfinfo->fn_oid = functionId;\n\t\tReleaseSysCache(procedureTuple);\n\t\treturn;\n\t}\n\n\tswitch (procedureStruct->prolang)\n\t{\n\t\tcase INTERNALlanguageId:\n\n\t\t\t/*\n\t\t\t * For an ordinary builtin function, we should never get here\n\t\t\t * because the isbuiltin() search above will have succeeded.\n\t\t\t * However, if the user has done a CREATE FUNCTION to create an\n\t\t\t * alias for a builtin function, we can end up here.  In that case\n\t\t\t * we have to look up the function by name.  The name of the\n\t\t\t * internal function is stored in prosrc (it doesn't have to be\n\t\t\t * the same as the name of the alias!)\n\t\t\t */\n\t\t\tprosrcdatum = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t\t  Anum_pg_proc_prosrc, &isnull);\n\t\t\tif (isnull)\n\t\t\t\telog(ERROR, \"null prosrc\");\n\t\t\tprosrc = TextDatumGetCString(prosrcdatum);\n\t\t\tfbp = fmgr_lookupByName(prosrc);\n\t\t\tif (fbp == NULL)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"internal function \\\"%s\\\" is not in internal lookup table\",\n\t\t\t\t\t\t\t\tprosrc)));\n\t\t\tpfree(prosrc);\n\t\t\t/* Should we check that nargs, strict, retset match the table? */\n\t\t\tfinfo->fn_addr = fbp->func;\n\t\t\t/* note this policy is also assumed in fast path above */\n\t\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\t\tbreak;\n\n\t\tcase ClanguageId:\n\t\t\tfmgr_info_C_lang(functionId, finfo, procedureTuple);\n\t\t\tfinfo->fn_stats = TRACK_FUNC_PL;\t/* ie, track if ALL */\n\t\t\tbreak;\n\n\t\tcase SQLlanguageId:\n\t\t\tfinfo->fn_addr = fmgr_sql;\n\t\t\tfinfo->fn_stats = TRACK_FUNC_PL;\t/* ie, track if ALL */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmgr_info_other_lang(functionId, finfo, procedureTuple);\n\t\t\tfinfo->fn_stats = TRACK_FUNC_OFF;\t/* ie, track if not OFF */\n\t\t\tbreak;\n\t}\n\n\tfinfo->fn_oid = functionId;\n\tReleaseSysCache(procedureTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "fcinfo->flinfo->fn_mcxt",
            "sizeof(*fcache)"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nPGDLLIMPORT fmgr_hook_type fmgr_hook = NULL;\nextern Datum fmgr_security_definer(PG_FUNCTION_ARGS);\n\nextern Datum\nfmgr_security_definer(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tresult;\n\tstruct fmgr_security_definer_cache *volatile fcache;\n\tFmgrInfo   *save_flinfo;\n\tOid\t\t\tsave_userid;\n\tint\t\t\tsave_sec_context;\n\tvolatile int save_nestlevel;\n\tPgStat_FunctionCallUsage fcusage;\n\n\tif (!fcinfo->flinfo->fn_extra)\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_proc procedureStruct;\n\t\tDatum\t\tdatum;\n\t\tbool\t\tisnull;\n\t\tMemoryContext oldcxt;\n\n\t\tfcache = MemoryContextAllocZero(fcinfo->flinfo->fn_mcxt,\n\t\t\t\t\t\t\t\t\t\tsizeof(*fcache));\n\n\t\tfmgr_info_cxt_security(fcinfo->flinfo->fn_oid, &fcache->flinfo,\n\t\t\t\t\t\t\t   fcinfo->flinfo->fn_mcxt, true);\n\t\tfcache->flinfo.fn_expr = fcinfo->flinfo->fn_expr;\n\n\t\ttuple = SearchSysCache1(PROCOID,\n\t\t\t\t\t\t\t\tObjectIdGetDatum(fcinfo->flinfo->fn_oid));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for function %u\",\n\t\t\t\t fcinfo->flinfo->fn_oid);\n\t\tprocedureStruct = (Form_pg_proc) GETSTRUCT(tuple);\n\n\t\tif (procedureStruct->prosecdef)\n\t\t\tfcache->userid = procedureStruct->proowner;\n\n\t\tdatum = SysCacheGetAttr(PROCOID, tuple, Anum_pg_proc_proconfig,\n\t\t\t\t\t\t\t\t&isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\toldcxt = MemoryContextSwitchTo(fcinfo->flinfo->fn_mcxt);\n\t\t\tfcache->proconfig = DatumGetArrayTypePCopy(datum);\n\t\t\tMemoryContextSwitchTo(oldcxt);\n\t\t}\n\n\t\tReleaseSysCache(tuple);\n\n\t\tfcinfo->flinfo->fn_extra = fcache;\n\t}\n\telse\n\t\tfcache = fcinfo->flinfo->fn_extra;\n\n\t/* GetUserIdAndSecContext is cheap enough that no harm in a wasted call */\n\tGetUserIdAndSecContext(&save_userid, &save_sec_context);\n\tif (fcache->proconfig)\t\t/* Need a new GUC nesting level */\n\t\tsave_nestlevel = NewGUCNestLevel();\n\telse\n\t\tsave_nestlevel = 0;\t\t/* keep compiler quiet */\n\n\tif (OidIsValid(fcache->userid))\n\t\tSetUserIdAndSecContext(fcache->userid,\n\t\t\t\t\t\t\t   save_sec_context | SECURITY_LOCAL_USERID_CHANGE);\n\n\tif (fcache->proconfig)\n\t{\n\t\tProcessGUCArray(fcache->proconfig,\n\t\t\t\t\t\t(superuser() ? PGC_SUSET : PGC_USERSET),\n\t\t\t\t\t\tPGC_S_SESSION,\n\t\t\t\t\t\tGUC_ACTION_SAVE);\n\t}\n\n\t/* function manager hook */\n\tif (fmgr_hook)\n\t\t(*fmgr_hook) (FHET_START, &fcache->flinfo, &fcache->arg);\n\n\t/*\n\t * We don't need to restore GUC or userid settings on error, because the\n\t * ensuing xact or subxact abort will do that.  The PG_TRY block is only\n\t * needed to clean up the flinfo link.\n\t */\n\tsave_flinfo = fcinfo->flinfo;\n\n\tPG_TRY();\n\t{\n\t\tfcinfo->flinfo = &fcache->flinfo;\n\n\t\t/* See notes in fmgr_info_cxt_security */\n\t\tpgstat_init_function_usage(fcinfo, &fcusage);\n\n\t\tresult = FunctionCallInvoke(fcinfo);\n\n\t\t/*\n\t\t * We could be calling either a regular or a set-returning function,\n\t\t * so we have to test to see what finalize flag to use.\n\t\t */\n\t\tpgstat_end_function_usage(&fcusage,\n\t\t\t\t\t\t\t\t  (fcinfo->resultinfo == NULL ||\n\t\t\t\t\t\t\t\t   !IsA(fcinfo->resultinfo, ReturnSetInfo) ||\n\t\t\t\t\t\t\t\t   ((ReturnSetInfo *) fcinfo->resultinfo)->isDone != ExprMultipleResult));\n\t}\n\tPG_CATCH();\n\t{\n\t\tfcinfo->flinfo = save_flinfo;\n\t\tif (fmgr_hook)\n\t\t\t(*fmgr_hook) (FHET_ABORT, &fcache->flinfo, &fcache->arg);\n\t\tPG_RE_THROW();\n\t}\n\tPG_END_TRY();\n\n\tfcinfo->flinfo = save_flinfo;\n\n\tif (fcache->proconfig)\n\t\tAtEOXact_GUC(true, save_nestlevel);\n\tif (OidIsValid(fcache->userid))\n\t\tSetUserIdAndSecContext(save_userid, save_sec_context);\n\tif (fmgr_hook)\n\t\t(*fmgr_hook) (FHET_END, &fcache->flinfo, &fcache->arg);\n\n\treturn result;\n}"
  },
  {
    "function_name": "fmgr_internal_function",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "624-632",
    "snippet": "Oid\nfmgr_internal_function(const char *proname)\n{\n\tconst FmgrBuiltin *fbp = fmgr_lookupByName(proname);\n\n\tif (fbp == NULL)\n\t\treturn InvalidOid;\n\treturn fbp->foid;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fmgr_lookupByName",
          "args": [
            "proname"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_lookupByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "97-108",
          "snippet": "static const FmgrBuiltin *\nfmgr_lookupByName(const char *name)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < fmgr_nbuiltins; i++)\n\t{\n\t\tif (strcmp(name, fmgr_builtins[i].funcName) == 0)\n\t\t\treturn fmgr_builtins + i;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic const FmgrBuiltin *\nfmgr_lookupByName(const char *name)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < fmgr_nbuiltins; i++)\n\t{\n\t\tif (strcmp(name, fmgr_builtins[i].funcName) == 0)\n\t\t\treturn fmgr_builtins + i;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nOid\nfmgr_internal_function(const char *proname)\n{\n\tconst FmgrBuiltin *fbp = fmgr_lookupByName(proname);\n\n\tif (fbp == NULL)\n\t\treturn InvalidOid;\n\treturn fbp->foid;\n}"
  },
  {
    "function_name": "fmgr_info_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "609-616",
    "snippet": "void\nfmgr_info_copy(FmgrInfo *dstinfo, FmgrInfo *srcinfo,\n\t\t\t   MemoryContext destcxt)\n{\n\tmemcpy(dstinfo, srcinfo, sizeof(FmgrInfo));\n\tdstinfo->fn_mcxt = destcxt;\n\tdstinfo->fn_extra = NULL;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dstinfo",
            "srcinfo",
            "sizeof(FmgrInfo)"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_copy(FmgrInfo *dstinfo, FmgrInfo *srcinfo,\n\t\t\t   MemoryContext destcxt)\n{\n\tmemcpy(dstinfo, srcinfo, sizeof(FmgrInfo));\n\tdstinfo->fn_mcxt = destcxt;\n\tdstinfo->fn_extra = NULL;\n}"
  },
  {
    "function_name": "clear_external_function_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "593-599",
    "snippet": "void\nclear_external_function_hash(void *filehandle)\n{\n\tif (CFuncHash)\n\t\thash_destroy(CFuncHash);\n\tCFuncHash = NULL;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *CFuncHash = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_destroy",
          "args": [
            "CFuncHash"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "hash_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "813-830",
          "snippet": "void\nhash_destroy(HTAB *hashp)\n{\n\tif (hashp != NULL)\n\t{\n\t\t/* allocation method must be one we know how to free, too */\n\t\tAssert(hashp->alloc == DynaHashAlloc);\n\t\t/* so this hashtable must have it's own context */\n\t\tAssert(hashp->hcxt != NULL);\n\n\t\thash_stats(\"destroy\", hashp);\n\n\t\t/*\n\t\t * Free everything by destroying the hash table's memory context.\n\t\t */\n\t\tMemoryContextDelete(hashp->hcxt);\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_destroy(HTAB *hashp)\n{\n\tif (hashp != NULL)\n\t{\n\t\t/* allocation method must be one we know how to free, too */\n\t\tAssert(hashp->alloc == DynaHashAlloc);\n\t\t/* so this hashtable must have it's own context */\n\t\tAssert(hashp->hcxt != NULL);\n\n\t\thash_stats(\"destroy\", hashp);\n\n\t\t/*\n\t\t * Free everything by destroying the hash table's memory context.\n\t\t */\n\t\tMemoryContextDelete(hashp->hcxt);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic HTAB *CFuncHash = NULL;\n\nvoid\nclear_external_function_hash(void *filehandle)\n{\n\tif (CFuncHash)\n\t\thash_destroy(CFuncHash);\n\tCFuncHash = NULL;\n}"
  },
  {
    "function_name": "record_C_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "553-585",
    "snippet": "static void\nrecord_C_func(HeapTuple procedureTuple,\n\t\t\t  PGFunction user_fn, const Pg_finfo_record *inforec)\n{\n\tOid\t\t\tfn_oid = HeapTupleGetOid(procedureTuple);\n\tCFuncHashTabEntry *entry;\n\tbool\t\tfound;\n\n\t/* Create the hash table if it doesn't exist yet */\n\tif (CFuncHash == NULL)\n\t{\n\t\tHASHCTL\t\thash_ctl;\n\n\t\tMemSet(&hash_ctl, 0, sizeof(hash_ctl));\n\t\thash_ctl.keysize = sizeof(Oid);\n\t\thash_ctl.entrysize = sizeof(CFuncHashTabEntry);\n\t\tCFuncHash = hash_create(\"CFuncHash\",\n\t\t\t\t\t\t\t\t100,\n\t\t\t\t\t\t\t\t&hash_ctl,\n\t\t\t\t\t\t\t\tHASH_ELEM | HASH_BLOBS);\n\t}\n\n\tentry = (CFuncHashTabEntry *)\n\t\thash_search(CFuncHash,\n\t\t\t\t\t&fn_oid,\n\t\t\t\t\tHASH_ENTER,\n\t\t\t\t\t&found);\n\t/* OID is already filled in */\n\tentry->fn_xmin = HeapTupleHeaderGetRawXmin(procedureTuple->t_data);\n\tentry->fn_tid = procedureTuple->t_self;\n\tentry->user_fn = user_fn;\n\tentry->inforec = inforec;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *CFuncHash = NULL;",
      "static void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
      "static void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
      "static CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);",
      "static void record_C_func(HeapTuple procedureTuple,\n\t\t\t  PGFunction user_fn, const Pg_finfo_record *inforec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "procedureTuple->t_data"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "CFuncHash",
            "&fn_oid",
            "HASH_ENTER",
            "&found"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_create",
          "args": [
            "\"CFuncHash\"",
            "100",
            "&hash_ctl",
            "HASH_ELEM | HASH_BLOBS"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "hash_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "315-564",
          "snippet": "HTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_FREELISTS\t\t\t32"
          ],
          "globals_used": [
            "static void *DynaHashAlloc(Size size);",
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static int\tchoose_nelem_alloc(Size entrysize);",
            "static bool init_htab(HTAB *hashp, long nelem);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);",
            "static MemoryContext CurrentDynaHashCxt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define NUM_FREELISTS\t\t\t32\n\nstatic void *DynaHashAlloc(Size size);\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic int\tchoose_nelem_alloc(Size entrysize);\nstatic bool init_htab(HTAB *hashp, long nelem);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\nstatic MemoryContext CurrentDynaHashCxt = NULL;\n\nHTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&hash_ctl",
            "0",
            "sizeof(hash_ctl)"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "procedureTuple"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic HTAB *CFuncHash = NULL;\nstatic void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);\nstatic void record_C_func(HeapTuple procedureTuple,\n\t\t\t  PGFunction user_fn, const Pg_finfo_record *inforec);\n\nstatic void\nrecord_C_func(HeapTuple procedureTuple,\n\t\t\t  PGFunction user_fn, const Pg_finfo_record *inforec)\n{\n\tOid\t\t\tfn_oid = HeapTupleGetOid(procedureTuple);\n\tCFuncHashTabEntry *entry;\n\tbool\t\tfound;\n\n\t/* Create the hash table if it doesn't exist yet */\n\tif (CFuncHash == NULL)\n\t{\n\t\tHASHCTL\t\thash_ctl;\n\n\t\tMemSet(&hash_ctl, 0, sizeof(hash_ctl));\n\t\thash_ctl.keysize = sizeof(Oid);\n\t\thash_ctl.entrysize = sizeof(CFuncHashTabEntry);\n\t\tCFuncHash = hash_create(\"CFuncHash\",\n\t\t\t\t\t\t\t\t100,\n\t\t\t\t\t\t\t\t&hash_ctl,\n\t\t\t\t\t\t\t\tHASH_ELEM | HASH_BLOBS);\n\t}\n\n\tentry = (CFuncHashTabEntry *)\n\t\thash_search(CFuncHash,\n\t\t\t\t\t&fn_oid,\n\t\t\t\t\tHASH_ENTER,\n\t\t\t\t\t&found);\n\t/* OID is already filled in */\n\tentry->fn_xmin = HeapTupleHeaderGetRawXmin(procedureTuple->t_data);\n\tentry->fn_tid = procedureTuple->t_self;\n\tentry->user_fn = user_fn;\n\tentry->inforec = inforec;\n}"
  },
  {
    "function_name": "lookup_C_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "529-548",
    "snippet": "static CFuncHashTabEntry *\nlookup_C_func(HeapTuple procedureTuple)\n{\n\tOid\t\t\tfn_oid = HeapTupleGetOid(procedureTuple);\n\tCFuncHashTabEntry *entry;\n\n\tif (CFuncHash == NULL)\n\t\treturn NULL;\t\t\t/* no table yet */\n\tentry = (CFuncHashTabEntry *)\n\t\thash_search(CFuncHash,\n\t\t\t\t\t&fn_oid,\n\t\t\t\t\tHASH_FIND,\n\t\t\t\t\tNULL);\n\tif (entry == NULL)\n\t\treturn NULL;\t\t\t/* no such entry */\n\tif (entry->fn_xmin == HeapTupleHeaderGetRawXmin(procedureTuple->t_data) &&\n\t\tItemPointerEquals(&entry->fn_tid, &procedureTuple->t_self))\n\t\treturn entry;\t\t\t/* OK */\n\treturn NULL;\t\t\t\t/* entry is out of date */\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *CFuncHash = NULL;",
      "static void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
      "static void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
      "static CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ItemPointerEquals",
          "args": [
            "&entry->fn_tid",
            "&procedureTuple->t_self"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetRawXmin",
          "args": [
            "procedureTuple->t_data"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "CFuncHash",
            "&fn_oid",
            "HASH_FIND",
            "NULL"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "procedureTuple"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic HTAB *CFuncHash = NULL;\nstatic void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);\n\nstatic CFuncHashTabEntry *\nlookup_C_func(HeapTuple procedureTuple)\n{\n\tOid\t\t\tfn_oid = HeapTupleGetOid(procedureTuple);\n\tCFuncHashTabEntry *entry;\n\n\tif (CFuncHash == NULL)\n\t\treturn NULL;\t\t\t/* no table yet */\n\tentry = (CFuncHashTabEntry *)\n\t\thash_search(CFuncHash,\n\t\t\t\t\t&fn_oid,\n\t\t\t\t\tHASH_FIND,\n\t\t\t\t\tNULL);\n\tif (entry == NULL)\n\t\treturn NULL;\t\t\t/* no such entry */\n\tif (entry->fn_xmin == HeapTupleHeaderGetRawXmin(procedureTuple->t_data) &&\n\t\tItemPointerEquals(&entry->fn_tid, &procedureTuple->t_self))\n\t\treturn entry;\t\t\t/* OK */\n\treturn NULL;\t\t\t\t/* entry is out of date */\n}"
  },
  {
    "function_name": "fetch_finfo_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "469-512",
    "snippet": "const Pg_finfo_record *\nfetch_finfo_record(void *filehandle, const char *funcname)\n{\n\tchar\t   *infofuncname;\n\tPGFInfoFunction infofunc;\n\tconst Pg_finfo_record *inforec;\n\n\tinfofuncname = psprintf(\"pg_finfo_%s\", funcname);\n\n\t/* Try to look up the info function */\n\tinfofunc = (PGFInfoFunction) lookup_external_function(filehandle,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  infofuncname);\n\tif (infofunc == NULL)\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"could not find function information for function \\\"%s\\\"\",\n\t\t\t\t\t\tfuncname),\n\t\t\t\t errhint(\"SQL-callable functions need an accompanying PG_FUNCTION_INFO_V1(funcname).\")));\n\t\treturn NULL;\t\t\t/* silence compiler */\n\t}\n\n\t/* Found, so call it */\n\tinforec = (*infofunc) ();\n\n\t/* Validate result as best we can */\n\tif (inforec == NULL)\n\t\telog(ERROR, \"null result from info function \\\"%s\\\"\", infofuncname);\n\tswitch (inforec->api_version)\n\t{\n\t\tcase 1:\n\t\t\t/* OK, no additional fields to validate */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"unrecognized API version %d reported by info function \\\"%s\\\"\",\n\t\t\t\t\t\t\tinforec->api_version, infofuncname)));\n\t\t\tbreak;\n\t}\n\n\tpfree(infofuncname);\n\treturn inforec;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void record_C_func(HeapTuple procedureTuple,\n\t\t\t  PGFunction user_fn, const Pg_finfo_record *inforec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "infofuncname"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"unrecognized API version %d reported by info function \\\"%s\\\"\",\n\t\t\t\t\t\t\tinforec->api_version, infofuncname))"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"unrecognized API version %d reported by info function \\\"%s\\\"\"",
            "inforec->api_version",
            "infofuncname"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"null result from info function \\\"%s\\\"\"",
            "infofuncname"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"could not find function information for function \\\"%s\\\"\",\n\t\t\t\t\t\tfuncname),\n\t\t\t\t errhint(\"SQL-callable functions need an accompanying PG_FUNCTION_INFO_V1(funcname).\"))"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"SQL-callable functions need an accompanying PG_FUNCTION_INFO_V1(funcname).\""
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_external_function",
          "args": [
            "filehandle",
            "infofuncname"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_external_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/dfmgr.c",
          "lines": "161-166",
          "snippet": "PGFunction\nlookup_external_function(void *filehandle, const char *funcname)\n{\n\t/* as above, cast away const for the time being */\n\treturn (PGFunction) pg_dlsym(filehandle, (char *) funcname);\n}",
          "includes": [
            "#include \"utils/hsearch.h\"",
            "#include \"utils/dynamic_loader.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"dynloader.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/hsearch.h\"\n#include \"utils/dynamic_loader.h\"\n#include \"storage/shmem.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"dynloader.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nPGFunction\nlookup_external_function(void *filehandle, const char *funcname)\n{\n\t/* as above, cast away const for the time being */\n\treturn (PGFunction) pg_dlsym(filehandle, (char *) funcname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"pg_finfo_%s\"",
            "funcname"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic void record_C_func(HeapTuple procedureTuple,\n\t\t\t  PGFunction user_fn, const Pg_finfo_record *inforec);\n\nconst Pg_finfo_record *\nfetch_finfo_record(void *filehandle, const char *funcname)\n{\n\tchar\t   *infofuncname;\n\tPGFInfoFunction infofunc;\n\tconst Pg_finfo_record *inforec;\n\n\tinfofuncname = psprintf(\"pg_finfo_%s\", funcname);\n\n\t/* Try to look up the info function */\n\tinfofunc = (PGFInfoFunction) lookup_external_function(filehandle,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  infofuncname);\n\tif (infofunc == NULL)\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"could not find function information for function \\\"%s\\\"\",\n\t\t\t\t\t\tfuncname),\n\t\t\t\t errhint(\"SQL-callable functions need an accompanying PG_FUNCTION_INFO_V1(funcname).\")));\n\t\treturn NULL;\t\t\t/* silence compiler */\n\t}\n\n\t/* Found, so call it */\n\tinforec = (*infofunc) ();\n\n\t/* Validate result as best we can */\n\tif (inforec == NULL)\n\t\telog(ERROR, \"null result from info function \\\"%s\\\"\", infofuncname);\n\tswitch (inforec->api_version)\n\t{\n\t\tcase 1:\n\t\t\t/* OK, no additional fields to validate */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"unrecognized API version %d reported by info function \\\"%s\\\"\",\n\t\t\t\t\t\t\tinforec->api_version, infofuncname)));\n\t\t\tbreak;\n\t}\n\n\tpfree(infofuncname);\n\treturn inforec;\n}"
  },
  {
    "function_name": "fmgr_info_other_lang",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "432-456",
    "snippet": "static void\nfmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple)\n{\n\tForm_pg_proc procedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);\n\tOid\t\t\tlanguage = procedureStruct->prolang;\n\tHeapTuple\tlanguageTuple;\n\tForm_pg_language languageStruct;\n\tFmgrInfo\tplfinfo;\n\n\tlanguageTuple = SearchSysCache1(LANGOID, ObjectIdGetDatum(language));\n\tif (!HeapTupleIsValid(languageTuple))\n\t\telog(ERROR, \"cache lookup failed for language %u\", language);\n\tlanguageStruct = (Form_pg_language) GETSTRUCT(languageTuple);\n\n\t/*\n\t * Look up the language's call handler function, ignoring any attributes\n\t * that would normally cause insertion of fmgr_security_definer.  We need\n\t * to get back a bare pointer to the actual C-language function.\n\t */\n\tfmgr_info_cxt_security(languageStruct->lanplcallfoid, &plfinfo,\n\t\t\t\t\t\t   CurrentMemoryContext, true);\n\tfinfo->fn_addr = plfinfo.fn_addr;\n\n\tReleaseSysCache(languageTuple);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
      "static void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
      "static CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "languageTuple"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt_security",
          "args": [
            "languageStruct->lanplcallfoid",
            "&plfinfo",
            "CurrentMemoryContext",
            "true"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt_security",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "143-263",
          "snippet": "static void\nfmgr_info_cxt_security(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,\n\t\t\t\t\t   bool ignore_security)\n{\n\tconst FmgrBuiltin *fbp;\n\tHeapTuple\tprocedureTuple;\n\tForm_pg_proc procedureStruct;\n\tDatum\t\tprosrcdatum;\n\tbool\t\tisnull;\n\tchar\t   *prosrc;\n\n\t/*\n\t * fn_oid *must* be filled in last.  Some code assumes that if fn_oid is\n\t * valid, the whole struct is valid.  Some FmgrInfo struct's do survive\n\t * elogs.\n\t */\n\tfinfo->fn_oid = InvalidOid;\n\tfinfo->fn_extra = NULL;\n\tfinfo->fn_mcxt = mcxt;\n\tfinfo->fn_expr = NULL;\t\t/* caller may set this later */\n\n\tif ((fbp = fmgr_isbuiltin(functionId)) != NULL)\n\t{\n\t\t/*\n\t\t * Fast path for builtin functions: don't bother consulting pg_proc\n\t\t */\n\t\tfinfo->fn_nargs = fbp->nargs;\n\t\tfinfo->fn_strict = fbp->strict;\n\t\tfinfo->fn_retset = fbp->retset;\n\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\tfinfo->fn_addr = fbp->func;\n\t\tfinfo->fn_oid = functionId;\n\t\treturn;\n\t}\n\n\t/* Otherwise we need the pg_proc entry */\n\tprocedureTuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(functionId));\n\tif (!HeapTupleIsValid(procedureTuple))\n\t\telog(ERROR, \"cache lookup failed for function %u\", functionId);\n\tprocedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);\n\n\tfinfo->fn_nargs = procedureStruct->pronargs;\n\tfinfo->fn_strict = procedureStruct->proisstrict;\n\tfinfo->fn_retset = procedureStruct->proretset;\n\n\t/*\n\t * If it has prosecdef set, non-null proconfig, or if a plugin wants to\n\t * hook function entry/exit, use fmgr_security_definer call handler ---\n\t * unless we are being called again by fmgr_security_definer or\n\t * fmgr_info_other_lang.\n\t *\n\t * When using fmgr_security_definer, function stats tracking is always\n\t * disabled at the outer level, and instead we set the flag properly in\n\t * fmgr_security_definer's private flinfo and implement the tracking\n\t * inside fmgr_security_definer.  This loses the ability to charge the\n\t * overhead of fmgr_security_definer to the function, but gains the\n\t * ability to set the track_functions GUC as a local GUC parameter of an\n\t * interesting function and have the right things happen.\n\t */\n\tif (!ignore_security &&\n\t\t(procedureStruct->prosecdef ||\n\t\t !heap_attisnull(procedureTuple, Anum_pg_proc_proconfig, NULL) ||\n\t\t FmgrHookIsNeeded(functionId)))\n\t{\n\t\tfinfo->fn_addr = fmgr_security_definer;\n\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\tfinfo->fn_oid = functionId;\n\t\tReleaseSysCache(procedureTuple);\n\t\treturn;\n\t}\n\n\tswitch (procedureStruct->prolang)\n\t{\n\t\tcase INTERNALlanguageId:\n\n\t\t\t/*\n\t\t\t * For an ordinary builtin function, we should never get here\n\t\t\t * because the isbuiltin() search above will have succeeded.\n\t\t\t * However, if the user has done a CREATE FUNCTION to create an\n\t\t\t * alias for a builtin function, we can end up here.  In that case\n\t\t\t * we have to look up the function by name.  The name of the\n\t\t\t * internal function is stored in prosrc (it doesn't have to be\n\t\t\t * the same as the name of the alias!)\n\t\t\t */\n\t\t\tprosrcdatum = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t\t  Anum_pg_proc_prosrc, &isnull);\n\t\t\tif (isnull)\n\t\t\t\telog(ERROR, \"null prosrc\");\n\t\t\tprosrc = TextDatumGetCString(prosrcdatum);\n\t\t\tfbp = fmgr_lookupByName(prosrc);\n\t\t\tif (fbp == NULL)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"internal function \\\"%s\\\" is not in internal lookup table\",\n\t\t\t\t\t\t\t\tprosrc)));\n\t\t\tpfree(prosrc);\n\t\t\t/* Should we check that nargs, strict, retset match the table? */\n\t\t\tfinfo->fn_addr = fbp->func;\n\t\t\t/* note this policy is also assumed in fast path above */\n\t\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\t\tbreak;\n\n\t\tcase ClanguageId:\n\t\t\tfmgr_info_C_lang(functionId, finfo, procedureTuple);\n\t\t\tfinfo->fn_stats = TRACK_FUNC_PL;\t/* ie, track if ALL */\n\t\t\tbreak;\n\n\t\tcase SQLlanguageId:\n\t\t\tfinfo->fn_addr = fmgr_sql;\n\t\t\tfinfo->fn_stats = TRACK_FUNC_PL;\t/* ie, track if ALL */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmgr_info_other_lang(functionId, finfo, procedureTuple);\n\t\t\tfinfo->fn_stats = TRACK_FUNC_OFF;\t/* ie, track if not OFF */\n\t\t\tbreak;\n\t}\n\n\tfinfo->fn_oid = functionId;\n\tReleaseSysCache(procedureTuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fmgr_info_cxt_security(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,\n\t\t\t\t\t   bool ignore_security);",
            "static void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
            "static void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
            "static CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic void fmgr_info_cxt_security(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,\n\t\t\t\t\t   bool ignore_security);\nstatic void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);\n\nstatic void\nfmgr_info_cxt_security(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,\n\t\t\t\t\t   bool ignore_security)\n{\n\tconst FmgrBuiltin *fbp;\n\tHeapTuple\tprocedureTuple;\n\tForm_pg_proc procedureStruct;\n\tDatum\t\tprosrcdatum;\n\tbool\t\tisnull;\n\tchar\t   *prosrc;\n\n\t/*\n\t * fn_oid *must* be filled in last.  Some code assumes that if fn_oid is\n\t * valid, the whole struct is valid.  Some FmgrInfo struct's do survive\n\t * elogs.\n\t */\n\tfinfo->fn_oid = InvalidOid;\n\tfinfo->fn_extra = NULL;\n\tfinfo->fn_mcxt = mcxt;\n\tfinfo->fn_expr = NULL;\t\t/* caller may set this later */\n\n\tif ((fbp = fmgr_isbuiltin(functionId)) != NULL)\n\t{\n\t\t/*\n\t\t * Fast path for builtin functions: don't bother consulting pg_proc\n\t\t */\n\t\tfinfo->fn_nargs = fbp->nargs;\n\t\tfinfo->fn_strict = fbp->strict;\n\t\tfinfo->fn_retset = fbp->retset;\n\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\tfinfo->fn_addr = fbp->func;\n\t\tfinfo->fn_oid = functionId;\n\t\treturn;\n\t}\n\n\t/* Otherwise we need the pg_proc entry */\n\tprocedureTuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(functionId));\n\tif (!HeapTupleIsValid(procedureTuple))\n\t\telog(ERROR, \"cache lookup failed for function %u\", functionId);\n\tprocedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);\n\n\tfinfo->fn_nargs = procedureStruct->pronargs;\n\tfinfo->fn_strict = procedureStruct->proisstrict;\n\tfinfo->fn_retset = procedureStruct->proretset;\n\n\t/*\n\t * If it has prosecdef set, non-null proconfig, or if a plugin wants to\n\t * hook function entry/exit, use fmgr_security_definer call handler ---\n\t * unless we are being called again by fmgr_security_definer or\n\t * fmgr_info_other_lang.\n\t *\n\t * When using fmgr_security_definer, function stats tracking is always\n\t * disabled at the outer level, and instead we set the flag properly in\n\t * fmgr_security_definer's private flinfo and implement the tracking\n\t * inside fmgr_security_definer.  This loses the ability to charge the\n\t * overhead of fmgr_security_definer to the function, but gains the\n\t * ability to set the track_functions GUC as a local GUC parameter of an\n\t * interesting function and have the right things happen.\n\t */\n\tif (!ignore_security &&\n\t\t(procedureStruct->prosecdef ||\n\t\t !heap_attisnull(procedureTuple, Anum_pg_proc_proconfig, NULL) ||\n\t\t FmgrHookIsNeeded(functionId)))\n\t{\n\t\tfinfo->fn_addr = fmgr_security_definer;\n\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\tfinfo->fn_oid = functionId;\n\t\tReleaseSysCache(procedureTuple);\n\t\treturn;\n\t}\n\n\tswitch (procedureStruct->prolang)\n\t{\n\t\tcase INTERNALlanguageId:\n\n\t\t\t/*\n\t\t\t * For an ordinary builtin function, we should never get here\n\t\t\t * because the isbuiltin() search above will have succeeded.\n\t\t\t * However, if the user has done a CREATE FUNCTION to create an\n\t\t\t * alias for a builtin function, we can end up here.  In that case\n\t\t\t * we have to look up the function by name.  The name of the\n\t\t\t * internal function is stored in prosrc (it doesn't have to be\n\t\t\t * the same as the name of the alias!)\n\t\t\t */\n\t\t\tprosrcdatum = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t\t  Anum_pg_proc_prosrc, &isnull);\n\t\t\tif (isnull)\n\t\t\t\telog(ERROR, \"null prosrc\");\n\t\t\tprosrc = TextDatumGetCString(prosrcdatum);\n\t\t\tfbp = fmgr_lookupByName(prosrc);\n\t\t\tif (fbp == NULL)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"internal function \\\"%s\\\" is not in internal lookup table\",\n\t\t\t\t\t\t\t\tprosrc)));\n\t\t\tpfree(prosrc);\n\t\t\t/* Should we check that nargs, strict, retset match the table? */\n\t\t\tfinfo->fn_addr = fbp->func;\n\t\t\t/* note this policy is also assumed in fast path above */\n\t\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\t\tbreak;\n\n\t\tcase ClanguageId:\n\t\t\tfmgr_info_C_lang(functionId, finfo, procedureTuple);\n\t\t\tfinfo->fn_stats = TRACK_FUNC_PL;\t/* ie, track if ALL */\n\t\t\tbreak;\n\n\t\tcase SQLlanguageId:\n\t\t\tfinfo->fn_addr = fmgr_sql;\n\t\t\tfinfo->fn_stats = TRACK_FUNC_PL;\t/* ie, track if ALL */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmgr_info_other_lang(functionId, finfo, procedureTuple);\n\t\t\tfinfo->fn_stats = TRACK_FUNC_OFF;\t/* ie, track if not OFF */\n\t\t\tbreak;\n\t}\n\n\tfinfo->fn_oid = functionId;\n\tReleaseSysCache(procedureTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "languageTuple"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for language %u\"",
            "language"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "languageTuple"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "LANGOID",
            "ObjectIdGetDatum(language)"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "language"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "procedureTuple"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);\n\nstatic void\nfmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple)\n{\n\tForm_pg_proc procedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);\n\tOid\t\t\tlanguage = procedureStruct->prolang;\n\tHeapTuple\tlanguageTuple;\n\tForm_pg_language languageStruct;\n\tFmgrInfo\tplfinfo;\n\n\tlanguageTuple = SearchSysCache1(LANGOID, ObjectIdGetDatum(language));\n\tif (!HeapTupleIsValid(languageTuple))\n\t\telog(ERROR, \"cache lookup failed for language %u\", language);\n\tlanguageStruct = (Form_pg_language) GETSTRUCT(languageTuple);\n\n\t/*\n\t * Look up the language's call handler function, ignoring any attributes\n\t * that would normally cause insertion of fmgr_security_definer.  We need\n\t * to get back a bare pointer to the actual C-language function.\n\t */\n\tfmgr_info_cxt_security(languageStruct->lanplcallfoid, &plfinfo,\n\t\t\t\t\t\t   CurrentMemoryContext, true);\n\tfinfo->fn_addr = plfinfo.fn_addr;\n\n\tReleaseSysCache(languageTuple);\n}"
  },
  {
    "function_name": "fmgr_info_C_lang",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "358-426",
    "snippet": "static void\nfmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple)\n{\n\tCFuncHashTabEntry *hashentry;\n\tPGFunction\tuser_fn;\n\tconst Pg_finfo_record *inforec;\n\tbool\t\tisnull;\n\n\t/*\n\t * See if we have the function address cached already\n\t */\n\thashentry = lookup_C_func(procedureTuple);\n\tif (hashentry)\n\t{\n\t\tuser_fn = hashentry->user_fn;\n\t\tinforec = hashentry->inforec;\n\t}\n\telse\n\t{\n\t\tDatum\t\tprosrcattr,\n\t\t\t\t\tprobinattr;\n\t\tchar\t   *prosrcstring,\n\t\t\t\t   *probinstring;\n\t\tvoid\t   *libraryhandle;\n\n\t\t/*\n\t\t * Get prosrc and probin strings (link symbol and library filename).\n\t\t * While in general these columns might be null, that's not allowed\n\t\t * for C-language functions.\n\t\t */\n\t\tprosrcattr = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t Anum_pg_proc_prosrc, &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null prosrc for C function %u\", functionId);\n\t\tprosrcstring = TextDatumGetCString(prosrcattr);\n\n\t\tprobinattr = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t Anum_pg_proc_probin, &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null probin for C function %u\", functionId);\n\t\tprobinstring = TextDatumGetCString(probinattr);\n\n\t\t/* Look up the function itself */\n\t\tuser_fn = load_external_function(probinstring, prosrcstring, true,\n\t\t\t\t\t\t\t\t\t\t &libraryhandle);\n\n\t\t/* Get the function information record (real or default) */\n\t\tinforec = fetch_finfo_record(libraryhandle, prosrcstring);\n\n\t\t/* Cache the addresses for later calls */\n\t\trecord_C_func(procedureTuple, user_fn, inforec);\n\n\t\tpfree(prosrcstring);\n\t\tpfree(probinstring);\n\t}\n\n\tswitch (inforec->api_version)\n\t{\n\t\tcase 1:\n\t\t\t/* New style: call directly */\n\t\t\tfinfo->fn_addr = user_fn;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Shouldn't get here if fetch_finfo_record did its job */\n\t\t\telog(ERROR, \"unrecognized function API version: %d\",\n\t\t\t\t inforec->api_version);\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
      "static void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
      "static CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);",
      "static void record_C_func(HeapTuple procedureTuple,\n\t\t\t  PGFunction user_fn, const Pg_finfo_record *inforec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized function API version: %d\"",
            "inforec->api_version"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "probinstring"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "record_C_func",
          "args": [
            "procedureTuple",
            "user_fn",
            "inforec"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "record_C_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "553-585",
          "snippet": "static void\nrecord_C_func(HeapTuple procedureTuple,\n\t\t\t  PGFunction user_fn, const Pg_finfo_record *inforec)\n{\n\tOid\t\t\tfn_oid = HeapTupleGetOid(procedureTuple);\n\tCFuncHashTabEntry *entry;\n\tbool\t\tfound;\n\n\t/* Create the hash table if it doesn't exist yet */\n\tif (CFuncHash == NULL)\n\t{\n\t\tHASHCTL\t\thash_ctl;\n\n\t\tMemSet(&hash_ctl, 0, sizeof(hash_ctl));\n\t\thash_ctl.keysize = sizeof(Oid);\n\t\thash_ctl.entrysize = sizeof(CFuncHashTabEntry);\n\t\tCFuncHash = hash_create(\"CFuncHash\",\n\t\t\t\t\t\t\t\t100,\n\t\t\t\t\t\t\t\t&hash_ctl,\n\t\t\t\t\t\t\t\tHASH_ELEM | HASH_BLOBS);\n\t}\n\n\tentry = (CFuncHashTabEntry *)\n\t\thash_search(CFuncHash,\n\t\t\t\t\t&fn_oid,\n\t\t\t\t\tHASH_ENTER,\n\t\t\t\t\t&found);\n\t/* OID is already filled in */\n\tentry->fn_xmin = HeapTupleHeaderGetRawXmin(procedureTuple->t_data);\n\tentry->fn_tid = procedureTuple->t_self;\n\tentry->user_fn = user_fn;\n\tentry->inforec = inforec;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *CFuncHash = NULL;",
            "static void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
            "static void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
            "static CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);",
            "static void record_C_func(HeapTuple procedureTuple,\n\t\t\t  PGFunction user_fn, const Pg_finfo_record *inforec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic HTAB *CFuncHash = NULL;\nstatic void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);\nstatic void record_C_func(HeapTuple procedureTuple,\n\t\t\t  PGFunction user_fn, const Pg_finfo_record *inforec);\n\nstatic void\nrecord_C_func(HeapTuple procedureTuple,\n\t\t\t  PGFunction user_fn, const Pg_finfo_record *inforec)\n{\n\tOid\t\t\tfn_oid = HeapTupleGetOid(procedureTuple);\n\tCFuncHashTabEntry *entry;\n\tbool\t\tfound;\n\n\t/* Create the hash table if it doesn't exist yet */\n\tif (CFuncHash == NULL)\n\t{\n\t\tHASHCTL\t\thash_ctl;\n\n\t\tMemSet(&hash_ctl, 0, sizeof(hash_ctl));\n\t\thash_ctl.keysize = sizeof(Oid);\n\t\thash_ctl.entrysize = sizeof(CFuncHashTabEntry);\n\t\tCFuncHash = hash_create(\"CFuncHash\",\n\t\t\t\t\t\t\t\t100,\n\t\t\t\t\t\t\t\t&hash_ctl,\n\t\t\t\t\t\t\t\tHASH_ELEM | HASH_BLOBS);\n\t}\n\n\tentry = (CFuncHashTabEntry *)\n\t\thash_search(CFuncHash,\n\t\t\t\t\t&fn_oid,\n\t\t\t\t\tHASH_ENTER,\n\t\t\t\t\t&found);\n\t/* OID is already filled in */\n\tentry->fn_xmin = HeapTupleHeaderGetRawXmin(procedureTuple->t_data);\n\tentry->fn_tid = procedureTuple->t_self;\n\tentry->user_fn = user_fn;\n\tentry->inforec = inforec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetch_finfo_record",
          "args": [
            "libraryhandle",
            "prosrcstring"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_finfo_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "469-512",
          "snippet": "const Pg_finfo_record *\nfetch_finfo_record(void *filehandle, const char *funcname)\n{\n\tchar\t   *infofuncname;\n\tPGFInfoFunction infofunc;\n\tconst Pg_finfo_record *inforec;\n\n\tinfofuncname = psprintf(\"pg_finfo_%s\", funcname);\n\n\t/* Try to look up the info function */\n\tinfofunc = (PGFInfoFunction) lookup_external_function(filehandle,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  infofuncname);\n\tif (infofunc == NULL)\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"could not find function information for function \\\"%s\\\"\",\n\t\t\t\t\t\tfuncname),\n\t\t\t\t errhint(\"SQL-callable functions need an accompanying PG_FUNCTION_INFO_V1(funcname).\")));\n\t\treturn NULL;\t\t\t/* silence compiler */\n\t}\n\n\t/* Found, so call it */\n\tinforec = (*infofunc) ();\n\n\t/* Validate result as best we can */\n\tif (inforec == NULL)\n\t\telog(ERROR, \"null result from info function \\\"%s\\\"\", infofuncname);\n\tswitch (inforec->api_version)\n\t{\n\t\tcase 1:\n\t\t\t/* OK, no additional fields to validate */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"unrecognized API version %d reported by info function \\\"%s\\\"\",\n\t\t\t\t\t\t\tinforec->api_version, infofuncname)));\n\t\t\tbreak;\n\t}\n\n\tpfree(infofuncname);\n\treturn inforec;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void record_C_func(HeapTuple procedureTuple,\n\t\t\t  PGFunction user_fn, const Pg_finfo_record *inforec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic void record_C_func(HeapTuple procedureTuple,\n\t\t\t  PGFunction user_fn, const Pg_finfo_record *inforec);\n\nconst Pg_finfo_record *\nfetch_finfo_record(void *filehandle, const char *funcname)\n{\n\tchar\t   *infofuncname;\n\tPGFInfoFunction infofunc;\n\tconst Pg_finfo_record *inforec;\n\n\tinfofuncname = psprintf(\"pg_finfo_%s\", funcname);\n\n\t/* Try to look up the info function */\n\tinfofunc = (PGFInfoFunction) lookup_external_function(filehandle,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  infofuncname);\n\tif (infofunc == NULL)\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"could not find function information for function \\\"%s\\\"\",\n\t\t\t\t\t\tfuncname),\n\t\t\t\t errhint(\"SQL-callable functions need an accompanying PG_FUNCTION_INFO_V1(funcname).\")));\n\t\treturn NULL;\t\t\t/* silence compiler */\n\t}\n\n\t/* Found, so call it */\n\tinforec = (*infofunc) ();\n\n\t/* Validate result as best we can */\n\tif (inforec == NULL)\n\t\telog(ERROR, \"null result from info function \\\"%s\\\"\", infofuncname);\n\tswitch (inforec->api_version)\n\t{\n\t\tcase 1:\n\t\t\t/* OK, no additional fields to validate */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"unrecognized API version %d reported by info function \\\"%s\\\"\",\n\t\t\t\t\t\t\tinforec->api_version, infofuncname)));\n\t\t\tbreak;\n\t}\n\n\tpfree(infofuncname);\n\treturn inforec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_external_function",
          "args": [
            "probinstring",
            "prosrcstring",
            "true",
            "&libraryhandle"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "load_external_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/dfmgr.c",
          "lines": "93-126",
          "snippet": "PGFunction\nload_external_function(const char *filename, const char *funcname,\n\t\t\t\t\t   bool signalNotFound, void **filehandle)\n{\n\tchar\t   *fullname;\n\tvoid\t   *lib_handle;\n\tPGFunction\tretval;\n\n\t/* Expand the possibly-abbreviated filename to an exact path name */\n\tfullname = expand_dynamic_library_name(filename);\n\n\t/* Load the shared library, unless we already did */\n\tlib_handle = internal_load_library(fullname);\n\n\t/* Return handle if caller wants it */\n\tif (filehandle)\n\t\t*filehandle = lib_handle;\n\n\t/*\n\t * Look up the function within the library.  According to POSIX dlsym()\n\t * should declare its second argument as \"const char *\", but older\n\t * platforms might not, so for the time being we just cast away const.\n\t */\n\tretval = (PGFunction) pg_dlsym(lib_handle, (char *) funcname);\n\n\tif (retval == NULL && signalNotFound)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"could not find function \\\"%s\\\" in file \\\"%s\\\"\",\n\t\t\t\t\t\tfuncname, fullname)));\n\n\tpfree(fullname);\n\treturn retval;\n}",
          "includes": [
            "#include \"utils/hsearch.h\"",
            "#include \"utils/dynamic_loader.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"dynloader.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool file_exists(const char *name);",
            "static char *expand_dynamic_library_name(const char *name);",
            "static void check_restricted_library_name(const char *name);",
            "static char *substitute_libpath_macro(const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/hsearch.h\"\n#include \"utils/dynamic_loader.h\"\n#include \"storage/shmem.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"dynloader.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic bool file_exists(const char *name);\nstatic char *expand_dynamic_library_name(const char *name);\nstatic void check_restricted_library_name(const char *name);\nstatic char *substitute_libpath_macro(const char *name);\n\nPGFunction\nload_external_function(const char *filename, const char *funcname,\n\t\t\t\t\t   bool signalNotFound, void **filehandle)\n{\n\tchar\t   *fullname;\n\tvoid\t   *lib_handle;\n\tPGFunction\tretval;\n\n\t/* Expand the possibly-abbreviated filename to an exact path name */\n\tfullname = expand_dynamic_library_name(filename);\n\n\t/* Load the shared library, unless we already did */\n\tlib_handle = internal_load_library(fullname);\n\n\t/* Return handle if caller wants it */\n\tif (filehandle)\n\t\t*filehandle = lib_handle;\n\n\t/*\n\t * Look up the function within the library.  According to POSIX dlsym()\n\t * should declare its second argument as \"const char *\", but older\n\t * platforms might not, so for the time being we just cast away const.\n\t */\n\tretval = (PGFunction) pg_dlsym(lib_handle, (char *) funcname);\n\n\tif (retval == NULL && signalNotFound)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"could not find function \\\"%s\\\" in file \\\"%s\\\"\",\n\t\t\t\t\t\tfuncname, fullname)));\n\n\tpfree(fullname);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "probinattr"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SysCacheGetAttr",
          "args": [
            "PROCOID",
            "procedureTuple",
            "Anum_pg_proc_probin",
            "&isnull"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "SysCacheGetAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1367-1390",
          "snippet": "Datum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nDatum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "prosrcattr"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_C_func",
          "args": [
            "procedureTuple"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_C_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "529-548",
          "snippet": "static CFuncHashTabEntry *\nlookup_C_func(HeapTuple procedureTuple)\n{\n\tOid\t\t\tfn_oid = HeapTupleGetOid(procedureTuple);\n\tCFuncHashTabEntry *entry;\n\n\tif (CFuncHash == NULL)\n\t\treturn NULL;\t\t\t/* no table yet */\n\tentry = (CFuncHashTabEntry *)\n\t\thash_search(CFuncHash,\n\t\t\t\t\t&fn_oid,\n\t\t\t\t\tHASH_FIND,\n\t\t\t\t\tNULL);\n\tif (entry == NULL)\n\t\treturn NULL;\t\t\t/* no such entry */\n\tif (entry->fn_xmin == HeapTupleHeaderGetRawXmin(procedureTuple->t_data) &&\n\t\tItemPointerEquals(&entry->fn_tid, &procedureTuple->t_self))\n\t\treturn entry;\t\t\t/* OK */\n\treturn NULL;\t\t\t\t/* entry is out of date */\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *CFuncHash = NULL;",
            "static void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
            "static void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
            "static CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic HTAB *CFuncHash = NULL;\nstatic void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);\n\nstatic CFuncHashTabEntry *\nlookup_C_func(HeapTuple procedureTuple)\n{\n\tOid\t\t\tfn_oid = HeapTupleGetOid(procedureTuple);\n\tCFuncHashTabEntry *entry;\n\n\tif (CFuncHash == NULL)\n\t\treturn NULL;\t\t\t/* no table yet */\n\tentry = (CFuncHashTabEntry *)\n\t\thash_search(CFuncHash,\n\t\t\t\t\t&fn_oid,\n\t\t\t\t\tHASH_FIND,\n\t\t\t\t\tNULL);\n\tif (entry == NULL)\n\t\treturn NULL;\t\t\t/* no such entry */\n\tif (entry->fn_xmin == HeapTupleHeaderGetRawXmin(procedureTuple->t_data) &&\n\t\tItemPointerEquals(&entry->fn_tid, &procedureTuple->t_self))\n\t\treturn entry;\t\t\t/* OK */\n\treturn NULL;\t\t\t\t/* entry is out of date */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);\nstatic void record_C_func(HeapTuple procedureTuple,\n\t\t\t  PGFunction user_fn, const Pg_finfo_record *inforec);\n\nstatic void\nfmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple)\n{\n\tCFuncHashTabEntry *hashentry;\n\tPGFunction\tuser_fn;\n\tconst Pg_finfo_record *inforec;\n\tbool\t\tisnull;\n\n\t/*\n\t * See if we have the function address cached already\n\t */\n\thashentry = lookup_C_func(procedureTuple);\n\tif (hashentry)\n\t{\n\t\tuser_fn = hashentry->user_fn;\n\t\tinforec = hashentry->inforec;\n\t}\n\telse\n\t{\n\t\tDatum\t\tprosrcattr,\n\t\t\t\t\tprobinattr;\n\t\tchar\t   *prosrcstring,\n\t\t\t\t   *probinstring;\n\t\tvoid\t   *libraryhandle;\n\n\t\t/*\n\t\t * Get prosrc and probin strings (link symbol and library filename).\n\t\t * While in general these columns might be null, that's not allowed\n\t\t * for C-language functions.\n\t\t */\n\t\tprosrcattr = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t Anum_pg_proc_prosrc, &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null prosrc for C function %u\", functionId);\n\t\tprosrcstring = TextDatumGetCString(prosrcattr);\n\n\t\tprobinattr = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t Anum_pg_proc_probin, &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null probin for C function %u\", functionId);\n\t\tprobinstring = TextDatumGetCString(probinattr);\n\n\t\t/* Look up the function itself */\n\t\tuser_fn = load_external_function(probinstring, prosrcstring, true,\n\t\t\t\t\t\t\t\t\t\t &libraryhandle);\n\n\t\t/* Get the function information record (real or default) */\n\t\tinforec = fetch_finfo_record(libraryhandle, prosrcstring);\n\n\t\t/* Cache the addresses for later calls */\n\t\trecord_C_func(procedureTuple, user_fn, inforec);\n\n\t\tpfree(prosrcstring);\n\t\tpfree(probinstring);\n\t}\n\n\tswitch (inforec->api_version)\n\t{\n\t\tcase 1:\n\t\t\t/* New style: call directly */\n\t\t\tfinfo->fn_addr = user_fn;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Shouldn't get here if fetch_finfo_record did its job */\n\t\t\telog(ERROR, \"unrecognized function API version: %d\",\n\t\t\t\t inforec->api_version);\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "fmgr_symbol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "280-351",
    "snippet": "void\nfmgr_symbol(Oid functionId, char **mod, char **fn)\n{\n\tHeapTuple\tprocedureTuple;\n\tForm_pg_proc procedureStruct;\n\tbool\t\tisnull;\n\tDatum\t\tprosrcattr;\n\tDatum\t\tprobinattr;\n\n\t/* Otherwise we need the pg_proc entry */\n\tprocedureTuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(functionId));\n\tif (!HeapTupleIsValid(procedureTuple))\n\t\telog(ERROR, \"cache lookup failed for function %u\", functionId);\n\tprocedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);\n\n\t/*\n\t */\n\tif (procedureStruct->prosecdef ||\n\t\t!heap_attisnull(procedureTuple, Anum_pg_proc_proconfig, NULL) ||\n\t\tFmgrHookIsNeeded(functionId))\n\t{\n\t\t*mod = NULL;\t\t\t/* core binary */\n\t\t*fn = pstrdup(\"fmgr_security_definer\");\n\t\tReleaseSysCache(procedureTuple);\n\t\treturn;\n\t}\n\n\t/* see fmgr_info_cxt_security for the individual cases */\n\tswitch (procedureStruct->prolang)\n\t{\n\t\tcase INTERNALlanguageId:\n\t\t\tprosrcattr = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t\t Anum_pg_proc_prosrc, &isnull);\n\t\t\tif (isnull)\n\t\t\t\telog(ERROR, \"null prosrc\");\n\n\t\t\t*mod = NULL;\t\t/* core binary */\n\t\t\t*fn = TextDatumGetCString(prosrcattr);\n\t\t\tbreak;\n\n\t\tcase ClanguageId:\n\t\t\tprosrcattr = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t\t Anum_pg_proc_prosrc, &isnull);\n\t\t\tif (isnull)\n\t\t\t\telog(ERROR, \"null prosrc for C function %u\", functionId);\n\n\t\t\tprobinattr = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t\t Anum_pg_proc_probin, &isnull);\n\t\t\tif (isnull)\n\t\t\t\telog(ERROR, \"null probin for C function %u\", functionId);\n\n\t\t\t/*\n\t\t\t * No need to check symbol presence / API version here, already\n\t\t\t * checked in fmgr_info_cxt_security.\n\t\t\t */\n\t\t\t*mod = TextDatumGetCString(probinattr);\n\t\t\t*fn = TextDatumGetCString(prosrcattr);\n\t\t\tbreak;\n\n\t\tcase SQLlanguageId:\n\t\t\t*mod = NULL;\t\t/* core binary */\n\t\t\t*fn = pstrdup(\"fmgr_sql\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t*mod = NULL;\n\t\t\t*fn = NULL;\t\t\t/* unknown, pass pointer */\n\t\t\tbreak;\n\t}\n\n\tReleaseSysCache(procedureTuple);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
      "static void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
      "static CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "procedureTuple"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "\"fmgr_sql\""
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1160-1164",
          "snippet": "char *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\n\nchar *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "prosrcattr"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "probinattr"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"null probin for C function %u\"",
            "functionId"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SysCacheGetAttr",
          "args": [
            "PROCOID",
            "procedureTuple",
            "Anum_pg_proc_probin",
            "&isnull"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "SysCacheGetAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1367-1390",
          "snippet": "Datum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nDatum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "prosrcattr"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FmgrHookIsNeeded",
          "args": [
            "functionId"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_attisnull",
          "args": [
            "procedureTuple",
            "Anum_pg_proc_proconfig",
            "NULL"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "procedureTuple"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "procedureTuple"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "PROCOID",
            "ObjectIdGetDatum(functionId)"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "functionId"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);\n\nvoid\nfmgr_symbol(Oid functionId, char **mod, char **fn)\n{\n\tHeapTuple\tprocedureTuple;\n\tForm_pg_proc procedureStruct;\n\tbool\t\tisnull;\n\tDatum\t\tprosrcattr;\n\tDatum\t\tprobinattr;\n\n\t/* Otherwise we need the pg_proc entry */\n\tprocedureTuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(functionId));\n\tif (!HeapTupleIsValid(procedureTuple))\n\t\telog(ERROR, \"cache lookup failed for function %u\", functionId);\n\tprocedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);\n\n\t/*\n\t */\n\tif (procedureStruct->prosecdef ||\n\t\t!heap_attisnull(procedureTuple, Anum_pg_proc_proconfig, NULL) ||\n\t\tFmgrHookIsNeeded(functionId))\n\t{\n\t\t*mod = NULL;\t\t\t/* core binary */\n\t\t*fn = pstrdup(\"fmgr_security_definer\");\n\t\tReleaseSysCache(procedureTuple);\n\t\treturn;\n\t}\n\n\t/* see fmgr_info_cxt_security for the individual cases */\n\tswitch (procedureStruct->prolang)\n\t{\n\t\tcase INTERNALlanguageId:\n\t\t\tprosrcattr = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t\t Anum_pg_proc_prosrc, &isnull);\n\t\t\tif (isnull)\n\t\t\t\telog(ERROR, \"null prosrc\");\n\n\t\t\t*mod = NULL;\t\t/* core binary */\n\t\t\t*fn = TextDatumGetCString(prosrcattr);\n\t\t\tbreak;\n\n\t\tcase ClanguageId:\n\t\t\tprosrcattr = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t\t Anum_pg_proc_prosrc, &isnull);\n\t\t\tif (isnull)\n\t\t\t\telog(ERROR, \"null prosrc for C function %u\", functionId);\n\n\t\t\tprobinattr = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t\t Anum_pg_proc_probin, &isnull);\n\t\t\tif (isnull)\n\t\t\t\telog(ERROR, \"null probin for C function %u\", functionId);\n\n\t\t\t/*\n\t\t\t * No need to check symbol presence / API version here, already\n\t\t\t * checked in fmgr_info_cxt_security.\n\t\t\t */\n\t\t\t*mod = TextDatumGetCString(probinattr);\n\t\t\t*fn = TextDatumGetCString(prosrcattr);\n\t\t\tbreak;\n\n\t\tcase SQLlanguageId:\n\t\t\t*mod = NULL;\t\t/* core binary */\n\t\t\t*fn = pstrdup(\"fmgr_sql\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t*mod = NULL;\n\t\t\t*fn = NULL;\t\t\t/* unknown, pass pointer */\n\t\t\tbreak;\n\t}\n\n\tReleaseSysCache(procedureTuple);\n}"
  },
  {
    "function_name": "fmgr_info_cxt_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "143-263",
    "snippet": "static void\nfmgr_info_cxt_security(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,\n\t\t\t\t\t   bool ignore_security)\n{\n\tconst FmgrBuiltin *fbp;\n\tHeapTuple\tprocedureTuple;\n\tForm_pg_proc procedureStruct;\n\tDatum\t\tprosrcdatum;\n\tbool\t\tisnull;\n\tchar\t   *prosrc;\n\n\t/*\n\t * fn_oid *must* be filled in last.  Some code assumes that if fn_oid is\n\t * valid, the whole struct is valid.  Some FmgrInfo struct's do survive\n\t * elogs.\n\t */\n\tfinfo->fn_oid = InvalidOid;\n\tfinfo->fn_extra = NULL;\n\tfinfo->fn_mcxt = mcxt;\n\tfinfo->fn_expr = NULL;\t\t/* caller may set this later */\n\n\tif ((fbp = fmgr_isbuiltin(functionId)) != NULL)\n\t{\n\t\t/*\n\t\t * Fast path for builtin functions: don't bother consulting pg_proc\n\t\t */\n\t\tfinfo->fn_nargs = fbp->nargs;\n\t\tfinfo->fn_strict = fbp->strict;\n\t\tfinfo->fn_retset = fbp->retset;\n\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\tfinfo->fn_addr = fbp->func;\n\t\tfinfo->fn_oid = functionId;\n\t\treturn;\n\t}\n\n\t/* Otherwise we need the pg_proc entry */\n\tprocedureTuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(functionId));\n\tif (!HeapTupleIsValid(procedureTuple))\n\t\telog(ERROR, \"cache lookup failed for function %u\", functionId);\n\tprocedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);\n\n\tfinfo->fn_nargs = procedureStruct->pronargs;\n\tfinfo->fn_strict = procedureStruct->proisstrict;\n\tfinfo->fn_retset = procedureStruct->proretset;\n\n\t/*\n\t * If it has prosecdef set, non-null proconfig, or if a plugin wants to\n\t * hook function entry/exit, use fmgr_security_definer call handler ---\n\t * unless we are being called again by fmgr_security_definer or\n\t * fmgr_info_other_lang.\n\t *\n\t * When using fmgr_security_definer, function stats tracking is always\n\t * disabled at the outer level, and instead we set the flag properly in\n\t * fmgr_security_definer's private flinfo and implement the tracking\n\t * inside fmgr_security_definer.  This loses the ability to charge the\n\t * overhead of fmgr_security_definer to the function, but gains the\n\t * ability to set the track_functions GUC as a local GUC parameter of an\n\t * interesting function and have the right things happen.\n\t */\n\tif (!ignore_security &&\n\t\t(procedureStruct->prosecdef ||\n\t\t !heap_attisnull(procedureTuple, Anum_pg_proc_proconfig, NULL) ||\n\t\t FmgrHookIsNeeded(functionId)))\n\t{\n\t\tfinfo->fn_addr = fmgr_security_definer;\n\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\tfinfo->fn_oid = functionId;\n\t\tReleaseSysCache(procedureTuple);\n\t\treturn;\n\t}\n\n\tswitch (procedureStruct->prolang)\n\t{\n\t\tcase INTERNALlanguageId:\n\n\t\t\t/*\n\t\t\t * For an ordinary builtin function, we should never get here\n\t\t\t * because the isbuiltin() search above will have succeeded.\n\t\t\t * However, if the user has done a CREATE FUNCTION to create an\n\t\t\t * alias for a builtin function, we can end up here.  In that case\n\t\t\t * we have to look up the function by name.  The name of the\n\t\t\t * internal function is stored in prosrc (it doesn't have to be\n\t\t\t * the same as the name of the alias!)\n\t\t\t */\n\t\t\tprosrcdatum = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t\t  Anum_pg_proc_prosrc, &isnull);\n\t\t\tif (isnull)\n\t\t\t\telog(ERROR, \"null prosrc\");\n\t\t\tprosrc = TextDatumGetCString(prosrcdatum);\n\t\t\tfbp = fmgr_lookupByName(prosrc);\n\t\t\tif (fbp == NULL)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"internal function \\\"%s\\\" is not in internal lookup table\",\n\t\t\t\t\t\t\t\tprosrc)));\n\t\t\tpfree(prosrc);\n\t\t\t/* Should we check that nargs, strict, retset match the table? */\n\t\t\tfinfo->fn_addr = fbp->func;\n\t\t\t/* note this policy is also assumed in fast path above */\n\t\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\t\tbreak;\n\n\t\tcase ClanguageId:\n\t\t\tfmgr_info_C_lang(functionId, finfo, procedureTuple);\n\t\t\tfinfo->fn_stats = TRACK_FUNC_PL;\t/* ie, track if ALL */\n\t\t\tbreak;\n\n\t\tcase SQLlanguageId:\n\t\t\tfinfo->fn_addr = fmgr_sql;\n\t\t\tfinfo->fn_stats = TRACK_FUNC_PL;\t/* ie, track if ALL */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmgr_info_other_lang(functionId, finfo, procedureTuple);\n\t\t\tfinfo->fn_stats = TRACK_FUNC_OFF;\t/* ie, track if not OFF */\n\t\t\tbreak;\n\t}\n\n\tfinfo->fn_oid = functionId;\n\tReleaseSysCache(procedureTuple);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void fmgr_info_cxt_security(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,\n\t\t\t\t\t   bool ignore_security);",
      "static void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
      "static void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
      "static CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "procedureTuple"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info_other_lang",
          "args": [
            "functionId",
            "finfo",
            "procedureTuple"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_other_lang",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "432-456",
          "snippet": "static void\nfmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple)\n{\n\tForm_pg_proc procedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);\n\tOid\t\t\tlanguage = procedureStruct->prolang;\n\tHeapTuple\tlanguageTuple;\n\tForm_pg_language languageStruct;\n\tFmgrInfo\tplfinfo;\n\n\tlanguageTuple = SearchSysCache1(LANGOID, ObjectIdGetDatum(language));\n\tif (!HeapTupleIsValid(languageTuple))\n\t\telog(ERROR, \"cache lookup failed for language %u\", language);\n\tlanguageStruct = (Form_pg_language) GETSTRUCT(languageTuple);\n\n\t/*\n\t * Look up the language's call handler function, ignoring any attributes\n\t * that would normally cause insertion of fmgr_security_definer.  We need\n\t * to get back a bare pointer to the actual C-language function.\n\t */\n\tfmgr_info_cxt_security(languageStruct->lanplcallfoid, &plfinfo,\n\t\t\t\t\t\t   CurrentMemoryContext, true);\n\tfinfo->fn_addr = plfinfo.fn_addr;\n\n\tReleaseSysCache(languageTuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
            "static void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
            "static CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);\n\nstatic void\nfmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple)\n{\n\tForm_pg_proc procedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);\n\tOid\t\t\tlanguage = procedureStruct->prolang;\n\tHeapTuple\tlanguageTuple;\n\tForm_pg_language languageStruct;\n\tFmgrInfo\tplfinfo;\n\n\tlanguageTuple = SearchSysCache1(LANGOID, ObjectIdGetDatum(language));\n\tif (!HeapTupleIsValid(languageTuple))\n\t\telog(ERROR, \"cache lookup failed for language %u\", language);\n\tlanguageStruct = (Form_pg_language) GETSTRUCT(languageTuple);\n\n\t/*\n\t * Look up the language's call handler function, ignoring any attributes\n\t * that would normally cause insertion of fmgr_security_definer.  We need\n\t * to get back a bare pointer to the actual C-language function.\n\t */\n\tfmgr_info_cxt_security(languageStruct->lanplcallfoid, &plfinfo,\n\t\t\t\t\t\t   CurrentMemoryContext, true);\n\tfinfo->fn_addr = plfinfo.fn_addr;\n\n\tReleaseSysCache(languageTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info_C_lang",
          "args": [
            "functionId",
            "finfo",
            "procedureTuple"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_C_lang",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "358-426",
          "snippet": "static void\nfmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple)\n{\n\tCFuncHashTabEntry *hashentry;\n\tPGFunction\tuser_fn;\n\tconst Pg_finfo_record *inforec;\n\tbool\t\tisnull;\n\n\t/*\n\t * See if we have the function address cached already\n\t */\n\thashentry = lookup_C_func(procedureTuple);\n\tif (hashentry)\n\t{\n\t\tuser_fn = hashentry->user_fn;\n\t\tinforec = hashentry->inforec;\n\t}\n\telse\n\t{\n\t\tDatum\t\tprosrcattr,\n\t\t\t\t\tprobinattr;\n\t\tchar\t   *prosrcstring,\n\t\t\t\t   *probinstring;\n\t\tvoid\t   *libraryhandle;\n\n\t\t/*\n\t\t * Get prosrc and probin strings (link symbol and library filename).\n\t\t * While in general these columns might be null, that's not allowed\n\t\t * for C-language functions.\n\t\t */\n\t\tprosrcattr = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t Anum_pg_proc_prosrc, &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null prosrc for C function %u\", functionId);\n\t\tprosrcstring = TextDatumGetCString(prosrcattr);\n\n\t\tprobinattr = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t Anum_pg_proc_probin, &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null probin for C function %u\", functionId);\n\t\tprobinstring = TextDatumGetCString(probinattr);\n\n\t\t/* Look up the function itself */\n\t\tuser_fn = load_external_function(probinstring, prosrcstring, true,\n\t\t\t\t\t\t\t\t\t\t &libraryhandle);\n\n\t\t/* Get the function information record (real or default) */\n\t\tinforec = fetch_finfo_record(libraryhandle, prosrcstring);\n\n\t\t/* Cache the addresses for later calls */\n\t\trecord_C_func(procedureTuple, user_fn, inforec);\n\n\t\tpfree(prosrcstring);\n\t\tpfree(probinstring);\n\t}\n\n\tswitch (inforec->api_version)\n\t{\n\t\tcase 1:\n\t\t\t/* New style: call directly */\n\t\t\tfinfo->fn_addr = user_fn;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Shouldn't get here if fetch_finfo_record did its job */\n\t\t\telog(ERROR, \"unrecognized function API version: %d\",\n\t\t\t\t inforec->api_version);\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
            "static void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
            "static CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);",
            "static void record_C_func(HeapTuple procedureTuple,\n\t\t\t  PGFunction user_fn, const Pg_finfo_record *inforec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);\nstatic void record_C_func(HeapTuple procedureTuple,\n\t\t\t  PGFunction user_fn, const Pg_finfo_record *inforec);\n\nstatic void\nfmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple)\n{\n\tCFuncHashTabEntry *hashentry;\n\tPGFunction\tuser_fn;\n\tconst Pg_finfo_record *inforec;\n\tbool\t\tisnull;\n\n\t/*\n\t * See if we have the function address cached already\n\t */\n\thashentry = lookup_C_func(procedureTuple);\n\tif (hashentry)\n\t{\n\t\tuser_fn = hashentry->user_fn;\n\t\tinforec = hashentry->inforec;\n\t}\n\telse\n\t{\n\t\tDatum\t\tprosrcattr,\n\t\t\t\t\tprobinattr;\n\t\tchar\t   *prosrcstring,\n\t\t\t\t   *probinstring;\n\t\tvoid\t   *libraryhandle;\n\n\t\t/*\n\t\t * Get prosrc and probin strings (link symbol and library filename).\n\t\t * While in general these columns might be null, that's not allowed\n\t\t * for C-language functions.\n\t\t */\n\t\tprosrcattr = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t Anum_pg_proc_prosrc, &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null prosrc for C function %u\", functionId);\n\t\tprosrcstring = TextDatumGetCString(prosrcattr);\n\n\t\tprobinattr = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t Anum_pg_proc_probin, &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null probin for C function %u\", functionId);\n\t\tprobinstring = TextDatumGetCString(probinattr);\n\n\t\t/* Look up the function itself */\n\t\tuser_fn = load_external_function(probinstring, prosrcstring, true,\n\t\t\t\t\t\t\t\t\t\t &libraryhandle);\n\n\t\t/* Get the function information record (real or default) */\n\t\tinforec = fetch_finfo_record(libraryhandle, prosrcstring);\n\n\t\t/* Cache the addresses for later calls */\n\t\trecord_C_func(procedureTuple, user_fn, inforec);\n\n\t\tpfree(prosrcstring);\n\t\tpfree(probinstring);\n\t}\n\n\tswitch (inforec->api_version)\n\t{\n\t\tcase 1:\n\t\t\t/* New style: call directly */\n\t\t\tfinfo->fn_addr = user_fn;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* Shouldn't get here if fetch_finfo_record did its job */\n\t\t\telog(ERROR, \"unrecognized function API version: %d\",\n\t\t\t\t inforec->api_version);\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "prosrc"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"internal function \\\"%s\\\" is not in internal lookup table\",\n\t\t\t\t\t\t\t\tprosrc))"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"internal function \\\"%s\\\" is not in internal lookup table\"",
            "prosrc"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_FUNCTION"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_lookupByName",
          "args": [
            "prosrc"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_lookupByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "97-108",
          "snippet": "static const FmgrBuiltin *\nfmgr_lookupByName(const char *name)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < fmgr_nbuiltins; i++)\n\t{\n\t\tif (strcmp(name, fmgr_builtins[i].funcName) == 0)\n\t\t\treturn fmgr_builtins + i;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic const FmgrBuiltin *\nfmgr_lookupByName(const char *name)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < fmgr_nbuiltins; i++)\n\t{\n\t\tif (strcmp(name, fmgr_builtins[i].funcName) == 0)\n\t\t\treturn fmgr_builtins + i;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "prosrcdatum"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"null prosrc\""
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SysCacheGetAttr",
          "args": [
            "PROCOID",
            "procedureTuple",
            "Anum_pg_proc_prosrc",
            "&isnull"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "SysCacheGetAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1367-1390",
          "snippet": "Datum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nDatum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FmgrHookIsNeeded",
          "args": [
            "functionId"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_attisnull",
          "args": [
            "procedureTuple",
            "Anum_pg_proc_proconfig",
            "NULL"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "procedureTuple"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "procedureTuple"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "PROCOID",
            "ObjectIdGetDatum(functionId)"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "functionId"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_isbuiltin",
          "args": [
            "functionId"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_isbuiltin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "72-90",
          "snippet": "static const FmgrBuiltin *\nfmgr_isbuiltin(Oid id)\n{\n\tuint16\t\tindex;\n\n\t/* fast lookup only possible if original oid still assigned */\n\tif (id >= FirstBootstrapObjectId)\n\t\treturn NULL;\n\n\t/*\n\t * Lookup function data. If there's a miss in that range it's likely a\n\t * nonexistant function, returning NULL here will trigger an ERROR later.\n\t */\n\tindex = fmgr_builtin_oid_index[id];\n\tif (index == InvalidOidBuiltinMapping)\n\t\treturn NULL;\n\n\treturn &fmgr_builtins[index];\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic const FmgrBuiltin *\nfmgr_isbuiltin(Oid id)\n{\n\tuint16\t\tindex;\n\n\t/* fast lookup only possible if original oid still assigned */\n\tif (id >= FirstBootstrapObjectId)\n\t\treturn NULL;\n\n\t/*\n\t * Lookup function data. If there's a miss in that range it's likely a\n\t * nonexistant function, returning NULL here will trigger an ERROR later.\n\t */\n\tindex = fmgr_builtin_oid_index[id];\n\tif (index == InvalidOidBuiltinMapping)\n\t\treturn NULL;\n\n\treturn &fmgr_builtins[index];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic void fmgr_info_cxt_security(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,\n\t\t\t\t\t   bool ignore_security);\nstatic void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);\n\nstatic void\nfmgr_info_cxt_security(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,\n\t\t\t\t\t   bool ignore_security)\n{\n\tconst FmgrBuiltin *fbp;\n\tHeapTuple\tprocedureTuple;\n\tForm_pg_proc procedureStruct;\n\tDatum\t\tprosrcdatum;\n\tbool\t\tisnull;\n\tchar\t   *prosrc;\n\n\t/*\n\t * fn_oid *must* be filled in last.  Some code assumes that if fn_oid is\n\t * valid, the whole struct is valid.  Some FmgrInfo struct's do survive\n\t * elogs.\n\t */\n\tfinfo->fn_oid = InvalidOid;\n\tfinfo->fn_extra = NULL;\n\tfinfo->fn_mcxt = mcxt;\n\tfinfo->fn_expr = NULL;\t\t/* caller may set this later */\n\n\tif ((fbp = fmgr_isbuiltin(functionId)) != NULL)\n\t{\n\t\t/*\n\t\t * Fast path for builtin functions: don't bother consulting pg_proc\n\t\t */\n\t\tfinfo->fn_nargs = fbp->nargs;\n\t\tfinfo->fn_strict = fbp->strict;\n\t\tfinfo->fn_retset = fbp->retset;\n\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\tfinfo->fn_addr = fbp->func;\n\t\tfinfo->fn_oid = functionId;\n\t\treturn;\n\t}\n\n\t/* Otherwise we need the pg_proc entry */\n\tprocedureTuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(functionId));\n\tif (!HeapTupleIsValid(procedureTuple))\n\t\telog(ERROR, \"cache lookup failed for function %u\", functionId);\n\tprocedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);\n\n\tfinfo->fn_nargs = procedureStruct->pronargs;\n\tfinfo->fn_strict = procedureStruct->proisstrict;\n\tfinfo->fn_retset = procedureStruct->proretset;\n\n\t/*\n\t * If it has prosecdef set, non-null proconfig, or if a plugin wants to\n\t * hook function entry/exit, use fmgr_security_definer call handler ---\n\t * unless we are being called again by fmgr_security_definer or\n\t * fmgr_info_other_lang.\n\t *\n\t * When using fmgr_security_definer, function stats tracking is always\n\t * disabled at the outer level, and instead we set the flag properly in\n\t * fmgr_security_definer's private flinfo and implement the tracking\n\t * inside fmgr_security_definer.  This loses the ability to charge the\n\t * overhead of fmgr_security_definer to the function, but gains the\n\t * ability to set the track_functions GUC as a local GUC parameter of an\n\t * interesting function and have the right things happen.\n\t */\n\tif (!ignore_security &&\n\t\t(procedureStruct->prosecdef ||\n\t\t !heap_attisnull(procedureTuple, Anum_pg_proc_proconfig, NULL) ||\n\t\t FmgrHookIsNeeded(functionId)))\n\t{\n\t\tfinfo->fn_addr = fmgr_security_definer;\n\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\tfinfo->fn_oid = functionId;\n\t\tReleaseSysCache(procedureTuple);\n\t\treturn;\n\t}\n\n\tswitch (procedureStruct->prolang)\n\t{\n\t\tcase INTERNALlanguageId:\n\n\t\t\t/*\n\t\t\t * For an ordinary builtin function, we should never get here\n\t\t\t * because the isbuiltin() search above will have succeeded.\n\t\t\t * However, if the user has done a CREATE FUNCTION to create an\n\t\t\t * alias for a builtin function, we can end up here.  In that case\n\t\t\t * we have to look up the function by name.  The name of the\n\t\t\t * internal function is stored in prosrc (it doesn't have to be\n\t\t\t * the same as the name of the alias!)\n\t\t\t */\n\t\t\tprosrcdatum = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t\t  Anum_pg_proc_prosrc, &isnull);\n\t\t\tif (isnull)\n\t\t\t\telog(ERROR, \"null prosrc\");\n\t\t\tprosrc = TextDatumGetCString(prosrcdatum);\n\t\t\tfbp = fmgr_lookupByName(prosrc);\n\t\t\tif (fbp == NULL)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"internal function \\\"%s\\\" is not in internal lookup table\",\n\t\t\t\t\t\t\t\tprosrc)));\n\t\t\tpfree(prosrc);\n\t\t\t/* Should we check that nargs, strict, retset match the table? */\n\t\t\tfinfo->fn_addr = fbp->func;\n\t\t\t/* note this policy is also assumed in fast path above */\n\t\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\t\tbreak;\n\n\t\tcase ClanguageId:\n\t\t\tfmgr_info_C_lang(functionId, finfo, procedureTuple);\n\t\t\tfinfo->fn_stats = TRACK_FUNC_PL;\t/* ie, track if ALL */\n\t\t\tbreak;\n\n\t\tcase SQLlanguageId:\n\t\t\tfinfo->fn_addr = fmgr_sql;\n\t\t\tfinfo->fn_stats = TRACK_FUNC_PL;\t/* ie, track if ALL */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmgr_info_other_lang(functionId, finfo, procedureTuple);\n\t\t\tfinfo->fn_stats = TRACK_FUNC_OFF;\t/* ie, track if not OFF */\n\t\t\tbreak;\n\t}\n\n\tfinfo->fn_oid = functionId;\n\tReleaseSysCache(procedureTuple);\n}"
  },
  {
    "function_name": "fmgr_info_cxt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "133-137",
    "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fmgr_info_cxt_security",
          "args": [
            "functionId",
            "finfo",
            "mcxt",
            "false"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt_security",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "143-263",
          "snippet": "static void\nfmgr_info_cxt_security(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,\n\t\t\t\t\t   bool ignore_security)\n{\n\tconst FmgrBuiltin *fbp;\n\tHeapTuple\tprocedureTuple;\n\tForm_pg_proc procedureStruct;\n\tDatum\t\tprosrcdatum;\n\tbool\t\tisnull;\n\tchar\t   *prosrc;\n\n\t/*\n\t * fn_oid *must* be filled in last.  Some code assumes that if fn_oid is\n\t * valid, the whole struct is valid.  Some FmgrInfo struct's do survive\n\t * elogs.\n\t */\n\tfinfo->fn_oid = InvalidOid;\n\tfinfo->fn_extra = NULL;\n\tfinfo->fn_mcxt = mcxt;\n\tfinfo->fn_expr = NULL;\t\t/* caller may set this later */\n\n\tif ((fbp = fmgr_isbuiltin(functionId)) != NULL)\n\t{\n\t\t/*\n\t\t * Fast path for builtin functions: don't bother consulting pg_proc\n\t\t */\n\t\tfinfo->fn_nargs = fbp->nargs;\n\t\tfinfo->fn_strict = fbp->strict;\n\t\tfinfo->fn_retset = fbp->retset;\n\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\tfinfo->fn_addr = fbp->func;\n\t\tfinfo->fn_oid = functionId;\n\t\treturn;\n\t}\n\n\t/* Otherwise we need the pg_proc entry */\n\tprocedureTuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(functionId));\n\tif (!HeapTupleIsValid(procedureTuple))\n\t\telog(ERROR, \"cache lookup failed for function %u\", functionId);\n\tprocedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);\n\n\tfinfo->fn_nargs = procedureStruct->pronargs;\n\tfinfo->fn_strict = procedureStruct->proisstrict;\n\tfinfo->fn_retset = procedureStruct->proretset;\n\n\t/*\n\t * If it has prosecdef set, non-null proconfig, or if a plugin wants to\n\t * hook function entry/exit, use fmgr_security_definer call handler ---\n\t * unless we are being called again by fmgr_security_definer or\n\t * fmgr_info_other_lang.\n\t *\n\t * When using fmgr_security_definer, function stats tracking is always\n\t * disabled at the outer level, and instead we set the flag properly in\n\t * fmgr_security_definer's private flinfo and implement the tracking\n\t * inside fmgr_security_definer.  This loses the ability to charge the\n\t * overhead of fmgr_security_definer to the function, but gains the\n\t * ability to set the track_functions GUC as a local GUC parameter of an\n\t * interesting function and have the right things happen.\n\t */\n\tif (!ignore_security &&\n\t\t(procedureStruct->prosecdef ||\n\t\t !heap_attisnull(procedureTuple, Anum_pg_proc_proconfig, NULL) ||\n\t\t FmgrHookIsNeeded(functionId)))\n\t{\n\t\tfinfo->fn_addr = fmgr_security_definer;\n\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\tfinfo->fn_oid = functionId;\n\t\tReleaseSysCache(procedureTuple);\n\t\treturn;\n\t}\n\n\tswitch (procedureStruct->prolang)\n\t{\n\t\tcase INTERNALlanguageId:\n\n\t\t\t/*\n\t\t\t * For an ordinary builtin function, we should never get here\n\t\t\t * because the isbuiltin() search above will have succeeded.\n\t\t\t * However, if the user has done a CREATE FUNCTION to create an\n\t\t\t * alias for a builtin function, we can end up here.  In that case\n\t\t\t * we have to look up the function by name.  The name of the\n\t\t\t * internal function is stored in prosrc (it doesn't have to be\n\t\t\t * the same as the name of the alias!)\n\t\t\t */\n\t\t\tprosrcdatum = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t\t  Anum_pg_proc_prosrc, &isnull);\n\t\t\tif (isnull)\n\t\t\t\telog(ERROR, \"null prosrc\");\n\t\t\tprosrc = TextDatumGetCString(prosrcdatum);\n\t\t\tfbp = fmgr_lookupByName(prosrc);\n\t\t\tif (fbp == NULL)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"internal function \\\"%s\\\" is not in internal lookup table\",\n\t\t\t\t\t\t\t\tprosrc)));\n\t\t\tpfree(prosrc);\n\t\t\t/* Should we check that nargs, strict, retset match the table? */\n\t\t\tfinfo->fn_addr = fbp->func;\n\t\t\t/* note this policy is also assumed in fast path above */\n\t\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\t\tbreak;\n\n\t\tcase ClanguageId:\n\t\t\tfmgr_info_C_lang(functionId, finfo, procedureTuple);\n\t\t\tfinfo->fn_stats = TRACK_FUNC_PL;\t/* ie, track if ALL */\n\t\t\tbreak;\n\n\t\tcase SQLlanguageId:\n\t\t\tfinfo->fn_addr = fmgr_sql;\n\t\t\tfinfo->fn_stats = TRACK_FUNC_PL;\t/* ie, track if ALL */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmgr_info_other_lang(functionId, finfo, procedureTuple);\n\t\t\tfinfo->fn_stats = TRACK_FUNC_OFF;\t/* ie, track if not OFF */\n\t\t\tbreak;\n\t}\n\n\tfinfo->fn_oid = functionId;\n\tReleaseSysCache(procedureTuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fmgr_info_cxt_security(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,\n\t\t\t\t\t   bool ignore_security);",
            "static void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
            "static void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
            "static CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic void fmgr_info_cxt_security(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,\n\t\t\t\t\t   bool ignore_security);\nstatic void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);\n\nstatic void\nfmgr_info_cxt_security(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,\n\t\t\t\t\t   bool ignore_security)\n{\n\tconst FmgrBuiltin *fbp;\n\tHeapTuple\tprocedureTuple;\n\tForm_pg_proc procedureStruct;\n\tDatum\t\tprosrcdatum;\n\tbool\t\tisnull;\n\tchar\t   *prosrc;\n\n\t/*\n\t * fn_oid *must* be filled in last.  Some code assumes that if fn_oid is\n\t * valid, the whole struct is valid.  Some FmgrInfo struct's do survive\n\t * elogs.\n\t */\n\tfinfo->fn_oid = InvalidOid;\n\tfinfo->fn_extra = NULL;\n\tfinfo->fn_mcxt = mcxt;\n\tfinfo->fn_expr = NULL;\t\t/* caller may set this later */\n\n\tif ((fbp = fmgr_isbuiltin(functionId)) != NULL)\n\t{\n\t\t/*\n\t\t * Fast path for builtin functions: don't bother consulting pg_proc\n\t\t */\n\t\tfinfo->fn_nargs = fbp->nargs;\n\t\tfinfo->fn_strict = fbp->strict;\n\t\tfinfo->fn_retset = fbp->retset;\n\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\tfinfo->fn_addr = fbp->func;\n\t\tfinfo->fn_oid = functionId;\n\t\treturn;\n\t}\n\n\t/* Otherwise we need the pg_proc entry */\n\tprocedureTuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(functionId));\n\tif (!HeapTupleIsValid(procedureTuple))\n\t\telog(ERROR, \"cache lookup failed for function %u\", functionId);\n\tprocedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);\n\n\tfinfo->fn_nargs = procedureStruct->pronargs;\n\tfinfo->fn_strict = procedureStruct->proisstrict;\n\tfinfo->fn_retset = procedureStruct->proretset;\n\n\t/*\n\t * If it has prosecdef set, non-null proconfig, or if a plugin wants to\n\t * hook function entry/exit, use fmgr_security_definer call handler ---\n\t * unless we are being called again by fmgr_security_definer or\n\t * fmgr_info_other_lang.\n\t *\n\t * When using fmgr_security_definer, function stats tracking is always\n\t * disabled at the outer level, and instead we set the flag properly in\n\t * fmgr_security_definer's private flinfo and implement the tracking\n\t * inside fmgr_security_definer.  This loses the ability to charge the\n\t * overhead of fmgr_security_definer to the function, but gains the\n\t * ability to set the track_functions GUC as a local GUC parameter of an\n\t * interesting function and have the right things happen.\n\t */\n\tif (!ignore_security &&\n\t\t(procedureStruct->prosecdef ||\n\t\t !heap_attisnull(procedureTuple, Anum_pg_proc_proconfig, NULL) ||\n\t\t FmgrHookIsNeeded(functionId)))\n\t{\n\t\tfinfo->fn_addr = fmgr_security_definer;\n\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\tfinfo->fn_oid = functionId;\n\t\tReleaseSysCache(procedureTuple);\n\t\treturn;\n\t}\n\n\tswitch (procedureStruct->prolang)\n\t{\n\t\tcase INTERNALlanguageId:\n\n\t\t\t/*\n\t\t\t * For an ordinary builtin function, we should never get here\n\t\t\t * because the isbuiltin() search above will have succeeded.\n\t\t\t * However, if the user has done a CREATE FUNCTION to create an\n\t\t\t * alias for a builtin function, we can end up here.  In that case\n\t\t\t * we have to look up the function by name.  The name of the\n\t\t\t * internal function is stored in prosrc (it doesn't have to be\n\t\t\t * the same as the name of the alias!)\n\t\t\t */\n\t\t\tprosrcdatum = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t\t  Anum_pg_proc_prosrc, &isnull);\n\t\t\tif (isnull)\n\t\t\t\telog(ERROR, \"null prosrc\");\n\t\t\tprosrc = TextDatumGetCString(prosrcdatum);\n\t\t\tfbp = fmgr_lookupByName(prosrc);\n\t\t\tif (fbp == NULL)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"internal function \\\"%s\\\" is not in internal lookup table\",\n\t\t\t\t\t\t\t\tprosrc)));\n\t\t\tpfree(prosrc);\n\t\t\t/* Should we check that nargs, strict, retset match the table? */\n\t\t\tfinfo->fn_addr = fbp->func;\n\t\t\t/* note this policy is also assumed in fast path above */\n\t\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\t\tbreak;\n\n\t\tcase ClanguageId:\n\t\t\tfmgr_info_C_lang(functionId, finfo, procedureTuple);\n\t\t\tfinfo->fn_stats = TRACK_FUNC_PL;\t/* ie, track if ALL */\n\t\t\tbreak;\n\n\t\tcase SQLlanguageId:\n\t\t\tfinfo->fn_addr = fmgr_sql;\n\t\t\tfinfo->fn_stats = TRACK_FUNC_PL;\t/* ie, track if ALL */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmgr_info_other_lang(functionId, finfo, procedureTuple);\n\t\t\tfinfo->fn_stats = TRACK_FUNC_OFF;\t/* ie, track if not OFF */\n\t\t\tbreak;\n\t}\n\n\tfinfo->fn_oid = functionId;\n\tReleaseSysCache(procedureTuple);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
  },
  {
    "function_name": "fmgr_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "123-127",
    "snippet": "void\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fmgr_info_cxt_security",
          "args": [
            "functionId",
            "finfo",
            "CurrentMemoryContext",
            "false"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt_security",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "143-263",
          "snippet": "static void\nfmgr_info_cxt_security(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,\n\t\t\t\t\t   bool ignore_security)\n{\n\tconst FmgrBuiltin *fbp;\n\tHeapTuple\tprocedureTuple;\n\tForm_pg_proc procedureStruct;\n\tDatum\t\tprosrcdatum;\n\tbool\t\tisnull;\n\tchar\t   *prosrc;\n\n\t/*\n\t * fn_oid *must* be filled in last.  Some code assumes that if fn_oid is\n\t * valid, the whole struct is valid.  Some FmgrInfo struct's do survive\n\t * elogs.\n\t */\n\tfinfo->fn_oid = InvalidOid;\n\tfinfo->fn_extra = NULL;\n\tfinfo->fn_mcxt = mcxt;\n\tfinfo->fn_expr = NULL;\t\t/* caller may set this later */\n\n\tif ((fbp = fmgr_isbuiltin(functionId)) != NULL)\n\t{\n\t\t/*\n\t\t * Fast path for builtin functions: don't bother consulting pg_proc\n\t\t */\n\t\tfinfo->fn_nargs = fbp->nargs;\n\t\tfinfo->fn_strict = fbp->strict;\n\t\tfinfo->fn_retset = fbp->retset;\n\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\tfinfo->fn_addr = fbp->func;\n\t\tfinfo->fn_oid = functionId;\n\t\treturn;\n\t}\n\n\t/* Otherwise we need the pg_proc entry */\n\tprocedureTuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(functionId));\n\tif (!HeapTupleIsValid(procedureTuple))\n\t\telog(ERROR, \"cache lookup failed for function %u\", functionId);\n\tprocedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);\n\n\tfinfo->fn_nargs = procedureStruct->pronargs;\n\tfinfo->fn_strict = procedureStruct->proisstrict;\n\tfinfo->fn_retset = procedureStruct->proretset;\n\n\t/*\n\t * If it has prosecdef set, non-null proconfig, or if a plugin wants to\n\t * hook function entry/exit, use fmgr_security_definer call handler ---\n\t * unless we are being called again by fmgr_security_definer or\n\t * fmgr_info_other_lang.\n\t *\n\t * When using fmgr_security_definer, function stats tracking is always\n\t * disabled at the outer level, and instead we set the flag properly in\n\t * fmgr_security_definer's private flinfo and implement the tracking\n\t * inside fmgr_security_definer.  This loses the ability to charge the\n\t * overhead of fmgr_security_definer to the function, but gains the\n\t * ability to set the track_functions GUC as a local GUC parameter of an\n\t * interesting function and have the right things happen.\n\t */\n\tif (!ignore_security &&\n\t\t(procedureStruct->prosecdef ||\n\t\t !heap_attisnull(procedureTuple, Anum_pg_proc_proconfig, NULL) ||\n\t\t FmgrHookIsNeeded(functionId)))\n\t{\n\t\tfinfo->fn_addr = fmgr_security_definer;\n\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\tfinfo->fn_oid = functionId;\n\t\tReleaseSysCache(procedureTuple);\n\t\treturn;\n\t}\n\n\tswitch (procedureStruct->prolang)\n\t{\n\t\tcase INTERNALlanguageId:\n\n\t\t\t/*\n\t\t\t * For an ordinary builtin function, we should never get here\n\t\t\t * because the isbuiltin() search above will have succeeded.\n\t\t\t * However, if the user has done a CREATE FUNCTION to create an\n\t\t\t * alias for a builtin function, we can end up here.  In that case\n\t\t\t * we have to look up the function by name.  The name of the\n\t\t\t * internal function is stored in prosrc (it doesn't have to be\n\t\t\t * the same as the name of the alias!)\n\t\t\t */\n\t\t\tprosrcdatum = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t\t  Anum_pg_proc_prosrc, &isnull);\n\t\t\tif (isnull)\n\t\t\t\telog(ERROR, \"null prosrc\");\n\t\t\tprosrc = TextDatumGetCString(prosrcdatum);\n\t\t\tfbp = fmgr_lookupByName(prosrc);\n\t\t\tif (fbp == NULL)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"internal function \\\"%s\\\" is not in internal lookup table\",\n\t\t\t\t\t\t\t\tprosrc)));\n\t\t\tpfree(prosrc);\n\t\t\t/* Should we check that nargs, strict, retset match the table? */\n\t\t\tfinfo->fn_addr = fbp->func;\n\t\t\t/* note this policy is also assumed in fast path above */\n\t\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\t\tbreak;\n\n\t\tcase ClanguageId:\n\t\t\tfmgr_info_C_lang(functionId, finfo, procedureTuple);\n\t\t\tfinfo->fn_stats = TRACK_FUNC_PL;\t/* ie, track if ALL */\n\t\t\tbreak;\n\n\t\tcase SQLlanguageId:\n\t\t\tfinfo->fn_addr = fmgr_sql;\n\t\t\tfinfo->fn_stats = TRACK_FUNC_PL;\t/* ie, track if ALL */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmgr_info_other_lang(functionId, finfo, procedureTuple);\n\t\t\tfinfo->fn_stats = TRACK_FUNC_OFF;\t/* ie, track if not OFF */\n\t\t\tbreak;\n\t}\n\n\tfinfo->fn_oid = functionId;\n\tReleaseSysCache(procedureTuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fmgr_info_cxt_security(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,\n\t\t\t\t\t   bool ignore_security);",
            "static void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
            "static void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);",
            "static CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic void fmgr_info_cxt_security(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,\n\t\t\t\t\t   bool ignore_security);\nstatic void fmgr_info_C_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic void fmgr_info_other_lang(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);\nstatic CFuncHashTabEntry *lookup_C_func(HeapTuple procedureTuple);\n\nstatic void\nfmgr_info_cxt_security(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,\n\t\t\t\t\t   bool ignore_security)\n{\n\tconst FmgrBuiltin *fbp;\n\tHeapTuple\tprocedureTuple;\n\tForm_pg_proc procedureStruct;\n\tDatum\t\tprosrcdatum;\n\tbool\t\tisnull;\n\tchar\t   *prosrc;\n\n\t/*\n\t * fn_oid *must* be filled in last.  Some code assumes that if fn_oid is\n\t * valid, the whole struct is valid.  Some FmgrInfo struct's do survive\n\t * elogs.\n\t */\n\tfinfo->fn_oid = InvalidOid;\n\tfinfo->fn_extra = NULL;\n\tfinfo->fn_mcxt = mcxt;\n\tfinfo->fn_expr = NULL;\t\t/* caller may set this later */\n\n\tif ((fbp = fmgr_isbuiltin(functionId)) != NULL)\n\t{\n\t\t/*\n\t\t * Fast path for builtin functions: don't bother consulting pg_proc\n\t\t */\n\t\tfinfo->fn_nargs = fbp->nargs;\n\t\tfinfo->fn_strict = fbp->strict;\n\t\tfinfo->fn_retset = fbp->retset;\n\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\tfinfo->fn_addr = fbp->func;\n\t\tfinfo->fn_oid = functionId;\n\t\treturn;\n\t}\n\n\t/* Otherwise we need the pg_proc entry */\n\tprocedureTuple = SearchSysCache1(PROCOID, ObjectIdGetDatum(functionId));\n\tif (!HeapTupleIsValid(procedureTuple))\n\t\telog(ERROR, \"cache lookup failed for function %u\", functionId);\n\tprocedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);\n\n\tfinfo->fn_nargs = procedureStruct->pronargs;\n\tfinfo->fn_strict = procedureStruct->proisstrict;\n\tfinfo->fn_retset = procedureStruct->proretset;\n\n\t/*\n\t * If it has prosecdef set, non-null proconfig, or if a plugin wants to\n\t * hook function entry/exit, use fmgr_security_definer call handler ---\n\t * unless we are being called again by fmgr_security_definer or\n\t * fmgr_info_other_lang.\n\t *\n\t * When using fmgr_security_definer, function stats tracking is always\n\t * disabled at the outer level, and instead we set the flag properly in\n\t * fmgr_security_definer's private flinfo and implement the tracking\n\t * inside fmgr_security_definer.  This loses the ability to charge the\n\t * overhead of fmgr_security_definer to the function, but gains the\n\t * ability to set the track_functions GUC as a local GUC parameter of an\n\t * interesting function and have the right things happen.\n\t */\n\tif (!ignore_security &&\n\t\t(procedureStruct->prosecdef ||\n\t\t !heap_attisnull(procedureTuple, Anum_pg_proc_proconfig, NULL) ||\n\t\t FmgrHookIsNeeded(functionId)))\n\t{\n\t\tfinfo->fn_addr = fmgr_security_definer;\n\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\tfinfo->fn_oid = functionId;\n\t\tReleaseSysCache(procedureTuple);\n\t\treturn;\n\t}\n\n\tswitch (procedureStruct->prolang)\n\t{\n\t\tcase INTERNALlanguageId:\n\n\t\t\t/*\n\t\t\t * For an ordinary builtin function, we should never get here\n\t\t\t * because the isbuiltin() search above will have succeeded.\n\t\t\t * However, if the user has done a CREATE FUNCTION to create an\n\t\t\t * alias for a builtin function, we can end up here.  In that case\n\t\t\t * we have to look up the function by name.  The name of the\n\t\t\t * internal function is stored in prosrc (it doesn't have to be\n\t\t\t * the same as the name of the alias!)\n\t\t\t */\n\t\t\tprosrcdatum = SysCacheGetAttr(PROCOID, procedureTuple,\n\t\t\t\t\t\t\t\t\t\t  Anum_pg_proc_prosrc, &isnull);\n\t\t\tif (isnull)\n\t\t\t\telog(ERROR, \"null prosrc\");\n\t\t\tprosrc = TextDatumGetCString(prosrcdatum);\n\t\t\tfbp = fmgr_lookupByName(prosrc);\n\t\t\tif (fbp == NULL)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t\t\t errmsg(\"internal function \\\"%s\\\" is not in internal lookup table\",\n\t\t\t\t\t\t\t\tprosrc)));\n\t\t\tpfree(prosrc);\n\t\t\t/* Should we check that nargs, strict, retset match the table? */\n\t\t\tfinfo->fn_addr = fbp->func;\n\t\t\t/* note this policy is also assumed in fast path above */\n\t\t\tfinfo->fn_stats = TRACK_FUNC_ALL;\t/* ie, never track */\n\t\t\tbreak;\n\n\t\tcase ClanguageId:\n\t\t\tfmgr_info_C_lang(functionId, finfo, procedureTuple);\n\t\t\tfinfo->fn_stats = TRACK_FUNC_PL;\t/* ie, track if ALL */\n\t\t\tbreak;\n\n\t\tcase SQLlanguageId:\n\t\t\tfinfo->fn_addr = fmgr_sql;\n\t\t\tfinfo->fn_stats = TRACK_FUNC_PL;\t/* ie, track if ALL */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfmgr_info_other_lang(functionId, finfo, procedureTuple);\n\t\t\tfinfo->fn_stats = TRACK_FUNC_OFF;\t/* ie, track if not OFF */\n\t\t\tbreak;\n\t}\n\n\tfinfo->fn_oid = functionId;\n\tReleaseSysCache(procedureTuple);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info(Oid functionId, FmgrInfo *finfo)\n{\n\tfmgr_info_cxt_security(functionId, finfo, CurrentMemoryContext, false);\n}"
  },
  {
    "function_name": "fmgr_lookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "97-108",
    "snippet": "static const FmgrBuiltin *\nfmgr_lookupByName(const char *name)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < fmgr_nbuiltins; i++)\n\t{\n\t\tif (strcmp(name, fmgr_builtins[i].funcName) == 0)\n\t\t\treturn fmgr_builtins + i;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "fmgr_builtins[i].funcName"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic const FmgrBuiltin *\nfmgr_lookupByName(const char *name)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < fmgr_nbuiltins; i++)\n\t{\n\t\tif (strcmp(name, fmgr_builtins[i].funcName) == 0)\n\t\t\treturn fmgr_builtins + i;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "fmgr_isbuiltin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
    "lines": "72-90",
    "snippet": "static const FmgrBuiltin *\nfmgr_isbuiltin(Oid id)\n{\n\tuint16\t\tindex;\n\n\t/* fast lookup only possible if original oid still assigned */\n\tif (id >= FirstBootstrapObjectId)\n\t\treturn NULL;\n\n\t/*\n\t * Lookup function data. If there's a miss in that range it's likely a\n\t * nonexistant function, returning NULL here will trigger an ERROR later.\n\t */\n\tindex = fmgr_builtin_oid_index[id];\n\tif (index == InvalidOidBuiltinMapping)\n\t\treturn NULL;\n\n\treturn &fmgr_builtins[index];\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/guc.h\"",
      "#include \"utils/fmgrtab.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/acl.h\"",
      "#include \"pgstat.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/functions.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_language.h\"",
      "#include \"access/tuptoaster.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nstatic const FmgrBuiltin *\nfmgr_isbuiltin(Oid id)\n{\n\tuint16\t\tindex;\n\n\t/* fast lookup only possible if original oid still assigned */\n\tif (id >= FirstBootstrapObjectId)\n\t\treturn NULL;\n\n\t/*\n\t * Lookup function data. If there's a miss in that range it's likely a\n\t * nonexistant function, returning NULL here will trigger an ERROR later.\n\t */\n\tindex = fmgr_builtin_oid_index[id];\n\tif (index == InvalidOidBuiltinMapping)\n\t\treturn NULL;\n\n\treturn &fmgr_builtins[index];\n}"
  }
]