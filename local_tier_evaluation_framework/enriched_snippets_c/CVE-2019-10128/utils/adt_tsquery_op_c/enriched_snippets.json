[
  {
    "function_name": "tsq_mcontained",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
    "lines": "374-384",
    "snippet": "Datum\ntsq_mcontained(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_DATUM(\n\t\t\t\t\tDirectFunctionCall2(\n\t\t\t\t\t\t\t\t\t\ttsq_mcontains,\n\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(1),\n\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(0)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "DirectFunctionCall2(\n\t\t\t\t\t\t\t\t\t\ttsq_mcontains,\n\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(1),\n\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(0)\n\t\t\t\t\t\t\t\t\t\t)"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "tsq_mcontains",
            "PG_GETARG_DATUM(1)",
            "PG_GETARG_DATUM(0)"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nDatum\ntsq_mcontained(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_DATUM(\n\t\t\t\t\tDirectFunctionCall2(\n\t\t\t\t\t\t\t\t\t\ttsq_mcontains,\n\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(1),\n\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(0)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t);\n}"
  },
  {
    "function_name": "tsq_mcontains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
    "lines": "328-372",
    "snippet": "Datum\ntsq_mcontains(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(0);\n\tTSQuery\t\tex = PG_GETARG_TSQUERY(1);\n\tchar\t  **query_values;\n\tint\t\t\tquery_nvalues;\n\tchar\t  **ex_values;\n\tint\t\t\tex_nvalues;\n\tbool\t\tresult = true;\n\n\t/* Extract the query terms into arrays */\n\tquery_values = collectTSQueryValues(query, &query_nvalues);\n\tex_values = collectTSQueryValues(ex, &ex_nvalues);\n\n\t/* Sort and remove duplicates from both arrays */\n\tqsort(query_values, query_nvalues, sizeof(char *), cmp_string);\n\tquery_nvalues = remove_duplicates(query_values, query_nvalues);\n\tqsort(ex_values, ex_nvalues, sizeof(char *), cmp_string);\n\tex_nvalues = remove_duplicates(ex_values, ex_nvalues);\n\n\tif (ex_nvalues > query_nvalues)\n\t\tresult = false;\n\telse\n\t{\n\t\tint\t\t\ti;\n\t\tint\t\t\tj = 0;\n\n\t\tfor (i = 0; i < ex_nvalues; i++)\n\t\t{\n\t\t\tfor (; j < query_nvalues; j++)\n\t\t\t{\n\t\t\t\tif (strcmp(ex_values[i], query_values[j]) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j == query_nvalues)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ex_values[i]",
            "query_values[j]"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_duplicates",
          "args": [
            "ex_values",
            "ex_nvalues"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "remove_duplicates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
          "lines": "305-326",
          "snippet": "static int\nremove_duplicates(char **strings, int n)\n{\n\tif (n <= 1)\n\t\treturn n;\n\telse\n\t{\n\t\tint\t\t\ti;\n\t\tchar\t   *prev = strings[0];\n\t\tint\t\t\tnew_n = 1;\n\n\t\tfor (i = 1; i < n; i++)\n\t\t{\n\t\t\tif (strcmp(strings[i], prev) != 0)\n\t\t\t{\n\t\t\t\tstrings[new_n++] = strings[i];\n\t\t\t\tprev = strings[i];\n\t\t\t}\n\t\t}\n\t\treturn new_n;\n\t}\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int\nremove_duplicates(char **strings, int n)\n{\n\tif (n <= 1)\n\t\treturn n;\n\telse\n\t{\n\t\tint\t\t\ti;\n\t\tchar\t   *prev = strings[0];\n\t\tint\t\t\tnew_n = 1;\n\n\t\tfor (i = 1; i < n; i++)\n\t\t{\n\t\t\tif (strcmp(strings[i], prev) != 0)\n\t\t\t{\n\t\t\t\tstrings[new_n++] = strings[i];\n\t\t\t\tprev = strings[i];\n\t\t\t}\n\t\t}\n\t\treturn new_n;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "ex_values",
            "ex_nvalues",
            "sizeof(char *)",
            "cmp_string"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "query_values",
            "query_nvalues",
            "sizeof(char *)",
            "cmp_string"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collectTSQueryValues",
          "args": [
            "ex",
            "&ex_nvalues"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "collectTSQueryValues",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
          "lines": "265-294",
          "snippet": "static char **\ncollectTSQueryValues(TSQuery a, int *nvalues_p)\n{\n\tQueryItem  *ptr = GETQUERY(a);\n\tchar\t   *operand = GETOPERAND(a);\n\tchar\t  **values;\n\tint\t\t\tnvalues = 0;\n\tint\t\t\ti;\n\n\tvalues = (char **) palloc(sizeof(char *) * a->size);\n\n\tfor (i = 0; i < a->size; i++)\n\t{\n\t\tif (ptr->type == QI_VAL)\n\t\t{\n\t\t\tint\t\t\tlen = ptr->qoperand.length;\n\t\t\tchar\t   *val;\n\n\t\t\tval = palloc(len + 1);\n\t\t\tmemcpy(val, operand + ptr->qoperand.distance, len);\n\t\t\tval[len] = '\\0';\n\n\t\t\tvalues[nvalues++] = val;\n\t\t}\n\t\tptr++;\n\t}\n\n\t*nvalues_p = nvalues;\n\treturn values;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic char **\ncollectTSQueryValues(TSQuery a, int *nvalues_p)\n{\n\tQueryItem  *ptr = GETQUERY(a);\n\tchar\t   *operand = GETOPERAND(a);\n\tchar\t  **values;\n\tint\t\t\tnvalues = 0;\n\tint\t\t\ti;\n\n\tvalues = (char **) palloc(sizeof(char *) * a->size);\n\n\tfor (i = 0; i < a->size; i++)\n\t{\n\t\tif (ptr->type == QI_VAL)\n\t\t{\n\t\t\tint\t\t\tlen = ptr->qoperand.length;\n\t\t\tchar\t   *val;\n\n\t\t\tval = palloc(len + 1);\n\t\t\tmemcpy(val, operand + ptr->qoperand.distance, len);\n\t\t\tval[len] = '\\0';\n\n\t\t\tvalues[nvalues++] = val;\n\t\t}\n\t\tptr++;\n\t}\n\n\t*nvalues_p = nvalues;\n\treturn values;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "1"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "0"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nDatum\ntsq_mcontains(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(0);\n\tTSQuery\t\tex = PG_GETARG_TSQUERY(1);\n\tchar\t  **query_values;\n\tint\t\t\tquery_nvalues;\n\tchar\t  **ex_values;\n\tint\t\t\tex_nvalues;\n\tbool\t\tresult = true;\n\n\t/* Extract the query terms into arrays */\n\tquery_values = collectTSQueryValues(query, &query_nvalues);\n\tex_values = collectTSQueryValues(ex, &ex_nvalues);\n\n\t/* Sort and remove duplicates from both arrays */\n\tqsort(query_values, query_nvalues, sizeof(char *), cmp_string);\n\tquery_nvalues = remove_duplicates(query_values, query_nvalues);\n\tqsort(ex_values, ex_nvalues, sizeof(char *), cmp_string);\n\tex_nvalues = remove_duplicates(ex_values, ex_nvalues);\n\n\tif (ex_nvalues > query_nvalues)\n\t\tresult = false;\n\telse\n\t{\n\t\tint\t\t\ti;\n\t\tint\t\t\tj = 0;\n\n\t\tfor (i = 0; i < ex_nvalues; i++)\n\t\t{\n\t\t\tfor (; j < query_nvalues; j++)\n\t\t\t{\n\t\t\t\tif (strcmp(ex_values[i], query_values[j]) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j == query_nvalues)\n\t\t\t{\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "remove_duplicates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
    "lines": "305-326",
    "snippet": "static int\nremove_duplicates(char **strings, int n)\n{\n\tif (n <= 1)\n\t\treturn n;\n\telse\n\t{\n\t\tint\t\t\ti;\n\t\tchar\t   *prev = strings[0];\n\t\tint\t\t\tnew_n = 1;\n\n\t\tfor (i = 1; i < n; i++)\n\t\t{\n\t\t\tif (strcmp(strings[i], prev) != 0)\n\t\t\t{\n\t\t\t\tstrings[new_n++] = strings[i];\n\t\t\t\tprev = strings[i];\n\t\t\t}\n\t\t}\n\t\treturn new_n;\n\t}\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "strings[i]",
            "prev"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int\nremove_duplicates(char **strings, int n)\n{\n\tif (n <= 1)\n\t\treturn n;\n\telse\n\t{\n\t\tint\t\t\ti;\n\t\tchar\t   *prev = strings[0];\n\t\tint\t\t\tnew_n = 1;\n\n\t\tfor (i = 1; i < n; i++)\n\t\t{\n\t\t\tif (strcmp(strings[i], prev) != 0)\n\t\t\t{\n\t\t\t\tstrings[new_n++] = strings[i];\n\t\t\t\tprev = strings[i];\n\t\t\t}\n\t\t}\n\t\treturn new_n;\n\t}\n}"
  },
  {
    "function_name": "cmp_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
    "lines": "296-303",
    "snippet": "static int\ncmp_string(const void *a, const void *b)\n{\n\tconst char *sa = *((const char **) a);\n\tconst char *sb = *((const char **) b);\n\n\treturn strcmp(sa, sb);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "sa",
            "sb"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int\ncmp_string(const void *a, const void *b)\n{\n\tconst char *sa = *((const char **) a);\n\tconst char *sb = *((const char **) b);\n\n\treturn strcmp(sa, sb);\n}"
  },
  {
    "function_name": "collectTSQueryValues",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
    "lines": "265-294",
    "snippet": "static char **\ncollectTSQueryValues(TSQuery a, int *nvalues_p)\n{\n\tQueryItem  *ptr = GETQUERY(a);\n\tchar\t   *operand = GETOPERAND(a);\n\tchar\t  **values;\n\tint\t\t\tnvalues = 0;\n\tint\t\t\ti;\n\n\tvalues = (char **) palloc(sizeof(char *) * a->size);\n\n\tfor (i = 0; i < a->size; i++)\n\t{\n\t\tif (ptr->type == QI_VAL)\n\t\t{\n\t\t\tint\t\t\tlen = ptr->qoperand.length;\n\t\t\tchar\t   *val;\n\n\t\t\tval = palloc(len + 1);\n\t\t\tmemcpy(val, operand + ptr->qoperand.distance, len);\n\t\t\tval[len] = '\\0';\n\n\t\t\tvalues[nvalues++] = val;\n\t\t}\n\t\tptr++;\n\t}\n\n\t*nvalues_p = nvalues;\n\treturn values;\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "val",
            "operand + ptr->qoperand.distance",
            "len"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len + 1"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "a"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "a"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic char **\ncollectTSQueryValues(TSQuery a, int *nvalues_p)\n{\n\tQueryItem  *ptr = GETQUERY(a);\n\tchar\t   *operand = GETOPERAND(a);\n\tchar\t  **values;\n\tint\t\t\tnvalues = 0;\n\tint\t\t\ti;\n\n\tvalues = (char **) palloc(sizeof(char *) * a->size);\n\n\tfor (i = 0; i < a->size; i++)\n\t{\n\t\tif (ptr->type == QI_VAL)\n\t\t{\n\t\t\tint\t\t\tlen = ptr->qoperand.length;\n\t\t\tchar\t   *val;\n\n\t\t\tval = palloc(len + 1);\n\t\t\tmemcpy(val, operand + ptr->qoperand.distance, len);\n\t\t\tval[len] = '\\0';\n\n\t\t\tvalues[nvalues++] = val;\n\t\t}\n\t\tptr++;\n\t}\n\n\t*nvalues_p = nvalues;\n\treturn values;\n}"
  },
  {
    "function_name": "makeTSQuerySign",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
    "lines": "248-263",
    "snippet": "TSQuerySign\nmakeTSQuerySign(TSQuery a)\n{\n\tint\t\t\ti;\n\tQueryItem  *ptr = GETQUERY(a);\n\tTSQuerySign sign = 0;\n\n\tfor (i = 0; i < a->size; i++)\n\t{\n\t\tif (ptr->type == QI_VAL)\n\t\t\tsign |= ((TSQuerySign) 1) << (((unsigned int) ptr->qoperand.valcrc) % TSQS_SIGLEN);\n\t\tptr++;\n\t}\n\n\treturn sign;\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "a"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nTSQuerySign\nmakeTSQuerySign(TSQuery a)\n{\n\tint\t\t\ti;\n\tQueryItem  *ptr = GETQUERY(a);\n\tTSQuerySign sign = 0;\n\n\tfor (i = 0; i < a->size; i++)\n\t{\n\t\tif (ptr->type == QI_VAL)\n\t\t\tsign |= ((TSQuerySign) 1) << (((unsigned int) ptr->qoperand.valcrc) % TSQS_SIGLEN);\n\t\tptr++;\n\t}\n\n\treturn sign;\n}"
  },
  {
    "function_name": "tsquery_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
    "lines": "213-224",
    "snippet": "Datum\ntsquery_cmp(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\ta = PG_GETARG_TSQUERY_COPY(0);\n\tTSQuery\t\tb = PG_GETARG_TSQUERY_COPY(1);\n\tint\t\t\tres = CompareTSQ(a, b);\n\n\tPG_FREE_IF_COPY(a, 0);\n\tPG_FREE_IF_COPY(b, 1);\n\n\tPG_RETURN_INT32(res);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "res"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "b",
            "1"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "a",
            "0"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CompareTSQ",
          "args": [
            "a",
            "b"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "CompareTSQ",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
          "lines": "187-211",
          "snippet": "static int\nCompareTSQ(TSQuery a, TSQuery b)\n{\n\tif (a->size != b->size)\n\t{\n\t\treturn (a->size < b->size) ? -1 : 1;\n\t}\n\telse if (VARSIZE(a) != VARSIZE(b))\n\t{\n\t\treturn (VARSIZE(a) < VARSIZE(b)) ? -1 : 1;\n\t}\n\telse if (a->size != 0)\n\t{\n\t\tQTNode\t   *an = QT2QTN(GETQUERY(a), GETOPERAND(a));\n\t\tQTNode\t   *bn = QT2QTN(GETQUERY(b), GETOPERAND(b));\n\t\tint\t\t\tres = QTNodeCompare(an, bn);\n\n\t\tQTNFree(an);\n\t\tQTNFree(bn);\n\n\t\treturn res;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int\nCompareTSQ(TSQuery a, TSQuery b)\n{\n\tif (a->size != b->size)\n\t{\n\t\treturn (a->size < b->size) ? -1 : 1;\n\t}\n\telse if (VARSIZE(a) != VARSIZE(b))\n\t{\n\t\treturn (VARSIZE(a) < VARSIZE(b)) ? -1 : 1;\n\t}\n\telse if (a->size != 0)\n\t{\n\t\tQTNode\t   *an = QT2QTN(GETQUERY(a), GETOPERAND(a));\n\t\tQTNode\t   *bn = QT2QTN(GETQUERY(b), GETOPERAND(b));\n\t\tint\t\t\tres = QTNodeCompare(an, bn);\n\n\t\tQTNFree(an);\n\t\tQTNFree(bn);\n\n\t\treturn res;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY_COPY",
          "args": [
            "1"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY_COPY",
          "args": [
            "0"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nDatum\ntsquery_cmp(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\ta = PG_GETARG_TSQUERY_COPY(0);\n\tTSQuery\t\tb = PG_GETARG_TSQUERY_COPY(1);\n\tint\t\t\tres = CompareTSQ(a, b);\n\n\tPG_FREE_IF_COPY(a, 0);\n\tPG_FREE_IF_COPY(b, 1);\n\n\tPG_RETURN_INT32(res);\n}"
  },
  {
    "function_name": "CompareTSQ",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
    "lines": "187-211",
    "snippet": "static int\nCompareTSQ(TSQuery a, TSQuery b)\n{\n\tif (a->size != b->size)\n\t{\n\t\treturn (a->size < b->size) ? -1 : 1;\n\t}\n\telse if (VARSIZE(a) != VARSIZE(b))\n\t{\n\t\treturn (VARSIZE(a) < VARSIZE(b)) ? -1 : 1;\n\t}\n\telse if (a->size != 0)\n\t{\n\t\tQTNode\t   *an = QT2QTN(GETQUERY(a), GETOPERAND(a));\n\t\tQTNode\t   *bn = QT2QTN(GETQUERY(b), GETOPERAND(b));\n\t\tint\t\t\tres = QTNodeCompare(an, bn);\n\n\t\tQTNFree(an);\n\t\tQTNFree(bn);\n\n\t\treturn res;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QTNFree",
          "args": [
            "bn"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "QTNFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "62-88",
          "snippet": "void\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTNodeCompare",
          "args": [
            "an",
            "bn"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "QTNodeCompare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "95-146",
          "snippet": "int\nQTNodeCompare(QTNode *an, QTNode *bn)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (an->valnode->type != bn->valnode->type)\n\t\treturn (an->valnode->type > bn->valnode->type) ? -1 : 1;\n\n\tif (an->valnode->type == QI_OPR)\n\t{\n\t\tQueryOperator *ao = &an->valnode->qoperator;\n\t\tQueryOperator *bo = &bn->valnode->qoperator;\n\n\t\tif (ao->oper != bo->oper)\n\t\t\treturn (ao->oper > bo->oper) ? -1 : 1;\n\n\t\tif (an->nchild != bn->nchild)\n\t\t\treturn (an->nchild > bn->nchild) ? -1 : 1;\n\n\t\t{\n\t\t\tint\t\t\ti,\n\t\t\t\t\t\tres;\n\n\t\t\tfor (i = 0; i < an->nchild; i++)\n\t\t\t\tif ((res = QTNodeCompare(an->child[i], bn->child[i])) != 0)\n\t\t\t\t\treturn res;\n\t\t}\n\n\t\tif (ao->oper == OP_PHRASE && ao->distance != bo->distance)\n\t\t\treturn (ao->distance > bo->distance) ? -1 : 1;\n\n\t\treturn 0;\n\t}\n\telse if (an->valnode->type == QI_VAL)\n\t{\n\t\tQueryOperand *ao = &an->valnode->qoperand;\n\t\tQueryOperand *bo = &bn->valnode->qoperand;\n\n\t\tif (ao->valcrc != bo->valcrc)\n\t\t{\n\t\t\treturn (ao->valcrc > bo->valcrc) ? -1 : 1;\n\t\t}\n\n\t\treturn tsCompareString(an->word, ao->length, bn->word, bo->length, false);\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"unrecognized QueryItem type: %d\", an->valnode->type);\n\t\treturn 0;\t\t\t\t/* keep compiler quiet */\n\t}\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nint\nQTNodeCompare(QTNode *an, QTNode *bn)\n{\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (an->valnode->type != bn->valnode->type)\n\t\treturn (an->valnode->type > bn->valnode->type) ? -1 : 1;\n\n\tif (an->valnode->type == QI_OPR)\n\t{\n\t\tQueryOperator *ao = &an->valnode->qoperator;\n\t\tQueryOperator *bo = &bn->valnode->qoperator;\n\n\t\tif (ao->oper != bo->oper)\n\t\t\treturn (ao->oper > bo->oper) ? -1 : 1;\n\n\t\tif (an->nchild != bn->nchild)\n\t\t\treturn (an->nchild > bn->nchild) ? -1 : 1;\n\n\t\t{\n\t\t\tint\t\t\ti,\n\t\t\t\t\t\tres;\n\n\t\t\tfor (i = 0; i < an->nchild; i++)\n\t\t\t\tif ((res = QTNodeCompare(an->child[i], bn->child[i])) != 0)\n\t\t\t\t\treturn res;\n\t\t}\n\n\t\tif (ao->oper == OP_PHRASE && ao->distance != bo->distance)\n\t\t\treturn (ao->distance > bo->distance) ? -1 : 1;\n\n\t\treturn 0;\n\t}\n\telse if (an->valnode->type == QI_VAL)\n\t{\n\t\tQueryOperand *ao = &an->valnode->qoperand;\n\t\tQueryOperand *bo = &bn->valnode->qoperand;\n\n\t\tif (ao->valcrc != bo->valcrc)\n\t\t{\n\t\t\treturn (ao->valcrc > bo->valcrc) ? -1 : 1;\n\t\t}\n\n\t\treturn tsCompareString(an->word, ao->length, bn->word, bo->length, false);\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"unrecognized QueryItem type: %d\", an->valnode->type);\n\t\treturn 0;\t\t\t\t/* keep compiler quiet */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "QT2QTN",
          "args": [
            "GETQUERY(b)",
            "GETOPERAND(b)"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "QT2QTN",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "23-54",
          "snippet": "QTNode *\nQT2QTN(QueryItem *in, char *operand)\n{\n\tQTNode\t   *node = (QTNode *) palloc0(sizeof(QTNode));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\t\tnode->child[0] = QT2QTN(in + 1, operand);\n\t\tnode->sign = node->child[0]->sign;\n\t\tif (in->qoperator.oper == OP_NOT)\n\t\t\tnode->nchild = 1;\n\t\telse\n\t\t{\n\t\t\tnode->nchild = 2;\n\t\t\tnode->child[1] = QT2QTN(in + in->qoperator.left, operand);\n\t\t\tnode->sign |= node->child[1]->sign;\n\t\t}\n\t}\n\telse if (operand)\n\t{\n\t\tnode->word = operand + in->qoperand.distance;\n\t\tnode->sign = ((uint32) 1) << (((unsigned int) in->qoperand.valcrc) % 32);\n\t}\n\n\treturn node;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nQTNode *\nQT2QTN(QueryItem *in, char *operand)\n{\n\tQTNode\t   *node = (QTNode *) palloc0(sizeof(QTNode));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\t\tnode->child[0] = QT2QTN(in + 1, operand);\n\t\tnode->sign = node->child[0]->sign;\n\t\tif (in->qoperator.oper == OP_NOT)\n\t\t\tnode->nchild = 1;\n\t\telse\n\t\t{\n\t\t\tnode->nchild = 2;\n\t\t\tnode->child[1] = QT2QTN(in + in->qoperator.left, operand);\n\t\t\tnode->sign |= node->child[1]->sign;\n\t\t}\n\t}\n\telse if (operand)\n\t{\n\t\tnode->word = operand + in->qoperand.distance;\n\t\tnode->sign = ((uint32) 1) << (((unsigned int) in->qoperand.valcrc) % 32);\n\t}\n\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "b"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "b"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "a"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "a"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "b"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "a"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "b"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "a"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int\nCompareTSQ(TSQuery a, TSQuery b)\n{\n\tif (a->size != b->size)\n\t{\n\t\treturn (a->size < b->size) ? -1 : 1;\n\t}\n\telse if (VARSIZE(a) != VARSIZE(b))\n\t{\n\t\treturn (VARSIZE(a) < VARSIZE(b)) ? -1 : 1;\n\t}\n\telse if (a->size != 0)\n\t{\n\t\tQTNode\t   *an = QT2QTN(GETQUERY(a), GETOPERAND(a));\n\t\tQTNode\t   *bn = QT2QTN(GETQUERY(b), GETOPERAND(b));\n\t\tint\t\t\tres = QTNodeCompare(an, bn);\n\n\t\tQTNFree(an);\n\t\tQTNFree(bn);\n\n\t\treturn res;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tsquery_not",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
    "lines": "157-185",
    "snippet": "Datum\ntsquery_not(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\ta = PG_GETARG_TSQUERY_COPY(0);\n\tQTNode\t   *res;\n\tTSQuery\t\tquery;\n\n\tif (a->size == 0)\n\t\tPG_RETURN_POINTER(a);\n\n\tres = (QTNode *) palloc0(sizeof(QTNode));\n\n\tres->flags |= QTN_NEEDFREE;\n\n\tres->valnode = (QueryItem *) palloc0(sizeof(QueryItem));\n\tres->valnode->type = QI_OPR;\n\tres->valnode->qoperator.oper = OP_NOT;\n\n\tres->child = (QTNode **) palloc0(sizeof(QTNode *));\n\tres->child[0] = QT2QTN(GETQUERY(a), GETOPERAND(a));\n\tres->nchild = 1;\n\n\tquery = QTN2QT(res);\n\n\tQTNFree(res);\n\tPG_FREE_IF_COPY(a, 0);\n\n\tPG_RETURN_POINTER(query);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "query"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "a",
            "0"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QTNFree",
          "args": [
            "res"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "QTNFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "62-88",
          "snippet": "void\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTN2QT",
          "args": [
            "res"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "QTN2QT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "361-387",
          "snippet": "TSQuery\nQTN2QT(QTNode *in)\n{\n\tTSQuery\t\tout;\n\tint\t\t\tlen;\n\tint\t\t\tsumlen = 0,\n\t\t\t\tnnode = 0;\n\tQTN2QTState state;\n\n\tcntsize(in, &sumlen, &nnode);\n\n\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tlen = COMPUTESIZE(nnode, sumlen);\n\n\tout = (TSQuery) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = nnode;\n\n\tstate.curitem = GETQUERY(out);\n\tstate.operand = state.curoperand = GETOPERAND(out);\n\n\tfillQT(&state, in);\n\treturn out;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nTSQuery\nQTN2QT(QTNode *in)\n{\n\tTSQuery\t\tout;\n\tint\t\t\tlen;\n\tint\t\t\tsumlen = 0,\n\t\t\t\tnnode = 0;\n\tQTN2QTState state;\n\n\tcntsize(in, &sumlen, &nnode);\n\n\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tlen = COMPUTESIZE(nnode, sumlen);\n\n\tout = (TSQuery) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = nnode;\n\n\tstate.curitem = GETQUERY(out);\n\tstate.operand = state.curoperand = GETOPERAND(out);\n\n\tfillQT(&state, in);\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QT2QTN",
          "args": [
            "GETQUERY(a)",
            "GETOPERAND(a)"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "QT2QTN",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "23-54",
          "snippet": "QTNode *\nQT2QTN(QueryItem *in, char *operand)\n{\n\tQTNode\t   *node = (QTNode *) palloc0(sizeof(QTNode));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\t\tnode->child[0] = QT2QTN(in + 1, operand);\n\t\tnode->sign = node->child[0]->sign;\n\t\tif (in->qoperator.oper == OP_NOT)\n\t\t\tnode->nchild = 1;\n\t\telse\n\t\t{\n\t\t\tnode->nchild = 2;\n\t\t\tnode->child[1] = QT2QTN(in + in->qoperator.left, operand);\n\t\t\tnode->sign |= node->child[1]->sign;\n\t\t}\n\t}\n\telse if (operand)\n\t{\n\t\tnode->word = operand + in->qoperand.distance;\n\t\tnode->sign = ((uint32) 1) << (((unsigned int) in->qoperand.valcrc) % 32);\n\t}\n\n\treturn node;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nQTNode *\nQT2QTN(QueryItem *in, char *operand)\n{\n\tQTNode\t   *node = (QTNode *) palloc0(sizeof(QTNode));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\t\tnode->child[0] = QT2QTN(in + 1, operand);\n\t\tnode->sign = node->child[0]->sign;\n\t\tif (in->qoperator.oper == OP_NOT)\n\t\t\tnode->nchild = 1;\n\t\telse\n\t\t{\n\t\t\tnode->nchild = 2;\n\t\t\tnode->child[1] = QT2QTN(in + in->qoperator.left, operand);\n\t\t\tnode->sign |= node->child[1]->sign;\n\t\t}\n\t}\n\telse if (operand)\n\t{\n\t\tnode->word = operand + in->qoperand.distance;\n\t\tnode->sign = ((uint32) 1) << (((unsigned int) in->qoperand.valcrc) % 32);\n\t}\n\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "a"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "a"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(QTNode *)"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "a"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY_COPY",
          "args": [
            "0"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nDatum\ntsquery_not(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\ta = PG_GETARG_TSQUERY_COPY(0);\n\tQTNode\t   *res;\n\tTSQuery\t\tquery;\n\n\tif (a->size == 0)\n\t\tPG_RETURN_POINTER(a);\n\n\tres = (QTNode *) palloc0(sizeof(QTNode));\n\n\tres->flags |= QTN_NEEDFREE;\n\n\tres->valnode = (QueryItem *) palloc0(sizeof(QueryItem));\n\tres->valnode->type = QI_OPR;\n\tres->valnode->qoperator.oper = OP_NOT;\n\n\tres->child = (QTNode **) palloc0(sizeof(QTNode *));\n\tres->child[0] = QT2QTN(GETQUERY(a), GETOPERAND(a));\n\tres->nchild = 1;\n\n\tquery = QTN2QT(res);\n\n\tQTNFree(res);\n\tPG_FREE_IF_COPY(a, 0);\n\n\tPG_RETURN_POINTER(query);\n}"
  },
  {
    "function_name": "tsquery_phrase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
    "lines": "147-155",
    "snippet": "Datum\ntsquery_phrase(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_POINTER(DirectFunctionCall3(\n\t\t\t\t\t\t\t\t\t\t  tsquery_phrase_distance,\n\t\t\t\t\t\t\t\t\t\t  PG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\t\t  PG_GETARG_DATUM(1),\n\t\t\t\t\t\t\t\t\t\t  Int32GetDatum(1)));\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "DirectFunctionCall3(\n\t\t\t\t\t\t\t\t\t\t  tsquery_phrase_distance,\n\t\t\t\t\t\t\t\t\t\t  PG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\t\t  PG_GETARG_DATUM(1),\n\t\t\t\t\t\t\t\t\t\t  Int32GetDatum(1))"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall3",
          "args": [
            "tsquery_phrase_distance",
            "PG_GETARG_DATUM(0)",
            "PG_GETARG_DATUM(1)",
            "Int32GetDatum(1)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "1"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nDatum\ntsquery_phrase(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_POINTER(DirectFunctionCall3(\n\t\t\t\t\t\t\t\t\t\t  tsquery_phrase_distance,\n\t\t\t\t\t\t\t\t\t\t  PG_GETARG_DATUM(0),\n\t\t\t\t\t\t\t\t\t\t  PG_GETARG_DATUM(1),\n\t\t\t\t\t\t\t\t\t\t  Int32GetDatum(1)));\n}"
  },
  {
    "function_name": "tsquery_phrase_distance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
    "lines": "111-145",
    "snippet": "Datum\ntsquery_phrase_distance(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\ta = PG_GETARG_TSQUERY_COPY(0);\n\tTSQuery\t\tb = PG_GETARG_TSQUERY_COPY(1);\n\tQTNode\t   *res;\n\tTSQuery\t\tquery;\n\tint32\t\tdistance = PG_GETARG_INT32(2);\n\n\tif (distance < 0 || distance > MAXENTRYPOS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"distance in phrase operator should be non-negative and less than %d\",\n\t\t\t\t\t\tMAXENTRYPOS)));\n\tif (a->size == 0)\n\t{\n\t\tPG_FREE_IF_COPY(a, 1);\n\t\tPG_RETURN_POINTER(b);\n\t}\n\telse if (b->size == 0)\n\t{\n\t\tPG_FREE_IF_COPY(b, 1);\n\t\tPG_RETURN_POINTER(a);\n\t}\n\n\tres = join_tsqueries(a, b, OP_PHRASE, (uint16) distance);\n\n\tquery = QTN2QT(res);\n\n\tQTNFree(res);\n\tPG_FREE_IF_COPY(a, 0);\n\tPG_FREE_IF_COPY(b, 1);\n\n\tPG_RETURN_TSQUERY(query);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TSQUERY",
          "args": [
            "query"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "b",
            "1"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "a",
            "0"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QTNFree",
          "args": [
            "res"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "QTNFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "62-88",
          "snippet": "void\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTN2QT",
          "args": [
            "res"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "QTN2QT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "361-387",
          "snippet": "TSQuery\nQTN2QT(QTNode *in)\n{\n\tTSQuery\t\tout;\n\tint\t\t\tlen;\n\tint\t\t\tsumlen = 0,\n\t\t\t\tnnode = 0;\n\tQTN2QTState state;\n\n\tcntsize(in, &sumlen, &nnode);\n\n\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tlen = COMPUTESIZE(nnode, sumlen);\n\n\tout = (TSQuery) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = nnode;\n\n\tstate.curitem = GETQUERY(out);\n\tstate.operand = state.curoperand = GETOPERAND(out);\n\n\tfillQT(&state, in);\n\treturn out;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nTSQuery\nQTN2QT(QTNode *in)\n{\n\tTSQuery\t\tout;\n\tint\t\t\tlen;\n\tint\t\t\tsumlen = 0,\n\t\t\t\tnnode = 0;\n\tQTN2QTState state;\n\n\tcntsize(in, &sumlen, &nnode);\n\n\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tlen = COMPUTESIZE(nnode, sumlen);\n\n\tout = (TSQuery) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = nnode;\n\n\tstate.curitem = GETQUERY(out);\n\tstate.operand = state.curoperand = GETOPERAND(out);\n\n\tfillQT(&state, in);\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "join_tsqueries",
          "args": [
            "a",
            "b",
            "OP_PHRASE",
            "(uint16) distance"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "join_tsqueries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
          "lines": "30-49",
          "snippet": "static QTNode *\njoin_tsqueries(TSQuery a, TSQuery b, int8 operator, uint16 distance)\n{\n\tQTNode\t   *res = (QTNode *) palloc0(sizeof(QTNode));\n\n\tres->flags |= QTN_NEEDFREE;\n\n\tres->valnode = (QueryItem *) palloc0(sizeof(QueryItem));\n\tres->valnode->type = QI_OPR;\n\tres->valnode->qoperator.oper = operator;\n\tif (operator == OP_PHRASE)\n\t\tres->valnode->qoperator.distance = distance;\n\n\tres->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\tres->child[0] = QT2QTN(GETQUERY(b), GETOPERAND(b));\n\tres->child[1] = QT2QTN(GETQUERY(a), GETOPERAND(a));\n\tres->nchild = 2;\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic QTNode *\njoin_tsqueries(TSQuery a, TSQuery b, int8 operator, uint16 distance)\n{\n\tQTNode\t   *res = (QTNode *) palloc0(sizeof(QTNode));\n\n\tres->flags |= QTN_NEEDFREE;\n\n\tres->valnode = (QueryItem *) palloc0(sizeof(QueryItem));\n\tres->valnode->type = QI_OPR;\n\tres->valnode->qoperator.oper = operator;\n\tif (operator == OP_PHRASE)\n\t\tres->valnode->qoperator.distance = distance;\n\n\tres->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\tres->child[0] = QT2QTN(GETQUERY(b), GETOPERAND(b));\n\tres->child[1] = QT2QTN(GETQUERY(a), GETOPERAND(a));\n\tres->nchild = 2;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "a"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "b",
            "1"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "b"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "a",
            "1"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"distance in phrase operator should be non-negative and less than %d\",\n\t\t\t\t\t\tMAXENTRYPOS))"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"distance in phrase operator should be non-negative and less than %d\"",
            "MAXENTRYPOS"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "2"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY_COPY",
          "args": [
            "1"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY_COPY",
          "args": [
            "0"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nDatum\ntsquery_phrase_distance(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\ta = PG_GETARG_TSQUERY_COPY(0);\n\tTSQuery\t\tb = PG_GETARG_TSQUERY_COPY(1);\n\tQTNode\t   *res;\n\tTSQuery\t\tquery;\n\tint32\t\tdistance = PG_GETARG_INT32(2);\n\n\tif (distance < 0 || distance > MAXENTRYPOS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"distance in phrase operator should be non-negative and less than %d\",\n\t\t\t\t\t\tMAXENTRYPOS)));\n\tif (a->size == 0)\n\t{\n\t\tPG_FREE_IF_COPY(a, 1);\n\t\tPG_RETURN_POINTER(b);\n\t}\n\telse if (b->size == 0)\n\t{\n\t\tPG_FREE_IF_COPY(b, 1);\n\t\tPG_RETURN_POINTER(a);\n\t}\n\n\tres = join_tsqueries(a, b, OP_PHRASE, (uint16) distance);\n\n\tquery = QTN2QT(res);\n\n\tQTNFree(res);\n\tPG_FREE_IF_COPY(a, 0);\n\tPG_FREE_IF_COPY(b, 1);\n\n\tPG_RETURN_TSQUERY(query);\n}"
  },
  {
    "function_name": "tsquery_or",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
    "lines": "81-109",
    "snippet": "Datum\ntsquery_or(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\ta = PG_GETARG_TSQUERY_COPY(0);\n\tTSQuery\t\tb = PG_GETARG_TSQUERY_COPY(1);\n\tQTNode\t   *res;\n\tTSQuery\t\tquery;\n\n\tif (a->size == 0)\n\t{\n\t\tPG_FREE_IF_COPY(a, 1);\n\t\tPG_RETURN_POINTER(b);\n\t}\n\telse if (b->size == 0)\n\t{\n\t\tPG_FREE_IF_COPY(b, 1);\n\t\tPG_RETURN_POINTER(a);\n\t}\n\n\tres = join_tsqueries(a, b, OP_OR, 0);\n\n\tquery = QTN2QT(res);\n\n\tQTNFree(res);\n\tPG_FREE_IF_COPY(a, 0);\n\tPG_FREE_IF_COPY(b, 1);\n\n\tPG_RETURN_TSQUERY(query);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TSQUERY",
          "args": [
            "query"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "b",
            "1"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "a",
            "0"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QTNFree",
          "args": [
            "res"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "QTNFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "62-88",
          "snippet": "void\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTN2QT",
          "args": [
            "res"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "QTN2QT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "361-387",
          "snippet": "TSQuery\nQTN2QT(QTNode *in)\n{\n\tTSQuery\t\tout;\n\tint\t\t\tlen;\n\tint\t\t\tsumlen = 0,\n\t\t\t\tnnode = 0;\n\tQTN2QTState state;\n\n\tcntsize(in, &sumlen, &nnode);\n\n\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tlen = COMPUTESIZE(nnode, sumlen);\n\n\tout = (TSQuery) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = nnode;\n\n\tstate.curitem = GETQUERY(out);\n\tstate.operand = state.curoperand = GETOPERAND(out);\n\n\tfillQT(&state, in);\n\treturn out;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nTSQuery\nQTN2QT(QTNode *in)\n{\n\tTSQuery\t\tout;\n\tint\t\t\tlen;\n\tint\t\t\tsumlen = 0,\n\t\t\t\tnnode = 0;\n\tQTN2QTState state;\n\n\tcntsize(in, &sumlen, &nnode);\n\n\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tlen = COMPUTESIZE(nnode, sumlen);\n\n\tout = (TSQuery) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = nnode;\n\n\tstate.curitem = GETQUERY(out);\n\tstate.operand = state.curoperand = GETOPERAND(out);\n\n\tfillQT(&state, in);\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "join_tsqueries",
          "args": [
            "a",
            "b",
            "OP_OR",
            "0"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "join_tsqueries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
          "lines": "30-49",
          "snippet": "static QTNode *\njoin_tsqueries(TSQuery a, TSQuery b, int8 operator, uint16 distance)\n{\n\tQTNode\t   *res = (QTNode *) palloc0(sizeof(QTNode));\n\n\tres->flags |= QTN_NEEDFREE;\n\n\tres->valnode = (QueryItem *) palloc0(sizeof(QueryItem));\n\tres->valnode->type = QI_OPR;\n\tres->valnode->qoperator.oper = operator;\n\tif (operator == OP_PHRASE)\n\t\tres->valnode->qoperator.distance = distance;\n\n\tres->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\tres->child[0] = QT2QTN(GETQUERY(b), GETOPERAND(b));\n\tres->child[1] = QT2QTN(GETQUERY(a), GETOPERAND(a));\n\tres->nchild = 2;\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic QTNode *\njoin_tsqueries(TSQuery a, TSQuery b, int8 operator, uint16 distance)\n{\n\tQTNode\t   *res = (QTNode *) palloc0(sizeof(QTNode));\n\n\tres->flags |= QTN_NEEDFREE;\n\n\tres->valnode = (QueryItem *) palloc0(sizeof(QueryItem));\n\tres->valnode->type = QI_OPR;\n\tres->valnode->qoperator.oper = operator;\n\tif (operator == OP_PHRASE)\n\t\tres->valnode->qoperator.distance = distance;\n\n\tres->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\tres->child[0] = QT2QTN(GETQUERY(b), GETOPERAND(b));\n\tres->child[1] = QT2QTN(GETQUERY(a), GETOPERAND(a));\n\tres->nchild = 2;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "a"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "b",
            "1"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "b"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "a",
            "1"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY_COPY",
          "args": [
            "1"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY_COPY",
          "args": [
            "0"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nDatum\ntsquery_or(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\ta = PG_GETARG_TSQUERY_COPY(0);\n\tTSQuery\t\tb = PG_GETARG_TSQUERY_COPY(1);\n\tQTNode\t   *res;\n\tTSQuery\t\tquery;\n\n\tif (a->size == 0)\n\t{\n\t\tPG_FREE_IF_COPY(a, 1);\n\t\tPG_RETURN_POINTER(b);\n\t}\n\telse if (b->size == 0)\n\t{\n\t\tPG_FREE_IF_COPY(b, 1);\n\t\tPG_RETURN_POINTER(a);\n\t}\n\n\tres = join_tsqueries(a, b, OP_OR, 0);\n\n\tquery = QTN2QT(res);\n\n\tQTNFree(res);\n\tPG_FREE_IF_COPY(a, 0);\n\tPG_FREE_IF_COPY(b, 1);\n\n\tPG_RETURN_TSQUERY(query);\n}"
  },
  {
    "function_name": "tsquery_and",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
    "lines": "51-79",
    "snippet": "Datum\ntsquery_and(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\ta = PG_GETARG_TSQUERY_COPY(0);\n\tTSQuery\t\tb = PG_GETARG_TSQUERY_COPY(1);\n\tQTNode\t   *res;\n\tTSQuery\t\tquery;\n\n\tif (a->size == 0)\n\t{\n\t\tPG_FREE_IF_COPY(a, 1);\n\t\tPG_RETURN_POINTER(b);\n\t}\n\telse if (b->size == 0)\n\t{\n\t\tPG_FREE_IF_COPY(b, 1);\n\t\tPG_RETURN_POINTER(a);\n\t}\n\n\tres = join_tsqueries(a, b, OP_AND, 0);\n\n\tquery = QTN2QT(res);\n\n\tQTNFree(res);\n\tPG_FREE_IF_COPY(a, 0);\n\tPG_FREE_IF_COPY(b, 1);\n\n\tPG_RETURN_TSQUERY(query);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TSQUERY",
          "args": [
            "query"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "b",
            "1"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "a",
            "0"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QTNFree",
          "args": [
            "res"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "QTNFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "62-88",
          "snippet": "void\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nvoid\nQTNFree(QTNode *in)\n{\n\tif (!in)\n\t\treturn;\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tif (in->valnode->type == QI_VAL && in->word && (in->flags & QTN_WORDFREE) != 0)\n\t\tpfree(in->word);\n\n\tif (in->valnode->type == QI_OPR)\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < in->nchild; i++)\n\t\t\tQTNFree(in->child[i]);\n\t}\n\tif (in->child)\n\t\tpfree(in->child);\n\n\tif (in->flags & QTN_NEEDFREE)\n\t\tpfree(in->valnode);\n\n\tpfree(in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QTN2QT",
          "args": [
            "res"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "QTN2QT",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "361-387",
          "snippet": "TSQuery\nQTN2QT(QTNode *in)\n{\n\tTSQuery\t\tout;\n\tint\t\t\tlen;\n\tint\t\t\tsumlen = 0,\n\t\t\t\tnnode = 0;\n\tQTN2QTState state;\n\n\tcntsize(in, &sumlen, &nnode);\n\n\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tlen = COMPUTESIZE(nnode, sumlen);\n\n\tout = (TSQuery) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = nnode;\n\n\tstate.curitem = GETQUERY(out);\n\tstate.operand = state.curoperand = GETOPERAND(out);\n\n\tfillQT(&state, in);\n\treturn out;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nTSQuery\nQTN2QT(QTNode *in)\n{\n\tTSQuery\t\tout;\n\tint\t\t\tlen;\n\tint\t\t\tsumlen = 0,\n\t\t\t\tnnode = 0;\n\tQTN2QTState state;\n\n\tcntsize(in, &sumlen, &nnode);\n\n\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tlen = COMPUTESIZE(nnode, sumlen);\n\n\tout = (TSQuery) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = nnode;\n\n\tstate.curitem = GETQUERY(out);\n\tstate.operand = state.curoperand = GETOPERAND(out);\n\n\tfillQT(&state, in);\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "join_tsqueries",
          "args": [
            "a",
            "b",
            "OP_AND",
            "0"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "join_tsqueries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
          "lines": "30-49",
          "snippet": "static QTNode *\njoin_tsqueries(TSQuery a, TSQuery b, int8 operator, uint16 distance)\n{\n\tQTNode\t   *res = (QTNode *) palloc0(sizeof(QTNode));\n\n\tres->flags |= QTN_NEEDFREE;\n\n\tres->valnode = (QueryItem *) palloc0(sizeof(QueryItem));\n\tres->valnode->type = QI_OPR;\n\tres->valnode->qoperator.oper = operator;\n\tif (operator == OP_PHRASE)\n\t\tres->valnode->qoperator.distance = distance;\n\n\tres->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\tres->child[0] = QT2QTN(GETQUERY(b), GETOPERAND(b));\n\tres->child[1] = QT2QTN(GETQUERY(a), GETOPERAND(a));\n\tres->nchild = 2;\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic QTNode *\njoin_tsqueries(TSQuery a, TSQuery b, int8 operator, uint16 distance)\n{\n\tQTNode\t   *res = (QTNode *) palloc0(sizeof(QTNode));\n\n\tres->flags |= QTN_NEEDFREE;\n\n\tres->valnode = (QueryItem *) palloc0(sizeof(QueryItem));\n\tres->valnode->type = QI_OPR;\n\tres->valnode->qoperator.oper = operator;\n\tif (operator == OP_PHRASE)\n\t\tres->valnode->qoperator.distance = distance;\n\n\tres->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\tres->child[0] = QT2QTN(GETQUERY(b), GETOPERAND(b));\n\tres->child[1] = QT2QTN(GETQUERY(a), GETOPERAND(a));\n\tres->nchild = 2;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "a"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "b",
            "1"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "b"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "a",
            "1"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY_COPY",
          "args": [
            "1"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY_COPY",
          "args": [
            "0"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nDatum\ntsquery_and(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\ta = PG_GETARG_TSQUERY_COPY(0);\n\tTSQuery\t\tb = PG_GETARG_TSQUERY_COPY(1);\n\tQTNode\t   *res;\n\tTSQuery\t\tquery;\n\n\tif (a->size == 0)\n\t{\n\t\tPG_FREE_IF_COPY(a, 1);\n\t\tPG_RETURN_POINTER(b);\n\t}\n\telse if (b->size == 0)\n\t{\n\t\tPG_FREE_IF_COPY(b, 1);\n\t\tPG_RETURN_POINTER(a);\n\t}\n\n\tres = join_tsqueries(a, b, OP_AND, 0);\n\n\tquery = QTN2QT(res);\n\n\tQTNFree(res);\n\tPG_FREE_IF_COPY(a, 0);\n\tPG_FREE_IF_COPY(b, 1);\n\n\tPG_RETURN_TSQUERY(query);\n}"
  },
  {
    "function_name": "join_tsqueries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
    "lines": "30-49",
    "snippet": "static QTNode *\njoin_tsqueries(TSQuery a, TSQuery b, int8 operator, uint16 distance)\n{\n\tQTNode\t   *res = (QTNode *) palloc0(sizeof(QTNode));\n\n\tres->flags |= QTN_NEEDFREE;\n\n\tres->valnode = (QueryItem *) palloc0(sizeof(QueryItem));\n\tres->valnode->type = QI_OPR;\n\tres->valnode->qoperator.oper = operator;\n\tif (operator == OP_PHRASE)\n\t\tres->valnode->qoperator.distance = distance;\n\n\tres->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\tres->child[0] = QT2QTN(GETQUERY(b), GETOPERAND(b));\n\tres->child[1] = QT2QTN(GETQUERY(a), GETOPERAND(a));\n\tres->nchild = 2;\n\n\treturn res;\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "QT2QTN",
          "args": [
            "GETQUERY(a)",
            "GETOPERAND(a)"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "QT2QTN",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_util.c",
          "lines": "23-54",
          "snippet": "QTNode *\nQT2QTN(QueryItem *in, char *operand)\n{\n\tQTNode\t   *node = (QTNode *) palloc0(sizeof(QTNode));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\t\tnode->child[0] = QT2QTN(in + 1, operand);\n\t\tnode->sign = node->child[0]->sign;\n\t\tif (in->qoperator.oper == OP_NOT)\n\t\t\tnode->nchild = 1;\n\t\telse\n\t\t{\n\t\t\tnode->nchild = 2;\n\t\t\tnode->child[1] = QT2QTN(in + in->qoperator.left, operand);\n\t\t\tnode->sign |= node->child[1]->sign;\n\t\t}\n\t}\n\telse if (operand)\n\t{\n\t\tnode->word = operand + in->qoperand.distance;\n\t\tnode->sign = ((uint32) 1) << (((unsigned int) in->qoperand.valcrc) % 32);\n\t}\n\n\treturn node;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nQTNode *\nQT2QTN(QueryItem *in, char *operand)\n{\n\tQTNode\t   *node = (QTNode *) palloc0(sizeof(QTNode));\n\n\t/* since this function recurses, it could be driven to stack overflow. */\n\tcheck_stack_depth();\n\n\tnode->valnode = in;\n\n\tif (in->type == QI_OPR)\n\t{\n\t\tnode->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\t\tnode->child[0] = QT2QTN(in + 1, operand);\n\t\tnode->sign = node->child[0]->sign;\n\t\tif (in->qoperator.oper == OP_NOT)\n\t\t\tnode->nchild = 1;\n\t\telse\n\t\t{\n\t\t\tnode->nchild = 2;\n\t\t\tnode->child[1] = QT2QTN(in + in->qoperator.left, operand);\n\t\t\tnode->sign |= node->child[1]->sign;\n\t\t}\n\t}\n\telse if (operand)\n\t{\n\t\tnode->word = operand + in->qoperand.distance;\n\t\tnode->sign = ((uint32) 1) << (((unsigned int) in->qoperand.valcrc) % 32);\n\t}\n\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "a"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "a"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "b"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "b"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(QTNode *) * 2"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic QTNode *\njoin_tsqueries(TSQuery a, TSQuery b, int8 operator, uint16 distance)\n{\n\tQTNode\t   *res = (QTNode *) palloc0(sizeof(QTNode));\n\n\tres->flags |= QTN_NEEDFREE;\n\n\tres->valnode = (QueryItem *) palloc0(sizeof(QueryItem));\n\tres->valnode->type = QI_OPR;\n\tres->valnode->qoperator.oper = operator;\n\tif (operator == OP_PHRASE)\n\t\tres->valnode->qoperator.distance = distance;\n\n\tres->child = (QTNode **) palloc0(sizeof(QTNode *) * 2);\n\tres->child[0] = QT2QTN(GETQUERY(b), GETOPERAND(b));\n\tres->child[1] = QT2QTN(GETQUERY(a), GETOPERAND(a));\n\tres->nchild = 2;\n\n\treturn res;\n}"
  },
  {
    "function_name": "tsquery_numnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_op.c",
    "lines": "20-28",
    "snippet": "Datum\ntsquery_numnode(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(0);\n\tint\t\t\tnnode = query->size;\n\n\tPG_FREE_IF_COPY(query, 0);\n\tPG_RETURN_INT32(nnode);\n}",
    "includes": [
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "nnode"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "query",
            "0"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "0"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nDatum\ntsquery_numnode(PG_FUNCTION_ARGS)\n{\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(0);\n\tint\t\t\tnnode = query->size;\n\n\tPG_FREE_IF_COPY(query, 0);\n\tPG_RETURN_INT32(nnode);\n}"
  }
]