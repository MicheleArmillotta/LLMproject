[
  {
    "function_name": "CallSyscacheCallbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "1486-1503",
    "snippet": "void\nCallSyscacheCallbacks(int cacheid, uint32 hashvalue)\n{\n\tint\t\t\ti;\n\n\tif (cacheid < 0 || cacheid >= SysCacheSize)\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheid);\n\n\ti = syscache_callback_links[cacheid] - 1;\n\twhile (i >= 0)\n\t{\n\t\tstruct SYSCACHECALLBACK *ccitem = syscache_callback_list + i;\n\n\t\tAssert(ccitem->id == cacheid);\n\t\tccitem->function(ccitem->arg, cacheid, hashvalue);\n\t\ti = ccitem->link - 1;\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];",
      "static int16 syscache_callback_links[SysCacheSize];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ccitem->function",
          "args": [
            "ccitem->arg",
            "cacheid",
            "hashvalue"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "ccitem->id == cacheid"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid cache ID: %d\"",
            "cacheid"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];\nstatic int16 syscache_callback_links[SysCacheSize];\n\nvoid\nCallSyscacheCallbacks(int cacheid, uint32 hashvalue)\n{\n\tint\t\t\ti;\n\n\tif (cacheid < 0 || cacheid >= SysCacheSize)\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheid);\n\n\ti = syscache_callback_links[cacheid] - 1;\n\twhile (i >= 0)\n\t{\n\t\tstruct SYSCACHECALLBACK *ccitem = syscache_callback_list + i;\n\n\t\tAssert(ccitem->id == cacheid);\n\t\tccitem->function(ccitem->arg, cacheid, hashvalue);\n\t\ti = ccitem->link - 1;\n\t}\n}"
  },
  {
    "function_name": "CacheRegisterRelcacheCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "1467-1478",
    "snippet": "void\nCacheRegisterRelcacheCallback(RelcacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (relcache_callback_count >= MAX_RELCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of relcache_callback_list slots\");\n\n\trelcache_callback_list[relcache_callback_count].function = func;\n\trelcache_callback_list[relcache_callback_count].arg = arg;\n\n\t++relcache_callback_count;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_RELCACHE_CALLBACKS 10"
    ],
    "globals_used": [
      "static struct RELCACHECALLBACK\n{\n\tRelcacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\trelcache_callback_list[MAX_RELCACHE_CALLBACKS];",
      "static int\trelcache_callback_count = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"out of relcache_callback_list slots\""
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define MAX_RELCACHE_CALLBACKS 10\n\nstatic struct RELCACHECALLBACK\n{\n\tRelcacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\trelcache_callback_list[MAX_RELCACHE_CALLBACKS];\nstatic int\trelcache_callback_count = 0;\n\nvoid\nCacheRegisterRelcacheCallback(RelcacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (relcache_callback_count >= MAX_RELCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of relcache_callback_list slots\");\n\n\trelcache_callback_list[relcache_callback_count].function = func;\n\trelcache_callback_list[relcache_callback_count].arg = arg;\n\n\t++relcache_callback_count;\n}"
  },
  {
    "function_name": "CacheRegisterSyscacheCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "1425-1456",
    "snippet": "void\nCacheRegisterSyscacheCallback(int cacheid,\n\t\t\t\t\t\t\t  SyscacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (cacheid < 0 || cacheid >= SysCacheSize)\n\t\telog(FATAL, \"invalid cache ID: %d\", cacheid);\n\tif (syscache_callback_count >= MAX_SYSCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of syscache_callback_list slots\");\n\n\tif (syscache_callback_links[cacheid] == 0)\n\t{\n\t\t/* first callback for this cache */\n\t\tsyscache_callback_links[cacheid] = syscache_callback_count + 1;\n\t}\n\telse\n\t{\n\t\t/* add to end of chain, so that older callbacks are called first */\n\t\tint\t\t\ti = syscache_callback_links[cacheid] - 1;\n\n\t\twhile (syscache_callback_list[i].link > 0)\n\t\t\ti = syscache_callback_list[i].link - 1;\n\t\tsyscache_callback_list[i].link = syscache_callback_count + 1;\n\t}\n\n\tsyscache_callback_list[syscache_callback_count].id = cacheid;\n\tsyscache_callback_list[syscache_callback_count].link = 0;\n\tsyscache_callback_list[syscache_callback_count].function = func;\n\tsyscache_callback_list[syscache_callback_count].arg = arg;\n\n\t++syscache_callback_count;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_SYSCACHE_CALLBACKS 64"
    ],
    "globals_used": [
      "static struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];",
      "static int16 syscache_callback_links[SysCacheSize];",
      "static int\tsyscache_callback_count = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"out of syscache_callback_list slots\""
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define MAX_SYSCACHE_CALLBACKS 64\n\nstatic struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];\nstatic int16 syscache_callback_links[SysCacheSize];\nstatic int\tsyscache_callback_count = 0;\n\nvoid\nCacheRegisterSyscacheCallback(int cacheid,\n\t\t\t\t\t\t\t  SyscacheCallbackFunction func,\n\t\t\t\t\t\t\t  Datum arg)\n{\n\tif (cacheid < 0 || cacheid >= SysCacheSize)\n\t\telog(FATAL, \"invalid cache ID: %d\", cacheid);\n\tif (syscache_callback_count >= MAX_SYSCACHE_CALLBACKS)\n\t\telog(FATAL, \"out of syscache_callback_list slots\");\n\n\tif (syscache_callback_links[cacheid] == 0)\n\t{\n\t\t/* first callback for this cache */\n\t\tsyscache_callback_links[cacheid] = syscache_callback_count + 1;\n\t}\n\telse\n\t{\n\t\t/* add to end of chain, so that older callbacks are called first */\n\t\tint\t\t\ti = syscache_callback_links[cacheid] - 1;\n\n\t\twhile (syscache_callback_list[i].link > 0)\n\t\t\ti = syscache_callback_list[i].link - 1;\n\t\tsyscache_callback_list[i].link = syscache_callback_count + 1;\n\t}\n\n\tsyscache_callback_list[syscache_callback_count].id = cacheid;\n\tsyscache_callback_list[syscache_callback_count].link = 0;\n\tsyscache_callback_list[syscache_callback_count].function = func;\n\tsyscache_callback_list[syscache_callback_count].arg = arg;\n\n\t++syscache_callback_count;\n}"
  },
  {
    "function_name": "CacheInvalidateRelmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "1398-1409",
    "snippet": "void\nCacheInvalidateRelmap(Oid databaseId)\n{\n\tSharedInvalidationMessage msg;\n\n\tmsg.rm.id = SHAREDINVALRELMAP_ID;\n\tmsg.rm.dbId = databaseId;\n\t/* check AddCatcacheInvalidationMessage() for an explanation */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tSendSharedInvalidMessages(&msg, 1);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SendSharedInvalidMessages",
          "args": [
            "&msg",
            "1"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "&msg",
            "sizeof(msg)"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nCacheInvalidateRelmap(Oid databaseId)\n{\n\tSharedInvalidationMessage msg;\n\n\tmsg.rm.id = SHAREDINVALRELMAP_ID;\n\tmsg.rm.dbId = databaseId;\n\t/* check AddCatcacheInvalidationMessage() for an explanation */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tSendSharedInvalidMessages(&msg, 1);\n}"
  },
  {
    "function_name": "CacheInvalidateSmgr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "1368-1381",
    "snippet": "void\nCacheInvalidateSmgr(RelFileNodeBackend rnode)\n{\n\tSharedInvalidationMessage msg;\n\n\tmsg.sm.id = SHAREDINVALSMGR_ID;\n\tmsg.sm.backend_hi = rnode.backend >> 16;\n\tmsg.sm.backend_lo = rnode.backend & 0xffff;\n\tmsg.sm.rnode = rnode.node;\n\t/* check AddCatcacheInvalidationMessage() for an explanation */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tSendSharedInvalidMessages(&msg, 1);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SendSharedInvalidMessages",
          "args": [
            "&msg",
            "1"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "&msg",
            "sizeof(msg)"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nCacheInvalidateSmgr(RelFileNodeBackend rnode)\n{\n\tSharedInvalidationMessage msg;\n\n\tmsg.sm.id = SHAREDINVALSMGR_ID;\n\tmsg.sm.backend_hi = rnode.backend >> 16;\n\tmsg.sm.backend_lo = rnode.backend & 0xffff;\n\tmsg.sm.rnode = rnode.node;\n\t/* check AddCatcacheInvalidationMessage() for an explanation */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tSendSharedInvalidMessages(&msg, 1);\n}"
  },
  {
    "function_name": "CacheInvalidateRelcacheByRelid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "1328-1340",
    "snippet": "void\nCacheInvalidateRelcacheByRelid(Oid relid)\n{\n\tHeapTuple\ttup;\n\n\tPrepareInvalidationState();\n\n\ttup = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for relation %u\", relid);\n\tCacheInvalidateRelcacheByTuple(tup);\n\tReleaseSysCache(tup);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tup"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CacheInvalidateRelcacheByTuple",
          "args": [
            "tup"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "CacheInvalidateRelcacheByTuple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "1305-1320",
          "snippet": "void\nCacheInvalidateRelcacheByTuple(HeapTuple classTuple)\n{\n\tForm_pg_class classtup = (Form_pg_class) GETSTRUCT(classTuple);\n\tOid\t\t\tdatabaseId;\n\tOid\t\t\trelationId;\n\n\tPrepareInvalidationState();\n\n\trelationId = HeapTupleGetOid(classTuple);\n\tif (classtup->relisshared)\n\t\tdatabaseId = InvalidOid;\n\telse\n\t\tdatabaseId = MyDatabaseId;\n\tRegisterRelcacheInvalidation(databaseId, relationId);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nCacheInvalidateRelcacheByTuple(HeapTuple classTuple)\n{\n\tForm_pg_class classtup = (Form_pg_class) GETSTRUCT(classTuple);\n\tOid\t\t\tdatabaseId;\n\tOid\t\t\trelationId;\n\n\tPrepareInvalidationState();\n\n\trelationId = HeapTupleGetOid(classTuple);\n\tif (classtup->relisshared)\n\t\tdatabaseId = InvalidOid;\n\telse\n\t\tdatabaseId = MyDatabaseId;\n\tRegisterRelcacheInvalidation(databaseId, relationId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for relation %u\"",
            "relid"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tup"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "RELOID",
            "ObjectIdGetDatum(relid)"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "relid"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrepareInvalidationState",
          "args": [],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "PrepareInvalidationState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "731-754",
          "snippet": "static void\nPrepareInvalidationState(void)\n{\n\tTransInvalidationInfo *myInfo;\n\n\tif (transInvalInfo != NULL &&\n\t\ttransInvalInfo->my_level == GetCurrentTransactionNestLevel())\n\t\treturn;\n\n\tmyInfo = (TransInvalidationInfo *)\n\t\tMemoryContextAllocZero(TopTransactionContext,\n\t\t\t\t\t\t\t   sizeof(TransInvalidationInfo));\n\tmyInfo->parent = transInvalInfo;\n\tmyInfo->my_level = GetCurrentTransactionNestLevel();\n\n\t/*\n\t * If there's any previous entry, this one should be for a deeper nesting\n\t * level.\n\t */\n\tAssert(transInvalInfo == NULL ||\n\t\t   myInfo->my_level > transInvalInfo->my_level);\n\n\ttransInvalInfo = myInfo;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TransInvalidationInfo *transInvalInfo = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\n\nstatic void\nPrepareInvalidationState(void)\n{\n\tTransInvalidationInfo *myInfo;\n\n\tif (transInvalInfo != NULL &&\n\t\ttransInvalInfo->my_level == GetCurrentTransactionNestLevel())\n\t\treturn;\n\n\tmyInfo = (TransInvalidationInfo *)\n\t\tMemoryContextAllocZero(TopTransactionContext,\n\t\t\t\t\t\t\t   sizeof(TransInvalidationInfo));\n\tmyInfo->parent = transInvalInfo;\n\tmyInfo->my_level = GetCurrentTransactionNestLevel();\n\n\t/*\n\t * If there's any previous entry, this one should be for a deeper nesting\n\t * level.\n\t */\n\tAssert(transInvalInfo == NULL ||\n\t\t   myInfo->my_level > transInvalInfo->my_level);\n\n\ttransInvalInfo = myInfo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nCacheInvalidateRelcacheByRelid(Oid relid)\n{\n\tHeapTuple\ttup;\n\n\tPrepareInvalidationState();\n\n\ttup = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for relation %u\", relid);\n\tCacheInvalidateRelcacheByTuple(tup);\n\tReleaseSysCache(tup);\n}"
  },
  {
    "function_name": "CacheInvalidateRelcacheByTuple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "1305-1320",
    "snippet": "void\nCacheInvalidateRelcacheByTuple(HeapTuple classTuple)\n{\n\tForm_pg_class classtup = (Form_pg_class) GETSTRUCT(classTuple);\n\tOid\t\t\tdatabaseId;\n\tOid\t\t\trelationId;\n\n\tPrepareInvalidationState();\n\n\trelationId = HeapTupleGetOid(classTuple);\n\tif (classtup->relisshared)\n\t\tdatabaseId = InvalidOid;\n\telse\n\t\tdatabaseId = MyDatabaseId;\n\tRegisterRelcacheInvalidation(databaseId, relationId);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RegisterRelcacheInvalidation",
          "args": [
            "databaseId",
            "relationId"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "RegisterRelcacheInvalidation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "511-533",
          "snippet": "static void\nRegisterRelcacheInvalidation(Oid dbId, Oid relId)\n{\n\tAddRelcacheInvalidationMessage(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   dbId, relId);\n\n\t/*\n\t * Most of the time, relcache invalidation is associated with system\n\t * catalog updates, but there are a few cases where it isn't.  Quick hack\n\t * to ensure that the next CommandCounterIncrement() will think that we\n\t * need to do CommandEndInvalidationMessages().\n\t */\n\t(void) GetCurrentCommandId(true);\n\n\t/*\n\t * If the relation being invalidated is one of those cached in a relcache\n\t * init file, mark that we need to zap that file at commit. For simplicity\n\t * invalidations for a specific database always invalidate the shared file\n\t * as well.  Also zap when we are invalidating whole relcache.\n\t */\n\tif (relId == InvalidOid || RelationIdIsInInitFile(relId))\n\t\ttransInvalInfo->RelcacheInitFileInval = true;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TransInvalidationInfo *transInvalInfo = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\n\nstatic void\nRegisterRelcacheInvalidation(Oid dbId, Oid relId)\n{\n\tAddRelcacheInvalidationMessage(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   dbId, relId);\n\n\t/*\n\t * Most of the time, relcache invalidation is associated with system\n\t * catalog updates, but there are a few cases where it isn't.  Quick hack\n\t * to ensure that the next CommandCounterIncrement() will think that we\n\t * need to do CommandEndInvalidationMessages().\n\t */\n\t(void) GetCurrentCommandId(true);\n\n\t/*\n\t * If the relation being invalidated is one of those cached in a relcache\n\t * init file, mark that we need to zap that file at commit. For simplicity\n\t * invalidations for a specific database always invalidate the shared file\n\t * as well.  Also zap when we are invalidating whole relcache.\n\t */\n\tif (relId == InvalidOid || RelationIdIsInInitFile(relId))\n\t\ttransInvalInfo->RelcacheInitFileInval = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "classTuple"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrepareInvalidationState",
          "args": [],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "PrepareInvalidationState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "731-754",
          "snippet": "static void\nPrepareInvalidationState(void)\n{\n\tTransInvalidationInfo *myInfo;\n\n\tif (transInvalInfo != NULL &&\n\t\ttransInvalInfo->my_level == GetCurrentTransactionNestLevel())\n\t\treturn;\n\n\tmyInfo = (TransInvalidationInfo *)\n\t\tMemoryContextAllocZero(TopTransactionContext,\n\t\t\t\t\t\t\t   sizeof(TransInvalidationInfo));\n\tmyInfo->parent = transInvalInfo;\n\tmyInfo->my_level = GetCurrentTransactionNestLevel();\n\n\t/*\n\t * If there's any previous entry, this one should be for a deeper nesting\n\t * level.\n\t */\n\tAssert(transInvalInfo == NULL ||\n\t\t   myInfo->my_level > transInvalInfo->my_level);\n\n\ttransInvalInfo = myInfo;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TransInvalidationInfo *transInvalInfo = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\n\nstatic void\nPrepareInvalidationState(void)\n{\n\tTransInvalidationInfo *myInfo;\n\n\tif (transInvalInfo != NULL &&\n\t\ttransInvalInfo->my_level == GetCurrentTransactionNestLevel())\n\t\treturn;\n\n\tmyInfo = (TransInvalidationInfo *)\n\t\tMemoryContextAllocZero(TopTransactionContext,\n\t\t\t\t\t\t\t   sizeof(TransInvalidationInfo));\n\tmyInfo->parent = transInvalInfo;\n\tmyInfo->my_level = GetCurrentTransactionNestLevel();\n\n\t/*\n\t * If there's any previous entry, this one should be for a deeper nesting\n\t * level.\n\t */\n\tAssert(transInvalInfo == NULL ||\n\t\t   myInfo->my_level > transInvalInfo->my_level);\n\n\ttransInvalInfo = myInfo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "classTuple"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nCacheInvalidateRelcacheByTuple(HeapTuple classTuple)\n{\n\tForm_pg_class classtup = (Form_pg_class) GETSTRUCT(classTuple);\n\tOid\t\t\tdatabaseId;\n\tOid\t\t\trelationId;\n\n\tPrepareInvalidationState();\n\n\trelationId = HeapTupleGetOid(classTuple);\n\tif (classtup->relisshared)\n\t\tdatabaseId = InvalidOid;\n\telse\n\t\tdatabaseId = MyDatabaseId;\n\tRegisterRelcacheInvalidation(databaseId, relationId);\n}"
  },
  {
    "function_name": "CacheInvalidateRelcacheAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "1293-1299",
    "snippet": "void\nCacheInvalidateRelcacheAll(void)\n{\n\tPrepareInvalidationState();\n\n\tRegisterRelcacheInvalidation(InvalidOid, InvalidOid);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RegisterRelcacheInvalidation",
          "args": [
            "InvalidOid",
            "InvalidOid"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "RegisterRelcacheInvalidation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "511-533",
          "snippet": "static void\nRegisterRelcacheInvalidation(Oid dbId, Oid relId)\n{\n\tAddRelcacheInvalidationMessage(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   dbId, relId);\n\n\t/*\n\t * Most of the time, relcache invalidation is associated with system\n\t * catalog updates, but there are a few cases where it isn't.  Quick hack\n\t * to ensure that the next CommandCounterIncrement() will think that we\n\t * need to do CommandEndInvalidationMessages().\n\t */\n\t(void) GetCurrentCommandId(true);\n\n\t/*\n\t * If the relation being invalidated is one of those cached in a relcache\n\t * init file, mark that we need to zap that file at commit. For simplicity\n\t * invalidations for a specific database always invalidate the shared file\n\t * as well.  Also zap when we are invalidating whole relcache.\n\t */\n\tif (relId == InvalidOid || RelationIdIsInInitFile(relId))\n\t\ttransInvalInfo->RelcacheInitFileInval = true;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TransInvalidationInfo *transInvalInfo = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\n\nstatic void\nRegisterRelcacheInvalidation(Oid dbId, Oid relId)\n{\n\tAddRelcacheInvalidationMessage(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   dbId, relId);\n\n\t/*\n\t * Most of the time, relcache invalidation is associated with system\n\t * catalog updates, but there are a few cases where it isn't.  Quick hack\n\t * to ensure that the next CommandCounterIncrement() will think that we\n\t * need to do CommandEndInvalidationMessages().\n\t */\n\t(void) GetCurrentCommandId(true);\n\n\t/*\n\t * If the relation being invalidated is one of those cached in a relcache\n\t * init file, mark that we need to zap that file at commit. For simplicity\n\t * invalidations for a specific database always invalidate the shared file\n\t * as well.  Also zap when we are invalidating whole relcache.\n\t */\n\tif (relId == InvalidOid || RelationIdIsInInitFile(relId))\n\t\ttransInvalInfo->RelcacheInitFileInval = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrepareInvalidationState",
          "args": [],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "PrepareInvalidationState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "731-754",
          "snippet": "static void\nPrepareInvalidationState(void)\n{\n\tTransInvalidationInfo *myInfo;\n\n\tif (transInvalInfo != NULL &&\n\t\ttransInvalInfo->my_level == GetCurrentTransactionNestLevel())\n\t\treturn;\n\n\tmyInfo = (TransInvalidationInfo *)\n\t\tMemoryContextAllocZero(TopTransactionContext,\n\t\t\t\t\t\t\t   sizeof(TransInvalidationInfo));\n\tmyInfo->parent = transInvalInfo;\n\tmyInfo->my_level = GetCurrentTransactionNestLevel();\n\n\t/*\n\t * If there's any previous entry, this one should be for a deeper nesting\n\t * level.\n\t */\n\tAssert(transInvalInfo == NULL ||\n\t\t   myInfo->my_level > transInvalInfo->my_level);\n\n\ttransInvalInfo = myInfo;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TransInvalidationInfo *transInvalInfo = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\n\nstatic void\nPrepareInvalidationState(void)\n{\n\tTransInvalidationInfo *myInfo;\n\n\tif (transInvalInfo != NULL &&\n\t\ttransInvalInfo->my_level == GetCurrentTransactionNestLevel())\n\t\treturn;\n\n\tmyInfo = (TransInvalidationInfo *)\n\t\tMemoryContextAllocZero(TopTransactionContext,\n\t\t\t\t\t\t\t   sizeof(TransInvalidationInfo));\n\tmyInfo->parent = transInvalInfo;\n\tmyInfo->my_level = GetCurrentTransactionNestLevel();\n\n\t/*\n\t * If there's any previous entry, this one should be for a deeper nesting\n\t * level.\n\t */\n\tAssert(transInvalInfo == NULL ||\n\t\t   myInfo->my_level > transInvalInfo->my_level);\n\n\ttransInvalInfo = myInfo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nCacheInvalidateRelcacheAll(void)\n{\n\tPrepareInvalidationState();\n\n\tRegisterRelcacheInvalidation(InvalidOid, InvalidOid);\n}"
  },
  {
    "function_name": "CacheInvalidateRelcache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "1269-1284",
    "snippet": "void\nCacheInvalidateRelcache(Relation relation)\n{\n\tOid\t\t\tdatabaseId;\n\tOid\t\t\trelationId;\n\n\tPrepareInvalidationState();\n\n\trelationId = RelationGetRelid(relation);\n\tif (relation->rd_rel->relisshared)\n\t\tdatabaseId = InvalidOid;\n\telse\n\t\tdatabaseId = MyDatabaseId;\n\n\tRegisterRelcacheInvalidation(databaseId, relationId);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RegisterRelcacheInvalidation",
          "args": [
            "databaseId",
            "relationId"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "RegisterRelcacheInvalidation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "511-533",
          "snippet": "static void\nRegisterRelcacheInvalidation(Oid dbId, Oid relId)\n{\n\tAddRelcacheInvalidationMessage(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   dbId, relId);\n\n\t/*\n\t * Most of the time, relcache invalidation is associated with system\n\t * catalog updates, but there are a few cases where it isn't.  Quick hack\n\t * to ensure that the next CommandCounterIncrement() will think that we\n\t * need to do CommandEndInvalidationMessages().\n\t */\n\t(void) GetCurrentCommandId(true);\n\n\t/*\n\t * If the relation being invalidated is one of those cached in a relcache\n\t * init file, mark that we need to zap that file at commit. For simplicity\n\t * invalidations for a specific database always invalidate the shared file\n\t * as well.  Also zap when we are invalidating whole relcache.\n\t */\n\tif (relId == InvalidOid || RelationIdIsInInitFile(relId))\n\t\ttransInvalInfo->RelcacheInitFileInval = true;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TransInvalidationInfo *transInvalInfo = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\n\nstatic void\nRegisterRelcacheInvalidation(Oid dbId, Oid relId)\n{\n\tAddRelcacheInvalidationMessage(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   dbId, relId);\n\n\t/*\n\t * Most of the time, relcache invalidation is associated with system\n\t * catalog updates, but there are a few cases where it isn't.  Quick hack\n\t * to ensure that the next CommandCounterIncrement() will think that we\n\t * need to do CommandEndInvalidationMessages().\n\t */\n\t(void) GetCurrentCommandId(true);\n\n\t/*\n\t * If the relation being invalidated is one of those cached in a relcache\n\t * init file, mark that we need to zap that file at commit. For simplicity\n\t * invalidations for a specific database always invalidate the shared file\n\t * as well.  Also zap when we are invalidating whole relcache.\n\t */\n\tif (relId == InvalidOid || RelationIdIsInInitFile(relId))\n\t\ttransInvalInfo->RelcacheInitFileInval = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrepareInvalidationState",
          "args": [],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "PrepareInvalidationState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "731-754",
          "snippet": "static void\nPrepareInvalidationState(void)\n{\n\tTransInvalidationInfo *myInfo;\n\n\tif (transInvalInfo != NULL &&\n\t\ttransInvalInfo->my_level == GetCurrentTransactionNestLevel())\n\t\treturn;\n\n\tmyInfo = (TransInvalidationInfo *)\n\t\tMemoryContextAllocZero(TopTransactionContext,\n\t\t\t\t\t\t\t   sizeof(TransInvalidationInfo));\n\tmyInfo->parent = transInvalInfo;\n\tmyInfo->my_level = GetCurrentTransactionNestLevel();\n\n\t/*\n\t * If there's any previous entry, this one should be for a deeper nesting\n\t * level.\n\t */\n\tAssert(transInvalInfo == NULL ||\n\t\t   myInfo->my_level > transInvalInfo->my_level);\n\n\ttransInvalInfo = myInfo;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TransInvalidationInfo *transInvalInfo = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\n\nstatic void\nPrepareInvalidationState(void)\n{\n\tTransInvalidationInfo *myInfo;\n\n\tif (transInvalInfo != NULL &&\n\t\ttransInvalInfo->my_level == GetCurrentTransactionNestLevel())\n\t\treturn;\n\n\tmyInfo = (TransInvalidationInfo *)\n\t\tMemoryContextAllocZero(TopTransactionContext,\n\t\t\t\t\t\t\t   sizeof(TransInvalidationInfo));\n\tmyInfo->parent = transInvalInfo;\n\tmyInfo->my_level = GetCurrentTransactionNestLevel();\n\n\t/*\n\t * If there's any previous entry, this one should be for a deeper nesting\n\t * level.\n\t */\n\tAssert(transInvalInfo == NULL ||\n\t\t   myInfo->my_level > transInvalInfo->my_level);\n\n\ttransInvalInfo = myInfo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nCacheInvalidateRelcache(Relation relation)\n{\n\tOid\t\t\tdatabaseId;\n\tOid\t\t\trelationId;\n\n\tPrepareInvalidationState();\n\n\trelationId = RelationGetRelid(relation);\n\tif (relation->rd_rel->relisshared)\n\t\tdatabaseId = InvalidOid;\n\telse\n\t\tdatabaseId = MyDatabaseId;\n\n\tRegisterRelcacheInvalidation(databaseId, relationId);\n}"
  },
  {
    "function_name": "CacheInvalidateCatalog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "1245-1258",
    "snippet": "void\nCacheInvalidateCatalog(Oid catalogId)\n{\n\tOid\t\t\tdatabaseId;\n\n\tPrepareInvalidationState();\n\n\tif (IsSharedRelation(catalogId))\n\t\tdatabaseId = InvalidOid;\n\telse\n\t\tdatabaseId = MyDatabaseId;\n\n\tRegisterCatalogInvalidation(databaseId, catalogId);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RegisterCatalogInvalidation",
          "args": [
            "databaseId",
            "catalogId"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "RegisterCatalogInvalidation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "499-504",
          "snippet": "static void\nRegisterCatalogInvalidation(Oid dbId, Oid catId)\n{\n\tAddCatalogInvalidationMessage(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t  dbId, catId);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TransInvalidationInfo *transInvalInfo = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\n\nstatic void\nRegisterCatalogInvalidation(Oid dbId, Oid catId)\n{\n\tAddCatalogInvalidationMessage(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t  dbId, catId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsSharedRelation",
          "args": [
            "catalogId"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrepareInvalidationState",
          "args": [],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "PrepareInvalidationState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "731-754",
          "snippet": "static void\nPrepareInvalidationState(void)\n{\n\tTransInvalidationInfo *myInfo;\n\n\tif (transInvalInfo != NULL &&\n\t\ttransInvalInfo->my_level == GetCurrentTransactionNestLevel())\n\t\treturn;\n\n\tmyInfo = (TransInvalidationInfo *)\n\t\tMemoryContextAllocZero(TopTransactionContext,\n\t\t\t\t\t\t\t   sizeof(TransInvalidationInfo));\n\tmyInfo->parent = transInvalInfo;\n\tmyInfo->my_level = GetCurrentTransactionNestLevel();\n\n\t/*\n\t * If there's any previous entry, this one should be for a deeper nesting\n\t * level.\n\t */\n\tAssert(transInvalInfo == NULL ||\n\t\t   myInfo->my_level > transInvalInfo->my_level);\n\n\ttransInvalInfo = myInfo;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TransInvalidationInfo *transInvalInfo = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\n\nstatic void\nPrepareInvalidationState(void)\n{\n\tTransInvalidationInfo *myInfo;\n\n\tif (transInvalInfo != NULL &&\n\t\ttransInvalInfo->my_level == GetCurrentTransactionNestLevel())\n\t\treturn;\n\n\tmyInfo = (TransInvalidationInfo *)\n\t\tMemoryContextAllocZero(TopTransactionContext,\n\t\t\t\t\t\t\t   sizeof(TransInvalidationInfo));\n\tmyInfo->parent = transInvalInfo;\n\tmyInfo->my_level = GetCurrentTransactionNestLevel();\n\n\t/*\n\t * If there's any previous entry, this one should be for a deeper nesting\n\t * level.\n\t */\n\tAssert(transInvalInfo == NULL ||\n\t\t   myInfo->my_level > transInvalInfo->my_level);\n\n\ttransInvalInfo = myInfo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nCacheInvalidateCatalog(Oid catalogId)\n{\n\tOid\t\t\tdatabaseId;\n\n\tPrepareInvalidationState();\n\n\tif (IsSharedRelation(catalogId))\n\t\tdatabaseId = InvalidOid;\n\telse\n\t\tdatabaseId = MyDatabaseId;\n\n\tRegisterCatalogInvalidation(databaseId, catalogId);\n}"
  },
  {
    "function_name": "CacheInvalidateHeapTuple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "1113-1232",
    "snippet": "void\nCacheInvalidateHeapTuple(Relation relation,\n\t\t\t\t\t\t HeapTuple tuple,\n\t\t\t\t\t\t HeapTuple newtuple)\n{\n\tOid\t\t\ttupleRelId;\n\tOid\t\t\tdatabaseId;\n\tOid\t\t\trelationId;\n\n\t/* Do nothing during bootstrap */\n\tif (IsBootstrapProcessingMode())\n\t\treturn;\n\n\t/*\n\t * We only need to worry about invalidation for tuples that are in system\n\t * catalogs; user-relation tuples are never in catcaches and can't affect\n\t * the relcache either.\n\t */\n\tif (!IsCatalogRelation(relation))\n\t\treturn;\n\n\t/*\n\t * IsCatalogRelation() will return true for TOAST tables of system\n\t * catalogs, but we don't care about those, either.\n\t */\n\tif (IsToastRelation(relation))\n\t\treturn;\n\n\t/*\n\t * If we're not prepared to queue invalidation messages for this\n\t * subtransaction level, get ready now.\n\t */\n\tPrepareInvalidationState();\n\n\t/*\n\t * First let the catcache do its thing\n\t */\n\ttupleRelId = RelationGetRelid(relation);\n\tif (RelationInvalidatesSnapshotsOnly(tupleRelId))\n\t{\n\t\tdatabaseId = IsSharedRelation(tupleRelId) ? InvalidOid : MyDatabaseId;\n\t\tRegisterSnapshotInvalidation(databaseId, tupleRelId);\n\t}\n\telse\n\t\tPrepareToInvalidateCacheTuple(relation, tuple, newtuple,\n\t\t\t\t\t\t\t\t\t  RegisterCatcacheInvalidation);\n\n\t/*\n\t * Now, is this tuple one of the primary definers of a relcache entry? See\n\t * comments in file header for deeper explanation.\n\t *\n\t * Note we ignore newtuple here; we assume an update cannot move a tuple\n\t * from being part of one relcache entry to being part of another.\n\t */\n\tif (tupleRelId == RelationRelationId)\n\t{\n\t\tForm_pg_class classtup = (Form_pg_class) GETSTRUCT(tuple);\n\n\t\trelationId = HeapTupleGetOid(tuple);\n\t\tif (classtup->relisshared)\n\t\t\tdatabaseId = InvalidOid;\n\t\telse\n\t\t\tdatabaseId = MyDatabaseId;\n\t}\n\telse if (tupleRelId == AttributeRelationId)\n\t{\n\t\tForm_pg_attribute atttup = (Form_pg_attribute) GETSTRUCT(tuple);\n\n\t\trelationId = atttup->attrelid;\n\n\t\t/*\n\t\t * KLUGE ALERT: we always send the relcache event with MyDatabaseId,\n\t\t * even if the rel in question is shared (which we can't easily tell).\n\t\t * This essentially means that only backends in this same database\n\t\t * will react to the relcache flush request.  This is in fact\n\t\t * appropriate, since only those backends could see our pg_attribute\n\t\t * change anyway.  It looks a bit ugly though.  (In practice, shared\n\t\t * relations can't have schema changes after bootstrap, so we should\n\t\t * never come here for a shared rel anyway.)\n\t\t */\n\t\tdatabaseId = MyDatabaseId;\n\t}\n\telse if (tupleRelId == IndexRelationId)\n\t{\n\t\tForm_pg_index indextup = (Form_pg_index) GETSTRUCT(tuple);\n\n\t\t/*\n\t\t * When a pg_index row is updated, we should send out a relcache inval\n\t\t * for the index relation.  As above, we don't know the shared status\n\t\t * of the index, but in practice it doesn't matter since indexes of\n\t\t * shared catalogs can't have such updates.\n\t\t */\n\t\trelationId = indextup->indexrelid;\n\t\tdatabaseId = MyDatabaseId;\n\t}\n\telse if (tupleRelId == ConstraintRelationId)\n\t{\n\t\tForm_pg_constraint constrtup = (Form_pg_constraint) GETSTRUCT(tuple);\n\n\t\t/*\n\t\t * Foreign keys are part of relcache entries, too, so send out an\n\t\t * inval for the table that the FK applies to.\n\t\t */\n\t\tif (constrtup->contype == CONSTRAINT_FOREIGN &&\n\t\t\tOidIsValid(constrtup->conrelid))\n\t\t{\n\t\t\trelationId = constrtup->conrelid;\n\t\t\tdatabaseId = MyDatabaseId;\n\t\t}\n\t\telse\n\t\t\treturn;\n\t}\n\telse\n\t\treturn;\n\n\t/*\n\t * Yes.  We need to register a relcache invalidation event.\n\t */\n\tRegisterRelcacheInvalidation(databaseId, relationId);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RegisterRelcacheInvalidation",
          "args": [
            "databaseId",
            "relationId"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "RegisterRelcacheInvalidation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "511-533",
          "snippet": "static void\nRegisterRelcacheInvalidation(Oid dbId, Oid relId)\n{\n\tAddRelcacheInvalidationMessage(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   dbId, relId);\n\n\t/*\n\t * Most of the time, relcache invalidation is associated with system\n\t * catalog updates, but there are a few cases where it isn't.  Quick hack\n\t * to ensure that the next CommandCounterIncrement() will think that we\n\t * need to do CommandEndInvalidationMessages().\n\t */\n\t(void) GetCurrentCommandId(true);\n\n\t/*\n\t * If the relation being invalidated is one of those cached in a relcache\n\t * init file, mark that we need to zap that file at commit. For simplicity\n\t * invalidations for a specific database always invalidate the shared file\n\t * as well.  Also zap when we are invalidating whole relcache.\n\t */\n\tif (relId == InvalidOid || RelationIdIsInInitFile(relId))\n\t\ttransInvalInfo->RelcacheInitFileInval = true;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TransInvalidationInfo *transInvalInfo = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\n\nstatic void\nRegisterRelcacheInvalidation(Oid dbId, Oid relId)\n{\n\tAddRelcacheInvalidationMessage(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   dbId, relId);\n\n\t/*\n\t * Most of the time, relcache invalidation is associated with system\n\t * catalog updates, but there are a few cases where it isn't.  Quick hack\n\t * to ensure that the next CommandCounterIncrement() will think that we\n\t * need to do CommandEndInvalidationMessages().\n\t */\n\t(void) GetCurrentCommandId(true);\n\n\t/*\n\t * If the relation being invalidated is one of those cached in a relcache\n\t * init file, mark that we need to zap that file at commit. For simplicity\n\t * invalidations for a specific database always invalidate the shared file\n\t * as well.  Also zap when we are invalidating whole relcache.\n\t */\n\tif (relId == InvalidOid || RelationIdIsInInitFile(relId))\n\t\ttransInvalInfo->RelcacheInitFileInval = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "constrtup->conrelid"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "tuple"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrepareToInvalidateCacheTuple",
          "args": [
            "relation",
            "tuple",
            "newtuple",
            "RegisterCatcacheInvalidation"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "PrepareToInvalidateCacheTuple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "2034-2091",
          "snippet": "void\nPrepareToInvalidateCacheTuple(Relation relation,\n\t\t\t\t\t\t\t  HeapTuple tuple,\n\t\t\t\t\t\t\t  HeapTuple newtuple,\n\t\t\t\t\t\t\t  void (*function) (int, uint32, Oid))\n{\n\tslist_iter\titer;\n\tOid\t\t\treloid;\n\n\tCACHE1_elog(DEBUG2, \"PrepareToInvalidateCacheTuple: called\");\n\n\t/*\n\t * sanity checks\n\t */\n\tAssert(RelationIsValid(relation));\n\tAssert(HeapTupleIsValid(tuple));\n\tAssert(PointerIsValid(function));\n\tAssert(CacheHdr != NULL);\n\n\treloid = RelationGetRelid(relation);\n\n\t/* ----------------\n\t *\tfor each cache\n\t *\t   if the cache contains tuples from the specified relation\n\t *\t\t   compute the tuple's hash value(s) in this cache,\n\t *\t\t   and call the passed function to register the information.\n\t * ----------------\n\t */\n\n\tslist_foreach(iter, &CacheHdr->ch_caches)\n\t{\n\t\tCatCache   *ccp = slist_container(CatCache, cc_next, iter.cur);\n\t\tuint32\t\thashvalue;\n\t\tOid\t\t\tdbid;\n\n\t\tif (ccp->cc_reloid != reloid)\n\t\t\tcontinue;\n\n\t\t/* Just in case cache hasn't finished initialization yet... */\n\t\tif (ccp->cc_tupdesc == NULL)\n\t\t\tCatalogCacheInitializeCache(ccp);\n\n\t\thashvalue = CatalogCacheComputeTupleHashValue(ccp, ccp->cc_nkeys, tuple);\n\t\tdbid = ccp->cc_relisshared ? (Oid) 0 : MyDatabaseId;\n\n\t\t(*function) (ccp->id, hashvalue, dbid);\n\n\t\tif (newtuple)\n\t\t{\n\t\t\tuint32\t\tnewhashvalue;\n\n\t\t\tnewhashvalue = CatalogCacheComputeTupleHashValue(ccp, ccp->cc_nkeys, newtuple);\n\n\t\t\tif (newhashvalue != hashvalue)\n\t\t\t\t(*function) (ccp->id, newhashvalue, dbid);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCacheHeader *CacheHdr = NULL;",
            "static uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);",
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic CatCacheHeader *CacheHdr = NULL;\nstatic uint32 CatalogCacheComputeTupleHashValue(CatCache *cache, int nkeys,\n\t\t\t\t\t\t\t\t  HeapTuple tuple);\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nPrepareToInvalidateCacheTuple(Relation relation,\n\t\t\t\t\t\t\t  HeapTuple tuple,\n\t\t\t\t\t\t\t  HeapTuple newtuple,\n\t\t\t\t\t\t\t  void (*function) (int, uint32, Oid))\n{\n\tslist_iter\titer;\n\tOid\t\t\treloid;\n\n\tCACHE1_elog(DEBUG2, \"PrepareToInvalidateCacheTuple: called\");\n\n\t/*\n\t * sanity checks\n\t */\n\tAssert(RelationIsValid(relation));\n\tAssert(HeapTupleIsValid(tuple));\n\tAssert(PointerIsValid(function));\n\tAssert(CacheHdr != NULL);\n\n\treloid = RelationGetRelid(relation);\n\n\t/* ----------------\n\t *\tfor each cache\n\t *\t   if the cache contains tuples from the specified relation\n\t *\t\t   compute the tuple's hash value(s) in this cache,\n\t *\t\t   and call the passed function to register the information.\n\t * ----------------\n\t */\n\n\tslist_foreach(iter, &CacheHdr->ch_caches)\n\t{\n\t\tCatCache   *ccp = slist_container(CatCache, cc_next, iter.cur);\n\t\tuint32\t\thashvalue;\n\t\tOid\t\t\tdbid;\n\n\t\tif (ccp->cc_reloid != reloid)\n\t\t\tcontinue;\n\n\t\t/* Just in case cache hasn't finished initialization yet... */\n\t\tif (ccp->cc_tupdesc == NULL)\n\t\t\tCatalogCacheInitializeCache(ccp);\n\n\t\thashvalue = CatalogCacheComputeTupleHashValue(ccp, ccp->cc_nkeys, tuple);\n\t\tdbid = ccp->cc_relisshared ? (Oid) 0 : MyDatabaseId;\n\n\t\t(*function) (ccp->id, hashvalue, dbid);\n\n\t\tif (newtuple)\n\t\t{\n\t\t\tuint32\t\tnewhashvalue;\n\n\t\t\tnewhashvalue = CatalogCacheComputeTupleHashValue(ccp, ccp->cc_nkeys, newtuple);\n\n\t\t\tif (newhashvalue != hashvalue)\n\t\t\t\t(*function) (ccp->id, newhashvalue, dbid);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RegisterSnapshotInvalidation",
          "args": [
            "databaseId",
            "tupleRelId"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "RegisterSnapshotInvalidation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "541-546",
          "snippet": "static void\nRegisterSnapshotInvalidation(Oid dbId, Oid relId)\n{\n\tAddSnapshotInvalidationMessage(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   dbId, relId);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TransInvalidationInfo *transInvalInfo = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\n\nstatic void\nRegisterSnapshotInvalidation(Oid dbId, Oid relId)\n{\n\tAddSnapshotInvalidationMessage(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   dbId, relId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsSharedRelation",
          "args": [
            "tupleRelId"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationInvalidatesSnapshotsOnly",
          "args": [
            "tupleRelId"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "RelationInvalidatesSnapshotsOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1463-1481",
          "snippet": "bool\nRelationInvalidatesSnapshotsOnly(Oid relid)\n{\n\tswitch (relid)\n\t{\n\t\tcase DbRoleSettingRelationId:\n\t\tcase DependRelationId:\n\t\tcase SharedDependRelationId:\n\t\tcase DescriptionRelationId:\n\t\tcase SharedDescriptionRelationId:\n\t\tcase SecLabelRelationId:\n\t\tcase SharedSecLabelRelationId:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nbool\nRelationInvalidatesSnapshotsOnly(Oid relid)\n{\n\tswitch (relid)\n\t{\n\t\tcase DbRoleSettingRelationId:\n\t\tcase DependRelationId:\n\t\tcase SharedDependRelationId:\n\t\tcase DescriptionRelationId:\n\t\tcase SharedDescriptionRelationId:\n\t\tcase SecLabelRelationId:\n\t\tcase SharedSecLabelRelationId:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrepareInvalidationState",
          "args": [],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "PrepareInvalidationState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "731-754",
          "snippet": "static void\nPrepareInvalidationState(void)\n{\n\tTransInvalidationInfo *myInfo;\n\n\tif (transInvalInfo != NULL &&\n\t\ttransInvalInfo->my_level == GetCurrentTransactionNestLevel())\n\t\treturn;\n\n\tmyInfo = (TransInvalidationInfo *)\n\t\tMemoryContextAllocZero(TopTransactionContext,\n\t\t\t\t\t\t\t   sizeof(TransInvalidationInfo));\n\tmyInfo->parent = transInvalInfo;\n\tmyInfo->my_level = GetCurrentTransactionNestLevel();\n\n\t/*\n\t * If there's any previous entry, this one should be for a deeper nesting\n\t * level.\n\t */\n\tAssert(transInvalInfo == NULL ||\n\t\t   myInfo->my_level > transInvalInfo->my_level);\n\n\ttransInvalInfo = myInfo;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TransInvalidationInfo *transInvalInfo = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\n\nstatic void\nPrepareInvalidationState(void)\n{\n\tTransInvalidationInfo *myInfo;\n\n\tif (transInvalInfo != NULL &&\n\t\ttransInvalInfo->my_level == GetCurrentTransactionNestLevel())\n\t\treturn;\n\n\tmyInfo = (TransInvalidationInfo *)\n\t\tMemoryContextAllocZero(TopTransactionContext,\n\t\t\t\t\t\t\t   sizeof(TransInvalidationInfo));\n\tmyInfo->parent = transInvalInfo;\n\tmyInfo->my_level = GetCurrentTransactionNestLevel();\n\n\t/*\n\t * If there's any previous entry, this one should be for a deeper nesting\n\t * level.\n\t */\n\tAssert(transInvalInfo == NULL ||\n\t\t   myInfo->my_level > transInvalInfo->my_level);\n\n\ttransInvalInfo = myInfo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsToastRelation",
          "args": [
            "relation"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsCatalogRelation",
          "args": [
            "relation"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nCacheInvalidateHeapTuple(Relation relation,\n\t\t\t\t\t\t HeapTuple tuple,\n\t\t\t\t\t\t HeapTuple newtuple)\n{\n\tOid\t\t\ttupleRelId;\n\tOid\t\t\tdatabaseId;\n\tOid\t\t\trelationId;\n\n\t/* Do nothing during bootstrap */\n\tif (IsBootstrapProcessingMode())\n\t\treturn;\n\n\t/*\n\t * We only need to worry about invalidation for tuples that are in system\n\t * catalogs; user-relation tuples are never in catcaches and can't affect\n\t * the relcache either.\n\t */\n\tif (!IsCatalogRelation(relation))\n\t\treturn;\n\n\t/*\n\t * IsCatalogRelation() will return true for TOAST tables of system\n\t * catalogs, but we don't care about those, either.\n\t */\n\tif (IsToastRelation(relation))\n\t\treturn;\n\n\t/*\n\t * If we're not prepared to queue invalidation messages for this\n\t * subtransaction level, get ready now.\n\t */\n\tPrepareInvalidationState();\n\n\t/*\n\t * First let the catcache do its thing\n\t */\n\ttupleRelId = RelationGetRelid(relation);\n\tif (RelationInvalidatesSnapshotsOnly(tupleRelId))\n\t{\n\t\tdatabaseId = IsSharedRelation(tupleRelId) ? InvalidOid : MyDatabaseId;\n\t\tRegisterSnapshotInvalidation(databaseId, tupleRelId);\n\t}\n\telse\n\t\tPrepareToInvalidateCacheTuple(relation, tuple, newtuple,\n\t\t\t\t\t\t\t\t\t  RegisterCatcacheInvalidation);\n\n\t/*\n\t * Now, is this tuple one of the primary definers of a relcache entry? See\n\t * comments in file header for deeper explanation.\n\t *\n\t * Note we ignore newtuple here; we assume an update cannot move a tuple\n\t * from being part of one relcache entry to being part of another.\n\t */\n\tif (tupleRelId == RelationRelationId)\n\t{\n\t\tForm_pg_class classtup = (Form_pg_class) GETSTRUCT(tuple);\n\n\t\trelationId = HeapTupleGetOid(tuple);\n\t\tif (classtup->relisshared)\n\t\t\tdatabaseId = InvalidOid;\n\t\telse\n\t\t\tdatabaseId = MyDatabaseId;\n\t}\n\telse if (tupleRelId == AttributeRelationId)\n\t{\n\t\tForm_pg_attribute atttup = (Form_pg_attribute) GETSTRUCT(tuple);\n\n\t\trelationId = atttup->attrelid;\n\n\t\t/*\n\t\t * KLUGE ALERT: we always send the relcache event with MyDatabaseId,\n\t\t * even if the rel in question is shared (which we can't easily tell).\n\t\t * This essentially means that only backends in this same database\n\t\t * will react to the relcache flush request.  This is in fact\n\t\t * appropriate, since only those backends could see our pg_attribute\n\t\t * change anyway.  It looks a bit ugly though.  (In practice, shared\n\t\t * relations can't have schema changes after bootstrap, so we should\n\t\t * never come here for a shared rel anyway.)\n\t\t */\n\t\tdatabaseId = MyDatabaseId;\n\t}\n\telse if (tupleRelId == IndexRelationId)\n\t{\n\t\tForm_pg_index indextup = (Form_pg_index) GETSTRUCT(tuple);\n\n\t\t/*\n\t\t * When a pg_index row is updated, we should send out a relcache inval\n\t\t * for the index relation.  As above, we don't know the shared status\n\t\t * of the index, but in practice it doesn't matter since indexes of\n\t\t * shared catalogs can't have such updates.\n\t\t */\n\t\trelationId = indextup->indexrelid;\n\t\tdatabaseId = MyDatabaseId;\n\t}\n\telse if (tupleRelId == ConstraintRelationId)\n\t{\n\t\tForm_pg_constraint constrtup = (Form_pg_constraint) GETSTRUCT(tuple);\n\n\t\t/*\n\t\t * Foreign keys are part of relcache entries, too, so send out an\n\t\t * inval for the table that the FK applies to.\n\t\t */\n\t\tif (constrtup->contype == CONSTRAINT_FOREIGN &&\n\t\t\tOidIsValid(constrtup->conrelid))\n\t\t{\n\t\t\trelationId = constrtup->conrelid;\n\t\t\tdatabaseId = MyDatabaseId;\n\t\t}\n\t\telse\n\t\t\treturn;\n\t}\n\telse\n\t\treturn;\n\n\t/*\n\t * Yes.  We need to register a relcache invalidation event.\n\t */\n\tRegisterRelcacheInvalidation(databaseId, relationId);\n}"
  },
  {
    "function_name": "CommandEndInvalidationMessages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "1084-1099",
    "snippet": "void\nCommandEndInvalidationMessages(void)\n{\n\t/*\n\t * You might think this shouldn't be called outside any transaction, but\n\t * bootstrap does it, and also ABORT issued when not in a transaction. So\n\t * just quietly return if no state to work on.\n\t */\n\tif (transInvalInfo == NULL)\n\t\treturn;\n\n\tProcessInvalidationMessages(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\tLocalExecuteInvalidationMessage);\n\tAppendInvalidationMessages(&transInvalInfo->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t   &transInvalInfo->CurrentCmdInvalidMsgs);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TransInvalidationInfo *transInvalInfo = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AppendInvalidationMessages",
          "args": [
            "&transInvalInfo->PriorCmdInvalidMsgs",
            "&transInvalInfo->CurrentCmdInvalidMsgs"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "AppendInvalidationMessages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "441-447",
          "snippet": "static void\nAppendInvalidationMessages(InvalidationListHeader *dest,\n\t\t\t\t\t\t   InvalidationListHeader *src)\n{\n\tAppendInvalidationMessageList(&dest->cclist, &src->cclist);\n\tAppendInvalidationMessageList(&dest->rclist, &src->rclist);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nAppendInvalidationMessages(InvalidationListHeader *dest,\n\t\t\t\t\t\t   InvalidationListHeader *src)\n{\n\tAppendInvalidationMessageList(&dest->cclist, &src->cclist);\n\tAppendInvalidationMessageList(&dest->rclist, &src->rclist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ProcessInvalidationMessages",
          "args": [
            "&transInvalInfo->CurrentCmdInvalidMsgs",
            "LocalExecuteInvalidationMessage"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessInvalidationMessagesMulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "467-473",
          "snippet": "static void\nProcessInvalidationMessagesMulti(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t\t void (*func) (const SharedInvalidationMessage *msgs, int n))\n{\n\tProcessMessageListMulti(hdr->cclist, func(msgs, n));\n\tProcessMessageListMulti(hdr->rclist, func(msgs, n));\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nProcessInvalidationMessagesMulti(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t\t void (*func) (const SharedInvalidationMessage *msgs, int n))\n{\n\tProcessMessageListMulti(hdr->cclist, func(msgs, n));\n\tProcessMessageListMulti(hdr->rclist, func(msgs, n));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\n\nvoid\nCommandEndInvalidationMessages(void)\n{\n\t/*\n\t * You might think this shouldn't be called outside any transaction, but\n\t * bootstrap does it, and also ABORT issued when not in a transaction. So\n\t * just quietly return if no state to work on.\n\t */\n\tif (transInvalInfo == NULL)\n\t\treturn;\n\n\tProcessInvalidationMessages(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\tLocalExecuteInvalidationMessage);\n\tAppendInvalidationMessages(&transInvalInfo->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t   &transInvalInfo->CurrentCmdInvalidMsgs);\n}"
  },
  {
    "function_name": "AtEOSubXact_Inval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "1007-1067",
    "snippet": "void\nAtEOSubXact_Inval(bool isCommit)\n{\n\tint\t\t\tmy_level;\n\tTransInvalidationInfo *myInfo = transInvalInfo;\n\n\t/* Quick exit if no messages. */\n\tif (myInfo == NULL)\n\t\treturn;\n\n\t/* Also bail out quickly if messages are not for this level. */\n\tmy_level = GetCurrentTransactionNestLevel();\n\tif (myInfo->my_level != my_level)\n\t{\n\t\tAssert(myInfo->my_level < my_level);\n\t\treturn;\n\t}\n\n\tif (isCommit)\n\t{\n\t\t/* If CurrentCmdInvalidMsgs still has anything, fix it */\n\t\tCommandEndInvalidationMessages();\n\n\t\t/*\n\t\t * We create invalidation stack entries lazily, so the parent might\n\t\t * not have one.  Instead of creating one, moving all the data over,\n\t\t * and then freeing our own, we can just adjust the level of our own\n\t\t * entry.\n\t\t */\n\t\tif (myInfo->parent == NULL || myInfo->parent->my_level < my_level - 1)\n\t\t{\n\t\t\tmyInfo->my_level--;\n\t\t\treturn;\n\t\t}\n\n\t\t/* Pass up my inval messages to parent */\n\t\tAppendInvalidationMessages(&myInfo->parent->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   &myInfo->PriorCmdInvalidMsgs);\n\n\t\t/* Pending relcache inval becomes parent's problem too */\n\t\tif (myInfo->RelcacheInitFileInval)\n\t\t\tmyInfo->parent->RelcacheInitFileInval = true;\n\n\t\t/* Pop the transaction state stack */\n\t\ttransInvalInfo = myInfo->parent;\n\n\t\t/* Need not free anything else explicitly */\n\t\tpfree(myInfo);\n\t}\n\telse\n\t{\n\t\tProcessInvalidationMessages(&myInfo->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t\tLocalExecuteInvalidationMessage);\n\n\t\t/* Pop the transaction state stack */\n\t\ttransInvalInfo = myInfo->parent;\n\n\t\t/* Need not free anything else explicitly */\n\t\tpfree(myInfo);\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TransInvalidationInfo *transInvalInfo = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "myInfo"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ProcessInvalidationMessages",
          "args": [
            "&myInfo->PriorCmdInvalidMsgs",
            "LocalExecuteInvalidationMessage"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessInvalidationMessagesMulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "467-473",
          "snippet": "static void\nProcessInvalidationMessagesMulti(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t\t void (*func) (const SharedInvalidationMessage *msgs, int n))\n{\n\tProcessMessageListMulti(hdr->cclist, func(msgs, n));\n\tProcessMessageListMulti(hdr->rclist, func(msgs, n));\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nProcessInvalidationMessagesMulti(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t\t void (*func) (const SharedInvalidationMessage *msgs, int n))\n{\n\tProcessMessageListMulti(hdr->cclist, func(msgs, n));\n\tProcessMessageListMulti(hdr->rclist, func(msgs, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "AppendInvalidationMessages",
          "args": [
            "&myInfo->parent->PriorCmdInvalidMsgs",
            "&myInfo->PriorCmdInvalidMsgs"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "AppendInvalidationMessages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "441-447",
          "snippet": "static void\nAppendInvalidationMessages(InvalidationListHeader *dest,\n\t\t\t\t\t\t   InvalidationListHeader *src)\n{\n\tAppendInvalidationMessageList(&dest->cclist, &src->cclist);\n\tAppendInvalidationMessageList(&dest->rclist, &src->rclist);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nAppendInvalidationMessages(InvalidationListHeader *dest,\n\t\t\t\t\t\t   InvalidationListHeader *src)\n{\n\tAppendInvalidationMessageList(&dest->cclist, &src->cclist);\n\tAppendInvalidationMessageList(&dest->rclist, &src->rclist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CommandEndInvalidationMessages",
          "args": [],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "CommandEndInvalidationMessages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "1084-1099",
          "snippet": "void\nCommandEndInvalidationMessages(void)\n{\n\t/*\n\t * You might think this shouldn't be called outside any transaction, but\n\t * bootstrap does it, and also ABORT issued when not in a transaction. So\n\t * just quietly return if no state to work on.\n\t */\n\tif (transInvalInfo == NULL)\n\t\treturn;\n\n\tProcessInvalidationMessages(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\tLocalExecuteInvalidationMessage);\n\tAppendInvalidationMessages(&transInvalInfo->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t   &transInvalInfo->CurrentCmdInvalidMsgs);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TransInvalidationInfo *transInvalInfo = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\n\nvoid\nCommandEndInvalidationMessages(void)\n{\n\t/*\n\t * You might think this shouldn't be called outside any transaction, but\n\t * bootstrap does it, and also ABORT issued when not in a transaction. So\n\t * just quietly return if no state to work on.\n\t */\n\tif (transInvalInfo == NULL)\n\t\treturn;\n\n\tProcessInvalidationMessages(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\tLocalExecuteInvalidationMessage);\n\tAppendInvalidationMessages(&transInvalInfo->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t   &transInvalInfo->CurrentCmdInvalidMsgs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "myInfo->my_level < my_level"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentTransactionNestLevel",
          "args": [],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\n\nvoid\nAtEOSubXact_Inval(bool isCommit)\n{\n\tint\t\t\tmy_level;\n\tTransInvalidationInfo *myInfo = transInvalInfo;\n\n\t/* Quick exit if no messages. */\n\tif (myInfo == NULL)\n\t\treturn;\n\n\t/* Also bail out quickly if messages are not for this level. */\n\tmy_level = GetCurrentTransactionNestLevel();\n\tif (myInfo->my_level != my_level)\n\t{\n\t\tAssert(myInfo->my_level < my_level);\n\t\treturn;\n\t}\n\n\tif (isCommit)\n\t{\n\t\t/* If CurrentCmdInvalidMsgs still has anything, fix it */\n\t\tCommandEndInvalidationMessages();\n\n\t\t/*\n\t\t * We create invalidation stack entries lazily, so the parent might\n\t\t * not have one.  Instead of creating one, moving all the data over,\n\t\t * and then freeing our own, we can just adjust the level of our own\n\t\t * entry.\n\t\t */\n\t\tif (myInfo->parent == NULL || myInfo->parent->my_level < my_level - 1)\n\t\t{\n\t\t\tmyInfo->my_level--;\n\t\t\treturn;\n\t\t}\n\n\t\t/* Pass up my inval messages to parent */\n\t\tAppendInvalidationMessages(&myInfo->parent->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   &myInfo->PriorCmdInvalidMsgs);\n\n\t\t/* Pending relcache inval becomes parent's problem too */\n\t\tif (myInfo->RelcacheInitFileInval)\n\t\t\tmyInfo->parent->RelcacheInitFileInval = true;\n\n\t\t/* Pop the transaction state stack */\n\t\ttransInvalInfo = myInfo->parent;\n\n\t\t/* Need not free anything else explicitly */\n\t\tpfree(myInfo);\n\t}\n\telse\n\t{\n\t\tProcessInvalidationMessages(&myInfo->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t\tLocalExecuteInvalidationMessage);\n\n\t\t/* Pop the transaction state stack */\n\t\ttransInvalInfo = myInfo->parent;\n\n\t\t/* Need not free anything else explicitly */\n\t\tpfree(myInfo);\n\t}\n}"
  },
  {
    "function_name": "AtEOXact_Inval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "948-987",
    "snippet": "void\nAtEOXact_Inval(bool isCommit)\n{\n\t/* Quick exit if no messages */\n\tif (transInvalInfo == NULL)\n\t\treturn;\n\n\t/* Must be at top of stack */\n\tAssert(transInvalInfo->my_level == 1 && transInvalInfo->parent == NULL);\n\n\tif (isCommit)\n\t{\n\t\t/*\n\t\t * Relcache init file invalidation requires processing both before and\n\t\t * after we send the SI messages.  However, we need not do anything\n\t\t * unless we committed.\n\t\t */\n\t\tif (transInvalInfo->RelcacheInitFileInval)\n\t\t\tRelationCacheInitFilePreInvalidate();\n\n\t\tAppendInvalidationMessages(&transInvalInfo->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   &transInvalInfo->CurrentCmdInvalidMsgs);\n\n\t\tProcessInvalidationMessagesMulti(&transInvalInfo->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t\t\t SendSharedInvalidMessages);\n\n\t\tif (transInvalInfo->RelcacheInitFileInval)\n\t\t\tRelationCacheInitFilePostInvalidate();\n\t}\n\telse\n\t{\n\t\tProcessInvalidationMessages(&transInvalInfo->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t\tLocalExecuteInvalidationMessage);\n\t}\n\n\t/* Need not free anything explicitly */\n\ttransInvalInfo = NULL;\n\tSharedInvalidMessagesArray = NULL;\n\tnumSharedInvalidMessagesArray = 0;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TransInvalidationInfo *transInvalInfo = NULL;",
      "static SharedInvalidationMessage *SharedInvalidMessagesArray;",
      "static int\tnumSharedInvalidMessagesArray;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ProcessInvalidationMessages",
          "args": [
            "&transInvalInfo->PriorCmdInvalidMsgs",
            "LocalExecuteInvalidationMessage"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessInvalidationMessagesMulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "467-473",
          "snippet": "static void\nProcessInvalidationMessagesMulti(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t\t void (*func) (const SharedInvalidationMessage *msgs, int n))\n{\n\tProcessMessageListMulti(hdr->cclist, func(msgs, n));\n\tProcessMessageListMulti(hdr->rclist, func(msgs, n));\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nProcessInvalidationMessagesMulti(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t\t void (*func) (const SharedInvalidationMessage *msgs, int n))\n{\n\tProcessMessageListMulti(hdr->cclist, func(msgs, n));\n\tProcessMessageListMulti(hdr->rclist, func(msgs, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationCacheInitFilePostInvalidate",
          "args": [],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "RelationCacheInitFilePostInvalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "6117-6121",
          "snippet": "void\nRelationCacheInitFilePostInvalidate(void)\n{\n\tLWLockRelease(RelCacheInitLock);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nvoid\nRelationCacheInitFilePostInvalidate(void)\n{\n\tLWLockRelease(RelCacheInitLock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AppendInvalidationMessages",
          "args": [
            "&transInvalInfo->PriorCmdInvalidMsgs",
            "&transInvalInfo->CurrentCmdInvalidMsgs"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "AppendInvalidationMessages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "441-447",
          "snippet": "static void\nAppendInvalidationMessages(InvalidationListHeader *dest,\n\t\t\t\t\t\t   InvalidationListHeader *src)\n{\n\tAppendInvalidationMessageList(&dest->cclist, &src->cclist);\n\tAppendInvalidationMessageList(&dest->rclist, &src->rclist);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nAppendInvalidationMessages(InvalidationListHeader *dest,\n\t\t\t\t\t\t   InvalidationListHeader *src)\n{\n\tAppendInvalidationMessageList(&dest->cclist, &src->cclist);\n\tAppendInvalidationMessageList(&dest->rclist, &src->rclist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationCacheInitFilePreInvalidate",
          "args": [],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "RelationCacheInitFilePreInvalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "6092-6115",
          "snippet": "void\nRelationCacheInitFilePreInvalidate(void)\n{\n\tchar\t\tlocalinitfname[MAXPGPATH];\n\tchar\t\tsharedinitfname[MAXPGPATH];\n\n\tif (DatabasePath)\n\t\tsnprintf(localinitfname, sizeof(localinitfname), \"%s/%s\",\n\t\t\t\t DatabasePath, RELCACHE_INIT_FILENAME);\n\tsnprintf(sharedinitfname, sizeof(sharedinitfname), \"global/%s\",\n\t\t\t RELCACHE_INIT_FILENAME);\n\n\tLWLockAcquire(RelCacheInitLock, LW_EXCLUSIVE);\n\n\t/*\n\t * The files might not be there if no backend has been started since the\n\t * last removal.  But complain about failures other than ENOENT with\n\t * ERROR.  Fortunately, it's not too late to abort the transaction if we\n\t * can't get rid of the would-be-obsolete init file.\n\t */\n\tif (DatabasePath)\n\t\tunlink_initfile(localinitfname, ERROR);\n\tunlink_initfile(sharedinitfname, ERROR);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nvoid\nRelationCacheInitFilePreInvalidate(void)\n{\n\tchar\t\tlocalinitfname[MAXPGPATH];\n\tchar\t\tsharedinitfname[MAXPGPATH];\n\n\tif (DatabasePath)\n\t\tsnprintf(localinitfname, sizeof(localinitfname), \"%s/%s\",\n\t\t\t\t DatabasePath, RELCACHE_INIT_FILENAME);\n\tsnprintf(sharedinitfname, sizeof(sharedinitfname), \"global/%s\",\n\t\t\t RELCACHE_INIT_FILENAME);\n\n\tLWLockAcquire(RelCacheInitLock, LW_EXCLUSIVE);\n\n\t/*\n\t * The files might not be there if no backend has been started since the\n\t * last removal.  But complain about failures other than ENOENT with\n\t * ERROR.  Fortunately, it's not too late to abort the transaction if we\n\t * can't get rid of the would-be-obsolete init file.\n\t */\n\tif (DatabasePath)\n\t\tunlink_initfile(localinitfname, ERROR);\n\tunlink_initfile(sharedinitfname, ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "transInvalInfo->my_level == 1 && transInvalInfo->parent == NULL"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\nstatic SharedInvalidationMessage *SharedInvalidMessagesArray;\nstatic int\tnumSharedInvalidMessagesArray;\n\nvoid\nAtEOXact_Inval(bool isCommit)\n{\n\t/* Quick exit if no messages */\n\tif (transInvalInfo == NULL)\n\t\treturn;\n\n\t/* Must be at top of stack */\n\tAssert(transInvalInfo->my_level == 1 && transInvalInfo->parent == NULL);\n\n\tif (isCommit)\n\t{\n\t\t/*\n\t\t * Relcache init file invalidation requires processing both before and\n\t\t * after we send the SI messages.  However, we need not do anything\n\t\t * unless we committed.\n\t\t */\n\t\tif (transInvalInfo->RelcacheInitFileInval)\n\t\t\tRelationCacheInitFilePreInvalidate();\n\n\t\tAppendInvalidationMessages(&transInvalInfo->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   &transInvalInfo->CurrentCmdInvalidMsgs);\n\n\t\tProcessInvalidationMessagesMulti(&transInvalInfo->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t\t\t SendSharedInvalidMessages);\n\n\t\tif (transInvalInfo->RelcacheInitFileInval)\n\t\t\tRelationCacheInitFilePostInvalidate();\n\t}\n\telse\n\t{\n\t\tProcessInvalidationMessages(&transInvalInfo->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t\tLocalExecuteInvalidationMessage);\n\t}\n\n\t/* Need not free anything explicitly */\n\ttransInvalInfo = NULL;\n\tSharedInvalidMessagesArray = NULL;\n\tnumSharedInvalidMessagesArray = 0;\n}"
  },
  {
    "function_name": "ProcessCommittedInvalidationMessages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "883-922",
    "snippet": "void\nProcessCommittedInvalidationMessages(SharedInvalidationMessage *msgs,\n\t\t\t\t\t\t\t\t\t int nmsgs, bool RelcacheInitFileInval,\n\t\t\t\t\t\t\t\t\t Oid dbid, Oid tsid)\n{\n\tif (nmsgs <= 0)\n\t\treturn;\n\n\telog(trace_recovery(DEBUG4), \"replaying commit with %d messages%s\", nmsgs,\n\t\t (RelcacheInitFileInval ? \" and relcache file invalidation\" : \"\"));\n\n\tif (RelcacheInitFileInval)\n\t{\n\t\telog(trace_recovery(DEBUG4), \"removing relcache init files for database %u\",\n\t\t\t dbid);\n\n\t\t/*\n\t\t * RelationCacheInitFilePreInvalidate, when the invalidation message\n\t\t * is for a specific database, requires DatabasePath to be set, but we\n\t\t * should not use SetDatabasePath during recovery, since it is\n\t\t * intended to be used only once by normal backends.  Hence, a quick\n\t\t * hack: set DatabasePath directly then unset after use.\n\t\t */\n\t\tif (OidIsValid(dbid))\n\t\t\tDatabasePath = GetDatabasePath(dbid, tsid);\n\n\t\tRelationCacheInitFilePreInvalidate();\n\n\t\tif (OidIsValid(dbid))\n\t\t{\n\t\t\tpfree(DatabasePath);\n\t\t\tDatabasePath = NULL;\n\t\t}\n\t}\n\n\tSendSharedInvalidMessages(msgs, nmsgs);\n\n\tif (RelcacheInitFileInval)\n\t\tRelationCacheInitFilePostInvalidate();\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RelationCacheInitFilePostInvalidate",
          "args": [],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "RelationCacheInitFilePostInvalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "6117-6121",
          "snippet": "void\nRelationCacheInitFilePostInvalidate(void)\n{\n\tLWLockRelease(RelCacheInitLock);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nvoid\nRelationCacheInitFilePostInvalidate(void)\n{\n\tLWLockRelease(RelCacheInitLock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SendSharedInvalidMessages",
          "args": [
            "msgs",
            "nmsgs"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "DatabasePath"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "dbid"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationCacheInitFilePreInvalidate",
          "args": [],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "RelationCacheInitFilePreInvalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "6092-6115",
          "snippet": "void\nRelationCacheInitFilePreInvalidate(void)\n{\n\tchar\t\tlocalinitfname[MAXPGPATH];\n\tchar\t\tsharedinitfname[MAXPGPATH];\n\n\tif (DatabasePath)\n\t\tsnprintf(localinitfname, sizeof(localinitfname), \"%s/%s\",\n\t\t\t\t DatabasePath, RELCACHE_INIT_FILENAME);\n\tsnprintf(sharedinitfname, sizeof(sharedinitfname), \"global/%s\",\n\t\t\t RELCACHE_INIT_FILENAME);\n\n\tLWLockAcquire(RelCacheInitLock, LW_EXCLUSIVE);\n\n\t/*\n\t * The files might not be there if no backend has been started since the\n\t * last removal.  But complain about failures other than ENOENT with\n\t * ERROR.  Fortunately, it's not too late to abort the transaction if we\n\t * can't get rid of the would-be-obsolete init file.\n\t */\n\tif (DatabasePath)\n\t\tunlink_initfile(localinitfname, ERROR);\n\tunlink_initfile(sharedinitfname, ERROR);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nvoid\nRelationCacheInitFilePreInvalidate(void)\n{\n\tchar\t\tlocalinitfname[MAXPGPATH];\n\tchar\t\tsharedinitfname[MAXPGPATH];\n\n\tif (DatabasePath)\n\t\tsnprintf(localinitfname, sizeof(localinitfname), \"%s/%s\",\n\t\t\t\t DatabasePath, RELCACHE_INIT_FILENAME);\n\tsnprintf(sharedinitfname, sizeof(sharedinitfname), \"global/%s\",\n\t\t\t RELCACHE_INIT_FILENAME);\n\n\tLWLockAcquire(RelCacheInitLock, LW_EXCLUSIVE);\n\n\t/*\n\t * The files might not be there if no backend has been started since the\n\t * last removal.  But complain about failures other than ENOENT with\n\t * ERROR.  Fortunately, it's not too late to abort the transaction if we\n\t * can't get rid of the would-be-obsolete init file.\n\t */\n\tif (DatabasePath)\n\t\tunlink_initfile(localinitfname, ERROR);\n\tunlink_initfile(sharedinitfname, ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDatabasePath",
          "args": [
            "dbid",
            "tsid"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "dbid"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "trace_recovery(DEBUG4)",
            "\"removing relcache init files for database %u\"",
            "dbid"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_recovery",
          "args": [
            "DEBUG4"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "trace_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3750-3758",
          "snippet": "int\ntrace_recovery(int trace_level)\n{\n\tif (trace_level < LOG &&\n\t\ttrace_level >= trace_recovery_messages)\n\t\treturn LOG;\n\n\treturn trace_level;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nint\ntrace_recovery(int trace_level)\n{\n\tif (trace_level < LOG &&\n\t\ttrace_level >= trace_recovery_messages)\n\t\treturn LOG;\n\n\treturn trace_level;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nProcessCommittedInvalidationMessages(SharedInvalidationMessage *msgs,\n\t\t\t\t\t\t\t\t\t int nmsgs, bool RelcacheInitFileInval,\n\t\t\t\t\t\t\t\t\t Oid dbid, Oid tsid)\n{\n\tif (nmsgs <= 0)\n\t\treturn;\n\n\telog(trace_recovery(DEBUG4), \"replaying commit with %d messages%s\", nmsgs,\n\t\t (RelcacheInitFileInval ? \" and relcache file invalidation\" : \"\"));\n\n\tif (RelcacheInitFileInval)\n\t{\n\t\telog(trace_recovery(DEBUG4), \"removing relcache init files for database %u\",\n\t\t\t dbid);\n\n\t\t/*\n\t\t * RelationCacheInitFilePreInvalidate, when the invalidation message\n\t\t * is for a specific database, requires DatabasePath to be set, but we\n\t\t * should not use SetDatabasePath during recovery, since it is\n\t\t * intended to be used only once by normal backends.  Hence, a quick\n\t\t * hack: set DatabasePath directly then unset after use.\n\t\t */\n\t\tif (OidIsValid(dbid))\n\t\t\tDatabasePath = GetDatabasePath(dbid, tsid);\n\n\t\tRelationCacheInitFilePreInvalidate();\n\n\t\tif (OidIsValid(dbid))\n\t\t{\n\t\t\tpfree(DatabasePath);\n\t\t\tDatabasePath = NULL;\n\t\t}\n\t}\n\n\tSendSharedInvalidMessages(msgs, nmsgs);\n\n\tif (RelcacheInitFileInval)\n\t\tRelationCacheInitFilePostInvalidate();\n}"
  },
  {
    "function_name": "xactGetCommittedInvalidationMessages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "827-873",
    "snippet": "int\nxactGetCommittedInvalidationMessages(SharedInvalidationMessage **msgs,\n\t\t\t\t\t\t\t\t\t bool *RelcacheInitFileInval)\n{\n\tMemoryContext oldcontext;\n\n\t/* Quick exit if we haven't done anything with invalidation messages. */\n\tif (transInvalInfo == NULL)\n\t{\n\t\t*RelcacheInitFileInval = false;\n\t\t*msgs = NULL;\n\t\treturn 0;\n\t}\n\n\t/* Must be at top of stack */\n\tAssert(transInvalInfo->my_level == 1 && transInvalInfo->parent == NULL);\n\n\t/*\n\t * Relcache init file invalidation requires processing both before and\n\t * after we send the SI messages.  However, we need not do anything unless\n\t * we committed.\n\t */\n\t*RelcacheInitFileInval = transInvalInfo->RelcacheInitFileInval;\n\n\t/*\n\t * Walk through TransInvalidationInfo to collect all the messages into a\n\t * single contiguous array of invalidation messages. It must be contiguous\n\t * so we can copy directly into WAL message. Maintain the order that they\n\t * would be processed in by AtEOXact_Inval(), to ensure emulated behaviour\n\t * in redo is as similar as possible to original. We want the same bugs,\n\t * if any, not new ones.\n\t */\n\toldcontext = MemoryContextSwitchTo(CurTransactionContext);\n\n\tProcessInvalidationMessagesMulti(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t\t MakeSharedInvalidMessagesArray);\n\tProcessInvalidationMessagesMulti(&transInvalInfo->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t\t MakeSharedInvalidMessagesArray);\n\tMemoryContextSwitchTo(oldcontext);\n\n\tAssert(!(numSharedInvalidMessagesArray > 0 &&\n\t\t\t SharedInvalidMessagesArray == NULL));\n\n\t*msgs = SharedInvalidMessagesArray;\n\n\treturn numSharedInvalidMessagesArray;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TransInvalidationInfo *transInvalInfo = NULL;",
      "static SharedInvalidationMessage *SharedInvalidMessagesArray;",
      "static int\tnumSharedInvalidMessagesArray;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!(numSharedInvalidMessagesArray > 0 &&\n\t\t\t SharedInvalidMessagesArray == NULL)"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ProcessInvalidationMessagesMulti",
          "args": [
            "&transInvalInfo->PriorCmdInvalidMsgs",
            "MakeSharedInvalidMessagesArray"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessInvalidationMessagesMulti",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "467-473",
          "snippet": "static void\nProcessInvalidationMessagesMulti(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t\t void (*func) (const SharedInvalidationMessage *msgs, int n))\n{\n\tProcessMessageListMulti(hdr->cclist, func(msgs, n));\n\tProcessMessageListMulti(hdr->rclist, func(msgs, n));\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nProcessInvalidationMessagesMulti(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t\t void (*func) (const SharedInvalidationMessage *msgs, int n))\n{\n\tProcessMessageListMulti(hdr->cclist, func(msgs, n));\n\tProcessMessageListMulti(hdr->rclist, func(msgs, n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CurTransactionContext"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "transInvalInfo->my_level == 1 && transInvalInfo->parent == NULL"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\nstatic SharedInvalidationMessage *SharedInvalidMessagesArray;\nstatic int\tnumSharedInvalidMessagesArray;\n\nint\nxactGetCommittedInvalidationMessages(SharedInvalidationMessage **msgs,\n\t\t\t\t\t\t\t\t\t bool *RelcacheInitFileInval)\n{\n\tMemoryContext oldcontext;\n\n\t/* Quick exit if we haven't done anything with invalidation messages. */\n\tif (transInvalInfo == NULL)\n\t{\n\t\t*RelcacheInitFileInval = false;\n\t\t*msgs = NULL;\n\t\treturn 0;\n\t}\n\n\t/* Must be at top of stack */\n\tAssert(transInvalInfo->my_level == 1 && transInvalInfo->parent == NULL);\n\n\t/*\n\t * Relcache init file invalidation requires processing both before and\n\t * after we send the SI messages.  However, we need not do anything unless\n\t * we committed.\n\t */\n\t*RelcacheInitFileInval = transInvalInfo->RelcacheInitFileInval;\n\n\t/*\n\t * Walk through TransInvalidationInfo to collect all the messages into a\n\t * single contiguous array of invalidation messages. It must be contiguous\n\t * so we can copy directly into WAL message. Maintain the order that they\n\t * would be processed in by AtEOXact_Inval(), to ensure emulated behaviour\n\t * in redo is as similar as possible to original. We want the same bugs,\n\t * if any, not new ones.\n\t */\n\toldcontext = MemoryContextSwitchTo(CurTransactionContext);\n\n\tProcessInvalidationMessagesMulti(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t\t MakeSharedInvalidMessagesArray);\n\tProcessInvalidationMessagesMulti(&transInvalInfo->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t\t MakeSharedInvalidMessagesArray);\n\tMemoryContextSwitchTo(oldcontext);\n\n\tAssert(!(numSharedInvalidMessagesArray > 0 &&\n\t\t\t SharedInvalidMessagesArray == NULL));\n\n\t*msgs = SharedInvalidMessagesArray;\n\n\treturn numSharedInvalidMessagesArray;\n}"
  },
  {
    "function_name": "MakeSharedInvalidMessagesArray",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "777-812",
    "snippet": "static void\nMakeSharedInvalidMessagesArray(const SharedInvalidationMessage *msgs, int n)\n{\n\t/*\n\t * Initialise array first time through in each commit\n\t */\n\tif (SharedInvalidMessagesArray == NULL)\n\t{\n\t\tmaxSharedInvalidMessagesArray = FIRSTCHUNKSIZE;\n\t\tnumSharedInvalidMessagesArray = 0;\n\n\t\t/*\n\t\t * Although this is being palloc'd we don't actually free it directly.\n\t\t * We're so close to EOXact that we now we're going to lose it anyhow.\n\t\t */\n\t\tSharedInvalidMessagesArray = palloc(maxSharedInvalidMessagesArray\n\t\t\t\t\t\t\t\t\t\t\t* sizeof(SharedInvalidationMessage));\n\t}\n\n\tif ((numSharedInvalidMessagesArray + n) > maxSharedInvalidMessagesArray)\n\t{\n\t\twhile ((numSharedInvalidMessagesArray + n) > maxSharedInvalidMessagesArray)\n\t\t\tmaxSharedInvalidMessagesArray *= 2;\n\n\t\tSharedInvalidMessagesArray = repalloc(SharedInvalidMessagesArray,\n\t\t\t\t\t\t\t\t\t\t\t  maxSharedInvalidMessagesArray\n\t\t\t\t\t\t\t\t\t\t\t  * sizeof(SharedInvalidationMessage));\n\t}\n\n\t/*\n\t * Append the next chunk onto the array\n\t */\n\tmemcpy(SharedInvalidMessagesArray + numSharedInvalidMessagesArray,\n\t\t   msgs, n * sizeof(SharedInvalidationMessage));\n\tnumSharedInvalidMessagesArray += n;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FIRSTCHUNKSIZE 32"
    ],
    "globals_used": [
      "static SharedInvalidationMessage *SharedInvalidMessagesArray;",
      "static int\tnumSharedInvalidMessagesArray;",
      "static int\tmaxSharedInvalidMessagesArray;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "SharedInvalidMessagesArray + numSharedInvalidMessagesArray",
            "msgs",
            "n * sizeof(SharedInvalidationMessage)"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "SharedInvalidMessagesArray",
            "maxSharedInvalidMessagesArray\n\t\t\t\t\t\t\t\t\t\t\t  * sizeof(SharedInvalidationMessage)"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "repalloc_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1113-1141",
          "snippet": "void *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "maxSharedInvalidMessagesArray\n\t\t\t\t\t\t\t\t\t\t\t* sizeof(SharedInvalidationMessage)"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define FIRSTCHUNKSIZE 32\n\nstatic SharedInvalidationMessage *SharedInvalidMessagesArray;\nstatic int\tnumSharedInvalidMessagesArray;\nstatic int\tmaxSharedInvalidMessagesArray;\n\nstatic void\nMakeSharedInvalidMessagesArray(const SharedInvalidationMessage *msgs, int n)\n{\n\t/*\n\t * Initialise array first time through in each commit\n\t */\n\tif (SharedInvalidMessagesArray == NULL)\n\t{\n\t\tmaxSharedInvalidMessagesArray = FIRSTCHUNKSIZE;\n\t\tnumSharedInvalidMessagesArray = 0;\n\n\t\t/*\n\t\t * Although this is being palloc'd we don't actually free it directly.\n\t\t * We're so close to EOXact that we now we're going to lose it anyhow.\n\t\t */\n\t\tSharedInvalidMessagesArray = palloc(maxSharedInvalidMessagesArray\n\t\t\t\t\t\t\t\t\t\t\t* sizeof(SharedInvalidationMessage));\n\t}\n\n\tif ((numSharedInvalidMessagesArray + n) > maxSharedInvalidMessagesArray)\n\t{\n\t\twhile ((numSharedInvalidMessagesArray + n) > maxSharedInvalidMessagesArray)\n\t\t\tmaxSharedInvalidMessagesArray *= 2;\n\n\t\tSharedInvalidMessagesArray = repalloc(SharedInvalidMessagesArray,\n\t\t\t\t\t\t\t\t\t\t\t  maxSharedInvalidMessagesArray\n\t\t\t\t\t\t\t\t\t\t\t  * sizeof(SharedInvalidationMessage));\n\t}\n\n\t/*\n\t * Append the next chunk onto the array\n\t */\n\tmemcpy(SharedInvalidMessagesArray + numSharedInvalidMessagesArray,\n\t\t   msgs, n * sizeof(SharedInvalidationMessage));\n\tnumSharedInvalidMessagesArray += n;\n}"
  },
  {
    "function_name": "PostPrepare_Inval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "768-772",
    "snippet": "void\nPostPrepare_Inval(void)\n{\n\tAtEOXact_Inval(false);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AtEOXact_Inval",
          "args": [
            "false"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "AtEOXact_Inval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "948-987",
          "snippet": "void\nAtEOXact_Inval(bool isCommit)\n{\n\t/* Quick exit if no messages */\n\tif (transInvalInfo == NULL)\n\t\treturn;\n\n\t/* Must be at top of stack */\n\tAssert(transInvalInfo->my_level == 1 && transInvalInfo->parent == NULL);\n\n\tif (isCommit)\n\t{\n\t\t/*\n\t\t * Relcache init file invalidation requires processing both before and\n\t\t * after we send the SI messages.  However, we need not do anything\n\t\t * unless we committed.\n\t\t */\n\t\tif (transInvalInfo->RelcacheInitFileInval)\n\t\t\tRelationCacheInitFilePreInvalidate();\n\n\t\tAppendInvalidationMessages(&transInvalInfo->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   &transInvalInfo->CurrentCmdInvalidMsgs);\n\n\t\tProcessInvalidationMessagesMulti(&transInvalInfo->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t\t\t SendSharedInvalidMessages);\n\n\t\tif (transInvalInfo->RelcacheInitFileInval)\n\t\t\tRelationCacheInitFilePostInvalidate();\n\t}\n\telse\n\t{\n\t\tProcessInvalidationMessages(&transInvalInfo->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t\tLocalExecuteInvalidationMessage);\n\t}\n\n\t/* Need not free anything explicitly */\n\ttransInvalInfo = NULL;\n\tSharedInvalidMessagesArray = NULL;\n\tnumSharedInvalidMessagesArray = 0;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TransInvalidationInfo *transInvalInfo = NULL;",
            "static SharedInvalidationMessage *SharedInvalidMessagesArray;",
            "static int\tnumSharedInvalidMessagesArray;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\nstatic SharedInvalidationMessage *SharedInvalidMessagesArray;\nstatic int\tnumSharedInvalidMessagesArray;\n\nvoid\nAtEOXact_Inval(bool isCommit)\n{\n\t/* Quick exit if no messages */\n\tif (transInvalInfo == NULL)\n\t\treturn;\n\n\t/* Must be at top of stack */\n\tAssert(transInvalInfo->my_level == 1 && transInvalInfo->parent == NULL);\n\n\tif (isCommit)\n\t{\n\t\t/*\n\t\t * Relcache init file invalidation requires processing both before and\n\t\t * after we send the SI messages.  However, we need not do anything\n\t\t * unless we committed.\n\t\t */\n\t\tif (transInvalInfo->RelcacheInitFileInval)\n\t\t\tRelationCacheInitFilePreInvalidate();\n\n\t\tAppendInvalidationMessages(&transInvalInfo->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   &transInvalInfo->CurrentCmdInvalidMsgs);\n\n\t\tProcessInvalidationMessagesMulti(&transInvalInfo->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t\t\t SendSharedInvalidMessages);\n\n\t\tif (transInvalInfo->RelcacheInitFileInval)\n\t\t\tRelationCacheInitFilePostInvalidate();\n\t}\n\telse\n\t{\n\t\tProcessInvalidationMessages(&transInvalInfo->PriorCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t\tLocalExecuteInvalidationMessage);\n\t}\n\n\t/* Need not free anything explicitly */\n\ttransInvalInfo = NULL;\n\tSharedInvalidMessagesArray = NULL;\n\tnumSharedInvalidMessagesArray = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nPostPrepare_Inval(void)\n{\n\tAtEOXact_Inval(false);\n}"
  },
  {
    "function_name": "PrepareInvalidationState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "731-754",
    "snippet": "static void\nPrepareInvalidationState(void)\n{\n\tTransInvalidationInfo *myInfo;\n\n\tif (transInvalInfo != NULL &&\n\t\ttransInvalInfo->my_level == GetCurrentTransactionNestLevel())\n\t\treturn;\n\n\tmyInfo = (TransInvalidationInfo *)\n\t\tMemoryContextAllocZero(TopTransactionContext,\n\t\t\t\t\t\t\t   sizeof(TransInvalidationInfo));\n\tmyInfo->parent = transInvalInfo;\n\tmyInfo->my_level = GetCurrentTransactionNestLevel();\n\n\t/*\n\t * If there's any previous entry, this one should be for a deeper nesting\n\t * level.\n\t */\n\tAssert(transInvalInfo == NULL ||\n\t\t   myInfo->my_level > transInvalInfo->my_level);\n\n\ttransInvalInfo = myInfo;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TransInvalidationInfo *transInvalInfo = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "transInvalInfo == NULL ||\n\t\t   myInfo->my_level > transInvalInfo->my_level"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentTransactionNestLevel",
          "args": [],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "TopTransactionContext",
            "sizeof(TransInvalidationInfo)"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentTransactionNestLevel",
          "args": [],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\n\nstatic void\nPrepareInvalidationState(void)\n{\n\tTransInvalidationInfo *myInfo;\n\n\tif (transInvalInfo != NULL &&\n\t\ttransInvalInfo->my_level == GetCurrentTransactionNestLevel())\n\t\treturn;\n\n\tmyInfo = (TransInvalidationInfo *)\n\t\tMemoryContextAllocZero(TopTransactionContext,\n\t\t\t\t\t\t\t   sizeof(TransInvalidationInfo));\n\tmyInfo->parent = transInvalInfo;\n\tmyInfo->my_level = GetCurrentTransactionNestLevel();\n\n\t/*\n\t * If there's any previous entry, this one should be for a deeper nesting\n\t * level.\n\t */\n\tAssert(transInvalInfo == NULL ||\n\t\t   myInfo->my_level > transInvalInfo->my_level);\n\n\ttransInvalInfo = myInfo;\n}"
  },
  {
    "function_name": "AcceptInvalidationMessages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "680-725",
    "snippet": "void\nAcceptInvalidationMessages(void)\n{\n\tReceiveSharedInvalidMessages(LocalExecuteInvalidationMessage,\n\t\t\t\t\t\t\t\t InvalidateSystemCaches);\n\n\t/*\n\t * Test code to force cache flushes anytime a flush could happen.\n\t *\n\t * If used with CLOBBER_FREED_MEMORY, CLOBBER_CACHE_ALWAYS provides a\n\t * fairly thorough test that the system contains no cache-flush hazards.\n\t * However, it also makes the system unbelievably slow --- the regression\n\t * tests take about 100 times longer than normal.\n\t *\n\t * If you're a glutton for punishment, try CLOBBER_CACHE_RECURSIVELY. This\n\t * slows things by at least a factor of 10000, so I wouldn't suggest\n\t * trying to run the entire regression tests that way.  It's useful to try\n\t * a few simple tests, to make sure that cache reload isn't subject to\n\t * internal cache-flush hazards, but after you've done a few thousand\n\t * recursive reloads it's unlikely you'll learn more.\n\t */\n#if defined(CLOBBER_CACHE_ALWAYS)\n\t{\n\t\tstatic bool in_recursion = false;\n\n\t\tif (!in_recursion)\n\t\t{\n\t\t\tin_recursion = true;\n\t\t\tInvalidateSystemCaches();\n\t\t\tin_recursion = false;\n\t\t}\n\t}\n#elif defined(CLOBBER_CACHE_RECURSIVELY)\n\t{\n\t\tstatic int\trecursion_depth = 0;\n\n\t\t/* Maximum depth is arbitrary depending on your threshold of pain */\n\t\tif (recursion_depth < 3)\n\t\t{\n\t\t\trecursion_depth++;\n\t\t\tInvalidateSystemCaches();\n\t\t\trecursion_depth--;\n\t\t}\n\t}\n#endif\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "InvalidateSystemCaches",
          "args": [],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "InvalidateSystemCaches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "642-664",
          "snippet": "void\nInvalidateSystemCaches(void)\n{\n\tint\t\t\ti;\n\n\tInvalidateCatalogSnapshot();\n\tResetCatalogCaches();\n\tRelationCacheInvalidate();\t/* gets smgr and relmap too */\n\n\tfor (i = 0; i < syscache_callback_count; i++)\n\t{\n\t\tstruct SYSCACHECALLBACK *ccitem = syscache_callback_list + i;\n\n\t\tccitem->function(ccitem->arg, ccitem->id, 0);\n\t}\n\n\tfor (i = 0; i < relcache_callback_count; i++)\n\t{\n\t\tstruct RELCACHECALLBACK *ccitem = relcache_callback_list + i;\n\n\t\tccitem->function(ccitem->arg, InvalidOid);\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];",
            "static int\tsyscache_callback_count = 0;",
            "static struct RELCACHECALLBACK\n{\n\tRelcacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\trelcache_callback_list[MAX_RELCACHE_CALLBACKS];",
            "static int\trelcache_callback_count = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];\nstatic int\tsyscache_callback_count = 0;\nstatic struct RELCACHECALLBACK\n{\n\tRelcacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\trelcache_callback_list[MAX_RELCACHE_CALLBACKS];\nstatic int\trelcache_callback_count = 0;\n\nvoid\nInvalidateSystemCaches(void)\n{\n\tint\t\t\ti;\n\n\tInvalidateCatalogSnapshot();\n\tResetCatalogCaches();\n\tRelationCacheInvalidate();\t/* gets smgr and relmap too */\n\n\tfor (i = 0; i < syscache_callback_count; i++)\n\t{\n\t\tstruct SYSCACHECALLBACK *ccitem = syscache_callback_list + i;\n\n\t\tccitem->function(ccitem->arg, ccitem->id, 0);\n\t}\n\n\tfor (i = 0; i < relcache_callback_count; i++)\n\t{\n\t\tstruct RELCACHECALLBACK *ccitem = relcache_callback_list + i;\n\n\t\tccitem->function(ccitem->arg, InvalidOid);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReceiveSharedInvalidMessages",
          "args": [
            "LocalExecuteInvalidationMessage",
            "InvalidateSystemCaches"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nAcceptInvalidationMessages(void)\n{\n\tReceiveSharedInvalidMessages(LocalExecuteInvalidationMessage,\n\t\t\t\t\t\t\t\t InvalidateSystemCaches);\n\n\t/*\n\t * Test code to force cache flushes anytime a flush could happen.\n\t *\n\t * If used with CLOBBER_FREED_MEMORY, CLOBBER_CACHE_ALWAYS provides a\n\t * fairly thorough test that the system contains no cache-flush hazards.\n\t * However, it also makes the system unbelievably slow --- the regression\n\t * tests take about 100 times longer than normal.\n\t *\n\t * If you're a glutton for punishment, try CLOBBER_CACHE_RECURSIVELY. This\n\t * slows things by at least a factor of 10000, so I wouldn't suggest\n\t * trying to run the entire regression tests that way.  It's useful to try\n\t * a few simple tests, to make sure that cache reload isn't subject to\n\t * internal cache-flush hazards, but after you've done a few thousand\n\t * recursive reloads it's unlikely you'll learn more.\n\t */\n#if defined(CLOBBER_CACHE_ALWAYS)\n\t{\n\t\tstatic bool in_recursion = false;\n\n\t\tif (!in_recursion)\n\t\t{\n\t\t\tin_recursion = true;\n\t\t\tInvalidateSystemCaches();\n\t\t\tin_recursion = false;\n\t\t}\n\t}\n#elif defined(CLOBBER_CACHE_RECURSIVELY)\n\t{\n\t\tstatic int\trecursion_depth = 0;\n\n\t\t/* Maximum depth is arbitrary depending on your threshold of pain */\n\t\tif (recursion_depth < 3)\n\t\t{\n\t\t\trecursion_depth++;\n\t\t\tInvalidateSystemCaches();\n\t\t\trecursion_depth--;\n\t\t}\n\t}\n#endif\n}"
  },
  {
    "function_name": "InvalidateSystemCaches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "642-664",
    "snippet": "void\nInvalidateSystemCaches(void)\n{\n\tint\t\t\ti;\n\n\tInvalidateCatalogSnapshot();\n\tResetCatalogCaches();\n\tRelationCacheInvalidate();\t/* gets smgr and relmap too */\n\n\tfor (i = 0; i < syscache_callback_count; i++)\n\t{\n\t\tstruct SYSCACHECALLBACK *ccitem = syscache_callback_list + i;\n\n\t\tccitem->function(ccitem->arg, ccitem->id, 0);\n\t}\n\n\tfor (i = 0; i < relcache_callback_count; i++)\n\t{\n\t\tstruct RELCACHECALLBACK *ccitem = relcache_callback_list + i;\n\n\t\tccitem->function(ccitem->arg, InvalidOid);\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];",
      "static int\tsyscache_callback_count = 0;",
      "static struct RELCACHECALLBACK\n{\n\tRelcacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\trelcache_callback_list[MAX_RELCACHE_CALLBACKS];",
      "static int\trelcache_callback_count = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ccitem->function",
          "args": [
            "ccitem->arg",
            "InvalidOid"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccitem->function",
          "args": [
            "ccitem->arg",
            "ccitem->id",
            "0"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationCacheInvalidate",
          "args": [],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "RelationCacheInvalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2673-2768",
          "snippet": "void\nRelationCacheInvalidate(void)\n{\n\tHASH_SEQ_STATUS status;\n\tRelIdCacheEnt *idhentry;\n\tRelation\trelation;\n\tList\t   *rebuildFirstList = NIL;\n\tList\t   *rebuildList = NIL;\n\tListCell   *l;\n\n\t/*\n\t * Reload relation mapping data before starting to reconstruct cache.\n\t */\n\tRelationMapInvalidateAll();\n\n\t/* Phase 1 */\n\thash_seq_init(&status, RelationIdCache);\n\n\twhile ((idhentry = (RelIdCacheEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\trelation = idhentry->reldesc;\n\n\t\t/* Must close all smgr references to avoid leaving dangling ptrs */\n\t\tRelationCloseSmgr(relation);\n\n\t\t/*\n\t\t * Ignore new relations; no other backend will manipulate them before\n\t\t * we commit.  Likewise, before replacing a relation's relfilenode, we\n\t\t * shall have acquired AccessExclusiveLock and drained any applicable\n\t\t * pending invalidations.\n\t\t */\n\t\tif (relation->rd_createSubid != InvalidSubTransactionId ||\n\t\t\trelation->rd_newRelfilenodeSubid != InvalidSubTransactionId)\n\t\t\tcontinue;\n\n\t\trelcacheInvalsReceived++;\n\n\t\tif (RelationHasReferenceCountZero(relation))\n\t\t{\n\t\t\t/* Delete this entry immediately */\n\t\t\tAssert(!relation->rd_isnailed);\n\t\t\tRelationClearRelation(relation, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If it's a mapped relation, immediately update its rd_node in\n\t\t\t * case its relfilenode changed.  We must do this during phase 1\n\t\t\t * in case the relation is consulted during rebuild of other\n\t\t\t * relcache entries in phase 2.  It's safe since consulting the\n\t\t\t * map doesn't involve any access to relcache entries.\n\t\t\t */\n\t\t\tif (RelationIsMapped(relation))\n\t\t\t\tRelationInitPhysicalAddr(relation);\n\n\t\t\t/*\n\t\t\t * Add this entry to list of stuff to rebuild in second pass.\n\t\t\t * pg_class goes to the front of rebuildFirstList while\n\t\t\t * pg_class_oid_index goes to the back of rebuildFirstList, so\n\t\t\t * they are done first and second respectively.  Other nailed\n\t\t\t * relations go to the front of rebuildList, so they'll be done\n\t\t\t * next in no particular order; and everything else goes to the\n\t\t\t * back of rebuildList.\n\t\t\t */\n\t\t\tif (RelationGetRelid(relation) == RelationRelationId)\n\t\t\t\trebuildFirstList = lcons(relation, rebuildFirstList);\n\t\t\telse if (RelationGetRelid(relation) == ClassOidIndexId)\n\t\t\t\trebuildFirstList = lappend(rebuildFirstList, relation);\n\t\t\telse if (relation->rd_isnailed)\n\t\t\t\trebuildList = lcons(relation, rebuildList);\n\t\t\telse\n\t\t\t\trebuildList = lappend(rebuildList, relation);\n\t\t}\n\t}\n\n\t/*\n\t * Now zap any remaining smgr cache entries.  This must happen before we\n\t * start to rebuild entries, since that may involve catalog fetches which\n\t * will re-open catalog files.\n\t */\n\tsmgrcloseall();\n\n\t/* Phase 2: rebuild the items found to need rebuild in phase 1 */\n\tforeach(l, rebuildFirstList)\n\t{\n\t\trelation = (Relation) lfirst(l);\n\t\tRelationClearRelation(relation, true);\n\t}\n\tlist_free(rebuildFirstList);\n\tforeach(l, rebuildList)\n\t{\n\t\trelation = (Relation) lfirst(l);\n\t\tRelationClearRelation(relation, true);\n\t}\n\tlist_free(rebuildList);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *RelationIdCache;",
            "static long relcacheInvalsReceived = 0L;",
            "static void RelationClearRelation(Relation relation, bool rebuild);",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic HTAB *RelationIdCache;\nstatic long relcacheInvalsReceived = 0L;\nstatic void RelationClearRelation(Relation relation, bool rebuild);\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationCacheInvalidate(void)\n{\n\tHASH_SEQ_STATUS status;\n\tRelIdCacheEnt *idhentry;\n\tRelation\trelation;\n\tList\t   *rebuildFirstList = NIL;\n\tList\t   *rebuildList = NIL;\n\tListCell   *l;\n\n\t/*\n\t * Reload relation mapping data before starting to reconstruct cache.\n\t */\n\tRelationMapInvalidateAll();\n\n\t/* Phase 1 */\n\thash_seq_init(&status, RelationIdCache);\n\n\twhile ((idhentry = (RelIdCacheEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\trelation = idhentry->reldesc;\n\n\t\t/* Must close all smgr references to avoid leaving dangling ptrs */\n\t\tRelationCloseSmgr(relation);\n\n\t\t/*\n\t\t * Ignore new relations; no other backend will manipulate them before\n\t\t * we commit.  Likewise, before replacing a relation's relfilenode, we\n\t\t * shall have acquired AccessExclusiveLock and drained any applicable\n\t\t * pending invalidations.\n\t\t */\n\t\tif (relation->rd_createSubid != InvalidSubTransactionId ||\n\t\t\trelation->rd_newRelfilenodeSubid != InvalidSubTransactionId)\n\t\t\tcontinue;\n\n\t\trelcacheInvalsReceived++;\n\n\t\tif (RelationHasReferenceCountZero(relation))\n\t\t{\n\t\t\t/* Delete this entry immediately */\n\t\t\tAssert(!relation->rd_isnailed);\n\t\t\tRelationClearRelation(relation, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If it's a mapped relation, immediately update its rd_node in\n\t\t\t * case its relfilenode changed.  We must do this during phase 1\n\t\t\t * in case the relation is consulted during rebuild of other\n\t\t\t * relcache entries in phase 2.  It's safe since consulting the\n\t\t\t * map doesn't involve any access to relcache entries.\n\t\t\t */\n\t\t\tif (RelationIsMapped(relation))\n\t\t\t\tRelationInitPhysicalAddr(relation);\n\n\t\t\t/*\n\t\t\t * Add this entry to list of stuff to rebuild in second pass.\n\t\t\t * pg_class goes to the front of rebuildFirstList while\n\t\t\t * pg_class_oid_index goes to the back of rebuildFirstList, so\n\t\t\t * they are done first and second respectively.  Other nailed\n\t\t\t * relations go to the front of rebuildList, so they'll be done\n\t\t\t * next in no particular order; and everything else goes to the\n\t\t\t * back of rebuildList.\n\t\t\t */\n\t\t\tif (RelationGetRelid(relation) == RelationRelationId)\n\t\t\t\trebuildFirstList = lcons(relation, rebuildFirstList);\n\t\t\telse if (RelationGetRelid(relation) == ClassOidIndexId)\n\t\t\t\trebuildFirstList = lappend(rebuildFirstList, relation);\n\t\t\telse if (relation->rd_isnailed)\n\t\t\t\trebuildList = lcons(relation, rebuildList);\n\t\t\telse\n\t\t\t\trebuildList = lappend(rebuildList, relation);\n\t\t}\n\t}\n\n\t/*\n\t * Now zap any remaining smgr cache entries.  This must happen before we\n\t * start to rebuild entries, since that may involve catalog fetches which\n\t * will re-open catalog files.\n\t */\n\tsmgrcloseall();\n\n\t/* Phase 2: rebuild the items found to need rebuild in phase 1 */\n\tforeach(l, rebuildFirstList)\n\t{\n\t\trelation = (Relation) lfirst(l);\n\t\tRelationClearRelation(relation, true);\n\t}\n\tlist_free(rebuildFirstList);\n\tforeach(l, rebuildList)\n\t{\n\t\trelation = (Relation) lfirst(l);\n\t\tRelationClearRelation(relation, true);\n\t}\n\tlist_free(rebuildList);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResetCatalogCaches",
          "args": [],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "ResetCatalogCaches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "704-719",
          "snippet": "void\nResetCatalogCaches(void)\n{\n\tslist_iter\titer;\n\n\tCACHE1_elog(DEBUG2, \"ResetCatalogCaches called\");\n\n\tslist_foreach(iter, &CacheHdr->ch_caches)\n\t{\n\t\tCatCache   *cache = slist_container(CatCache, cc_next, iter.cur);\n\n\t\tResetCatalogCache(cache);\n\t}\n\n\tCACHE1_elog(DEBUG2, \"end of ResetCatalogCaches call\");\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCacheHeader *CacheHdr = NULL;",
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic CatCacheHeader *CacheHdr = NULL;\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nResetCatalogCaches(void)\n{\n\tslist_iter\titer;\n\n\tCACHE1_elog(DEBUG2, \"ResetCatalogCaches called\");\n\n\tslist_foreach(iter, &CacheHdr->ch_caches)\n\t{\n\t\tCatCache   *cache = slist_container(CatCache, cc_next, iter.cur);\n\n\t\tResetCatalogCache(cache);\n\t}\n\n\tCACHE1_elog(DEBUG2, \"end of ResetCatalogCaches call\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidateCatalogSnapshot",
          "args": [],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "InvalidateCatalogSnapshotConditionally",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "530-537",
          "snippet": "void\nInvalidateCatalogSnapshotConditionally(void)\n{\n\tif (CatalogSnapshot &&\n\t\tActiveSnapshot == NULL &&\n\t\tpairingheap_is_singular(&RegisteredSnapshots))\n\t\tInvalidateCatalogSnapshot();\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CatalogSnapshot = NULL;",
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CatalogSnapshot = NULL;\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\n\nvoid\nInvalidateCatalogSnapshotConditionally(void)\n{\n\tif (CatalogSnapshot &&\n\t\tActiveSnapshot == NULL &&\n\t\tpairingheap_is_singular(&RegisteredSnapshots))\n\t\tInvalidateCatalogSnapshot();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];\nstatic int\tsyscache_callback_count = 0;\nstatic struct RELCACHECALLBACK\n{\n\tRelcacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\trelcache_callback_list[MAX_RELCACHE_CALLBACKS];\nstatic int\trelcache_callback_count = 0;\n\nvoid\nInvalidateSystemCaches(void)\n{\n\tint\t\t\ti;\n\n\tInvalidateCatalogSnapshot();\n\tResetCatalogCaches();\n\tRelationCacheInvalidate();\t/* gets smgr and relmap too */\n\n\tfor (i = 0; i < syscache_callback_count; i++)\n\t{\n\t\tstruct SYSCACHECALLBACK *ccitem = syscache_callback_list + i;\n\n\t\tccitem->function(ccitem->arg, ccitem->id, 0);\n\t}\n\n\tfor (i = 0; i < relcache_callback_count; i++)\n\t{\n\t\tstruct RELCACHECALLBACK *ccitem = relcache_callback_list + i;\n\n\t\tccitem->function(ccitem->arg, InvalidOid);\n\t}\n}"
  },
  {
    "function_name": "LocalExecuteInvalidationMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "555-629",
    "snippet": "void\nLocalExecuteInvalidationMessage(SharedInvalidationMessage *msg)\n{\n\tif (msg->id >= 0)\n\t{\n\t\tif (msg->cc.dbId == MyDatabaseId || msg->cc.dbId == InvalidOid)\n\t\t{\n\t\t\tInvalidateCatalogSnapshot();\n\n\t\t\tSysCacheInvalidate(msg->cc.id, msg->cc.hashValue);\n\n\t\t\tCallSyscacheCallbacks(msg->cc.id, msg->cc.hashValue);\n\t\t}\n\t}\n\telse if (msg->id == SHAREDINVALCATALOG_ID)\n\t{\n\t\tif (msg->cat.dbId == MyDatabaseId || msg->cat.dbId == InvalidOid)\n\t\t{\n\t\t\tInvalidateCatalogSnapshot();\n\n\t\t\tCatalogCacheFlushCatalog(msg->cat.catId);\n\n\t\t\t/* CatalogCacheFlushCatalog calls CallSyscacheCallbacks as needed */\n\t\t}\n\t}\n\telse if (msg->id == SHAREDINVALRELCACHE_ID)\n\t{\n\t\tif (msg->rc.dbId == MyDatabaseId || msg->rc.dbId == InvalidOid)\n\t\t{\n\t\t\tint\t\t\ti;\n\n\t\t\tif (msg->rc.relId == InvalidOid)\n\t\t\t\tRelationCacheInvalidate();\n\t\t\telse\n\t\t\t\tRelationCacheInvalidateEntry(msg->rc.relId);\n\n\t\t\tfor (i = 0; i < relcache_callback_count; i++)\n\t\t\t{\n\t\t\t\tstruct RELCACHECALLBACK *ccitem = relcache_callback_list + i;\n\n\t\t\t\tccitem->function(ccitem->arg, msg->rc.relId);\n\t\t\t}\n\t\t}\n\t}\n\telse if (msg->id == SHAREDINVALSMGR_ID)\n\t{\n\t\t/*\n\t\t * We could have smgr entries for relations of other databases, so no\n\t\t * short-circuit test is possible here.\n\t\t */\n\t\tRelFileNodeBackend rnode;\n\n\t\trnode.node = msg->sm.rnode;\n\t\trnode.backend = (msg->sm.backend_hi << 16) | (int) msg->sm.backend_lo;\n\t\tsmgrclosenode(rnode);\n\t}\n\telse if (msg->id == SHAREDINVALRELMAP_ID)\n\t{\n\t\t/* We only care about our own database and shared catalogs */\n\t\tif (msg->rm.dbId == InvalidOid)\n\t\t\tRelationMapInvalidate(true);\n\t\telse if (msg->rm.dbId == MyDatabaseId)\n\t\t\tRelationMapInvalidate(false);\n\t}\n\telse if (msg->id == SHAREDINVALSNAPSHOT_ID)\n\t{\n\t\t/* We only care about our own database and shared catalogs */\n\t\tif (msg->rm.dbId == InvalidOid)\n\t\t\tInvalidateCatalogSnapshot();\n\t\telse if (msg->rm.dbId == MyDatabaseId)\n\t\t\tInvalidateCatalogSnapshot();\n\t}\n\telse\n\t\telog(FATAL, \"unrecognized SI message ID: %d\", msg->id);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct RELCACHECALLBACK\n{\n\tRelcacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\trelcache_callback_list[MAX_RELCACHE_CALLBACKS];",
      "static int\trelcache_callback_count = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"unrecognized SI message ID: %d\"",
            "msg->id"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidateCatalogSnapshot",
          "args": [],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "InvalidateCatalogSnapshotConditionally",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "530-537",
          "snippet": "void\nInvalidateCatalogSnapshotConditionally(void)\n{\n\tif (CatalogSnapshot &&\n\t\tActiveSnapshot == NULL &&\n\t\tpairingheap_is_singular(&RegisteredSnapshots))\n\t\tInvalidateCatalogSnapshot();\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot CatalogSnapshot = NULL;",
            "static ActiveSnapshotElt *ActiveSnapshot = NULL;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot CatalogSnapshot = NULL;\nstatic ActiveSnapshotElt *ActiveSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\n\nvoid\nInvalidateCatalogSnapshotConditionally(void)\n{\n\tif (CatalogSnapshot &&\n\t\tActiveSnapshot == NULL &&\n\t\tpairingheap_is_singular(&RegisteredSnapshots))\n\t\tInvalidateCatalogSnapshot();\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationMapInvalidate",
          "args": [
            "false"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "RelationMapInvalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "390-403",
          "snippet": "void\nRelationMapInvalidate(bool shared)\n{\n\tif (shared)\n\t{\n\t\tif (shared_map.magic == RELMAPPER_FILEMAGIC)\n\t\t\tload_relmap_file(true);\n\t}\n\telse\n\t{\n\t\tif (local_map.magic == RELMAPPER_FILEMAGIC)\n\t\t\tload_relmap_file(false);\n\t}\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */"
          ],
          "globals_used": [
            "static RelMapFile shared_map;",
            "static RelMapFile local_map;",
            "static void load_relmap_file(bool shared);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic void load_relmap_file(bool shared);\n\nvoid\nRelationMapInvalidate(bool shared)\n{\n\tif (shared)\n\t{\n\t\tif (shared_map.magic == RELMAPPER_FILEMAGIC)\n\t\t\tload_relmap_file(true);\n\t}\n\telse\n\t{\n\t\tif (local_map.magic == RELMAPPER_FILEMAGIC)\n\t\t\tload_relmap_file(false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "smgrclosenode",
          "args": [
            "rnode"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ccitem->function",
          "args": [
            "ccitem->arg",
            "msg->rc.relId"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationCacheInvalidateEntry",
          "args": [
            "msg->rc.relId"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "RelationCacheInvalidateEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2629-2641",
          "snippet": "void\nRelationCacheInvalidateEntry(Oid relationId)\n{\n\tRelation\trelation;\n\n\tRelationIdCacheLookup(relationId, relation);\n\n\tif (PointerIsValid(relation))\n\t{\n\t\trelcacheInvalsReceived++;\n\t\tRelationFlushRelation(relation);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long relcacheInvalsReceived = 0L;",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic long relcacheInvalsReceived = 0L;\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationCacheInvalidateEntry(Oid relationId)\n{\n\tRelation\trelation;\n\n\tRelationIdCacheLookup(relationId, relation);\n\n\tif (PointerIsValid(relation))\n\t{\n\t\trelcacheInvalsReceived++;\n\t\tRelationFlushRelation(relation);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationCacheInvalidate",
          "args": [],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "RelationCacheInvalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2673-2768",
          "snippet": "void\nRelationCacheInvalidate(void)\n{\n\tHASH_SEQ_STATUS status;\n\tRelIdCacheEnt *idhentry;\n\tRelation\trelation;\n\tList\t   *rebuildFirstList = NIL;\n\tList\t   *rebuildList = NIL;\n\tListCell   *l;\n\n\t/*\n\t * Reload relation mapping data before starting to reconstruct cache.\n\t */\n\tRelationMapInvalidateAll();\n\n\t/* Phase 1 */\n\thash_seq_init(&status, RelationIdCache);\n\n\twhile ((idhentry = (RelIdCacheEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\trelation = idhentry->reldesc;\n\n\t\t/* Must close all smgr references to avoid leaving dangling ptrs */\n\t\tRelationCloseSmgr(relation);\n\n\t\t/*\n\t\t * Ignore new relations; no other backend will manipulate them before\n\t\t * we commit.  Likewise, before replacing a relation's relfilenode, we\n\t\t * shall have acquired AccessExclusiveLock and drained any applicable\n\t\t * pending invalidations.\n\t\t */\n\t\tif (relation->rd_createSubid != InvalidSubTransactionId ||\n\t\t\trelation->rd_newRelfilenodeSubid != InvalidSubTransactionId)\n\t\t\tcontinue;\n\n\t\trelcacheInvalsReceived++;\n\n\t\tif (RelationHasReferenceCountZero(relation))\n\t\t{\n\t\t\t/* Delete this entry immediately */\n\t\t\tAssert(!relation->rd_isnailed);\n\t\t\tRelationClearRelation(relation, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If it's a mapped relation, immediately update its rd_node in\n\t\t\t * case its relfilenode changed.  We must do this during phase 1\n\t\t\t * in case the relation is consulted during rebuild of other\n\t\t\t * relcache entries in phase 2.  It's safe since consulting the\n\t\t\t * map doesn't involve any access to relcache entries.\n\t\t\t */\n\t\t\tif (RelationIsMapped(relation))\n\t\t\t\tRelationInitPhysicalAddr(relation);\n\n\t\t\t/*\n\t\t\t * Add this entry to list of stuff to rebuild in second pass.\n\t\t\t * pg_class goes to the front of rebuildFirstList while\n\t\t\t * pg_class_oid_index goes to the back of rebuildFirstList, so\n\t\t\t * they are done first and second respectively.  Other nailed\n\t\t\t * relations go to the front of rebuildList, so they'll be done\n\t\t\t * next in no particular order; and everything else goes to the\n\t\t\t * back of rebuildList.\n\t\t\t */\n\t\t\tif (RelationGetRelid(relation) == RelationRelationId)\n\t\t\t\trebuildFirstList = lcons(relation, rebuildFirstList);\n\t\t\telse if (RelationGetRelid(relation) == ClassOidIndexId)\n\t\t\t\trebuildFirstList = lappend(rebuildFirstList, relation);\n\t\t\telse if (relation->rd_isnailed)\n\t\t\t\trebuildList = lcons(relation, rebuildList);\n\t\t\telse\n\t\t\t\trebuildList = lappend(rebuildList, relation);\n\t\t}\n\t}\n\n\t/*\n\t * Now zap any remaining smgr cache entries.  This must happen before we\n\t * start to rebuild entries, since that may involve catalog fetches which\n\t * will re-open catalog files.\n\t */\n\tsmgrcloseall();\n\n\t/* Phase 2: rebuild the items found to need rebuild in phase 1 */\n\tforeach(l, rebuildFirstList)\n\t{\n\t\trelation = (Relation) lfirst(l);\n\t\tRelationClearRelation(relation, true);\n\t}\n\tlist_free(rebuildFirstList);\n\tforeach(l, rebuildList)\n\t{\n\t\trelation = (Relation) lfirst(l);\n\t\tRelationClearRelation(relation, true);\n\t}\n\tlist_free(rebuildList);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HTAB *RelationIdCache;",
            "static long relcacheInvalsReceived = 0L;",
            "static void RelationClearRelation(Relation relation, bool rebuild);",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic HTAB *RelationIdCache;\nstatic long relcacheInvalsReceived = 0L;\nstatic void RelationClearRelation(Relation relation, bool rebuild);\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationCacheInvalidate(void)\n{\n\tHASH_SEQ_STATUS status;\n\tRelIdCacheEnt *idhentry;\n\tRelation\trelation;\n\tList\t   *rebuildFirstList = NIL;\n\tList\t   *rebuildList = NIL;\n\tListCell   *l;\n\n\t/*\n\t * Reload relation mapping data before starting to reconstruct cache.\n\t */\n\tRelationMapInvalidateAll();\n\n\t/* Phase 1 */\n\thash_seq_init(&status, RelationIdCache);\n\n\twhile ((idhentry = (RelIdCacheEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\trelation = idhentry->reldesc;\n\n\t\t/* Must close all smgr references to avoid leaving dangling ptrs */\n\t\tRelationCloseSmgr(relation);\n\n\t\t/*\n\t\t * Ignore new relations; no other backend will manipulate them before\n\t\t * we commit.  Likewise, before replacing a relation's relfilenode, we\n\t\t * shall have acquired AccessExclusiveLock and drained any applicable\n\t\t * pending invalidations.\n\t\t */\n\t\tif (relation->rd_createSubid != InvalidSubTransactionId ||\n\t\t\trelation->rd_newRelfilenodeSubid != InvalidSubTransactionId)\n\t\t\tcontinue;\n\n\t\trelcacheInvalsReceived++;\n\n\t\tif (RelationHasReferenceCountZero(relation))\n\t\t{\n\t\t\t/* Delete this entry immediately */\n\t\t\tAssert(!relation->rd_isnailed);\n\t\t\tRelationClearRelation(relation, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If it's a mapped relation, immediately update its rd_node in\n\t\t\t * case its relfilenode changed.  We must do this during phase 1\n\t\t\t * in case the relation is consulted during rebuild of other\n\t\t\t * relcache entries in phase 2.  It's safe since consulting the\n\t\t\t * map doesn't involve any access to relcache entries.\n\t\t\t */\n\t\t\tif (RelationIsMapped(relation))\n\t\t\t\tRelationInitPhysicalAddr(relation);\n\n\t\t\t/*\n\t\t\t * Add this entry to list of stuff to rebuild in second pass.\n\t\t\t * pg_class goes to the front of rebuildFirstList while\n\t\t\t * pg_class_oid_index goes to the back of rebuildFirstList, so\n\t\t\t * they are done first and second respectively.  Other nailed\n\t\t\t * relations go to the front of rebuildList, so they'll be done\n\t\t\t * next in no particular order; and everything else goes to the\n\t\t\t * back of rebuildList.\n\t\t\t */\n\t\t\tif (RelationGetRelid(relation) == RelationRelationId)\n\t\t\t\trebuildFirstList = lcons(relation, rebuildFirstList);\n\t\t\telse if (RelationGetRelid(relation) == ClassOidIndexId)\n\t\t\t\trebuildFirstList = lappend(rebuildFirstList, relation);\n\t\t\telse if (relation->rd_isnailed)\n\t\t\t\trebuildList = lcons(relation, rebuildList);\n\t\t\telse\n\t\t\t\trebuildList = lappend(rebuildList, relation);\n\t\t}\n\t}\n\n\t/*\n\t * Now zap any remaining smgr cache entries.  This must happen before we\n\t * start to rebuild entries, since that may involve catalog fetches which\n\t * will re-open catalog files.\n\t */\n\tsmgrcloseall();\n\n\t/* Phase 2: rebuild the items found to need rebuild in phase 1 */\n\tforeach(l, rebuildFirstList)\n\t{\n\t\trelation = (Relation) lfirst(l);\n\t\tRelationClearRelation(relation, true);\n\t}\n\tlist_free(rebuildFirstList);\n\tforeach(l, rebuildList)\n\t{\n\t\trelation = (Relation) lfirst(l);\n\t\tRelationClearRelation(relation, true);\n\t}\n\tlist_free(rebuildList);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CatalogCacheFlushCatalog",
          "args": [
            "msg->cat.catId"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "CatalogCacheFlushCatalog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "734-757",
          "snippet": "void\nCatalogCacheFlushCatalog(Oid catId)\n{\n\tslist_iter\titer;\n\n\tCACHE2_elog(DEBUG2, \"CatalogCacheFlushCatalog called for %u\", catId);\n\n\tslist_foreach(iter, &CacheHdr->ch_caches)\n\t{\n\t\tCatCache   *cache = slist_container(CatCache, cc_next, iter.cur);\n\n\t\t/* Does this cache store tuples of the target catalog? */\n\t\tif (cache->cc_reloid == catId)\n\t\t{\n\t\t\t/* Yes, so flush all its contents */\n\t\t\tResetCatalogCache(cache);\n\n\t\t\t/* Tell inval.c to call syscache callbacks for this cache */\n\t\t\tCallSyscacheCallbacks(cache->id, 0);\n\t\t}\n\t}\n\n\tCACHE1_elog(DEBUG2, \"end of CatalogCacheFlushCatalog call\");\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCacheHeader *CacheHdr = NULL;",
            "static void CatalogCacheInitializeCache(CatCache *cache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nstatic CatCacheHeader *CacheHdr = NULL;\nstatic void CatalogCacheInitializeCache(CatCache *cache);\n\nvoid\nCatalogCacheFlushCatalog(Oid catId)\n{\n\tslist_iter\titer;\n\n\tCACHE2_elog(DEBUG2, \"CatalogCacheFlushCatalog called for %u\", catId);\n\n\tslist_foreach(iter, &CacheHdr->ch_caches)\n\t{\n\t\tCatCache   *cache = slist_container(CatCache, cc_next, iter.cur);\n\n\t\t/* Does this cache store tuples of the target catalog? */\n\t\tif (cache->cc_reloid == catId)\n\t\t{\n\t\t\t/* Yes, so flush all its contents */\n\t\t\tResetCatalogCache(cache);\n\n\t\t\t/* Tell inval.c to call syscache callbacks for this cache */\n\t\t\tCallSyscacheCallbacks(cache->id, 0);\n\t\t}\n\t}\n\n\tCACHE1_elog(DEBUG2, \"end of CatalogCacheFlushCatalog call\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "CallSyscacheCallbacks",
          "args": [
            "msg->cc.id",
            "msg->cc.hashValue"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "CallSyscacheCallbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "1486-1503",
          "snippet": "void\nCallSyscacheCallbacks(int cacheid, uint32 hashvalue)\n{\n\tint\t\t\ti;\n\n\tif (cacheid < 0 || cacheid >= SysCacheSize)\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheid);\n\n\ti = syscache_callback_links[cacheid] - 1;\n\twhile (i >= 0)\n\t{\n\t\tstruct SYSCACHECALLBACK *ccitem = syscache_callback_list + i;\n\n\t\tAssert(ccitem->id == cacheid);\n\t\tccitem->function(ccitem->arg, cacheid, hashvalue);\n\t\ti = ccitem->link - 1;\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];",
            "static int16 syscache_callback_links[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic struct SYSCACHECALLBACK\n{\n\tint16\t\tid;\t\t\t\t/* cache number */\n\tint16\t\tlink;\t\t\t/* next callback index+1 for same cache */\n\tSyscacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\tsyscache_callback_list[MAX_SYSCACHE_CALLBACKS];\nstatic int16 syscache_callback_links[SysCacheSize];\n\nvoid\nCallSyscacheCallbacks(int cacheid, uint32 hashvalue)\n{\n\tint\t\t\ti;\n\n\tif (cacheid < 0 || cacheid >= SysCacheSize)\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheid);\n\n\ti = syscache_callback_links[cacheid] - 1;\n\twhile (i >= 0)\n\t{\n\t\tstruct SYSCACHECALLBACK *ccitem = syscache_callback_list + i;\n\n\t\tAssert(ccitem->id == cacheid);\n\t\tccitem->function(ccitem->arg, cacheid, hashvalue);\n\t\ti = ccitem->link - 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "SysCacheInvalidate",
          "args": [
            "msg->cc.id",
            "msg->cc.hashValue"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "SysCacheInvalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1439-1450",
          "snippet": "void\nSysCacheInvalidate(int cacheId, uint32 hashValue)\n{\n\tif (cacheId < 0 || cacheId >= SysCacheSize)\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\n\t/* if this cache isn't initialized yet, no need to do anything */\n\tif (!PointerIsValid(SysCache[cacheId]))\n\t\treturn;\n\n\tCatCacheInvalidate(SysCache[cacheId], hashValue);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nvoid\nSysCacheInvalidate(int cacheId, uint32 hashValue)\n{\n\tif (cacheId < 0 || cacheId >= SysCacheSize)\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\n\t/* if this cache isn't initialized yet, no need to do anything */\n\tif (!PointerIsValid(SysCache[cacheId]))\n\t\treturn;\n\n\tCatCacheInvalidate(SysCache[cacheId], hashValue);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic struct RELCACHECALLBACK\n{\n\tRelcacheCallbackFunction function;\n\tDatum\t\targ;\n}\t\t\trelcache_callback_list[MAX_RELCACHE_CALLBACKS];\nstatic int\trelcache_callback_count = 0;\n\nvoid\nLocalExecuteInvalidationMessage(SharedInvalidationMessage *msg)\n{\n\tif (msg->id >= 0)\n\t{\n\t\tif (msg->cc.dbId == MyDatabaseId || msg->cc.dbId == InvalidOid)\n\t\t{\n\t\t\tInvalidateCatalogSnapshot();\n\n\t\t\tSysCacheInvalidate(msg->cc.id, msg->cc.hashValue);\n\n\t\t\tCallSyscacheCallbacks(msg->cc.id, msg->cc.hashValue);\n\t\t}\n\t}\n\telse if (msg->id == SHAREDINVALCATALOG_ID)\n\t{\n\t\tif (msg->cat.dbId == MyDatabaseId || msg->cat.dbId == InvalidOid)\n\t\t{\n\t\t\tInvalidateCatalogSnapshot();\n\n\t\t\tCatalogCacheFlushCatalog(msg->cat.catId);\n\n\t\t\t/* CatalogCacheFlushCatalog calls CallSyscacheCallbacks as needed */\n\t\t}\n\t}\n\telse if (msg->id == SHAREDINVALRELCACHE_ID)\n\t{\n\t\tif (msg->rc.dbId == MyDatabaseId || msg->rc.dbId == InvalidOid)\n\t\t{\n\t\t\tint\t\t\ti;\n\n\t\t\tif (msg->rc.relId == InvalidOid)\n\t\t\t\tRelationCacheInvalidate();\n\t\t\telse\n\t\t\t\tRelationCacheInvalidateEntry(msg->rc.relId);\n\n\t\t\tfor (i = 0; i < relcache_callback_count; i++)\n\t\t\t{\n\t\t\t\tstruct RELCACHECALLBACK *ccitem = relcache_callback_list + i;\n\n\t\t\t\tccitem->function(ccitem->arg, msg->rc.relId);\n\t\t\t}\n\t\t}\n\t}\n\telse if (msg->id == SHAREDINVALSMGR_ID)\n\t{\n\t\t/*\n\t\t * We could have smgr entries for relations of other databases, so no\n\t\t * short-circuit test is possible here.\n\t\t */\n\t\tRelFileNodeBackend rnode;\n\n\t\trnode.node = msg->sm.rnode;\n\t\trnode.backend = (msg->sm.backend_hi << 16) | (int) msg->sm.backend_lo;\n\t\tsmgrclosenode(rnode);\n\t}\n\telse if (msg->id == SHAREDINVALRELMAP_ID)\n\t{\n\t\t/* We only care about our own database and shared catalogs */\n\t\tif (msg->rm.dbId == InvalidOid)\n\t\t\tRelationMapInvalidate(true);\n\t\telse if (msg->rm.dbId == MyDatabaseId)\n\t\t\tRelationMapInvalidate(false);\n\t}\n\telse if (msg->id == SHAREDINVALSNAPSHOT_ID)\n\t{\n\t\t/* We only care about our own database and shared catalogs */\n\t\tif (msg->rm.dbId == InvalidOid)\n\t\t\tInvalidateCatalogSnapshot();\n\t\telse if (msg->rm.dbId == MyDatabaseId)\n\t\t\tInvalidateCatalogSnapshot();\n\t}\n\telse\n\t\telog(FATAL, \"unrecognized SI message ID: %d\", msg->id);\n}"
  },
  {
    "function_name": "RegisterSnapshotInvalidation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "541-546",
    "snippet": "static void\nRegisterSnapshotInvalidation(Oid dbId, Oid relId)\n{\n\tAddSnapshotInvalidationMessage(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   dbId, relId);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TransInvalidationInfo *transInvalInfo = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AddSnapshotInvalidationMessage",
          "args": [
            "&transInvalInfo->CurrentCmdInvalidMsgs",
            "dbId",
            "relId"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "AddSnapshotInvalidationMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "414-435",
          "snippet": "static void\nAddSnapshotInvalidationMessage(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t   Oid dbId, Oid relId)\n{\n\tSharedInvalidationMessage msg;\n\n\t/* Don't add a duplicate item */\n\t/* We assume dbId need not be checked because it will never change */\n\tProcessMessageList(hdr->rclist,\n\t\t\t\t\t   if (msg->sn.id == SHAREDINVALSNAPSHOT_ID &&\n\t\t\t\t\t\t   msg->sn.relId == relId)\n\t\t\t\t\t   return);\n\n\t/* OK, add the item */\n\tmsg.sn.id = SHAREDINVALSNAPSHOT_ID;\n\tmsg.sn.dbId = dbId;\n\tmsg.sn.relId = relId;\n\t/* check AddCatcacheInvalidationMessage() for an explanation */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tAddInvalidationMessage(&hdr->rclist, &msg);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nAddSnapshotInvalidationMessage(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t   Oid dbId, Oid relId)\n{\n\tSharedInvalidationMessage msg;\n\n\t/* Don't add a duplicate item */\n\t/* We assume dbId need not be checked because it will never change */\n\tProcessMessageList(hdr->rclist,\n\t\t\t\t\t   if (msg->sn.id == SHAREDINVALSNAPSHOT_ID &&\n\t\t\t\t\t\t   msg->sn.relId == relId)\n\t\t\t\t\t   return);\n\n\t/* OK, add the item */\n\tmsg.sn.id = SHAREDINVALSNAPSHOT_ID;\n\tmsg.sn.dbId = dbId;\n\tmsg.sn.relId = relId;\n\t/* check AddCatcacheInvalidationMessage() for an explanation */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tAddInvalidationMessage(&hdr->rclist, &msg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\n\nstatic void\nRegisterSnapshotInvalidation(Oid dbId, Oid relId)\n{\n\tAddSnapshotInvalidationMessage(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   dbId, relId);\n}"
  },
  {
    "function_name": "RegisterRelcacheInvalidation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "511-533",
    "snippet": "static void\nRegisterRelcacheInvalidation(Oid dbId, Oid relId)\n{\n\tAddRelcacheInvalidationMessage(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   dbId, relId);\n\n\t/*\n\t * Most of the time, relcache invalidation is associated with system\n\t * catalog updates, but there are a few cases where it isn't.  Quick hack\n\t * to ensure that the next CommandCounterIncrement() will think that we\n\t * need to do CommandEndInvalidationMessages().\n\t */\n\t(void) GetCurrentCommandId(true);\n\n\t/*\n\t * If the relation being invalidated is one of those cached in a relcache\n\t * init file, mark that we need to zap that file at commit. For simplicity\n\t * invalidations for a specific database always invalidate the shared file\n\t * as well.  Also zap when we are invalidating whole relcache.\n\t */\n\tif (relId == InvalidOid || RelationIdIsInInitFile(relId))\n\t\ttransInvalInfo->RelcacheInitFileInval = true;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TransInvalidationInfo *transInvalInfo = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RelationIdIsInInitFile",
          "args": [
            "relId"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "RelationIdIsInInitFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "6010-6026",
          "snippet": "bool\nRelationIdIsInInitFile(Oid relationId)\n{\n\tif (relationId == SharedSecLabelRelationId ||\n\t\trelationId == TriggerRelidNameIndexId ||\n\t\trelationId == DatabaseNameIndexId ||\n\t\trelationId == SharedSecLabelObjectIndexId)\n\t{\n\t\t/*\n\t\t * If this Assert fails, we don't need the applicable special case\n\t\t * anymore.\n\t\t */\n\t\tAssert(!RelationSupportsSysCache(relationId));\n\t\treturn true;\n\t}\n\treturn RelationSupportsSysCache(relationId);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nbool\nRelationIdIsInInitFile(Oid relationId)\n{\n\tif (relationId == SharedSecLabelRelationId ||\n\t\trelationId == TriggerRelidNameIndexId ||\n\t\trelationId == DatabaseNameIndexId ||\n\t\trelationId == SharedSecLabelObjectIndexId)\n\t{\n\t\t/*\n\t\t * If this Assert fails, we don't need the applicable special case\n\t\t * anymore.\n\t\t */\n\t\tAssert(!RelationSupportsSysCache(relationId));\n\t\treturn true;\n\t}\n\treturn RelationSupportsSysCache(relationId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetCurrentCommandId",
          "args": [
            "true"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AddRelcacheInvalidationMessage",
          "args": [
            "&transInvalInfo->CurrentCmdInvalidMsgs",
            "dbId",
            "relId"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "AddRelcacheInvalidationMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "384-409",
          "snippet": "static void\nAddRelcacheInvalidationMessage(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t   Oid dbId, Oid relId)\n{\n\tSharedInvalidationMessage msg;\n\n\t/*\n\t * Don't add a duplicate item. We assume dbId need not be checked because\n\t * it will never change. InvalidOid for relId means all relations so we\n\t * don't need to add individual ones when it is present.\n\t */\n\tProcessMessageList(hdr->rclist,\n\t\t\t\t\t   if (msg->rc.id == SHAREDINVALRELCACHE_ID &&\n\t\t\t\t\t\t   (msg->rc.relId == relId ||\n\t\t\t\t\t\t\tmsg->rc.relId == InvalidOid))\n\t\t\t\t\t   return);\n\n\t/* OK, add the item */\n\tmsg.rc.id = SHAREDINVALRELCACHE_ID;\n\tmsg.rc.dbId = dbId;\n\tmsg.rc.relId = relId;\n\t/* check AddCatcacheInvalidationMessage() for an explanation */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tAddInvalidationMessage(&hdr->rclist, &msg);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nAddRelcacheInvalidationMessage(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t   Oid dbId, Oid relId)\n{\n\tSharedInvalidationMessage msg;\n\n\t/*\n\t * Don't add a duplicate item. We assume dbId need not be checked because\n\t * it will never change. InvalidOid for relId means all relations so we\n\t * don't need to add individual ones when it is present.\n\t */\n\tProcessMessageList(hdr->rclist,\n\t\t\t\t\t   if (msg->rc.id == SHAREDINVALRELCACHE_ID &&\n\t\t\t\t\t\t   (msg->rc.relId == relId ||\n\t\t\t\t\t\t\tmsg->rc.relId == InvalidOid))\n\t\t\t\t\t   return);\n\n\t/* OK, add the item */\n\tmsg.rc.id = SHAREDINVALRELCACHE_ID;\n\tmsg.rc.dbId = dbId;\n\tmsg.rc.relId = relId;\n\t/* check AddCatcacheInvalidationMessage() for an explanation */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tAddInvalidationMessage(&hdr->rclist, &msg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\n\nstatic void\nRegisterRelcacheInvalidation(Oid dbId, Oid relId)\n{\n\tAddRelcacheInvalidationMessage(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   dbId, relId);\n\n\t/*\n\t * Most of the time, relcache invalidation is associated with system\n\t * catalog updates, but there are a few cases where it isn't.  Quick hack\n\t * to ensure that the next CommandCounterIncrement() will think that we\n\t * need to do CommandEndInvalidationMessages().\n\t */\n\t(void) GetCurrentCommandId(true);\n\n\t/*\n\t * If the relation being invalidated is one of those cached in a relcache\n\t * init file, mark that we need to zap that file at commit. For simplicity\n\t * invalidations for a specific database always invalidate the shared file\n\t * as well.  Also zap when we are invalidating whole relcache.\n\t */\n\tif (relId == InvalidOid || RelationIdIsInInitFile(relId))\n\t\ttransInvalInfo->RelcacheInitFileInval = true;\n}"
  },
  {
    "function_name": "RegisterCatalogInvalidation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "499-504",
    "snippet": "static void\nRegisterCatalogInvalidation(Oid dbId, Oid catId)\n{\n\tAddCatalogInvalidationMessage(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t  dbId, catId);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TransInvalidationInfo *transInvalInfo = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AddCatalogInvalidationMessage",
          "args": [
            "&transInvalInfo->CurrentCmdInvalidMsgs",
            "dbId",
            "catId"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "AddCatalogInvalidationMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "366-379",
          "snippet": "static void\nAddCatalogInvalidationMessage(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t  Oid dbId, Oid catId)\n{\n\tSharedInvalidationMessage msg;\n\n\tmsg.cat.id = SHAREDINVALCATALOG_ID;\n\tmsg.cat.dbId = dbId;\n\tmsg.cat.catId = catId;\n\t/* check AddCatcacheInvalidationMessage() for an explanation */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tAddInvalidationMessage(&hdr->cclist, &msg);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nAddCatalogInvalidationMessage(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t  Oid dbId, Oid catId)\n{\n\tSharedInvalidationMessage msg;\n\n\tmsg.cat.id = SHAREDINVALCATALOG_ID;\n\tmsg.cat.dbId = dbId;\n\tmsg.cat.catId = catId;\n\t/* check AddCatcacheInvalidationMessage() for an explanation */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tAddInvalidationMessage(&hdr->cclist, &msg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\n\nstatic void\nRegisterCatalogInvalidation(Oid dbId, Oid catId)\n{\n\tAddCatalogInvalidationMessage(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t  dbId, catId);\n}"
  },
  {
    "function_name": "RegisterCatcacheInvalidation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "485-492",
    "snippet": "static void\nRegisterCatcacheInvalidation(int cacheId,\n\t\t\t\t\t\t\t uint32 hashValue,\n\t\t\t\t\t\t\t Oid dbId)\n{\n\tAddCatcacheInvalidationMessage(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   cacheId, hashValue, dbId);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TransInvalidationInfo *transInvalInfo = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AddCatcacheInvalidationMessage",
          "args": [
            "&transInvalInfo->CurrentCmdInvalidMsgs",
            "cacheId",
            "hashValue",
            "dbId"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "AddCatcacheInvalidationMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "338-361",
          "snippet": "static void\nAddCatcacheInvalidationMessage(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t   int id, uint32 hashValue, Oid dbId)\n{\n\tSharedInvalidationMessage msg;\n\n\tAssert(id < CHAR_MAX);\n\tmsg.cc.id = (int8) id;\n\tmsg.cc.dbId = dbId;\n\tmsg.cc.hashValue = hashValue;\n\n\t/*\n\t * Define padding bytes in SharedInvalidationMessage structs to be\n\t * defined. Otherwise the sinvaladt.c ringbuffer, which is accessed by\n\t * multiple processes, will cause spurious valgrind warnings about\n\t * undefined memory being used. That's because valgrind remembers the\n\t * undefined bytes from the last local process's store, not realizing that\n\t * another process has written since, filling the previously uninitialized\n\t * bytes\n\t */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tAddInvalidationMessage(&hdr->cclist, &msg);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nAddCatcacheInvalidationMessage(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t   int id, uint32 hashValue, Oid dbId)\n{\n\tSharedInvalidationMessage msg;\n\n\tAssert(id < CHAR_MAX);\n\tmsg.cc.id = (int8) id;\n\tmsg.cc.dbId = dbId;\n\tmsg.cc.hashValue = hashValue;\n\n\t/*\n\t * Define padding bytes in SharedInvalidationMessage structs to be\n\t * defined. Otherwise the sinvaladt.c ringbuffer, which is accessed by\n\t * multiple processes, will cause spurious valgrind warnings about\n\t * undefined memory being used. That's because valgrind remembers the\n\t * undefined bytes from the last local process's store, not realizing that\n\t * another process has written since, filling the previously uninitialized\n\t * bytes\n\t */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tAddInvalidationMessage(&hdr->cclist, &msg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TransInvalidationInfo *transInvalInfo = NULL;\n\nstatic void\nRegisterCatcacheInvalidation(int cacheId,\n\t\t\t\t\t\t\t uint32 hashValue,\n\t\t\t\t\t\t\t Oid dbId)\n{\n\tAddCatcacheInvalidationMessage(&transInvalInfo->CurrentCmdInvalidMsgs,\n\t\t\t\t\t\t\t\t   cacheId, hashValue, dbId);\n}"
  },
  {
    "function_name": "ProcessInvalidationMessagesMulti",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "467-473",
    "snippet": "static void\nProcessInvalidationMessagesMulti(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t\t void (*func) (const SharedInvalidationMessage *msgs, int n))\n{\n\tProcessMessageListMulti(hdr->cclist, func(msgs, n));\n\tProcessMessageListMulti(hdr->rclist, func(msgs, n));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ProcessMessageListMulti",
          "args": [
            "hdr->rclist",
            "func(msgs, n)"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "msgs",
            "n"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "get_windowfunc_expr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "9289-9358",
          "snippet": "static void\nget_windowfunc_expr(WindowFunc *wfunc, deparse_context *context)\n{\n\tStringInfo\tbuf = context->buf;\n\tOid\t\t\targtypes[FUNC_MAX_ARGS];\n\tint\t\t\tnargs;\n\tList\t   *argnames;\n\tListCell   *l;\n\n\tif (list_length(wfunc->args) > FUNC_MAX_ARGS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_TOO_MANY_ARGUMENTS),\n\t\t\t\t errmsg(\"too many arguments\")));\n\tnargs = 0;\n\targnames = NIL;\n\tforeach(l, wfunc->args)\n\t{\n\t\tNode\t   *arg = (Node *) lfirst(l);\n\n\t\tif (IsA(arg, NamedArgExpr))\n\t\t\targnames = lappend(argnames, ((NamedArgExpr *) arg)->name);\n\t\targtypes[nargs] = exprType(arg);\n\t\tnargs++;\n\t}\n\n\tappendStringInfo(buf, \"%s(\",\n\t\t\t\t\t generate_function_name(wfunc->winfnoid, nargs,\n\t\t\t\t\t\t\t\t\t\t\targnames, argtypes,\n\t\t\t\t\t\t\t\t\t\t\tfalse, NULL,\n\t\t\t\t\t\t\t\t\t\t\tcontext->special_exprkind));\n\t/* winstar can be set only in zero-argument aggregates */\n\tif (wfunc->winstar)\n\t\tappendStringInfoChar(buf, '*');\n\telse\n\t\tget_rule_expr((Node *) wfunc->args, context, true);\n\n\tif (wfunc->aggfilter != NULL)\n\t{\n\t\tappendStringInfoString(buf, \") FILTER (WHERE \");\n\t\tget_rule_expr((Node *) wfunc->aggfilter, context, false);\n\t}\n\n\tappendStringInfoString(buf, \") OVER \");\n\n\tforeach(l, context->windowClause)\n\t{\n\t\tWindowClause *wc = (WindowClause *) lfirst(l);\n\n\t\tif (wc->winref == wfunc->winref)\n\t\t{\n\t\t\tif (wc->name)\n\t\t\t\tappendStringInfoString(buf, quote_identifier(wc->name));\n\t\t\telse\n\t\t\t\tget_rule_windowspec(wc, context->windowTList, context);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (l == NULL)\n\t{\n\t\tif (context->windowClause)\n\t\t\telog(ERROR, \"could not find window clause for winref %u\",\n\t\t\t\t wfunc->winref);\n\n\t\t/*\n\t\t * In EXPLAIN, we don't have window context information available, so\n\t\t * we have to settle for this:\n\t\t */\n\t\tappendStringInfoString(buf, \"(?)\");\n\t}\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int decompile_column_index_array(Datum column_index_array, Oid relId,\n\t\t\t\t\t\t\t StringInfo buf);",
            "static char *get_rtable_name(int rtindex, deparse_context *context);",
            "static void get_values_def(List *values_lists, deparse_context *context);",
            "static void get_with_clause(Query *query, deparse_context *context);",
            "static void get_insert_query_def(Query *query, deparse_context *context);",
            "static void get_update_query_def(Query *query, deparse_context *context);",
            "static void get_delete_query_def(Query *query, deparse_context *context);",
            "static void get_utility_query_def(Query *query, deparse_context *context);",
            "static Node *get_rule_sortgroupclause(Index ref, List *tlist,\n\t\t\t\t\t\t bool force_colno,\n\t\t\t\t\t\t deparse_context *context);",
            "static void get_rule_groupingset(GroupingSet *gset, List *targetlist,\n\t\t\t\t\t bool omit_parens, deparse_context *context);",
            "static void get_rule_orderby(List *orderList, List *targetList,\n\t\t\t\t bool force_colno, deparse_context *context);",
            "static void get_rule_windowclause(Query *query, deparse_context *context);",
            "static void get_rule_windowspec(WindowClause *wc, List *targetList,\n\t\t\t\t\tdeparse_context *context);",
            "static char *get_variable(Var *var, int levelsup, bool istoplevel,\n\t\t\t deparse_context *context);",
            "static void resolve_special_varno(Node *node, deparse_context *context,\n\t\t\t\t\t  void *private,\n\t\t\t\t\t  void (*callback) (Node *, deparse_context *, void *));",
            "static void get_parameter(Param *param, deparse_context *context);",
            "static void get_oper_expr(OpExpr *expr, deparse_context *context);",
            "static void get_windowfunc_expr(WindowFunc *wfunc, deparse_context *context);",
            "static void get_const_collation(Const *constval, deparse_context *context);",
            "static void get_sublink_expr(SubLink *sublink, deparse_context *context);",
            "static void get_from_clause(Query *query, const char *prefix,\n\t\t\t\tdeparse_context *context);",
            "static void get_from_clause_item(Node *jtnode, Query *query,\n\t\t\t\t\t deparse_context *context);",
            "static void get_column_alias_list(deparse_columns *colinfo,\n\t\t\t\t\t  deparse_context *context);",
            "static void get_from_clause_coldeflist(RangeTblFunction *rtfunc,\n\t\t\t\t\t\t   deparse_columns *colinfo,\n\t\t\t\t\t\t   deparse_context *context);",
            "static void get_tablesample_def(TableSampleClause *tablesample,\n\t\t\t\t\tdeparse_context *context);",
            "static void get_opclass_name(Oid opclass, Oid actual_datatype,\n\t\t\t\t StringInfo buf);",
            "static Node *processIndirection(Node *node, deparse_context *context);",
            "static void printSubscripts(ArrayRef *aref, deparse_context *context);",
            "static char *generate_function_name(Oid funcid, int nargs,\n\t\t\t\t\t   List *argnames, Oid *argtypes,\n\t\t\t\t\t   bool has_variadic, bool *use_variadic_p,\n\t\t\t\t\t   ParseExprKind special_exprkind);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int decompile_column_index_array(Datum column_index_array, Oid relId,\n\t\t\t\t\t\t\t StringInfo buf);\nstatic char *get_rtable_name(int rtindex, deparse_context *context);\nstatic void get_values_def(List *values_lists, deparse_context *context);\nstatic void get_with_clause(Query *query, deparse_context *context);\nstatic void get_insert_query_def(Query *query, deparse_context *context);\nstatic void get_update_query_def(Query *query, deparse_context *context);\nstatic void get_delete_query_def(Query *query, deparse_context *context);\nstatic void get_utility_query_def(Query *query, deparse_context *context);\nstatic Node *get_rule_sortgroupclause(Index ref, List *tlist,\n\t\t\t\t\t\t bool force_colno,\n\t\t\t\t\t\t deparse_context *context);\nstatic void get_rule_groupingset(GroupingSet *gset, List *targetlist,\n\t\t\t\t\t bool omit_parens, deparse_context *context);\nstatic void get_rule_orderby(List *orderList, List *targetList,\n\t\t\t\t bool force_colno, deparse_context *context);\nstatic void get_rule_windowclause(Query *query, deparse_context *context);\nstatic void get_rule_windowspec(WindowClause *wc, List *targetList,\n\t\t\t\t\tdeparse_context *context);\nstatic char *get_variable(Var *var, int levelsup, bool istoplevel,\n\t\t\t deparse_context *context);\nstatic void resolve_special_varno(Node *node, deparse_context *context,\n\t\t\t\t\t  void *private,\n\t\t\t\t\t  void (*callback) (Node *, deparse_context *, void *));\nstatic void get_parameter(Param *param, deparse_context *context);\nstatic void get_oper_expr(OpExpr *expr, deparse_context *context);\nstatic void get_windowfunc_expr(WindowFunc *wfunc, deparse_context *context);\nstatic void get_const_collation(Const *constval, deparse_context *context);\nstatic void get_sublink_expr(SubLink *sublink, deparse_context *context);\nstatic void get_from_clause(Query *query, const char *prefix,\n\t\t\t\tdeparse_context *context);\nstatic void get_from_clause_item(Node *jtnode, Query *query,\n\t\t\t\t\t deparse_context *context);\nstatic void get_column_alias_list(deparse_columns *colinfo,\n\t\t\t\t\t  deparse_context *context);\nstatic void get_from_clause_coldeflist(RangeTblFunction *rtfunc,\n\t\t\t\t\t\t   deparse_columns *colinfo,\n\t\t\t\t\t\t   deparse_context *context);\nstatic void get_tablesample_def(TableSampleClause *tablesample,\n\t\t\t\t\tdeparse_context *context);\nstatic void get_opclass_name(Oid opclass, Oid actual_datatype,\n\t\t\t\t StringInfo buf);\nstatic Node *processIndirection(Node *node, deparse_context *context);\nstatic void printSubscripts(ArrayRef *aref, deparse_context *context);\nstatic char *generate_function_name(Oid funcid, int nargs,\n\t\t\t\t\t   List *argnames, Oid *argtypes,\n\t\t\t\t\t   bool has_variadic, bool *use_variadic_p,\n\t\t\t\t\t   ParseExprKind special_exprkind);\n\nstatic void\nget_windowfunc_expr(WindowFunc *wfunc, deparse_context *context)\n{\n\tStringInfo\tbuf = context->buf;\n\tOid\t\t\targtypes[FUNC_MAX_ARGS];\n\tint\t\t\tnargs;\n\tList\t   *argnames;\n\tListCell   *l;\n\n\tif (list_length(wfunc->args) > FUNC_MAX_ARGS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_TOO_MANY_ARGUMENTS),\n\t\t\t\t errmsg(\"too many arguments\")));\n\tnargs = 0;\n\targnames = NIL;\n\tforeach(l, wfunc->args)\n\t{\n\t\tNode\t   *arg = (Node *) lfirst(l);\n\n\t\tif (IsA(arg, NamedArgExpr))\n\t\t\targnames = lappend(argnames, ((NamedArgExpr *) arg)->name);\n\t\targtypes[nargs] = exprType(arg);\n\t\tnargs++;\n\t}\n\n\tappendStringInfo(buf, \"%s(\",\n\t\t\t\t\t generate_function_name(wfunc->winfnoid, nargs,\n\t\t\t\t\t\t\t\t\t\t\targnames, argtypes,\n\t\t\t\t\t\t\t\t\t\t\tfalse, NULL,\n\t\t\t\t\t\t\t\t\t\t\tcontext->special_exprkind));\n\t/* winstar can be set only in zero-argument aggregates */\n\tif (wfunc->winstar)\n\t\tappendStringInfoChar(buf, '*');\n\telse\n\t\tget_rule_expr((Node *) wfunc->args, context, true);\n\n\tif (wfunc->aggfilter != NULL)\n\t{\n\t\tappendStringInfoString(buf, \") FILTER (WHERE \");\n\t\tget_rule_expr((Node *) wfunc->aggfilter, context, false);\n\t}\n\n\tappendStringInfoString(buf, \") OVER \");\n\n\tforeach(l, context->windowClause)\n\t{\n\t\tWindowClause *wc = (WindowClause *) lfirst(l);\n\n\t\tif (wc->winref == wfunc->winref)\n\t\t{\n\t\t\tif (wc->name)\n\t\t\t\tappendStringInfoString(buf, quote_identifier(wc->name));\n\t\t\telse\n\t\t\t\tget_rule_windowspec(wc, context->windowTList, context);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (l == NULL)\n\t{\n\t\tif (context->windowClause)\n\t\t\telog(ERROR, \"could not find window clause for winref %u\",\n\t\t\t\t wfunc->winref);\n\n\t\t/*\n\t\t * In EXPLAIN, we don't have window context information available, so\n\t\t * we have to settle for this:\n\t\t */\n\t\tappendStringInfoString(buf, \"(?)\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ProcessMessageListMulti",
          "args": [
            "hdr->cclist",
            "func(msgs, n)"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nProcessInvalidationMessagesMulti(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t\t void (*func) (const SharedInvalidationMessage *msgs, int n))\n{\n\tProcessMessageListMulti(hdr->cclist, func(msgs, n));\n\tProcessMessageListMulti(hdr->rclist, func(msgs, n));\n}"
  },
  {
    "function_name": "ProcessInvalidationMessages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "455-461",
    "snippet": "static void\nProcessInvalidationMessages(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\tvoid (*func) (SharedInvalidationMessage *msg))\n{\n\tProcessMessageList(hdr->cclist, func(msg));\n\tProcessMessageList(hdr->rclist, func(msg));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ProcessMessageList",
          "args": [
            "hdr->rclist",
            "func(msg)"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "msg"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "get_func_rows",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1663-1676",
          "snippet": "float4\nget_func_rows(Oid funcid)\n{\n\tHeapTuple\ttp;\n\tfloat4\t\tresult;\n\n\ttp = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for function %u\", funcid);\n\n\tresult = ((Form_pg_proc) GETSTRUCT(tp))->prorows;\n\tReleaseSysCache(tp);\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nfloat4\nget_func_rows(Oid funcid)\n{\n\tHeapTuple\ttp;\n\tfloat4\t\tresult;\n\n\ttp = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcid));\n\tif (!HeapTupleIsValid(tp))\n\t\telog(ERROR, \"cache lookup failed for function %u\", funcid);\n\n\tresult = ((Form_pg_proc) GETSTRUCT(tp))->prorows;\n\tReleaseSysCache(tp);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ProcessMessageList",
          "args": [
            "hdr->cclist",
            "func(msg)"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nProcessInvalidationMessages(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\tvoid (*func) (SharedInvalidationMessage *msg))\n{\n\tProcessMessageList(hdr->cclist, func(msg));\n\tProcessMessageList(hdr->rclist, func(msg));\n}"
  },
  {
    "function_name": "AppendInvalidationMessages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "441-447",
    "snippet": "static void\nAppendInvalidationMessages(InvalidationListHeader *dest,\n\t\t\t\t\t\t   InvalidationListHeader *src)\n{\n\tAppendInvalidationMessageList(&dest->cclist, &src->cclist);\n\tAppendInvalidationMessageList(&dest->rclist, &src->rclist);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AppendInvalidationMessageList",
          "args": [
            "&dest->rclist",
            "&src->rclist"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "AppendInvalidationMessageList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "270-287",
          "snippet": "static void\nAppendInvalidationMessageList(InvalidationChunk **destHdr,\n\t\t\t\t\t\t\t  InvalidationChunk **srcHdr)\n{\n\tInvalidationChunk *chunk = *srcHdr;\n\n\tif (chunk == NULL)\n\t\treturn;\t\t\t\t\t/* nothing to do */\n\n\twhile (chunk->next != NULL)\n\t\tchunk = chunk->next;\n\n\tchunk->next = *destHdr;\n\n\t*destHdr = *srcHdr;\n\n\t*srcHdr = NULL;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nAppendInvalidationMessageList(InvalidationChunk **destHdr,\n\t\t\t\t\t\t\t  InvalidationChunk **srcHdr)\n{\n\tInvalidationChunk *chunk = *srcHdr;\n\n\tif (chunk == NULL)\n\t\treturn;\t\t\t\t\t/* nothing to do */\n\n\twhile (chunk->next != NULL)\n\t\tchunk = chunk->next;\n\n\tchunk->next = *destHdr;\n\n\t*destHdr = *srcHdr;\n\n\t*srcHdr = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nAppendInvalidationMessages(InvalidationListHeader *dest,\n\t\t\t\t\t\t   InvalidationListHeader *src)\n{\n\tAppendInvalidationMessageList(&dest->cclist, &src->cclist);\n\tAppendInvalidationMessageList(&dest->rclist, &src->rclist);\n}"
  },
  {
    "function_name": "AddSnapshotInvalidationMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "414-435",
    "snippet": "static void\nAddSnapshotInvalidationMessage(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t   Oid dbId, Oid relId)\n{\n\tSharedInvalidationMessage msg;\n\n\t/* Don't add a duplicate item */\n\t/* We assume dbId need not be checked because it will never change */\n\tProcessMessageList(hdr->rclist,\n\t\t\t\t\t   if (msg->sn.id == SHAREDINVALSNAPSHOT_ID &&\n\t\t\t\t\t\t   msg->sn.relId == relId)\n\t\t\t\t\t   return);\n\n\t/* OK, add the item */\n\tmsg.sn.id = SHAREDINVALSNAPSHOT_ID;\n\tmsg.sn.dbId = dbId;\n\tmsg.sn.relId = relId;\n\t/* check AddCatcacheInvalidationMessage() for an explanation */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tAddInvalidationMessage(&hdr->rclist, &msg);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AddInvalidationMessage",
          "args": [
            "&hdr->rclist",
            "&msg"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "AddInvalidationMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "228-264",
          "snippet": "static void\nAddInvalidationMessage(InvalidationChunk **listHdr,\n\t\t\t\t\t   SharedInvalidationMessage *msg)\n{\n\tInvalidationChunk *chunk = *listHdr;\n\n\tif (chunk == NULL)\n\t{\n\t\t/* First time through; create initial chunk */\n#define FIRSTCHUNKSIZE 32\n\t\tchunk = (InvalidationChunk *)\n\t\t\tMemoryContextAlloc(CurTransactionContext,\n\t\t\t\t\t\t\t   offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   FIRSTCHUNKSIZE * sizeof(SharedInvalidationMessage));\n\t\tchunk->nitems = 0;\n\t\tchunk->maxitems = FIRSTCHUNKSIZE;\n\t\tchunk->next = *listHdr;\n\t\t*listHdr = chunk;\n\t}\n\telse if (chunk->nitems >= chunk->maxitems)\n\t{\n\t\t/* Need another chunk; double size of last chunk */\n\t\tint\t\t\tchunksize = 2 * chunk->maxitems;\n\n\t\tchunk = (InvalidationChunk *)\n\t\t\tMemoryContextAlloc(CurTransactionContext,\n\t\t\t\t\t\t\t   offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   chunksize * sizeof(SharedInvalidationMessage));\n\t\tchunk->nitems = 0;\n\t\tchunk->maxitems = chunksize;\n\t\tchunk->next = *listHdr;\n\t\t*listHdr = chunk;\n\t}\n\t/* Okay, add message to current chunk */\n\tchunk->msgs[chunk->nitems] = *msg;\n\tchunk->nitems++;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FIRSTCHUNKSIZE 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define FIRSTCHUNKSIZE 32\n\nstatic void\nAddInvalidationMessage(InvalidationChunk **listHdr,\n\t\t\t\t\t   SharedInvalidationMessage *msg)\n{\n\tInvalidationChunk *chunk = *listHdr;\n\n\tif (chunk == NULL)\n\t{\n\t\t/* First time through; create initial chunk */\n#define FIRSTCHUNKSIZE 32\n\t\tchunk = (InvalidationChunk *)\n\t\t\tMemoryContextAlloc(CurTransactionContext,\n\t\t\t\t\t\t\t   offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   FIRSTCHUNKSIZE * sizeof(SharedInvalidationMessage));\n\t\tchunk->nitems = 0;\n\t\tchunk->maxitems = FIRSTCHUNKSIZE;\n\t\tchunk->next = *listHdr;\n\t\t*listHdr = chunk;\n\t}\n\telse if (chunk->nitems >= chunk->maxitems)\n\t{\n\t\t/* Need another chunk; double size of last chunk */\n\t\tint\t\t\tchunksize = 2 * chunk->maxitems;\n\n\t\tchunk = (InvalidationChunk *)\n\t\t\tMemoryContextAlloc(CurTransactionContext,\n\t\t\t\t\t\t\t   offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   chunksize * sizeof(SharedInvalidationMessage));\n\t\tchunk->nitems = 0;\n\t\tchunk->maxitems = chunksize;\n\t\tchunk->next = *listHdr;\n\t\t*listHdr = chunk;\n\t}\n\t/* Okay, add message to current chunk */\n\tchunk->msgs[chunk->nitems] = *msg;\n\tchunk->nitems++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "&msg",
            "sizeof(msg)"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ProcessMessageList",
          "args": [
            "hdr->rclist",
            "if (msg->sn.id == SHAREDINVALSNAPSHOT_ID &&\n\t\t\t\t\t\t   msg->sn.relId == relId)return"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if",
          "args": [
            "msg->sn.id == SHAREDINVALSNAPSHOT_ID &&\n\t\t\t\t\t\t   msg->sn.relId == relId"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "map_xml_name_to_sql_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2080-2108",
          "snippet": "char *\nmap_xml_name_to_sql_identifier(const char *name)\n{\n\tStringInfoData buf;\n\tconst char *p;\n\n\tinitStringInfo(&buf);\n\n\tfor (p = name; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == '_' && *(p + 1) == 'x'\n\t\t\t&& isxdigit((unsigned char) *(p + 2))\n\t\t\t&& isxdigit((unsigned char) *(p + 3))\n\t\t\t&& isxdigit((unsigned char) *(p + 4))\n\t\t\t&& isxdigit((unsigned char) *(p + 5))\n\t\t\t&& *(p + 6) == '_')\n\t\t{\n\t\t\tunsigned int u;\n\n\t\t\tsscanf(p + 2, \"%X\", &u);\n\t\t\tappendStringInfoString(&buf, unicode_to_sqlchar(u));\n\t\t\tp += 6;\n\t\t}\n\t\telse\n\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t}\n\n\treturn buf.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nchar *\nmap_xml_name_to_sql_identifier(const char *name)\n{\n\tStringInfoData buf;\n\tconst char *p;\n\n\tinitStringInfo(&buf);\n\n\tfor (p = name; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == '_' && *(p + 1) == 'x'\n\t\t\t&& isxdigit((unsigned char) *(p + 2))\n\t\t\t&& isxdigit((unsigned char) *(p + 3))\n\t\t\t&& isxdigit((unsigned char) *(p + 4))\n\t\t\t&& isxdigit((unsigned char) *(p + 5))\n\t\t\t&& *(p + 6) == '_')\n\t\t{\n\t\t\tunsigned int u;\n\n\t\t\tsscanf(p + 2, \"%X\", &u);\n\t\t\tappendStringInfoString(&buf, unicode_to_sqlchar(u));\n\t\t\tp += 6;\n\t\t}\n\t\telse\n\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t}\n\n\treturn buf.data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nAddSnapshotInvalidationMessage(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t   Oid dbId, Oid relId)\n{\n\tSharedInvalidationMessage msg;\n\n\t/* Don't add a duplicate item */\n\t/* We assume dbId need not be checked because it will never change */\n\tProcessMessageList(hdr->rclist,\n\t\t\t\t\t   if (msg->sn.id == SHAREDINVALSNAPSHOT_ID &&\n\t\t\t\t\t\t   msg->sn.relId == relId)\n\t\t\t\t\t   return);\n\n\t/* OK, add the item */\n\tmsg.sn.id = SHAREDINVALSNAPSHOT_ID;\n\tmsg.sn.dbId = dbId;\n\tmsg.sn.relId = relId;\n\t/* check AddCatcacheInvalidationMessage() for an explanation */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tAddInvalidationMessage(&hdr->rclist, &msg);\n}"
  },
  {
    "function_name": "AddRelcacheInvalidationMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "384-409",
    "snippet": "static void\nAddRelcacheInvalidationMessage(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t   Oid dbId, Oid relId)\n{\n\tSharedInvalidationMessage msg;\n\n\t/*\n\t * Don't add a duplicate item. We assume dbId need not be checked because\n\t * it will never change. InvalidOid for relId means all relations so we\n\t * don't need to add individual ones when it is present.\n\t */\n\tProcessMessageList(hdr->rclist,\n\t\t\t\t\t   if (msg->rc.id == SHAREDINVALRELCACHE_ID &&\n\t\t\t\t\t\t   (msg->rc.relId == relId ||\n\t\t\t\t\t\t\tmsg->rc.relId == InvalidOid))\n\t\t\t\t\t   return);\n\n\t/* OK, add the item */\n\tmsg.rc.id = SHAREDINVALRELCACHE_ID;\n\tmsg.rc.dbId = dbId;\n\tmsg.rc.relId = relId;\n\t/* check AddCatcacheInvalidationMessage() for an explanation */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tAddInvalidationMessage(&hdr->rclist, &msg);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AddInvalidationMessage",
          "args": [
            "&hdr->rclist",
            "&msg"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "AddInvalidationMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "228-264",
          "snippet": "static void\nAddInvalidationMessage(InvalidationChunk **listHdr,\n\t\t\t\t\t   SharedInvalidationMessage *msg)\n{\n\tInvalidationChunk *chunk = *listHdr;\n\n\tif (chunk == NULL)\n\t{\n\t\t/* First time through; create initial chunk */\n#define FIRSTCHUNKSIZE 32\n\t\tchunk = (InvalidationChunk *)\n\t\t\tMemoryContextAlloc(CurTransactionContext,\n\t\t\t\t\t\t\t   offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   FIRSTCHUNKSIZE * sizeof(SharedInvalidationMessage));\n\t\tchunk->nitems = 0;\n\t\tchunk->maxitems = FIRSTCHUNKSIZE;\n\t\tchunk->next = *listHdr;\n\t\t*listHdr = chunk;\n\t}\n\telse if (chunk->nitems >= chunk->maxitems)\n\t{\n\t\t/* Need another chunk; double size of last chunk */\n\t\tint\t\t\tchunksize = 2 * chunk->maxitems;\n\n\t\tchunk = (InvalidationChunk *)\n\t\t\tMemoryContextAlloc(CurTransactionContext,\n\t\t\t\t\t\t\t   offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   chunksize * sizeof(SharedInvalidationMessage));\n\t\tchunk->nitems = 0;\n\t\tchunk->maxitems = chunksize;\n\t\tchunk->next = *listHdr;\n\t\t*listHdr = chunk;\n\t}\n\t/* Okay, add message to current chunk */\n\tchunk->msgs[chunk->nitems] = *msg;\n\tchunk->nitems++;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FIRSTCHUNKSIZE 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define FIRSTCHUNKSIZE 32\n\nstatic void\nAddInvalidationMessage(InvalidationChunk **listHdr,\n\t\t\t\t\t   SharedInvalidationMessage *msg)\n{\n\tInvalidationChunk *chunk = *listHdr;\n\n\tif (chunk == NULL)\n\t{\n\t\t/* First time through; create initial chunk */\n#define FIRSTCHUNKSIZE 32\n\t\tchunk = (InvalidationChunk *)\n\t\t\tMemoryContextAlloc(CurTransactionContext,\n\t\t\t\t\t\t\t   offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   FIRSTCHUNKSIZE * sizeof(SharedInvalidationMessage));\n\t\tchunk->nitems = 0;\n\t\tchunk->maxitems = FIRSTCHUNKSIZE;\n\t\tchunk->next = *listHdr;\n\t\t*listHdr = chunk;\n\t}\n\telse if (chunk->nitems >= chunk->maxitems)\n\t{\n\t\t/* Need another chunk; double size of last chunk */\n\t\tint\t\t\tchunksize = 2 * chunk->maxitems;\n\n\t\tchunk = (InvalidationChunk *)\n\t\t\tMemoryContextAlloc(CurTransactionContext,\n\t\t\t\t\t\t\t   offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   chunksize * sizeof(SharedInvalidationMessage));\n\t\tchunk->nitems = 0;\n\t\tchunk->maxitems = chunksize;\n\t\tchunk->next = *listHdr;\n\t\t*listHdr = chunk;\n\t}\n\t/* Okay, add message to current chunk */\n\tchunk->msgs[chunk->nitems] = *msg;\n\tchunk->nitems++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "&msg",
            "sizeof(msg)"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ProcessMessageList",
          "args": [
            "hdr->rclist",
            "if (msg->rc.id == SHAREDINVALRELCACHE_ID &&\n\t\t\t\t\t\t   (msg->rc.relId == relId ||\n\t\t\t\t\t\t\tmsg->rc.relId == InvalidOid))return"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if",
          "args": [
            "msg->rc.id == SHAREDINVALRELCACHE_ID &&\n\t\t\t\t\t\t   (msg->rc.relId == relId ||\n\t\t\t\t\t\t\tmsg->rc.relId == InvalidOid)"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "map_xml_name_to_sql_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "2080-2108",
          "snippet": "char *\nmap_xml_name_to_sql_identifier(const char *name)\n{\n\tStringInfoData buf;\n\tconst char *p;\n\n\tinitStringInfo(&buf);\n\n\tfor (p = name; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == '_' && *(p + 1) == 'x'\n\t\t\t&& isxdigit((unsigned char) *(p + 2))\n\t\t\t&& isxdigit((unsigned char) *(p + 3))\n\t\t\t&& isxdigit((unsigned char) *(p + 4))\n\t\t\t&& isxdigit((unsigned char) *(p + 5))\n\t\t\t&& *(p + 6) == '_')\n\t\t{\n\t\t\tunsigned int u;\n\n\t\t\tsscanf(p + 2, \"%X\", &u);\n\t\t\tappendStringInfoString(&buf, unicode_to_sqlchar(u));\n\t\t\tp += 6;\n\t\t}\n\t\telse\n\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t}\n\n\treturn buf.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nchar *\nmap_xml_name_to_sql_identifier(const char *name)\n{\n\tStringInfoData buf;\n\tconst char *p;\n\n\tinitStringInfo(&buf);\n\n\tfor (p = name; *p; p += pg_mblen(p))\n\t{\n\t\tif (*p == '_' && *(p + 1) == 'x'\n\t\t\t&& isxdigit((unsigned char) *(p + 2))\n\t\t\t&& isxdigit((unsigned char) *(p + 3))\n\t\t\t&& isxdigit((unsigned char) *(p + 4))\n\t\t\t&& isxdigit((unsigned char) *(p + 5))\n\t\t\t&& *(p + 6) == '_')\n\t\t{\n\t\t\tunsigned int u;\n\n\t\t\tsscanf(p + 2, \"%X\", &u);\n\t\t\tappendStringInfoString(&buf, unicode_to_sqlchar(u));\n\t\t\tp += 6;\n\t\t}\n\t\telse\n\t\t\tappendBinaryStringInfo(&buf, p, pg_mblen(p));\n\t}\n\n\treturn buf.data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nAddRelcacheInvalidationMessage(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t   Oid dbId, Oid relId)\n{\n\tSharedInvalidationMessage msg;\n\n\t/*\n\t * Don't add a duplicate item. We assume dbId need not be checked because\n\t * it will never change. InvalidOid for relId means all relations so we\n\t * don't need to add individual ones when it is present.\n\t */\n\tProcessMessageList(hdr->rclist,\n\t\t\t\t\t   if (msg->rc.id == SHAREDINVALRELCACHE_ID &&\n\t\t\t\t\t\t   (msg->rc.relId == relId ||\n\t\t\t\t\t\t\tmsg->rc.relId == InvalidOid))\n\t\t\t\t\t   return);\n\n\t/* OK, add the item */\n\tmsg.rc.id = SHAREDINVALRELCACHE_ID;\n\tmsg.rc.dbId = dbId;\n\tmsg.rc.relId = relId;\n\t/* check AddCatcacheInvalidationMessage() for an explanation */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tAddInvalidationMessage(&hdr->rclist, &msg);\n}"
  },
  {
    "function_name": "AddCatalogInvalidationMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "366-379",
    "snippet": "static void\nAddCatalogInvalidationMessage(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t  Oid dbId, Oid catId)\n{\n\tSharedInvalidationMessage msg;\n\n\tmsg.cat.id = SHAREDINVALCATALOG_ID;\n\tmsg.cat.dbId = dbId;\n\tmsg.cat.catId = catId;\n\t/* check AddCatcacheInvalidationMessage() for an explanation */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tAddInvalidationMessage(&hdr->cclist, &msg);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AddInvalidationMessage",
          "args": [
            "&hdr->cclist",
            "&msg"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "AddInvalidationMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "228-264",
          "snippet": "static void\nAddInvalidationMessage(InvalidationChunk **listHdr,\n\t\t\t\t\t   SharedInvalidationMessage *msg)\n{\n\tInvalidationChunk *chunk = *listHdr;\n\n\tif (chunk == NULL)\n\t{\n\t\t/* First time through; create initial chunk */\n#define FIRSTCHUNKSIZE 32\n\t\tchunk = (InvalidationChunk *)\n\t\t\tMemoryContextAlloc(CurTransactionContext,\n\t\t\t\t\t\t\t   offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   FIRSTCHUNKSIZE * sizeof(SharedInvalidationMessage));\n\t\tchunk->nitems = 0;\n\t\tchunk->maxitems = FIRSTCHUNKSIZE;\n\t\tchunk->next = *listHdr;\n\t\t*listHdr = chunk;\n\t}\n\telse if (chunk->nitems >= chunk->maxitems)\n\t{\n\t\t/* Need another chunk; double size of last chunk */\n\t\tint\t\t\tchunksize = 2 * chunk->maxitems;\n\n\t\tchunk = (InvalidationChunk *)\n\t\t\tMemoryContextAlloc(CurTransactionContext,\n\t\t\t\t\t\t\t   offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   chunksize * sizeof(SharedInvalidationMessage));\n\t\tchunk->nitems = 0;\n\t\tchunk->maxitems = chunksize;\n\t\tchunk->next = *listHdr;\n\t\t*listHdr = chunk;\n\t}\n\t/* Okay, add message to current chunk */\n\tchunk->msgs[chunk->nitems] = *msg;\n\tchunk->nitems++;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FIRSTCHUNKSIZE 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define FIRSTCHUNKSIZE 32\n\nstatic void\nAddInvalidationMessage(InvalidationChunk **listHdr,\n\t\t\t\t\t   SharedInvalidationMessage *msg)\n{\n\tInvalidationChunk *chunk = *listHdr;\n\n\tif (chunk == NULL)\n\t{\n\t\t/* First time through; create initial chunk */\n#define FIRSTCHUNKSIZE 32\n\t\tchunk = (InvalidationChunk *)\n\t\t\tMemoryContextAlloc(CurTransactionContext,\n\t\t\t\t\t\t\t   offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   FIRSTCHUNKSIZE * sizeof(SharedInvalidationMessage));\n\t\tchunk->nitems = 0;\n\t\tchunk->maxitems = FIRSTCHUNKSIZE;\n\t\tchunk->next = *listHdr;\n\t\t*listHdr = chunk;\n\t}\n\telse if (chunk->nitems >= chunk->maxitems)\n\t{\n\t\t/* Need another chunk; double size of last chunk */\n\t\tint\t\t\tchunksize = 2 * chunk->maxitems;\n\n\t\tchunk = (InvalidationChunk *)\n\t\t\tMemoryContextAlloc(CurTransactionContext,\n\t\t\t\t\t\t\t   offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   chunksize * sizeof(SharedInvalidationMessage));\n\t\tchunk->nitems = 0;\n\t\tchunk->maxitems = chunksize;\n\t\tchunk->next = *listHdr;\n\t\t*listHdr = chunk;\n\t}\n\t/* Okay, add message to current chunk */\n\tchunk->msgs[chunk->nitems] = *msg;\n\tchunk->nitems++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "&msg",
            "sizeof(msg)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nAddCatalogInvalidationMessage(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t  Oid dbId, Oid catId)\n{\n\tSharedInvalidationMessage msg;\n\n\tmsg.cat.id = SHAREDINVALCATALOG_ID;\n\tmsg.cat.dbId = dbId;\n\tmsg.cat.catId = catId;\n\t/* check AddCatcacheInvalidationMessage() for an explanation */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tAddInvalidationMessage(&hdr->cclist, &msg);\n}"
  },
  {
    "function_name": "AddCatcacheInvalidationMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "338-361",
    "snippet": "static void\nAddCatcacheInvalidationMessage(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t   int id, uint32 hashValue, Oid dbId)\n{\n\tSharedInvalidationMessage msg;\n\n\tAssert(id < CHAR_MAX);\n\tmsg.cc.id = (int8) id;\n\tmsg.cc.dbId = dbId;\n\tmsg.cc.hashValue = hashValue;\n\n\t/*\n\t * Define padding bytes in SharedInvalidationMessage structs to be\n\t * defined. Otherwise the sinvaladt.c ringbuffer, which is accessed by\n\t * multiple processes, will cause spurious valgrind warnings about\n\t * undefined memory being used. That's because valgrind remembers the\n\t * undefined bytes from the last local process's store, not realizing that\n\t * another process has written since, filling the previously uninitialized\n\t * bytes\n\t */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tAddInvalidationMessage(&hdr->cclist, &msg);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AddInvalidationMessage",
          "args": [
            "&hdr->cclist",
            "&msg"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "AddInvalidationMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "228-264",
          "snippet": "static void\nAddInvalidationMessage(InvalidationChunk **listHdr,\n\t\t\t\t\t   SharedInvalidationMessage *msg)\n{\n\tInvalidationChunk *chunk = *listHdr;\n\n\tif (chunk == NULL)\n\t{\n\t\t/* First time through; create initial chunk */\n#define FIRSTCHUNKSIZE 32\n\t\tchunk = (InvalidationChunk *)\n\t\t\tMemoryContextAlloc(CurTransactionContext,\n\t\t\t\t\t\t\t   offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   FIRSTCHUNKSIZE * sizeof(SharedInvalidationMessage));\n\t\tchunk->nitems = 0;\n\t\tchunk->maxitems = FIRSTCHUNKSIZE;\n\t\tchunk->next = *listHdr;\n\t\t*listHdr = chunk;\n\t}\n\telse if (chunk->nitems >= chunk->maxitems)\n\t{\n\t\t/* Need another chunk; double size of last chunk */\n\t\tint\t\t\tchunksize = 2 * chunk->maxitems;\n\n\t\tchunk = (InvalidationChunk *)\n\t\t\tMemoryContextAlloc(CurTransactionContext,\n\t\t\t\t\t\t\t   offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   chunksize * sizeof(SharedInvalidationMessage));\n\t\tchunk->nitems = 0;\n\t\tchunk->maxitems = chunksize;\n\t\tchunk->next = *listHdr;\n\t\t*listHdr = chunk;\n\t}\n\t/* Okay, add message to current chunk */\n\tchunk->msgs[chunk->nitems] = *msg;\n\tchunk->nitems++;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FIRSTCHUNKSIZE 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define FIRSTCHUNKSIZE 32\n\nstatic void\nAddInvalidationMessage(InvalidationChunk **listHdr,\n\t\t\t\t\t   SharedInvalidationMessage *msg)\n{\n\tInvalidationChunk *chunk = *listHdr;\n\n\tif (chunk == NULL)\n\t{\n\t\t/* First time through; create initial chunk */\n#define FIRSTCHUNKSIZE 32\n\t\tchunk = (InvalidationChunk *)\n\t\t\tMemoryContextAlloc(CurTransactionContext,\n\t\t\t\t\t\t\t   offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   FIRSTCHUNKSIZE * sizeof(SharedInvalidationMessage));\n\t\tchunk->nitems = 0;\n\t\tchunk->maxitems = FIRSTCHUNKSIZE;\n\t\tchunk->next = *listHdr;\n\t\t*listHdr = chunk;\n\t}\n\telse if (chunk->nitems >= chunk->maxitems)\n\t{\n\t\t/* Need another chunk; double size of last chunk */\n\t\tint\t\t\tchunksize = 2 * chunk->maxitems;\n\n\t\tchunk = (InvalidationChunk *)\n\t\t\tMemoryContextAlloc(CurTransactionContext,\n\t\t\t\t\t\t\t   offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   chunksize * sizeof(SharedInvalidationMessage));\n\t\tchunk->nitems = 0;\n\t\tchunk->maxitems = chunksize;\n\t\tchunk->next = *listHdr;\n\t\t*listHdr = chunk;\n\t}\n\t/* Okay, add message to current chunk */\n\tchunk->msgs[chunk->nitems] = *msg;\n\tchunk->nitems++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VALGRIND_MAKE_MEM_DEFINED",
          "args": [
            "&msg",
            "sizeof(msg)"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "id < CHAR_MAX"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nAddCatcacheInvalidationMessage(InvalidationListHeader *hdr,\n\t\t\t\t\t\t\t   int id, uint32 hashValue, Oid dbId)\n{\n\tSharedInvalidationMessage msg;\n\n\tAssert(id < CHAR_MAX);\n\tmsg.cc.id = (int8) id;\n\tmsg.cc.dbId = dbId;\n\tmsg.cc.hashValue = hashValue;\n\n\t/*\n\t * Define padding bytes in SharedInvalidationMessage structs to be\n\t * defined. Otherwise the sinvaladt.c ringbuffer, which is accessed by\n\t * multiple processes, will cause spurious valgrind warnings about\n\t * undefined memory being used. That's because valgrind remembers the\n\t * undefined bytes from the last local process's store, not realizing that\n\t * another process has written since, filling the previously uninitialized\n\t * bytes\n\t */\n\tVALGRIND_MAKE_MEM_DEFINED(&msg, sizeof(msg));\n\n\tAddInvalidationMessage(&hdr->cclist, &msg);\n}"
  },
  {
    "function_name": "AppendInvalidationMessageList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "270-287",
    "snippet": "static void\nAppendInvalidationMessageList(InvalidationChunk **destHdr,\n\t\t\t\t\t\t\t  InvalidationChunk **srcHdr)\n{\n\tInvalidationChunk *chunk = *srcHdr;\n\n\tif (chunk == NULL)\n\t\treturn;\t\t\t\t\t/* nothing to do */\n\n\twhile (chunk->next != NULL)\n\t\tchunk = chunk->next;\n\n\tchunk->next = *destHdr;\n\n\t*destHdr = *srcHdr;\n\n\t*srcHdr = NULL;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nAppendInvalidationMessageList(InvalidationChunk **destHdr,\n\t\t\t\t\t\t\t  InvalidationChunk **srcHdr)\n{\n\tInvalidationChunk *chunk = *srcHdr;\n\n\tif (chunk == NULL)\n\t\treturn;\t\t\t\t\t/* nothing to do */\n\n\twhile (chunk->next != NULL)\n\t\tchunk = chunk->next;\n\n\tchunk->next = *destHdr;\n\n\t*destHdr = *srcHdr;\n\n\t*srcHdr = NULL;\n}"
  },
  {
    "function_name": "AddInvalidationMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
    "lines": "228-264",
    "snippet": "static void\nAddInvalidationMessage(InvalidationChunk **listHdr,\n\t\t\t\t\t   SharedInvalidationMessage *msg)\n{\n\tInvalidationChunk *chunk = *listHdr;\n\n\tif (chunk == NULL)\n\t{\n\t\t/* First time through; create initial chunk */\n#define FIRSTCHUNKSIZE 32\n\t\tchunk = (InvalidationChunk *)\n\t\t\tMemoryContextAlloc(CurTransactionContext,\n\t\t\t\t\t\t\t   offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   FIRSTCHUNKSIZE * sizeof(SharedInvalidationMessage));\n\t\tchunk->nitems = 0;\n\t\tchunk->maxitems = FIRSTCHUNKSIZE;\n\t\tchunk->next = *listHdr;\n\t\t*listHdr = chunk;\n\t}\n\telse if (chunk->nitems >= chunk->maxitems)\n\t{\n\t\t/* Need another chunk; double size of last chunk */\n\t\tint\t\t\tchunksize = 2 * chunk->maxitems;\n\n\t\tchunk = (InvalidationChunk *)\n\t\t\tMemoryContextAlloc(CurTransactionContext,\n\t\t\t\t\t\t\t   offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   chunksize * sizeof(SharedInvalidationMessage));\n\t\tchunk->nitems = 0;\n\t\tchunk->maxitems = chunksize;\n\t\tchunk->next = *listHdr;\n\t\t*listHdr = chunk;\n\t}\n\t/* Okay, add message to current chunk */\n\tchunk->msgs[chunk->nitems] = *msg;\n\tchunk->nitems++;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/rel.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/memdebug.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/catcache.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/sinval.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FIRSTCHUNKSIZE 32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "CurTransactionContext",
            "offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   chunksize * sizeof(SharedInvalidationMessage)"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define FIRSTCHUNKSIZE 32\n\nstatic void\nAddInvalidationMessage(InvalidationChunk **listHdr,\n\t\t\t\t\t   SharedInvalidationMessage *msg)\n{\n\tInvalidationChunk *chunk = *listHdr;\n\n\tif (chunk == NULL)\n\t{\n\t\t/* First time through; create initial chunk */\n#define FIRSTCHUNKSIZE 32\n\t\tchunk = (InvalidationChunk *)\n\t\t\tMemoryContextAlloc(CurTransactionContext,\n\t\t\t\t\t\t\t   offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   FIRSTCHUNKSIZE * sizeof(SharedInvalidationMessage));\n\t\tchunk->nitems = 0;\n\t\tchunk->maxitems = FIRSTCHUNKSIZE;\n\t\tchunk->next = *listHdr;\n\t\t*listHdr = chunk;\n\t}\n\telse if (chunk->nitems >= chunk->maxitems)\n\t{\n\t\t/* Need another chunk; double size of last chunk */\n\t\tint\t\t\tchunksize = 2 * chunk->maxitems;\n\n\t\tchunk = (InvalidationChunk *)\n\t\t\tMemoryContextAlloc(CurTransactionContext,\n\t\t\t\t\t\t\t   offsetof(InvalidationChunk, msgs) +\n\t\t\t\t\t\t\t   chunksize * sizeof(SharedInvalidationMessage));\n\t\tchunk->nitems = 0;\n\t\tchunk->maxitems = chunksize;\n\t\tchunk->next = *listHdr;\n\t\t*listHdr = chunk;\n\t}\n\t/* Okay, add message to current chunk */\n\tchunk->msgs[chunk->nitems] = *msg;\n\tchunk->nitems++;\n}"
  }
]