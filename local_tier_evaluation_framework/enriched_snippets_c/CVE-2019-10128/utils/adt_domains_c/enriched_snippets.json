[
  {
    "function_name": "errdomainconstraint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
    "lines": "383-390",
    "snippet": "int\nerrdomainconstraint(Oid datatypeOid, const char *conname)\n{\n\terrdatatype(datatypeOid);\n\terr_generic_string(PG_DIAG_CONSTRAINT_NAME, conname);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/expandeddatum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "err_generic_string",
          "args": [
            "PG_DIAG_CONSTRAINT_NAME",
            "conname"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "err_generic_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1188-1219",
          "snippet": "int\nerr_generic_string(int field, const char *str)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (field)\n\t{\n\t\tcase PG_DIAG_SCHEMA_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->schema_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_TABLE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->table_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_COLUMN_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->column_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_DATATYPE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->datatype_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_CONSTRAINT_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->constraint_name, str);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unsupported ErrorData field id: %d\", field);\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static void append_with_tabs(StringInfo buf, const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic void append_with_tabs(StringInfo buf, const char *str);\n\nint\nerr_generic_string(int field, const char *str)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (field)\n\t{\n\t\tcase PG_DIAG_SCHEMA_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->schema_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_TABLE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->table_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_COLUMN_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->column_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_DATATYPE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->datatype_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_CONSTRAINT_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->constraint_name, str);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unsupported ErrorData field id: %d\", field);\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errdatatype",
          "args": [
            "datatypeOid"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "errdatatype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
          "lines": "359-377",
          "snippet": "int\nerrdatatype(Oid datatypeOid)\n{\n\tHeapTuple\ttup;\n\tForm_pg_type typtup;\n\n\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(datatypeOid));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for type %u\", datatypeOid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tup);\n\n\terr_generic_string(PG_DIAG_SCHEMA_NAME,\n\t\t\t\t\t   get_namespace_name(typtup->typnamespace));\n\terr_generic_string(PG_DIAG_DATATYPE_NAME, NameStr(typtup->typname));\n\n\tReleaseSysCache(tup);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nint\nerrdatatype(Oid datatypeOid)\n{\n\tHeapTuple\ttup;\n\tForm_pg_type typtup;\n\n\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(datatypeOid));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for type %u\", datatypeOid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tup);\n\n\terr_generic_string(PG_DIAG_SCHEMA_NAME,\n\t\t\t\t\t   get_namespace_name(typtup->typnamespace));\n\terr_generic_string(PG_DIAG_DATATYPE_NAME, NameStr(typtup->typname));\n\n\tReleaseSysCache(tup);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nint\nerrdomainconstraint(Oid datatypeOid, const char *conname)\n{\n\terrdatatype(datatypeOid);\n\terr_generic_string(PG_DIAG_CONSTRAINT_NAME, conname);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errdatatype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
    "lines": "359-377",
    "snippet": "int\nerrdatatype(Oid datatypeOid)\n{\n\tHeapTuple\ttup;\n\tForm_pg_type typtup;\n\n\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(datatypeOid));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for type %u\", datatypeOid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tup);\n\n\terr_generic_string(PG_DIAG_SCHEMA_NAME,\n\t\t\t\t\t   get_namespace_name(typtup->typnamespace));\n\terr_generic_string(PG_DIAG_DATATYPE_NAME, NameStr(typtup->typname));\n\n\tReleaseSysCache(tup);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/expandeddatum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tup"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "err_generic_string",
          "args": [
            "PG_DIAG_DATATYPE_NAME",
            "NameStr(typtup->typname)"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "err_generic_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1188-1219",
          "snippet": "int\nerr_generic_string(int field, const char *str)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (field)\n\t{\n\t\tcase PG_DIAG_SCHEMA_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->schema_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_TABLE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->table_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_COLUMN_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->column_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_DATATYPE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->datatype_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_CONSTRAINT_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->constraint_name, str);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unsupported ErrorData field id: %d\", field);\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static void append_with_tabs(StringInfo buf, const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic void append_with_tabs(StringInfo buf, const char *str);\n\nint\nerr_generic_string(int field, const char *str)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (field)\n\t{\n\t\tcase PG_DIAG_SCHEMA_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->schema_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_TABLE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->table_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_COLUMN_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->column_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_DATATYPE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->datatype_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_CONSTRAINT_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->constraint_name, str);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unsupported ErrorData field id: %d\", field);\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "typtup->typname"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_namespace_name",
          "args": [
            "typtup->typnamespace"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tup"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for type %u\"",
            "datatypeOid"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tup"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "TYPEOID",
            "ObjectIdGetDatum(datatypeOid)"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "datatypeOid"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nint\nerrdatatype(Oid datatypeOid)\n{\n\tHeapTuple\ttup;\n\tForm_pg_type typtup;\n\n\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(datatypeOid));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for type %u\", datatypeOid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tup);\n\n\terr_generic_string(PG_DIAG_SCHEMA_NAME,\n\t\t\t\t\t   get_namespace_name(typtup->typnamespace));\n\terr_generic_string(PG_DIAG_DATATYPE_NAME, NameStr(typtup->typname));\n\n\tReleaseSysCache(tup);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "domain_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
    "lines": "326-353",
    "snippet": "void\ndomain_check(Datum value, bool isnull, Oid domainType,\n\t\t\t void **extra, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra = NULL;\n\n\tif (mcxt == NULL)\n\t\tmcxt = CurrentMemoryContext;\n\n\t/*\n\t * We arrange to look up the needed info just once per series of calls,\n\t * assuming the domain type doesn't change underneath us (which really\n\t * shouldn't happen, but cope if it does).\n\t */\n\tif (extra)\n\t\tmy_extra = (DomainIOData *) *extra;\n\tif (my_extra == NULL || my_extra->domain_type != domainType)\n\t{\n\t\tmy_extra = domain_state_setup(domainType, true, mcxt);\n\t\tif (extra)\n\t\t\t*extra = (void *) my_extra;\n\t}\n\n\t/*\n\t * Do the necessary checks to ensure it's a valid domain value.\n\t */\n\tdomain_check_input(value, isnull, my_extra);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/expandeddatum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "domain_check_input",
          "args": [
            "value",
            "isnull",
            "my_extra"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "domain_check_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
          "lines": "130-205",
          "snippet": "static void\ndomain_check_input(Datum value, bool isnull, DomainIOData *my_extra)\n{\n\tExprContext *econtext = my_extra->econtext;\n\tListCell   *l;\n\n\t/* Make sure we have up-to-date constraints */\n\tUpdateDomainConstraintRef(&my_extra->constraint_ref);\n\n\tforeach(l, my_extra->constraint_ref.constraints)\n\t{\n\t\tDomainConstraintState *con = (DomainConstraintState *) lfirst(l);\n\n\t\tswitch (con->constrainttype)\n\t\t{\n\t\t\tcase DOM_CONSTRAINT_NOTNULL:\n\t\t\t\tif (isnull)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_NOT_NULL_VIOLATION),\n\t\t\t\t\t\t\t errmsg(\"domain %s does not allow null values\",\n\t\t\t\t\t\t\t\t\tformat_type_be(my_extra->domain_type)),\n\t\t\t\t\t\t\t errdatatype(my_extra->domain_type)));\n\t\t\t\tbreak;\n\t\t\tcase DOM_CONSTRAINT_CHECK:\n\t\t\t\t{\n\t\t\t\t\t/* Make the econtext if we didn't already */\n\t\t\t\t\tif (econtext == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tMemoryContext oldcontext;\n\n\t\t\t\t\t\toldcontext = MemoryContextSwitchTo(my_extra->mcxt);\n\t\t\t\t\t\tecontext = CreateStandaloneExprContext();\n\t\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\t\tmy_extra->econtext = econtext;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set up value to be returned by CoerceToDomainValue\n\t\t\t\t\t * nodes.  Unlike in the generic expression case, this\n\t\t\t\t\t * econtext couldn't be shared with anything else, so no\n\t\t\t\t\t * need to save and restore fields.  But we do need to\n\t\t\t\t\t * protect the passed-in value against being changed by\n\t\t\t\t\t * called functions.  (It couldn't be a R/W expanded\n\t\t\t\t\t * object for most uses, but that seems possible for\n\t\t\t\t\t * domain_check().)\n\t\t\t\t\t */\n\t\t\t\t\tecontext->domainValue_datum =\n\t\t\t\t\t\tMakeExpandedObjectReadOnly(value, isnull,\n\t\t\t\t\t\t\t\t\t\t\t\t   my_extra->constraint_ref.tcache->typlen);\n\t\t\t\t\tecontext->domainValue_isNull = isnull;\n\n\t\t\t\t\tif (!ExecCheck(con->check_exprstate, econtext))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CHECK_VIOLATION),\n\t\t\t\t\t\t\t\t errmsg(\"value for domain %s violates check constraint \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\tformat_type_be(my_extra->domain_type),\n\t\t\t\t\t\t\t\t\t\tcon->name),\n\t\t\t\t\t\t\t\t errdomainconstraint(my_extra->domain_type,\n\t\t\t\t\t\t\t\t\t\t\t\t\t con->name)));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized constraint type: %d\",\n\t\t\t\t\t (int) con->constrainttype);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Before exiting, call any shutdown callbacks and reset econtext's\n\t * per-tuple memory.  This avoids leaking non-memory resources, if\n\t * anything in the expression(s) has any.\n\t */\n\tif (econtext)\n\t\tReScanExprContext(econtext);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\ndomain_check_input(Datum value, bool isnull, DomainIOData *my_extra)\n{\n\tExprContext *econtext = my_extra->econtext;\n\tListCell   *l;\n\n\t/* Make sure we have up-to-date constraints */\n\tUpdateDomainConstraintRef(&my_extra->constraint_ref);\n\n\tforeach(l, my_extra->constraint_ref.constraints)\n\t{\n\t\tDomainConstraintState *con = (DomainConstraintState *) lfirst(l);\n\n\t\tswitch (con->constrainttype)\n\t\t{\n\t\t\tcase DOM_CONSTRAINT_NOTNULL:\n\t\t\t\tif (isnull)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_NOT_NULL_VIOLATION),\n\t\t\t\t\t\t\t errmsg(\"domain %s does not allow null values\",\n\t\t\t\t\t\t\t\t\tformat_type_be(my_extra->domain_type)),\n\t\t\t\t\t\t\t errdatatype(my_extra->domain_type)));\n\t\t\t\tbreak;\n\t\t\tcase DOM_CONSTRAINT_CHECK:\n\t\t\t\t{\n\t\t\t\t\t/* Make the econtext if we didn't already */\n\t\t\t\t\tif (econtext == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tMemoryContext oldcontext;\n\n\t\t\t\t\t\toldcontext = MemoryContextSwitchTo(my_extra->mcxt);\n\t\t\t\t\t\tecontext = CreateStandaloneExprContext();\n\t\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\t\tmy_extra->econtext = econtext;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set up value to be returned by CoerceToDomainValue\n\t\t\t\t\t * nodes.  Unlike in the generic expression case, this\n\t\t\t\t\t * econtext couldn't be shared with anything else, so no\n\t\t\t\t\t * need to save and restore fields.  But we do need to\n\t\t\t\t\t * protect the passed-in value against being changed by\n\t\t\t\t\t * called functions.  (It couldn't be a R/W expanded\n\t\t\t\t\t * object for most uses, but that seems possible for\n\t\t\t\t\t * domain_check().)\n\t\t\t\t\t */\n\t\t\t\t\tecontext->domainValue_datum =\n\t\t\t\t\t\tMakeExpandedObjectReadOnly(value, isnull,\n\t\t\t\t\t\t\t\t\t\t\t\t   my_extra->constraint_ref.tcache->typlen);\n\t\t\t\t\tecontext->domainValue_isNull = isnull;\n\n\t\t\t\t\tif (!ExecCheck(con->check_exprstate, econtext))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CHECK_VIOLATION),\n\t\t\t\t\t\t\t\t errmsg(\"value for domain %s violates check constraint \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\tformat_type_be(my_extra->domain_type),\n\t\t\t\t\t\t\t\t\t\tcon->name),\n\t\t\t\t\t\t\t\t errdomainconstraint(my_extra->domain_type,\n\t\t\t\t\t\t\t\t\t\t\t\t\t con->name)));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized constraint type: %d\",\n\t\t\t\t\t (int) con->constrainttype);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Before exiting, call any shutdown callbacks and reset econtext's\n\t * per-tuple memory.  This avoids leaking non-memory resources, if\n\t * anything in the expression(s) has any.\n\t */\n\tif (econtext)\n\t\tReScanExprContext(econtext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "domain_state_setup",
          "args": [
            "domainType",
            "true",
            "mcxt"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "domain_state_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
          "lines": "72-121",
          "snippet": "static DomainIOData *\ndomain_state_setup(Oid domainType, bool binary, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra;\n\tTypeCacheEntry *typentry;\n\tOid\t\t\tbaseType;\n\n\tmy_extra = (DomainIOData *) MemoryContextAlloc(mcxt, sizeof(DomainIOData));\n\n\t/*\n\t * Verify that domainType represents a valid domain type.  We need to be\n\t * careful here because domain_in and domain_recv can be called from SQL,\n\t * possibly with incorrect arguments.  We use lookup_type_cache mainly\n\t * because it will throw a clean user-facing error for a bad OID; but also\n\t * it can cache the underlying base type info.\n\t */\n\ttypentry = lookup_type_cache(domainType, TYPECACHE_DOMAIN_BASE_INFO);\n\tif (typentry->typtype != TYPTYPE_DOMAIN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"type %s is not a domain\",\n\t\t\t\t\t\tformat_type_be(domainType))));\n\n\t/* Find out the base type */\n\tbaseType = typentry->domainBaseType;\n\tmy_extra->typtypmod = typentry->domainBaseTypmod;\n\n\t/* Look up underlying I/O function */\n\tif (binary)\n\t\tgetTypeBinaryInputInfo(baseType,\n\t\t\t\t\t\t\t   &my_extra->typiofunc,\n\t\t\t\t\t\t\t   &my_extra->typioparam);\n\telse\n\t\tgetTypeInputInfo(baseType,\n\t\t\t\t\t\t &my_extra->typiofunc,\n\t\t\t\t\t\t &my_extra->typioparam);\n\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc, mcxt);\n\n\t/* Look up constraints for domain */\n\tInitDomainConstraintRef(domainType, &my_extra->constraint_ref, mcxt, true);\n\n\t/* We don't make an ExprContext until needed */\n\tmy_extra->econtext = NULL;\n\tmy_extra->mcxt = mcxt;\n\n\t/* Mark cache valid */\n\tmy_extra->domain_type = domainType;\n\n\treturn my_extra;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic DomainIOData *\ndomain_state_setup(Oid domainType, bool binary, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra;\n\tTypeCacheEntry *typentry;\n\tOid\t\t\tbaseType;\n\n\tmy_extra = (DomainIOData *) MemoryContextAlloc(mcxt, sizeof(DomainIOData));\n\n\t/*\n\t * Verify that domainType represents a valid domain type.  We need to be\n\t * careful here because domain_in and domain_recv can be called from SQL,\n\t * possibly with incorrect arguments.  We use lookup_type_cache mainly\n\t * because it will throw a clean user-facing error for a bad OID; but also\n\t * it can cache the underlying base type info.\n\t */\n\ttypentry = lookup_type_cache(domainType, TYPECACHE_DOMAIN_BASE_INFO);\n\tif (typentry->typtype != TYPTYPE_DOMAIN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"type %s is not a domain\",\n\t\t\t\t\t\tformat_type_be(domainType))));\n\n\t/* Find out the base type */\n\tbaseType = typentry->domainBaseType;\n\tmy_extra->typtypmod = typentry->domainBaseTypmod;\n\n\t/* Look up underlying I/O function */\n\tif (binary)\n\t\tgetTypeBinaryInputInfo(baseType,\n\t\t\t\t\t\t\t   &my_extra->typiofunc,\n\t\t\t\t\t\t\t   &my_extra->typioparam);\n\telse\n\t\tgetTypeInputInfo(baseType,\n\t\t\t\t\t\t &my_extra->typiofunc,\n\t\t\t\t\t\t &my_extra->typioparam);\n\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc, mcxt);\n\n\t/* Look up constraints for domain */\n\tInitDomainConstraintRef(domainType, &my_extra->constraint_ref, mcxt, true);\n\n\t/* We don't make an ExprContext until needed */\n\tmy_extra->econtext = NULL;\n\tmy_extra->mcxt = mcxt;\n\n\t/* Mark cache valid */\n\tmy_extra->domain_type = domainType;\n\n\treturn my_extra;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\ndomain_check(Datum value, bool isnull, Oid domainType,\n\t\t\t void **extra, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra = NULL;\n\n\tif (mcxt == NULL)\n\t\tmcxt = CurrentMemoryContext;\n\n\t/*\n\t * We arrange to look up the needed info just once per series of calls,\n\t * assuming the domain type doesn't change underneath us (which really\n\t * shouldn't happen, but cope if it does).\n\t */\n\tif (extra)\n\t\tmy_extra = (DomainIOData *) *extra;\n\tif (my_extra == NULL || my_extra->domain_type != domainType)\n\t{\n\t\tmy_extra = domain_state_setup(domainType, true, mcxt);\n\t\tif (extra)\n\t\t\t*extra = (void *) my_extra;\n\t}\n\n\t/*\n\t * Do the necessary checks to ensure it's a valid domain value.\n\t */\n\tdomain_check_input(value, isnull, my_extra);\n}"
  },
  {
    "function_name": "domain_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
    "lines": "267-318",
    "snippet": "Datum\ndomain_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf;\n\tOid\t\t\tdomainType;\n\tDomainIOData *my_extra;\n\tDatum\t\tvalue;\n\n\t/*\n\t * Since domain_recv is not strict, we have to check for null inputs. The\n\t * typioparam argument should never be null in normal system usage, but it\n\t * could be null in a manual invocation --- if so, just return null.\n\t */\n\tif (PG_ARGISNULL(0))\n\t\tbuf = NULL;\n\telse\n\t\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tif (PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\tdomainType = PG_GETARG_OID(1);\n\n\t/*\n\t * We arrange to look up the needed info just once per series of calls,\n\t * assuming the domain type doesn't change underneath us (which really\n\t * shouldn't happen, but cope if it does).\n\t */\n\tmy_extra = (DomainIOData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL || my_extra->domain_type != domainType)\n\t{\n\t\tmy_extra = domain_state_setup(domainType, true,\n\t\t\t\t\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tfcinfo->flinfo->fn_extra = (void *) my_extra;\n\t}\n\n\t/*\n\t * Invoke the base type's typreceive procedure to convert the data.\n\t */\n\tvalue = ReceiveFunctionCall(&my_extra->proc,\n\t\t\t\t\t\t\t\tbuf,\n\t\t\t\t\t\t\t\tmy_extra->typioparam,\n\t\t\t\t\t\t\t\tmy_extra->typtypmod);\n\n\t/*\n\t * Do the necessary checks to ensure it's a valid domain value.\n\t */\n\tdomain_check_input(value, (buf == NULL), my_extra);\n\n\tif (buf == NULL)\n\t\tPG_RETURN_NULL();\n\telse\n\t\tPG_RETURN_DATUM(value);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/expandeddatum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "value"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain_check_input",
          "args": [
            "value",
            "(buf == NULL)",
            "my_extra"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "domain_check_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
          "lines": "130-205",
          "snippet": "static void\ndomain_check_input(Datum value, bool isnull, DomainIOData *my_extra)\n{\n\tExprContext *econtext = my_extra->econtext;\n\tListCell   *l;\n\n\t/* Make sure we have up-to-date constraints */\n\tUpdateDomainConstraintRef(&my_extra->constraint_ref);\n\n\tforeach(l, my_extra->constraint_ref.constraints)\n\t{\n\t\tDomainConstraintState *con = (DomainConstraintState *) lfirst(l);\n\n\t\tswitch (con->constrainttype)\n\t\t{\n\t\t\tcase DOM_CONSTRAINT_NOTNULL:\n\t\t\t\tif (isnull)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_NOT_NULL_VIOLATION),\n\t\t\t\t\t\t\t errmsg(\"domain %s does not allow null values\",\n\t\t\t\t\t\t\t\t\tformat_type_be(my_extra->domain_type)),\n\t\t\t\t\t\t\t errdatatype(my_extra->domain_type)));\n\t\t\t\tbreak;\n\t\t\tcase DOM_CONSTRAINT_CHECK:\n\t\t\t\t{\n\t\t\t\t\t/* Make the econtext if we didn't already */\n\t\t\t\t\tif (econtext == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tMemoryContext oldcontext;\n\n\t\t\t\t\t\toldcontext = MemoryContextSwitchTo(my_extra->mcxt);\n\t\t\t\t\t\tecontext = CreateStandaloneExprContext();\n\t\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\t\tmy_extra->econtext = econtext;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set up value to be returned by CoerceToDomainValue\n\t\t\t\t\t * nodes.  Unlike in the generic expression case, this\n\t\t\t\t\t * econtext couldn't be shared with anything else, so no\n\t\t\t\t\t * need to save and restore fields.  But we do need to\n\t\t\t\t\t * protect the passed-in value against being changed by\n\t\t\t\t\t * called functions.  (It couldn't be a R/W expanded\n\t\t\t\t\t * object for most uses, but that seems possible for\n\t\t\t\t\t * domain_check().)\n\t\t\t\t\t */\n\t\t\t\t\tecontext->domainValue_datum =\n\t\t\t\t\t\tMakeExpandedObjectReadOnly(value, isnull,\n\t\t\t\t\t\t\t\t\t\t\t\t   my_extra->constraint_ref.tcache->typlen);\n\t\t\t\t\tecontext->domainValue_isNull = isnull;\n\n\t\t\t\t\tif (!ExecCheck(con->check_exprstate, econtext))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CHECK_VIOLATION),\n\t\t\t\t\t\t\t\t errmsg(\"value for domain %s violates check constraint \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\tformat_type_be(my_extra->domain_type),\n\t\t\t\t\t\t\t\t\t\tcon->name),\n\t\t\t\t\t\t\t\t errdomainconstraint(my_extra->domain_type,\n\t\t\t\t\t\t\t\t\t\t\t\t\t con->name)));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized constraint type: %d\",\n\t\t\t\t\t (int) con->constrainttype);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Before exiting, call any shutdown callbacks and reset econtext's\n\t * per-tuple memory.  This avoids leaking non-memory resources, if\n\t * anything in the expression(s) has any.\n\t */\n\tif (econtext)\n\t\tReScanExprContext(econtext);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\ndomain_check_input(Datum value, bool isnull, DomainIOData *my_extra)\n{\n\tExprContext *econtext = my_extra->econtext;\n\tListCell   *l;\n\n\t/* Make sure we have up-to-date constraints */\n\tUpdateDomainConstraintRef(&my_extra->constraint_ref);\n\n\tforeach(l, my_extra->constraint_ref.constraints)\n\t{\n\t\tDomainConstraintState *con = (DomainConstraintState *) lfirst(l);\n\n\t\tswitch (con->constrainttype)\n\t\t{\n\t\t\tcase DOM_CONSTRAINT_NOTNULL:\n\t\t\t\tif (isnull)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_NOT_NULL_VIOLATION),\n\t\t\t\t\t\t\t errmsg(\"domain %s does not allow null values\",\n\t\t\t\t\t\t\t\t\tformat_type_be(my_extra->domain_type)),\n\t\t\t\t\t\t\t errdatatype(my_extra->domain_type)));\n\t\t\t\tbreak;\n\t\t\tcase DOM_CONSTRAINT_CHECK:\n\t\t\t\t{\n\t\t\t\t\t/* Make the econtext if we didn't already */\n\t\t\t\t\tif (econtext == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tMemoryContext oldcontext;\n\n\t\t\t\t\t\toldcontext = MemoryContextSwitchTo(my_extra->mcxt);\n\t\t\t\t\t\tecontext = CreateStandaloneExprContext();\n\t\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\t\tmy_extra->econtext = econtext;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set up value to be returned by CoerceToDomainValue\n\t\t\t\t\t * nodes.  Unlike in the generic expression case, this\n\t\t\t\t\t * econtext couldn't be shared with anything else, so no\n\t\t\t\t\t * need to save and restore fields.  But we do need to\n\t\t\t\t\t * protect the passed-in value against being changed by\n\t\t\t\t\t * called functions.  (It couldn't be a R/W expanded\n\t\t\t\t\t * object for most uses, but that seems possible for\n\t\t\t\t\t * domain_check().)\n\t\t\t\t\t */\n\t\t\t\t\tecontext->domainValue_datum =\n\t\t\t\t\t\tMakeExpandedObjectReadOnly(value, isnull,\n\t\t\t\t\t\t\t\t\t\t\t\t   my_extra->constraint_ref.tcache->typlen);\n\t\t\t\t\tecontext->domainValue_isNull = isnull;\n\n\t\t\t\t\tif (!ExecCheck(con->check_exprstate, econtext))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CHECK_VIOLATION),\n\t\t\t\t\t\t\t\t errmsg(\"value for domain %s violates check constraint \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\tformat_type_be(my_extra->domain_type),\n\t\t\t\t\t\t\t\t\t\tcon->name),\n\t\t\t\t\t\t\t\t errdomainconstraint(my_extra->domain_type,\n\t\t\t\t\t\t\t\t\t\t\t\t\t con->name)));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized constraint type: %d\",\n\t\t\t\t\t (int) con->constrainttype);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Before exiting, call any shutdown callbacks and reset econtext's\n\t * per-tuple memory.  This avoids leaking non-memory resources, if\n\t * anything in the expression(s) has any.\n\t */\n\tif (econtext)\n\t\tReScanExprContext(econtext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReceiveFunctionCall",
          "args": [
            "&my_extra->proc",
            "buf",
            "my_extra->typioparam",
            "my_extra->typtypmod"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "OidReceiveFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1841-1849",
          "snippet": "Datum\nOidReceiveFunctionCall(Oid functionId, StringInfo buf,\n\t\t\t\t\t   Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn ReceiveFunctionCall(&flinfo, buf, typioparam, typmod);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidReceiveFunctionCall(Oid functionId, StringInfo buf,\n\t\t\t\t\t   Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn ReceiveFunctionCall(&flinfo, buf, typioparam, typmod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "domain_state_setup",
          "args": [
            "domainType",
            "true",
            "fcinfo->flinfo->fn_mcxt"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "domain_state_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
          "lines": "72-121",
          "snippet": "static DomainIOData *\ndomain_state_setup(Oid domainType, bool binary, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra;\n\tTypeCacheEntry *typentry;\n\tOid\t\t\tbaseType;\n\n\tmy_extra = (DomainIOData *) MemoryContextAlloc(mcxt, sizeof(DomainIOData));\n\n\t/*\n\t * Verify that domainType represents a valid domain type.  We need to be\n\t * careful here because domain_in and domain_recv can be called from SQL,\n\t * possibly with incorrect arguments.  We use lookup_type_cache mainly\n\t * because it will throw a clean user-facing error for a bad OID; but also\n\t * it can cache the underlying base type info.\n\t */\n\ttypentry = lookup_type_cache(domainType, TYPECACHE_DOMAIN_BASE_INFO);\n\tif (typentry->typtype != TYPTYPE_DOMAIN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"type %s is not a domain\",\n\t\t\t\t\t\tformat_type_be(domainType))));\n\n\t/* Find out the base type */\n\tbaseType = typentry->domainBaseType;\n\tmy_extra->typtypmod = typentry->domainBaseTypmod;\n\n\t/* Look up underlying I/O function */\n\tif (binary)\n\t\tgetTypeBinaryInputInfo(baseType,\n\t\t\t\t\t\t\t   &my_extra->typiofunc,\n\t\t\t\t\t\t\t   &my_extra->typioparam);\n\telse\n\t\tgetTypeInputInfo(baseType,\n\t\t\t\t\t\t &my_extra->typiofunc,\n\t\t\t\t\t\t &my_extra->typioparam);\n\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc, mcxt);\n\n\t/* Look up constraints for domain */\n\tInitDomainConstraintRef(domainType, &my_extra->constraint_ref, mcxt, true);\n\n\t/* We don't make an ExprContext until needed */\n\tmy_extra->econtext = NULL;\n\tmy_extra->mcxt = mcxt;\n\n\t/* Mark cache valid */\n\tmy_extra->domain_type = domainType;\n\n\treturn my_extra;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic DomainIOData *\ndomain_state_setup(Oid domainType, bool binary, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra;\n\tTypeCacheEntry *typentry;\n\tOid\t\t\tbaseType;\n\n\tmy_extra = (DomainIOData *) MemoryContextAlloc(mcxt, sizeof(DomainIOData));\n\n\t/*\n\t * Verify that domainType represents a valid domain type.  We need to be\n\t * careful here because domain_in and domain_recv can be called from SQL,\n\t * possibly with incorrect arguments.  We use lookup_type_cache mainly\n\t * because it will throw a clean user-facing error for a bad OID; but also\n\t * it can cache the underlying base type info.\n\t */\n\ttypentry = lookup_type_cache(domainType, TYPECACHE_DOMAIN_BASE_INFO);\n\tif (typentry->typtype != TYPTYPE_DOMAIN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"type %s is not a domain\",\n\t\t\t\t\t\tformat_type_be(domainType))));\n\n\t/* Find out the base type */\n\tbaseType = typentry->domainBaseType;\n\tmy_extra->typtypmod = typentry->domainBaseTypmod;\n\n\t/* Look up underlying I/O function */\n\tif (binary)\n\t\tgetTypeBinaryInputInfo(baseType,\n\t\t\t\t\t\t\t   &my_extra->typiofunc,\n\t\t\t\t\t\t\t   &my_extra->typioparam);\n\telse\n\t\tgetTypeInputInfo(baseType,\n\t\t\t\t\t\t &my_extra->typiofunc,\n\t\t\t\t\t\t &my_extra->typioparam);\n\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc, mcxt);\n\n\t/* Look up constraints for domain */\n\tInitDomainConstraintRef(domainType, &my_extra->constraint_ref, mcxt, true);\n\n\t/* We don't make an ExprContext until needed */\n\tmy_extra->econtext = NULL;\n\tmy_extra->mcxt = mcxt;\n\n\t/* Mark cache valid */\n\tmy_extra->domain_type = domainType;\n\n\treturn my_extra;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\ndomain_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf;\n\tOid\t\t\tdomainType;\n\tDomainIOData *my_extra;\n\tDatum\t\tvalue;\n\n\t/*\n\t * Since domain_recv is not strict, we have to check for null inputs. The\n\t * typioparam argument should never be null in normal system usage, but it\n\t * could be null in a manual invocation --- if so, just return null.\n\t */\n\tif (PG_ARGISNULL(0))\n\t\tbuf = NULL;\n\telse\n\t\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tif (PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\tdomainType = PG_GETARG_OID(1);\n\n\t/*\n\t * We arrange to look up the needed info just once per series of calls,\n\t * assuming the domain type doesn't change underneath us (which really\n\t * shouldn't happen, but cope if it does).\n\t */\n\tmy_extra = (DomainIOData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL || my_extra->domain_type != domainType)\n\t{\n\t\tmy_extra = domain_state_setup(domainType, true,\n\t\t\t\t\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tfcinfo->flinfo->fn_extra = (void *) my_extra;\n\t}\n\n\t/*\n\t * Invoke the base type's typreceive procedure to convert the data.\n\t */\n\tvalue = ReceiveFunctionCall(&my_extra->proc,\n\t\t\t\t\t\t\t\tbuf,\n\t\t\t\t\t\t\t\tmy_extra->typioparam,\n\t\t\t\t\t\t\t\tmy_extra->typtypmod);\n\n\t/*\n\t * Do the necessary checks to ensure it's a valid domain value.\n\t */\n\tdomain_check_input(value, (buf == NULL), my_extra);\n\n\tif (buf == NULL)\n\t\tPG_RETURN_NULL();\n\telse\n\t\tPG_RETURN_DATUM(value);\n}"
  },
  {
    "function_name": "domain_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
    "lines": "211-262",
    "snippet": "Datum\ndomain_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *string;\n\tOid\t\t\tdomainType;\n\tDomainIOData *my_extra;\n\tDatum\t\tvalue;\n\n\t/*\n\t * Since domain_in is not strict, we have to check for null inputs. The\n\t * typioparam argument should never be null in normal system usage, but it\n\t * could be null in a manual invocation --- if so, just return null.\n\t */\n\tif (PG_ARGISNULL(0))\n\t\tstring = NULL;\n\telse\n\t\tstring = PG_GETARG_CSTRING(0);\n\tif (PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\tdomainType = PG_GETARG_OID(1);\n\n\t/*\n\t * We arrange to look up the needed info just once per series of calls,\n\t * assuming the domain type doesn't change underneath us (which really\n\t * shouldn't happen, but cope if it does).\n\t */\n\tmy_extra = (DomainIOData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL || my_extra->domain_type != domainType)\n\t{\n\t\tmy_extra = domain_state_setup(domainType, false,\n\t\t\t\t\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tfcinfo->flinfo->fn_extra = (void *) my_extra;\n\t}\n\n\t/*\n\t * Invoke the base type's typinput procedure to convert the data.\n\t */\n\tvalue = InputFunctionCall(&my_extra->proc,\n\t\t\t\t\t\t\t  string,\n\t\t\t\t\t\t\t  my_extra->typioparam,\n\t\t\t\t\t\t\t  my_extra->typtypmod);\n\n\t/*\n\t * Do the necessary checks to ensure it's a valid domain value.\n\t */\n\tdomain_check_input(value, (string == NULL), my_extra);\n\n\tif (string == NULL)\n\t\tPG_RETURN_NULL();\n\telse\n\t\tPG_RETURN_DATUM(value);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/expandeddatum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "value"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain_check_input",
          "args": [
            "value",
            "(string == NULL)",
            "my_extra"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "domain_check_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
          "lines": "130-205",
          "snippet": "static void\ndomain_check_input(Datum value, bool isnull, DomainIOData *my_extra)\n{\n\tExprContext *econtext = my_extra->econtext;\n\tListCell   *l;\n\n\t/* Make sure we have up-to-date constraints */\n\tUpdateDomainConstraintRef(&my_extra->constraint_ref);\n\n\tforeach(l, my_extra->constraint_ref.constraints)\n\t{\n\t\tDomainConstraintState *con = (DomainConstraintState *) lfirst(l);\n\n\t\tswitch (con->constrainttype)\n\t\t{\n\t\t\tcase DOM_CONSTRAINT_NOTNULL:\n\t\t\t\tif (isnull)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_NOT_NULL_VIOLATION),\n\t\t\t\t\t\t\t errmsg(\"domain %s does not allow null values\",\n\t\t\t\t\t\t\t\t\tformat_type_be(my_extra->domain_type)),\n\t\t\t\t\t\t\t errdatatype(my_extra->domain_type)));\n\t\t\t\tbreak;\n\t\t\tcase DOM_CONSTRAINT_CHECK:\n\t\t\t\t{\n\t\t\t\t\t/* Make the econtext if we didn't already */\n\t\t\t\t\tif (econtext == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tMemoryContext oldcontext;\n\n\t\t\t\t\t\toldcontext = MemoryContextSwitchTo(my_extra->mcxt);\n\t\t\t\t\t\tecontext = CreateStandaloneExprContext();\n\t\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\t\tmy_extra->econtext = econtext;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set up value to be returned by CoerceToDomainValue\n\t\t\t\t\t * nodes.  Unlike in the generic expression case, this\n\t\t\t\t\t * econtext couldn't be shared with anything else, so no\n\t\t\t\t\t * need to save and restore fields.  But we do need to\n\t\t\t\t\t * protect the passed-in value against being changed by\n\t\t\t\t\t * called functions.  (It couldn't be a R/W expanded\n\t\t\t\t\t * object for most uses, but that seems possible for\n\t\t\t\t\t * domain_check().)\n\t\t\t\t\t */\n\t\t\t\t\tecontext->domainValue_datum =\n\t\t\t\t\t\tMakeExpandedObjectReadOnly(value, isnull,\n\t\t\t\t\t\t\t\t\t\t\t\t   my_extra->constraint_ref.tcache->typlen);\n\t\t\t\t\tecontext->domainValue_isNull = isnull;\n\n\t\t\t\t\tif (!ExecCheck(con->check_exprstate, econtext))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CHECK_VIOLATION),\n\t\t\t\t\t\t\t\t errmsg(\"value for domain %s violates check constraint \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\tformat_type_be(my_extra->domain_type),\n\t\t\t\t\t\t\t\t\t\tcon->name),\n\t\t\t\t\t\t\t\t errdomainconstraint(my_extra->domain_type,\n\t\t\t\t\t\t\t\t\t\t\t\t\t con->name)));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized constraint type: %d\",\n\t\t\t\t\t (int) con->constrainttype);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Before exiting, call any shutdown callbacks and reset econtext's\n\t * per-tuple memory.  This avoids leaking non-memory resources, if\n\t * anything in the expression(s) has any.\n\t */\n\tif (econtext)\n\t\tReScanExprContext(econtext);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\ndomain_check_input(Datum value, bool isnull, DomainIOData *my_extra)\n{\n\tExprContext *econtext = my_extra->econtext;\n\tListCell   *l;\n\n\t/* Make sure we have up-to-date constraints */\n\tUpdateDomainConstraintRef(&my_extra->constraint_ref);\n\n\tforeach(l, my_extra->constraint_ref.constraints)\n\t{\n\t\tDomainConstraintState *con = (DomainConstraintState *) lfirst(l);\n\n\t\tswitch (con->constrainttype)\n\t\t{\n\t\t\tcase DOM_CONSTRAINT_NOTNULL:\n\t\t\t\tif (isnull)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_NOT_NULL_VIOLATION),\n\t\t\t\t\t\t\t errmsg(\"domain %s does not allow null values\",\n\t\t\t\t\t\t\t\t\tformat_type_be(my_extra->domain_type)),\n\t\t\t\t\t\t\t errdatatype(my_extra->domain_type)));\n\t\t\t\tbreak;\n\t\t\tcase DOM_CONSTRAINT_CHECK:\n\t\t\t\t{\n\t\t\t\t\t/* Make the econtext if we didn't already */\n\t\t\t\t\tif (econtext == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tMemoryContext oldcontext;\n\n\t\t\t\t\t\toldcontext = MemoryContextSwitchTo(my_extra->mcxt);\n\t\t\t\t\t\tecontext = CreateStandaloneExprContext();\n\t\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\t\tmy_extra->econtext = econtext;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set up value to be returned by CoerceToDomainValue\n\t\t\t\t\t * nodes.  Unlike in the generic expression case, this\n\t\t\t\t\t * econtext couldn't be shared with anything else, so no\n\t\t\t\t\t * need to save and restore fields.  But we do need to\n\t\t\t\t\t * protect the passed-in value against being changed by\n\t\t\t\t\t * called functions.  (It couldn't be a R/W expanded\n\t\t\t\t\t * object for most uses, but that seems possible for\n\t\t\t\t\t * domain_check().)\n\t\t\t\t\t */\n\t\t\t\t\tecontext->domainValue_datum =\n\t\t\t\t\t\tMakeExpandedObjectReadOnly(value, isnull,\n\t\t\t\t\t\t\t\t\t\t\t\t   my_extra->constraint_ref.tcache->typlen);\n\t\t\t\t\tecontext->domainValue_isNull = isnull;\n\n\t\t\t\t\tif (!ExecCheck(con->check_exprstate, econtext))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CHECK_VIOLATION),\n\t\t\t\t\t\t\t\t errmsg(\"value for domain %s violates check constraint \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\tformat_type_be(my_extra->domain_type),\n\t\t\t\t\t\t\t\t\t\tcon->name),\n\t\t\t\t\t\t\t\t errdomainconstraint(my_extra->domain_type,\n\t\t\t\t\t\t\t\t\t\t\t\t\t con->name)));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized constraint type: %d\",\n\t\t\t\t\t (int) con->constrainttype);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Before exiting, call any shutdown callbacks and reset econtext's\n\t * per-tuple memory.  This avoids leaking non-memory resources, if\n\t * anything in the expression(s) has any.\n\t */\n\tif (econtext)\n\t\tReScanExprContext(econtext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "InputFunctionCall",
          "args": [
            "&my_extra->proc",
            "string",
            "my_extra->typioparam",
            "my_extra->typtypmod"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "OidInputFunctionCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1823-1830",
          "snippet": "Datum\nOidInputFunctionCall(Oid functionId, char *str, Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn InputFunctionCall(&flinfo, str, typioparam, typmod);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidInputFunctionCall(Oid functionId, char *str, Oid typioparam, int32 typmod)\n{\n\tFmgrInfo\tflinfo;\n\n\tfmgr_info(functionId, &flinfo);\n\treturn InputFunctionCall(&flinfo, str, typioparam, typmod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "domain_state_setup",
          "args": [
            "domainType",
            "false",
            "fcinfo->flinfo->fn_mcxt"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "domain_state_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
          "lines": "72-121",
          "snippet": "static DomainIOData *\ndomain_state_setup(Oid domainType, bool binary, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra;\n\tTypeCacheEntry *typentry;\n\tOid\t\t\tbaseType;\n\n\tmy_extra = (DomainIOData *) MemoryContextAlloc(mcxt, sizeof(DomainIOData));\n\n\t/*\n\t * Verify that domainType represents a valid domain type.  We need to be\n\t * careful here because domain_in and domain_recv can be called from SQL,\n\t * possibly with incorrect arguments.  We use lookup_type_cache mainly\n\t * because it will throw a clean user-facing error for a bad OID; but also\n\t * it can cache the underlying base type info.\n\t */\n\ttypentry = lookup_type_cache(domainType, TYPECACHE_DOMAIN_BASE_INFO);\n\tif (typentry->typtype != TYPTYPE_DOMAIN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"type %s is not a domain\",\n\t\t\t\t\t\tformat_type_be(domainType))));\n\n\t/* Find out the base type */\n\tbaseType = typentry->domainBaseType;\n\tmy_extra->typtypmod = typentry->domainBaseTypmod;\n\n\t/* Look up underlying I/O function */\n\tif (binary)\n\t\tgetTypeBinaryInputInfo(baseType,\n\t\t\t\t\t\t\t   &my_extra->typiofunc,\n\t\t\t\t\t\t\t   &my_extra->typioparam);\n\telse\n\t\tgetTypeInputInfo(baseType,\n\t\t\t\t\t\t &my_extra->typiofunc,\n\t\t\t\t\t\t &my_extra->typioparam);\n\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc, mcxt);\n\n\t/* Look up constraints for domain */\n\tInitDomainConstraintRef(domainType, &my_extra->constraint_ref, mcxt, true);\n\n\t/* We don't make an ExprContext until needed */\n\tmy_extra->econtext = NULL;\n\tmy_extra->mcxt = mcxt;\n\n\t/* Mark cache valid */\n\tmy_extra->domain_type = domainType;\n\n\treturn my_extra;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic DomainIOData *\ndomain_state_setup(Oid domainType, bool binary, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra;\n\tTypeCacheEntry *typentry;\n\tOid\t\t\tbaseType;\n\n\tmy_extra = (DomainIOData *) MemoryContextAlloc(mcxt, sizeof(DomainIOData));\n\n\t/*\n\t * Verify that domainType represents a valid domain type.  We need to be\n\t * careful here because domain_in and domain_recv can be called from SQL,\n\t * possibly with incorrect arguments.  We use lookup_type_cache mainly\n\t * because it will throw a clean user-facing error for a bad OID; but also\n\t * it can cache the underlying base type info.\n\t */\n\ttypentry = lookup_type_cache(domainType, TYPECACHE_DOMAIN_BASE_INFO);\n\tif (typentry->typtype != TYPTYPE_DOMAIN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"type %s is not a domain\",\n\t\t\t\t\t\tformat_type_be(domainType))));\n\n\t/* Find out the base type */\n\tbaseType = typentry->domainBaseType;\n\tmy_extra->typtypmod = typentry->domainBaseTypmod;\n\n\t/* Look up underlying I/O function */\n\tif (binary)\n\t\tgetTypeBinaryInputInfo(baseType,\n\t\t\t\t\t\t\t   &my_extra->typiofunc,\n\t\t\t\t\t\t\t   &my_extra->typioparam);\n\telse\n\t\tgetTypeInputInfo(baseType,\n\t\t\t\t\t\t &my_extra->typiofunc,\n\t\t\t\t\t\t &my_extra->typioparam);\n\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc, mcxt);\n\n\t/* Look up constraints for domain */\n\tInitDomainConstraintRef(domainType, &my_extra->constraint_ref, mcxt, true);\n\n\t/* We don't make an ExprContext until needed */\n\tmy_extra->econtext = NULL;\n\tmy_extra->mcxt = mcxt;\n\n\t/* Mark cache valid */\n\tmy_extra->domain_type = domainType;\n\n\treturn my_extra;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "1"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_ARGISNULL",
          "args": [
            "0"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nDatum\ndomain_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *string;\n\tOid\t\t\tdomainType;\n\tDomainIOData *my_extra;\n\tDatum\t\tvalue;\n\n\t/*\n\t * Since domain_in is not strict, we have to check for null inputs. The\n\t * typioparam argument should never be null in normal system usage, but it\n\t * could be null in a manual invocation --- if so, just return null.\n\t */\n\tif (PG_ARGISNULL(0))\n\t\tstring = NULL;\n\telse\n\t\tstring = PG_GETARG_CSTRING(0);\n\tif (PG_ARGISNULL(1))\n\t\tPG_RETURN_NULL();\n\tdomainType = PG_GETARG_OID(1);\n\n\t/*\n\t * We arrange to look up the needed info just once per series of calls,\n\t * assuming the domain type doesn't change underneath us (which really\n\t * shouldn't happen, but cope if it does).\n\t */\n\tmy_extra = (DomainIOData *) fcinfo->flinfo->fn_extra;\n\tif (my_extra == NULL || my_extra->domain_type != domainType)\n\t{\n\t\tmy_extra = domain_state_setup(domainType, false,\n\t\t\t\t\t\t\t\t\t  fcinfo->flinfo->fn_mcxt);\n\t\tfcinfo->flinfo->fn_extra = (void *) my_extra;\n\t}\n\n\t/*\n\t * Invoke the base type's typinput procedure to convert the data.\n\t */\n\tvalue = InputFunctionCall(&my_extra->proc,\n\t\t\t\t\t\t\t  string,\n\t\t\t\t\t\t\t  my_extra->typioparam,\n\t\t\t\t\t\t\t  my_extra->typtypmod);\n\n\t/*\n\t * Do the necessary checks to ensure it's a valid domain value.\n\t */\n\tdomain_check_input(value, (string == NULL), my_extra);\n\n\tif (string == NULL)\n\t\tPG_RETURN_NULL();\n\telse\n\t\tPG_RETURN_DATUM(value);\n}"
  },
  {
    "function_name": "domain_check_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
    "lines": "130-205",
    "snippet": "static void\ndomain_check_input(Datum value, bool isnull, DomainIOData *my_extra)\n{\n\tExprContext *econtext = my_extra->econtext;\n\tListCell   *l;\n\n\t/* Make sure we have up-to-date constraints */\n\tUpdateDomainConstraintRef(&my_extra->constraint_ref);\n\n\tforeach(l, my_extra->constraint_ref.constraints)\n\t{\n\t\tDomainConstraintState *con = (DomainConstraintState *) lfirst(l);\n\n\t\tswitch (con->constrainttype)\n\t\t{\n\t\t\tcase DOM_CONSTRAINT_NOTNULL:\n\t\t\t\tif (isnull)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_NOT_NULL_VIOLATION),\n\t\t\t\t\t\t\t errmsg(\"domain %s does not allow null values\",\n\t\t\t\t\t\t\t\t\tformat_type_be(my_extra->domain_type)),\n\t\t\t\t\t\t\t errdatatype(my_extra->domain_type)));\n\t\t\t\tbreak;\n\t\t\tcase DOM_CONSTRAINT_CHECK:\n\t\t\t\t{\n\t\t\t\t\t/* Make the econtext if we didn't already */\n\t\t\t\t\tif (econtext == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tMemoryContext oldcontext;\n\n\t\t\t\t\t\toldcontext = MemoryContextSwitchTo(my_extra->mcxt);\n\t\t\t\t\t\tecontext = CreateStandaloneExprContext();\n\t\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\t\tmy_extra->econtext = econtext;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set up value to be returned by CoerceToDomainValue\n\t\t\t\t\t * nodes.  Unlike in the generic expression case, this\n\t\t\t\t\t * econtext couldn't be shared with anything else, so no\n\t\t\t\t\t * need to save and restore fields.  But we do need to\n\t\t\t\t\t * protect the passed-in value against being changed by\n\t\t\t\t\t * called functions.  (It couldn't be a R/W expanded\n\t\t\t\t\t * object for most uses, but that seems possible for\n\t\t\t\t\t * domain_check().)\n\t\t\t\t\t */\n\t\t\t\t\tecontext->domainValue_datum =\n\t\t\t\t\t\tMakeExpandedObjectReadOnly(value, isnull,\n\t\t\t\t\t\t\t\t\t\t\t\t   my_extra->constraint_ref.tcache->typlen);\n\t\t\t\t\tecontext->domainValue_isNull = isnull;\n\n\t\t\t\t\tif (!ExecCheck(con->check_exprstate, econtext))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CHECK_VIOLATION),\n\t\t\t\t\t\t\t\t errmsg(\"value for domain %s violates check constraint \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\tformat_type_be(my_extra->domain_type),\n\t\t\t\t\t\t\t\t\t\tcon->name),\n\t\t\t\t\t\t\t\t errdomainconstraint(my_extra->domain_type,\n\t\t\t\t\t\t\t\t\t\t\t\t\t con->name)));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized constraint type: %d\",\n\t\t\t\t\t (int) con->constrainttype);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Before exiting, call any shutdown callbacks and reset econtext's\n\t * per-tuple memory.  This avoids leaking non-memory resources, if\n\t * anything in the expression(s) has any.\n\t */\n\tif (econtext)\n\t\tReScanExprContext(econtext);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/expandeddatum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReScanExprContext",
          "args": [
            "econtext"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized constraint type: %d\"",
            "(int) con->constrainttype"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_CHECK_VIOLATION),\n\t\t\t\t\t\t\t\t errmsg(\"value for domain %s violates check constraint \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\tformat_type_be(my_extra->domain_type),\n\t\t\t\t\t\t\t\t\t\tcon->name),\n\t\t\t\t\t\t\t\t errdomainconstraint(my_extra->domain_type,\n\t\t\t\t\t\t\t\t\t\t\t\t\t con->name))"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdomainconstraint",
          "args": [
            "my_extra->domain_type",
            "con->name"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "errdomainconstraint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
          "lines": "383-390",
          "snippet": "int\nerrdomainconstraint(Oid datatypeOid, const char *conname)\n{\n\terrdatatype(datatypeOid);\n\terr_generic_string(PG_DIAG_CONSTRAINT_NAME, conname);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nint\nerrdomainconstraint(Oid datatypeOid, const char *conname)\n{\n\terrdatatype(datatypeOid);\n\terr_generic_string(PG_DIAG_CONSTRAINT_NAME, conname);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"value for domain %s violates check constraint \\\"%s\\\"\"",
            "format_type_be(my_extra->domain_type)",
            "con->name"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "my_extra->domain_type"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_CHECK_VIOLATION"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExecCheck",
          "args": [
            "con->check_exprstate",
            "econtext"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakeExpandedObjectReadOnly",
          "args": [
            "value",
            "isnull",
            "my_extra->constraint_ref.tcache->typlen"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateStandaloneExprContext",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "my_extra->mcxt"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NOT_NULL_VIOLATION),\n\t\t\t\t\t\t\t errmsg(\"domain %s does not allow null values\",\n\t\t\t\t\t\t\t\t\tformat_type_be(my_extra->domain_type)),\n\t\t\t\t\t\t\t errdatatype(my_extra->domain_type))"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdatatype",
          "args": [
            "my_extra->domain_type"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "errdatatype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
          "lines": "359-377",
          "snippet": "int\nerrdatatype(Oid datatypeOid)\n{\n\tHeapTuple\ttup;\n\tForm_pg_type typtup;\n\n\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(datatypeOid));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for type %u\", datatypeOid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tup);\n\n\terr_generic_string(PG_DIAG_SCHEMA_NAME,\n\t\t\t\t\t   get_namespace_name(typtup->typnamespace));\n\terr_generic_string(PG_DIAG_DATATYPE_NAME, NameStr(typtup->typname));\n\n\tReleaseSysCache(tup);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nint\nerrdatatype(Oid datatypeOid)\n{\n\tHeapTuple\ttup;\n\tForm_pg_type typtup;\n\n\ttup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(datatypeOid));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for type %u\", datatypeOid);\n\ttyptup = (Form_pg_type) GETSTRUCT(tup);\n\n\terr_generic_string(PG_DIAG_SCHEMA_NAME,\n\t\t\t\t\t   get_namespace_name(typtup->typnamespace));\n\terr_generic_string(PG_DIAG_DATATYPE_NAME, NameStr(typtup->typname));\n\n\tReleaseSysCache(tup);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "l"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "l",
            "my_extra->constraint_ref.constraints"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UpdateDomainConstraintRef",
          "args": [
            "&my_extra->constraint_ref"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "UpdateDomainConstraintRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1228-1270",
          "snippet": "void\nUpdateDomainConstraintRef(DomainConstraintRef *ref)\n{\n\tTypeCacheEntry *typentry = ref->tcache;\n\n\t/* Make sure typcache entry's data is up to date */\n\tif ((typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t\tload_domaintype_info(typentry);\n\n\t/* Transfer to ref object if there's new info, adjusting refcounts */\n\tif (ref->dcc != typentry->domainData)\n\t{\n\t\t/* Paranoia --- be sure link is nulled before trying to release */\n\t\tDomainConstraintCache *dcc = ref->dcc;\n\n\t\tif (dcc)\n\t\t{\n\t\t\t/*\n\t\t\t * Note: we just leak the previous list of executable domain\n\t\t\t * constraints.  Alternatively, we could keep those in a child\n\t\t\t * context of ref->refctx and free that context at this point.\n\t\t\t * However, in practice this code path will be taken so seldom\n\t\t\t * that the extra bookkeeping for a child context doesn't seem\n\t\t\t * worthwhile; we'll just allow a leak for the lifespan of refctx.\n\t\t\t */\n\t\t\tref->constraints = NIL;\n\t\t\tref->dcc = NULL;\n\t\t\tdecr_dcc_refcount(dcc);\n\t\t}\n\t\tdcc = typentry->domainData;\n\t\tif (dcc)\n\t\t{\n\t\t\tref->dcc = dcc;\n\t\t\tdcc->dccRefCount++;\n\t\t\tif (ref->need_exprstate)\n\t\t\t\tref->constraints = prep_domain_constraints(dcc->constraints,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   ref->refctx);\n\t\t\telse\n\t\t\t\tref->constraints = dcc->constraints;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000"
          ],
          "globals_used": [
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static void decr_dcc_refcount(DomainConstraintCache *dcc);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static void load_enum_cache_data(TypeCacheEntry *tcache);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic void decr_dcc_refcount(DomainConstraintCache *dcc);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic void load_enum_cache_data(TypeCacheEntry *tcache);\n\nvoid\nUpdateDomainConstraintRef(DomainConstraintRef *ref)\n{\n\tTypeCacheEntry *typentry = ref->tcache;\n\n\t/* Make sure typcache entry's data is up to date */\n\tif ((typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t\tload_domaintype_info(typentry);\n\n\t/* Transfer to ref object if there's new info, adjusting refcounts */\n\tif (ref->dcc != typentry->domainData)\n\t{\n\t\t/* Paranoia --- be sure link is nulled before trying to release */\n\t\tDomainConstraintCache *dcc = ref->dcc;\n\n\t\tif (dcc)\n\t\t{\n\t\t\t/*\n\t\t\t * Note: we just leak the previous list of executable domain\n\t\t\t * constraints.  Alternatively, we could keep those in a child\n\t\t\t * context of ref->refctx and free that context at this point.\n\t\t\t * However, in practice this code path will be taken so seldom\n\t\t\t * that the extra bookkeeping for a child context doesn't seem\n\t\t\t * worthwhile; we'll just allow a leak for the lifespan of refctx.\n\t\t\t */\n\t\t\tref->constraints = NIL;\n\t\t\tref->dcc = NULL;\n\t\t\tdecr_dcc_refcount(dcc);\n\t\t}\n\t\tdcc = typentry->domainData;\n\t\tif (dcc)\n\t\t{\n\t\t\tref->dcc = dcc;\n\t\t\tdcc->dccRefCount++;\n\t\t\tif (ref->need_exprstate)\n\t\t\t\tref->constraints = prep_domain_constraints(dcc->constraints,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   ref->refctx);\n\t\t\telse\n\t\t\t\tref->constraints = dcc->constraints;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic void\ndomain_check_input(Datum value, bool isnull, DomainIOData *my_extra)\n{\n\tExprContext *econtext = my_extra->econtext;\n\tListCell   *l;\n\n\t/* Make sure we have up-to-date constraints */\n\tUpdateDomainConstraintRef(&my_extra->constraint_ref);\n\n\tforeach(l, my_extra->constraint_ref.constraints)\n\t{\n\t\tDomainConstraintState *con = (DomainConstraintState *) lfirst(l);\n\n\t\tswitch (con->constrainttype)\n\t\t{\n\t\t\tcase DOM_CONSTRAINT_NOTNULL:\n\t\t\t\tif (isnull)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_NOT_NULL_VIOLATION),\n\t\t\t\t\t\t\t errmsg(\"domain %s does not allow null values\",\n\t\t\t\t\t\t\t\t\tformat_type_be(my_extra->domain_type)),\n\t\t\t\t\t\t\t errdatatype(my_extra->domain_type)));\n\t\t\t\tbreak;\n\t\t\tcase DOM_CONSTRAINT_CHECK:\n\t\t\t\t{\n\t\t\t\t\t/* Make the econtext if we didn't already */\n\t\t\t\t\tif (econtext == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tMemoryContext oldcontext;\n\n\t\t\t\t\t\toldcontext = MemoryContextSwitchTo(my_extra->mcxt);\n\t\t\t\t\t\tecontext = CreateStandaloneExprContext();\n\t\t\t\t\t\tMemoryContextSwitchTo(oldcontext);\n\t\t\t\t\t\tmy_extra->econtext = econtext;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set up value to be returned by CoerceToDomainValue\n\t\t\t\t\t * nodes.  Unlike in the generic expression case, this\n\t\t\t\t\t * econtext couldn't be shared with anything else, so no\n\t\t\t\t\t * need to save and restore fields.  But we do need to\n\t\t\t\t\t * protect the passed-in value against being changed by\n\t\t\t\t\t * called functions.  (It couldn't be a R/W expanded\n\t\t\t\t\t * object for most uses, but that seems possible for\n\t\t\t\t\t * domain_check().)\n\t\t\t\t\t */\n\t\t\t\t\tecontext->domainValue_datum =\n\t\t\t\t\t\tMakeExpandedObjectReadOnly(value, isnull,\n\t\t\t\t\t\t\t\t\t\t\t\t   my_extra->constraint_ref.tcache->typlen);\n\t\t\t\t\tecontext->domainValue_isNull = isnull;\n\n\t\t\t\t\tif (!ExecCheck(con->check_exprstate, econtext))\n\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t(errcode(ERRCODE_CHECK_VIOLATION),\n\t\t\t\t\t\t\t\t errmsg(\"value for domain %s violates check constraint \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\t\tformat_type_be(my_extra->domain_type),\n\t\t\t\t\t\t\t\t\t\tcon->name),\n\t\t\t\t\t\t\t\t errdomainconstraint(my_extra->domain_type,\n\t\t\t\t\t\t\t\t\t\t\t\t\t con->name)));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized constraint type: %d\",\n\t\t\t\t\t (int) con->constrainttype);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Before exiting, call any shutdown callbacks and reset econtext's\n\t * per-tuple memory.  This avoids leaking non-memory resources, if\n\t * anything in the expression(s) has any.\n\t */\n\tif (econtext)\n\t\tReScanExprContext(econtext);\n}"
  },
  {
    "function_name": "domain_state_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/domains.c",
    "lines": "72-121",
    "snippet": "static DomainIOData *\ndomain_state_setup(Oid domainType, bool binary, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra;\n\tTypeCacheEntry *typentry;\n\tOid\t\t\tbaseType;\n\n\tmy_extra = (DomainIOData *) MemoryContextAlloc(mcxt, sizeof(DomainIOData));\n\n\t/*\n\t * Verify that domainType represents a valid domain type.  We need to be\n\t * careful here because domain_in and domain_recv can be called from SQL,\n\t * possibly with incorrect arguments.  We use lookup_type_cache mainly\n\t * because it will throw a clean user-facing error for a bad OID; but also\n\t * it can cache the underlying base type info.\n\t */\n\ttypentry = lookup_type_cache(domainType, TYPECACHE_DOMAIN_BASE_INFO);\n\tif (typentry->typtype != TYPTYPE_DOMAIN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"type %s is not a domain\",\n\t\t\t\t\t\tformat_type_be(domainType))));\n\n\t/* Find out the base type */\n\tbaseType = typentry->domainBaseType;\n\tmy_extra->typtypmod = typentry->domainBaseTypmod;\n\n\t/* Look up underlying I/O function */\n\tif (binary)\n\t\tgetTypeBinaryInputInfo(baseType,\n\t\t\t\t\t\t\t   &my_extra->typiofunc,\n\t\t\t\t\t\t\t   &my_extra->typioparam);\n\telse\n\t\tgetTypeInputInfo(baseType,\n\t\t\t\t\t\t &my_extra->typiofunc,\n\t\t\t\t\t\t &my_extra->typioparam);\n\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc, mcxt);\n\n\t/* Look up constraints for domain */\n\tInitDomainConstraintRef(domainType, &my_extra->constraint_ref, mcxt, true);\n\n\t/* We don't make an ExprContext until needed */\n\tmy_extra->econtext = NULL;\n\tmy_extra->mcxt = mcxt;\n\n\t/* Mark cache valid */\n\tmy_extra->domain_type = domainType;\n\n\treturn my_extra;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/expandeddatum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"executor/executor.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "InitDomainConstraintRef",
          "args": [
            "domainType",
            "&my_extra->constraint_ref",
            "mcxt",
            "true"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "InitDomainConstraintRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "1190-1216",
          "snippet": "void\nInitDomainConstraintRef(Oid type_id, DomainConstraintRef *ref,\n\t\t\t\t\t\tMemoryContext refctx, bool need_exprstate)\n{\n\t/* Look up the typcache entry --- we assume it survives indefinitely */\n\tref->tcache = lookup_type_cache(type_id, TYPECACHE_DOMAIN_CONSTR_INFO);\n\tref->need_exprstate = need_exprstate;\n\t/* For safety, establish the callback before acquiring a refcount */\n\tref->refctx = refctx;\n\tref->dcc = NULL;\n\tref->callback.func = dccref_deletion_callback;\n\tref->callback.arg = (void *) ref;\n\tMemoryContextRegisterResetCallback(refctx, &ref->callback);\n\t/* Acquire refcount if there are constraints, and set up exported list */\n\tif (ref->tcache->domainData)\n\t{\n\t\tref->dcc = ref->tcache->domainData;\n\t\tref->dcc->dccRefCount++;\n\t\tif (ref->need_exprstate)\n\t\t\tref->constraints = prep_domain_constraints(ref->dcc->constraints,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ref->refctx);\n\t\telse\n\t\t\tref->constraints = ref->dcc->constraints;\n\t}\n\telse\n\t\tref->constraints = NIL;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void decr_dcc_refcount(DomainConstraintCache *dcc);",
            "static void dccref_deletion_callback(void *arg);",
            "static void load_enum_cache_data(TypeCacheEntry *tcache);",
            "static EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void decr_dcc_refcount(DomainConstraintCache *dcc);\nstatic void dccref_deletion_callback(void *arg);\nstatic void load_enum_cache_data(TypeCacheEntry *tcache);\nstatic EnumItem *find_enumitem(TypeCacheEnumData *enumdata, Oid arg);\n\nvoid\nInitDomainConstraintRef(Oid type_id, DomainConstraintRef *ref,\n\t\t\t\t\t\tMemoryContext refctx, bool need_exprstate)\n{\n\t/* Look up the typcache entry --- we assume it survives indefinitely */\n\tref->tcache = lookup_type_cache(type_id, TYPECACHE_DOMAIN_CONSTR_INFO);\n\tref->need_exprstate = need_exprstate;\n\t/* For safety, establish the callback before acquiring a refcount */\n\tref->refctx = refctx;\n\tref->dcc = NULL;\n\tref->callback.func = dccref_deletion_callback;\n\tref->callback.arg = (void *) ref;\n\tMemoryContextRegisterResetCallback(refctx, &ref->callback);\n\t/* Acquire refcount if there are constraints, and set up exported list */\n\tif (ref->tcache->domainData)\n\t{\n\t\tref->dcc = ref->tcache->domainData;\n\t\tref->dcc->dccRefCount++;\n\t\tif (ref->need_exprstate)\n\t\t\tref->constraints = prep_domain_constraints(ref->dcc->constraints,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ref->refctx);\n\t\telse\n\t\t\tref->constraints = ref->dcc->constraints;\n\t}\n\telse\n\t\tref->constraints = NIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "my_extra->typiofunc",
            "&my_extra->proc",
            "mcxt"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTypeInputInfo",
          "args": [
            "baseType",
            "&my_extra->typiofunc",
            "&my_extra->typioparam"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "getTypeInputInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2640-2666",
          "snippet": "void\ngetTypeInputInfo(Oid type, Oid *typInput, Oid *typIOParam)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typinput))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no input function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typInput = pt->typinput;\n\t*typIOParam = getTypeIOParam(typeTuple);\n\n\tReleaseSysCache(typeTuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\ngetTypeInputInfo(Oid type, Oid *typInput, Oid *typIOParam)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typinput))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no input function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typInput = pt->typinput;\n\t*typIOParam = getTypeIOParam(typeTuple);\n\n\tReleaseSysCache(typeTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getTypeBinaryInputInfo",
          "args": [
            "baseType",
            "&my_extra->typiofunc",
            "&my_extra->typioparam"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "getTypeBinaryInputInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2706-2732",
          "snippet": "void\ngetTypeBinaryInputInfo(Oid type, Oid *typReceive, Oid *typIOParam)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typreceive))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no binary input function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typReceive = pt->typreceive;\n\t*typIOParam = getTypeIOParam(typeTuple);\n\n\tReleaseSysCache(typeTuple);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\ngetTypeBinaryInputInfo(Oid type, Oid *typReceive, Oid *typIOParam)\n{\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type pt;\n\n\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type));\n\tif (!HeapTupleIsValid(typeTuple))\n\t\telog(ERROR, \"cache lookup failed for type %u\", type);\n\tpt = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\tif (!pt->typisdefined)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"type %s is only a shell\",\n\t\t\t\t\t\tformat_type_be(type))));\n\tif (!OidIsValid(pt->typreceive))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"no binary input function available for type %s\",\n\t\t\t\t\t\tformat_type_be(type))));\n\n\t*typReceive = pt->typreceive;\n\t*typIOParam = getTypeIOParam(typeTuple);\n\n\tReleaseSysCache(typeTuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"type %s is not a domain\",\n\t\t\t\t\t\tformat_type_be(domainType)))"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"type %s is not a domain\"",
            "format_type_be(domainType)"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "domainType"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATATYPE_MISMATCH"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_type_cache",
          "args": [
            "domainType",
            "TYPECACHE_DOMAIN_BASE_INFO"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_type_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/typcache.c",
          "lines": "320-778",
          "snippet": "TypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"lib/dshash.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/session.h\"",
            "#include \"access/parallel.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000",
            "#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080",
            "#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040",
            "#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020",
            "#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010",
            "#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008",
            "#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004",
            "#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002",
            "#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001"
          ],
          "globals_used": [
            "static HTAB *TypeCacheHash = NULL;",
            "static TypeCacheEntry *firstDomainTypeEntry = NULL;",
            "static void load_typcache_tupdesc(TypeCacheEntry *typentry);",
            "static void load_rangetype_info(TypeCacheEntry *typentry);",
            "static void load_domaintype_info(TypeCacheEntry *typentry);",
            "static bool array_element_has_equality(TypeCacheEntry *typentry);",
            "static bool array_element_has_compare(TypeCacheEntry *typentry);",
            "static bool array_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool array_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_array_element_properties(TypeCacheEntry *typentry);",
            "static bool record_fields_have_equality(TypeCacheEntry *typentry);",
            "static bool record_fields_have_compare(TypeCacheEntry *typentry);",
            "static void cache_record_field_properties(TypeCacheEntry *typentry);",
            "static bool range_element_has_hashing(TypeCacheEntry *typentry);",
            "static bool range_element_has_extended_hashing(TypeCacheEntry *typentry);",
            "static void cache_range_element_properties(TypeCacheEntry *typentry);",
            "static int\tenum_oid_cmp(const void *left, const void *right);",
            "static TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lwlock.h\"\n#include \"optimizer/planner.h\"\n#include \"lib/dshash.h\"\n#include \"executor/executor.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/indexing.h\"\n#include \"access/session.h\"\n#include \"access/parallel.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS\t0x010000\n#define TCFLAGS_CHECKED_HASH_EXTENDED_PROC\t0x000080\n#define TCFLAGS_CHECKED_HASH_PROC\t\t\t0x000040\n#define TCFLAGS_CHECKED_CMP_PROC\t\t\t0x000020\n#define TCFLAGS_CHECKED_GT_OPR\t\t\t\t0x000010\n#define TCFLAGS_CHECKED_LT_OPR\t\t\t\t0x000008\n#define TCFLAGS_CHECKED_EQ_OPR\t\t\t\t0x000004\n#define TCFLAGS_CHECKED_HASH_OPCLASS\t\t0x000002\n#define TCFLAGS_CHECKED_BTREE_OPCLASS\t\t0x000001\n\nstatic HTAB *TypeCacheHash = NULL;\nstatic TypeCacheEntry *firstDomainTypeEntry = NULL;\nstatic void load_typcache_tupdesc(TypeCacheEntry *typentry);\nstatic void load_rangetype_info(TypeCacheEntry *typentry);\nstatic void load_domaintype_info(TypeCacheEntry *typentry);\nstatic bool array_element_has_equality(TypeCacheEntry *typentry);\nstatic bool array_element_has_compare(TypeCacheEntry *typentry);\nstatic bool array_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool array_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_array_element_properties(TypeCacheEntry *typentry);\nstatic bool record_fields_have_equality(TypeCacheEntry *typentry);\nstatic bool record_fields_have_compare(TypeCacheEntry *typentry);\nstatic void cache_record_field_properties(TypeCacheEntry *typentry);\nstatic bool range_element_has_hashing(TypeCacheEntry *typentry);\nstatic bool range_element_has_extended_hashing(TypeCacheEntry *typentry);\nstatic void cache_range_element_properties(TypeCacheEntry *typentry);\nstatic int\tenum_oid_cmp(const void *left, const void *right);\nstatic TupleDesc find_or_make_matching_shared_tupledesc(TupleDesc tupdesc);\n\nTypeCacheEntry *\nlookup_type_cache(Oid type_id, int flags)\n{\n\tTypeCacheEntry *typentry;\n\tbool\t\tfound;\n\n\tif (TypeCacheHash == NULL)\n\t{\n\t\t/* First time through: initialize the hash table */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(TypeCacheEntry);\n\t\tTypeCacheHash = hash_create(\"Type information cache\", 64,\n\t\t\t\t\t\t\t\t\t&ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also set up callbacks for SI invalidations */\n\t\tCacheRegisterRelcacheCallback(TypeCacheRelCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CLAOID, TypeCacheOpcCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(CONSTROID, TypeCacheConstrCallback, (Datum) 0);\n\t\tCacheRegisterSyscacheCallback(TYPEOID, TypeCacheConstrCallback, (Datum) 0);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\t/* Try to look up an existing entry */\n\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t  HASH_FIND, NULL);\n\tif (typentry == NULL)\n\t{\n\t\t/*\n\t\t * If we didn't find one, we want to make one.  But first look up the\n\t\t * pg_type row, just to make sure we don't make a cache entry for an\n\t\t * invalid type OID.  If the type OID is not valid, present a\n\t\t * user-facing error, since some code paths such as domain_in() allow\n\t\t * this function to be reached with a user-supplied OID.\n\t\t */\n\t\tHeapTuple\ttp;\n\t\tForm_pg_type typtup;\n\n\t\ttp = SearchSysCache1(TYPEOID, ObjectIdGetDatum(type_id));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type with OID %u does not exist\", type_id)));\n\t\ttyptup = (Form_pg_type) GETSTRUCT(tp);\n\t\tif (!typtup->typisdefined)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"type \\\"%s\\\" is only a shell\",\n\t\t\t\t\t\t\tNameStr(typtup->typname))));\n\n\t\t/* Now make the typcache entry */\n\t\ttypentry = (TypeCacheEntry *) hash_search(TypeCacheHash,\n\t\t\t\t\t\t\t\t\t\t\t\t  (void *) &type_id,\n\t\t\t\t\t\t\t\t\t\t\t\t  HASH_ENTER, &found);\n\t\tAssert(!found);\t\t\t/* it wasn't there a moment ago */\n\n\t\tMemSet(typentry, 0, sizeof(TypeCacheEntry));\n\t\ttypentry->type_id = type_id;\n\t\ttypentry->typlen = typtup->typlen;\n\t\ttypentry->typbyval = typtup->typbyval;\n\t\ttypentry->typalign = typtup->typalign;\n\t\ttypentry->typstorage = typtup->typstorage;\n\t\ttypentry->typtype = typtup->typtype;\n\t\ttypentry->typrelid = typtup->typrelid;\n\t\ttypentry->typelem = typtup->typelem;\n\n\t\t/* If it's a domain, immediately thread it into the domain cache list */\n\t\tif (typentry->typtype == TYPTYPE_DOMAIN)\n\t\t{\n\t\t\ttypentry->nextDomain = firstDomainTypeEntry;\n\t\t\tfirstDomainTypeEntry = typentry;\n\t\t}\n\n\t\tReleaseSysCache(tp);\n\t}\n\n\t/*\n\t * Look up opclasses if we haven't already and any dependent info is\n\t * requested.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_LT_OPR | TYPECACHE_GT_OPR |\n\t\t\t\t  TYPECACHE_CMP_PROC |\n\t\t\t\t  TYPECACHE_EQ_OPR_FINFO | TYPECACHE_CMP_PROC_FINFO |\n\t\t\t\t  TYPECACHE_BTREE_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_BTREE_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, BTREE_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->btree_opf = get_opclass_family(opclass);\n\t\t\ttypentry->btree_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->btree_opf = typentry->btree_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from btree opclass.  Note in particular\n\t\t * that we'll redetermine the eq_opr even if we previously found one;\n\t\t * this matters in case a btree opclass has been added to a type that\n\t\t * previously had only a hash opclass.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_EQ_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_LT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_GT_OPR |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_CMP_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_BTREE_OPCLASS;\n\t}\n\n\t/*\n\t * If we need to look up equality operator, and there's no btree opclass,\n\t * force lookup of hash opclass.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR) &&\n\t\ttypentry->btree_opf == InvalidOid)\n\t\tflags |= TYPECACHE_HASH_OPFAMILY;\n\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO |\n\t\t\t\t  TYPECACHE_HASH_OPFAMILY)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_OPCLASS))\n\t{\n\t\tOid\t\t\topclass;\n\n\t\topclass = GetDefaultOpClass(type_id, HASH_AM_OID);\n\t\tif (OidIsValid(opclass))\n\t\t{\n\t\t\ttypentry->hash_opf = get_opclass_family(opclass);\n\t\t\ttypentry->hash_opintype = get_opclass_input_type(opclass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttypentry->hash_opf = typentry->hash_opintype = InvalidOid;\n\t\t}\n\n\t\t/*\n\t\t * Reset information derived from hash opclass.  We do *not* reset the\n\t\t * eq_opr; if we already found one from the btree opclass, that\n\t\t * decision is still good.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_OPCLASS;\n\t}\n\n\t/*\n\t * Look for requested operators and functions, if we haven't already.\n\t */\n\tif ((flags & (TYPECACHE_EQ_OPR | TYPECACHE_EQ_OPR_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_EQ_OPR))\n\t{\n\t\tOid\t\t\teq_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTEqualStrategyNumber);\n\t\tif (eq_opr == InvalidOid &&\n\t\t\ttypentry->hash_opf != InvalidOid)\n\t\t\teq_opr = get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber);\n\n\t\t/*\n\t\t * If the proposed equality operator is array_eq or record_eq, check\n\t\t * to see if the element type or column types support equality.  If\n\t\t * not, array_eq or record_eq would fail at runtime, so we don't want\n\t\t * to report that the type has equality.  (We can omit similar\n\t\t * checking for ranges because ranges can't be created in the first\n\t\t * place unless their subtypes support equality.)\n\t\t */\n\t\tif (eq_opr == ARRAY_EQ_OP &&\n\t\t\t!array_element_has_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\t\telse if (eq_opr == RECORD_EQ_OP &&\n\t\t\t\t !record_fields_have_equality(typentry))\n\t\t\teq_opr = InvalidOid;\n\n\t\t/* Force update of eq_opr_finfo only if we're changing state */\n\t\tif (typentry->eq_opr != eq_opr)\n\t\t\ttypentry->eq_opr_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->eq_opr = eq_opr;\n\n\t\t/*\n\t\t * Reset info about hash functions whenever we pick up new info about\n\t\t * equality operator.  This is so we can ensure that the hash\n\t\t * functions match the operator.\n\t\t */\n\t\ttypentry->flags &= ~(TCFLAGS_CHECKED_HASH_PROC |\n\t\t\t\t\t\t\t TCFLAGS_CHECKED_HASH_EXTENDED_PROC);\n\t\ttypentry->flags |= TCFLAGS_CHECKED_EQ_OPR;\n\t}\n\tif ((flags & TYPECACHE_LT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_LT_OPR))\n\t{\n\t\tOid\t\t\tlt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tlt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTLessStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (lt_opr == ARRAY_LT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\t\telse if (lt_opr == RECORD_LT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tlt_opr = InvalidOid;\n\n\t\ttypentry->lt_opr = lt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_LT_OPR;\n\t}\n\tif ((flags & TYPECACHE_GT_OPR) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_GT_OPR))\n\t{\n\t\tOid\t\t\tgt_opr = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tgt_opr = get_opfamily_member(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTGreaterStrategyNumber);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (gt_opr == ARRAY_GT_OP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\t\telse if (gt_opr == RECORD_GT_OP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tgt_opr = InvalidOid;\n\n\t\ttypentry->gt_opr = gt_opr;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_GT_OPR;\n\t}\n\tif ((flags & (TYPECACHE_CMP_PROC | TYPECACHE_CMP_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_CMP_PROC))\n\t{\n\t\tOid\t\t\tcmp_proc = InvalidOid;\n\n\t\tif (typentry->btree_opf != InvalidOid)\n\t\t\tcmp_proc = get_opfamily_proc(typentry->btree_opf,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t typentry->btree_opintype,\n\t\t\t\t\t\t\t\t\t\t BTORDER_PROC);\n\n\t\t/*\n\t\t * As above, make sure array_cmp or record_cmp will succeed; but again\n\t\t * we need no special check for ranges.\n\t\t */\n\t\tif (cmp_proc == F_BTARRAYCMP &&\n\t\t\t!array_element_has_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\t\telse if (cmp_proc == F_BTRECORDCMP &&\n\t\t\t\t !record_fields_have_compare(typentry))\n\t\t\tcmp_proc = InvalidOid;\n\n\t\t/* Force update of cmp_proc_finfo only if we're changing state */\n\t\tif (typentry->cmp_proc != cmp_proc)\n\t\t\ttypentry->cmp_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->cmp_proc = cmp_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_CMP_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_PROC | TYPECACHE_HASH_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_PROC))\n\t{\n\t\tOid\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t  HASHSTANDARD_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array will succeed.  We don't currently\n\t\t * support hashing for composite types, but when we do, we'll need\n\t\t * more logic here to check that case too.\n\t\t */\n\t\tif (hash_proc == F_HASH_ARRAY &&\n\t\t\t!array_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range.\n\t\t */\n\t\tif (hash_proc == F_HASH_RANGE &&\n\t\t\t!range_element_has_hashing(typentry))\n\t\t\thash_proc = InvalidOid;\n\n\t\t/* Force update of hash_proc_finfo only if we're changing state */\n\t\tif (typentry->hash_proc != hash_proc)\n\t\t\ttypentry->hash_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_proc = hash_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_PROC;\n\t}\n\tif ((flags & (TYPECACHE_HASH_EXTENDED_PROC |\n\t\t\t\t  TYPECACHE_HASH_EXTENDED_PROC_FINFO)) &&\n\t\t!(typentry->flags & TCFLAGS_CHECKED_HASH_EXTENDED_PROC))\n\t{\n\t\tOid\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * We insist that the eq_opr, if one has been determined, match the\n\t\t * hash opclass; else report there is no hash function.\n\t\t */\n\t\tif (typentry->hash_opf != InvalidOid &&\n\t\t\t(!OidIsValid(typentry->eq_opr) ||\n\t\t\t typentry->eq_opr == get_opfamily_member(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t\t HTEqualStrategyNumber)))\n\t\t\thash_extended_proc = get_opfamily_proc(typentry->hash_opf,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   typentry->hash_opintype,\n\t\t\t\t\t\t\t\t\t\t\t\t   HASHEXTENDED_PROC);\n\n\t\t/*\n\t\t * As above, make sure hash_array_extended will succeed.  We don't\n\t\t * currently support hashing for composite types, but when we do,\n\t\t * we'll need more logic here to check that case too.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_ARRAY_EXTENDED &&\n\t\t\t!array_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/*\n\t\t * Likewise for hash_range_extended.\n\t\t */\n\t\tif (hash_extended_proc == F_HASH_RANGE_EXTENDED &&\n\t\t\t!range_element_has_extended_hashing(typentry))\n\t\t\thash_extended_proc = InvalidOid;\n\n\t\t/* Force update of proc finfo only if we're changing state */\n\t\tif (typentry->hash_extended_proc != hash_extended_proc)\n\t\t\ttypentry->hash_extended_proc_finfo.fn_oid = InvalidOid;\n\n\t\ttypentry->hash_extended_proc = hash_extended_proc;\n\t\ttypentry->flags |= TCFLAGS_CHECKED_HASH_EXTENDED_PROC;\n\t}\n\n\t/*\n\t * Set up fmgr lookup info as requested\n\t *\n\t * Note: we tell fmgr the finfo structures live in CacheMemoryContext,\n\t * which is not quite right (they're really in the hash table's private\n\t * memory context) but this will do for our purposes.\n\t *\n\t * Note: the code above avoids invalidating the finfo structs unless the\n\t * referenced operator/function OID actually changes.  This is to prevent\n\t * unnecessary leakage of any subsidiary data attached to an finfo, since\n\t * that would cause session-lifespan memory leaks.\n\t */\n\tif ((flags & TYPECACHE_EQ_OPR_FINFO) &&\n\t\ttypentry->eq_opr_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->eq_opr != InvalidOid)\n\t{\n\t\tOid\t\t\teq_opr_func;\n\n\t\teq_opr_func = get_opcode(typentry->eq_opr);\n\t\tif (eq_opr_func != InvalidOid)\n\t\t\tfmgr_info_cxt(eq_opr_func, &typentry->eq_opr_finfo,\n\t\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_CMP_PROC_FINFO) &&\n\t\ttypentry->cmp_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->cmp_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->cmp_proc, &typentry->cmp_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_PROC_FINFO) &&\n\t\ttypentry->hash_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_proc, &typentry->hash_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\tif ((flags & TYPECACHE_HASH_EXTENDED_PROC_FINFO) &&\n\t\ttypentry->hash_extended_proc_finfo.fn_oid == InvalidOid &&\n\t\ttypentry->hash_extended_proc != InvalidOid)\n\t{\n\t\tfmgr_info_cxt(typentry->hash_extended_proc,\n\t\t\t\t\t  &typentry->hash_extended_proc_finfo,\n\t\t\t\t\t  CacheMemoryContext);\n\t}\n\n\t/*\n\t * If it's a composite type (row type), get tupdesc if requested\n\t */\n\tif ((flags & TYPECACHE_TUPDESC) &&\n\t\ttypentry->tupDesc == NULL &&\n\t\ttypentry->typtype == TYPTYPE_COMPOSITE)\n\t{\n\t\tload_typcache_tupdesc(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a range type\n\t */\n\tif ((flags & TYPECACHE_RANGE_INFO) &&\n\t\ttypentry->rngelemtype == NULL &&\n\t\ttypentry->typtype == TYPTYPE_RANGE)\n\t{\n\t\tload_rangetype_info(typentry);\n\t}\n\n\t/*\n\t * If requested, get information about a domain type\n\t */\n\tif ((flags & TYPECACHE_DOMAIN_BASE_INFO) &&\n\t\ttypentry->domainBaseType == InvalidOid &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\ttypentry->domainBaseTypmod = -1;\n\t\ttypentry->domainBaseType =\n\t\t\tgetBaseTypeAndTypmod(type_id, &typentry->domainBaseTypmod);\n\t}\n\tif ((flags & TYPECACHE_DOMAIN_CONSTR_INFO) &&\n\t\t(typentry->flags & TCFLAGS_CHECKED_DOMAIN_CONSTRAINTS) == 0 &&\n\t\ttypentry->typtype == TYPTYPE_DOMAIN)\n\t{\n\t\tload_domaintype_info(typentry);\n\t}\n\n\treturn typentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "mcxt",
            "sizeof(DomainIOData)"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/expandeddatum.h\"\n#include \"utils/builtins.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic DomainIOData *\ndomain_state_setup(Oid domainType, bool binary, MemoryContext mcxt)\n{\n\tDomainIOData *my_extra;\n\tTypeCacheEntry *typentry;\n\tOid\t\t\tbaseType;\n\n\tmy_extra = (DomainIOData *) MemoryContextAlloc(mcxt, sizeof(DomainIOData));\n\n\t/*\n\t * Verify that domainType represents a valid domain type.  We need to be\n\t * careful here because domain_in and domain_recv can be called from SQL,\n\t * possibly with incorrect arguments.  We use lookup_type_cache mainly\n\t * because it will throw a clean user-facing error for a bad OID; but also\n\t * it can cache the underlying base type info.\n\t */\n\ttypentry = lookup_type_cache(domainType, TYPECACHE_DOMAIN_BASE_INFO);\n\tif (typentry->typtype != TYPTYPE_DOMAIN)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"type %s is not a domain\",\n\t\t\t\t\t\tformat_type_be(domainType))));\n\n\t/* Find out the base type */\n\tbaseType = typentry->domainBaseType;\n\tmy_extra->typtypmod = typentry->domainBaseTypmod;\n\n\t/* Look up underlying I/O function */\n\tif (binary)\n\t\tgetTypeBinaryInputInfo(baseType,\n\t\t\t\t\t\t\t   &my_extra->typiofunc,\n\t\t\t\t\t\t\t   &my_extra->typioparam);\n\telse\n\t\tgetTypeInputInfo(baseType,\n\t\t\t\t\t\t &my_extra->typiofunc,\n\t\t\t\t\t\t &my_extra->typioparam);\n\tfmgr_info_cxt(my_extra->typiofunc, &my_extra->proc, mcxt);\n\n\t/* Look up constraints for domain */\n\tInitDomainConstraintRef(domainType, &my_extra->constraint_ref, mcxt, true);\n\n\t/* We don't make an ExprContext until needed */\n\tmy_extra->econtext = NULL;\n\tmy_extra->mcxt = mcxt;\n\n\t/* Mark cache valid */\n\tmy_extra->domain_type = domainType;\n\n\treturn my_extra;\n}"
  }
]