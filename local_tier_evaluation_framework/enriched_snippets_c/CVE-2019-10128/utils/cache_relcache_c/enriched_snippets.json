[
  {
    "function_name": "unlink_initfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "6189-6201",
    "snippet": "static void\nunlink_initfile(const char *initfilename, int elevel)\n{\n\tif (unlink(initfilename) < 0)\n\t{\n\t\t/* It might not be there, but log any error other than ENOENT */\n\t\tif (errno != ENOENT)\n\t\t\tereport(elevel,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove cache file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tinitfilename)));\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unlink_initfile(const char *initfilename, int elevel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "elevel",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove cache file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tinitfilename))"
          ],
          "line": 6196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not remove cache file \\\"%s\\\": %m\"",
            "initfilename"
          ],
          "line": 6198
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 6197
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "initfilename"
          ],
          "line": 6192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void unlink_initfile(const char *initfilename, int elevel);\n\nstatic void\nunlink_initfile(const char *initfilename, int elevel)\n{\n\tif (unlink(initfilename) < 0)\n\t{\n\t\t/* It might not be there, but log any error other than ENOENT */\n\t\tif (errno != ENOENT)\n\t\t\tereport(elevel,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove cache file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tinitfilename)));\n\t}\n}"
  },
  {
    "function_name": "RelationCacheInitFileRemoveInDir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "6165-6187",
    "snippet": "static void\nRelationCacheInitFileRemoveInDir(const char *tblspcpath)\n{\n\tDIR\t\t   *dir;\n\tstruct dirent *de;\n\tchar\t\tinitfilename[MAXPGPATH * 2];\n\n\t/* Scan the tablespace directory to find per-database directories */\n\tdir = AllocateDir(tblspcpath);\n\n\twhile ((de = ReadDirExtended(dir, tblspcpath, LOG)) != NULL)\n\t{\n\t\tif (strspn(de->d_name, \"0123456789\") == strlen(de->d_name))\n\t\t{\n\t\t\t/* Try to remove the init file in each database */\n\t\t\tsnprintf(initfilename, sizeof(initfilename), \"%s/%s/%s\",\n\t\t\t\t\t tblspcpath, de->d_name, RELCACHE_INIT_FILENAME);\n\t\t\tunlink_initfile(initfilename, LOG);\n\t\t}\n\t}\n\n\tFreeDir(dir);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationCacheInitFileRemoveInDir(const char *tblspcpath);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreeDir",
          "args": [
            "dir"
          ],
          "line": 6186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink_initfile",
          "args": [
            "initfilename",
            "LOG"
          ],
          "line": 6182
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_initfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "6189-6201",
          "snippet": "static void\nunlink_initfile(const char *initfilename, int elevel)\n{\n\tif (unlink(initfilename) < 0)\n\t{\n\t\t/* It might not be there, but log any error other than ENOENT */\n\t\tif (errno != ENOENT)\n\t\t\tereport(elevel,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove cache file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tinitfilename)));\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unlink_initfile(const char *initfilename, int elevel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void unlink_initfile(const char *initfilename, int elevel);\n\nstatic void\nunlink_initfile(const char *initfilename, int elevel)\n{\n\tif (unlink(initfilename) < 0)\n\t{\n\t\t/* It might not be there, but log any error other than ENOENT */\n\t\tif (errno != ENOENT)\n\t\t\tereport(elevel,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove cache file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tinitfilename)));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "initfilename",
            "sizeof(initfilename)",
            "\"%s/%s/%s\"",
            "tblspcpath",
            "de->d_name",
            "RELCACHE_INIT_FILENAME"
          ],
          "line": 6180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "de->d_name"
          ],
          "line": 6177
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "de->d_name",
            "\"0123456789\""
          ],
          "line": 6177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadDirExtended",
          "args": [
            "dir",
            "tblspcpath",
            "LOG"
          ],
          "line": 6175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocateDir",
          "args": [
            "tblspcpath"
          ],
          "line": 6173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationCacheInitFileRemoveInDir(const char *tblspcpath);\n\nstatic void\nRelationCacheInitFileRemoveInDir(const char *tblspcpath)\n{\n\tDIR\t\t   *dir;\n\tstruct dirent *de;\n\tchar\t\tinitfilename[MAXPGPATH * 2];\n\n\t/* Scan the tablespace directory to find per-database directories */\n\tdir = AllocateDir(tblspcpath);\n\n\twhile ((de = ReadDirExtended(dir, tblspcpath, LOG)) != NULL)\n\t{\n\t\tif (strspn(de->d_name, \"0123456789\") == strlen(de->d_name))\n\t\t{\n\t\t\t/* Try to remove the init file in each database */\n\t\t\tsnprintf(initfilename, sizeof(initfilename), \"%s/%s/%s\",\n\t\t\t\t\t tblspcpath, de->d_name, RELCACHE_INIT_FILENAME);\n\t\t\tunlink_initfile(initfilename, LOG);\n\t\t}\n\t}\n\n\tFreeDir(dir);\n}"
  },
  {
    "function_name": "RelationCacheInitFileRemove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "6132-6162",
    "snippet": "void\nRelationCacheInitFileRemove(void)\n{\n\tconst char *tblspcdir = \"pg_tblspc\";\n\tDIR\t\t   *dir;\n\tstruct dirent *de;\n\tchar\t\tpath[MAXPGPATH + 10 + sizeof(TABLESPACE_VERSION_DIRECTORY)];\n\n\tsnprintf(path, sizeof(path), \"global/%s\",\n\t\t\t RELCACHE_INIT_FILENAME);\n\tunlink_initfile(path, LOG);\n\n\t/* Scan everything in the default tablespace */\n\tRelationCacheInitFileRemoveInDir(\"base\");\n\n\t/* Scan the tablespace link directory to find non-default tablespaces */\n\tdir = AllocateDir(tblspcdir);\n\n\twhile ((de = ReadDirExtended(dir, tblspcdir, LOG)) != NULL)\n\t{\n\t\tif (strspn(de->d_name, \"0123456789\") == strlen(de->d_name))\n\t\t{\n\t\t\t/* Scan the tablespace dir for per-database dirs */\n\t\t\tsnprintf(path, sizeof(path), \"%s/%s/%s\",\n\t\t\t\t\t tblspcdir, de->d_name, TABLESPACE_VERSION_DIRECTORY);\n\t\t\tRelationCacheInitFileRemoveInDir(path);\n\t\t}\n\t}\n\n\tFreeDir(dir);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreeDir",
          "args": [
            "dir"
          ],
          "line": 6161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationCacheInitFileRemoveInDir",
          "args": [
            "path"
          ],
          "line": 6157
        },
        "resolved": true,
        "details": {
          "function_name": "RelationCacheInitFileRemoveInDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "6165-6187",
          "snippet": "static void\nRelationCacheInitFileRemoveInDir(const char *tblspcpath)\n{\n\tDIR\t\t   *dir;\n\tstruct dirent *de;\n\tchar\t\tinitfilename[MAXPGPATH * 2];\n\n\t/* Scan the tablespace directory to find per-database directories */\n\tdir = AllocateDir(tblspcpath);\n\n\twhile ((de = ReadDirExtended(dir, tblspcpath, LOG)) != NULL)\n\t{\n\t\tif (strspn(de->d_name, \"0123456789\") == strlen(de->d_name))\n\t\t{\n\t\t\t/* Try to remove the init file in each database */\n\t\t\tsnprintf(initfilename, sizeof(initfilename), \"%s/%s/%s\",\n\t\t\t\t\t tblspcpath, de->d_name, RELCACHE_INIT_FILENAME);\n\t\t\tunlink_initfile(initfilename, LOG);\n\t\t}\n\t}\n\n\tFreeDir(dir);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationCacheInitFileRemoveInDir(const char *tblspcpath);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationCacheInitFileRemoveInDir(const char *tblspcpath);\n\nstatic void\nRelationCacheInitFileRemoveInDir(const char *tblspcpath)\n{\n\tDIR\t\t   *dir;\n\tstruct dirent *de;\n\tchar\t\tinitfilename[MAXPGPATH * 2];\n\n\t/* Scan the tablespace directory to find per-database directories */\n\tdir = AllocateDir(tblspcpath);\n\n\twhile ((de = ReadDirExtended(dir, tblspcpath, LOG)) != NULL)\n\t{\n\t\tif (strspn(de->d_name, \"0123456789\") == strlen(de->d_name))\n\t\t{\n\t\t\t/* Try to remove the init file in each database */\n\t\t\tsnprintf(initfilename, sizeof(initfilename), \"%s/%s/%s\",\n\t\t\t\t\t tblspcpath, de->d_name, RELCACHE_INIT_FILENAME);\n\t\t\tunlink_initfile(initfilename, LOG);\n\t\t}\n\t}\n\n\tFreeDir(dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof(path)",
            "\"%s/%s/%s\"",
            "tblspcdir",
            "de->d_name",
            "TABLESPACE_VERSION_DIRECTORY"
          ],
          "line": 6155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "de->d_name"
          ],
          "line": 6152
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "de->d_name",
            "\"0123456789\""
          ],
          "line": 6152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadDirExtended",
          "args": [
            "dir",
            "tblspcdir",
            "LOG"
          ],
          "line": 6150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocateDir",
          "args": [
            "tblspcdir"
          ],
          "line": 6148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink_initfile",
          "args": [
            "path",
            "LOG"
          ],
          "line": 6142
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_initfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "6189-6201",
          "snippet": "static void\nunlink_initfile(const char *initfilename, int elevel)\n{\n\tif (unlink(initfilename) < 0)\n\t{\n\t\t/* It might not be there, but log any error other than ENOENT */\n\t\tif (errno != ENOENT)\n\t\t\tereport(elevel,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove cache file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tinitfilename)));\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unlink_initfile(const char *initfilename, int elevel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void unlink_initfile(const char *initfilename, int elevel);\n\nstatic void\nunlink_initfile(const char *initfilename, int elevel)\n{\n\tif (unlink(initfilename) < 0)\n\t{\n\t\t/* It might not be there, but log any error other than ENOENT */\n\t\tif (errno != ENOENT)\n\t\t\tereport(elevel,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove cache file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tinitfilename)));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "path",
            "sizeof(path)",
            "\"global/%s\"",
            "RELCACHE_INIT_FILENAME"
          ],
          "line": 6140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nvoid\nRelationCacheInitFileRemove(void)\n{\n\tconst char *tblspcdir = \"pg_tblspc\";\n\tDIR\t\t   *dir;\n\tstruct dirent *de;\n\tchar\t\tpath[MAXPGPATH + 10 + sizeof(TABLESPACE_VERSION_DIRECTORY)];\n\n\tsnprintf(path, sizeof(path), \"global/%s\",\n\t\t\t RELCACHE_INIT_FILENAME);\n\tunlink_initfile(path, LOG);\n\n\t/* Scan everything in the default tablespace */\n\tRelationCacheInitFileRemoveInDir(\"base\");\n\n\t/* Scan the tablespace link directory to find non-default tablespaces */\n\tdir = AllocateDir(tblspcdir);\n\n\twhile ((de = ReadDirExtended(dir, tblspcdir, LOG)) != NULL)\n\t{\n\t\tif (strspn(de->d_name, \"0123456789\") == strlen(de->d_name))\n\t\t{\n\t\t\t/* Scan the tablespace dir for per-database dirs */\n\t\t\tsnprintf(path, sizeof(path), \"%s/%s/%s\",\n\t\t\t\t\t tblspcdir, de->d_name, TABLESPACE_VERSION_DIRECTORY);\n\t\t\tRelationCacheInitFileRemoveInDir(path);\n\t\t}\n\t}\n\n\tFreeDir(dir);\n}"
  },
  {
    "function_name": "RelationCacheInitFilePostInvalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "6117-6121",
    "snippet": "void\nRelationCacheInitFilePostInvalidate(void)\n{\n\tLWLockRelease(RelCacheInitLock);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "RelCacheInitLock"
          ],
          "line": 6120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nvoid\nRelationCacheInitFilePostInvalidate(void)\n{\n\tLWLockRelease(RelCacheInitLock);\n}"
  },
  {
    "function_name": "RelationCacheInitFilePreInvalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "6092-6115",
    "snippet": "void\nRelationCacheInitFilePreInvalidate(void)\n{\n\tchar\t\tlocalinitfname[MAXPGPATH];\n\tchar\t\tsharedinitfname[MAXPGPATH];\n\n\tif (DatabasePath)\n\t\tsnprintf(localinitfname, sizeof(localinitfname), \"%s/%s\",\n\t\t\t\t DatabasePath, RELCACHE_INIT_FILENAME);\n\tsnprintf(sharedinitfname, sizeof(sharedinitfname), \"global/%s\",\n\t\t\t RELCACHE_INIT_FILENAME);\n\n\tLWLockAcquire(RelCacheInitLock, LW_EXCLUSIVE);\n\n\t/*\n\t * The files might not be there if no backend has been started since the\n\t * last removal.  But complain about failures other than ENOENT with\n\t * ERROR.  Fortunately, it's not too late to abort the transaction if we\n\t * can't get rid of the would-be-obsolete init file.\n\t */\n\tif (DatabasePath)\n\t\tunlink_initfile(localinitfname, ERROR);\n\tunlink_initfile(sharedinitfname, ERROR);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink_initfile",
          "args": [
            "sharedinitfname",
            "ERROR"
          ],
          "line": 6114
        },
        "resolved": true,
        "details": {
          "function_name": "unlink_initfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "6189-6201",
          "snippet": "static void\nunlink_initfile(const char *initfilename, int elevel)\n{\n\tif (unlink(initfilename) < 0)\n\t{\n\t\t/* It might not be there, but log any error other than ENOENT */\n\t\tif (errno != ENOENT)\n\t\t\tereport(elevel,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove cache file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tinitfilename)));\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unlink_initfile(const char *initfilename, int elevel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void unlink_initfile(const char *initfilename, int elevel);\n\nstatic void\nunlink_initfile(const char *initfilename, int elevel)\n{\n\tif (unlink(initfilename) < 0)\n\t{\n\t\t/* It might not be there, but log any error other than ENOENT */\n\t\tif (errno != ENOENT)\n\t\t\tereport(elevel,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not remove cache file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tinitfilename)));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "RelCacheInitLock",
            "LW_EXCLUSIVE"
          ],
          "line": 6104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "sharedinitfname",
            "sizeof(sharedinitfname)",
            "\"global/%s\"",
            "RELCACHE_INIT_FILENAME"
          ],
          "line": 6101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "localinitfname",
            "sizeof(localinitfname)",
            "\"%s/%s\"",
            "DatabasePath",
            "RELCACHE_INIT_FILENAME"
          ],
          "line": 6099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nvoid\nRelationCacheInitFilePreInvalidate(void)\n{\n\tchar\t\tlocalinitfname[MAXPGPATH];\n\tchar\t\tsharedinitfname[MAXPGPATH];\n\n\tif (DatabasePath)\n\t\tsnprintf(localinitfname, sizeof(localinitfname), \"%s/%s\",\n\t\t\t\t DatabasePath, RELCACHE_INIT_FILENAME);\n\tsnprintf(sharedinitfname, sizeof(sharedinitfname), \"global/%s\",\n\t\t\t RELCACHE_INIT_FILENAME);\n\n\tLWLockAcquire(RelCacheInitLock, LW_EXCLUSIVE);\n\n\t/*\n\t * The files might not be there if no backend has been started since the\n\t * last removal.  But complain about failures other than ENOENT with\n\t * ERROR.  Fortunately, it's not too late to abort the transaction if we\n\t * can't get rid of the would-be-obsolete init file.\n\t */\n\tif (DatabasePath)\n\t\tunlink_initfile(localinitfname, ERROR);\n\tunlink_initfile(sharedinitfname, ERROR);\n}"
  },
  {
    "function_name": "RelationHasUnloggedIndex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "6036-6068",
    "snippet": "bool\nRelationHasUnloggedIndex(Relation rel)\n{\n\tList\t   *indexoidlist;\n\tListCell   *indexoidscan;\n\tbool\t\tresult = false;\n\n\tindexoidlist = RelationGetIndexList(rel);\n\n\tforeach(indexoidscan, indexoidlist)\n\t{\n\t\tOid\t\t\tindexoid = lfirst_oid(indexoidscan);\n\t\tHeapTuple\ttp;\n\t\tForm_pg_class reltup;\n\n\t\ttp = SearchSysCache1(RELOID, ObjectIdGetDatum(indexoid));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", indexoid);\n\t\treltup = (Form_pg_class) GETSTRUCT(tp);\n\n\t\tif (reltup->relpersistence == RELPERSISTENCE_UNLOGGED)\n\t\t\tresult = true;\n\n\t\tReleaseSysCache(tp);\n\n\t\tif (result == true)\n\t\t\tbreak;\n\t}\n\n\tlist_free(indexoidlist);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_free",
          "args": [
            "indexoidlist"
          ],
          "line": 6065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tp"
          ],
          "line": 6059
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tp"
          ],
          "line": 6054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for relation %u\"",
            "indexoid"
          ],
          "line": 6053
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tp"
          ],
          "line": 6052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "RELOID",
            "ObjectIdGetDatum(indexoid)"
          ],
          "line": 6051
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "indexoid"
          ],
          "line": 6051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst_oid",
          "args": [
            "indexoidscan"
          ],
          "line": 6047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "indexoidscan",
            "indexoidlist"
          ],
          "line": 6045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetIndexList",
          "args": [
            "rel"
          ],
          "line": 6043
        },
        "resolved": true,
        "details": {
          "function_name": "RelationGetIndexList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "4242-4359",
          "snippet": "List *\nRelationGetIndexList(Relation relation)\n{\n\tRelation\tindrel;\n\tSysScanDesc indscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tList\t   *result;\n\tList\t   *oldlist;\n\tchar\t\treplident = relation->rd_rel->relreplident;\n\tOid\t\t\toidIndex = InvalidOid;\n\tOid\t\t\tpkeyIndex = InvalidOid;\n\tOid\t\t\tcandidateIndex = InvalidOid;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the list. */\n\tif (relation->rd_indexvalid != 0)\n\t\treturn list_copy(relation->rd_indexlist);\n\n\t/*\n\t * We build the list we intend to return (in the caller's context) while\n\t * doing the scan.  After successfully completing the scan, we copy that\n\t * list into the relcache entry.  This avoids cache-context memory leakage\n\t * if we get some sort of error partway through.\n\t */\n\tresult = NIL;\n\toidIndex = InvalidOid;\n\n\t/* Prepare to scan pg_index for entries having indrelid = this rel. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_index_indrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tindrel = heap_open(IndexRelationId, AccessShareLock);\n\tindscan = systable_beginscan(indrel, IndexIndrelidIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, &skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(indscan)))\n\t{\n\t\tForm_pg_index index = (Form_pg_index) GETSTRUCT(htup);\n\t\tDatum\t\tindclassDatum;\n\t\toidvector  *indclass;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Ignore any indexes that are currently being dropped.  This will\n\t\t * prevent them from being searched, inserted into, or considered in\n\t\t * HOT-safety decisions.  It's unsafe to touch such an index at all\n\t\t * since its catalog entries could disappear at any instant.\n\t\t */\n\t\tif (!IndexIsLive(index))\n\t\t\tcontinue;\n\n\t\t/* Add index's OID to result list in the proper order */\n\t\tresult = insert_ordered_oid(result, index->indexrelid);\n\n\t\t/*\n\t\t * indclass cannot be referenced directly through the C struct,\n\t\t * because it comes after the variable-width indkey field.  Must\n\t\t * extract the datum the hard way...\n\t\t */\n\t\tindclassDatum = heap_getattr(htup,\n\t\t\t\t\t\t\t\t\t Anum_pg_index_indclass,\n\t\t\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t\t &isnull);\n\t\tAssert(!isnull);\n\t\tindclass = (oidvector *) DatumGetPointer(indclassDatum);\n\n\t\t/*\n\t\t * Invalid, non-unique, non-immediate or predicate indexes aren't\n\t\t * interesting for either oid indexes or replication identity indexes,\n\t\t * so don't check them.\n\t\t */\n\t\tif (!IndexIsValid(index) || !index->indisunique ||\n\t\t\t!index->indimmediate ||\n\t\t\t!heap_attisnull(htup, Anum_pg_index_indpred, NULL))\n\t\t\tcontinue;\n\n\t\t/* Check to see if is a usable btree index on OID */\n\t\tif (index->indnatts == 1 &&\n\t\t\tindex->indkey.values[0] == ObjectIdAttributeNumber &&\n\t\t\tindclass->values[0] == OID_BTREE_OPS_OID)\n\t\t\toidIndex = index->indexrelid;\n\n\t\t/* remember primary key index if any */\n\t\tif (index->indisprimary)\n\t\t\tpkeyIndex = index->indexrelid;\n\n\t\t/* remember explicitly chosen replica index */\n\t\tif (index->indisreplident)\n\t\t\tcandidateIndex = index->indexrelid;\n\t}\n\n\tsystable_endscan(indscan);\n\n\theap_close(indrel, AccessShareLock);\n\n\t/* Now save a copy of the completed list in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\toldlist = relation->rd_indexlist;\n\trelation->rd_indexlist = list_copy(result);\n\trelation->rd_oidindex = oidIndex;\n\trelation->rd_pkindex = pkeyIndex;\n\tif (replident == REPLICA_IDENTITY_DEFAULT && OidIsValid(pkeyIndex))\n\t\trelation->rd_replidindex = pkeyIndex;\n\telse if (replident == REPLICA_IDENTITY_INDEX && OidIsValid(candidateIndex))\n\t\trelation->rd_replidindex = candidateIndex;\n\telse\n\t\trelation->rd_replidindex = InvalidOid;\n\trelation->rd_indexvalid = 1;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Don't leak the old list, if there is one */\n\tlist_free(oldlist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static TupleDesc GetPgIndexDescriptor(void);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static List *insert_ordered_oid(List *list, Oid datum);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic TupleDesc GetPgIndexDescriptor(void);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic List *insert_ordered_oid(List *list, Oid datum);\nstatic void InitIndexAmRoutine(Relation relation);\n\nList *\nRelationGetIndexList(Relation relation)\n{\n\tRelation\tindrel;\n\tSysScanDesc indscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tList\t   *result;\n\tList\t   *oldlist;\n\tchar\t\treplident = relation->rd_rel->relreplident;\n\tOid\t\t\toidIndex = InvalidOid;\n\tOid\t\t\tpkeyIndex = InvalidOid;\n\tOid\t\t\tcandidateIndex = InvalidOid;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the list. */\n\tif (relation->rd_indexvalid != 0)\n\t\treturn list_copy(relation->rd_indexlist);\n\n\t/*\n\t * We build the list we intend to return (in the caller's context) while\n\t * doing the scan.  After successfully completing the scan, we copy that\n\t * list into the relcache entry.  This avoids cache-context memory leakage\n\t * if we get some sort of error partway through.\n\t */\n\tresult = NIL;\n\toidIndex = InvalidOid;\n\n\t/* Prepare to scan pg_index for entries having indrelid = this rel. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_index_indrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tindrel = heap_open(IndexRelationId, AccessShareLock);\n\tindscan = systable_beginscan(indrel, IndexIndrelidIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, &skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(indscan)))\n\t{\n\t\tForm_pg_index index = (Form_pg_index) GETSTRUCT(htup);\n\t\tDatum\t\tindclassDatum;\n\t\toidvector  *indclass;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Ignore any indexes that are currently being dropped.  This will\n\t\t * prevent them from being searched, inserted into, or considered in\n\t\t * HOT-safety decisions.  It's unsafe to touch such an index at all\n\t\t * since its catalog entries could disappear at any instant.\n\t\t */\n\t\tif (!IndexIsLive(index))\n\t\t\tcontinue;\n\n\t\t/* Add index's OID to result list in the proper order */\n\t\tresult = insert_ordered_oid(result, index->indexrelid);\n\n\t\t/*\n\t\t * indclass cannot be referenced directly through the C struct,\n\t\t * because it comes after the variable-width indkey field.  Must\n\t\t * extract the datum the hard way...\n\t\t */\n\t\tindclassDatum = heap_getattr(htup,\n\t\t\t\t\t\t\t\t\t Anum_pg_index_indclass,\n\t\t\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t\t &isnull);\n\t\tAssert(!isnull);\n\t\tindclass = (oidvector *) DatumGetPointer(indclassDatum);\n\n\t\t/*\n\t\t * Invalid, non-unique, non-immediate or predicate indexes aren't\n\t\t * interesting for either oid indexes or replication identity indexes,\n\t\t * so don't check them.\n\t\t */\n\t\tif (!IndexIsValid(index) || !index->indisunique ||\n\t\t\t!index->indimmediate ||\n\t\t\t!heap_attisnull(htup, Anum_pg_index_indpred, NULL))\n\t\t\tcontinue;\n\n\t\t/* Check to see if is a usable btree index on OID */\n\t\tif (index->indnatts == 1 &&\n\t\t\tindex->indkey.values[0] == ObjectIdAttributeNumber &&\n\t\t\tindclass->values[0] == OID_BTREE_OPS_OID)\n\t\t\toidIndex = index->indexrelid;\n\n\t\t/* remember primary key index if any */\n\t\tif (index->indisprimary)\n\t\t\tpkeyIndex = index->indexrelid;\n\n\t\t/* remember explicitly chosen replica index */\n\t\tif (index->indisreplident)\n\t\t\tcandidateIndex = index->indexrelid;\n\t}\n\n\tsystable_endscan(indscan);\n\n\theap_close(indrel, AccessShareLock);\n\n\t/* Now save a copy of the completed list in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\toldlist = relation->rd_indexlist;\n\trelation->rd_indexlist = list_copy(result);\n\trelation->rd_oidindex = oidIndex;\n\trelation->rd_pkindex = pkeyIndex;\n\tif (replident == REPLICA_IDENTITY_DEFAULT && OidIsValid(pkeyIndex))\n\t\trelation->rd_replidindex = pkeyIndex;\n\telse if (replident == REPLICA_IDENTITY_INDEX && OidIsValid(candidateIndex))\n\t\trelation->rd_replidindex = candidateIndex;\n\telse\n\t\trelation->rd_replidindex = InvalidOid;\n\trelation->rd_indexvalid = 1;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Don't leak the old list, if there is one */\n\tlist_free(oldlist);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nbool\nRelationHasUnloggedIndex(Relation rel)\n{\n\tList\t   *indexoidlist;\n\tListCell   *indexoidscan;\n\tbool\t\tresult = false;\n\n\tindexoidlist = RelationGetIndexList(rel);\n\n\tforeach(indexoidscan, indexoidlist)\n\t{\n\t\tOid\t\t\tindexoid = lfirst_oid(indexoidscan);\n\t\tHeapTuple\ttp;\n\t\tForm_pg_class reltup;\n\n\t\ttp = SearchSysCache1(RELOID, ObjectIdGetDatum(indexoid));\n\t\tif (!HeapTupleIsValid(tp))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", indexoid);\n\t\treltup = (Form_pg_class) GETSTRUCT(tp);\n\n\t\tif (reltup->relpersistence == RELPERSISTENCE_UNLOGGED)\n\t\t\tresult = true;\n\n\t\tReleaseSysCache(tp);\n\n\t\tif (result == true)\n\t\t\tbreak;\n\t}\n\n\tlist_free(indexoidlist);\n\n\treturn result;\n}"
  },
  {
    "function_name": "RelationIdIsInInitFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "6010-6026",
    "snippet": "bool\nRelationIdIsInInitFile(Oid relationId)\n{\n\tif (relationId == SharedSecLabelRelationId ||\n\t\trelationId == TriggerRelidNameIndexId ||\n\t\trelationId == DatabaseNameIndexId ||\n\t\trelationId == SharedSecLabelObjectIndexId)\n\t{\n\t\t/*\n\t\t * If this Assert fails, we don't need the applicable special case\n\t\t * anymore.\n\t\t */\n\t\tAssert(!RelationSupportsSysCache(relationId));\n\t\treturn true;\n\t}\n\treturn RelationSupportsSysCache(relationId);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RelationSupportsSysCache",
          "args": [
            "relationId"
          ],
          "line": 6025
        },
        "resolved": true,
        "details": {
          "function_name": "RelationSupportsSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1511-1530",
          "snippet": "bool\nRelationSupportsSysCache(Oid relid)\n{\n\tint\t\t\tlow = 0,\n\t\t\t\thigh = SysCacheSupportingRelOidSize - 1;\n\n\twhile (low <= high)\n\t{\n\t\tint\t\t\tmiddle = low + (high - low) / 2;\n\n\t\tif (SysCacheSupportingRelOid[middle] == relid)\n\t\t\treturn true;\n\t\tif (SysCacheSupportingRelOid[middle] < relid)\n\t\t\tlow = middle + 1;\n\t\telse\n\t\t\thigh = middle - 1;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Oid\tSysCacheSupportingRelOid[SysCacheSize * 2];",
            "static int\tSysCacheSupportingRelOidSize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic Oid\tSysCacheSupportingRelOid[SysCacheSize * 2];\nstatic int\tSysCacheSupportingRelOidSize;\n\nbool\nRelationSupportsSysCache(Oid relid)\n{\n\tint\t\t\tlow = 0,\n\t\t\t\thigh = SysCacheSupportingRelOidSize - 1;\n\n\twhile (low <= high)\n\t{\n\t\tint\t\t\tmiddle = low + (high - low) / 2;\n\n\t\tif (SysCacheSupportingRelOid[middle] == relid)\n\t\t\treturn true;\n\t\tif (SysCacheSupportingRelOid[middle] < relid)\n\t\t\tlow = middle + 1;\n\t\telse\n\t\t\thigh = middle - 1;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!RelationSupportsSysCache(relationId)"
          ],
          "line": 6022
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nbool\nRelationIdIsInInitFile(Oid relationId)\n{\n\tif (relationId == SharedSecLabelRelationId ||\n\t\trelationId == TriggerRelidNameIndexId ||\n\t\trelationId == DatabaseNameIndexId ||\n\t\trelationId == SharedSecLabelObjectIndexId)\n\t{\n\t\t/*\n\t\t * If this Assert fails, we don't need the applicable special case\n\t\t * anymore.\n\t\t */\n\t\tAssert(!RelationSupportsSysCache(relationId));\n\t\treturn true;\n\t}\n\treturn RelationSupportsSysCache(relationId);\n}"
  },
  {
    "function_name": "write_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "5991-5998",
    "snippet": "static void\nwrite_item(const void *data, Size len, FILE *fp)\n{\n\tif (fwrite(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\telog(FATAL, \"could not write init file\");\n\tif (fwrite(data, 1, len, fp) != len)\n\t\telog(FATAL, \"could not write init file\");\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void write_item(const void *data, Size len, FILE *fp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"could not write init file\""
          ],
          "line": 5997
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "data",
            "1",
            "len",
            "fp"
          ],
          "line": 5996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "&len",
            "1",
            "sizeof(len)",
            "fp"
          ],
          "line": 5994
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void write_item(const void *data, Size len, FILE *fp);\n\nstatic void\nwrite_item(const void *data, Size len, FILE *fp)\n{\n\tif (fwrite(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\telog(FATAL, \"could not write init file\");\n\tif (fwrite(data, 1, len, fp) != len)\n\t\telog(FATAL, \"could not write init file\");\n}"
  },
  {
    "function_name": "write_relcache_init_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "5793-5988",
    "snippet": "static void\nwrite_relcache_init_file(bool shared)\n{\n\tFILE\t   *fp;\n\tchar\t\ttempfilename[MAXPGPATH];\n\tchar\t\tfinalfilename[MAXPGPATH];\n\tint\t\t\tmagic;\n\tHASH_SEQ_STATUS status;\n\tRelIdCacheEnt *idhentry;\n\tint\t\t\ti;\n\n\t/*\n\t * If we have already received any relcache inval events, there's no\n\t * chance of succeeding so we may as well skip the whole thing.\n\t */\n\tif (relcacheInvalsReceived != 0L)\n\t\treturn;\n\n\t/*\n\t * We must write a temporary file and rename it into place. Otherwise,\n\t * another backend starting at about the same time might crash trying to\n\t * read the partially-complete file.\n\t */\n\tif (shared)\n\t{\n\t\tsnprintf(tempfilename, sizeof(tempfilename), \"global/%s.%d\",\n\t\t\t\t RELCACHE_INIT_FILENAME, MyProcPid);\n\t\tsnprintf(finalfilename, sizeof(finalfilename), \"global/%s\",\n\t\t\t\t RELCACHE_INIT_FILENAME);\n\t}\n\telse\n\t{\n\t\tsnprintf(tempfilename, sizeof(tempfilename), \"%s/%s.%d\",\n\t\t\t\t DatabasePath, RELCACHE_INIT_FILENAME, MyProcPid);\n\t\tsnprintf(finalfilename, sizeof(finalfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELCACHE_INIT_FILENAME);\n\t}\n\n\tunlink(tempfilename);\t\t/* in case it exists w/wrong permissions */\n\n\tfp = AllocateFile(tempfilename, PG_BINARY_W);\n\tif (fp == NULL)\n\t{\n\t\t/*\n\t\t * We used to consider this a fatal error, but we might as well\n\t\t * continue with backend startup ...\n\t\t */\n\t\tereport(WARNING,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not create relation-cache initialization file \\\"%s\\\": %m\",\n\t\t\t\t\t\ttempfilename),\n\t\t\t\t errdetail(\"Continuing anyway, but there's something wrong.\")));\n\t\treturn;\n\t}\n\n\t/*\n\t * Write a magic number to serve as a file version identifier.  We can\n\t * change the magic number whenever the relcache layout changes.\n\t */\n\tmagic = RELCACHE_INIT_FILEMAGIC;\n\tif (fwrite(&magic, 1, sizeof(magic), fp) != sizeof(magic))\n\t\telog(FATAL, \"could not write init file\");\n\n\t/*\n\t * Write all the appropriate reldescs (in no particular order).\n\t */\n\thash_seq_init(&status, RelationIdCache);\n\n\twhile ((idhentry = (RelIdCacheEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tRelation\trel = idhentry->reldesc;\n\t\tForm_pg_class relform = rel->rd_rel;\n\n\t\t/* ignore if not correct group */\n\t\tif (relform->relisshared != shared)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Ignore if not supposed to be in init file.  We can allow any shared\n\t\t * relation that's been loaded so far to be in the shared init file,\n\t\t * but unshared relations must be ones that should be in the local\n\t\t * file per RelationIdIsInInitFile.  (Note: if you want to change the\n\t\t * criterion for rels to be kept in the init file, see also inval.c.\n\t\t * The reason for filtering here is to be sure that we don't put\n\t\t * anything into the local init file for which a relcache inval would\n\t\t * not cause invalidation of that init file.)\n\t\t */\n\t\tif (!shared && !RelationIdIsInInitFile(RelationGetRelid(rel)))\n\t\t{\n\t\t\t/* Nailed rels had better get stored. */\n\t\t\tAssert(!rel->rd_isnailed);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* first write the relcache entry proper */\n\t\twrite_item(rel, sizeof(RelationData), fp);\n\n\t\t/* next write the relation tuple form */\n\t\twrite_item(relform, CLASS_TUPLE_SIZE, fp);\n\n\t\t/* next, do all the attribute tuple form data entries */\n\t\tfor (i = 0; i < relform->relnatts; i++)\n\t\t{\n\t\t\twrite_item(TupleDescAttr(rel->rd_att, i),\n\t\t\t\t\t   ATTRIBUTE_FIXED_PART_SIZE, fp);\n\t\t}\n\n\t\t/* next, do the access method specific field */\n\t\twrite_item(rel->rd_options,\n\t\t\t\t   (rel->rd_options ? VARSIZE(rel->rd_options) : 0),\n\t\t\t\t   fp);\n\n\t\t/*\n\t\t * If it's an index, there's more to do. Note we explicitly ignore\n\t\t * partitioned indexes here.\n\t\t */\n\t\tif (rel->rd_rel->relkind == RELKIND_INDEX)\n\t\t{\n\t\t\t/* write the pg_index tuple */\n\t\t\t/* we assume this was created by heap_copytuple! */\n\t\t\twrite_item(rel->rd_indextuple,\n\t\t\t\t\t   HEAPTUPLESIZE + rel->rd_indextuple->t_len,\n\t\t\t\t\t   fp);\n\n\t\t\t/* next, write the vector of opfamily OIDs */\n\t\t\twrite_item(rel->rd_opfamily,\n\t\t\t\t\t   relform->relnatts * sizeof(Oid),\n\t\t\t\t\t   fp);\n\n\t\t\t/* next, write the vector of opcintype OIDs */\n\t\t\twrite_item(rel->rd_opcintype,\n\t\t\t\t\t   relform->relnatts * sizeof(Oid),\n\t\t\t\t\t   fp);\n\n\t\t\t/* next, write the vector of support procedure OIDs */\n\t\t\twrite_item(rel->rd_support,\n\t\t\t\t\t   relform->relnatts * (rel->rd_amroutine->amsupport * sizeof(RegProcedure)),\n\t\t\t\t\t   fp);\n\n\t\t\t/* next, write the vector of collation OIDs */\n\t\t\twrite_item(rel->rd_indcollation,\n\t\t\t\t\t   relform->relnatts * sizeof(Oid),\n\t\t\t\t\t   fp);\n\n\t\t\t/* finally, write the vector of indoption values */\n\t\t\twrite_item(rel->rd_indoption,\n\t\t\t\t\t   relform->relnatts * sizeof(int16),\n\t\t\t\t\t   fp);\n\t\t}\n\t}\n\n\tif (FreeFile(fp))\n\t\telog(FATAL, \"could not write init file\");\n\n\t/*\n\t * Now we have to check whether the data we've so painstakingly\n\t * accumulated is already obsolete due to someone else's just-committed\n\t * catalog changes.  If so, we just delete the temp file and leave it to\n\t * the next backend to try again.  (Our own relcache entries will be\n\t * updated by SI message processing, but we can't be sure whether what we\n\t * wrote out was up-to-date.)\n\t *\n\t * This mustn't run concurrently with the code that unlinks an init file\n\t * and sends SI messages, so grab a serialization lock for the duration.\n\t */\n\tLWLockAcquire(RelCacheInitLock, LW_EXCLUSIVE);\n\n\t/* Make sure we have seen all incoming SI messages */\n\tAcceptInvalidationMessages();\n\n\t/*\n\t * If we have received any SI relcache invals since backend start, assume\n\t * we may have written out-of-date data.\n\t */\n\tif (relcacheInvalsReceived == 0L)\n\t{\n\t\t/*\n\t\t * OK, rename the temp file to its final name, deleting any\n\t\t * previously-existing init file.\n\t\t *\n\t\t * Note: a failure here is possible under Cygwin, if some other\n\t\t * backend is holding open an unlinked-but-not-yet-gone init file. So\n\t\t * treat this as a noncritical failure; just remove the useless temp\n\t\t * file on failure.\n\t\t */\n\t\tif (rename(tempfilename, finalfilename) < 0)\n\t\t\tunlink(tempfilename);\n\t}\n\telse\n\t{\n\t\t/* Delete the already-obsolete temp file */\n\t\tunlink(tempfilename);\n\t}\n\n\tLWLockRelease(RelCacheInitLock);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define RELCACHE_INIT_FILEMAGIC\t\t0x573266\t/* version ID value */"
    ],
    "globals_used": [
      "static HTAB *RelationIdCache;",
      "static long relcacheInvalsReceived = 0L;",
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static bool load_relcache_init_file(bool shared);",
      "static void write_relcache_init_file(bool shared);",
      "static void write_item(const void *data, Size len, FILE *fp);",
      "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LWLockRelease",
          "args": [
            "RelCacheInitLock"
          ],
          "line": 5987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tempfilename"
          ],
          "line": 5984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tempfilename"
          ],
          "line": 5979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rename",
          "args": [
            "tempfilename",
            "finalfilename"
          ],
          "line": 5978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AcceptInvalidationMessages",
          "args": [],
          "line": 5961
        },
        "resolved": true,
        "details": {
          "function_name": "AcceptInvalidationMessages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "680-725",
          "snippet": "void\nAcceptInvalidationMessages(void)\n{\n\tReceiveSharedInvalidMessages(LocalExecuteInvalidationMessage,\n\t\t\t\t\t\t\t\t InvalidateSystemCaches);\n\n\t/*\n\t * Test code to force cache flushes anytime a flush could happen.\n\t *\n\t * If used with CLOBBER_FREED_MEMORY, CLOBBER_CACHE_ALWAYS provides a\n\t * fairly thorough test that the system contains no cache-flush hazards.\n\t * However, it also makes the system unbelievably slow --- the regression\n\t * tests take about 100 times longer than normal.\n\t *\n\t * If you're a glutton for punishment, try CLOBBER_CACHE_RECURSIVELY. This\n\t * slows things by at least a factor of 10000, so I wouldn't suggest\n\t * trying to run the entire regression tests that way.  It's useful to try\n\t * a few simple tests, to make sure that cache reload isn't subject to\n\t * internal cache-flush hazards, but after you've done a few thousand\n\t * recursive reloads it's unlikely you'll learn more.\n\t */\n#if defined(CLOBBER_CACHE_ALWAYS)\n\t{\n\t\tstatic bool in_recursion = false;\n\n\t\tif (!in_recursion)\n\t\t{\n\t\t\tin_recursion = true;\n\t\t\tInvalidateSystemCaches();\n\t\t\tin_recursion = false;\n\t\t}\n\t}\n#elif defined(CLOBBER_CACHE_RECURSIVELY)\n\t{\n\t\tstatic int\trecursion_depth = 0;\n\n\t\t/* Maximum depth is arbitrary depending on your threshold of pain */\n\t\tif (recursion_depth < 3)\n\t\t{\n\t\t\trecursion_depth++;\n\t\t\tInvalidateSystemCaches();\n\t\t\trecursion_depth--;\n\t\t}\n\t}\n#endif\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nAcceptInvalidationMessages(void)\n{\n\tReceiveSharedInvalidMessages(LocalExecuteInvalidationMessage,\n\t\t\t\t\t\t\t\t InvalidateSystemCaches);\n\n\t/*\n\t * Test code to force cache flushes anytime a flush could happen.\n\t *\n\t * If used with CLOBBER_FREED_MEMORY, CLOBBER_CACHE_ALWAYS provides a\n\t * fairly thorough test that the system contains no cache-flush hazards.\n\t * However, it also makes the system unbelievably slow --- the regression\n\t * tests take about 100 times longer than normal.\n\t *\n\t * If you're a glutton for punishment, try CLOBBER_CACHE_RECURSIVELY. This\n\t * slows things by at least a factor of 10000, so I wouldn't suggest\n\t * trying to run the entire regression tests that way.  It's useful to try\n\t * a few simple tests, to make sure that cache reload isn't subject to\n\t * internal cache-flush hazards, but after you've done a few thousand\n\t * recursive reloads it's unlikely you'll learn more.\n\t */\n#if defined(CLOBBER_CACHE_ALWAYS)\n\t{\n\t\tstatic bool in_recursion = false;\n\n\t\tif (!in_recursion)\n\t\t{\n\t\t\tin_recursion = true;\n\t\t\tInvalidateSystemCaches();\n\t\t\tin_recursion = false;\n\t\t}\n\t}\n#elif defined(CLOBBER_CACHE_RECURSIVELY)\n\t{\n\t\tstatic int\trecursion_depth = 0;\n\n\t\t/* Maximum depth is arbitrary depending on your threshold of pain */\n\t\tif (recursion_depth < 3)\n\t\t{\n\t\t\trecursion_depth++;\n\t\t\tInvalidateSystemCaches();\n\t\t\trecursion_depth--;\n\t\t}\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "LWLockAcquire",
          "args": [
            "RelCacheInitLock",
            "LW_EXCLUSIVE"
          ],
          "line": 5958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"could not write init file\""
          ],
          "line": 5945
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreeFile",
          "args": [
            "fp"
          ],
          "line": 5944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_item",
          "args": [
            "rel->rd_indoption",
            "relform->relnatts * sizeof(int16)",
            "fp"
          ],
          "line": 5938
        },
        "resolved": true,
        "details": {
          "function_name": "write_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "5991-5998",
          "snippet": "static void\nwrite_item(const void *data, Size len, FILE *fp)\n{\n\tif (fwrite(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\telog(FATAL, \"could not write init file\");\n\tif (fwrite(data, 1, len, fp) != len)\n\t\telog(FATAL, \"could not write init file\");\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void write_item(const void *data, Size len, FILE *fp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void write_item(const void *data, Size len, FILE *fp);\n\nstatic void\nwrite_item(const void *data, Size len, FILE *fp)\n{\n\tif (fwrite(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\telog(FATAL, \"could not write init file\");\n\tif (fwrite(data, 1, len, fp) != len)\n\t\telog(FATAL, \"could not write init file\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "rel->rd_options"
          ],
          "line": 5902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "rel->rd_att",
            "i"
          ],
          "line": 5896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!rel->rd_isnailed"
          ],
          "line": 5883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationIdIsInInitFile",
          "args": [
            "RelationGetRelid(rel)"
          ],
          "line": 5880
        },
        "resolved": true,
        "details": {
          "function_name": "RelationIdIsInInitFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "6010-6026",
          "snippet": "bool\nRelationIdIsInInitFile(Oid relationId)\n{\n\tif (relationId == SharedSecLabelRelationId ||\n\t\trelationId == TriggerRelidNameIndexId ||\n\t\trelationId == DatabaseNameIndexId ||\n\t\trelationId == SharedSecLabelObjectIndexId)\n\t{\n\t\t/*\n\t\t * If this Assert fails, we don't need the applicable special case\n\t\t * anymore.\n\t\t */\n\t\tAssert(!RelationSupportsSysCache(relationId));\n\t\treturn true;\n\t}\n\treturn RelationSupportsSysCache(relationId);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nbool\nRelationIdIsInInitFile(Oid relationId)\n{\n\tif (relationId == SharedSecLabelRelationId ||\n\t\trelationId == TriggerRelidNameIndexId ||\n\t\trelationId == DatabaseNameIndexId ||\n\t\trelationId == SharedSecLabelObjectIndexId)\n\t{\n\t\t/*\n\t\t * If this Assert fails, we don't need the applicable special case\n\t\t * anymore.\n\t\t */\n\t\tAssert(!RelationSupportsSysCache(relationId));\n\t\treturn true;\n\t}\n\treturn RelationSupportsSysCache(relationId);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "rel"
          ],
          "line": 5880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_seq_search",
          "args": [
            "&status"
          ],
          "line": 5861
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1388-1462",
          "snippet": "void *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_init",
          "args": [
            "&status",
            "RelationIdCache"
          ],
          "line": 5859
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1378-1386",
          "snippet": "void\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "&magic",
            "1",
            "sizeof(magic)",
            "fp"
          ],
          "line": 5853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "WARNING",
            "(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not create relation-cache initialization file \\\"%s\\\": %m\",\n\t\t\t\t\t\ttempfilename),\n\t\t\t\t errdetail(\"Continuing anyway, but there's something wrong.\"))"
          ],
          "line": 5840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"Continuing anyway, but there's something wrong.\""
          ],
          "line": 5844
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not create relation-cache initialization file \\\"%s\\\": %m\"",
            "tempfilename"
          ],
          "line": 5842
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 5841
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "AllocateFile",
          "args": [
            "tempfilename",
            "PG_BINARY_W"
          ],
          "line": 5833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tempfilename"
          ],
          "line": 5831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "finalfilename",
            "sizeof(finalfilename)",
            "\"%s/%s\"",
            "DatabasePath",
            "RELCACHE_INIT_FILENAME"
          ],
          "line": 5827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tempfilename",
            "sizeof(tempfilename)",
            "\"%s/%s.%d\"",
            "DatabasePath",
            "RELCACHE_INIT_FILENAME",
            "MyProcPid"
          ],
          "line": 5825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "finalfilename",
            "sizeof(finalfilename)",
            "\"global/%s\"",
            "RELCACHE_INIT_FILENAME"
          ],
          "line": 5820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tempfilename",
            "sizeof(tempfilename)",
            "\"global/%s.%d\"",
            "RELCACHE_INIT_FILENAME",
            "MyProcPid"
          ],
          "line": 5818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\n#define RELCACHE_INIT_FILEMAGIC\t\t0x573266\t/* version ID value */\n\nstatic HTAB *RelationIdCache;\nstatic long relcacheInvalsReceived = 0L;\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic bool load_relcache_init_file(bool shared);\nstatic void write_relcache_init_file(bool shared);\nstatic void write_item(const void *data, Size len, FILE *fp);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nwrite_relcache_init_file(bool shared)\n{\n\tFILE\t   *fp;\n\tchar\t\ttempfilename[MAXPGPATH];\n\tchar\t\tfinalfilename[MAXPGPATH];\n\tint\t\t\tmagic;\n\tHASH_SEQ_STATUS status;\n\tRelIdCacheEnt *idhentry;\n\tint\t\t\ti;\n\n\t/*\n\t * If we have already received any relcache inval events, there's no\n\t * chance of succeeding so we may as well skip the whole thing.\n\t */\n\tif (relcacheInvalsReceived != 0L)\n\t\treturn;\n\n\t/*\n\t * We must write a temporary file and rename it into place. Otherwise,\n\t * another backend starting at about the same time might crash trying to\n\t * read the partially-complete file.\n\t */\n\tif (shared)\n\t{\n\t\tsnprintf(tempfilename, sizeof(tempfilename), \"global/%s.%d\",\n\t\t\t\t RELCACHE_INIT_FILENAME, MyProcPid);\n\t\tsnprintf(finalfilename, sizeof(finalfilename), \"global/%s\",\n\t\t\t\t RELCACHE_INIT_FILENAME);\n\t}\n\telse\n\t{\n\t\tsnprintf(tempfilename, sizeof(tempfilename), \"%s/%s.%d\",\n\t\t\t\t DatabasePath, RELCACHE_INIT_FILENAME, MyProcPid);\n\t\tsnprintf(finalfilename, sizeof(finalfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELCACHE_INIT_FILENAME);\n\t}\n\n\tunlink(tempfilename);\t\t/* in case it exists w/wrong permissions */\n\n\tfp = AllocateFile(tempfilename, PG_BINARY_W);\n\tif (fp == NULL)\n\t{\n\t\t/*\n\t\t * We used to consider this a fatal error, but we might as well\n\t\t * continue with backend startup ...\n\t\t */\n\t\tereport(WARNING,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not create relation-cache initialization file \\\"%s\\\": %m\",\n\t\t\t\t\t\ttempfilename),\n\t\t\t\t errdetail(\"Continuing anyway, but there's something wrong.\")));\n\t\treturn;\n\t}\n\n\t/*\n\t * Write a magic number to serve as a file version identifier.  We can\n\t * change the magic number whenever the relcache layout changes.\n\t */\n\tmagic = RELCACHE_INIT_FILEMAGIC;\n\tif (fwrite(&magic, 1, sizeof(magic), fp) != sizeof(magic))\n\t\telog(FATAL, \"could not write init file\");\n\n\t/*\n\t * Write all the appropriate reldescs (in no particular order).\n\t */\n\thash_seq_init(&status, RelationIdCache);\n\n\twhile ((idhentry = (RelIdCacheEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tRelation\trel = idhentry->reldesc;\n\t\tForm_pg_class relform = rel->rd_rel;\n\n\t\t/* ignore if not correct group */\n\t\tif (relform->relisshared != shared)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Ignore if not supposed to be in init file.  We can allow any shared\n\t\t * relation that's been loaded so far to be in the shared init file,\n\t\t * but unshared relations must be ones that should be in the local\n\t\t * file per RelationIdIsInInitFile.  (Note: if you want to change the\n\t\t * criterion for rels to be kept in the init file, see also inval.c.\n\t\t * The reason for filtering here is to be sure that we don't put\n\t\t * anything into the local init file for which a relcache inval would\n\t\t * not cause invalidation of that init file.)\n\t\t */\n\t\tif (!shared && !RelationIdIsInInitFile(RelationGetRelid(rel)))\n\t\t{\n\t\t\t/* Nailed rels had better get stored. */\n\t\t\tAssert(!rel->rd_isnailed);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* first write the relcache entry proper */\n\t\twrite_item(rel, sizeof(RelationData), fp);\n\n\t\t/* next write the relation tuple form */\n\t\twrite_item(relform, CLASS_TUPLE_SIZE, fp);\n\n\t\t/* next, do all the attribute tuple form data entries */\n\t\tfor (i = 0; i < relform->relnatts; i++)\n\t\t{\n\t\t\twrite_item(TupleDescAttr(rel->rd_att, i),\n\t\t\t\t\t   ATTRIBUTE_FIXED_PART_SIZE, fp);\n\t\t}\n\n\t\t/* next, do the access method specific field */\n\t\twrite_item(rel->rd_options,\n\t\t\t\t   (rel->rd_options ? VARSIZE(rel->rd_options) : 0),\n\t\t\t\t   fp);\n\n\t\t/*\n\t\t * If it's an index, there's more to do. Note we explicitly ignore\n\t\t * partitioned indexes here.\n\t\t */\n\t\tif (rel->rd_rel->relkind == RELKIND_INDEX)\n\t\t{\n\t\t\t/* write the pg_index tuple */\n\t\t\t/* we assume this was created by heap_copytuple! */\n\t\t\twrite_item(rel->rd_indextuple,\n\t\t\t\t\t   HEAPTUPLESIZE + rel->rd_indextuple->t_len,\n\t\t\t\t\t   fp);\n\n\t\t\t/* next, write the vector of opfamily OIDs */\n\t\t\twrite_item(rel->rd_opfamily,\n\t\t\t\t\t   relform->relnatts * sizeof(Oid),\n\t\t\t\t\t   fp);\n\n\t\t\t/* next, write the vector of opcintype OIDs */\n\t\t\twrite_item(rel->rd_opcintype,\n\t\t\t\t\t   relform->relnatts * sizeof(Oid),\n\t\t\t\t\t   fp);\n\n\t\t\t/* next, write the vector of support procedure OIDs */\n\t\t\twrite_item(rel->rd_support,\n\t\t\t\t\t   relform->relnatts * (rel->rd_amroutine->amsupport * sizeof(RegProcedure)),\n\t\t\t\t\t   fp);\n\n\t\t\t/* next, write the vector of collation OIDs */\n\t\t\twrite_item(rel->rd_indcollation,\n\t\t\t\t\t   relform->relnatts * sizeof(Oid),\n\t\t\t\t\t   fp);\n\n\t\t\t/* finally, write the vector of indoption values */\n\t\t\twrite_item(rel->rd_indoption,\n\t\t\t\t\t   relform->relnatts * sizeof(int16),\n\t\t\t\t\t   fp);\n\t\t}\n\t}\n\n\tif (FreeFile(fp))\n\t\telog(FATAL, \"could not write init file\");\n\n\t/*\n\t * Now we have to check whether the data we've so painstakingly\n\t * accumulated is already obsolete due to someone else's just-committed\n\t * catalog changes.  If so, we just delete the temp file and leave it to\n\t * the next backend to try again.  (Our own relcache entries will be\n\t * updated by SI message processing, but we can't be sure whether what we\n\t * wrote out was up-to-date.)\n\t *\n\t * This mustn't run concurrently with the code that unlinks an init file\n\t * and sends SI messages, so grab a serialization lock for the duration.\n\t */\n\tLWLockAcquire(RelCacheInitLock, LW_EXCLUSIVE);\n\n\t/* Make sure we have seen all incoming SI messages */\n\tAcceptInvalidationMessages();\n\n\t/*\n\t * If we have received any SI relcache invals since backend start, assume\n\t * we may have written out-of-date data.\n\t */\n\tif (relcacheInvalsReceived == 0L)\n\t{\n\t\t/*\n\t\t * OK, rename the temp file to its final name, deleting any\n\t\t * previously-existing init file.\n\t\t *\n\t\t * Note: a failure here is possible under Cygwin, if some other\n\t\t * backend is holding open an unlinked-but-not-yet-gone init file. So\n\t\t * treat this as a noncritical failure; just remove the useless temp\n\t\t * file on failure.\n\t\t */\n\t\tif (rename(tempfilename, finalfilename) < 0)\n\t\t\tunlink(tempfilename);\n\t}\n\telse\n\t{\n\t\t/* Delete the already-obsolete temp file */\n\t\tunlink(tempfilename);\n\t}\n\n\tLWLockRelease(RelCacheInitLock);\n}"
  },
  {
    "function_name": "load_relcache_init_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "5400-5787",
    "snippet": "static bool\nload_relcache_init_file(bool shared)\n{\n\tFILE\t   *fp;\n\tchar\t\tinitfilename[MAXPGPATH];\n\tRelation   *rels;\n\tint\t\t\trelno,\n\t\t\t\tnum_rels,\n\t\t\t\tmax_rels,\n\t\t\t\tnailed_rels,\n\t\t\t\tnailed_indexes,\n\t\t\t\tmagic;\n\tint\t\t\ti;\n\n\tif (shared)\n\t\tsnprintf(initfilename, sizeof(initfilename), \"global/%s\",\n\t\t\t\t RELCACHE_INIT_FILENAME);\n\telse\n\t\tsnprintf(initfilename, sizeof(initfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELCACHE_INIT_FILENAME);\n\n\tfp = AllocateFile(initfilename, PG_BINARY_R);\n\tif (fp == NULL)\n\t\treturn false;\n\n\t/*\n\t * Read the index relcache entries from the file.  Note we will not enter\n\t * any of them into the cache if the read fails partway through; this\n\t * helps to guard against broken init files.\n\t */\n\tmax_rels = 100;\n\trels = (Relation *) palloc(max_rels * sizeof(Relation));\n\tnum_rels = 0;\n\tnailed_rels = nailed_indexes = 0;\n\n\t/* check for correct magic number (compatible version) */\n\tif (fread(&magic, 1, sizeof(magic), fp) != sizeof(magic))\n\t\tgoto read_failed;\n\tif (magic != RELCACHE_INIT_FILEMAGIC)\n\t\tgoto read_failed;\n\n\tfor (relno = 0;; relno++)\n\t{\n\t\tSize\t\tlen;\n\t\tsize_t\t\tnread;\n\t\tRelation\trel;\n\t\tForm_pg_class relform;\n\t\tbool\t\thas_not_null;\n\n\t\t/* first read the relation descriptor length */\n\t\tnread = fread(&len, 1, sizeof(len), fp);\n\t\tif (nread != sizeof(len))\n\t\t{\n\t\t\tif (nread == 0)\n\t\t\t\tbreak;\t\t\t/* end of file */\n\t\t\tgoto read_failed;\n\t\t}\n\n\t\t/* safety check for incompatible relcache layout */\n\t\tif (len != sizeof(RelationData))\n\t\t\tgoto read_failed;\n\n\t\t/* allocate another relcache header */\n\t\tif (num_rels >= max_rels)\n\t\t{\n\t\t\tmax_rels *= 2;\n\t\t\trels = (Relation *) repalloc(rels, max_rels * sizeof(Relation));\n\t\t}\n\n\t\trel = rels[num_rels++] = (Relation) palloc(len);\n\n\t\t/* then, read the Relation structure */\n\t\tif (fread(rel, 1, len, fp) != len)\n\t\t\tgoto read_failed;\n\n\t\t/* next read the relation tuple form */\n\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\tgoto read_failed;\n\n\t\trelform = (Form_pg_class) palloc(len);\n\t\tif (fread(relform, 1, len, fp) != len)\n\t\t\tgoto read_failed;\n\n\t\trel->rd_rel = relform;\n\n\t\t/* initialize attribute tuple forms */\n\t\trel->rd_att = CreateTemplateTupleDesc(relform->relnatts,\n\t\t\t\t\t\t\t\t\t\t\t  relform->relhasoids);\n\t\trel->rd_att->tdrefcount = 1;\t/* mark as refcounted */\n\n\t\trel->rd_att->tdtypeid = relform->reltype;\n\t\trel->rd_att->tdtypmod = -1; /* unnecessary, but... */\n\n\t\t/* next read all the attribute tuple form data entries */\n\t\thas_not_null = false;\n\t\tfor (i = 0; i < relform->relnatts; i++)\n\t\t{\n\t\t\tForm_pg_attribute attr = TupleDescAttr(rel->rd_att, i);\n\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\t\t\tif (len != ATTRIBUTE_FIXED_PART_SIZE)\n\t\t\t\tgoto read_failed;\n\t\t\tif (fread(attr, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\thas_not_null |= attr->attnotnull;\n\t\t}\n\n\t\t/* next read the access method specific field */\n\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\tgoto read_failed;\n\t\tif (len > 0)\n\t\t{\n\t\t\trel->rd_options = palloc(len);\n\t\t\tif (fread(rel->rd_options, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\t\t\tif (len != VARSIZE(rel->rd_options))\n\t\t\t\tgoto read_failed;\t/* sanity check */\n\t\t}\n\t\telse\n\t\t{\n\t\t\trel->rd_options = NULL;\n\t\t}\n\n\t\t/* mark not-null status */\n\t\tif (has_not_null)\n\t\t{\n\t\t\tTupleConstr *constr = (TupleConstr *) palloc0(sizeof(TupleConstr));\n\n\t\t\tconstr->has_not_null = true;\n\t\t\trel->rd_att->constr = constr;\n\t\t}\n\n\t\t/*\n\t\t * If it's an index, there's more to do.  Note we explicitly ignore\n\t\t * partitioned indexes here.\n\t\t */\n\t\tif (rel->rd_rel->relkind == RELKIND_INDEX)\n\t\t{\n\t\t\tMemoryContext indexcxt;\n\t\t\tOid\t\t   *opfamily;\n\t\t\tOid\t\t   *opcintype;\n\t\t\tRegProcedure *support;\n\t\t\tint\t\t\tnsupport;\n\t\t\tint16\t   *indoption;\n\t\t\tOid\t\t   *indcollation;\n\n\t\t\t/* Count nailed indexes to ensure we have 'em all */\n\t\t\tif (rel->rd_isnailed)\n\t\t\t\tnailed_indexes++;\n\n\t\t\t/* next, read the pg_index tuple */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_indextuple = (HeapTuple) palloc(len);\n\t\t\tif (fread(rel->rd_indextuple, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\t/* Fix up internal pointers in the tuple -- see heap_copytuple */\n\t\t\trel->rd_indextuple->t_data = (HeapTupleHeader) ((char *) rel->rd_indextuple + HEAPTUPLESIZE);\n\t\t\trel->rd_index = (Form_pg_index) GETSTRUCT(rel->rd_indextuple);\n\n\t\t\t/*\n\t\t\t * prepare index info context --- parameters should match\n\t\t\t * RelationInitIndexAccessInfo\n\t\t\t */\n\t\t\tindexcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t \"index info\",\n\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\t\t\trel->rd_indexcxt = indexcxt;\n\t\t\tMemoryContextCopyAndSetIdentifier(indexcxt,\n\t\t\t\t\t\t\t\t\t\t\t  RelationGetRelationName(rel));\n\n\t\t\t/*\n\t\t\t * Now we can fetch the index AM's API struct.  (We can't store\n\t\t\t * that in the init file, since it contains function pointers that\n\t\t\t * might vary across server executions.  Fortunately, it should be\n\t\t\t * safe to call the amhandler even while bootstrapping indexes.)\n\t\t\t */\n\t\t\tInitIndexAmRoutine(rel);\n\n\t\t\t/* next, read the vector of opfamily OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\topfamily = (Oid *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(opfamily, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_opfamily = opfamily;\n\n\t\t\t/* next, read the vector of opcintype OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\topcintype = (Oid *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(opcintype, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_opcintype = opcintype;\n\n\t\t\t/* next, read the vector of support procedure OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\t\t\tsupport = (RegProcedure *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(support, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_support = support;\n\n\t\t\t/* next, read the vector of collation OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\tindcollation = (Oid *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(indcollation, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_indcollation = indcollation;\n\n\t\t\t/* finally, read the vector of indoption values */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\tindoption = (int16 *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(indoption, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_indoption = indoption;\n\n\t\t\t/* set up zeroed fmgr-info vector */\n\t\t\tnsupport = relform->relnatts * rel->rd_amroutine->amsupport;\n\t\t\trel->rd_supportinfo = (FmgrInfo *)\n\t\t\t\tMemoryContextAllocZero(indexcxt, nsupport * sizeof(FmgrInfo));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Count nailed rels to ensure we have 'em all */\n\t\t\tif (rel->rd_isnailed)\n\t\t\t\tnailed_rels++;\n\n\t\t\tAssert(rel->rd_index == NULL);\n\t\t\tAssert(rel->rd_indextuple == NULL);\n\t\t\tAssert(rel->rd_indexcxt == NULL);\n\t\t\tAssert(rel->rd_amroutine == NULL);\n\t\t\tAssert(rel->rd_opfamily == NULL);\n\t\t\tAssert(rel->rd_opcintype == NULL);\n\t\t\tAssert(rel->rd_support == NULL);\n\t\t\tAssert(rel->rd_supportinfo == NULL);\n\t\t\tAssert(rel->rd_indoption == NULL);\n\t\t\tAssert(rel->rd_indcollation == NULL);\n\t\t}\n\n\t\t/*\n\t\t * Rules and triggers are not saved (mainly because the internal\n\t\t * format is complex and subject to change).  They must be rebuilt if\n\t\t * needed by RelationCacheInitializePhase3.  This is not expected to\n\t\t * be a big performance hit since few system catalogs have such. Ditto\n\t\t * for RLS policy data, partition info, index expressions, predicates,\n\t\t * exclusion info, and FDW info.\n\t\t */\n\t\trel->rd_rules = NULL;\n\t\trel->rd_rulescxt = NULL;\n\t\trel->trigdesc = NULL;\n\t\trel->rd_rsdesc = NULL;\n\t\trel->rd_partkey = NULL;\n\t\trel->rd_partkeycxt = NULL;\n\t\trel->rd_partdesc = NULL;\n\t\trel->rd_pdcxt = NULL;\n\t\trel->rd_partcheck = NIL;\n\t\trel->rd_partcheckvalid = false;\n\t\trel->rd_partcheckcxt = NULL;\n\t\trel->rd_indexprs = NIL;\n\t\trel->rd_indpred = NIL;\n\t\trel->rd_exclops = NULL;\n\t\trel->rd_exclprocs = NULL;\n\t\trel->rd_exclstrats = NULL;\n\t\trel->rd_fdwroutine = NULL;\n\n\t\t/*\n\t\t * Reset transient-state fields in the relcache entry\n\t\t */\n\t\trel->rd_smgr = NULL;\n\t\tif (rel->rd_isnailed)\n\t\t\trel->rd_refcnt = 1;\n\t\telse\n\t\t\trel->rd_refcnt = 0;\n\t\trel->rd_indexvalid = 0;\n\t\trel->rd_fkeylist = NIL;\n\t\trel->rd_fkeyvalid = false;\n\t\trel->rd_indexlist = NIL;\n\t\trel->rd_oidindex = InvalidOid;\n\t\trel->rd_pkindex = InvalidOid;\n\t\trel->rd_replidindex = InvalidOid;\n\t\trel->rd_indexattr = NULL;\n\t\trel->rd_projindexattr = NULL;\n\t\trel->rd_keyattr = NULL;\n\t\trel->rd_pkattr = NULL;\n\t\trel->rd_idattr = NULL;\n\t\trel->rd_projidx = NULL;\n\t\trel->rd_pubactions = NULL;\n\t\trel->rd_statvalid = false;\n\t\trel->rd_statlist = NIL;\n\t\trel->rd_createSubid = InvalidSubTransactionId;\n\t\trel->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\t\trel->rd_amcache = NULL;\n\t\tMemSet(&rel->pgstat_info, 0, sizeof(rel->pgstat_info));\n\n\t\t/*\n\t\t * Recompute lock and physical addressing info.  This is needed in\n\t\t * case the pg_internal.init file was copied from some other database\n\t\t * by CREATE DATABASE.\n\t\t */\n\t\tRelationInitLockInfo(rel);\n\t\tRelationInitPhysicalAddr(rel);\n\t}\n\n\t/*\n\t * We reached the end of the init file without apparent problem.  Did we\n\t * get the right number of nailed items?  This is a useful crosscheck in\n\t * case the set of critical rels or indexes changes.  However, that should\n\t * not happen in a normally-running system, so let's bleat if it does.\n\t *\n\t * For the shared init file, we're called before client authentication is\n\t * done, which means that elog(WARNING) will go only to the postmaster\n\t * log, where it's easily missed.  To ensure that developers notice bad\n\t * values of NUM_CRITICAL_SHARED_RELS/NUM_CRITICAL_SHARED_INDEXES, we put\n\t * an Assert(false) there.\n\t */\n\tif (shared)\n\t{\n\t\tif (nailed_rels != NUM_CRITICAL_SHARED_RELS ||\n\t\t\tnailed_indexes != NUM_CRITICAL_SHARED_INDEXES)\n\t\t{\n\t\t\telog(WARNING, \"found %d nailed shared rels and %d nailed shared indexes in init file, but expected %d and %d respectively\",\n\t\t\t\t nailed_rels, nailed_indexes,\n\t\t\t\t NUM_CRITICAL_SHARED_RELS, NUM_CRITICAL_SHARED_INDEXES);\n\t\t\t/* Make sure we get developers' attention about this */\n\t\t\tAssert(false);\n\t\t\t/* In production builds, recover by bootstrapping the relcache */\n\t\t\tgoto read_failed;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (nailed_rels != NUM_CRITICAL_LOCAL_RELS ||\n\t\t\tnailed_indexes != NUM_CRITICAL_LOCAL_INDEXES)\n\t\t{\n\t\t\telog(WARNING, \"found %d nailed rels and %d nailed indexes in init file, but expected %d and %d respectively\",\n\t\t\t\t nailed_rels, nailed_indexes,\n\t\t\t\t NUM_CRITICAL_LOCAL_RELS, NUM_CRITICAL_LOCAL_INDEXES);\n\t\t\t/* We don't need an Assert() in this case */\n\t\t\tgoto read_failed;\n\t\t}\n\t}\n\n\t/*\n\t * OK, all appears well.\n\t *\n\t * Now insert all the new relcache entries into the cache.\n\t */\n\tfor (relno = 0; relno < num_rels; relno++)\n\t{\n\t\tRelationCacheInsert(rels[relno], false);\n\t}\n\n\tpfree(rels);\n\tFreeFile(fp);\n\n\tif (shared)\n\t\tcriticalSharedRelcachesBuilt = true;\n\telse\n\t\tcriticalRelcachesBuilt = true;\n\treturn true;\n\n\t/*\n\t * init file is broken, so do it the hard way.  We don't bother trying to\n\t * free the clutter we just allocated; it's not in the relcache so it\n\t * won't hurt.\n\t */\nread_failed:\n\tpfree(rels);\n\tFreeFile(fp);\n\n\treturn false;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NUM_CRITICAL_SHARED_INDEXES 6\t/* fix if you change list above */",
      "#define NUM_CRITICAL_LOCAL_INDEXES\t7\t/* fix if you change list above */",
      "#define NUM_CRITICAL_LOCAL_RELS 4\t/* fix if you change list above */",
      "#define NUM_CRITICAL_SHARED_RELS\t5\t/* fix if you change list above */",
      "#define RELCACHE_INIT_FILEMAGIC\t\t0x573266\t/* version ID value */"
    ],
    "globals_used": [
      "bool\t\tcriticalRelcachesBuilt = false;",
      "bool\t\tcriticalSharedRelcachesBuilt = false;",
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static bool load_relcache_init_file(bool shared);",
      "static void write_relcache_init_file(bool shared);",
      "static void write_item(const void *data, Size len, FILE *fp);",
      "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreeFile",
          "args": [
            "fp"
          ],
          "line": 5784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "rels"
          ],
          "line": 5783
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreeFile",
          "args": [
            "fp"
          ],
          "line": 5769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationCacheInsert",
          "args": [
            "rels[relno]",
            "false"
          ],
          "line": 5765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"found %d nailed rels and %d nailed indexes in init file, but expected %d and %d respectively\"",
            "nailed_rels",
            "nailed_indexes",
            "NUM_CRITICAL_LOCAL_RELS",
            "NUM_CRITICAL_LOCAL_INDEXES"
          ],
          "line": 5750
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "false"
          ],
          "line": 5740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationInitPhysicalAddr",
          "args": [
            "rel"
          ],
          "line": 5716
        },
        "resolved": true,
        "details": {
          "function_name": "RelationInitPhysicalAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1259-1315",
          "snippet": "static void\nRelationInitPhysicalAddr(Relation relation)\n{\n\tif (relation->rd_rel->reltablespace)\n\t\trelation->rd_node.spcNode = relation->rd_rel->reltablespace;\n\telse\n\t\trelation->rd_node.spcNode = MyDatabaseTableSpace;\n\tif (relation->rd_node.spcNode == GLOBALTABLESPACE_OID)\n\t\trelation->rd_node.dbNode = InvalidOid;\n\telse\n\t\trelation->rd_node.dbNode = MyDatabaseId;\n\n\tif (relation->rd_rel->relfilenode)\n\t{\n\t\t/*\n\t\t * Even if we are using a decoding snapshot that doesn't represent the\n\t\t * current state of the catalog we need to make sure the filenode\n\t\t * points to the current file since the older file will be gone (or\n\t\t * truncated). The new file will still contain older rows so lookups\n\t\t * in them will work correctly. This wouldn't work correctly if\n\t\t * rewrites were allowed to change the schema in an incompatible way,\n\t\t * but those are prevented both on catalog tables and on user tables\n\t\t * declared as additional catalog tables.\n\t\t */\n\t\tif (HistoricSnapshotActive()\n\t\t\t&& RelationIsAccessibleInLogicalDecoding(relation)\n\t\t\t&& IsTransactionState())\n\t\t{\n\t\t\tHeapTuple\tphys_tuple;\n\t\t\tForm_pg_class physrel;\n\n\t\t\tphys_tuple = ScanPgRelation(RelationGetRelid(relation),\n\t\t\t\t\t\t\t\t\t\tRelationGetRelid(relation) != ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t\ttrue);\n\t\t\tif (!HeapTupleIsValid(phys_tuple))\n\t\t\t\telog(ERROR, \"could not find pg_class entry for %u\",\n\t\t\t\t\t RelationGetRelid(relation));\n\t\t\tphysrel = (Form_pg_class) GETSTRUCT(phys_tuple);\n\n\t\t\trelation->rd_rel->reltablespace = physrel->reltablespace;\n\t\t\trelation->rd_rel->relfilenode = physrel->relfilenode;\n\t\t\theap_freetuple(phys_tuple);\n\t\t}\n\n\t\trelation->rd_node.relNode = relation->rd_rel->relfilenode;\n\t}\n\telse\n\t{\n\t\t/* Consult the relation mapper */\n\t\trelation->rd_node.relNode =\n\t\t\tRelationMapOidToFilenode(relation->rd_id,\n\t\t\t\t\t\t\t\t\t relation->rd_rel->relisshared);\n\t\tif (!OidIsValid(relation->rd_node.relNode))\n\t\t\telog(ERROR, \"could not find relation mapping for relation \\\"%s\\\", OID %u\",\n\t\t\t\t RelationGetRelationName(relation), relation->rd_id);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationInitPhysicalAddr(Relation relation)\n{\n\tif (relation->rd_rel->reltablespace)\n\t\trelation->rd_node.spcNode = relation->rd_rel->reltablespace;\n\telse\n\t\trelation->rd_node.spcNode = MyDatabaseTableSpace;\n\tif (relation->rd_node.spcNode == GLOBALTABLESPACE_OID)\n\t\trelation->rd_node.dbNode = InvalidOid;\n\telse\n\t\trelation->rd_node.dbNode = MyDatabaseId;\n\n\tif (relation->rd_rel->relfilenode)\n\t{\n\t\t/*\n\t\t * Even if we are using a decoding snapshot that doesn't represent the\n\t\t * current state of the catalog we need to make sure the filenode\n\t\t * points to the current file since the older file will be gone (or\n\t\t * truncated). The new file will still contain older rows so lookups\n\t\t * in them will work correctly. This wouldn't work correctly if\n\t\t * rewrites were allowed to change the schema in an incompatible way,\n\t\t * but those are prevented both on catalog tables and on user tables\n\t\t * declared as additional catalog tables.\n\t\t */\n\t\tif (HistoricSnapshotActive()\n\t\t\t&& RelationIsAccessibleInLogicalDecoding(relation)\n\t\t\t&& IsTransactionState())\n\t\t{\n\t\t\tHeapTuple\tphys_tuple;\n\t\t\tForm_pg_class physrel;\n\n\t\t\tphys_tuple = ScanPgRelation(RelationGetRelid(relation),\n\t\t\t\t\t\t\t\t\t\tRelationGetRelid(relation) != ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t\ttrue);\n\t\t\tif (!HeapTupleIsValid(phys_tuple))\n\t\t\t\telog(ERROR, \"could not find pg_class entry for %u\",\n\t\t\t\t\t RelationGetRelid(relation));\n\t\t\tphysrel = (Form_pg_class) GETSTRUCT(phys_tuple);\n\n\t\t\trelation->rd_rel->reltablespace = physrel->reltablespace;\n\t\t\trelation->rd_rel->relfilenode = physrel->relfilenode;\n\t\t\theap_freetuple(phys_tuple);\n\t\t}\n\n\t\trelation->rd_node.relNode = relation->rd_rel->relfilenode;\n\t}\n\telse\n\t{\n\t\t/* Consult the relation mapper */\n\t\trelation->rd_node.relNode =\n\t\t\tRelationMapOidToFilenode(relation->rd_id,\n\t\t\t\t\t\t\t\t\t relation->rd_rel->relisshared);\n\t\tif (!OidIsValid(relation->rd_node.relNode))\n\t\t\telog(ERROR, \"could not find relation mapping for relation \\\"%s\\\", OID %u\",\n\t\t\t\t RelationGetRelationName(relation), relation->rd_id);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationInitLockInfo",
          "args": [
            "rel"
          ],
          "line": 5715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&rel->pgstat_info",
            "0",
            "sizeof(rel->pgstat_info)"
          ],
          "line": 5708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rel->rd_indcollation == NULL"
          ],
          "line": 5652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rel->rd_indoption == NULL"
          ],
          "line": 5651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rel->rd_supportinfo == NULL"
          ],
          "line": 5650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rel->rd_support == NULL"
          ],
          "line": 5649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rel->rd_opcintype == NULL"
          ],
          "line": 5648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rel->rd_opfamily == NULL"
          ],
          "line": 5647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rel->rd_amroutine == NULL"
          ],
          "line": 5646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rel->rd_indexcxt == NULL"
          ],
          "line": 5645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rel->rd_indextuple == NULL"
          ],
          "line": 5644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rel->rd_index == NULL"
          ],
          "line": 5643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "indexcxt",
            "nsupport * sizeof(FmgrInfo)"
          ],
          "line": 5635
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "indoption",
            "1",
            "len",
            "fp"
          ],
          "line": 5627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "indexcxt",
            "len"
          ],
          "line": 5626
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "&len",
            "1",
            "sizeof(len)",
            "fp"
          ],
          "line": 5623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "indcollation",
            "1",
            "len",
            "fp"
          ],
          "line": 5617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "&len",
            "1",
            "sizeof(len)",
            "fp"
          ],
          "line": 5613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "support",
            "1",
            "len",
            "fp"
          ],
          "line": 5607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "&len",
            "1",
            "sizeof(len)",
            "fp"
          ],
          "line": 5604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "opcintype",
            "1",
            "len",
            "fp"
          ],
          "line": 5598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "&len",
            "1",
            "sizeof(len)",
            "fp"
          ],
          "line": 5594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "opfamily",
            "1",
            "len",
            "fp"
          ],
          "line": 5588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "&len",
            "1",
            "sizeof(len)",
            "fp"
          ],
          "line": 5584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitIndexAmRoutine",
          "args": [
            "rel"
          ],
          "line": 5581
        },
        "resolved": true,
        "details": {
          "function_name": "InitIndexAmRoutine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1322-1341",
          "snippet": "static void\nInitIndexAmRoutine(Relation relation)\n{\n\tIndexAmRoutine *cached,\n\t\t\t   *tmp;\n\n\t/*\n\t * Call the amhandler in current, short-lived memory context, just in case\n\t * it leaks anything (it probably won't, but let's be paranoid).\n\t */\n\ttmp = GetIndexAmRoutine(relation->rd_amhandler);\n\n\t/* OK, now transfer the data into relation's rd_indexcxt. */\n\tcached = (IndexAmRoutine *) MemoryContextAlloc(relation->rd_indexcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(IndexAmRoutine));\n\tmemcpy(cached, tmp, sizeof(IndexAmRoutine));\n\trelation->rd_amroutine = cached;\n\n\tpfree(tmp);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nInitIndexAmRoutine(Relation relation)\n{\n\tIndexAmRoutine *cached,\n\t\t\t   *tmp;\n\n\t/*\n\t * Call the amhandler in current, short-lived memory context, just in case\n\t * it leaks anything (it probably won't, but let's be paranoid).\n\t */\n\ttmp = GetIndexAmRoutine(relation->rd_amhandler);\n\n\t/* OK, now transfer the data into relation's rd_indexcxt. */\n\tcached = (IndexAmRoutine *) MemoryContextAlloc(relation->rd_indexcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(IndexAmRoutine));\n\tmemcpy(cached, tmp, sizeof(IndexAmRoutine));\n\trelation->rd_amroutine = cached;\n\n\tpfree(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextCopyAndSetIdentifier",
          "args": [
            "indexcxt",
            "RelationGetRelationName(rel)"
          ],
          "line": 5572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "rel"
          ],
          "line": 5573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "CacheMemoryContext",
            "\"index info\"",
            "ALLOCSET_SMALL_SIZES"
          ],
          "line": 5568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "rel->rd_indextuple"
          ],
          "line": 5562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(char *) rel->rd_indextuple + HEAPTUPLESIZE"
          ],
          "line": 5561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "rel->rd_indextuple",
            "1",
            "len",
            "fp"
          ],
          "line": 5557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len"
          ],
          "line": 5556
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "&len",
            "1",
            "sizeof(len)",
            "fp"
          ],
          "line": 5553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "rel->rd_options"
          ],
          "line": 5517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "rel->rd_options",
            "1",
            "len",
            "fp"
          ],
          "line": 5515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "&len",
            "1",
            "sizeof(len)",
            "fp"
          ],
          "line": 5510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "attr",
            "1",
            "len",
            "fp"
          ],
          "line": 5503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "&len",
            "1",
            "sizeof(len)",
            "fp"
          ],
          "line": 5499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "rel->rd_att",
            "i"
          ],
          "line": 5497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTemplateTupleDesc",
          "args": [
            "relform->relnatts",
            "relform->relhasoids"
          ],
          "line": 5486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "relform",
            "1",
            "len",
            "fp"
          ],
          "line": 5480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "&len",
            "1",
            "sizeof(len)",
            "fp"
          ],
          "line": 5476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "rel",
            "1",
            "len",
            "fp"
          ],
          "line": 5472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "rels",
            "max_rels * sizeof(Relation)"
          ],
          "line": 5466
        },
        "resolved": true,
        "details": {
          "function_name": "repalloc_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1113-1141",
          "snippet": "void *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "&len",
            "1",
            "sizeof(len)",
            "fp"
          ],
          "line": 5450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "&magic",
            "1",
            "sizeof(magic)",
            "fp"
          ],
          "line": 5436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocateFile",
          "args": [
            "initfilename",
            "PG_BINARY_R"
          ],
          "line": 5421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "initfilename",
            "sizeof(initfilename)",
            "\"%s/%s\"",
            "DatabasePath",
            "RELCACHE_INIT_FILENAME"
          ],
          "line": 5418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "initfilename",
            "sizeof(initfilename)",
            "\"global/%s\"",
            "RELCACHE_INIT_FILENAME"
          ],
          "line": 5415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\n#define NUM_CRITICAL_SHARED_INDEXES 6\t/* fix if you change list above */\n#define NUM_CRITICAL_LOCAL_INDEXES\t7\t/* fix if you change list above */\n#define NUM_CRITICAL_LOCAL_RELS 4\t/* fix if you change list above */\n#define NUM_CRITICAL_SHARED_RELS\t5\t/* fix if you change list above */\n#define RELCACHE_INIT_FILEMAGIC\t\t0x573266\t/* version ID value */\n\nbool\t\tcriticalRelcachesBuilt = false;\nbool\t\tcriticalSharedRelcachesBuilt = false;\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic bool load_relcache_init_file(bool shared);\nstatic void write_relcache_init_file(bool shared);\nstatic void write_item(const void *data, Size len, FILE *fp);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic bool\nload_relcache_init_file(bool shared)\n{\n\tFILE\t   *fp;\n\tchar\t\tinitfilename[MAXPGPATH];\n\tRelation   *rels;\n\tint\t\t\trelno,\n\t\t\t\tnum_rels,\n\t\t\t\tmax_rels,\n\t\t\t\tnailed_rels,\n\t\t\t\tnailed_indexes,\n\t\t\t\tmagic;\n\tint\t\t\ti;\n\n\tif (shared)\n\t\tsnprintf(initfilename, sizeof(initfilename), \"global/%s\",\n\t\t\t\t RELCACHE_INIT_FILENAME);\n\telse\n\t\tsnprintf(initfilename, sizeof(initfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELCACHE_INIT_FILENAME);\n\n\tfp = AllocateFile(initfilename, PG_BINARY_R);\n\tif (fp == NULL)\n\t\treturn false;\n\n\t/*\n\t * Read the index relcache entries from the file.  Note we will not enter\n\t * any of them into the cache if the read fails partway through; this\n\t * helps to guard against broken init files.\n\t */\n\tmax_rels = 100;\n\trels = (Relation *) palloc(max_rels * sizeof(Relation));\n\tnum_rels = 0;\n\tnailed_rels = nailed_indexes = 0;\n\n\t/* check for correct magic number (compatible version) */\n\tif (fread(&magic, 1, sizeof(magic), fp) != sizeof(magic))\n\t\tgoto read_failed;\n\tif (magic != RELCACHE_INIT_FILEMAGIC)\n\t\tgoto read_failed;\n\n\tfor (relno = 0;; relno++)\n\t{\n\t\tSize\t\tlen;\n\t\tsize_t\t\tnread;\n\t\tRelation\trel;\n\t\tForm_pg_class relform;\n\t\tbool\t\thas_not_null;\n\n\t\t/* first read the relation descriptor length */\n\t\tnread = fread(&len, 1, sizeof(len), fp);\n\t\tif (nread != sizeof(len))\n\t\t{\n\t\t\tif (nread == 0)\n\t\t\t\tbreak;\t\t\t/* end of file */\n\t\t\tgoto read_failed;\n\t\t}\n\n\t\t/* safety check for incompatible relcache layout */\n\t\tif (len != sizeof(RelationData))\n\t\t\tgoto read_failed;\n\n\t\t/* allocate another relcache header */\n\t\tif (num_rels >= max_rels)\n\t\t{\n\t\t\tmax_rels *= 2;\n\t\t\trels = (Relation *) repalloc(rels, max_rels * sizeof(Relation));\n\t\t}\n\n\t\trel = rels[num_rels++] = (Relation) palloc(len);\n\n\t\t/* then, read the Relation structure */\n\t\tif (fread(rel, 1, len, fp) != len)\n\t\t\tgoto read_failed;\n\n\t\t/* next read the relation tuple form */\n\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\tgoto read_failed;\n\n\t\trelform = (Form_pg_class) palloc(len);\n\t\tif (fread(relform, 1, len, fp) != len)\n\t\t\tgoto read_failed;\n\n\t\trel->rd_rel = relform;\n\n\t\t/* initialize attribute tuple forms */\n\t\trel->rd_att = CreateTemplateTupleDesc(relform->relnatts,\n\t\t\t\t\t\t\t\t\t\t\t  relform->relhasoids);\n\t\trel->rd_att->tdrefcount = 1;\t/* mark as refcounted */\n\n\t\trel->rd_att->tdtypeid = relform->reltype;\n\t\trel->rd_att->tdtypmod = -1; /* unnecessary, but... */\n\n\t\t/* next read all the attribute tuple form data entries */\n\t\thas_not_null = false;\n\t\tfor (i = 0; i < relform->relnatts; i++)\n\t\t{\n\t\t\tForm_pg_attribute attr = TupleDescAttr(rel->rd_att, i);\n\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\t\t\tif (len != ATTRIBUTE_FIXED_PART_SIZE)\n\t\t\t\tgoto read_failed;\n\t\t\tif (fread(attr, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\thas_not_null |= attr->attnotnull;\n\t\t}\n\n\t\t/* next read the access method specific field */\n\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\tgoto read_failed;\n\t\tif (len > 0)\n\t\t{\n\t\t\trel->rd_options = palloc(len);\n\t\t\tif (fread(rel->rd_options, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\t\t\tif (len != VARSIZE(rel->rd_options))\n\t\t\t\tgoto read_failed;\t/* sanity check */\n\t\t}\n\t\telse\n\t\t{\n\t\t\trel->rd_options = NULL;\n\t\t}\n\n\t\t/* mark not-null status */\n\t\tif (has_not_null)\n\t\t{\n\t\t\tTupleConstr *constr = (TupleConstr *) palloc0(sizeof(TupleConstr));\n\n\t\t\tconstr->has_not_null = true;\n\t\t\trel->rd_att->constr = constr;\n\t\t}\n\n\t\t/*\n\t\t * If it's an index, there's more to do.  Note we explicitly ignore\n\t\t * partitioned indexes here.\n\t\t */\n\t\tif (rel->rd_rel->relkind == RELKIND_INDEX)\n\t\t{\n\t\t\tMemoryContext indexcxt;\n\t\t\tOid\t\t   *opfamily;\n\t\t\tOid\t\t   *opcintype;\n\t\t\tRegProcedure *support;\n\t\t\tint\t\t\tnsupport;\n\t\t\tint16\t   *indoption;\n\t\t\tOid\t\t   *indcollation;\n\n\t\t\t/* Count nailed indexes to ensure we have 'em all */\n\t\t\tif (rel->rd_isnailed)\n\t\t\t\tnailed_indexes++;\n\n\t\t\t/* next, read the pg_index tuple */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_indextuple = (HeapTuple) palloc(len);\n\t\t\tif (fread(rel->rd_indextuple, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\t/* Fix up internal pointers in the tuple -- see heap_copytuple */\n\t\t\trel->rd_indextuple->t_data = (HeapTupleHeader) ((char *) rel->rd_indextuple + HEAPTUPLESIZE);\n\t\t\trel->rd_index = (Form_pg_index) GETSTRUCT(rel->rd_indextuple);\n\n\t\t\t/*\n\t\t\t * prepare index info context --- parameters should match\n\t\t\t * RelationInitIndexAccessInfo\n\t\t\t */\n\t\t\tindexcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t \"index info\",\n\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\t\t\trel->rd_indexcxt = indexcxt;\n\t\t\tMemoryContextCopyAndSetIdentifier(indexcxt,\n\t\t\t\t\t\t\t\t\t\t\t  RelationGetRelationName(rel));\n\n\t\t\t/*\n\t\t\t * Now we can fetch the index AM's API struct.  (We can't store\n\t\t\t * that in the init file, since it contains function pointers that\n\t\t\t * might vary across server executions.  Fortunately, it should be\n\t\t\t * safe to call the amhandler even while bootstrapping indexes.)\n\t\t\t */\n\t\t\tInitIndexAmRoutine(rel);\n\n\t\t\t/* next, read the vector of opfamily OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\topfamily = (Oid *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(opfamily, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_opfamily = opfamily;\n\n\t\t\t/* next, read the vector of opcintype OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\topcintype = (Oid *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(opcintype, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_opcintype = opcintype;\n\n\t\t\t/* next, read the vector of support procedure OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\t\t\tsupport = (RegProcedure *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(support, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_support = support;\n\n\t\t\t/* next, read the vector of collation OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\tindcollation = (Oid *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(indcollation, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_indcollation = indcollation;\n\n\t\t\t/* finally, read the vector of indoption values */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\tindoption = (int16 *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(indoption, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_indoption = indoption;\n\n\t\t\t/* set up zeroed fmgr-info vector */\n\t\t\tnsupport = relform->relnatts * rel->rd_amroutine->amsupport;\n\t\t\trel->rd_supportinfo = (FmgrInfo *)\n\t\t\t\tMemoryContextAllocZero(indexcxt, nsupport * sizeof(FmgrInfo));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Count nailed rels to ensure we have 'em all */\n\t\t\tif (rel->rd_isnailed)\n\t\t\t\tnailed_rels++;\n\n\t\t\tAssert(rel->rd_index == NULL);\n\t\t\tAssert(rel->rd_indextuple == NULL);\n\t\t\tAssert(rel->rd_indexcxt == NULL);\n\t\t\tAssert(rel->rd_amroutine == NULL);\n\t\t\tAssert(rel->rd_opfamily == NULL);\n\t\t\tAssert(rel->rd_opcintype == NULL);\n\t\t\tAssert(rel->rd_support == NULL);\n\t\t\tAssert(rel->rd_supportinfo == NULL);\n\t\t\tAssert(rel->rd_indoption == NULL);\n\t\t\tAssert(rel->rd_indcollation == NULL);\n\t\t}\n\n\t\t/*\n\t\t * Rules and triggers are not saved (mainly because the internal\n\t\t * format is complex and subject to change).  They must be rebuilt if\n\t\t * needed by RelationCacheInitializePhase3.  This is not expected to\n\t\t * be a big performance hit since few system catalogs have such. Ditto\n\t\t * for RLS policy data, partition info, index expressions, predicates,\n\t\t * exclusion info, and FDW info.\n\t\t */\n\t\trel->rd_rules = NULL;\n\t\trel->rd_rulescxt = NULL;\n\t\trel->trigdesc = NULL;\n\t\trel->rd_rsdesc = NULL;\n\t\trel->rd_partkey = NULL;\n\t\trel->rd_partkeycxt = NULL;\n\t\trel->rd_partdesc = NULL;\n\t\trel->rd_pdcxt = NULL;\n\t\trel->rd_partcheck = NIL;\n\t\trel->rd_partcheckvalid = false;\n\t\trel->rd_partcheckcxt = NULL;\n\t\trel->rd_indexprs = NIL;\n\t\trel->rd_indpred = NIL;\n\t\trel->rd_exclops = NULL;\n\t\trel->rd_exclprocs = NULL;\n\t\trel->rd_exclstrats = NULL;\n\t\trel->rd_fdwroutine = NULL;\n\n\t\t/*\n\t\t * Reset transient-state fields in the relcache entry\n\t\t */\n\t\trel->rd_smgr = NULL;\n\t\tif (rel->rd_isnailed)\n\t\t\trel->rd_refcnt = 1;\n\t\telse\n\t\t\trel->rd_refcnt = 0;\n\t\trel->rd_indexvalid = 0;\n\t\trel->rd_fkeylist = NIL;\n\t\trel->rd_fkeyvalid = false;\n\t\trel->rd_indexlist = NIL;\n\t\trel->rd_oidindex = InvalidOid;\n\t\trel->rd_pkindex = InvalidOid;\n\t\trel->rd_replidindex = InvalidOid;\n\t\trel->rd_indexattr = NULL;\n\t\trel->rd_projindexattr = NULL;\n\t\trel->rd_keyattr = NULL;\n\t\trel->rd_pkattr = NULL;\n\t\trel->rd_idattr = NULL;\n\t\trel->rd_projidx = NULL;\n\t\trel->rd_pubactions = NULL;\n\t\trel->rd_statvalid = false;\n\t\trel->rd_statlist = NIL;\n\t\trel->rd_createSubid = InvalidSubTransactionId;\n\t\trel->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\t\trel->rd_amcache = NULL;\n\t\tMemSet(&rel->pgstat_info, 0, sizeof(rel->pgstat_info));\n\n\t\t/*\n\t\t * Recompute lock and physical addressing info.  This is needed in\n\t\t * case the pg_internal.init file was copied from some other database\n\t\t * by CREATE DATABASE.\n\t\t */\n\t\tRelationInitLockInfo(rel);\n\t\tRelationInitPhysicalAddr(rel);\n\t}\n\n\t/*\n\t * We reached the end of the init file without apparent problem.  Did we\n\t * get the right number of nailed items?  This is a useful crosscheck in\n\t * case the set of critical rels or indexes changes.  However, that should\n\t * not happen in a normally-running system, so let's bleat if it does.\n\t *\n\t * For the shared init file, we're called before client authentication is\n\t * done, which means that elog(WARNING) will go only to the postmaster\n\t * log, where it's easily missed.  To ensure that developers notice bad\n\t * values of NUM_CRITICAL_SHARED_RELS/NUM_CRITICAL_SHARED_INDEXES, we put\n\t * an Assert(false) there.\n\t */\n\tif (shared)\n\t{\n\t\tif (nailed_rels != NUM_CRITICAL_SHARED_RELS ||\n\t\t\tnailed_indexes != NUM_CRITICAL_SHARED_INDEXES)\n\t\t{\n\t\t\telog(WARNING, \"found %d nailed shared rels and %d nailed shared indexes in init file, but expected %d and %d respectively\",\n\t\t\t\t nailed_rels, nailed_indexes,\n\t\t\t\t NUM_CRITICAL_SHARED_RELS, NUM_CRITICAL_SHARED_INDEXES);\n\t\t\t/* Make sure we get developers' attention about this */\n\t\t\tAssert(false);\n\t\t\t/* In production builds, recover by bootstrapping the relcache */\n\t\t\tgoto read_failed;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (nailed_rels != NUM_CRITICAL_LOCAL_RELS ||\n\t\t\tnailed_indexes != NUM_CRITICAL_LOCAL_INDEXES)\n\t\t{\n\t\t\telog(WARNING, \"found %d nailed rels and %d nailed indexes in init file, but expected %d and %d respectively\",\n\t\t\t\t nailed_rels, nailed_indexes,\n\t\t\t\t NUM_CRITICAL_LOCAL_RELS, NUM_CRITICAL_LOCAL_INDEXES);\n\t\t\t/* We don't need an Assert() in this case */\n\t\t\tgoto read_failed;\n\t\t}\n\t}\n\n\t/*\n\t * OK, all appears well.\n\t *\n\t * Now insert all the new relcache entries into the cache.\n\t */\n\tfor (relno = 0; relno < num_rels; relno++)\n\t{\n\t\tRelationCacheInsert(rels[relno], false);\n\t}\n\n\tpfree(rels);\n\tFreeFile(fp);\n\n\tif (shared)\n\t\tcriticalSharedRelcachesBuilt = true;\n\telse\n\t\tcriticalRelcachesBuilt = true;\n\treturn true;\n\n\t/*\n\t * init file is broken, so do it the hard way.  We don't bother trying to\n\t * free the clutter we just allocated; it's not in the relcache so it\n\t * won't hurt.\n\t */\nread_failed:\n\tpfree(rels);\n\tFreeFile(fp);\n\n\treturn false;\n}"
  },
  {
    "function_name": "errtableconstraint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "5336-5343",
    "snippet": "int\nerrtableconstraint(Relation rel, const char *conname)\n{\n\terrtable(rel);\n\terr_generic_string(PG_DIAG_CONSTRAINT_NAME, conname);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "err_generic_string",
          "args": [
            "PG_DIAG_CONSTRAINT_NAME",
            "conname"
          ],
          "line": 5340
        },
        "resolved": true,
        "details": {
          "function_name": "err_generic_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1188-1219",
          "snippet": "int\nerr_generic_string(int field, const char *str)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (field)\n\t{\n\t\tcase PG_DIAG_SCHEMA_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->schema_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_TABLE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->table_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_COLUMN_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->column_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_DATATYPE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->datatype_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_CONSTRAINT_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->constraint_name, str);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unsupported ErrorData field id: %d\", field);\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static void append_with_tabs(StringInfo buf, const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic void append_with_tabs(StringInfo buf, const char *str);\n\nint\nerr_generic_string(int field, const char *str)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (field)\n\t{\n\t\tcase PG_DIAG_SCHEMA_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->schema_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_TABLE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->table_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_COLUMN_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->column_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_DATATYPE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->datatype_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_CONSTRAINT_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->constraint_name, str);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unsupported ErrorData field id: %d\", field);\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errtable",
          "args": [
            "rel"
          ],
          "line": 5339
        },
        "resolved": true,
        "details": {
          "function_name": "errtable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "5282-5290",
          "snippet": "int\nerrtable(Relation rel)\n{\n\terr_generic_string(PG_DIAG_SCHEMA_NAME,\n\t\t\t\t\t   get_namespace_name(RelationGetNamespace(rel)));\n\terr_generic_string(PG_DIAG_TABLE_NAME, RelationGetRelationName(rel));\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nint\nerrtable(Relation rel)\n{\n\terr_generic_string(PG_DIAG_SCHEMA_NAME,\n\t\t\t\t\t   get_namespace_name(RelationGetNamespace(rel)));\n\terr_generic_string(PG_DIAG_TABLE_NAME, RelationGetRelationName(rel));\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nint\nerrtableconstraint(Relation rel, const char *conname)\n{\n\terrtable(rel);\n\terr_generic_string(PG_DIAG_CONSTRAINT_NAME, conname);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errtablecolname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "5323-5330",
    "snippet": "int\nerrtablecolname(Relation rel, const char *colname)\n{\n\terrtable(rel);\n\terr_generic_string(PG_DIAG_COLUMN_NAME, colname);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "err_generic_string",
          "args": [
            "PG_DIAG_COLUMN_NAME",
            "colname"
          ],
          "line": 5327
        },
        "resolved": true,
        "details": {
          "function_name": "err_generic_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1188-1219",
          "snippet": "int\nerr_generic_string(int field, const char *str)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (field)\n\t{\n\t\tcase PG_DIAG_SCHEMA_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->schema_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_TABLE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->table_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_COLUMN_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->column_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_DATATYPE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->datatype_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_CONSTRAINT_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->constraint_name, str);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unsupported ErrorData field id: %d\", field);\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static void append_with_tabs(StringInfo buf, const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic void append_with_tabs(StringInfo buf, const char *str);\n\nint\nerr_generic_string(int field, const char *str)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (field)\n\t{\n\t\tcase PG_DIAG_SCHEMA_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->schema_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_TABLE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->table_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_COLUMN_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->column_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_DATATYPE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->datatype_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_CONSTRAINT_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->constraint_name, str);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unsupported ErrorData field id: %d\", field);\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errtable",
          "args": [
            "rel"
          ],
          "line": 5326
        },
        "resolved": true,
        "details": {
          "function_name": "errtable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "5282-5290",
          "snippet": "int\nerrtable(Relation rel)\n{\n\terr_generic_string(PG_DIAG_SCHEMA_NAME,\n\t\t\t\t\t   get_namespace_name(RelationGetNamespace(rel)));\n\terr_generic_string(PG_DIAG_TABLE_NAME, RelationGetRelationName(rel));\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nint\nerrtable(Relation rel)\n{\n\terr_generic_string(PG_DIAG_SCHEMA_NAME,\n\t\t\t\t\t   get_namespace_name(RelationGetNamespace(rel)));\n\terr_generic_string(PG_DIAG_TABLE_NAME, RelationGetRelationName(rel));\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nint\nerrtablecolname(Relation rel, const char *colname)\n{\n\terrtable(rel);\n\terr_generic_string(PG_DIAG_COLUMN_NAME, colname);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errtablecol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "5299-5312",
    "snippet": "int\nerrtablecol(Relation rel, int attnum)\n{\n\tTupleDesc\treldesc = RelationGetDescr(rel);\n\tconst char *colname;\n\n\t/* Use reldesc if it's a user attribute, else consult the catalogs */\n\tif (attnum > 0 && attnum <= reldesc->natts)\n\t\tcolname = NameStr(TupleDescAttr(reldesc, attnum - 1)->attname);\n\telse\n\t\tcolname = get_attname(RelationGetRelid(rel), attnum, false);\n\n\treturn errtablecolname(rel, colname);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "errtablecolname",
          "args": [
            "rel",
            "colname"
          ],
          "line": 5311
        },
        "resolved": true,
        "details": {
          "function_name": "errtablecolname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "5323-5330",
          "snippet": "int\nerrtablecolname(Relation rel, const char *colname)\n{\n\terrtable(rel);\n\terr_generic_string(PG_DIAG_COLUMN_NAME, colname);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nint\nerrtablecolname(Relation rel, const char *colname)\n{\n\terrtable(rel);\n\terr_generic_string(PG_DIAG_COLUMN_NAME, colname);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_attname",
          "args": [
            "RelationGetRelid(rel)",
            "attnum",
            "false"
          ],
          "line": 5309
        },
        "resolved": true,
        "details": {
          "function_name": "get_attname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "774-795",
          "snippet": "char *\nget_attname(Oid relid, AttrNumber attnum, bool missing_ok)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache2(ATTNUM,\n\t\t\t\t\t\t ObjectIdGetDatum(relid), Int16GetDatum(attnum));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_attribute att_tup = (Form_pg_attribute) GETSTRUCT(tp);\n\t\tchar\t   *result;\n\n\t\tresult = pstrdup(NameStr(att_tup->attname));\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\n\tif (!missing_ok)\n\t\telog(ERROR, \"cache lookup failed for attribute %d of relation %u\",\n\t\t\t attnum, relid);\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_attname(Oid relid, AttrNumber attnum, bool missing_ok)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache2(ATTNUM,\n\t\t\t\t\t\t ObjectIdGetDatum(relid), Int16GetDatum(attnum));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_attribute att_tup = (Form_pg_attribute) GETSTRUCT(tp);\n\t\tchar\t   *result;\n\n\t\tresult = pstrdup(NameStr(att_tup->attname));\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\n\tif (!missing_ok)\n\t\telog(ERROR, \"cache lookup failed for attribute %d of relation %u\",\n\t\t\t attnum, relid);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "rel"
          ],
          "line": 5309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "TupleDescAttr(reldesc, attnum - 1)->attname"
          ],
          "line": 5307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "reldesc",
            "attnum - 1"
          ],
          "line": 5307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "rel"
          ],
          "line": 5302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nint\nerrtablecol(Relation rel, int attnum)\n{\n\tTupleDesc\treldesc = RelationGetDescr(rel);\n\tconst char *colname;\n\n\t/* Use reldesc if it's a user attribute, else consult the catalogs */\n\tif (attnum > 0 && attnum <= reldesc->natts)\n\t\tcolname = NameStr(TupleDescAttr(reldesc, attnum - 1)->attname);\n\telse\n\t\tcolname = get_attname(RelationGetRelid(rel), attnum, false);\n\n\treturn errtablecolname(rel, colname);\n}"
  },
  {
    "function_name": "errtable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "5282-5290",
    "snippet": "int\nerrtable(Relation rel)\n{\n\terr_generic_string(PG_DIAG_SCHEMA_NAME,\n\t\t\t\t\t   get_namespace_name(RelationGetNamespace(rel)));\n\terr_generic_string(PG_DIAG_TABLE_NAME, RelationGetRelationName(rel));\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "err_generic_string",
          "args": [
            "PG_DIAG_TABLE_NAME",
            "RelationGetRelationName(rel)"
          ],
          "line": 5287
        },
        "resolved": true,
        "details": {
          "function_name": "err_generic_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1188-1219",
          "snippet": "int\nerr_generic_string(int field, const char *str)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (field)\n\t{\n\t\tcase PG_DIAG_SCHEMA_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->schema_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_TABLE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->table_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_COLUMN_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->column_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_DATATYPE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->datatype_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_CONSTRAINT_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->constraint_name, str);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unsupported ErrorData field id: %d\", field);\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static void append_with_tabs(StringInfo buf, const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic void append_with_tabs(StringInfo buf, const char *str);\n\nint\nerr_generic_string(int field, const char *str)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (field)\n\t{\n\t\tcase PG_DIAG_SCHEMA_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->schema_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_TABLE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->table_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_COLUMN_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->column_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_DATATYPE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->datatype_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_CONSTRAINT_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->constraint_name, str);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unsupported ErrorData field id: %d\", field);\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "rel"
          ],
          "line": 5287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_namespace_name",
          "args": [
            "RelationGetNamespace(rel)"
          ],
          "line": 5286
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetNamespace",
          "args": [
            "rel"
          ],
          "line": 5286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nint\nerrtable(Relation rel)\n{\n\terr_generic_string(PG_DIAG_SCHEMA_NAME,\n\t\t\t\t\t   get_namespace_name(RelationGetNamespace(rel)));\n\terr_generic_string(PG_DIAG_TABLE_NAME, RelationGetRelationName(rel));\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "GetRelationPublicationActions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "5203-5268",
    "snippet": "struct PublicationActions *\nGetRelationPublicationActions(Relation relation)\n{\n\tList\t   *puboids;\n\tListCell   *lc;\n\tMemoryContext oldcxt;\n\tPublicationActions *pubactions = palloc0(sizeof(PublicationActions));\n\n\t/*\n\t * If not publishable, it publishes no actions.  (pgoutput_change() will\n\t * ignore it.)\n\t */\n\tif (!is_publishable_relation(relation))\n\t\treturn pubactions;\n\n\tif (relation->rd_pubactions)\n\t\treturn memcpy(pubactions, relation->rd_pubactions,\n\t\t\t\t\t  sizeof(PublicationActions));\n\n\t/* Fetch the publication membership info. */\n\tpuboids = GetRelationPublications(RelationGetRelid(relation));\n\tpuboids = list_concat_unique_oid(puboids, GetAllTablesPublications());\n\n\tforeach(lc, puboids)\n\t{\n\t\tOid\t\t\tpubid = lfirst_oid(lc);\n\t\tHeapTuple\ttup;\n\t\tForm_pg_publication pubform;\n\n\t\ttup = SearchSysCache1(PUBLICATIONOID, ObjectIdGetDatum(pubid));\n\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\telog(ERROR, \"cache lookup failed for publication %u\", pubid);\n\n\t\tpubform = (Form_pg_publication) GETSTRUCT(tup);\n\n\t\tpubactions->pubinsert |= pubform->pubinsert;\n\t\tpubactions->pubupdate |= pubform->pubupdate;\n\t\tpubactions->pubdelete |= pubform->pubdelete;\n\t\tpubactions->pubtruncate |= pubform->pubtruncate;\n\n\t\tReleaseSysCache(tup);\n\n\t\t/*\n\t\t * If we know everything is replicated, there is no point to check for\n\t\t * other publications.\n\t\t */\n\t\tif (pubactions->pubinsert && pubactions->pubupdate &&\n\t\t\tpubactions->pubdelete && pubactions->pubtruncate)\n\t\t\tbreak;\n\t}\n\n\tif (relation->rd_pubactions)\n\t{\n\t\tpfree(relation->rd_pubactions);\n\t\trelation->rd_pubactions = NULL;\n\t}\n\n\t/* Now save copy of the actions in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\trelation->rd_pubactions = palloc(sizeof(PublicationActions));\n\tmemcpy(relation->rd_pubactions, pubactions, sizeof(PublicationActions));\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn pubactions;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 5265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "relation->rd_pubactions",
            "pubactions",
            "sizeof(PublicationActions)"
          ],
          "line": 5264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(PublicationActions)"
          ],
          "line": 5263
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 5262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "relation->rd_pubactions"
          ],
          "line": 5257
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tup"
          ],
          "line": 5244
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tup"
          ],
          "line": 5237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for publication %u\"",
            "pubid"
          ],
          "line": 5235
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tup"
          ],
          "line": 5234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "PUBLICATIONOID",
            "ObjectIdGetDatum(pubid)"
          ],
          "line": 5232
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "pubid"
          ],
          "line": 5232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst_oid",
          "args": [
            "lc"
          ],
          "line": 5228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "puboids"
          ],
          "line": 5226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_concat_unique_oid",
          "args": [
            "puboids",
            "GetAllTablesPublications()"
          ],
          "line": 5224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAllTablesPublications",
          "args": [],
          "line": 5224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRelationPublications",
          "args": [
            "RelationGetRelid(relation)"
          ],
          "line": 5223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 5223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pubactions",
            "relation->rd_pubactions",
            "sizeof(PublicationActions)"
          ],
          "line": 5219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_publishable_relation",
          "args": [
            "relation"
          ],
          "line": 5215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstruct PublicationActions *\nGetRelationPublicationActions(Relation relation)\n{\n\tList\t   *puboids;\n\tListCell   *lc;\n\tMemoryContext oldcxt;\n\tPublicationActions *pubactions = palloc0(sizeof(PublicationActions));\n\n\t/*\n\t * If not publishable, it publishes no actions.  (pgoutput_change() will\n\t * ignore it.)\n\t */\n\tif (!is_publishable_relation(relation))\n\t\treturn pubactions;\n\n\tif (relation->rd_pubactions)\n\t\treturn memcpy(pubactions, relation->rd_pubactions,\n\t\t\t\t\t  sizeof(PublicationActions));\n\n\t/* Fetch the publication membership info. */\n\tpuboids = GetRelationPublications(RelationGetRelid(relation));\n\tpuboids = list_concat_unique_oid(puboids, GetAllTablesPublications());\n\n\tforeach(lc, puboids)\n\t{\n\t\tOid\t\t\tpubid = lfirst_oid(lc);\n\t\tHeapTuple\ttup;\n\t\tForm_pg_publication pubform;\n\n\t\ttup = SearchSysCache1(PUBLICATIONOID, ObjectIdGetDatum(pubid));\n\n\t\tif (!HeapTupleIsValid(tup))\n\t\t\telog(ERROR, \"cache lookup failed for publication %u\", pubid);\n\n\t\tpubform = (Form_pg_publication) GETSTRUCT(tup);\n\n\t\tpubactions->pubinsert |= pubform->pubinsert;\n\t\tpubactions->pubupdate |= pubform->pubupdate;\n\t\tpubactions->pubdelete |= pubform->pubdelete;\n\t\tpubactions->pubtruncate |= pubform->pubtruncate;\n\n\t\tReleaseSysCache(tup);\n\n\t\t/*\n\t\t * If we know everything is replicated, there is no point to check for\n\t\t * other publications.\n\t\t */\n\t\tif (pubactions->pubinsert && pubactions->pubupdate &&\n\t\t\tpubactions->pubdelete && pubactions->pubtruncate)\n\t\t\tbreak;\n\t}\n\n\tif (relation->rd_pubactions)\n\t{\n\t\tpfree(relation->rd_pubactions);\n\t\trelation->rd_pubactions = NULL;\n\t}\n\n\t/* Now save copy of the actions in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\trelation->rd_pubactions = palloc(sizeof(PublicationActions));\n\tmemcpy(relation->rd_pubactions, pubactions, sizeof(PublicationActions));\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn pubactions;\n}"
  },
  {
    "function_name": "RelationGetExclusionInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "5079-5198",
    "snippet": "void\nRelationGetExclusionInfo(Relation indexRelation,\n\t\t\t\t\t\t Oid **operators,\n\t\t\t\t\t\t Oid **procs,\n\t\t\t\t\t\t uint16 **strategies)\n{\n\tint\t\t\tindnkeyatts;\n\tOid\t\t   *ops;\n\tOid\t\t   *funcs;\n\tuint16\t   *strats;\n\tRelation\tconrel;\n\tSysScanDesc conscan;\n\tScanKeyData skey[1];\n\tHeapTuple\thtup;\n\tbool\t\tfound;\n\tMemoryContext oldcxt;\n\tint\t\t\ti;\n\n\tindnkeyatts = IndexRelationGetNumberOfKeyAttributes(indexRelation);\n\n\t/* Allocate result space in caller context */\n\t*operators = ops = (Oid *) palloc(sizeof(Oid) * indnkeyatts);\n\t*procs = funcs = (Oid *) palloc(sizeof(Oid) * indnkeyatts);\n\t*strategies = strats = (uint16 *) palloc(sizeof(uint16) * indnkeyatts);\n\n\t/* Quick exit if we have the data cached already */\n\tif (indexRelation->rd_exclstrats != NULL)\n\t{\n\t\tmemcpy(ops, indexRelation->rd_exclops, sizeof(Oid) * indnkeyatts);\n\t\tmemcpy(funcs, indexRelation->rd_exclprocs, sizeof(Oid) * indnkeyatts);\n\t\tmemcpy(strats, indexRelation->rd_exclstrats, sizeof(uint16) * indnkeyatts);\n\t\treturn;\n\t}\n\n\t/*\n\t * Search pg_constraint for the constraint associated with the index. To\n\t * make this not too painfully slow, we use the index on conrelid; that\n\t * will hold the parent relation's OID not the index's own OID.\n\t *\n\t * Note: if we wanted to rely on the constraint name matching the index's\n\t * name, we could just do a direct lookup using pg_constraint's unique\n\t * index.  For the moment it doesn't seem worth requiring that.\n\t */\n\tScanKeyInit(&skey[0],\n\t\t\t\tAnum_pg_constraint_conrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(indexRelation->rd_index->indrelid));\n\n\tconrel = heap_open(ConstraintRelationId, AccessShareLock);\n\tconscan = systable_beginscan(conrel, ConstraintRelidTypidNameIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, skey);\n\tfound = false;\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(conscan)))\n\t{\n\t\tForm_pg_constraint conform = (Form_pg_constraint) GETSTRUCT(htup);\n\t\tDatum\t\tval;\n\t\tbool\t\tisnull;\n\t\tArrayType  *arr;\n\t\tint\t\t\tnelem;\n\n\t\t/* We want the exclusion constraint owning the index */\n\t\tif (conform->contype != CONSTRAINT_EXCLUSION ||\n\t\t\tconform->conindid != RelationGetRelid(indexRelation))\n\t\t\tcontinue;\n\n\t\t/* There should be only one */\n\t\tif (found)\n\t\t\telog(ERROR, \"unexpected exclusion constraint record found for rel %s\",\n\t\t\t\t RelationGetRelationName(indexRelation));\n\t\tfound = true;\n\n\t\t/* Extract the operator OIDS from conexclop */\n\t\tval = fastgetattr(htup,\n\t\t\t\t\t\t  Anum_pg_constraint_conexclop,\n\t\t\t\t\t\t  conrel->rd_att, &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null conexclop for rel %s\",\n\t\t\t\t RelationGetRelationName(indexRelation));\n\n\t\tarr = DatumGetArrayTypeP(val);\t/* ensure not toasted */\n\t\tnelem = ARR_DIMS(arr)[0];\n\t\tif (ARR_NDIM(arr) != 1 ||\n\t\t\tnelem != indnkeyatts ||\n\t\t\tARR_HASNULL(arr) ||\n\t\t\tARR_ELEMTYPE(arr) != OIDOID)\n\t\t\telog(ERROR, \"conexclop is not a 1-D Oid array\");\n\n\t\tmemcpy(ops, ARR_DATA_PTR(arr), sizeof(Oid) * indnkeyatts);\n\t}\n\n\tsystable_endscan(conscan);\n\theap_close(conrel, AccessShareLock);\n\n\tif (!found)\n\t\telog(ERROR, \"exclusion constraint record missing for rel %s\",\n\t\t\t RelationGetRelationName(indexRelation));\n\n\t/* We need the func OIDs and strategy numbers too */\n\tfor (i = 0; i < indnkeyatts; i++)\n\t{\n\t\tfuncs[i] = get_opcode(ops[i]);\n\t\tstrats[i] = get_op_opfamily_strategy(ops[i],\n\t\t\t\t\t\t\t\t\t\t\t indexRelation->rd_opfamily[i]);\n\t\t/* shouldn't fail, since it was checked at index creation */\n\t\tif (strats[i] == InvalidStrategy)\n\t\t\telog(ERROR, \"could not find strategy for operator %u in family %u\",\n\t\t\t\t ops[i], indexRelation->rd_opfamily[i]);\n\t}\n\n\t/* Save a copy of the results in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(indexRelation->rd_indexcxt);\n\tindexRelation->rd_exclops = (Oid *) palloc(sizeof(Oid) * indnkeyatts);\n\tindexRelation->rd_exclprocs = (Oid *) palloc(sizeof(Oid) * indnkeyatts);\n\tindexRelation->rd_exclstrats = (uint16 *) palloc(sizeof(uint16) * indnkeyatts);\n\tmemcpy(indexRelation->rd_exclops, ops, sizeof(Oid) * indnkeyatts);\n\tmemcpy(indexRelation->rd_exclprocs, funcs, sizeof(Oid) * indnkeyatts);\n\tmemcpy(indexRelation->rd_exclstrats, strats, sizeof(uint16) * indnkeyatts);\n\tMemoryContextSwitchTo(oldcxt);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 5197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "indexRelation->rd_exclstrats",
            "strats",
            "sizeof(uint16) * indnkeyatts"
          ],
          "line": 5196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "indexRelation->rd_exclprocs",
            "funcs",
            "sizeof(Oid) * indnkeyatts"
          ],
          "line": 5195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "indexRelation->rd_exclops",
            "ops",
            "sizeof(Oid) * indnkeyatts"
          ],
          "line": 5194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(uint16) * indnkeyatts"
          ],
          "line": 5193
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "indexRelation->rd_indexcxt"
          ],
          "line": 5190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"could not find strategy for operator %u in family %u\"",
            "ops[i]",
            "indexRelation->rd_opfamily[i]"
          ],
          "line": 5185
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_op_opfamily_strategy",
          "args": [
            "ops[i]",
            "indexRelation->rd_opfamily[i]"
          ],
          "line": 5181
        },
        "resolved": true,
        "details": {
          "function_name": "get_op_opfamily_strategy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "79-96",
          "snippet": "int\nget_op_opfamily_strategy(Oid opno, Oid opfamily)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\tint\t\t\tresult;\n\n\ttp = SearchSysCache3(AMOPOPID,\n\t\t\t\t\t\t ObjectIdGetDatum(opno),\n\t\t\t\t\t\t CharGetDatum(AMOP_SEARCH),\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn 0;\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\tresult = amop_tup->amopstrategy;\n\tReleaseSysCache(tp);\n\treturn result;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nint\nget_op_opfamily_strategy(Oid opno, Oid opfamily)\n{\n\tHeapTuple\ttp;\n\tForm_pg_amop amop_tup;\n\tint\t\t\tresult;\n\n\ttp = SearchSysCache3(AMOPOPID,\n\t\t\t\t\t\t ObjectIdGetDatum(opno),\n\t\t\t\t\t\t CharGetDatum(AMOP_SEARCH),\n\t\t\t\t\t\t ObjectIdGetDatum(opfamily));\n\tif (!HeapTupleIsValid(tp))\n\t\treturn 0;\n\tamop_tup = (Form_pg_amop) GETSTRUCT(tp);\n\tresult = amop_tup->amopstrategy;\n\tReleaseSysCache(tp);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_opcode",
          "args": [
            "ops[i]"
          ],
          "line": 5180
        },
        "resolved": true,
        "details": {
          "function_name": "get_opcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1078-1095",
          "snippet": "RegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nRegProcedure\nget_opcode(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tRegProcedure result;\n\n\t\tresult = optup->oprcode;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn (RegProcedure) InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "indexRelation"
          ],
          "line": 5175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "conrel",
            "AccessShareLock"
          ],
          "line": 5171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan",
          "args": [
            "conscan"
          ],
          "line": 5170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ops",
            "ARR_DATA_PTR(arr)",
            "sizeof(Oid) * indnkeyatts"
          ],
          "line": 5167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "arr"
          ],
          "line": 5167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_ELEMTYPE",
          "args": [
            "arr"
          ],
          "line": 5164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_HASNULL",
          "args": [
            "arr"
          ],
          "line": 5163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_NDIM",
          "args": [
            "arr"
          ],
          "line": 5161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "arr"
          ],
          "line": 5160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetArrayTypeP",
          "args": [
            "val"
          ],
          "line": 5159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "indexRelation"
          ],
          "line": 5157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fastgetattr",
          "args": [
            "htup",
            "Anum_pg_constraint_conexclop",
            "conrel->rd_att",
            "&isnull"
          ],
          "line": 5152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "indexRelation"
          ],
          "line": 5148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "indexRelation"
          ],
          "line": 5142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "htup"
          ],
          "line": 5134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "htup = systable_getnext(conscan)"
          ],
          "line": 5132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext",
          "args": [
            "conscan"
          ],
          "line": 5132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_beginscan",
          "args": [
            "conrel",
            "ConstraintRelidTypidNameIndexId",
            "true",
            "NULL",
            "1",
            "skey"
          ],
          "line": 5128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "ConstraintRelationId",
            "AccessShareLock"
          ],
          "line": 5127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyInit",
          "args": [
            "&skey[0]",
            "Anum_pg_constraint_conrelid",
            "BTEqualStrategyNumber",
            "F_OIDEQ",
            "ObjectIdGetDatum(indexRelation->rd_index->indrelid)"
          ],
          "line": 5122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "indexRelation->rd_index->indrelid"
          ],
          "line": 5125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "strats",
            "indexRelation->rd_exclstrats",
            "sizeof(uint16) * indnkeyatts"
          ],
          "line": 5109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "funcs",
            "indexRelation->rd_exclprocs",
            "sizeof(Oid) * indnkeyatts"
          ],
          "line": 5108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ops",
            "indexRelation->rd_exclops",
            "sizeof(Oid) * indnkeyatts"
          ],
          "line": 5107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IndexRelationGetNumberOfKeyAttributes",
          "args": [
            "indexRelation"
          ],
          "line": 5097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationGetExclusionInfo(Relation indexRelation,\n\t\t\t\t\t\t Oid **operators,\n\t\t\t\t\t\t Oid **procs,\n\t\t\t\t\t\t uint16 **strategies)\n{\n\tint\t\t\tindnkeyatts;\n\tOid\t\t   *ops;\n\tOid\t\t   *funcs;\n\tuint16\t   *strats;\n\tRelation\tconrel;\n\tSysScanDesc conscan;\n\tScanKeyData skey[1];\n\tHeapTuple\thtup;\n\tbool\t\tfound;\n\tMemoryContext oldcxt;\n\tint\t\t\ti;\n\n\tindnkeyatts = IndexRelationGetNumberOfKeyAttributes(indexRelation);\n\n\t/* Allocate result space in caller context */\n\t*operators = ops = (Oid *) palloc(sizeof(Oid) * indnkeyatts);\n\t*procs = funcs = (Oid *) palloc(sizeof(Oid) * indnkeyatts);\n\t*strategies = strats = (uint16 *) palloc(sizeof(uint16) * indnkeyatts);\n\n\t/* Quick exit if we have the data cached already */\n\tif (indexRelation->rd_exclstrats != NULL)\n\t{\n\t\tmemcpy(ops, indexRelation->rd_exclops, sizeof(Oid) * indnkeyatts);\n\t\tmemcpy(funcs, indexRelation->rd_exclprocs, sizeof(Oid) * indnkeyatts);\n\t\tmemcpy(strats, indexRelation->rd_exclstrats, sizeof(uint16) * indnkeyatts);\n\t\treturn;\n\t}\n\n\t/*\n\t * Search pg_constraint for the constraint associated with the index. To\n\t * make this not too painfully slow, we use the index on conrelid; that\n\t * will hold the parent relation's OID not the index's own OID.\n\t *\n\t * Note: if we wanted to rely on the constraint name matching the index's\n\t * name, we could just do a direct lookup using pg_constraint's unique\n\t * index.  For the moment it doesn't seem worth requiring that.\n\t */\n\tScanKeyInit(&skey[0],\n\t\t\t\tAnum_pg_constraint_conrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(indexRelation->rd_index->indrelid));\n\n\tconrel = heap_open(ConstraintRelationId, AccessShareLock);\n\tconscan = systable_beginscan(conrel, ConstraintRelidTypidNameIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, skey);\n\tfound = false;\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(conscan)))\n\t{\n\t\tForm_pg_constraint conform = (Form_pg_constraint) GETSTRUCT(htup);\n\t\tDatum\t\tval;\n\t\tbool\t\tisnull;\n\t\tArrayType  *arr;\n\t\tint\t\t\tnelem;\n\n\t\t/* We want the exclusion constraint owning the index */\n\t\tif (conform->contype != CONSTRAINT_EXCLUSION ||\n\t\t\tconform->conindid != RelationGetRelid(indexRelation))\n\t\t\tcontinue;\n\n\t\t/* There should be only one */\n\t\tif (found)\n\t\t\telog(ERROR, \"unexpected exclusion constraint record found for rel %s\",\n\t\t\t\t RelationGetRelationName(indexRelation));\n\t\tfound = true;\n\n\t\t/* Extract the operator OIDS from conexclop */\n\t\tval = fastgetattr(htup,\n\t\t\t\t\t\t  Anum_pg_constraint_conexclop,\n\t\t\t\t\t\t  conrel->rd_att, &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null conexclop for rel %s\",\n\t\t\t\t RelationGetRelationName(indexRelation));\n\n\t\tarr = DatumGetArrayTypeP(val);\t/* ensure not toasted */\n\t\tnelem = ARR_DIMS(arr)[0];\n\t\tif (ARR_NDIM(arr) != 1 ||\n\t\t\tnelem != indnkeyatts ||\n\t\t\tARR_HASNULL(arr) ||\n\t\t\tARR_ELEMTYPE(arr) != OIDOID)\n\t\t\telog(ERROR, \"conexclop is not a 1-D Oid array\");\n\n\t\tmemcpy(ops, ARR_DATA_PTR(arr), sizeof(Oid) * indnkeyatts);\n\t}\n\n\tsystable_endscan(conscan);\n\theap_close(conrel, AccessShareLock);\n\n\tif (!found)\n\t\telog(ERROR, \"exclusion constraint record missing for rel %s\",\n\t\t\t RelationGetRelationName(indexRelation));\n\n\t/* We need the func OIDs and strategy numbers too */\n\tfor (i = 0; i < indnkeyatts; i++)\n\t{\n\t\tfuncs[i] = get_opcode(ops[i]);\n\t\tstrats[i] = get_op_opfamily_strategy(ops[i],\n\t\t\t\t\t\t\t\t\t\t\t indexRelation->rd_opfamily[i]);\n\t\t/* shouldn't fail, since it was checked at index creation */\n\t\tif (strats[i] == InvalidStrategy)\n\t\t\telog(ERROR, \"could not find strategy for operator %u in family %u\",\n\t\t\t\t ops[i], indexRelation->rd_opfamily[i]);\n\t}\n\n\t/* Save a copy of the results in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(indexRelation->rd_indexcxt);\n\tindexRelation->rd_exclops = (Oid *) palloc(sizeof(Oid) * indnkeyatts);\n\tindexRelation->rd_exclprocs = (Oid *) palloc(sizeof(Oid) * indnkeyatts);\n\tindexRelation->rd_exclstrats = (uint16 *) palloc(sizeof(uint16) * indnkeyatts);\n\tmemcpy(indexRelation->rd_exclops, ops, sizeof(Oid) * indnkeyatts);\n\tmemcpy(indexRelation->rd_exclprocs, funcs, sizeof(Oid) * indnkeyatts);\n\tmemcpy(indexRelation->rd_exclstrats, strats, sizeof(uint16) * indnkeyatts);\n\tMemoryContextSwitchTo(oldcxt);\n}"
  },
  {
    "function_name": "RelationGetIndexAttrBitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "4814-5068",
    "snippet": "Bitmapset *\nRelationGetIndexAttrBitmap(Relation relation, IndexAttrBitmapKind attrKind)\n{\n\tBitmapset  *indexattrs;\t\t/* columns used in non-projection indexes */\n\tBitmapset  *projindexattrs; /* columns used in projection indexes */\n\tBitmapset  *uindexattrs;\t/* columns in unique indexes */\n\tBitmapset  *pkindexattrs;\t/* columns in the primary index */\n\tBitmapset  *idindexattrs;\t/* columns in the replica identity */\n\tBitmapset  *projindexes;\t/* projection indexes */\n\tList\t   *indexoidlist;\n\tList\t   *newindexoidlist;\n\tOid\t\t\trelpkindex;\n\tOid\t\t\trelreplindex;\n\tListCell   *l;\n\tMemoryContext oldcxt;\n\tint\t\t\tindexno;\n\n\t/* Quick exit if we already computed the result. */\n\tif (relation->rd_indexattr != NULL)\n\t{\n\t\tswitch (attrKind)\n\t\t{\n\t\t\tcase INDEX_ATTR_BITMAP_HOT:\n\t\t\t\treturn bms_copy(relation->rd_indexattr);\n\t\t\tcase INDEX_ATTR_BITMAP_PROJ:\n\t\t\t\treturn bms_copy(relation->rd_projindexattr);\n\t\t\tcase INDEX_ATTR_BITMAP_KEY:\n\t\t\t\treturn bms_copy(relation->rd_keyattr);\n\t\t\tcase INDEX_ATTR_BITMAP_PRIMARY_KEY:\n\t\t\t\treturn bms_copy(relation->rd_pkattr);\n\t\t\tcase INDEX_ATTR_BITMAP_IDENTITY_KEY:\n\t\t\t\treturn bms_copy(relation->rd_idattr);\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unknown attrKind %u\", attrKind);\n\t\t}\n\t}\n\n\t/* Fast path if definitely no indexes */\n\tif (!RelationGetForm(relation)->relhasindex)\n\t\treturn NULL;\n\n\t/*\n\t * Get cached list of index OIDs. If we have to start over, we do so here.\n\t */\nrestart:\n\tindexoidlist = RelationGetIndexList(relation);\n\n\t/* Fall out if no indexes (but relhasindex was set) */\n\tif (indexoidlist == NIL)\n\t\treturn NULL;\n\n\t/*\n\t * Copy the rd_pkindex and rd_replidindex values computed by\n\t * RelationGetIndexList before proceeding.  This is needed because a\n\t * relcache flush could occur inside index_open below, resetting the\n\t * fields managed by RelationGetIndexList.  We need to do the work with\n\t * stable values of these fields.\n\t */\n\trelpkindex = relation->rd_pkindex;\n\trelreplindex = relation->rd_replidindex;\n\n\t/*\n\t * For each index, add referenced attributes to indexattrs.\n\t *\n\t * Note: we consider all indexes returned by RelationGetIndexList, even if\n\t * they are not indisready or indisvalid.  This is important because an\n\t * index for which CREATE INDEX CONCURRENTLY has just started must be\n\t * included in HOT-safety decisions (see README.HOT).  If a DROP INDEX\n\t * CONCURRENTLY is far enough along that we should ignore the index, it\n\t * won't be returned at all by RelationGetIndexList.\n\t */\n\tindexattrs = NULL;\n\tprojindexattrs = NULL;\n\tuindexattrs = NULL;\n\tpkindexattrs = NULL;\n\tidindexattrs = NULL;\n\tprojindexes = NULL;\n\tindexno = 0;\n\tforeach(l, indexoidlist)\n\t{\n\t\tOid\t\t\tindexOid = lfirst_oid(l);\n\t\tRelation\tindexDesc;\n\t\tDatum\t\tdatum;\n\t\tbool\t\tisnull;\n\t\tNode\t   *indexExpressions;\n\t\tNode\t   *indexPredicate;\n\t\tint\t\t\ti;\n\t\tbool\t\tisKey;\t\t/* candidate key */\n\t\tbool\t\tisPK;\t\t/* primary key */\n\t\tbool\t\tisIDKey;\t/* replica identity index */\n\n\t\tindexDesc = index_open(indexOid, AccessShareLock);\n\n\t\t/*\n\t\t * Extract index expressions and index predicate.  Note: Don't use\n\t\t * RelationGetIndexExpressions()/RelationGetIndexPredicate(), because\n\t\t * those might run constant expressions evaluation, which needs a\n\t\t * snapshot, which we might not have here.  (Also, it's probably more\n\t\t * sound to collect the bitmaps before any transformations that might\n\t\t * eliminate columns, but the practical impact of this is limited.)\n\t\t */\n\n\t\tdatum = heap_getattr(indexDesc->rd_indextuple, Anum_pg_index_indexprs,\n\t\t\t\t\t\t\t GetPgIndexDescriptor(), &isnull);\n\t\tif (!isnull)\n\t\t\tindexExpressions = stringToNode(TextDatumGetCString(datum));\n\t\telse\n\t\t\tindexExpressions = NULL;\n\n\t\tdatum = heap_getattr(indexDesc->rd_indextuple, Anum_pg_index_indpred,\n\t\t\t\t\t\t\t GetPgIndexDescriptor(), &isnull);\n\t\tif (!isnull)\n\t\t\tindexPredicate = stringToNode(TextDatumGetCString(datum));\n\t\telse\n\t\t\tindexPredicate = NULL;\n\n\t\t/* Can this index be referenced by a foreign key? */\n\t\tisKey = indexDesc->rd_index->indisunique &&\n\t\t\tindexExpressions == NULL &&\n\t\t\tindexPredicate == NULL;\n\n\t\t/* Is this a primary key? */\n\t\tisPK = (indexOid == relpkindex);\n\n\t\t/* Is this index the configured (or default) replica identity? */\n\t\tisIDKey = (indexOid == relreplindex);\n\n\t\t/* Collect simple attribute references */\n\t\tfor (i = 0; i < indexDesc->rd_index->indnatts; i++)\n\t\t{\n\t\t\tint\t\t\tattrnum = indexDesc->rd_index->indkey.values[i];\n\n\t\t\t/*\n\t\t\t * Since we have covering indexes with non-key columns, we must\n\t\t\t * handle them accurately here. non-key columns must be added into\n\t\t\t * indexattrs, since they are in index, and HOT-update shouldn't\n\t\t\t * miss them. Obviously, non-key columns couldn't be referenced by\n\t\t\t * foreign key or identity key. Hence we do not include them into\n\t\t\t * uindexattrs, pkindexattrs and idindexattrs bitmaps.\n\t\t\t */\n\t\t\tif (attrnum != 0)\n\t\t\t{\n\t\t\t\tindexattrs = bms_add_member(indexattrs,\n\t\t\t\t\t\t\t\t\t\t\tattrnum - FirstLowInvalidHeapAttributeNumber);\n\n\t\t\t\tif (isKey && i < indexDesc->rd_index->indnkeyatts)\n\t\t\t\t\tuindexattrs = bms_add_member(uindexattrs,\n\t\t\t\t\t\t\t\t\t\t\t\t attrnum - FirstLowInvalidHeapAttributeNumber);\n\n\t\t\t\tif (isPK && i < indexDesc->rd_index->indnkeyatts)\n\t\t\t\t\tpkindexattrs = bms_add_member(pkindexattrs,\n\t\t\t\t\t\t\t\t\t\t\t\t  attrnum - FirstLowInvalidHeapAttributeNumber);\n\n\t\t\t\tif (isIDKey && i < indexDesc->rd_index->indnkeyatts)\n\t\t\t\t\tidindexattrs = bms_add_member(idindexattrs,\n\t\t\t\t\t\t\t\t\t\t\t\t  attrnum - FirstLowInvalidHeapAttributeNumber);\n\t\t\t}\n\t\t}\n\n\t\t/* Collect attributes used in expressions, too */\n\t\tif (IsProjectionFunctionalIndex(indexDesc))\n\t\t{\n\t\t\tprojindexes = bms_add_member(projindexes, indexno);\n\t\t\tpull_varattnos(indexExpressions, 1, &projindexattrs);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Collect all attributes used in expressions, too */\n\t\t\tpull_varattnos(indexExpressions, 1, &indexattrs);\n\t\t}\n\t\t/* Collect all attributes in the index predicate, too */\n\t\tpull_varattnos(indexPredicate, 1, &indexattrs);\n\n\t\tindex_close(indexDesc, AccessShareLock);\n\t\tindexno += 1;\n\t}\n\n\t/*\n\t * During one of the index_opens in the above loop, we might have received\n\t * a relcache flush event on this relcache entry, which might have been\n\t * signaling a change in the rel's index list.  If so, we'd better start\n\t * over to ensure we deliver up-to-date attribute bitmaps.\n\t */\n\tnewindexoidlist = RelationGetIndexList(relation);\n\tif (equal(indexoidlist, newindexoidlist) &&\n\t\trelpkindex == relation->rd_pkindex &&\n\t\trelreplindex == relation->rd_replidindex)\n\t{\n\t\t/* Still the same index set, so proceed */\n\t\tlist_free(newindexoidlist);\n\t\tlist_free(indexoidlist);\n\t}\n\telse\n\t{\n\t\t/* Gotta do it over ... might as well not leak memory */\n\t\tlist_free(newindexoidlist);\n\t\tlist_free(indexoidlist);\n\t\tbms_free(uindexattrs);\n\t\tbms_free(pkindexattrs);\n\t\tbms_free(idindexattrs);\n\t\tbms_free(indexattrs);\n\t\tbms_free(projindexattrs);\n\t\tbms_free(projindexes);\n\n\t\tgoto restart;\n\t}\n\n\t/* Don't leak the old values of these bitmaps, if any */\n\tbms_free(relation->rd_indexattr);\n\trelation->rd_indexattr = NULL;\n\tbms_free(relation->rd_projindexattr);\n\trelation->rd_projindexattr = NULL;\n\tbms_free(relation->rd_keyattr);\n\trelation->rd_keyattr = NULL;\n\tbms_free(relation->rd_pkattr);\n\trelation->rd_pkattr = NULL;\n\tbms_free(relation->rd_idattr);\n\trelation->rd_idattr = NULL;\n\tbms_free(relation->rd_projidx);\n\trelation->rd_projidx = NULL;\n\n\t/*\n\t * Now save copies of the bitmaps in the relcache entry.  We intentionally\n\t * set rd_indexattr last, because that's the one that signals validity of\n\t * the values; if we run out of memory before making that copy, we won't\n\t * leave the relcache entry looking like the other ones are valid but\n\t * empty.\n\t */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\trelation->rd_keyattr = bms_copy(uindexattrs);\n\trelation->rd_pkattr = bms_copy(pkindexattrs);\n\trelation->rd_idattr = bms_copy(idindexattrs);\n\trelation->rd_indexattr = bms_copy(indexattrs);\n\trelation->rd_projindexattr = bms_copy(projindexattrs);\n\trelation->rd_projidx = bms_copy(projindexes);\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* We return our original working copy for caller to play with */\n\tswitch (attrKind)\n\t{\n\t\tcase INDEX_ATTR_BITMAP_HOT:\n\t\t\treturn indexattrs;\n\t\tcase INDEX_ATTR_BITMAP_PROJ:\n\t\t\treturn projindexattrs;\n\t\tcase INDEX_ATTR_BITMAP_KEY:\n\t\t\treturn uindexattrs;\n\t\tcase INDEX_ATTR_BITMAP_PRIMARY_KEY:\n\t\t\treturn pkindexattrs;\n\t\tcase INDEX_ATTR_BITMAP_IDENTITY_KEY:\n\t\t\treturn idindexattrs;\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown attrKind %u\", attrKind);\n\t\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static TupleDesc GetPgIndexDescriptor(void);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static List *insert_ordered_oid(List *list, Oid datum);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unknown attrKind %u\"",
            "attrKind"
          ],
          "line": 5065
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 5049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_copy",
          "args": [
            "projindexes"
          ],
          "line": 5048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_copy",
          "args": [
            "projindexattrs"
          ],
          "line": 5047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_copy",
          "args": [
            "indexattrs"
          ],
          "line": 5046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_copy",
          "args": [
            "idindexattrs"
          ],
          "line": 5045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_copy",
          "args": [
            "pkindexattrs"
          ],
          "line": 5044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_copy",
          "args": [
            "uindexattrs"
          ],
          "line": 5043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 5042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "relation->rd_projidx"
          ],
          "line": 5032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "relation->rd_idattr"
          ],
          "line": 5030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "relation->rd_pkattr"
          ],
          "line": 5028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "relation->rd_keyattr"
          ],
          "line": 5026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "relation->rd_projindexattr"
          ],
          "line": 5024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "relation->rd_indexattr"
          ],
          "line": 5022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "projindexes"
          ],
          "line": 5016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "projindexattrs"
          ],
          "line": 5015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "indexattrs"
          ],
          "line": 5014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "idindexattrs"
          ],
          "line": 5013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "pkindexattrs"
          ],
          "line": 5012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "uindexattrs"
          ],
          "line": 5011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_free",
          "args": [
            "indexoidlist"
          ],
          "line": 5010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_free",
          "args": [
            "newindexoidlist"
          ],
          "line": 5009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_free",
          "args": [
            "indexoidlist"
          ],
          "line": 5004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_free",
          "args": [
            "newindexoidlist"
          ],
          "line": 5003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equal",
          "args": [
            "indexoidlist",
            "newindexoidlist"
          ],
          "line": 4998
        },
        "resolved": true,
        "details": {
          "function_name": "equalRSDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "975-1002",
          "snippet": "static bool\nequalRSDesc(RowSecurityDesc *rsdesc1, RowSecurityDesc *rsdesc2)\n{\n\tListCell   *lc,\n\t\t\t   *rc;\n\n\tif (rsdesc1 == NULL && rsdesc2 == NULL)\n\t\treturn true;\n\n\tif ((rsdesc1 != NULL && rsdesc2 == NULL) ||\n\t\t(rsdesc1 == NULL && rsdesc2 != NULL))\n\t\treturn false;\n\n\tif (list_length(rsdesc1->policies) != list_length(rsdesc2->policies))\n\t\treturn false;\n\n\t/* RelationBuildRowSecurity should build policies in order */\n\tforboth(lc, rsdesc1->policies, rc, rsdesc2->policies)\n\t{\n\t\tRowSecurityPolicy *l = (RowSecurityPolicy *) lfirst(lc);\n\t\tRowSecurityPolicy *r = (RowSecurityPolicy *) lfirst(rc);\n\n\t\tif (!equalPolicy(l, r))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic bool\nequalRSDesc(RowSecurityDesc *rsdesc1, RowSecurityDesc *rsdesc2)\n{\n\tListCell   *lc,\n\t\t\t   *rc;\n\n\tif (rsdesc1 == NULL && rsdesc2 == NULL)\n\t\treturn true;\n\n\tif ((rsdesc1 != NULL && rsdesc2 == NULL) ||\n\t\t(rsdesc1 == NULL && rsdesc2 != NULL))\n\t\treturn false;\n\n\tif (list_length(rsdesc1->policies) != list_length(rsdesc2->policies))\n\t\treturn false;\n\n\t/* RelationBuildRowSecurity should build policies in order */\n\tforboth(lc, rsdesc1->policies, rc, rsdesc2->policies)\n\t{\n\t\tRowSecurityPolicy *l = (RowSecurityPolicy *) lfirst(lc);\n\t\tRowSecurityPolicy *r = (RowSecurityPolicy *) lfirst(rc);\n\n\t\tif (!equalPolicy(l, r))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetIndexList",
          "args": [
            "relation"
          ],
          "line": 4997
        },
        "resolved": true,
        "details": {
          "function_name": "RelationGetIndexList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "4242-4359",
          "snippet": "List *\nRelationGetIndexList(Relation relation)\n{\n\tRelation\tindrel;\n\tSysScanDesc indscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tList\t   *result;\n\tList\t   *oldlist;\n\tchar\t\treplident = relation->rd_rel->relreplident;\n\tOid\t\t\toidIndex = InvalidOid;\n\tOid\t\t\tpkeyIndex = InvalidOid;\n\tOid\t\t\tcandidateIndex = InvalidOid;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the list. */\n\tif (relation->rd_indexvalid != 0)\n\t\treturn list_copy(relation->rd_indexlist);\n\n\t/*\n\t * We build the list we intend to return (in the caller's context) while\n\t * doing the scan.  After successfully completing the scan, we copy that\n\t * list into the relcache entry.  This avoids cache-context memory leakage\n\t * if we get some sort of error partway through.\n\t */\n\tresult = NIL;\n\toidIndex = InvalidOid;\n\n\t/* Prepare to scan pg_index for entries having indrelid = this rel. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_index_indrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tindrel = heap_open(IndexRelationId, AccessShareLock);\n\tindscan = systable_beginscan(indrel, IndexIndrelidIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, &skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(indscan)))\n\t{\n\t\tForm_pg_index index = (Form_pg_index) GETSTRUCT(htup);\n\t\tDatum\t\tindclassDatum;\n\t\toidvector  *indclass;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Ignore any indexes that are currently being dropped.  This will\n\t\t * prevent them from being searched, inserted into, or considered in\n\t\t * HOT-safety decisions.  It's unsafe to touch such an index at all\n\t\t * since its catalog entries could disappear at any instant.\n\t\t */\n\t\tif (!IndexIsLive(index))\n\t\t\tcontinue;\n\n\t\t/* Add index's OID to result list in the proper order */\n\t\tresult = insert_ordered_oid(result, index->indexrelid);\n\n\t\t/*\n\t\t * indclass cannot be referenced directly through the C struct,\n\t\t * because it comes after the variable-width indkey field.  Must\n\t\t * extract the datum the hard way...\n\t\t */\n\t\tindclassDatum = heap_getattr(htup,\n\t\t\t\t\t\t\t\t\t Anum_pg_index_indclass,\n\t\t\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t\t &isnull);\n\t\tAssert(!isnull);\n\t\tindclass = (oidvector *) DatumGetPointer(indclassDatum);\n\n\t\t/*\n\t\t * Invalid, non-unique, non-immediate or predicate indexes aren't\n\t\t * interesting for either oid indexes or replication identity indexes,\n\t\t * so don't check them.\n\t\t */\n\t\tif (!IndexIsValid(index) || !index->indisunique ||\n\t\t\t!index->indimmediate ||\n\t\t\t!heap_attisnull(htup, Anum_pg_index_indpred, NULL))\n\t\t\tcontinue;\n\n\t\t/* Check to see if is a usable btree index on OID */\n\t\tif (index->indnatts == 1 &&\n\t\t\tindex->indkey.values[0] == ObjectIdAttributeNumber &&\n\t\t\tindclass->values[0] == OID_BTREE_OPS_OID)\n\t\t\toidIndex = index->indexrelid;\n\n\t\t/* remember primary key index if any */\n\t\tif (index->indisprimary)\n\t\t\tpkeyIndex = index->indexrelid;\n\n\t\t/* remember explicitly chosen replica index */\n\t\tif (index->indisreplident)\n\t\t\tcandidateIndex = index->indexrelid;\n\t}\n\n\tsystable_endscan(indscan);\n\n\theap_close(indrel, AccessShareLock);\n\n\t/* Now save a copy of the completed list in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\toldlist = relation->rd_indexlist;\n\trelation->rd_indexlist = list_copy(result);\n\trelation->rd_oidindex = oidIndex;\n\trelation->rd_pkindex = pkeyIndex;\n\tif (replident == REPLICA_IDENTITY_DEFAULT && OidIsValid(pkeyIndex))\n\t\trelation->rd_replidindex = pkeyIndex;\n\telse if (replident == REPLICA_IDENTITY_INDEX && OidIsValid(candidateIndex))\n\t\trelation->rd_replidindex = candidateIndex;\n\telse\n\t\trelation->rd_replidindex = InvalidOid;\n\trelation->rd_indexvalid = 1;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Don't leak the old list, if there is one */\n\tlist_free(oldlist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static TupleDesc GetPgIndexDescriptor(void);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static List *insert_ordered_oid(List *list, Oid datum);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic TupleDesc GetPgIndexDescriptor(void);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic List *insert_ordered_oid(List *list, Oid datum);\nstatic void InitIndexAmRoutine(Relation relation);\n\nList *\nRelationGetIndexList(Relation relation)\n{\n\tRelation\tindrel;\n\tSysScanDesc indscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tList\t   *result;\n\tList\t   *oldlist;\n\tchar\t\treplident = relation->rd_rel->relreplident;\n\tOid\t\t\toidIndex = InvalidOid;\n\tOid\t\t\tpkeyIndex = InvalidOid;\n\tOid\t\t\tcandidateIndex = InvalidOid;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the list. */\n\tif (relation->rd_indexvalid != 0)\n\t\treturn list_copy(relation->rd_indexlist);\n\n\t/*\n\t * We build the list we intend to return (in the caller's context) while\n\t * doing the scan.  After successfully completing the scan, we copy that\n\t * list into the relcache entry.  This avoids cache-context memory leakage\n\t * if we get some sort of error partway through.\n\t */\n\tresult = NIL;\n\toidIndex = InvalidOid;\n\n\t/* Prepare to scan pg_index for entries having indrelid = this rel. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_index_indrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tindrel = heap_open(IndexRelationId, AccessShareLock);\n\tindscan = systable_beginscan(indrel, IndexIndrelidIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, &skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(indscan)))\n\t{\n\t\tForm_pg_index index = (Form_pg_index) GETSTRUCT(htup);\n\t\tDatum\t\tindclassDatum;\n\t\toidvector  *indclass;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Ignore any indexes that are currently being dropped.  This will\n\t\t * prevent them from being searched, inserted into, or considered in\n\t\t * HOT-safety decisions.  It's unsafe to touch such an index at all\n\t\t * since its catalog entries could disappear at any instant.\n\t\t */\n\t\tif (!IndexIsLive(index))\n\t\t\tcontinue;\n\n\t\t/* Add index's OID to result list in the proper order */\n\t\tresult = insert_ordered_oid(result, index->indexrelid);\n\n\t\t/*\n\t\t * indclass cannot be referenced directly through the C struct,\n\t\t * because it comes after the variable-width indkey field.  Must\n\t\t * extract the datum the hard way...\n\t\t */\n\t\tindclassDatum = heap_getattr(htup,\n\t\t\t\t\t\t\t\t\t Anum_pg_index_indclass,\n\t\t\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t\t &isnull);\n\t\tAssert(!isnull);\n\t\tindclass = (oidvector *) DatumGetPointer(indclassDatum);\n\n\t\t/*\n\t\t * Invalid, non-unique, non-immediate or predicate indexes aren't\n\t\t * interesting for either oid indexes or replication identity indexes,\n\t\t * so don't check them.\n\t\t */\n\t\tif (!IndexIsValid(index) || !index->indisunique ||\n\t\t\t!index->indimmediate ||\n\t\t\t!heap_attisnull(htup, Anum_pg_index_indpred, NULL))\n\t\t\tcontinue;\n\n\t\t/* Check to see if is a usable btree index on OID */\n\t\tif (index->indnatts == 1 &&\n\t\t\tindex->indkey.values[0] == ObjectIdAttributeNumber &&\n\t\t\tindclass->values[0] == OID_BTREE_OPS_OID)\n\t\t\toidIndex = index->indexrelid;\n\n\t\t/* remember primary key index if any */\n\t\tif (index->indisprimary)\n\t\t\tpkeyIndex = index->indexrelid;\n\n\t\t/* remember explicitly chosen replica index */\n\t\tif (index->indisreplident)\n\t\t\tcandidateIndex = index->indexrelid;\n\t}\n\n\tsystable_endscan(indscan);\n\n\theap_close(indrel, AccessShareLock);\n\n\t/* Now save a copy of the completed list in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\toldlist = relation->rd_indexlist;\n\trelation->rd_indexlist = list_copy(result);\n\trelation->rd_oidindex = oidIndex;\n\trelation->rd_pkindex = pkeyIndex;\n\tif (replident == REPLICA_IDENTITY_DEFAULT && OidIsValid(pkeyIndex))\n\t\trelation->rd_replidindex = pkeyIndex;\n\telse if (replident == REPLICA_IDENTITY_INDEX && OidIsValid(candidateIndex))\n\t\trelation->rd_replidindex = candidateIndex;\n\telse\n\t\trelation->rd_replidindex = InvalidOid;\n\trelation->rd_indexvalid = 1;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Don't leak the old list, if there is one */\n\tlist_free(oldlist);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_close",
          "args": [
            "indexDesc",
            "AccessShareLock"
          ],
          "line": 4987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pull_varattnos",
          "args": [
            "indexPredicate",
            "1",
            "&indexattrs"
          ],
          "line": 4985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pull_varattnos",
          "args": [
            "indexExpressions",
            "1",
            "&indexattrs"
          ],
          "line": 4982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pull_varattnos",
          "args": [
            "indexExpressions",
            "1",
            "&projindexattrs"
          ],
          "line": 4977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_add_member",
          "args": [
            "projindexes",
            "indexno"
          ],
          "line": 4976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsProjectionFunctionalIndex",
          "args": [
            "indexDesc"
          ],
          "line": 4974
        },
        "resolved": true,
        "details": {
          "function_name": "IsProjectionFunctionalIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "4734-4788",
          "snippet": "static bool\nIsProjectionFunctionalIndex(Relation index)\n{\n\tbool\t\tis_projection = false;\n\n#ifdef NOT_USED\n\tif (RelationGetIndexExpressions(index))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tDatum\t\treloptions;\n\t\tbool\t\tisnull;\n\t\tQualCost\tindex_expr_cost;\n\n\t\t/* by default functional index is considered as non-injective */\n\t\tis_projection = true;\n\n\t\tcost_qual_eval(&index_expr_cost, RelationGetIndexExpressions(index), NULL);\n\n\t\t/*\n\t\t * If index expression is too expensive, then disable projection\n\t\t * optimization, because extra evaluation of index expression is\n\t\t * expected to be more expensive than index update.  Currently the\n\t\t * projection optimization has to calculate index expression twice\n\t\t * when the value of index expression has not changed and three times\n\t\t * when values differ because the expression is recalculated when\n\t\t * inserting a new index entry for the changed value.\n\t\t */\n\t\tif ((index_expr_cost.startup + index_expr_cost.per_tuple) >\n\t\t\tHEURISTIC_MAX_HOT_RECHECK_EXPR_COST)\n\t\t\tis_projection = false;\n\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(RelationGetRelid(index)));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", RelationGetRelid(index));\n\n\t\treloptions = SysCacheGetAttr(RELOID, tuple,\n\t\t\t\t\t\t\t\t\t Anum_pg_class_reloptions, &isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\tGenericIndexOpts *idxopts;\n\n\t\t\tidxopts = (GenericIndexOpts *) index_generic_reloptions(reloptions, false);\n\n\t\t\tif (idxopts != NULL)\n\t\t\t{\n\t\t\t\tis_projection = idxopts->recheck_on_update;\n\t\t\t\tpfree(idxopts);\n\t\t\t}\n\t\t}\n\t\tReleaseSysCache(tuple);\n\t}\n#endif\n\n\treturn is_projection;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define HEURISTIC_MAX_HOT_RECHECK_EXPR_COST 1000"
          ],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\n#define HEURISTIC_MAX_HOT_RECHECK_EXPR_COST 1000\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic bool\nIsProjectionFunctionalIndex(Relation index)\n{\n\tbool\t\tis_projection = false;\n\n#ifdef NOT_USED\n\tif (RelationGetIndexExpressions(index))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tDatum\t\treloptions;\n\t\tbool\t\tisnull;\n\t\tQualCost\tindex_expr_cost;\n\n\t\t/* by default functional index is considered as non-injective */\n\t\tis_projection = true;\n\n\t\tcost_qual_eval(&index_expr_cost, RelationGetIndexExpressions(index), NULL);\n\n\t\t/*\n\t\t * If index expression is too expensive, then disable projection\n\t\t * optimization, because extra evaluation of index expression is\n\t\t * expected to be more expensive than index update.  Currently the\n\t\t * projection optimization has to calculate index expression twice\n\t\t * when the value of index expression has not changed and three times\n\t\t * when values differ because the expression is recalculated when\n\t\t * inserting a new index entry for the changed value.\n\t\t */\n\t\tif ((index_expr_cost.startup + index_expr_cost.per_tuple) >\n\t\t\tHEURISTIC_MAX_HOT_RECHECK_EXPR_COST)\n\t\t\tis_projection = false;\n\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(RelationGetRelid(index)));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", RelationGetRelid(index));\n\n\t\treloptions = SysCacheGetAttr(RELOID, tuple,\n\t\t\t\t\t\t\t\t\t Anum_pg_class_reloptions, &isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\tGenericIndexOpts *idxopts;\n\n\t\t\tidxopts = (GenericIndexOpts *) index_generic_reloptions(reloptions, false);\n\n\t\t\tif (idxopts != NULL)\n\t\t\t{\n\t\t\t\tis_projection = idxopts->recheck_on_update;\n\t\t\t\tpfree(idxopts);\n\t\t\t}\n\t\t}\n\t\tReleaseSysCache(tuple);\n\t}\n#endif\n\n\treturn is_projection;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bms_add_member",
          "args": [
            "idindexattrs",
            "attrnum - FirstLowInvalidHeapAttributeNumber"
          ],
          "line": 4968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_add_member",
          "args": [
            "pkindexattrs",
            "attrnum - FirstLowInvalidHeapAttributeNumber"
          ],
          "line": 4964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_add_member",
          "args": [
            "uindexattrs",
            "attrnum - FirstLowInvalidHeapAttributeNumber"
          ],
          "line": 4960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_add_member",
          "args": [
            "indexattrs",
            "attrnum - FirstLowInvalidHeapAttributeNumber"
          ],
          "line": 4956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringToNode",
          "args": [
            "TextDatumGetCString(datum)"
          ],
          "line": 4926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "datum"
          ],
          "line": 4926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "indexDesc->rd_indextuple",
            "Anum_pg_index_indpred",
            "GetPgIndexDescriptor()",
            "&isnull"
          ],
          "line": 4923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetPgIndexDescriptor",
          "args": [],
          "line": 4924
        },
        "resolved": true,
        "details": {
          "function_name": "GetPgIndexDescriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "3947-3959",
          "snippet": "static TupleDesc\nGetPgIndexDescriptor(void)\n{\n\tstatic TupleDesc pgindexdesc = NULL;\n\n\t/* Already done? */\n\tif (pgindexdesc == NULL)\n\t\tpgindexdesc = BuildHardcodedDescriptor(Natts_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   Desc_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   false);\n\n\treturn pgindexdesc;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const FormData_pg_attribute Desc_pg_index[Natts_pg_index] = {Schema_pg_index};",
            "static TupleDesc GetPgIndexDescriptor(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic const FormData_pg_attribute Desc_pg_index[Natts_pg_index] = {Schema_pg_index};\nstatic TupleDesc GetPgIndexDescriptor(void);\n\nstatic TupleDesc\nGetPgIndexDescriptor(void)\n{\n\tstatic TupleDesc pgindexdesc = NULL;\n\n\t/* Already done? */\n\tif (pgindexdesc == NULL)\n\t\tpgindexdesc = BuildHardcodedDescriptor(Natts_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   Desc_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   false);\n\n\treturn pgindexdesc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stringToNode",
          "args": [
            "TextDatumGetCString(datum)"
          ],
          "line": 4919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "datum"
          ],
          "line": 4919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "indexDesc->rd_indextuple",
            "Anum_pg_index_indexprs",
            "GetPgIndexDescriptor()",
            "&isnull"
          ],
          "line": 4916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_open",
          "args": [
            "indexOid",
            "AccessShareLock"
          ],
          "line": 4905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst_oid",
          "args": [
            "l"
          ],
          "line": 4894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "l",
            "indexoidlist"
          ],
          "line": 4892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetForm",
          "args": [
            "relation"
          ],
          "line": 4852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_copy",
          "args": [
            "relation->rd_idattr"
          ],
          "line": 4845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_copy",
          "args": [
            "relation->rd_pkattr"
          ],
          "line": 4843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_copy",
          "args": [
            "relation->rd_keyattr"
          ],
          "line": 4841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_copy",
          "args": [
            "relation->rd_projindexattr"
          ],
          "line": 4839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_copy",
          "args": [
            "relation->rd_indexattr"
          ],
          "line": 4837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic TupleDesc GetPgIndexDescriptor(void);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic List *insert_ordered_oid(List *list, Oid datum);\nstatic void InitIndexAmRoutine(Relation relation);\n\nBitmapset *\nRelationGetIndexAttrBitmap(Relation relation, IndexAttrBitmapKind attrKind)\n{\n\tBitmapset  *indexattrs;\t\t/* columns used in non-projection indexes */\n\tBitmapset  *projindexattrs; /* columns used in projection indexes */\n\tBitmapset  *uindexattrs;\t/* columns in unique indexes */\n\tBitmapset  *pkindexattrs;\t/* columns in the primary index */\n\tBitmapset  *idindexattrs;\t/* columns in the replica identity */\n\tBitmapset  *projindexes;\t/* projection indexes */\n\tList\t   *indexoidlist;\n\tList\t   *newindexoidlist;\n\tOid\t\t\trelpkindex;\n\tOid\t\t\trelreplindex;\n\tListCell   *l;\n\tMemoryContext oldcxt;\n\tint\t\t\tindexno;\n\n\t/* Quick exit if we already computed the result. */\n\tif (relation->rd_indexattr != NULL)\n\t{\n\t\tswitch (attrKind)\n\t\t{\n\t\t\tcase INDEX_ATTR_BITMAP_HOT:\n\t\t\t\treturn bms_copy(relation->rd_indexattr);\n\t\t\tcase INDEX_ATTR_BITMAP_PROJ:\n\t\t\t\treturn bms_copy(relation->rd_projindexattr);\n\t\t\tcase INDEX_ATTR_BITMAP_KEY:\n\t\t\t\treturn bms_copy(relation->rd_keyattr);\n\t\t\tcase INDEX_ATTR_BITMAP_PRIMARY_KEY:\n\t\t\t\treturn bms_copy(relation->rd_pkattr);\n\t\t\tcase INDEX_ATTR_BITMAP_IDENTITY_KEY:\n\t\t\t\treturn bms_copy(relation->rd_idattr);\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unknown attrKind %u\", attrKind);\n\t\t}\n\t}\n\n\t/* Fast path if definitely no indexes */\n\tif (!RelationGetForm(relation)->relhasindex)\n\t\treturn NULL;\n\n\t/*\n\t * Get cached list of index OIDs. If we have to start over, we do so here.\n\t */\nrestart:\n\tindexoidlist = RelationGetIndexList(relation);\n\n\t/* Fall out if no indexes (but relhasindex was set) */\n\tif (indexoidlist == NIL)\n\t\treturn NULL;\n\n\t/*\n\t * Copy the rd_pkindex and rd_replidindex values computed by\n\t * RelationGetIndexList before proceeding.  This is needed because a\n\t * relcache flush could occur inside index_open below, resetting the\n\t * fields managed by RelationGetIndexList.  We need to do the work with\n\t * stable values of these fields.\n\t */\n\trelpkindex = relation->rd_pkindex;\n\trelreplindex = relation->rd_replidindex;\n\n\t/*\n\t * For each index, add referenced attributes to indexattrs.\n\t *\n\t * Note: we consider all indexes returned by RelationGetIndexList, even if\n\t * they are not indisready or indisvalid.  This is important because an\n\t * index for which CREATE INDEX CONCURRENTLY has just started must be\n\t * included in HOT-safety decisions (see README.HOT).  If a DROP INDEX\n\t * CONCURRENTLY is far enough along that we should ignore the index, it\n\t * won't be returned at all by RelationGetIndexList.\n\t */\n\tindexattrs = NULL;\n\tprojindexattrs = NULL;\n\tuindexattrs = NULL;\n\tpkindexattrs = NULL;\n\tidindexattrs = NULL;\n\tprojindexes = NULL;\n\tindexno = 0;\n\tforeach(l, indexoidlist)\n\t{\n\t\tOid\t\t\tindexOid = lfirst_oid(l);\n\t\tRelation\tindexDesc;\n\t\tDatum\t\tdatum;\n\t\tbool\t\tisnull;\n\t\tNode\t   *indexExpressions;\n\t\tNode\t   *indexPredicate;\n\t\tint\t\t\ti;\n\t\tbool\t\tisKey;\t\t/* candidate key */\n\t\tbool\t\tisPK;\t\t/* primary key */\n\t\tbool\t\tisIDKey;\t/* replica identity index */\n\n\t\tindexDesc = index_open(indexOid, AccessShareLock);\n\n\t\t/*\n\t\t * Extract index expressions and index predicate.  Note: Don't use\n\t\t * RelationGetIndexExpressions()/RelationGetIndexPredicate(), because\n\t\t * those might run constant expressions evaluation, which needs a\n\t\t * snapshot, which we might not have here.  (Also, it's probably more\n\t\t * sound to collect the bitmaps before any transformations that might\n\t\t * eliminate columns, but the practical impact of this is limited.)\n\t\t */\n\n\t\tdatum = heap_getattr(indexDesc->rd_indextuple, Anum_pg_index_indexprs,\n\t\t\t\t\t\t\t GetPgIndexDescriptor(), &isnull);\n\t\tif (!isnull)\n\t\t\tindexExpressions = stringToNode(TextDatumGetCString(datum));\n\t\telse\n\t\t\tindexExpressions = NULL;\n\n\t\tdatum = heap_getattr(indexDesc->rd_indextuple, Anum_pg_index_indpred,\n\t\t\t\t\t\t\t GetPgIndexDescriptor(), &isnull);\n\t\tif (!isnull)\n\t\t\tindexPredicate = stringToNode(TextDatumGetCString(datum));\n\t\telse\n\t\t\tindexPredicate = NULL;\n\n\t\t/* Can this index be referenced by a foreign key? */\n\t\tisKey = indexDesc->rd_index->indisunique &&\n\t\t\tindexExpressions == NULL &&\n\t\t\tindexPredicate == NULL;\n\n\t\t/* Is this a primary key? */\n\t\tisPK = (indexOid == relpkindex);\n\n\t\t/* Is this index the configured (or default) replica identity? */\n\t\tisIDKey = (indexOid == relreplindex);\n\n\t\t/* Collect simple attribute references */\n\t\tfor (i = 0; i < indexDesc->rd_index->indnatts; i++)\n\t\t{\n\t\t\tint\t\t\tattrnum = indexDesc->rd_index->indkey.values[i];\n\n\t\t\t/*\n\t\t\t * Since we have covering indexes with non-key columns, we must\n\t\t\t * handle them accurately here. non-key columns must be added into\n\t\t\t * indexattrs, since they are in index, and HOT-update shouldn't\n\t\t\t * miss them. Obviously, non-key columns couldn't be referenced by\n\t\t\t * foreign key or identity key. Hence we do not include them into\n\t\t\t * uindexattrs, pkindexattrs and idindexattrs bitmaps.\n\t\t\t */\n\t\t\tif (attrnum != 0)\n\t\t\t{\n\t\t\t\tindexattrs = bms_add_member(indexattrs,\n\t\t\t\t\t\t\t\t\t\t\tattrnum - FirstLowInvalidHeapAttributeNumber);\n\n\t\t\t\tif (isKey && i < indexDesc->rd_index->indnkeyatts)\n\t\t\t\t\tuindexattrs = bms_add_member(uindexattrs,\n\t\t\t\t\t\t\t\t\t\t\t\t attrnum - FirstLowInvalidHeapAttributeNumber);\n\n\t\t\t\tif (isPK && i < indexDesc->rd_index->indnkeyatts)\n\t\t\t\t\tpkindexattrs = bms_add_member(pkindexattrs,\n\t\t\t\t\t\t\t\t\t\t\t\t  attrnum - FirstLowInvalidHeapAttributeNumber);\n\n\t\t\t\tif (isIDKey && i < indexDesc->rd_index->indnkeyatts)\n\t\t\t\t\tidindexattrs = bms_add_member(idindexattrs,\n\t\t\t\t\t\t\t\t\t\t\t\t  attrnum - FirstLowInvalidHeapAttributeNumber);\n\t\t\t}\n\t\t}\n\n\t\t/* Collect attributes used in expressions, too */\n\t\tif (IsProjectionFunctionalIndex(indexDesc))\n\t\t{\n\t\t\tprojindexes = bms_add_member(projindexes, indexno);\n\t\t\tpull_varattnos(indexExpressions, 1, &projindexattrs);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Collect all attributes used in expressions, too */\n\t\t\tpull_varattnos(indexExpressions, 1, &indexattrs);\n\t\t}\n\t\t/* Collect all attributes in the index predicate, too */\n\t\tpull_varattnos(indexPredicate, 1, &indexattrs);\n\n\t\tindex_close(indexDesc, AccessShareLock);\n\t\tindexno += 1;\n\t}\n\n\t/*\n\t * During one of the index_opens in the above loop, we might have received\n\t * a relcache flush event on this relcache entry, which might have been\n\t * signaling a change in the rel's index list.  If so, we'd better start\n\t * over to ensure we deliver up-to-date attribute bitmaps.\n\t */\n\tnewindexoidlist = RelationGetIndexList(relation);\n\tif (equal(indexoidlist, newindexoidlist) &&\n\t\trelpkindex == relation->rd_pkindex &&\n\t\trelreplindex == relation->rd_replidindex)\n\t{\n\t\t/* Still the same index set, so proceed */\n\t\tlist_free(newindexoidlist);\n\t\tlist_free(indexoidlist);\n\t}\n\telse\n\t{\n\t\t/* Gotta do it over ... might as well not leak memory */\n\t\tlist_free(newindexoidlist);\n\t\tlist_free(indexoidlist);\n\t\tbms_free(uindexattrs);\n\t\tbms_free(pkindexattrs);\n\t\tbms_free(idindexattrs);\n\t\tbms_free(indexattrs);\n\t\tbms_free(projindexattrs);\n\t\tbms_free(projindexes);\n\n\t\tgoto restart;\n\t}\n\n\t/* Don't leak the old values of these bitmaps, if any */\n\tbms_free(relation->rd_indexattr);\n\trelation->rd_indexattr = NULL;\n\tbms_free(relation->rd_projindexattr);\n\trelation->rd_projindexattr = NULL;\n\tbms_free(relation->rd_keyattr);\n\trelation->rd_keyattr = NULL;\n\tbms_free(relation->rd_pkattr);\n\trelation->rd_pkattr = NULL;\n\tbms_free(relation->rd_idattr);\n\trelation->rd_idattr = NULL;\n\tbms_free(relation->rd_projidx);\n\trelation->rd_projidx = NULL;\n\n\t/*\n\t * Now save copies of the bitmaps in the relcache entry.  We intentionally\n\t * set rd_indexattr last, because that's the one that signals validity of\n\t * the values; if we run out of memory before making that copy, we won't\n\t * leave the relcache entry looking like the other ones are valid but\n\t * empty.\n\t */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\trelation->rd_keyattr = bms_copy(uindexattrs);\n\trelation->rd_pkattr = bms_copy(pkindexattrs);\n\trelation->rd_idattr = bms_copy(idindexattrs);\n\trelation->rd_indexattr = bms_copy(indexattrs);\n\trelation->rd_projindexattr = bms_copy(projindexattrs);\n\trelation->rd_projidx = bms_copy(projindexes);\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* We return our original working copy for caller to play with */\n\tswitch (attrKind)\n\t{\n\t\tcase INDEX_ATTR_BITMAP_HOT:\n\t\t\treturn indexattrs;\n\t\tcase INDEX_ATTR_BITMAP_PROJ:\n\t\t\treturn projindexattrs;\n\t\tcase INDEX_ATTR_BITMAP_KEY:\n\t\t\treturn uindexattrs;\n\t\tcase INDEX_ATTR_BITMAP_PRIMARY_KEY:\n\t\t\treturn pkindexattrs;\n\t\tcase INDEX_ATTR_BITMAP_IDENTITY_KEY:\n\t\t\treturn idindexattrs;\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown attrKind %u\", attrKind);\n\t\t\treturn NULL;\n\t}\n}"
  },
  {
    "function_name": "IsProjectionFunctionalIndex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "4734-4788",
    "snippet": "static bool\nIsProjectionFunctionalIndex(Relation index)\n{\n\tbool\t\tis_projection = false;\n\n#ifdef NOT_USED\n\tif (RelationGetIndexExpressions(index))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tDatum\t\treloptions;\n\t\tbool\t\tisnull;\n\t\tQualCost\tindex_expr_cost;\n\n\t\t/* by default functional index is considered as non-injective */\n\t\tis_projection = true;\n\n\t\tcost_qual_eval(&index_expr_cost, RelationGetIndexExpressions(index), NULL);\n\n\t\t/*\n\t\t * If index expression is too expensive, then disable projection\n\t\t * optimization, because extra evaluation of index expression is\n\t\t * expected to be more expensive than index update.  Currently the\n\t\t * projection optimization has to calculate index expression twice\n\t\t * when the value of index expression has not changed and three times\n\t\t * when values differ because the expression is recalculated when\n\t\t * inserting a new index entry for the changed value.\n\t\t */\n\t\tif ((index_expr_cost.startup + index_expr_cost.per_tuple) >\n\t\t\tHEURISTIC_MAX_HOT_RECHECK_EXPR_COST)\n\t\t\tis_projection = false;\n\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(RelationGetRelid(index)));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", RelationGetRelid(index));\n\n\t\treloptions = SysCacheGetAttr(RELOID, tuple,\n\t\t\t\t\t\t\t\t\t Anum_pg_class_reloptions, &isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\tGenericIndexOpts *idxopts;\n\n\t\t\tidxopts = (GenericIndexOpts *) index_generic_reloptions(reloptions, false);\n\n\t\t\tif (idxopts != NULL)\n\t\t\t{\n\t\t\t\tis_projection = idxopts->recheck_on_update;\n\t\t\t\tpfree(idxopts);\n\t\t\t}\n\t\t}\n\t\tReleaseSysCache(tuple);\n\t}\n#endif\n\n\treturn is_projection;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define HEURISTIC_MAX_HOT_RECHECK_EXPR_COST 1000"
    ],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tuple"
          ],
          "line": 4783
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "idxopts"
          ],
          "line": 4780
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_generic_reloptions",
          "args": [
            "reloptions",
            "false"
          ],
          "line": 4775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SysCacheGetAttr",
          "args": [
            "RELOID",
            "tuple",
            "Anum_pg_class_reloptions",
            "&isnull"
          ],
          "line": 4769
        },
        "resolved": true,
        "details": {
          "function_name": "SysCacheGetAttr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1367-1390",
          "snippet": "Datum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nDatum\nSysCacheGetAttr(int cacheId, HeapTuple tup,\n\t\t\t\tAttrNumber attributeNumber,\n\t\t\t\tbool *isNull)\n{\n\t/*\n\t * We just need to get the TupleDesc out of the cache entry, and then we\n\t * can apply heap_getattr().  Normally the cache control data is already\n\t * valid (because the caller recently fetched the tuple via this same\n\t * cache), but there are cases where we have to initialize the cache here.\n\t */\n\tif (cacheId < 0 || cacheId >= SysCacheSize ||\n\t\t!PointerIsValid(SysCache[cacheId]))\n\t\telog(ERROR, \"invalid cache ID: %d\", cacheId);\n\tif (!PointerIsValid(SysCache[cacheId]->cc_tupdesc))\n\t{\n\t\tInitCatCachePhase2(SysCache[cacheId], false);\n\t\tAssert(PointerIsValid(SysCache[cacheId]->cc_tupdesc));\n\t}\n\n\treturn heap_getattr(tup, attributeNumber,\n\t\t\t\t\t\tSysCache[cacheId]->cc_tupdesc,\n\t\t\t\t\t\tisNull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for relation %u\"",
            "RelationGetRelid(index)"
          ],
          "line": 4767
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "index"
          ],
          "line": 4767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 4766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "RELOID",
            "ObjectIdGetDatum(RelationGetRelid(index))"
          ],
          "line": 4765
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "RelationGetRelid(index)"
          ],
          "line": 4765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "index"
          ],
          "line": 4765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cost_qual_eval",
          "args": [
            "&index_expr_cost",
            "RelationGetIndexExpressions(index)",
            "NULL"
          ],
          "line": 4750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetIndexExpressions",
          "args": [
            "index"
          ],
          "line": 4750
        },
        "resolved": true,
        "details": {
          "function_name": "RelationGetIndexExpressions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "4598-4648",
          "snippet": "List *\nRelationGetIndexExpressions(Relation relation)\n{\n\tList\t   *result;\n\tDatum\t\texprsDatum;\n\tbool\t\tisnull;\n\tchar\t   *exprsString;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the result. */\n\tif (relation->rd_indexprs)\n\t\treturn copyObject(relation->rd_indexprs);\n\n\t/* Quick exit if there is nothing to do. */\n\tif (relation->rd_indextuple == NULL ||\n\t\theap_attisnull(relation->rd_indextuple, Anum_pg_index_indexprs, NULL))\n\t\treturn NIL;\n\n\t/*\n\t * We build the tree we intend to return in the caller's context. After\n\t * successfully completing the work, we copy it into the relcache entry.\n\t * This avoids problems if we get some sort of error partway through.\n\t */\n\texprsDatum = heap_getattr(relation->rd_indextuple,\n\t\t\t\t\t\t\t  Anum_pg_index_indexprs,\n\t\t\t\t\t\t\t  GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t  &isnull);\n\tAssert(!isnull);\n\texprsString = TextDatumGetCString(exprsDatum);\n\tresult = (List *) stringToNode(exprsString);\n\tpfree(exprsString);\n\n\t/*\n\t * Run the expressions through eval_const_expressions. This is not just an\n\t * optimization, but is necessary, because the planner will be comparing\n\t * them to similarly-processed qual clauses, and may fail to detect valid\n\t * matches without this.  We must not use canonicalize_qual, however,\n\t * since these aren't qual expressions.\n\t */\n\tresult = (List *) eval_const_expressions(NULL, (Node *) result);\n\n\t/* May as well fix opfuncids too */\n\tfix_opfuncids((Node *) result);\n\n\t/* Now save a copy of the completed tree in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(relation->rd_indexcxt);\n\trelation->rd_indexprs = copyObject(result);\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static TupleDesc GetPgIndexDescriptor(void);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic TupleDesc GetPgIndexDescriptor(void);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nList *\nRelationGetIndexExpressions(Relation relation)\n{\n\tList\t   *result;\n\tDatum\t\texprsDatum;\n\tbool\t\tisnull;\n\tchar\t   *exprsString;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the result. */\n\tif (relation->rd_indexprs)\n\t\treturn copyObject(relation->rd_indexprs);\n\n\t/* Quick exit if there is nothing to do. */\n\tif (relation->rd_indextuple == NULL ||\n\t\theap_attisnull(relation->rd_indextuple, Anum_pg_index_indexprs, NULL))\n\t\treturn NIL;\n\n\t/*\n\t * We build the tree we intend to return in the caller's context. After\n\t * successfully completing the work, we copy it into the relcache entry.\n\t * This avoids problems if we get some sort of error partway through.\n\t */\n\texprsDatum = heap_getattr(relation->rd_indextuple,\n\t\t\t\t\t\t\t  Anum_pg_index_indexprs,\n\t\t\t\t\t\t\t  GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t  &isnull);\n\tAssert(!isnull);\n\texprsString = TextDatumGetCString(exprsDatum);\n\tresult = (List *) stringToNode(exprsString);\n\tpfree(exprsString);\n\n\t/*\n\t * Run the expressions through eval_const_expressions. This is not just an\n\t * optimization, but is necessary, because the planner will be comparing\n\t * them to similarly-processed qual clauses, and may fail to detect valid\n\t * matches without this.  We must not use canonicalize_qual, however,\n\t * since these aren't qual expressions.\n\t */\n\tresult = (List *) eval_const_expressions(NULL, (Node *) result);\n\n\t/* May as well fix opfuncids too */\n\tfix_opfuncids((Node *) result);\n\n\t/* Now save a copy of the completed tree in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(relation->rd_indexcxt);\n\trelation->rd_indexprs = copyObject(result);\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\n#define HEURISTIC_MAX_HOT_RECHECK_EXPR_COST 1000\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic bool\nIsProjectionFunctionalIndex(Relation index)\n{\n\tbool\t\tis_projection = false;\n\n#ifdef NOT_USED\n\tif (RelationGetIndexExpressions(index))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tDatum\t\treloptions;\n\t\tbool\t\tisnull;\n\t\tQualCost\tindex_expr_cost;\n\n\t\t/* by default functional index is considered as non-injective */\n\t\tis_projection = true;\n\n\t\tcost_qual_eval(&index_expr_cost, RelationGetIndexExpressions(index), NULL);\n\n\t\t/*\n\t\t * If index expression is too expensive, then disable projection\n\t\t * optimization, because extra evaluation of index expression is\n\t\t * expected to be more expensive than index update.  Currently the\n\t\t * projection optimization has to calculate index expression twice\n\t\t * when the value of index expression has not changed and three times\n\t\t * when values differ because the expression is recalculated when\n\t\t * inserting a new index entry for the changed value.\n\t\t */\n\t\tif ((index_expr_cost.startup + index_expr_cost.per_tuple) >\n\t\t\tHEURISTIC_MAX_HOT_RECHECK_EXPR_COST)\n\t\t\tis_projection = false;\n\n\t\ttuple = SearchSysCache1(RELOID, ObjectIdGetDatum(RelationGetRelid(index)));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", RelationGetRelid(index));\n\n\t\treloptions = SysCacheGetAttr(RELOID, tuple,\n\t\t\t\t\t\t\t\t\t Anum_pg_class_reloptions, &isnull);\n\t\tif (!isnull)\n\t\t{\n\t\t\tGenericIndexOpts *idxopts;\n\n\t\t\tidxopts = (GenericIndexOpts *) index_generic_reloptions(reloptions, false);\n\n\t\t\tif (idxopts != NULL)\n\t\t\t{\n\t\t\t\tis_projection = idxopts->recheck_on_update;\n\t\t\t\tpfree(idxopts);\n\t\t\t}\n\t\t}\n\t\tReleaseSysCache(tuple);\n\t}\n#endif\n\n\treturn is_projection;\n}"
  },
  {
    "function_name": "RelationGetIndexPredicate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "4660-4717",
    "snippet": "List *\nRelationGetIndexPredicate(Relation relation)\n{\n\tList\t   *result;\n\tDatum\t\tpredDatum;\n\tbool\t\tisnull;\n\tchar\t   *predString;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the result. */\n\tif (relation->rd_indpred)\n\t\treturn copyObject(relation->rd_indpred);\n\n\t/* Quick exit if there is nothing to do. */\n\tif (relation->rd_indextuple == NULL ||\n\t\theap_attisnull(relation->rd_indextuple, Anum_pg_index_indpred, NULL))\n\t\treturn NIL;\n\n\t/*\n\t * We build the tree we intend to return in the caller's context. After\n\t * successfully completing the work, we copy it into the relcache entry.\n\t * This avoids problems if we get some sort of error partway through.\n\t */\n\tpredDatum = heap_getattr(relation->rd_indextuple,\n\t\t\t\t\t\t\t Anum_pg_index_indpred,\n\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t &isnull);\n\tAssert(!isnull);\n\tpredString = TextDatumGetCString(predDatum);\n\tresult = (List *) stringToNode(predString);\n\tpfree(predString);\n\n\t/*\n\t * Run the expression through const-simplification and canonicalization.\n\t * This is not just an optimization, but is necessary, because the planner\n\t * will be comparing it to similarly-processed qual clauses, and may fail\n\t * to detect valid matches without this.  This must match the processing\n\t * done to qual clauses in preprocess_expression()!  (We can skip the\n\t * stuff involving subqueries, however, since we don't allow any in index\n\t * predicates.)\n\t */\n\tresult = (List *) eval_const_expressions(NULL, (Node *) result);\n\n\tresult = (List *) canonicalize_qual((Expr *) result, false);\n\n\t/* Also convert to implicit-AND format */\n\tresult = make_ands_implicit((Expr *) result);\n\n\t/* May as well fix opfuncids too */\n\tfix_opfuncids((Node *) result);\n\n\t/* Now save a copy of the completed tree in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(relation->rd_indexcxt);\n\trelation->rd_indpred = copyObject(result);\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static TupleDesc GetPgIndexDescriptor(void);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 4714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyObject",
          "args": [
            "result"
          ],
          "line": 4713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "relation->rd_indexcxt"
          ],
          "line": 4712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fix_opfuncids",
          "args": [
            "(Node *) result"
          ],
          "line": 4709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_ands_implicit",
          "args": [
            "(Expr *) result"
          ],
          "line": 4706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "canonicalize_qual",
          "args": [
            "(Expr *) result",
            "false"
          ],
          "line": 4703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eval_const_expressions",
          "args": [
            "NULL",
            "(Node *) result"
          ],
          "line": 4701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "predString"
          ],
          "line": 4690
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stringToNode",
          "args": [
            "predString"
          ],
          "line": 4689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "predDatum"
          ],
          "line": 4688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isnull"
          ],
          "line": 4687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "relation->rd_indextuple",
            "Anum_pg_index_indpred",
            "GetPgIndexDescriptor()",
            "&isnull"
          ],
          "line": 4683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetPgIndexDescriptor",
          "args": [],
          "line": 4685
        },
        "resolved": true,
        "details": {
          "function_name": "GetPgIndexDescriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "3947-3959",
          "snippet": "static TupleDesc\nGetPgIndexDescriptor(void)\n{\n\tstatic TupleDesc pgindexdesc = NULL;\n\n\t/* Already done? */\n\tif (pgindexdesc == NULL)\n\t\tpgindexdesc = BuildHardcodedDescriptor(Natts_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   Desc_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   false);\n\n\treturn pgindexdesc;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const FormData_pg_attribute Desc_pg_index[Natts_pg_index] = {Schema_pg_index};",
            "static TupleDesc GetPgIndexDescriptor(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic const FormData_pg_attribute Desc_pg_index[Natts_pg_index] = {Schema_pg_index};\nstatic TupleDesc GetPgIndexDescriptor(void);\n\nstatic TupleDesc\nGetPgIndexDescriptor(void)\n{\n\tstatic TupleDesc pgindexdesc = NULL;\n\n\t/* Already done? */\n\tif (pgindexdesc == NULL)\n\t\tpgindexdesc = BuildHardcodedDescriptor(Natts_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   Desc_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   false);\n\n\treturn pgindexdesc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_attisnull",
          "args": [
            "relation->rd_indextuple",
            "Anum_pg_index_indpred",
            "NULL"
          ],
          "line": 4675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyObject",
          "args": [
            "relation->rd_indpred"
          ],
          "line": 4671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic TupleDesc GetPgIndexDescriptor(void);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nList *\nRelationGetIndexPredicate(Relation relation)\n{\n\tList\t   *result;\n\tDatum\t\tpredDatum;\n\tbool\t\tisnull;\n\tchar\t   *predString;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the result. */\n\tif (relation->rd_indpred)\n\t\treturn copyObject(relation->rd_indpred);\n\n\t/* Quick exit if there is nothing to do. */\n\tif (relation->rd_indextuple == NULL ||\n\t\theap_attisnull(relation->rd_indextuple, Anum_pg_index_indpred, NULL))\n\t\treturn NIL;\n\n\t/*\n\t * We build the tree we intend to return in the caller's context. After\n\t * successfully completing the work, we copy it into the relcache entry.\n\t * This avoids problems if we get some sort of error partway through.\n\t */\n\tpredDatum = heap_getattr(relation->rd_indextuple,\n\t\t\t\t\t\t\t Anum_pg_index_indpred,\n\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t &isnull);\n\tAssert(!isnull);\n\tpredString = TextDatumGetCString(predDatum);\n\tresult = (List *) stringToNode(predString);\n\tpfree(predString);\n\n\t/*\n\t * Run the expression through const-simplification and canonicalization.\n\t * This is not just an optimization, but is necessary, because the planner\n\t * will be comparing it to similarly-processed qual clauses, and may fail\n\t * to detect valid matches without this.  This must match the processing\n\t * done to qual clauses in preprocess_expression()!  (We can skip the\n\t * stuff involving subqueries, however, since we don't allow any in index\n\t * predicates.)\n\t */\n\tresult = (List *) eval_const_expressions(NULL, (Node *) result);\n\n\tresult = (List *) canonicalize_qual((Expr *) result, false);\n\n\t/* Also convert to implicit-AND format */\n\tresult = make_ands_implicit((Expr *) result);\n\n\t/* May as well fix opfuncids too */\n\tfix_opfuncids((Node *) result);\n\n\t/* Now save a copy of the completed tree in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(relation->rd_indexcxt);\n\trelation->rd_indpred = copyObject(result);\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn result;\n}"
  },
  {
    "function_name": "RelationGetIndexExpressions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "4598-4648",
    "snippet": "List *\nRelationGetIndexExpressions(Relation relation)\n{\n\tList\t   *result;\n\tDatum\t\texprsDatum;\n\tbool\t\tisnull;\n\tchar\t   *exprsString;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the result. */\n\tif (relation->rd_indexprs)\n\t\treturn copyObject(relation->rd_indexprs);\n\n\t/* Quick exit if there is nothing to do. */\n\tif (relation->rd_indextuple == NULL ||\n\t\theap_attisnull(relation->rd_indextuple, Anum_pg_index_indexprs, NULL))\n\t\treturn NIL;\n\n\t/*\n\t * We build the tree we intend to return in the caller's context. After\n\t * successfully completing the work, we copy it into the relcache entry.\n\t * This avoids problems if we get some sort of error partway through.\n\t */\n\texprsDatum = heap_getattr(relation->rd_indextuple,\n\t\t\t\t\t\t\t  Anum_pg_index_indexprs,\n\t\t\t\t\t\t\t  GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t  &isnull);\n\tAssert(!isnull);\n\texprsString = TextDatumGetCString(exprsDatum);\n\tresult = (List *) stringToNode(exprsString);\n\tpfree(exprsString);\n\n\t/*\n\t * Run the expressions through eval_const_expressions. This is not just an\n\t * optimization, but is necessary, because the planner will be comparing\n\t * them to similarly-processed qual clauses, and may fail to detect valid\n\t * matches without this.  We must not use canonicalize_qual, however,\n\t * since these aren't qual expressions.\n\t */\n\tresult = (List *) eval_const_expressions(NULL, (Node *) result);\n\n\t/* May as well fix opfuncids too */\n\tfix_opfuncids((Node *) result);\n\n\t/* Now save a copy of the completed tree in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(relation->rd_indexcxt);\n\trelation->rd_indexprs = copyObject(result);\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static TupleDesc GetPgIndexDescriptor(void);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 4645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyObject",
          "args": [
            "result"
          ],
          "line": 4644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "relation->rd_indexcxt"
          ],
          "line": 4643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fix_opfuncids",
          "args": [
            "(Node *) result"
          ],
          "line": 4640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eval_const_expressions",
          "args": [
            "NULL",
            "(Node *) result"
          ],
          "line": 4637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "exprsString"
          ],
          "line": 4628
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stringToNode",
          "args": [
            "exprsString"
          ],
          "line": 4627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "exprsDatum"
          ],
          "line": 4626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isnull"
          ],
          "line": 4625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "relation->rd_indextuple",
            "Anum_pg_index_indexprs",
            "GetPgIndexDescriptor()",
            "&isnull"
          ],
          "line": 4621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetPgIndexDescriptor",
          "args": [],
          "line": 4623
        },
        "resolved": true,
        "details": {
          "function_name": "GetPgIndexDescriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "3947-3959",
          "snippet": "static TupleDesc\nGetPgIndexDescriptor(void)\n{\n\tstatic TupleDesc pgindexdesc = NULL;\n\n\t/* Already done? */\n\tif (pgindexdesc == NULL)\n\t\tpgindexdesc = BuildHardcodedDescriptor(Natts_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   Desc_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   false);\n\n\treturn pgindexdesc;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const FormData_pg_attribute Desc_pg_index[Natts_pg_index] = {Schema_pg_index};",
            "static TupleDesc GetPgIndexDescriptor(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic const FormData_pg_attribute Desc_pg_index[Natts_pg_index] = {Schema_pg_index};\nstatic TupleDesc GetPgIndexDescriptor(void);\n\nstatic TupleDesc\nGetPgIndexDescriptor(void)\n{\n\tstatic TupleDesc pgindexdesc = NULL;\n\n\t/* Already done? */\n\tif (pgindexdesc == NULL)\n\t\tpgindexdesc = BuildHardcodedDescriptor(Natts_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   Desc_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   false);\n\n\treturn pgindexdesc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_attisnull",
          "args": [
            "relation->rd_indextuple",
            "Anum_pg_index_indexprs",
            "NULL"
          ],
          "line": 4613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyObject",
          "args": [
            "relation->rd_indexprs"
          ],
          "line": 4609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic TupleDesc GetPgIndexDescriptor(void);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nList *\nRelationGetIndexExpressions(Relation relation)\n{\n\tList\t   *result;\n\tDatum\t\texprsDatum;\n\tbool\t\tisnull;\n\tchar\t   *exprsString;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the result. */\n\tif (relation->rd_indexprs)\n\t\treturn copyObject(relation->rd_indexprs);\n\n\t/* Quick exit if there is nothing to do. */\n\tif (relation->rd_indextuple == NULL ||\n\t\theap_attisnull(relation->rd_indextuple, Anum_pg_index_indexprs, NULL))\n\t\treturn NIL;\n\n\t/*\n\t * We build the tree we intend to return in the caller's context. After\n\t * successfully completing the work, we copy it into the relcache entry.\n\t * This avoids problems if we get some sort of error partway through.\n\t */\n\texprsDatum = heap_getattr(relation->rd_indextuple,\n\t\t\t\t\t\t\t  Anum_pg_index_indexprs,\n\t\t\t\t\t\t\t  GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t  &isnull);\n\tAssert(!isnull);\n\texprsString = TextDatumGetCString(exprsDatum);\n\tresult = (List *) stringToNode(exprsString);\n\tpfree(exprsString);\n\n\t/*\n\t * Run the expressions through eval_const_expressions. This is not just an\n\t * optimization, but is necessary, because the planner will be comparing\n\t * them to similarly-processed qual clauses, and may fail to detect valid\n\t * matches without this.  We must not use canonicalize_qual, however,\n\t * since these aren't qual expressions.\n\t */\n\tresult = (List *) eval_const_expressions(NULL, (Node *) result);\n\n\t/* May as well fix opfuncids too */\n\tfix_opfuncids((Node *) result);\n\n\t/* Now save a copy of the completed tree in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(relation->rd_indexcxt);\n\trelation->rd_indexprs = copyObject(result);\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn result;\n}"
  },
  {
    "function_name": "RelationGetReplicaIndex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "4573-4587",
    "snippet": "Oid\nRelationGetReplicaIndex(Relation relation)\n{\n\tList\t   *ilist;\n\n\tif (relation->rd_indexvalid == 0)\n\t{\n\t\t/* RelationGetIndexList does the heavy lifting. */\n\t\tilist = RelationGetIndexList(relation);\n\t\tlist_free(ilist);\n\t\tAssert(relation->rd_indexvalid != 0);\n\t}\n\n\treturn relation->rd_replidindex;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relation->rd_indexvalid != 0"
          ],
          "line": 4583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_free",
          "args": [
            "ilist"
          ],
          "line": 4582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetIndexList",
          "args": [
            "relation"
          ],
          "line": 4581
        },
        "resolved": true,
        "details": {
          "function_name": "RelationGetIndexList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "4242-4359",
          "snippet": "List *\nRelationGetIndexList(Relation relation)\n{\n\tRelation\tindrel;\n\tSysScanDesc indscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tList\t   *result;\n\tList\t   *oldlist;\n\tchar\t\treplident = relation->rd_rel->relreplident;\n\tOid\t\t\toidIndex = InvalidOid;\n\tOid\t\t\tpkeyIndex = InvalidOid;\n\tOid\t\t\tcandidateIndex = InvalidOid;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the list. */\n\tif (relation->rd_indexvalid != 0)\n\t\treturn list_copy(relation->rd_indexlist);\n\n\t/*\n\t * We build the list we intend to return (in the caller's context) while\n\t * doing the scan.  After successfully completing the scan, we copy that\n\t * list into the relcache entry.  This avoids cache-context memory leakage\n\t * if we get some sort of error partway through.\n\t */\n\tresult = NIL;\n\toidIndex = InvalidOid;\n\n\t/* Prepare to scan pg_index for entries having indrelid = this rel. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_index_indrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tindrel = heap_open(IndexRelationId, AccessShareLock);\n\tindscan = systable_beginscan(indrel, IndexIndrelidIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, &skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(indscan)))\n\t{\n\t\tForm_pg_index index = (Form_pg_index) GETSTRUCT(htup);\n\t\tDatum\t\tindclassDatum;\n\t\toidvector  *indclass;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Ignore any indexes that are currently being dropped.  This will\n\t\t * prevent them from being searched, inserted into, or considered in\n\t\t * HOT-safety decisions.  It's unsafe to touch such an index at all\n\t\t * since its catalog entries could disappear at any instant.\n\t\t */\n\t\tif (!IndexIsLive(index))\n\t\t\tcontinue;\n\n\t\t/* Add index's OID to result list in the proper order */\n\t\tresult = insert_ordered_oid(result, index->indexrelid);\n\n\t\t/*\n\t\t * indclass cannot be referenced directly through the C struct,\n\t\t * because it comes after the variable-width indkey field.  Must\n\t\t * extract the datum the hard way...\n\t\t */\n\t\tindclassDatum = heap_getattr(htup,\n\t\t\t\t\t\t\t\t\t Anum_pg_index_indclass,\n\t\t\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t\t &isnull);\n\t\tAssert(!isnull);\n\t\tindclass = (oidvector *) DatumGetPointer(indclassDatum);\n\n\t\t/*\n\t\t * Invalid, non-unique, non-immediate or predicate indexes aren't\n\t\t * interesting for either oid indexes or replication identity indexes,\n\t\t * so don't check them.\n\t\t */\n\t\tif (!IndexIsValid(index) || !index->indisunique ||\n\t\t\t!index->indimmediate ||\n\t\t\t!heap_attisnull(htup, Anum_pg_index_indpred, NULL))\n\t\t\tcontinue;\n\n\t\t/* Check to see if is a usable btree index on OID */\n\t\tif (index->indnatts == 1 &&\n\t\t\tindex->indkey.values[0] == ObjectIdAttributeNumber &&\n\t\t\tindclass->values[0] == OID_BTREE_OPS_OID)\n\t\t\toidIndex = index->indexrelid;\n\n\t\t/* remember primary key index if any */\n\t\tif (index->indisprimary)\n\t\t\tpkeyIndex = index->indexrelid;\n\n\t\t/* remember explicitly chosen replica index */\n\t\tif (index->indisreplident)\n\t\t\tcandidateIndex = index->indexrelid;\n\t}\n\n\tsystable_endscan(indscan);\n\n\theap_close(indrel, AccessShareLock);\n\n\t/* Now save a copy of the completed list in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\toldlist = relation->rd_indexlist;\n\trelation->rd_indexlist = list_copy(result);\n\trelation->rd_oidindex = oidIndex;\n\trelation->rd_pkindex = pkeyIndex;\n\tif (replident == REPLICA_IDENTITY_DEFAULT && OidIsValid(pkeyIndex))\n\t\trelation->rd_replidindex = pkeyIndex;\n\telse if (replident == REPLICA_IDENTITY_INDEX && OidIsValid(candidateIndex))\n\t\trelation->rd_replidindex = candidateIndex;\n\telse\n\t\trelation->rd_replidindex = InvalidOid;\n\trelation->rd_indexvalid = 1;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Don't leak the old list, if there is one */\n\tlist_free(oldlist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static TupleDesc GetPgIndexDescriptor(void);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static List *insert_ordered_oid(List *list, Oid datum);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic TupleDesc GetPgIndexDescriptor(void);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic List *insert_ordered_oid(List *list, Oid datum);\nstatic void InitIndexAmRoutine(Relation relation);\n\nList *\nRelationGetIndexList(Relation relation)\n{\n\tRelation\tindrel;\n\tSysScanDesc indscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tList\t   *result;\n\tList\t   *oldlist;\n\tchar\t\treplident = relation->rd_rel->relreplident;\n\tOid\t\t\toidIndex = InvalidOid;\n\tOid\t\t\tpkeyIndex = InvalidOid;\n\tOid\t\t\tcandidateIndex = InvalidOid;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the list. */\n\tif (relation->rd_indexvalid != 0)\n\t\treturn list_copy(relation->rd_indexlist);\n\n\t/*\n\t * We build the list we intend to return (in the caller's context) while\n\t * doing the scan.  After successfully completing the scan, we copy that\n\t * list into the relcache entry.  This avoids cache-context memory leakage\n\t * if we get some sort of error partway through.\n\t */\n\tresult = NIL;\n\toidIndex = InvalidOid;\n\n\t/* Prepare to scan pg_index for entries having indrelid = this rel. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_index_indrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tindrel = heap_open(IndexRelationId, AccessShareLock);\n\tindscan = systable_beginscan(indrel, IndexIndrelidIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, &skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(indscan)))\n\t{\n\t\tForm_pg_index index = (Form_pg_index) GETSTRUCT(htup);\n\t\tDatum\t\tindclassDatum;\n\t\toidvector  *indclass;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Ignore any indexes that are currently being dropped.  This will\n\t\t * prevent them from being searched, inserted into, or considered in\n\t\t * HOT-safety decisions.  It's unsafe to touch such an index at all\n\t\t * since its catalog entries could disappear at any instant.\n\t\t */\n\t\tif (!IndexIsLive(index))\n\t\t\tcontinue;\n\n\t\t/* Add index's OID to result list in the proper order */\n\t\tresult = insert_ordered_oid(result, index->indexrelid);\n\n\t\t/*\n\t\t * indclass cannot be referenced directly through the C struct,\n\t\t * because it comes after the variable-width indkey field.  Must\n\t\t * extract the datum the hard way...\n\t\t */\n\t\tindclassDatum = heap_getattr(htup,\n\t\t\t\t\t\t\t\t\t Anum_pg_index_indclass,\n\t\t\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t\t &isnull);\n\t\tAssert(!isnull);\n\t\tindclass = (oidvector *) DatumGetPointer(indclassDatum);\n\n\t\t/*\n\t\t * Invalid, non-unique, non-immediate or predicate indexes aren't\n\t\t * interesting for either oid indexes or replication identity indexes,\n\t\t * so don't check them.\n\t\t */\n\t\tif (!IndexIsValid(index) || !index->indisunique ||\n\t\t\t!index->indimmediate ||\n\t\t\t!heap_attisnull(htup, Anum_pg_index_indpred, NULL))\n\t\t\tcontinue;\n\n\t\t/* Check to see if is a usable btree index on OID */\n\t\tif (index->indnatts == 1 &&\n\t\t\tindex->indkey.values[0] == ObjectIdAttributeNumber &&\n\t\t\tindclass->values[0] == OID_BTREE_OPS_OID)\n\t\t\toidIndex = index->indexrelid;\n\n\t\t/* remember primary key index if any */\n\t\tif (index->indisprimary)\n\t\t\tpkeyIndex = index->indexrelid;\n\n\t\t/* remember explicitly chosen replica index */\n\t\tif (index->indisreplident)\n\t\t\tcandidateIndex = index->indexrelid;\n\t}\n\n\tsystable_endscan(indscan);\n\n\theap_close(indrel, AccessShareLock);\n\n\t/* Now save a copy of the completed list in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\toldlist = relation->rd_indexlist;\n\trelation->rd_indexlist = list_copy(result);\n\trelation->rd_oidindex = oidIndex;\n\trelation->rd_pkindex = pkeyIndex;\n\tif (replident == REPLICA_IDENTITY_DEFAULT && OidIsValid(pkeyIndex))\n\t\trelation->rd_replidindex = pkeyIndex;\n\telse if (replident == REPLICA_IDENTITY_INDEX && OidIsValid(candidateIndex))\n\t\trelation->rd_replidindex = candidateIndex;\n\telse\n\t\trelation->rd_replidindex = InvalidOid;\n\trelation->rd_indexvalid = 1;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Don't leak the old list, if there is one */\n\tlist_free(oldlist);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nOid\nRelationGetReplicaIndex(Relation relation)\n{\n\tList\t   *ilist;\n\n\tif (relation->rd_indexvalid == 0)\n\t{\n\t\t/* RelationGetIndexList does the heavy lifting. */\n\t\tilist = RelationGetIndexList(relation);\n\t\tlist_free(ilist);\n\t\tAssert(relation->rd_indexvalid != 0);\n\t}\n\n\treturn relation->rd_replidindex;\n}"
  },
  {
    "function_name": "RelationGetPrimaryKeyIndex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "4552-4566",
    "snippet": "Oid\nRelationGetPrimaryKeyIndex(Relation relation)\n{\n\tList\t   *ilist;\n\n\tif (relation->rd_indexvalid == 0)\n\t{\n\t\t/* RelationGetIndexList does the heavy lifting. */\n\t\tilist = RelationGetIndexList(relation);\n\t\tlist_free(ilist);\n\t\tAssert(relation->rd_indexvalid != 0);\n\t}\n\n\treturn relation->rd_pkindex;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relation->rd_indexvalid != 0"
          ],
          "line": 4562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_free",
          "args": [
            "ilist"
          ],
          "line": 4561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetIndexList",
          "args": [
            "relation"
          ],
          "line": 4560
        },
        "resolved": true,
        "details": {
          "function_name": "RelationGetIndexList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "4242-4359",
          "snippet": "List *\nRelationGetIndexList(Relation relation)\n{\n\tRelation\tindrel;\n\tSysScanDesc indscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tList\t   *result;\n\tList\t   *oldlist;\n\tchar\t\treplident = relation->rd_rel->relreplident;\n\tOid\t\t\toidIndex = InvalidOid;\n\tOid\t\t\tpkeyIndex = InvalidOid;\n\tOid\t\t\tcandidateIndex = InvalidOid;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the list. */\n\tif (relation->rd_indexvalid != 0)\n\t\treturn list_copy(relation->rd_indexlist);\n\n\t/*\n\t * We build the list we intend to return (in the caller's context) while\n\t * doing the scan.  After successfully completing the scan, we copy that\n\t * list into the relcache entry.  This avoids cache-context memory leakage\n\t * if we get some sort of error partway through.\n\t */\n\tresult = NIL;\n\toidIndex = InvalidOid;\n\n\t/* Prepare to scan pg_index for entries having indrelid = this rel. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_index_indrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tindrel = heap_open(IndexRelationId, AccessShareLock);\n\tindscan = systable_beginscan(indrel, IndexIndrelidIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, &skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(indscan)))\n\t{\n\t\tForm_pg_index index = (Form_pg_index) GETSTRUCT(htup);\n\t\tDatum\t\tindclassDatum;\n\t\toidvector  *indclass;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Ignore any indexes that are currently being dropped.  This will\n\t\t * prevent them from being searched, inserted into, or considered in\n\t\t * HOT-safety decisions.  It's unsafe to touch such an index at all\n\t\t * since its catalog entries could disappear at any instant.\n\t\t */\n\t\tif (!IndexIsLive(index))\n\t\t\tcontinue;\n\n\t\t/* Add index's OID to result list in the proper order */\n\t\tresult = insert_ordered_oid(result, index->indexrelid);\n\n\t\t/*\n\t\t * indclass cannot be referenced directly through the C struct,\n\t\t * because it comes after the variable-width indkey field.  Must\n\t\t * extract the datum the hard way...\n\t\t */\n\t\tindclassDatum = heap_getattr(htup,\n\t\t\t\t\t\t\t\t\t Anum_pg_index_indclass,\n\t\t\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t\t &isnull);\n\t\tAssert(!isnull);\n\t\tindclass = (oidvector *) DatumGetPointer(indclassDatum);\n\n\t\t/*\n\t\t * Invalid, non-unique, non-immediate or predicate indexes aren't\n\t\t * interesting for either oid indexes or replication identity indexes,\n\t\t * so don't check them.\n\t\t */\n\t\tif (!IndexIsValid(index) || !index->indisunique ||\n\t\t\t!index->indimmediate ||\n\t\t\t!heap_attisnull(htup, Anum_pg_index_indpred, NULL))\n\t\t\tcontinue;\n\n\t\t/* Check to see if is a usable btree index on OID */\n\t\tif (index->indnatts == 1 &&\n\t\t\tindex->indkey.values[0] == ObjectIdAttributeNumber &&\n\t\t\tindclass->values[0] == OID_BTREE_OPS_OID)\n\t\t\toidIndex = index->indexrelid;\n\n\t\t/* remember primary key index if any */\n\t\tif (index->indisprimary)\n\t\t\tpkeyIndex = index->indexrelid;\n\n\t\t/* remember explicitly chosen replica index */\n\t\tif (index->indisreplident)\n\t\t\tcandidateIndex = index->indexrelid;\n\t}\n\n\tsystable_endscan(indscan);\n\n\theap_close(indrel, AccessShareLock);\n\n\t/* Now save a copy of the completed list in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\toldlist = relation->rd_indexlist;\n\trelation->rd_indexlist = list_copy(result);\n\trelation->rd_oidindex = oidIndex;\n\trelation->rd_pkindex = pkeyIndex;\n\tif (replident == REPLICA_IDENTITY_DEFAULT && OidIsValid(pkeyIndex))\n\t\trelation->rd_replidindex = pkeyIndex;\n\telse if (replident == REPLICA_IDENTITY_INDEX && OidIsValid(candidateIndex))\n\t\trelation->rd_replidindex = candidateIndex;\n\telse\n\t\trelation->rd_replidindex = InvalidOid;\n\trelation->rd_indexvalid = 1;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Don't leak the old list, if there is one */\n\tlist_free(oldlist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static TupleDesc GetPgIndexDescriptor(void);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static List *insert_ordered_oid(List *list, Oid datum);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic TupleDesc GetPgIndexDescriptor(void);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic List *insert_ordered_oid(List *list, Oid datum);\nstatic void InitIndexAmRoutine(Relation relation);\n\nList *\nRelationGetIndexList(Relation relation)\n{\n\tRelation\tindrel;\n\tSysScanDesc indscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tList\t   *result;\n\tList\t   *oldlist;\n\tchar\t\treplident = relation->rd_rel->relreplident;\n\tOid\t\t\toidIndex = InvalidOid;\n\tOid\t\t\tpkeyIndex = InvalidOid;\n\tOid\t\t\tcandidateIndex = InvalidOid;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the list. */\n\tif (relation->rd_indexvalid != 0)\n\t\treturn list_copy(relation->rd_indexlist);\n\n\t/*\n\t * We build the list we intend to return (in the caller's context) while\n\t * doing the scan.  After successfully completing the scan, we copy that\n\t * list into the relcache entry.  This avoids cache-context memory leakage\n\t * if we get some sort of error partway through.\n\t */\n\tresult = NIL;\n\toidIndex = InvalidOid;\n\n\t/* Prepare to scan pg_index for entries having indrelid = this rel. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_index_indrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tindrel = heap_open(IndexRelationId, AccessShareLock);\n\tindscan = systable_beginscan(indrel, IndexIndrelidIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, &skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(indscan)))\n\t{\n\t\tForm_pg_index index = (Form_pg_index) GETSTRUCT(htup);\n\t\tDatum\t\tindclassDatum;\n\t\toidvector  *indclass;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Ignore any indexes that are currently being dropped.  This will\n\t\t * prevent them from being searched, inserted into, or considered in\n\t\t * HOT-safety decisions.  It's unsafe to touch such an index at all\n\t\t * since its catalog entries could disappear at any instant.\n\t\t */\n\t\tif (!IndexIsLive(index))\n\t\t\tcontinue;\n\n\t\t/* Add index's OID to result list in the proper order */\n\t\tresult = insert_ordered_oid(result, index->indexrelid);\n\n\t\t/*\n\t\t * indclass cannot be referenced directly through the C struct,\n\t\t * because it comes after the variable-width indkey field.  Must\n\t\t * extract the datum the hard way...\n\t\t */\n\t\tindclassDatum = heap_getattr(htup,\n\t\t\t\t\t\t\t\t\t Anum_pg_index_indclass,\n\t\t\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t\t &isnull);\n\t\tAssert(!isnull);\n\t\tindclass = (oidvector *) DatumGetPointer(indclassDatum);\n\n\t\t/*\n\t\t * Invalid, non-unique, non-immediate or predicate indexes aren't\n\t\t * interesting for either oid indexes or replication identity indexes,\n\t\t * so don't check them.\n\t\t */\n\t\tif (!IndexIsValid(index) || !index->indisunique ||\n\t\t\t!index->indimmediate ||\n\t\t\t!heap_attisnull(htup, Anum_pg_index_indpred, NULL))\n\t\t\tcontinue;\n\n\t\t/* Check to see if is a usable btree index on OID */\n\t\tif (index->indnatts == 1 &&\n\t\t\tindex->indkey.values[0] == ObjectIdAttributeNumber &&\n\t\t\tindclass->values[0] == OID_BTREE_OPS_OID)\n\t\t\toidIndex = index->indexrelid;\n\n\t\t/* remember primary key index if any */\n\t\tif (index->indisprimary)\n\t\t\tpkeyIndex = index->indexrelid;\n\n\t\t/* remember explicitly chosen replica index */\n\t\tif (index->indisreplident)\n\t\t\tcandidateIndex = index->indexrelid;\n\t}\n\n\tsystable_endscan(indscan);\n\n\theap_close(indrel, AccessShareLock);\n\n\t/* Now save a copy of the completed list in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\toldlist = relation->rd_indexlist;\n\trelation->rd_indexlist = list_copy(result);\n\trelation->rd_oidindex = oidIndex;\n\trelation->rd_pkindex = pkeyIndex;\n\tif (replident == REPLICA_IDENTITY_DEFAULT && OidIsValid(pkeyIndex))\n\t\trelation->rd_replidindex = pkeyIndex;\n\telse if (replident == REPLICA_IDENTITY_INDEX && OidIsValid(candidateIndex))\n\t\trelation->rd_replidindex = candidateIndex;\n\telse\n\t\trelation->rd_replidindex = InvalidOid;\n\trelation->rd_indexvalid = 1;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Don't leak the old list, if there is one */\n\tlist_free(oldlist);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nOid\nRelationGetPrimaryKeyIndex(Relation relation)\n{\n\tList\t   *ilist;\n\n\tif (relation->rd_indexvalid == 0)\n\t{\n\t\t/* RelationGetIndexList does the heavy lifting. */\n\t\tilist = RelationGetIndexList(relation);\n\t\tlist_free(ilist);\n\t\tAssert(relation->rd_indexvalid != 0);\n\t}\n\n\treturn relation->rd_pkindex;\n}"
  },
  {
    "function_name": "RelationGetOidIndex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "4524-4545",
    "snippet": "Oid\nRelationGetOidIndex(Relation relation)\n{\n\tList\t   *ilist;\n\n\t/*\n\t * If relation doesn't have OIDs at all, caller is probably confused. (We\n\t * could just silently return InvalidOid, but it seems better to throw an\n\t * assertion.)\n\t */\n\tAssert(relation->rd_rel->relhasoids);\n\n\tif (relation->rd_indexvalid == 0)\n\t{\n\t\t/* RelationGetIndexList does the heavy lifting. */\n\t\tilist = RelationGetIndexList(relation);\n\t\tlist_free(ilist);\n\t\tAssert(relation->rd_indexvalid != 0);\n\t}\n\n\treturn relation->rd_oidindex;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relation->rd_indexvalid != 0"
          ],
          "line": 4541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_free",
          "args": [
            "ilist"
          ],
          "line": 4540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetIndexList",
          "args": [
            "relation"
          ],
          "line": 4539
        },
        "resolved": true,
        "details": {
          "function_name": "RelationGetIndexList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "4242-4359",
          "snippet": "List *\nRelationGetIndexList(Relation relation)\n{\n\tRelation\tindrel;\n\tSysScanDesc indscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tList\t   *result;\n\tList\t   *oldlist;\n\tchar\t\treplident = relation->rd_rel->relreplident;\n\tOid\t\t\toidIndex = InvalidOid;\n\tOid\t\t\tpkeyIndex = InvalidOid;\n\tOid\t\t\tcandidateIndex = InvalidOid;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the list. */\n\tif (relation->rd_indexvalid != 0)\n\t\treturn list_copy(relation->rd_indexlist);\n\n\t/*\n\t * We build the list we intend to return (in the caller's context) while\n\t * doing the scan.  After successfully completing the scan, we copy that\n\t * list into the relcache entry.  This avoids cache-context memory leakage\n\t * if we get some sort of error partway through.\n\t */\n\tresult = NIL;\n\toidIndex = InvalidOid;\n\n\t/* Prepare to scan pg_index for entries having indrelid = this rel. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_index_indrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tindrel = heap_open(IndexRelationId, AccessShareLock);\n\tindscan = systable_beginscan(indrel, IndexIndrelidIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, &skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(indscan)))\n\t{\n\t\tForm_pg_index index = (Form_pg_index) GETSTRUCT(htup);\n\t\tDatum\t\tindclassDatum;\n\t\toidvector  *indclass;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Ignore any indexes that are currently being dropped.  This will\n\t\t * prevent them from being searched, inserted into, or considered in\n\t\t * HOT-safety decisions.  It's unsafe to touch such an index at all\n\t\t * since its catalog entries could disappear at any instant.\n\t\t */\n\t\tif (!IndexIsLive(index))\n\t\t\tcontinue;\n\n\t\t/* Add index's OID to result list in the proper order */\n\t\tresult = insert_ordered_oid(result, index->indexrelid);\n\n\t\t/*\n\t\t * indclass cannot be referenced directly through the C struct,\n\t\t * because it comes after the variable-width indkey field.  Must\n\t\t * extract the datum the hard way...\n\t\t */\n\t\tindclassDatum = heap_getattr(htup,\n\t\t\t\t\t\t\t\t\t Anum_pg_index_indclass,\n\t\t\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t\t &isnull);\n\t\tAssert(!isnull);\n\t\tindclass = (oidvector *) DatumGetPointer(indclassDatum);\n\n\t\t/*\n\t\t * Invalid, non-unique, non-immediate or predicate indexes aren't\n\t\t * interesting for either oid indexes or replication identity indexes,\n\t\t * so don't check them.\n\t\t */\n\t\tif (!IndexIsValid(index) || !index->indisunique ||\n\t\t\t!index->indimmediate ||\n\t\t\t!heap_attisnull(htup, Anum_pg_index_indpred, NULL))\n\t\t\tcontinue;\n\n\t\t/* Check to see if is a usable btree index on OID */\n\t\tif (index->indnatts == 1 &&\n\t\t\tindex->indkey.values[0] == ObjectIdAttributeNumber &&\n\t\t\tindclass->values[0] == OID_BTREE_OPS_OID)\n\t\t\toidIndex = index->indexrelid;\n\n\t\t/* remember primary key index if any */\n\t\tif (index->indisprimary)\n\t\t\tpkeyIndex = index->indexrelid;\n\n\t\t/* remember explicitly chosen replica index */\n\t\tif (index->indisreplident)\n\t\t\tcandidateIndex = index->indexrelid;\n\t}\n\n\tsystable_endscan(indscan);\n\n\theap_close(indrel, AccessShareLock);\n\n\t/* Now save a copy of the completed list in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\toldlist = relation->rd_indexlist;\n\trelation->rd_indexlist = list_copy(result);\n\trelation->rd_oidindex = oidIndex;\n\trelation->rd_pkindex = pkeyIndex;\n\tif (replident == REPLICA_IDENTITY_DEFAULT && OidIsValid(pkeyIndex))\n\t\trelation->rd_replidindex = pkeyIndex;\n\telse if (replident == REPLICA_IDENTITY_INDEX && OidIsValid(candidateIndex))\n\t\trelation->rd_replidindex = candidateIndex;\n\telse\n\t\trelation->rd_replidindex = InvalidOid;\n\trelation->rd_indexvalid = 1;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Don't leak the old list, if there is one */\n\tlist_free(oldlist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static TupleDesc GetPgIndexDescriptor(void);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static List *insert_ordered_oid(List *list, Oid datum);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic TupleDesc GetPgIndexDescriptor(void);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic List *insert_ordered_oid(List *list, Oid datum);\nstatic void InitIndexAmRoutine(Relation relation);\n\nList *\nRelationGetIndexList(Relation relation)\n{\n\tRelation\tindrel;\n\tSysScanDesc indscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tList\t   *result;\n\tList\t   *oldlist;\n\tchar\t\treplident = relation->rd_rel->relreplident;\n\tOid\t\t\toidIndex = InvalidOid;\n\tOid\t\t\tpkeyIndex = InvalidOid;\n\tOid\t\t\tcandidateIndex = InvalidOid;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the list. */\n\tif (relation->rd_indexvalid != 0)\n\t\treturn list_copy(relation->rd_indexlist);\n\n\t/*\n\t * We build the list we intend to return (in the caller's context) while\n\t * doing the scan.  After successfully completing the scan, we copy that\n\t * list into the relcache entry.  This avoids cache-context memory leakage\n\t * if we get some sort of error partway through.\n\t */\n\tresult = NIL;\n\toidIndex = InvalidOid;\n\n\t/* Prepare to scan pg_index for entries having indrelid = this rel. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_index_indrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tindrel = heap_open(IndexRelationId, AccessShareLock);\n\tindscan = systable_beginscan(indrel, IndexIndrelidIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, &skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(indscan)))\n\t{\n\t\tForm_pg_index index = (Form_pg_index) GETSTRUCT(htup);\n\t\tDatum\t\tindclassDatum;\n\t\toidvector  *indclass;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Ignore any indexes that are currently being dropped.  This will\n\t\t * prevent them from being searched, inserted into, or considered in\n\t\t * HOT-safety decisions.  It's unsafe to touch such an index at all\n\t\t * since its catalog entries could disappear at any instant.\n\t\t */\n\t\tif (!IndexIsLive(index))\n\t\t\tcontinue;\n\n\t\t/* Add index's OID to result list in the proper order */\n\t\tresult = insert_ordered_oid(result, index->indexrelid);\n\n\t\t/*\n\t\t * indclass cannot be referenced directly through the C struct,\n\t\t * because it comes after the variable-width indkey field.  Must\n\t\t * extract the datum the hard way...\n\t\t */\n\t\tindclassDatum = heap_getattr(htup,\n\t\t\t\t\t\t\t\t\t Anum_pg_index_indclass,\n\t\t\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t\t &isnull);\n\t\tAssert(!isnull);\n\t\tindclass = (oidvector *) DatumGetPointer(indclassDatum);\n\n\t\t/*\n\t\t * Invalid, non-unique, non-immediate or predicate indexes aren't\n\t\t * interesting for either oid indexes or replication identity indexes,\n\t\t * so don't check them.\n\t\t */\n\t\tif (!IndexIsValid(index) || !index->indisunique ||\n\t\t\t!index->indimmediate ||\n\t\t\t!heap_attisnull(htup, Anum_pg_index_indpred, NULL))\n\t\t\tcontinue;\n\n\t\t/* Check to see if is a usable btree index on OID */\n\t\tif (index->indnatts == 1 &&\n\t\t\tindex->indkey.values[0] == ObjectIdAttributeNumber &&\n\t\t\tindclass->values[0] == OID_BTREE_OPS_OID)\n\t\t\toidIndex = index->indexrelid;\n\n\t\t/* remember primary key index if any */\n\t\tif (index->indisprimary)\n\t\t\tpkeyIndex = index->indexrelid;\n\n\t\t/* remember explicitly chosen replica index */\n\t\tif (index->indisreplident)\n\t\t\tcandidateIndex = index->indexrelid;\n\t}\n\n\tsystable_endscan(indscan);\n\n\theap_close(indrel, AccessShareLock);\n\n\t/* Now save a copy of the completed list in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\toldlist = relation->rd_indexlist;\n\trelation->rd_indexlist = list_copy(result);\n\trelation->rd_oidindex = oidIndex;\n\trelation->rd_pkindex = pkeyIndex;\n\tif (replident == REPLICA_IDENTITY_DEFAULT && OidIsValid(pkeyIndex))\n\t\trelation->rd_replidindex = pkeyIndex;\n\telse if (replident == REPLICA_IDENTITY_INDEX && OidIsValid(candidateIndex))\n\t\trelation->rd_replidindex = candidateIndex;\n\telse\n\t\trelation->rd_replidindex = InvalidOid;\n\trelation->rd_indexvalid = 1;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Don't leak the old list, if there is one */\n\tlist_free(oldlist);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relation->rd_rel->relhasoids"
          ],
          "line": 4534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nOid\nRelationGetOidIndex(Relation relation)\n{\n\tList\t   *ilist;\n\n\t/*\n\t * If relation doesn't have OIDs at all, caller is probably confused. (We\n\t * could just silently return InvalidOid, but it seems better to throw an\n\t * assertion.)\n\t */\n\tAssert(relation->rd_rel->relhasoids);\n\n\tif (relation->rd_indexvalid == 0)\n\t{\n\t\t/* RelationGetIndexList does the heavy lifting. */\n\t\tilist = RelationGetIndexList(relation);\n\t\tlist_free(ilist);\n\t\tAssert(relation->rd_indexvalid != 0);\n\t}\n\n\treturn relation->rd_oidindex;\n}"
  },
  {
    "function_name": "RelationSetIndexList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "4493-4517",
    "snippet": "void\nRelationSetIndexList(Relation relation, List *indexIds, Oid oidIndex)\n{\n\tMemoryContext oldcxt;\n\n\tAssert(relation->rd_isnailed);\n\t/* Copy the list into the cache context (could fail for lack of mem) */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\tindexIds = list_copy(indexIds);\n\tMemoryContextSwitchTo(oldcxt);\n\t/* Okay to replace old list */\n\tlist_free(relation->rd_indexlist);\n\trelation->rd_indexlist = indexIds;\n\trelation->rd_oidindex = oidIndex;\n\n\t/*\n\t * For the moment, assume the target rel hasn't got a pk or replica index.\n\t * We'll load them on demand in the API that wraps access to them.\n\t */\n\trelation->rd_pkindex = InvalidOid;\n\trelation->rd_replidindex = InvalidOid;\n\trelation->rd_indexvalid = 2;\t/* mark list as forced */\n\t/* Flag relation as needing eoxact cleanup (to reset the list) */\n\tEOXactListAdd(relation);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EOXactListAdd",
          "args": [
            "relation"
          ],
          "line": 4516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_free",
          "args": [
            "relation->rd_indexlist"
          ],
          "line": 4504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 4502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_copy",
          "args": [
            "indexIds"
          ],
          "line": 4501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 4500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relation->rd_isnailed"
          ],
          "line": 4498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationSetIndexList(Relation relation, List *indexIds, Oid oidIndex)\n{\n\tMemoryContext oldcxt;\n\n\tAssert(relation->rd_isnailed);\n\t/* Copy the list into the cache context (could fail for lack of mem) */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\tindexIds = list_copy(indexIds);\n\tMemoryContextSwitchTo(oldcxt);\n\t/* Okay to replace old list */\n\tlist_free(relation->rd_indexlist);\n\trelation->rd_indexlist = indexIds;\n\trelation->rd_oidindex = oidIndex;\n\n\t/*\n\t * For the moment, assume the target rel hasn't got a pk or replica index.\n\t * We'll load them on demand in the API that wraps access to them.\n\t */\n\trelation->rd_pkindex = InvalidOid;\n\trelation->rd_replidindex = InvalidOid;\n\trelation->rd_indexvalid = 2;\t/* mark list as forced */\n\t/* Flag relation as needing eoxact cleanup (to reset the list) */\n\tEOXactListAdd(relation);\n}"
  },
  {
    "function_name": "insert_ordered_oid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "4448-4470",
    "snippet": "static List *\ninsert_ordered_oid(List *list, Oid datum)\n{\n\tListCell   *prev;\n\n\t/* Does the datum belong at the front? */\n\tif (list == NIL || datum < linitial_oid(list))\n\t\treturn lcons_oid(datum, list);\n\t/* No, so find the entry it belongs after */\n\tprev = list_head(list);\n\tfor (;;)\n\t{\n\t\tListCell   *curr = lnext(prev);\n\n\t\tif (curr == NULL || datum < lfirst_oid(curr))\n\t\t\tbreak;\t\t\t\t/* it belongs after 'prev', before 'curr' */\n\n\t\tprev = curr;\n\t}\n\t/* Insert datum into list after 'prev' */\n\tlappend_cell_oid(list, prev, datum);\n\treturn list;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static List *insert_ordered_oid(List *list, Oid datum);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lappend_cell_oid",
          "args": [
            "list",
            "prev",
            "datum"
          ],
          "line": 4468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst_oid",
          "args": [
            "curr"
          ],
          "line": 4462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnext",
          "args": [
            "prev"
          ],
          "line": 4460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_head",
          "args": [
            "list"
          ],
          "line": 4457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lcons_oid",
          "args": [
            "datum",
            "list"
          ],
          "line": 4455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial_oid",
          "args": [
            "list"
          ],
          "line": 4454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic List *insert_ordered_oid(List *list, Oid datum);\n\nstatic List *\ninsert_ordered_oid(List *list, Oid datum)\n{\n\tListCell   *prev;\n\n\t/* Does the datum belong at the front? */\n\tif (list == NIL || datum < linitial_oid(list))\n\t\treturn lcons_oid(datum, list);\n\t/* No, so find the entry it belongs after */\n\tprev = list_head(list);\n\tfor (;;)\n\t{\n\t\tListCell   *curr = lnext(prev);\n\n\t\tif (curr == NULL || datum < lfirst_oid(curr))\n\t\t\tbreak;\t\t\t\t/* it belongs after 'prev', before 'curr' */\n\n\t\tprev = curr;\n\t}\n\t/* Insert datum into list after 'prev' */\n\tlappend_cell_oid(list, prev, datum);\n\treturn list;\n}"
  },
  {
    "function_name": "RelationGetStatExtList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "4382-4437",
    "snippet": "List *\nRelationGetStatExtList(Relation relation)\n{\n\tRelation\tindrel;\n\tSysScanDesc indscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tList\t   *result;\n\tList\t   *oldlist;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the list. */\n\tif (relation->rd_statvalid != 0)\n\t\treturn list_copy(relation->rd_statlist);\n\n\t/*\n\t * We build the list we intend to return (in the caller's context) while\n\t * doing the scan.  After successfully completing the scan, we copy that\n\t * list into the relcache entry.  This avoids cache-context memory leakage\n\t * if we get some sort of error partway through.\n\t */\n\tresult = NIL;\n\n\t/*\n\t * Prepare to scan pg_statistic_ext for entries having stxrelid = this\n\t * rel.\n\t */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_statistic_ext_stxrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tindrel = heap_open(StatisticExtRelationId, AccessShareLock);\n\tindscan = systable_beginscan(indrel, StatisticExtRelidIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, &skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(indscan)))\n\t\tresult = insert_ordered_oid(result, HeapTupleGetOid(htup));\n\n\tsystable_endscan(indscan);\n\n\theap_close(indrel, AccessShareLock);\n\n\t/* Now save a copy of the completed list in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\toldlist = relation->rd_statlist;\n\trelation->rd_statlist = list_copy(result);\n\n\trelation->rd_statvalid = true;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Don't leak the old list, if there is one */\n\tlist_free(oldlist);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_free",
          "args": [
            "oldlist"
          ],
          "line": 4434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 4431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_copy",
          "args": [
            "result"
          ],
          "line": 4428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 4426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "indrel",
            "AccessShareLock"
          ],
          "line": 4423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan",
          "args": [
            "indscan"
          ],
          "line": 4421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_ordered_oid",
          "args": [
            "result",
            "HeapTupleGetOid(htup)"
          ],
          "line": 4419
        },
        "resolved": true,
        "details": {
          "function_name": "insert_ordered_oid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "4448-4470",
          "snippet": "static List *\ninsert_ordered_oid(List *list, Oid datum)\n{\n\tListCell   *prev;\n\n\t/* Does the datum belong at the front? */\n\tif (list == NIL || datum < linitial_oid(list))\n\t\treturn lcons_oid(datum, list);\n\t/* No, so find the entry it belongs after */\n\tprev = list_head(list);\n\tfor (;;)\n\t{\n\t\tListCell   *curr = lnext(prev);\n\n\t\tif (curr == NULL || datum < lfirst_oid(curr))\n\t\t\tbreak;\t\t\t\t/* it belongs after 'prev', before 'curr' */\n\n\t\tprev = curr;\n\t}\n\t/* Insert datum into list after 'prev' */\n\tlappend_cell_oid(list, prev, datum);\n\treturn list;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static List *insert_ordered_oid(List *list, Oid datum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic List *insert_ordered_oid(List *list, Oid datum);\n\nstatic List *\ninsert_ordered_oid(List *list, Oid datum)\n{\n\tListCell   *prev;\n\n\t/* Does the datum belong at the front? */\n\tif (list == NIL || datum < linitial_oid(list))\n\t\treturn lcons_oid(datum, list);\n\t/* No, so find the entry it belongs after */\n\tprev = list_head(list);\n\tfor (;;)\n\t{\n\t\tListCell   *curr = lnext(prev);\n\n\t\tif (curr == NULL || datum < lfirst_oid(curr))\n\t\t\tbreak;\t\t\t\t/* it belongs after 'prev', before 'curr' */\n\n\t\tprev = curr;\n\t}\n\t/* Insert datum into list after 'prev' */\n\tlappend_cell_oid(list, prev, datum);\n\treturn list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "htup"
          ],
          "line": 4419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "htup = systable_getnext(indscan)"
          ],
          "line": 4418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext",
          "args": [
            "indscan"
          ],
          "line": 4418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_beginscan",
          "args": [
            "indrel",
            "StatisticExtRelidIndexId",
            "true",
            "NULL",
            "1",
            "&skey"
          ],
          "line": 4415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "StatisticExtRelationId",
            "AccessShareLock"
          ],
          "line": 4414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyInit",
          "args": [
            "&skey",
            "Anum_pg_statistic_ext_stxrelid",
            "BTEqualStrategyNumber",
            "F_OIDEQ",
            "ObjectIdGetDatum(RelationGetRelid(relation))"
          ],
          "line": 4409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "RelationGetRelid(relation)"
          ],
          "line": 4412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 4412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_copy",
          "args": [
            "relation->rd_statlist"
          ],
          "line": 4395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nList *\nRelationGetStatExtList(Relation relation)\n{\n\tRelation\tindrel;\n\tSysScanDesc indscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tList\t   *result;\n\tList\t   *oldlist;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the list. */\n\tif (relation->rd_statvalid != 0)\n\t\treturn list_copy(relation->rd_statlist);\n\n\t/*\n\t * We build the list we intend to return (in the caller's context) while\n\t * doing the scan.  After successfully completing the scan, we copy that\n\t * list into the relcache entry.  This avoids cache-context memory leakage\n\t * if we get some sort of error partway through.\n\t */\n\tresult = NIL;\n\n\t/*\n\t * Prepare to scan pg_statistic_ext for entries having stxrelid = this\n\t * rel.\n\t */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_statistic_ext_stxrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tindrel = heap_open(StatisticExtRelationId, AccessShareLock);\n\tindscan = systable_beginscan(indrel, StatisticExtRelidIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, &skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(indscan)))\n\t\tresult = insert_ordered_oid(result, HeapTupleGetOid(htup));\n\n\tsystable_endscan(indscan);\n\n\theap_close(indrel, AccessShareLock);\n\n\t/* Now save a copy of the completed list in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\toldlist = relation->rd_statlist;\n\trelation->rd_statlist = list_copy(result);\n\n\trelation->rd_statvalid = true;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Don't leak the old list, if there is one */\n\tlist_free(oldlist);\n\n\treturn result;\n}"
  },
  {
    "function_name": "RelationGetIndexList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "4242-4359",
    "snippet": "List *\nRelationGetIndexList(Relation relation)\n{\n\tRelation\tindrel;\n\tSysScanDesc indscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tList\t   *result;\n\tList\t   *oldlist;\n\tchar\t\treplident = relation->rd_rel->relreplident;\n\tOid\t\t\toidIndex = InvalidOid;\n\tOid\t\t\tpkeyIndex = InvalidOid;\n\tOid\t\t\tcandidateIndex = InvalidOid;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the list. */\n\tif (relation->rd_indexvalid != 0)\n\t\treturn list_copy(relation->rd_indexlist);\n\n\t/*\n\t * We build the list we intend to return (in the caller's context) while\n\t * doing the scan.  After successfully completing the scan, we copy that\n\t * list into the relcache entry.  This avoids cache-context memory leakage\n\t * if we get some sort of error partway through.\n\t */\n\tresult = NIL;\n\toidIndex = InvalidOid;\n\n\t/* Prepare to scan pg_index for entries having indrelid = this rel. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_index_indrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tindrel = heap_open(IndexRelationId, AccessShareLock);\n\tindscan = systable_beginscan(indrel, IndexIndrelidIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, &skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(indscan)))\n\t{\n\t\tForm_pg_index index = (Form_pg_index) GETSTRUCT(htup);\n\t\tDatum\t\tindclassDatum;\n\t\toidvector  *indclass;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Ignore any indexes that are currently being dropped.  This will\n\t\t * prevent them from being searched, inserted into, or considered in\n\t\t * HOT-safety decisions.  It's unsafe to touch such an index at all\n\t\t * since its catalog entries could disappear at any instant.\n\t\t */\n\t\tif (!IndexIsLive(index))\n\t\t\tcontinue;\n\n\t\t/* Add index's OID to result list in the proper order */\n\t\tresult = insert_ordered_oid(result, index->indexrelid);\n\n\t\t/*\n\t\t * indclass cannot be referenced directly through the C struct,\n\t\t * because it comes after the variable-width indkey field.  Must\n\t\t * extract the datum the hard way...\n\t\t */\n\t\tindclassDatum = heap_getattr(htup,\n\t\t\t\t\t\t\t\t\t Anum_pg_index_indclass,\n\t\t\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t\t &isnull);\n\t\tAssert(!isnull);\n\t\tindclass = (oidvector *) DatumGetPointer(indclassDatum);\n\n\t\t/*\n\t\t * Invalid, non-unique, non-immediate or predicate indexes aren't\n\t\t * interesting for either oid indexes or replication identity indexes,\n\t\t * so don't check them.\n\t\t */\n\t\tif (!IndexIsValid(index) || !index->indisunique ||\n\t\t\t!index->indimmediate ||\n\t\t\t!heap_attisnull(htup, Anum_pg_index_indpred, NULL))\n\t\t\tcontinue;\n\n\t\t/* Check to see if is a usable btree index on OID */\n\t\tif (index->indnatts == 1 &&\n\t\t\tindex->indkey.values[0] == ObjectIdAttributeNumber &&\n\t\t\tindclass->values[0] == OID_BTREE_OPS_OID)\n\t\t\toidIndex = index->indexrelid;\n\n\t\t/* remember primary key index if any */\n\t\tif (index->indisprimary)\n\t\t\tpkeyIndex = index->indexrelid;\n\n\t\t/* remember explicitly chosen replica index */\n\t\tif (index->indisreplident)\n\t\t\tcandidateIndex = index->indexrelid;\n\t}\n\n\tsystable_endscan(indscan);\n\n\theap_close(indrel, AccessShareLock);\n\n\t/* Now save a copy of the completed list in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\toldlist = relation->rd_indexlist;\n\trelation->rd_indexlist = list_copy(result);\n\trelation->rd_oidindex = oidIndex;\n\trelation->rd_pkindex = pkeyIndex;\n\tif (replident == REPLICA_IDENTITY_DEFAULT && OidIsValid(pkeyIndex))\n\t\trelation->rd_replidindex = pkeyIndex;\n\telse if (replident == REPLICA_IDENTITY_INDEX && OidIsValid(candidateIndex))\n\t\trelation->rd_replidindex = candidateIndex;\n\telse\n\t\trelation->rd_replidindex = InvalidOid;\n\trelation->rd_indexvalid = 1;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Don't leak the old list, if there is one */\n\tlist_free(oldlist);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static TupleDesc GetPgIndexDescriptor(void);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static List *insert_ordered_oid(List *list, Oid datum);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_free",
          "args": [
            "oldlist"
          ],
          "line": 4356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 4353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "candidateIndex"
          ],
          "line": 4348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "pkeyIndex"
          ],
          "line": 4346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_copy",
          "args": [
            "result"
          ],
          "line": 4343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 4341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "indrel",
            "AccessShareLock"
          ],
          "line": 4338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan",
          "args": [
            "indscan"
          ],
          "line": 4336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_attisnull",
          "args": [
            "htup",
            "Anum_pg_index_indpred",
            "NULL"
          ],
          "line": 4318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IndexIsValid",
          "args": [
            "index"
          ],
          "line": 4316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "indclassDatum"
          ],
          "line": 4309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isnull"
          ],
          "line": 4308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "htup",
            "Anum_pg_index_indclass",
            "GetPgIndexDescriptor()",
            "&isnull"
          ],
          "line": 4304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetPgIndexDescriptor",
          "args": [],
          "line": 4306
        },
        "resolved": true,
        "details": {
          "function_name": "GetPgIndexDescriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "3947-3959",
          "snippet": "static TupleDesc\nGetPgIndexDescriptor(void)\n{\n\tstatic TupleDesc pgindexdesc = NULL;\n\n\t/* Already done? */\n\tif (pgindexdesc == NULL)\n\t\tpgindexdesc = BuildHardcodedDescriptor(Natts_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   Desc_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   false);\n\n\treturn pgindexdesc;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const FormData_pg_attribute Desc_pg_index[Natts_pg_index] = {Schema_pg_index};",
            "static TupleDesc GetPgIndexDescriptor(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic const FormData_pg_attribute Desc_pg_index[Natts_pg_index] = {Schema_pg_index};\nstatic TupleDesc GetPgIndexDescriptor(void);\n\nstatic TupleDesc\nGetPgIndexDescriptor(void)\n{\n\tstatic TupleDesc pgindexdesc = NULL;\n\n\t/* Already done? */\n\tif (pgindexdesc == NULL)\n\t\tpgindexdesc = BuildHardcodedDescriptor(Natts_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   Desc_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   false);\n\n\treturn pgindexdesc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_ordered_oid",
          "args": [
            "result",
            "index->indexrelid"
          ],
          "line": 4297
        },
        "resolved": true,
        "details": {
          "function_name": "insert_ordered_oid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "4448-4470",
          "snippet": "static List *\ninsert_ordered_oid(List *list, Oid datum)\n{\n\tListCell   *prev;\n\n\t/* Does the datum belong at the front? */\n\tif (list == NIL || datum < linitial_oid(list))\n\t\treturn lcons_oid(datum, list);\n\t/* No, so find the entry it belongs after */\n\tprev = list_head(list);\n\tfor (;;)\n\t{\n\t\tListCell   *curr = lnext(prev);\n\n\t\tif (curr == NULL || datum < lfirst_oid(curr))\n\t\t\tbreak;\t\t\t\t/* it belongs after 'prev', before 'curr' */\n\n\t\tprev = curr;\n\t}\n\t/* Insert datum into list after 'prev' */\n\tlappend_cell_oid(list, prev, datum);\n\treturn list;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static List *insert_ordered_oid(List *list, Oid datum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic List *insert_ordered_oid(List *list, Oid datum);\n\nstatic List *\ninsert_ordered_oid(List *list, Oid datum)\n{\n\tListCell   *prev;\n\n\t/* Does the datum belong at the front? */\n\tif (list == NIL || datum < linitial_oid(list))\n\t\treturn lcons_oid(datum, list);\n\t/* No, so find the entry it belongs after */\n\tprev = list_head(list);\n\tfor (;;)\n\t{\n\t\tListCell   *curr = lnext(prev);\n\n\t\tif (curr == NULL || datum < lfirst_oid(curr))\n\t\t\tbreak;\t\t\t\t/* it belongs after 'prev', before 'curr' */\n\n\t\tprev = curr;\n\t}\n\t/* Insert datum into list after 'prev' */\n\tlappend_cell_oid(list, prev, datum);\n\treturn list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IndexIsLive",
          "args": [
            "index"
          ],
          "line": 4293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "htup"
          ],
          "line": 4282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "htup = systable_getnext(indscan)"
          ],
          "line": 4280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext",
          "args": [
            "indscan"
          ],
          "line": 4280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_beginscan",
          "args": [
            "indrel",
            "IndexIndrelidIndexId",
            "true",
            "NULL",
            "1",
            "&skey"
          ],
          "line": 4277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "IndexRelationId",
            "AccessShareLock"
          ],
          "line": 4276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyInit",
          "args": [
            "&skey",
            "Anum_pg_index_indrelid",
            "BTEqualStrategyNumber",
            "F_OIDEQ",
            "ObjectIdGetDatum(RelationGetRelid(relation))"
          ],
          "line": 4271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "RelationGetRelid(relation)"
          ],
          "line": 4274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 4274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_copy",
          "args": [
            "relation->rd_indexlist"
          ],
          "line": 4259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic TupleDesc GetPgIndexDescriptor(void);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic List *insert_ordered_oid(List *list, Oid datum);\nstatic void InitIndexAmRoutine(Relation relation);\n\nList *\nRelationGetIndexList(Relation relation)\n{\n\tRelation\tindrel;\n\tSysScanDesc indscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tList\t   *result;\n\tList\t   *oldlist;\n\tchar\t\treplident = relation->rd_rel->relreplident;\n\tOid\t\t\toidIndex = InvalidOid;\n\tOid\t\t\tpkeyIndex = InvalidOid;\n\tOid\t\t\tcandidateIndex = InvalidOid;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the list. */\n\tif (relation->rd_indexvalid != 0)\n\t\treturn list_copy(relation->rd_indexlist);\n\n\t/*\n\t * We build the list we intend to return (in the caller's context) while\n\t * doing the scan.  After successfully completing the scan, we copy that\n\t * list into the relcache entry.  This avoids cache-context memory leakage\n\t * if we get some sort of error partway through.\n\t */\n\tresult = NIL;\n\toidIndex = InvalidOid;\n\n\t/* Prepare to scan pg_index for entries having indrelid = this rel. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_index_indrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tindrel = heap_open(IndexRelationId, AccessShareLock);\n\tindscan = systable_beginscan(indrel, IndexIndrelidIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, &skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(indscan)))\n\t{\n\t\tForm_pg_index index = (Form_pg_index) GETSTRUCT(htup);\n\t\tDatum\t\tindclassDatum;\n\t\toidvector  *indclass;\n\t\tbool\t\tisnull;\n\n\t\t/*\n\t\t * Ignore any indexes that are currently being dropped.  This will\n\t\t * prevent them from being searched, inserted into, or considered in\n\t\t * HOT-safety decisions.  It's unsafe to touch such an index at all\n\t\t * since its catalog entries could disappear at any instant.\n\t\t */\n\t\tif (!IndexIsLive(index))\n\t\t\tcontinue;\n\n\t\t/* Add index's OID to result list in the proper order */\n\t\tresult = insert_ordered_oid(result, index->indexrelid);\n\n\t\t/*\n\t\t * indclass cannot be referenced directly through the C struct,\n\t\t * because it comes after the variable-width indkey field.  Must\n\t\t * extract the datum the hard way...\n\t\t */\n\t\tindclassDatum = heap_getattr(htup,\n\t\t\t\t\t\t\t\t\t Anum_pg_index_indclass,\n\t\t\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t\t &isnull);\n\t\tAssert(!isnull);\n\t\tindclass = (oidvector *) DatumGetPointer(indclassDatum);\n\n\t\t/*\n\t\t * Invalid, non-unique, non-immediate or predicate indexes aren't\n\t\t * interesting for either oid indexes or replication identity indexes,\n\t\t * so don't check them.\n\t\t */\n\t\tif (!IndexIsValid(index) || !index->indisunique ||\n\t\t\t!index->indimmediate ||\n\t\t\t!heap_attisnull(htup, Anum_pg_index_indpred, NULL))\n\t\t\tcontinue;\n\n\t\t/* Check to see if is a usable btree index on OID */\n\t\tif (index->indnatts == 1 &&\n\t\t\tindex->indkey.values[0] == ObjectIdAttributeNumber &&\n\t\t\tindclass->values[0] == OID_BTREE_OPS_OID)\n\t\t\toidIndex = index->indexrelid;\n\n\t\t/* remember primary key index if any */\n\t\tif (index->indisprimary)\n\t\t\tpkeyIndex = index->indexrelid;\n\n\t\t/* remember explicitly chosen replica index */\n\t\tif (index->indisreplident)\n\t\t\tcandidateIndex = index->indexrelid;\n\t}\n\n\tsystable_endscan(indscan);\n\n\theap_close(indrel, AccessShareLock);\n\n\t/* Now save a copy of the completed list in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\toldlist = relation->rd_indexlist;\n\trelation->rd_indexlist = list_copy(result);\n\trelation->rd_oidindex = oidIndex;\n\trelation->rd_pkindex = pkeyIndex;\n\tif (replident == REPLICA_IDENTITY_DEFAULT && OidIsValid(pkeyIndex))\n\t\trelation->rd_replidindex = pkeyIndex;\n\telse if (replident == REPLICA_IDENTITY_INDEX && OidIsValid(candidateIndex))\n\t\trelation->rd_replidindex = candidateIndex;\n\telse\n\t\trelation->rd_replidindex = InvalidOid;\n\trelation->rd_indexvalid = 1;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Don't leak the old list, if there is one */\n\tlist_free(oldlist);\n\n\treturn result;\n}"
  },
  {
    "function_name": "RelationGetFKeyList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "4128-4204",
    "snippet": "List *\nRelationGetFKeyList(Relation relation)\n{\n\tList\t   *result;\n\tRelation\tconrel;\n\tSysScanDesc conscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tList\t   *oldlist;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the list. */\n\tif (relation->rd_fkeyvalid)\n\t\treturn relation->rd_fkeylist;\n\n\t/* Fast path: non-partitioned tables without triggers can't have FKs */\n\tif (!relation->rd_rel->relhastriggers &&\n\t\trelation->rd_rel->relkind != RELKIND_PARTITIONED_TABLE)\n\t\treturn NIL;\n\n\t/*\n\t * We build the list we intend to return (in the caller's context) while\n\t * doing the scan.  After successfully completing the scan, we copy that\n\t * list into the relcache entry.  This avoids cache-context memory leakage\n\t * if we get some sort of error partway through.\n\t */\n\tresult = NIL;\n\n\t/* Prepare to scan pg_constraint for entries having conrelid = this rel. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_constraint_conrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tconrel = heap_open(ConstraintRelationId, AccessShareLock);\n\tconscan = systable_beginscan(conrel, ConstraintRelidTypidNameIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, &skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(conscan)))\n\t{\n\t\tForm_pg_constraint constraint = (Form_pg_constraint) GETSTRUCT(htup);\n\t\tForeignKeyCacheInfo *info;\n\n\t\t/* consider only foreign keys */\n\t\tif (constraint->contype != CONSTRAINT_FOREIGN)\n\t\t\tcontinue;\n\n\t\tinfo = makeNode(ForeignKeyCacheInfo);\n\t\tinfo->conoid = HeapTupleGetOid(htup);\n\t\tinfo->conrelid = constraint->conrelid;\n\t\tinfo->confrelid = constraint->confrelid;\n\n\t\tDeconstructFkConstraintRow(htup, &info->nkeys,\n\t\t\t\t\t\t\t\t   info->conkey,\n\t\t\t\t\t\t\t\t   info->confkey,\n\t\t\t\t\t\t\t\t   info->conpfeqop,\n\t\t\t\t\t\t\t\t   NULL, NULL);\n\n\t\t/* Add FK's node to the result list */\n\t\tresult = lappend(result, info);\n\t}\n\n\tsystable_endscan(conscan);\n\theap_close(conrel, AccessShareLock);\n\n\t/* Now save a copy of the completed list in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\toldlist = relation->rd_fkeylist;\n\trelation->rd_fkeylist = copyObject(result);\n\trelation->rd_fkeyvalid = true;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Don't leak the old list, if there is one */\n\tlist_free_deep(oldlist);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_free_deep",
          "args": [
            "oldlist"
          ],
          "line": 4201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 4198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyObject",
          "args": [
            "result"
          ],
          "line": 4196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 4194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "conrel",
            "AccessShareLock"
          ],
          "line": 4191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan",
          "args": [
            "conscan"
          ],
          "line": 4190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "result",
            "info"
          ],
          "line": 4187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DeconstructFkConstraintRow",
          "args": [
            "htup",
            "&info->nkeys",
            "info->conkey",
            "info->confkey",
            "info->conpfeqop",
            "NULL",
            "NULL"
          ],
          "line": 4180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "htup"
          ],
          "line": 4176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeNode",
          "args": [
            "ForeignKeyCacheInfo"
          ],
          "line": 4175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "htup"
          ],
          "line": 4168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "htup = systable_getnext(conscan)"
          ],
          "line": 4166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext",
          "args": [
            "conscan"
          ],
          "line": 4166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_beginscan",
          "args": [
            "conrel",
            "ConstraintRelidTypidNameIndexId",
            "true",
            "NULL",
            "1",
            "&skey"
          ],
          "line": 4163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "ConstraintRelationId",
            "AccessShareLock"
          ],
          "line": 4162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyInit",
          "args": [
            "&skey",
            "Anum_pg_constraint_conrelid",
            "BTEqualStrategyNumber",
            "F_OIDEQ",
            "ObjectIdGetDatum(RelationGetRelid(relation))"
          ],
          "line": 4157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "RelationGetRelid(relation)"
          ],
          "line": 4160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 4160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nList *\nRelationGetFKeyList(Relation relation)\n{\n\tList\t   *result;\n\tRelation\tconrel;\n\tSysScanDesc conscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tList\t   *oldlist;\n\tMemoryContext oldcxt;\n\n\t/* Quick exit if we already computed the list. */\n\tif (relation->rd_fkeyvalid)\n\t\treturn relation->rd_fkeylist;\n\n\t/* Fast path: non-partitioned tables without triggers can't have FKs */\n\tif (!relation->rd_rel->relhastriggers &&\n\t\trelation->rd_rel->relkind != RELKIND_PARTITIONED_TABLE)\n\t\treturn NIL;\n\n\t/*\n\t * We build the list we intend to return (in the caller's context) while\n\t * doing the scan.  After successfully completing the scan, we copy that\n\t * list into the relcache entry.  This avoids cache-context memory leakage\n\t * if we get some sort of error partway through.\n\t */\n\tresult = NIL;\n\n\t/* Prepare to scan pg_constraint for entries having conrelid = this rel. */\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_constraint_conrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tconrel = heap_open(ConstraintRelationId, AccessShareLock);\n\tconscan = systable_beginscan(conrel, ConstraintRelidTypidNameIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, &skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(conscan)))\n\t{\n\t\tForm_pg_constraint constraint = (Form_pg_constraint) GETSTRUCT(htup);\n\t\tForeignKeyCacheInfo *info;\n\n\t\t/* consider only foreign keys */\n\t\tif (constraint->contype != CONSTRAINT_FOREIGN)\n\t\t\tcontinue;\n\n\t\tinfo = makeNode(ForeignKeyCacheInfo);\n\t\tinfo->conoid = HeapTupleGetOid(htup);\n\t\tinfo->conrelid = constraint->conrelid;\n\t\tinfo->confrelid = constraint->confrelid;\n\n\t\tDeconstructFkConstraintRow(htup, &info->nkeys,\n\t\t\t\t\t\t\t\t   info->conkey,\n\t\t\t\t\t\t\t\t   info->confkey,\n\t\t\t\t\t\t\t\t   info->conpfeqop,\n\t\t\t\t\t\t\t\t   NULL, NULL);\n\n\t\t/* Add FK's node to the result list */\n\t\tresult = lappend(result, info);\n\t}\n\n\tsystable_endscan(conscan);\n\theap_close(conrel, AccessShareLock);\n\n\t/* Now save a copy of the completed list in the relcache entry. */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\toldlist = relation->rd_fkeylist;\n\trelation->rd_fkeylist = copyObject(result);\n\trelation->rd_fkeyvalid = true;\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* Don't leak the old list, if there is one */\n\tlist_free_deep(oldlist);\n\n\treturn result;\n}"
  },
  {
    "function_name": "CheckConstraintCmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "4105-4112",
    "snippet": "static int\nCheckConstraintCmp(const void *a, const void *b)\n{\n\tconst ConstrCheck *ca = (const ConstrCheck *) a;\n\tconst ConstrCheck *cb = (const ConstrCheck *) b;\n\n\treturn strcmp(ca->ccname, cb->ccname);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tCheckConstraintCmp(const void *a, const void *b);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ca->ccname",
            "cb->ccname"
          ],
          "line": 4111
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic int\tCheckConstraintCmp(const void *a, const void *b);\n\nstatic int\nCheckConstraintCmp(const void *a, const void *b)\n{\n\tconst ConstrCheck *ca = (const ConstrCheck *) a;\n\tconst ConstrCheck *cb = (const ConstrCheck *) b;\n\n\treturn strcmp(ca->ccname, cb->ccname);\n}"
  },
  {
    "function_name": "CheckConstraintFetch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "4034-4100",
    "snippet": "static void\nCheckConstraintFetch(Relation relation)\n{\n\tConstrCheck *check = relation->rd_att->constr->check;\n\tint\t\t\tncheck = relation->rd_att->constr->num_check;\n\tRelation\tconrel;\n\tSysScanDesc conscan;\n\tScanKeyData skey[1];\n\tHeapTuple\thtup;\n\tint\t\t\tfound = 0;\n\n\tScanKeyInit(&skey[0],\n\t\t\t\tAnum_pg_constraint_conrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tconrel = heap_open(ConstraintRelationId, AccessShareLock);\n\tconscan = systable_beginscan(conrel, ConstraintRelidTypidNameIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(conscan)))\n\t{\n\t\tForm_pg_constraint conform = (Form_pg_constraint) GETSTRUCT(htup);\n\t\tDatum\t\tval;\n\t\tbool\t\tisnull;\n\t\tchar\t   *s;\n\n\t\t/* We want check constraints only */\n\t\tif (conform->contype != CONSTRAINT_CHECK)\n\t\t\tcontinue;\n\n\t\tif (found >= ncheck)\n\t\t\telog(ERROR, \"unexpected constraint record found for rel %s\",\n\t\t\t\t RelationGetRelationName(relation));\n\n\t\tcheck[found].ccvalid = conform->convalidated;\n\t\tcheck[found].ccnoinherit = conform->connoinherit;\n\t\tcheck[found].ccname = MemoryContextStrdup(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t  NameStr(conform->conname));\n\n\t\t/* Grab and test conbin is actually set */\n\t\tval = fastgetattr(htup,\n\t\t\t\t\t\t  Anum_pg_constraint_conbin,\n\t\t\t\t\t\t  conrel->rd_att, &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null conbin for rel %s\",\n\t\t\t\t RelationGetRelationName(relation));\n\n\t\t/* detoast and convert to cstring in caller's context */\n\t\ts = TextDatumGetCString(val);\n\t\tcheck[found].ccbin = MemoryContextStrdup(CacheMemoryContext, s);\n\t\tpfree(s);\n\n\t\tfound++;\n\t}\n\n\tsystable_endscan(conscan);\n\theap_close(conrel, AccessShareLock);\n\n\tif (found != ncheck)\n\t\telog(ERROR, \"%d constraint record(s) missing for rel %s\",\n\t\t\t ncheck - found, RelationGetRelationName(relation));\n\n\t/* Sort the records so that CHECKs are applied in a deterministic order */\n\tif (ncheck > 1)\n\t\tqsort(check, ncheck, sizeof(ConstrCheck), CheckConstraintCmp);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "check",
            "ncheck",
            "sizeof(ConstrCheck)",
            "CheckConstraintCmp"
          ],
          "line": 4099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"%d constraint record(s) missing for rel %s\"",
            "ncheck - found",
            "RelationGetRelationName(relation)"
          ],
          "line": 4094
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "relation"
          ],
          "line": 4095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "conrel",
            "AccessShareLock"
          ],
          "line": 4091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan",
          "args": [
            "conscan"
          ],
          "line": 4090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "s"
          ],
          "line": 4085
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextStrdup",
          "args": [
            "CacheMemoryContext",
            "s"
          ],
          "line": 4084
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextStrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1147-1158",
          "snippet": "char *\nMemoryContextStrdup(MemoryContext context, const char *string)\n{\n\tchar\t   *nstr;\n\tSize\t\tlen = strlen(string) + 1;\n\n\tnstr = (char *) MemoryContextAlloc(context, len);\n\n\tmemcpy(nstr, string, len);\n\n\treturn nstr;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nchar *\nMemoryContextStrdup(MemoryContext context, const char *string)\n{\n\tchar\t   *nstr;\n\tSize\t\tlen = strlen(string) + 1;\n\n\tnstr = (char *) MemoryContextAlloc(context, len);\n\n\tmemcpy(nstr, string, len);\n\n\treturn nstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "val"
          ],
          "line": 4083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "relation"
          ],
          "line": 4080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fastgetattr",
          "args": [
            "htup",
            "Anum_pg_constraint_conbin",
            "conrel->rd_att",
            "&isnull"
          ],
          "line": 4075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "conform->conname"
          ],
          "line": 4072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "relation"
          ],
          "line": 4067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "htup"
          ],
          "line": 4056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "htup = systable_getnext(conscan)"
          ],
          "line": 4054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext",
          "args": [
            "conscan"
          ],
          "line": 4054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_beginscan",
          "args": [
            "conrel",
            "ConstraintRelidTypidNameIndexId",
            "true",
            "NULL",
            "1",
            "skey"
          ],
          "line": 4051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "ConstraintRelationId",
            "AccessShareLock"
          ],
          "line": 4050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyInit",
          "args": [
            "&skey[0]",
            "Anum_pg_constraint_conrelid",
            "BTEqualStrategyNumber",
            "F_OIDEQ",
            "ObjectIdGetDatum(RelationGetRelid(relation))"
          ],
          "line": 4045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "RelationGetRelid(relation)"
          ],
          "line": 4048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 4048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nCheckConstraintFetch(Relation relation)\n{\n\tConstrCheck *check = relation->rd_att->constr->check;\n\tint\t\t\tncheck = relation->rd_att->constr->num_check;\n\tRelation\tconrel;\n\tSysScanDesc conscan;\n\tScanKeyData skey[1];\n\tHeapTuple\thtup;\n\tint\t\t\tfound = 0;\n\n\tScanKeyInit(&skey[0],\n\t\t\t\tAnum_pg_constraint_conrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tconrel = heap_open(ConstraintRelationId, AccessShareLock);\n\tconscan = systable_beginscan(conrel, ConstraintRelidTypidNameIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(conscan)))\n\t{\n\t\tForm_pg_constraint conform = (Form_pg_constraint) GETSTRUCT(htup);\n\t\tDatum\t\tval;\n\t\tbool\t\tisnull;\n\t\tchar\t   *s;\n\n\t\t/* We want check constraints only */\n\t\tif (conform->contype != CONSTRAINT_CHECK)\n\t\t\tcontinue;\n\n\t\tif (found >= ncheck)\n\t\t\telog(ERROR, \"unexpected constraint record found for rel %s\",\n\t\t\t\t RelationGetRelationName(relation));\n\n\t\tcheck[found].ccvalid = conform->convalidated;\n\t\tcheck[found].ccnoinherit = conform->connoinherit;\n\t\tcheck[found].ccname = MemoryContextStrdup(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t  NameStr(conform->conname));\n\n\t\t/* Grab and test conbin is actually set */\n\t\tval = fastgetattr(htup,\n\t\t\t\t\t\t  Anum_pg_constraint_conbin,\n\t\t\t\t\t\t  conrel->rd_att, &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null conbin for rel %s\",\n\t\t\t\t RelationGetRelationName(relation));\n\n\t\t/* detoast and convert to cstring in caller's context */\n\t\ts = TextDatumGetCString(val);\n\t\tcheck[found].ccbin = MemoryContextStrdup(CacheMemoryContext, s);\n\t\tpfree(s);\n\n\t\tfound++;\n\t}\n\n\tsystable_endscan(conscan);\n\theap_close(conrel, AccessShareLock);\n\n\tif (found != ncheck)\n\t\telog(ERROR, \"%d constraint record(s) missing for rel %s\",\n\t\t\t ncheck - found, RelationGetRelationName(relation));\n\n\t/* Sort the records so that CHECKs are applied in a deterministic order */\n\tif (ncheck > 1)\n\t\tqsort(check, ncheck, sizeof(ConstrCheck), CheckConstraintCmp);\n}"
  },
  {
    "function_name": "AttrDefaultFetch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "3964-4029",
    "snippet": "static void\nAttrDefaultFetch(Relation relation)\n{\n\tAttrDefault *attrdef = relation->rd_att->constr->defval;\n\tint\t\t\tndef = relation->rd_att->constr->num_defval;\n\tRelation\tadrel;\n\tSysScanDesc adscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tint\t\t\tfound;\n\tint\t\t\ti;\n\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_attrdef_adrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tadrel = heap_open(AttrDefaultRelationId, AccessShareLock);\n\tadscan = systable_beginscan(adrel, AttrDefaultIndexId, true,\n\t\t\t\t\t\t\t\tNULL, 1, &skey);\n\tfound = 0;\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(adscan)))\n\t{\n\t\tForm_pg_attrdef adform = (Form_pg_attrdef) GETSTRUCT(htup);\n\t\tForm_pg_attribute attr = TupleDescAttr(relation->rd_att, adform->adnum - 1);\n\n\t\tfor (i = 0; i < ndef; i++)\n\t\t{\n\t\t\tif (adform->adnum != attrdef[i].adnum)\n\t\t\t\tcontinue;\n\t\t\tif (attrdef[i].adbin != NULL)\n\t\t\t\telog(WARNING, \"multiple attrdef records found for attr %s of rel %s\",\n\t\t\t\t\t NameStr(attr->attname),\n\t\t\t\t\t RelationGetRelationName(relation));\n\t\t\telse\n\t\t\t\tfound++;\n\n\t\t\tval = fastgetattr(htup,\n\t\t\t\t\t\t\t  Anum_pg_attrdef_adbin,\n\t\t\t\t\t\t\t  adrel->rd_att, &isnull);\n\t\t\tif (isnull)\n\t\t\t\telog(WARNING, \"null adbin for attr %s of rel %s\",\n\t\t\t\t\t NameStr(attr->attname),\n\t\t\t\t\t RelationGetRelationName(relation));\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* detoast and convert to cstring in caller's context */\n\t\t\t\tchar\t   *s = TextDatumGetCString(val);\n\n\t\t\t\tattrdef[i].adbin = MemoryContextStrdup(CacheMemoryContext, s);\n\t\t\t\tpfree(s);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i >= ndef)\n\t\t\telog(WARNING, \"unexpected attrdef record found for attr %d of rel %s\",\n\t\t\t\t adform->adnum, RelationGetRelationName(relation));\n\t}\n\n\tsystable_endscan(adscan);\n\theap_close(adrel, AccessShareLock);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "adrel",
            "AccessShareLock"
          ],
          "line": 4028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan",
          "args": [
            "adscan"
          ],
          "line": 4027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"unexpected attrdef record found for attr %d of rel %s\"",
            "adform->adnum",
            "RelationGetRelationName(relation)"
          ],
          "line": 4023
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "relation"
          ],
          "line": 4024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "s"
          ],
          "line": 4017
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextStrdup",
          "args": [
            "CacheMemoryContext",
            "s"
          ],
          "line": 4016
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextStrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1147-1158",
          "snippet": "char *\nMemoryContextStrdup(MemoryContext context, const char *string)\n{\n\tchar\t   *nstr;\n\tSize\t\tlen = strlen(string) + 1;\n\n\tnstr = (char *) MemoryContextAlloc(context, len);\n\n\tmemcpy(nstr, string, len);\n\n\treturn nstr;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nchar *\nMemoryContextStrdup(MemoryContext context, const char *string)\n{\n\tchar\t   *nstr;\n\tSize\t\tlen = strlen(string) + 1;\n\n\tnstr = (char *) MemoryContextAlloc(context, len);\n\n\tmemcpy(nstr, string, len);\n\n\treturn nstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "val"
          ],
          "line": 4014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "relation"
          ],
          "line": 4010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "attr->attname"
          ],
          "line": 4009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fastgetattr",
          "args": [
            "htup",
            "Anum_pg_attrdef_adbin",
            "adrel->rd_att",
            "&isnull"
          ],
          "line": 4004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "relation"
          ],
          "line": 4000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "attr->attname"
          ],
          "line": 3999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "relation->rd_att",
            "adform->adnum - 1"
          ],
          "line": 3991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "htup"
          ],
          "line": 3990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "htup = systable_getnext(adscan)"
          ],
          "line": 3988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext",
          "args": [
            "adscan"
          ],
          "line": 3988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_beginscan",
          "args": [
            "adrel",
            "AttrDefaultIndexId",
            "true",
            "NULL",
            "1",
            "&skey"
          ],
          "line": 3984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "AttrDefaultRelationId",
            "AccessShareLock"
          ],
          "line": 3983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyInit",
          "args": [
            "&skey",
            "Anum_pg_attrdef_adrelid",
            "BTEqualStrategyNumber",
            "F_OIDEQ",
            "ObjectIdGetDatum(RelationGetRelid(relation))"
          ],
          "line": 3978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "RelationGetRelid(relation)"
          ],
          "line": 3981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 3981
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nAttrDefaultFetch(Relation relation)\n{\n\tAttrDefault *attrdef = relation->rd_att->constr->defval;\n\tint\t\t\tndef = relation->rd_att->constr->num_defval;\n\tRelation\tadrel;\n\tSysScanDesc adscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tint\t\t\tfound;\n\tint\t\t\ti;\n\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_attrdef_adrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tadrel = heap_open(AttrDefaultRelationId, AccessShareLock);\n\tadscan = systable_beginscan(adrel, AttrDefaultIndexId, true,\n\t\t\t\t\t\t\t\tNULL, 1, &skey);\n\tfound = 0;\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(adscan)))\n\t{\n\t\tForm_pg_attrdef adform = (Form_pg_attrdef) GETSTRUCT(htup);\n\t\tForm_pg_attribute attr = TupleDescAttr(relation->rd_att, adform->adnum - 1);\n\n\t\tfor (i = 0; i < ndef; i++)\n\t\t{\n\t\t\tif (adform->adnum != attrdef[i].adnum)\n\t\t\t\tcontinue;\n\t\t\tif (attrdef[i].adbin != NULL)\n\t\t\t\telog(WARNING, \"multiple attrdef records found for attr %s of rel %s\",\n\t\t\t\t\t NameStr(attr->attname),\n\t\t\t\t\t RelationGetRelationName(relation));\n\t\t\telse\n\t\t\t\tfound++;\n\n\t\t\tval = fastgetattr(htup,\n\t\t\t\t\t\t\t  Anum_pg_attrdef_adbin,\n\t\t\t\t\t\t\t  adrel->rd_att, &isnull);\n\t\t\tif (isnull)\n\t\t\t\telog(WARNING, \"null adbin for attr %s of rel %s\",\n\t\t\t\t\t NameStr(attr->attname),\n\t\t\t\t\t RelationGetRelationName(relation));\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* detoast and convert to cstring in caller's context */\n\t\t\t\tchar\t   *s = TextDatumGetCString(val);\n\n\t\t\t\tattrdef[i].adbin = MemoryContextStrdup(CacheMemoryContext, s);\n\t\t\t\tpfree(s);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i >= ndef)\n\t\t\telog(WARNING, \"unexpected attrdef record found for attr %d of rel %s\",\n\t\t\t\t adform->adnum, RelationGetRelationName(relation));\n\t}\n\n\tsystable_endscan(adscan);\n\theap_close(adrel, AccessShareLock);\n}"
  },
  {
    "function_name": "GetPgIndexDescriptor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "3947-3959",
    "snippet": "static TupleDesc\nGetPgIndexDescriptor(void)\n{\n\tstatic TupleDesc pgindexdesc = NULL;\n\n\t/* Already done? */\n\tif (pgindexdesc == NULL)\n\t\tpgindexdesc = BuildHardcodedDescriptor(Natts_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   Desc_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   false);\n\n\treturn pgindexdesc;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const FormData_pg_attribute Desc_pg_index[Natts_pg_index] = {Schema_pg_index};",
      "static TupleDesc GetPgIndexDescriptor(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BuildHardcodedDescriptor",
          "args": [
            "Natts_pg_index",
            "Desc_pg_index",
            "false"
          ],
          "line": 3954
        },
        "resolved": true,
        "details": {
          "function_name": "BuildHardcodedDescriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "3902-3931",
          "snippet": "static TupleDesc\nBuildHardcodedDescriptor(int natts, const FormData_pg_attribute *attrs,\n\t\t\t\t\t\t bool hasoids)\n{\n\tTupleDesc\tresult;\n\tMemoryContext oldcxt;\n\tint\t\t\ti;\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\tresult = CreateTemplateTupleDesc(natts, hasoids);\n\tresult->tdtypeid = RECORDOID;\t/* not right, but we don't care */\n\tresult->tdtypmod = -1;\n\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tmemcpy(TupleDescAttr(result, i), &attrs[i], ATTRIBUTE_FIXED_PART_SIZE);\n\t\t/* make sure attcacheoff is valid */\n\t\tTupleDescAttr(result, i)->attcacheoff = -1;\n\t}\n\n\t/* initialize first attribute's attcacheoff, cf RelationBuildTupleDesc */\n\tTupleDescAttr(result, 0)->attcacheoff = 0;\n\n\t/* Note: we don't bother to set up a TupleConstr entry */\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void formrdesc(const char *relationName, Oid relationReltype,\n\t\t  bool isshared, bool hasoids,\n\t\t  int natts, const FormData_pg_attribute *attrs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void formrdesc(const char *relationName, Oid relationReltype,\n\t\t  bool isshared, bool hasoids,\n\t\t  int natts, const FormData_pg_attribute *attrs);\n\nstatic TupleDesc\nBuildHardcodedDescriptor(int natts, const FormData_pg_attribute *attrs,\n\t\t\t\t\t\t bool hasoids)\n{\n\tTupleDesc\tresult;\n\tMemoryContext oldcxt;\n\tint\t\t\ti;\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\tresult = CreateTemplateTupleDesc(natts, hasoids);\n\tresult->tdtypeid = RECORDOID;\t/* not right, but we don't care */\n\tresult->tdtypmod = -1;\n\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tmemcpy(TupleDescAttr(result, i), &attrs[i], ATTRIBUTE_FIXED_PART_SIZE);\n\t\t/* make sure attcacheoff is valid */\n\t\tTupleDescAttr(result, i)->attcacheoff = -1;\n\t}\n\n\t/* initialize first attribute's attcacheoff, cf RelationBuildTupleDesc */\n\tTupleDescAttr(result, 0)->attcacheoff = 0;\n\n\t/* Note: we don't bother to set up a TupleConstr entry */\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic const FormData_pg_attribute Desc_pg_index[Natts_pg_index] = {Schema_pg_index};\nstatic TupleDesc GetPgIndexDescriptor(void);\n\nstatic TupleDesc\nGetPgIndexDescriptor(void)\n{\n\tstatic TupleDesc pgindexdesc = NULL;\n\n\t/* Already done? */\n\tif (pgindexdesc == NULL)\n\t\tpgindexdesc = BuildHardcodedDescriptor(Natts_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   Desc_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   false);\n\n\treturn pgindexdesc;\n}"
  },
  {
    "function_name": "GetPgClassDescriptor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "3933-3945",
    "snippet": "static TupleDesc\nGetPgClassDescriptor(void)\n{\n\tstatic TupleDesc pgclassdesc = NULL;\n\n\t/* Already done? */\n\tif (pgclassdesc == NULL)\n\t\tpgclassdesc = BuildHardcodedDescriptor(Natts_pg_class,\n\t\t\t\t\t\t\t\t\t\t\t   Desc_pg_class,\n\t\t\t\t\t\t\t\t\t\t\t   true);\n\n\treturn pgclassdesc;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const FormData_pg_attribute Desc_pg_class[Natts_pg_class] = {Schema_pg_class};",
      "static TupleDesc GetPgClassDescriptor(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BuildHardcodedDescriptor",
          "args": [
            "Natts_pg_class",
            "Desc_pg_class",
            "true"
          ],
          "line": 3940
        },
        "resolved": true,
        "details": {
          "function_name": "BuildHardcodedDescriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "3902-3931",
          "snippet": "static TupleDesc\nBuildHardcodedDescriptor(int natts, const FormData_pg_attribute *attrs,\n\t\t\t\t\t\t bool hasoids)\n{\n\tTupleDesc\tresult;\n\tMemoryContext oldcxt;\n\tint\t\t\ti;\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\tresult = CreateTemplateTupleDesc(natts, hasoids);\n\tresult->tdtypeid = RECORDOID;\t/* not right, but we don't care */\n\tresult->tdtypmod = -1;\n\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tmemcpy(TupleDescAttr(result, i), &attrs[i], ATTRIBUTE_FIXED_PART_SIZE);\n\t\t/* make sure attcacheoff is valid */\n\t\tTupleDescAttr(result, i)->attcacheoff = -1;\n\t}\n\n\t/* initialize first attribute's attcacheoff, cf RelationBuildTupleDesc */\n\tTupleDescAttr(result, 0)->attcacheoff = 0;\n\n\t/* Note: we don't bother to set up a TupleConstr entry */\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void formrdesc(const char *relationName, Oid relationReltype,\n\t\t  bool isshared, bool hasoids,\n\t\t  int natts, const FormData_pg_attribute *attrs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void formrdesc(const char *relationName, Oid relationReltype,\n\t\t  bool isshared, bool hasoids,\n\t\t  int natts, const FormData_pg_attribute *attrs);\n\nstatic TupleDesc\nBuildHardcodedDescriptor(int natts, const FormData_pg_attribute *attrs,\n\t\t\t\t\t\t bool hasoids)\n{\n\tTupleDesc\tresult;\n\tMemoryContext oldcxt;\n\tint\t\t\ti;\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\tresult = CreateTemplateTupleDesc(natts, hasoids);\n\tresult->tdtypeid = RECORDOID;\t/* not right, but we don't care */\n\tresult->tdtypmod = -1;\n\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tmemcpy(TupleDescAttr(result, i), &attrs[i], ATTRIBUTE_FIXED_PART_SIZE);\n\t\t/* make sure attcacheoff is valid */\n\t\tTupleDescAttr(result, i)->attcacheoff = -1;\n\t}\n\n\t/* initialize first attribute's attcacheoff, cf RelationBuildTupleDesc */\n\tTupleDescAttr(result, 0)->attcacheoff = 0;\n\n\t/* Note: we don't bother to set up a TupleConstr entry */\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic const FormData_pg_attribute Desc_pg_class[Natts_pg_class] = {Schema_pg_class};\nstatic TupleDesc GetPgClassDescriptor(void);\n\nstatic TupleDesc\nGetPgClassDescriptor(void)\n{\n\tstatic TupleDesc pgclassdesc = NULL;\n\n\t/* Already done? */\n\tif (pgclassdesc == NULL)\n\t\tpgclassdesc = BuildHardcodedDescriptor(Natts_pg_class,\n\t\t\t\t\t\t\t\t\t\t\t   Desc_pg_class,\n\t\t\t\t\t\t\t\t\t\t\t   true);\n\n\treturn pgclassdesc;\n}"
  },
  {
    "function_name": "BuildHardcodedDescriptor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "3902-3931",
    "snippet": "static TupleDesc\nBuildHardcodedDescriptor(int natts, const FormData_pg_attribute *attrs,\n\t\t\t\t\t\t bool hasoids)\n{\n\tTupleDesc\tresult;\n\tMemoryContext oldcxt;\n\tint\t\t\ti;\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\tresult = CreateTemplateTupleDesc(natts, hasoids);\n\tresult->tdtypeid = RECORDOID;\t/* not right, but we don't care */\n\tresult->tdtypmod = -1;\n\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tmemcpy(TupleDescAttr(result, i), &attrs[i], ATTRIBUTE_FIXED_PART_SIZE);\n\t\t/* make sure attcacheoff is valid */\n\t\tTupleDescAttr(result, i)->attcacheoff = -1;\n\t}\n\n\t/* initialize first attribute's attcacheoff, cf RelationBuildTupleDesc */\n\tTupleDescAttr(result, 0)->attcacheoff = 0;\n\n\t/* Note: we don't bother to set up a TupleConstr entry */\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void formrdesc(const char *relationName, Oid relationReltype,\n\t\t  bool isshared, bool hasoids,\n\t\t  int natts, const FormData_pg_attribute *attrs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 3928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "result",
            "0"
          ],
          "line": 3924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "result",
            "i"
          ],
          "line": 3920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "TupleDescAttr(result, i)",
            "&attrs[i]",
            "ATTRIBUTE_FIXED_PART_SIZE"
          ],
          "line": 3918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "result",
            "i"
          ],
          "line": 3918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTemplateTupleDesc",
          "args": [
            "natts",
            "hasoids"
          ],
          "line": 3912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 3910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void formrdesc(const char *relationName, Oid relationReltype,\n\t\t  bool isshared, bool hasoids,\n\t\t  int natts, const FormData_pg_attribute *attrs);\n\nstatic TupleDesc\nBuildHardcodedDescriptor(int natts, const FormData_pg_attribute *attrs,\n\t\t\t\t\t\t bool hasoids)\n{\n\tTupleDesc\tresult;\n\tMemoryContext oldcxt;\n\tint\t\t\ti;\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\tresult = CreateTemplateTupleDesc(natts, hasoids);\n\tresult->tdtypeid = RECORDOID;\t/* not right, but we don't care */\n\tresult->tdtypmod = -1;\n\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tmemcpy(TupleDescAttr(result, i), &attrs[i], ATTRIBUTE_FIXED_PART_SIZE);\n\t\t/* make sure attcacheoff is valid */\n\t\tTupleDescAttr(result, i)->attcacheoff = -1;\n\t}\n\n\t/* initialize first attribute's attcacheoff, cf RelationBuildTupleDesc */\n\tTupleDescAttr(result, 0)->attcacheoff = 0;\n\n\t/* Note: we don't bother to set up a TupleConstr entry */\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn result;\n}"
  },
  {
    "function_name": "load_critical_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "3868-3888",
    "snippet": "static void\nload_critical_index(Oid indexoid, Oid heapoid)\n{\n\tRelation\tird;\n\n\t/*\n\t * We must lock the underlying catalog before locking the index to avoid\n\t * deadlock, since RelationBuildDesc might well need to read the catalog,\n\t * and if anyone else is exclusive-locking this catalog and index they'll\n\t * be doing it in that order.\n\t */\n\tLockRelationOid(heapoid, AccessShareLock);\n\tLockRelationOid(indexoid, AccessShareLock);\n\tird = RelationBuildDesc(indexoid, true);\n\tif (ird == NULL)\n\t\telog(PANIC, \"could not open critical system index %u\", indexoid);\n\tird->rd_isnailed = true;\n\tird->rd_refcnt = 1;\n\tUnlockRelationOid(indexoid, AccessShareLock);\n\tUnlockRelationOid(heapoid, AccessShareLock);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void load_critical_index(Oid indexoid, Oid heapoid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UnlockRelationOid",
          "args": [
            "heapoid",
            "AccessShareLock"
          ],
          "line": 3887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UnlockRelationOid",
          "args": [
            "indexoid",
            "AccessShareLock"
          ],
          "line": 3886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "PANIC",
            "\"could not open critical system index %u\"",
            "indexoid"
          ],
          "line": 3883
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationBuildDesc",
          "args": [
            "indexoid",
            "true"
          ],
          "line": 3881
        },
        "resolved": true,
        "details": {
          "function_name": "RelationBuildDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1070-1250",
          "snippet": "static Relation\nRelationBuildDesc(Oid targetRelId, bool insertIt)\n{\n\tRelation\trelation;\n\tOid\t\t\trelid;\n\tHeapTuple\tpg_class_tuple;\n\tForm_pg_class relp;\n\n\t/*\n\t * find the tuple in pg_class corresponding to the given relation id\n\t */\n\tpg_class_tuple = ScanPgRelation(targetRelId, true, false);\n\n\t/*\n\t * if no such tuple exists, return NULL\n\t */\n\tif (!HeapTupleIsValid(pg_class_tuple))\n\t\treturn NULL;\n\n\t/*\n\t * get information from the pg_class_tuple\n\t */\n\trelid = HeapTupleGetOid(pg_class_tuple);\n\trelp = (Form_pg_class) GETSTRUCT(pg_class_tuple);\n\tAssert(relid == targetRelId);\n\n\t/*\n\t * allocate storage for the relation descriptor, and copy pg_class_tuple\n\t * to relation->rd_rel.\n\t */\n\trelation = AllocateRelationDesc(relp);\n\n\t/*\n\t * initialize the relation's relation id (relation->rd_id)\n\t */\n\tRelationGetRelid(relation) = relid;\n\n\t/*\n\t * normal relations are not nailed into the cache; nor can a pre-existing\n\t * relation be new.  It could be temp though.  (Actually, it could be new\n\t * too, but it's okay to forget that fact if forced to flush the entry.)\n\t */\n\trelation->rd_refcnt = 0;\n\trelation->rd_isnailed = false;\n\trelation->rd_createSubid = InvalidSubTransactionId;\n\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\tswitch (relation->rd_rel->relpersistence)\n\t{\n\t\tcase RELPERSISTENCE_UNLOGGED:\n\t\tcase RELPERSISTENCE_PERMANENT:\n\t\t\trelation->rd_backend = InvalidBackendId;\n\t\t\trelation->rd_islocaltemp = false;\n\t\t\tbreak;\n\t\tcase RELPERSISTENCE_TEMP:\n\t\t\tif (isTempOrTempToastNamespace(relation->rd_rel->relnamespace))\n\t\t\t{\n\t\t\t\trelation->rd_backend = BackendIdForTempRelations();\n\t\t\t\trelation->rd_islocaltemp = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If it's a temp table, but not one of ours, we have to use\n\t\t\t\t * the slow, grotty method to figure out the owning backend.\n\t\t\t\t *\n\t\t\t\t * Note: it's possible that rd_backend gets set to MyBackendId\n\t\t\t\t * here, in case we are looking at a pg_class entry left over\n\t\t\t\t * from a crashed backend that coincidentally had the same\n\t\t\t\t * BackendId we're using.  We should *not* consider such a\n\t\t\t\t * table to be \"ours\"; this is why we need the separate\n\t\t\t\t * rd_islocaltemp flag.  The pg_class entry will get flushed\n\t\t\t\t * if/when we clean out the corresponding temp table namespace\n\t\t\t\t * in preparation for using it.\n\t\t\t\t */\n\t\t\t\trelation->rd_backend =\n\t\t\t\t\tGetTempNamespaceBackendId(relation->rd_rel->relnamespace);\n\t\t\t\tAssert(relation->rd_backend != InvalidBackendId);\n\t\t\t\trelation->rd_islocaltemp = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid relpersistence: %c\",\n\t\t\t\t relation->rd_rel->relpersistence);\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * initialize the tuple descriptor (relation->rd_att).\n\t */\n\tRelationBuildTupleDesc(relation);\n\n\t/*\n\t * Fetch rules and triggers that affect this relation\n\t */\n\tif (relation->rd_rel->relhasrules)\n\t\tRelationBuildRuleLock(relation);\n\telse\n\t{\n\t\trelation->rd_rules = NULL;\n\t\trelation->rd_rulescxt = NULL;\n\t}\n\n\tif (relation->rd_rel->relhastriggers)\n\t\tRelationBuildTriggers(relation);\n\telse\n\t\trelation->trigdesc = NULL;\n\n\tif (relation->rd_rel->relrowsecurity)\n\t\tRelationBuildRowSecurity(relation);\n\telse\n\t\trelation->rd_rsdesc = NULL;\n\n\t/* foreign key data is not loaded till asked for */\n\trelation->rd_fkeylist = NIL;\n\trelation->rd_fkeyvalid = false;\n\n\t/* if a partitioned table, initialize key and partition descriptor info */\n\tif (relation->rd_rel->relkind == RELKIND_PARTITIONED_TABLE)\n\t{\n\t\tRelationBuildPartitionKey(relation);\n\t\tRelationBuildPartitionDesc(relation);\n\t}\n\telse\n\t{\n\t\trelation->rd_partkey = NULL;\n\t\trelation->rd_partkeycxt = NULL;\n\t\trelation->rd_partdesc = NULL;\n\t\trelation->rd_pdcxt = NULL;\n\t}\n\t/* ... but partcheck is not loaded till asked for */\n\trelation->rd_partcheck = NIL;\n\trelation->rd_partcheckvalid = false;\n\trelation->rd_partcheckcxt = NULL;\n\n\t/*\n\t * if it's an index, initialize index-related information\n\t */\n\tif (OidIsValid(relation->rd_rel->relam))\n\t\tRelationInitIndexAccessInfo(relation);\n\n\t/* extract reloptions if any */\n\tRelationParseRelOptions(relation, pg_class_tuple);\n\n\t/*\n\t * initialize the relation lock manager information\n\t */\n\tRelationInitLockInfo(relation); /* see lmgr.c */\n\n\t/*\n\t * initialize physical addressing information for the relation\n\t */\n\tRelationInitPhysicalAddr(relation);\n\n\t/* make sure relation is marked as having no open file yet */\n\trelation->rd_smgr = NULL;\n\n\t/*\n\t * now we can free the memory allocated for pg_class_tuple\n\t */\n\theap_freetuple(pg_class_tuple);\n\n\t/*\n\t * Insert newly created relation into relcache hash table, if requested.\n\t *\n\t * There is one scenario in which we might find a hashtable entry already\n\t * present, even though our caller failed to find it: if the relation is a\n\t * system catalog or index that's used during relcache load, we might have\n\t * recursively created the same relcache entry during the preceding steps.\n\t * So allow RelationCacheInsert to delete any already-present relcache\n\t * entry for the same OID.  The already-present entry should have refcount\n\t * zero (else somebody forgot to close it); in the event that it doesn't,\n\t * we'll elog a WARNING and leak the already-present entry.\n\t */\n\tif (insertIt)\n\t\tRelationCacheInsert(relation, true);\n\n\t/* It's fully valid */\n\trelation->rd_isvalid = true;\n\n\treturn relation;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static Relation AllocateRelationDesc(Form_pg_class relp);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static Relation RelationBuildDesc(Oid targetRelId, bool insertIt);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic Relation AllocateRelationDesc(Form_pg_class relp);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic Relation RelationBuildDesc(Oid targetRelId, bool insertIt);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic Relation\nRelationBuildDesc(Oid targetRelId, bool insertIt)\n{\n\tRelation\trelation;\n\tOid\t\t\trelid;\n\tHeapTuple\tpg_class_tuple;\n\tForm_pg_class relp;\n\n\t/*\n\t * find the tuple in pg_class corresponding to the given relation id\n\t */\n\tpg_class_tuple = ScanPgRelation(targetRelId, true, false);\n\n\t/*\n\t * if no such tuple exists, return NULL\n\t */\n\tif (!HeapTupleIsValid(pg_class_tuple))\n\t\treturn NULL;\n\n\t/*\n\t * get information from the pg_class_tuple\n\t */\n\trelid = HeapTupleGetOid(pg_class_tuple);\n\trelp = (Form_pg_class) GETSTRUCT(pg_class_tuple);\n\tAssert(relid == targetRelId);\n\n\t/*\n\t * allocate storage for the relation descriptor, and copy pg_class_tuple\n\t * to relation->rd_rel.\n\t */\n\trelation = AllocateRelationDesc(relp);\n\n\t/*\n\t * initialize the relation's relation id (relation->rd_id)\n\t */\n\tRelationGetRelid(relation) = relid;\n\n\t/*\n\t * normal relations are not nailed into the cache; nor can a pre-existing\n\t * relation be new.  It could be temp though.  (Actually, it could be new\n\t * too, but it's okay to forget that fact if forced to flush the entry.)\n\t */\n\trelation->rd_refcnt = 0;\n\trelation->rd_isnailed = false;\n\trelation->rd_createSubid = InvalidSubTransactionId;\n\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\tswitch (relation->rd_rel->relpersistence)\n\t{\n\t\tcase RELPERSISTENCE_UNLOGGED:\n\t\tcase RELPERSISTENCE_PERMANENT:\n\t\t\trelation->rd_backend = InvalidBackendId;\n\t\t\trelation->rd_islocaltemp = false;\n\t\t\tbreak;\n\t\tcase RELPERSISTENCE_TEMP:\n\t\t\tif (isTempOrTempToastNamespace(relation->rd_rel->relnamespace))\n\t\t\t{\n\t\t\t\trelation->rd_backend = BackendIdForTempRelations();\n\t\t\t\trelation->rd_islocaltemp = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If it's a temp table, but not one of ours, we have to use\n\t\t\t\t * the slow, grotty method to figure out the owning backend.\n\t\t\t\t *\n\t\t\t\t * Note: it's possible that rd_backend gets set to MyBackendId\n\t\t\t\t * here, in case we are looking at a pg_class entry left over\n\t\t\t\t * from a crashed backend that coincidentally had the same\n\t\t\t\t * BackendId we're using.  We should *not* consider such a\n\t\t\t\t * table to be \"ours\"; this is why we need the separate\n\t\t\t\t * rd_islocaltemp flag.  The pg_class entry will get flushed\n\t\t\t\t * if/when we clean out the corresponding temp table namespace\n\t\t\t\t * in preparation for using it.\n\t\t\t\t */\n\t\t\t\trelation->rd_backend =\n\t\t\t\t\tGetTempNamespaceBackendId(relation->rd_rel->relnamespace);\n\t\t\t\tAssert(relation->rd_backend != InvalidBackendId);\n\t\t\t\trelation->rd_islocaltemp = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid relpersistence: %c\",\n\t\t\t\t relation->rd_rel->relpersistence);\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * initialize the tuple descriptor (relation->rd_att).\n\t */\n\tRelationBuildTupleDesc(relation);\n\n\t/*\n\t * Fetch rules and triggers that affect this relation\n\t */\n\tif (relation->rd_rel->relhasrules)\n\t\tRelationBuildRuleLock(relation);\n\telse\n\t{\n\t\trelation->rd_rules = NULL;\n\t\trelation->rd_rulescxt = NULL;\n\t}\n\n\tif (relation->rd_rel->relhastriggers)\n\t\tRelationBuildTriggers(relation);\n\telse\n\t\trelation->trigdesc = NULL;\n\n\tif (relation->rd_rel->relrowsecurity)\n\t\tRelationBuildRowSecurity(relation);\n\telse\n\t\trelation->rd_rsdesc = NULL;\n\n\t/* foreign key data is not loaded till asked for */\n\trelation->rd_fkeylist = NIL;\n\trelation->rd_fkeyvalid = false;\n\n\t/* if a partitioned table, initialize key and partition descriptor info */\n\tif (relation->rd_rel->relkind == RELKIND_PARTITIONED_TABLE)\n\t{\n\t\tRelationBuildPartitionKey(relation);\n\t\tRelationBuildPartitionDesc(relation);\n\t}\n\telse\n\t{\n\t\trelation->rd_partkey = NULL;\n\t\trelation->rd_partkeycxt = NULL;\n\t\trelation->rd_partdesc = NULL;\n\t\trelation->rd_pdcxt = NULL;\n\t}\n\t/* ... but partcheck is not loaded till asked for */\n\trelation->rd_partcheck = NIL;\n\trelation->rd_partcheckvalid = false;\n\trelation->rd_partcheckcxt = NULL;\n\n\t/*\n\t * if it's an index, initialize index-related information\n\t */\n\tif (OidIsValid(relation->rd_rel->relam))\n\t\tRelationInitIndexAccessInfo(relation);\n\n\t/* extract reloptions if any */\n\tRelationParseRelOptions(relation, pg_class_tuple);\n\n\t/*\n\t * initialize the relation lock manager information\n\t */\n\tRelationInitLockInfo(relation); /* see lmgr.c */\n\n\t/*\n\t * initialize physical addressing information for the relation\n\t */\n\tRelationInitPhysicalAddr(relation);\n\n\t/* make sure relation is marked as having no open file yet */\n\trelation->rd_smgr = NULL;\n\n\t/*\n\t * now we can free the memory allocated for pg_class_tuple\n\t */\n\theap_freetuple(pg_class_tuple);\n\n\t/*\n\t * Insert newly created relation into relcache hash table, if requested.\n\t *\n\t * There is one scenario in which we might find a hashtable entry already\n\t * present, even though our caller failed to find it: if the relation is a\n\t * system catalog or index that's used during relcache load, we might have\n\t * recursively created the same relcache entry during the preceding steps.\n\t * So allow RelationCacheInsert to delete any already-present relcache\n\t * entry for the same OID.  The already-present entry should have refcount\n\t * zero (else somebody forgot to close it); in the event that it doesn't,\n\t * we'll elog a WARNING and leak the already-present entry.\n\t */\n\tif (insertIt)\n\t\tRelationCacheInsert(relation, true);\n\n\t/* It's fully valid */\n\trelation->rd_isvalid = true;\n\n\treturn relation;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LockRelationOid",
          "args": [
            "indexoid",
            "AccessShareLock"
          ],
          "line": 3880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LockRelationOid",
          "args": [
            "heapoid",
            "AccessShareLock"
          ],
          "line": 3879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void load_critical_index(Oid indexoid, Oid heapoid);\n\nstatic void\nload_critical_index(Oid indexoid, Oid heapoid)\n{\n\tRelation\tird;\n\n\t/*\n\t * We must lock the underlying catalog before locking the index to avoid\n\t * deadlock, since RelationBuildDesc might well need to read the catalog,\n\t * and if anyone else is exclusive-locking this catalog and index they'll\n\t * be doing it in that order.\n\t */\n\tLockRelationOid(heapoid, AccessShareLock);\n\tLockRelationOid(indexoid, AccessShareLock);\n\tird = RelationBuildDesc(indexoid, true);\n\tif (ird == NULL)\n\t\telog(PANIC, \"could not open critical system index %u\", indexoid);\n\tird->rd_isnailed = true;\n\tird->rd_refcnt = 1;\n\tUnlockRelationOid(indexoid, AccessShareLock);\n\tUnlockRelationOid(heapoid, AccessShareLock);\n}"
  },
  {
    "function_name": "RelationCacheInitializePhase3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "3573-3860",
    "snippet": "void\nRelationCacheInitializePhase3(void)\n{\n\tHASH_SEQ_STATUS status;\n\tRelIdCacheEnt *idhentry;\n\tMemoryContext oldcxt;\n\tbool\t\tneedNewCacheFile = !criticalSharedRelcachesBuilt;\n\n\t/*\n\t * relation mapper needs initialized too\n\t */\n\tRelationMapInitializePhase3();\n\n\t/*\n\t * switch to cache memory context\n\t */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * Try to load the local relcache cache file.  If unsuccessful, bootstrap\n\t * the cache with pre-made descriptors for the critical \"nailed-in\" system\n\t * catalogs.\n\t */\n\tif (IsBootstrapProcessingMode() ||\n\t\t!load_relcache_init_file(false))\n\t{\n\t\tneedNewCacheFile = true;\n\n\t\tformrdesc(\"pg_class\", RelationRelation_Rowtype_Id, false,\n\t\t\t\t  true, Natts_pg_class, Desc_pg_class);\n\t\tformrdesc(\"pg_attribute\", AttributeRelation_Rowtype_Id, false,\n\t\t\t\t  false, Natts_pg_attribute, Desc_pg_attribute);\n\t\tformrdesc(\"pg_proc\", ProcedureRelation_Rowtype_Id, false,\n\t\t\t\t  true, Natts_pg_proc, Desc_pg_proc);\n\t\tformrdesc(\"pg_type\", TypeRelation_Rowtype_Id, false,\n\t\t\t\t  true, Natts_pg_type, Desc_pg_type);\n\n#define NUM_CRITICAL_LOCAL_RELS 4\t/* fix if you change list above */\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* In bootstrap mode, the faked-up formrdesc info is all we'll have */\n\tif (IsBootstrapProcessingMode())\n\t\treturn;\n\n\t/*\n\t * If we didn't get the critical system indexes loaded into relcache, do\n\t * so now.  These are critical because the catcache and/or opclass cache\n\t * depend on them for fetches done during relcache load.  Thus, we have an\n\t * infinite-recursion problem.  We can break the recursion by doing\n\t * heapscans instead of indexscans at certain key spots. To avoid hobbling\n\t * performance, we only want to do that until we have the critical indexes\n\t * loaded into relcache.  Thus, the flag criticalRelcachesBuilt is used to\n\t * decide whether to do heapscan or indexscan at the key spots, and we set\n\t * it true after we've loaded the critical indexes.\n\t *\n\t * The critical indexes are marked as \"nailed in cache\", partly to make it\n\t * easy for load_relcache_init_file to count them, but mainly because we\n\t * cannot flush and rebuild them once we've set criticalRelcachesBuilt to\n\t * true.  (NOTE: perhaps it would be possible to reload them by\n\t * temporarily setting criticalRelcachesBuilt to false again.  For now,\n\t * though, we just nail 'em in.)\n\t *\n\t * RewriteRelRulenameIndexId and TriggerRelidNameIndexId are not critical\n\t * in the same way as the others, because the critical catalogs don't\n\t * (currently) have any rules or triggers, and so these indexes can be\n\t * rebuilt without inducing recursion.  However they are used during\n\t * relcache load when a rel does have rules or triggers, so we choose to\n\t * nail them for performance reasons.\n\t */\n\tif (!criticalRelcachesBuilt)\n\t{\n\t\tload_critical_index(ClassOidIndexId,\n\t\t\t\t\t\t\tRelationRelationId);\n\t\tload_critical_index(AttributeRelidNumIndexId,\n\t\t\t\t\t\t\tAttributeRelationId);\n\t\tload_critical_index(IndexRelidIndexId,\n\t\t\t\t\t\t\tIndexRelationId);\n\t\tload_critical_index(OpclassOidIndexId,\n\t\t\t\t\t\t\tOperatorClassRelationId);\n\t\tload_critical_index(AccessMethodProcedureIndexId,\n\t\t\t\t\t\t\tAccessMethodProcedureRelationId);\n\t\tload_critical_index(RewriteRelRulenameIndexId,\n\t\t\t\t\t\t\tRewriteRelationId);\n\t\tload_critical_index(TriggerRelidNameIndexId,\n\t\t\t\t\t\t\tTriggerRelationId);\n\n#define NUM_CRITICAL_LOCAL_INDEXES\t7\t/* fix if you change list above */\n\n\t\tcriticalRelcachesBuilt = true;\n\t}\n\n\t/*\n\t * Process critical shared indexes too.\n\t *\n\t * DatabaseNameIndexId isn't critical for relcache loading, but rather for\n\t * initial lookup of MyDatabaseId, without which we'll never find any\n\t * non-shared catalogs at all.  Autovacuum calls InitPostgres with a\n\t * database OID, so it instead depends on DatabaseOidIndexId.  We also\n\t * need to nail up some indexes on pg_authid and pg_auth_members for use\n\t * during client authentication.  SharedSecLabelObjectIndexId isn't\n\t * critical for the core system, but authentication hooks might be\n\t * interested in it.\n\t */\n\tif (!criticalSharedRelcachesBuilt)\n\t{\n\t\tload_critical_index(DatabaseNameIndexId,\n\t\t\t\t\t\t\tDatabaseRelationId);\n\t\tload_critical_index(DatabaseOidIndexId,\n\t\t\t\t\t\t\tDatabaseRelationId);\n\t\tload_critical_index(AuthIdRolnameIndexId,\n\t\t\t\t\t\t\tAuthIdRelationId);\n\t\tload_critical_index(AuthIdOidIndexId,\n\t\t\t\t\t\t\tAuthIdRelationId);\n\t\tload_critical_index(AuthMemMemRoleIndexId,\n\t\t\t\t\t\t\tAuthMemRelationId);\n\t\tload_critical_index(SharedSecLabelObjectIndexId,\n\t\t\t\t\t\t\tSharedSecLabelRelationId);\n\n#define NUM_CRITICAL_SHARED_INDEXES 6\t/* fix if you change list above */\n\n\t\tcriticalSharedRelcachesBuilt = true;\n\t}\n\n\t/*\n\t * Now, scan all the relcache entries and update anything that might be\n\t * wrong in the results from formrdesc or the relcache cache file. If we\n\t * faked up relcache entries using formrdesc, then read the real pg_class\n\t * rows and replace the fake entries with them. Also, if any of the\n\t * relcache entries have rules, triggers, or security policies, load that\n\t * info the hard way since it isn't recorded in the cache file.\n\t *\n\t * Whenever we access the catalogs to read data, there is a possibility of\n\t * a shared-inval cache flush causing relcache entries to be removed.\n\t * Since hash_seq_search only guarantees to still work after the *current*\n\t * entry is removed, it's unsafe to continue the hashtable scan afterward.\n\t * We handle this by restarting the scan from scratch after each access.\n\t * This is theoretically O(N^2), but the number of entries that actually\n\t * need to be fixed is small enough that it doesn't matter.\n\t */\n\thash_seq_init(&status, RelationIdCache);\n\n\twhile ((idhentry = (RelIdCacheEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tRelation\trelation = idhentry->reldesc;\n\t\tbool\t\trestart = false;\n\n\t\t/*\n\t\t * Make sure *this* entry doesn't get flushed while we work with it.\n\t\t */\n\t\tRelationIncrementReferenceCount(relation);\n\n\t\t/*\n\t\t * If it's a faked-up entry, read the real pg_class tuple.\n\t\t */\n\t\tif (relation->rd_rel->relowner == InvalidOid)\n\t\t{\n\t\t\tHeapTuple\thtup;\n\t\t\tForm_pg_class relp;\n\n\t\t\thtup = SearchSysCache1(RELOID,\n\t\t\t\t\t\t\t\t   ObjectIdGetDatum(RelationGetRelid(relation)));\n\t\t\tif (!HeapTupleIsValid(htup))\n\t\t\t\telog(FATAL, \"cache lookup failed for relation %u\",\n\t\t\t\t\t RelationGetRelid(relation));\n\t\t\trelp = (Form_pg_class) GETSTRUCT(htup);\n\n\t\t\t/*\n\t\t\t * Copy tuple to relation->rd_rel. (See notes in\n\t\t\t * AllocateRelationDesc())\n\t\t\t */\n\t\t\tmemcpy((char *) relation->rd_rel, (char *) relp, CLASS_TUPLE_SIZE);\n\n\t\t\t/* Update rd_options while we have the tuple */\n\t\t\tif (relation->rd_options)\n\t\t\t\tpfree(relation->rd_options);\n\t\t\tRelationParseRelOptions(relation, htup);\n\n\t\t\t/*\n\t\t\t * Check the values in rd_att were set up correctly.  (We cannot\n\t\t\t * just copy them over now: formrdesc must have set up the rd_att\n\t\t\t * data correctly to start with, because it may already have been\n\t\t\t * copied into one or more catcache entries.)\n\t\t\t */\n\t\t\tAssert(relation->rd_att->tdtypeid == relp->reltype);\n\t\t\tAssert(relation->rd_att->tdtypmod == -1);\n\t\t\tAssert(relation->rd_att->tdhasoid == relp->relhasoids);\n\n\t\t\tReleaseSysCache(htup);\n\n\t\t\t/* relowner had better be OK now, else we'll loop forever */\n\t\t\tif (relation->rd_rel->relowner == InvalidOid)\n\t\t\t\telog(ERROR, \"invalid relowner in pg_class entry for \\\"%s\\\"\",\n\t\t\t\t\t RelationGetRelationName(relation));\n\n\t\t\trestart = true;\n\t\t}\n\n\t\t/*\n\t\t * Fix data that isn't saved in relcache cache file.\n\t\t *\n\t\t * relhasrules or relhastriggers could possibly be wrong or out of\n\t\t * date.  If we don't actually find any rules or triggers, clear the\n\t\t * local copy of the flag so that we don't get into an infinite loop\n\t\t * here.  We don't make any attempt to fix the pg_class entry, though.\n\t\t */\n\t\tif (relation->rd_rel->relhasrules && relation->rd_rules == NULL)\n\t\t{\n\t\t\tRelationBuildRuleLock(relation);\n\t\t\tif (relation->rd_rules == NULL)\n\t\t\t\trelation->rd_rel->relhasrules = false;\n\t\t\trestart = true;\n\t\t}\n\t\tif (relation->rd_rel->relhastriggers && relation->trigdesc == NULL)\n\t\t{\n\t\t\tRelationBuildTriggers(relation);\n\t\t\tif (relation->trigdesc == NULL)\n\t\t\t\trelation->rd_rel->relhastriggers = false;\n\t\t\trestart = true;\n\t\t}\n\n\t\t/*\n\t\t * Re-load the row security policies if the relation has them, since\n\t\t * they are not preserved in the cache.  Note that we can never NOT\n\t\t * have a policy while relrowsecurity is true,\n\t\t * RelationBuildRowSecurity will create a single default-deny policy\n\t\t * if there is no policy defined in pg_policy.\n\t\t */\n\t\tif (relation->rd_rel->relrowsecurity && relation->rd_rsdesc == NULL)\n\t\t{\n\t\t\tRelationBuildRowSecurity(relation);\n\n\t\t\tAssert(relation->rd_rsdesc != NULL);\n\t\t\trestart = true;\n\t\t}\n\n\t\t/*\n\t\t * Reload the partition key and descriptor for a partitioned table.\n\t\t */\n\t\tif (relation->rd_rel->relkind == RELKIND_PARTITIONED_TABLE &&\n\t\t\trelation->rd_partkey == NULL)\n\t\t{\n\t\t\tRelationBuildPartitionKey(relation);\n\t\t\tAssert(relation->rd_partkey != NULL);\n\n\t\t\trestart = true;\n\t\t}\n\n\t\tif (relation->rd_rel->relkind == RELKIND_PARTITIONED_TABLE &&\n\t\t\trelation->rd_partdesc == NULL)\n\t\t{\n\t\t\tRelationBuildPartitionDesc(relation);\n\t\t\tAssert(relation->rd_partdesc != NULL);\n\n\t\t\trestart = true;\n\t\t}\n\n\t\t/* Release hold on the relation */\n\t\tRelationDecrementReferenceCount(relation);\n\n\t\t/* Now, restart the hashtable scan if needed */\n\t\tif (restart)\n\t\t{\n\t\t\thash_seq_term(&status);\n\t\t\thash_seq_init(&status, RelationIdCache);\n\t\t}\n\t}\n\n\t/*\n\t * Lastly, write out new relcache cache files if needed.  We don't bother\n\t * to distinguish cases where only one of the two needs an update.\n\t */\n\tif (needNewCacheFile)\n\t{\n\t\t/*\n\t\t * Force all the catcaches to finish initializing and thereby open the\n\t\t * catalogs and indexes they use.  This will preload the relcache with\n\t\t * entries for all the most important system catalogs and indexes, so\n\t\t * that the init files will be most useful for future backends.\n\t\t */\n\t\tInitCatalogCachePhase2();\n\n\t\t/* now write the files */\n\t\twrite_relcache_init_file(true);\n\t\twrite_relcache_init_file(false);\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NUM_CRITICAL_SHARED_INDEXES 6\t/* fix if you change list above */",
      "#define NUM_CRITICAL_LOCAL_INDEXES\t7\t/* fix if you change list above */",
      "#define NUM_CRITICAL_LOCAL_RELS 4\t/* fix if you change list above */"
    ],
    "globals_used": [
      "static const FormData_pg_attribute Desc_pg_class[Natts_pg_class] = {Schema_pg_class};",
      "static const FormData_pg_attribute Desc_pg_attribute[Natts_pg_attribute] = {Schema_pg_attribute};",
      "static const FormData_pg_attribute Desc_pg_proc[Natts_pg_proc] = {Schema_pg_proc};",
      "static const FormData_pg_attribute Desc_pg_type[Natts_pg_type] = {Schema_pg_type};",
      "static HTAB *RelationIdCache;",
      "bool\t\tcriticalRelcachesBuilt = false;",
      "bool\t\tcriticalSharedRelcachesBuilt = false;",
      "static void RelationClearRelation(Relation relation, bool rebuild);",
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static bool load_relcache_init_file(bool shared);",
      "static void write_relcache_init_file(bool shared);",
      "static Relation AllocateRelationDesc(Form_pg_class relp);",
      "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_relcache_init_file",
          "args": [
            "false"
          ],
          "line": 3858
        },
        "resolved": true,
        "details": {
          "function_name": "write_relcache_init_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "5793-5988",
          "snippet": "static void\nwrite_relcache_init_file(bool shared)\n{\n\tFILE\t   *fp;\n\tchar\t\ttempfilename[MAXPGPATH];\n\tchar\t\tfinalfilename[MAXPGPATH];\n\tint\t\t\tmagic;\n\tHASH_SEQ_STATUS status;\n\tRelIdCacheEnt *idhentry;\n\tint\t\t\ti;\n\n\t/*\n\t * If we have already received any relcache inval events, there's no\n\t * chance of succeeding so we may as well skip the whole thing.\n\t */\n\tif (relcacheInvalsReceived != 0L)\n\t\treturn;\n\n\t/*\n\t * We must write a temporary file and rename it into place. Otherwise,\n\t * another backend starting at about the same time might crash trying to\n\t * read the partially-complete file.\n\t */\n\tif (shared)\n\t{\n\t\tsnprintf(tempfilename, sizeof(tempfilename), \"global/%s.%d\",\n\t\t\t\t RELCACHE_INIT_FILENAME, MyProcPid);\n\t\tsnprintf(finalfilename, sizeof(finalfilename), \"global/%s\",\n\t\t\t\t RELCACHE_INIT_FILENAME);\n\t}\n\telse\n\t{\n\t\tsnprintf(tempfilename, sizeof(tempfilename), \"%s/%s.%d\",\n\t\t\t\t DatabasePath, RELCACHE_INIT_FILENAME, MyProcPid);\n\t\tsnprintf(finalfilename, sizeof(finalfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELCACHE_INIT_FILENAME);\n\t}\n\n\tunlink(tempfilename);\t\t/* in case it exists w/wrong permissions */\n\n\tfp = AllocateFile(tempfilename, PG_BINARY_W);\n\tif (fp == NULL)\n\t{\n\t\t/*\n\t\t * We used to consider this a fatal error, but we might as well\n\t\t * continue with backend startup ...\n\t\t */\n\t\tereport(WARNING,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not create relation-cache initialization file \\\"%s\\\": %m\",\n\t\t\t\t\t\ttempfilename),\n\t\t\t\t errdetail(\"Continuing anyway, but there's something wrong.\")));\n\t\treturn;\n\t}\n\n\t/*\n\t * Write a magic number to serve as a file version identifier.  We can\n\t * change the magic number whenever the relcache layout changes.\n\t */\n\tmagic = RELCACHE_INIT_FILEMAGIC;\n\tif (fwrite(&magic, 1, sizeof(magic), fp) != sizeof(magic))\n\t\telog(FATAL, \"could not write init file\");\n\n\t/*\n\t * Write all the appropriate reldescs (in no particular order).\n\t */\n\thash_seq_init(&status, RelationIdCache);\n\n\twhile ((idhentry = (RelIdCacheEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tRelation\trel = idhentry->reldesc;\n\t\tForm_pg_class relform = rel->rd_rel;\n\n\t\t/* ignore if not correct group */\n\t\tif (relform->relisshared != shared)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Ignore if not supposed to be in init file.  We can allow any shared\n\t\t * relation that's been loaded so far to be in the shared init file,\n\t\t * but unshared relations must be ones that should be in the local\n\t\t * file per RelationIdIsInInitFile.  (Note: if you want to change the\n\t\t * criterion for rels to be kept in the init file, see also inval.c.\n\t\t * The reason for filtering here is to be sure that we don't put\n\t\t * anything into the local init file for which a relcache inval would\n\t\t * not cause invalidation of that init file.)\n\t\t */\n\t\tif (!shared && !RelationIdIsInInitFile(RelationGetRelid(rel)))\n\t\t{\n\t\t\t/* Nailed rels had better get stored. */\n\t\t\tAssert(!rel->rd_isnailed);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* first write the relcache entry proper */\n\t\twrite_item(rel, sizeof(RelationData), fp);\n\n\t\t/* next write the relation tuple form */\n\t\twrite_item(relform, CLASS_TUPLE_SIZE, fp);\n\n\t\t/* next, do all the attribute tuple form data entries */\n\t\tfor (i = 0; i < relform->relnatts; i++)\n\t\t{\n\t\t\twrite_item(TupleDescAttr(rel->rd_att, i),\n\t\t\t\t\t   ATTRIBUTE_FIXED_PART_SIZE, fp);\n\t\t}\n\n\t\t/* next, do the access method specific field */\n\t\twrite_item(rel->rd_options,\n\t\t\t\t   (rel->rd_options ? VARSIZE(rel->rd_options) : 0),\n\t\t\t\t   fp);\n\n\t\t/*\n\t\t * If it's an index, there's more to do. Note we explicitly ignore\n\t\t * partitioned indexes here.\n\t\t */\n\t\tif (rel->rd_rel->relkind == RELKIND_INDEX)\n\t\t{\n\t\t\t/* write the pg_index tuple */\n\t\t\t/* we assume this was created by heap_copytuple! */\n\t\t\twrite_item(rel->rd_indextuple,\n\t\t\t\t\t   HEAPTUPLESIZE + rel->rd_indextuple->t_len,\n\t\t\t\t\t   fp);\n\n\t\t\t/* next, write the vector of opfamily OIDs */\n\t\t\twrite_item(rel->rd_opfamily,\n\t\t\t\t\t   relform->relnatts * sizeof(Oid),\n\t\t\t\t\t   fp);\n\n\t\t\t/* next, write the vector of opcintype OIDs */\n\t\t\twrite_item(rel->rd_opcintype,\n\t\t\t\t\t   relform->relnatts * sizeof(Oid),\n\t\t\t\t\t   fp);\n\n\t\t\t/* next, write the vector of support procedure OIDs */\n\t\t\twrite_item(rel->rd_support,\n\t\t\t\t\t   relform->relnatts * (rel->rd_amroutine->amsupport * sizeof(RegProcedure)),\n\t\t\t\t\t   fp);\n\n\t\t\t/* next, write the vector of collation OIDs */\n\t\t\twrite_item(rel->rd_indcollation,\n\t\t\t\t\t   relform->relnatts * sizeof(Oid),\n\t\t\t\t\t   fp);\n\n\t\t\t/* finally, write the vector of indoption values */\n\t\t\twrite_item(rel->rd_indoption,\n\t\t\t\t\t   relform->relnatts * sizeof(int16),\n\t\t\t\t\t   fp);\n\t\t}\n\t}\n\n\tif (FreeFile(fp))\n\t\telog(FATAL, \"could not write init file\");\n\n\t/*\n\t * Now we have to check whether the data we've so painstakingly\n\t * accumulated is already obsolete due to someone else's just-committed\n\t * catalog changes.  If so, we just delete the temp file and leave it to\n\t * the next backend to try again.  (Our own relcache entries will be\n\t * updated by SI message processing, but we can't be sure whether what we\n\t * wrote out was up-to-date.)\n\t *\n\t * This mustn't run concurrently with the code that unlinks an init file\n\t * and sends SI messages, so grab a serialization lock for the duration.\n\t */\n\tLWLockAcquire(RelCacheInitLock, LW_EXCLUSIVE);\n\n\t/* Make sure we have seen all incoming SI messages */\n\tAcceptInvalidationMessages();\n\n\t/*\n\t * If we have received any SI relcache invals since backend start, assume\n\t * we may have written out-of-date data.\n\t */\n\tif (relcacheInvalsReceived == 0L)\n\t{\n\t\t/*\n\t\t * OK, rename the temp file to its final name, deleting any\n\t\t * previously-existing init file.\n\t\t *\n\t\t * Note: a failure here is possible under Cygwin, if some other\n\t\t * backend is holding open an unlinked-but-not-yet-gone init file. So\n\t\t * treat this as a noncritical failure; just remove the useless temp\n\t\t * file on failure.\n\t\t */\n\t\tif (rename(tempfilename, finalfilename) < 0)\n\t\t\tunlink(tempfilename);\n\t}\n\telse\n\t{\n\t\t/* Delete the already-obsolete temp file */\n\t\tunlink(tempfilename);\n\t}\n\n\tLWLockRelease(RelCacheInitLock);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RELCACHE_INIT_FILEMAGIC\t\t0x573266\t/* version ID value */"
          ],
          "globals_used": [
            "static HTAB *RelationIdCache;",
            "static long relcacheInvalsReceived = 0L;",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static bool load_relcache_init_file(bool shared);",
            "static void write_relcache_init_file(bool shared);",
            "static void write_item(const void *data, Size len, FILE *fp);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\n#define RELCACHE_INIT_FILEMAGIC\t\t0x573266\t/* version ID value */\n\nstatic HTAB *RelationIdCache;\nstatic long relcacheInvalsReceived = 0L;\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic bool load_relcache_init_file(bool shared);\nstatic void write_relcache_init_file(bool shared);\nstatic void write_item(const void *data, Size len, FILE *fp);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nwrite_relcache_init_file(bool shared)\n{\n\tFILE\t   *fp;\n\tchar\t\ttempfilename[MAXPGPATH];\n\tchar\t\tfinalfilename[MAXPGPATH];\n\tint\t\t\tmagic;\n\tHASH_SEQ_STATUS status;\n\tRelIdCacheEnt *idhentry;\n\tint\t\t\ti;\n\n\t/*\n\t * If we have already received any relcache inval events, there's no\n\t * chance of succeeding so we may as well skip the whole thing.\n\t */\n\tif (relcacheInvalsReceived != 0L)\n\t\treturn;\n\n\t/*\n\t * We must write a temporary file and rename it into place. Otherwise,\n\t * another backend starting at about the same time might crash trying to\n\t * read the partially-complete file.\n\t */\n\tif (shared)\n\t{\n\t\tsnprintf(tempfilename, sizeof(tempfilename), \"global/%s.%d\",\n\t\t\t\t RELCACHE_INIT_FILENAME, MyProcPid);\n\t\tsnprintf(finalfilename, sizeof(finalfilename), \"global/%s\",\n\t\t\t\t RELCACHE_INIT_FILENAME);\n\t}\n\telse\n\t{\n\t\tsnprintf(tempfilename, sizeof(tempfilename), \"%s/%s.%d\",\n\t\t\t\t DatabasePath, RELCACHE_INIT_FILENAME, MyProcPid);\n\t\tsnprintf(finalfilename, sizeof(finalfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELCACHE_INIT_FILENAME);\n\t}\n\n\tunlink(tempfilename);\t\t/* in case it exists w/wrong permissions */\n\n\tfp = AllocateFile(tempfilename, PG_BINARY_W);\n\tif (fp == NULL)\n\t{\n\t\t/*\n\t\t * We used to consider this a fatal error, but we might as well\n\t\t * continue with backend startup ...\n\t\t */\n\t\tereport(WARNING,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not create relation-cache initialization file \\\"%s\\\": %m\",\n\t\t\t\t\t\ttempfilename),\n\t\t\t\t errdetail(\"Continuing anyway, but there's something wrong.\")));\n\t\treturn;\n\t}\n\n\t/*\n\t * Write a magic number to serve as a file version identifier.  We can\n\t * change the magic number whenever the relcache layout changes.\n\t */\n\tmagic = RELCACHE_INIT_FILEMAGIC;\n\tif (fwrite(&magic, 1, sizeof(magic), fp) != sizeof(magic))\n\t\telog(FATAL, \"could not write init file\");\n\n\t/*\n\t * Write all the appropriate reldescs (in no particular order).\n\t */\n\thash_seq_init(&status, RelationIdCache);\n\n\twhile ((idhentry = (RelIdCacheEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tRelation\trel = idhentry->reldesc;\n\t\tForm_pg_class relform = rel->rd_rel;\n\n\t\t/* ignore if not correct group */\n\t\tif (relform->relisshared != shared)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Ignore if not supposed to be in init file.  We can allow any shared\n\t\t * relation that's been loaded so far to be in the shared init file,\n\t\t * but unshared relations must be ones that should be in the local\n\t\t * file per RelationIdIsInInitFile.  (Note: if you want to change the\n\t\t * criterion for rels to be kept in the init file, see also inval.c.\n\t\t * The reason for filtering here is to be sure that we don't put\n\t\t * anything into the local init file for which a relcache inval would\n\t\t * not cause invalidation of that init file.)\n\t\t */\n\t\tif (!shared && !RelationIdIsInInitFile(RelationGetRelid(rel)))\n\t\t{\n\t\t\t/* Nailed rels had better get stored. */\n\t\t\tAssert(!rel->rd_isnailed);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* first write the relcache entry proper */\n\t\twrite_item(rel, sizeof(RelationData), fp);\n\n\t\t/* next write the relation tuple form */\n\t\twrite_item(relform, CLASS_TUPLE_SIZE, fp);\n\n\t\t/* next, do all the attribute tuple form data entries */\n\t\tfor (i = 0; i < relform->relnatts; i++)\n\t\t{\n\t\t\twrite_item(TupleDescAttr(rel->rd_att, i),\n\t\t\t\t\t   ATTRIBUTE_FIXED_PART_SIZE, fp);\n\t\t}\n\n\t\t/* next, do the access method specific field */\n\t\twrite_item(rel->rd_options,\n\t\t\t\t   (rel->rd_options ? VARSIZE(rel->rd_options) : 0),\n\t\t\t\t   fp);\n\n\t\t/*\n\t\t * If it's an index, there's more to do. Note we explicitly ignore\n\t\t * partitioned indexes here.\n\t\t */\n\t\tif (rel->rd_rel->relkind == RELKIND_INDEX)\n\t\t{\n\t\t\t/* write the pg_index tuple */\n\t\t\t/* we assume this was created by heap_copytuple! */\n\t\t\twrite_item(rel->rd_indextuple,\n\t\t\t\t\t   HEAPTUPLESIZE + rel->rd_indextuple->t_len,\n\t\t\t\t\t   fp);\n\n\t\t\t/* next, write the vector of opfamily OIDs */\n\t\t\twrite_item(rel->rd_opfamily,\n\t\t\t\t\t   relform->relnatts * sizeof(Oid),\n\t\t\t\t\t   fp);\n\n\t\t\t/* next, write the vector of opcintype OIDs */\n\t\t\twrite_item(rel->rd_opcintype,\n\t\t\t\t\t   relform->relnatts * sizeof(Oid),\n\t\t\t\t\t   fp);\n\n\t\t\t/* next, write the vector of support procedure OIDs */\n\t\t\twrite_item(rel->rd_support,\n\t\t\t\t\t   relform->relnatts * (rel->rd_amroutine->amsupport * sizeof(RegProcedure)),\n\t\t\t\t\t   fp);\n\n\t\t\t/* next, write the vector of collation OIDs */\n\t\t\twrite_item(rel->rd_indcollation,\n\t\t\t\t\t   relform->relnatts * sizeof(Oid),\n\t\t\t\t\t   fp);\n\n\t\t\t/* finally, write the vector of indoption values */\n\t\t\twrite_item(rel->rd_indoption,\n\t\t\t\t\t   relform->relnatts * sizeof(int16),\n\t\t\t\t\t   fp);\n\t\t}\n\t}\n\n\tif (FreeFile(fp))\n\t\telog(FATAL, \"could not write init file\");\n\n\t/*\n\t * Now we have to check whether the data we've so painstakingly\n\t * accumulated is already obsolete due to someone else's just-committed\n\t * catalog changes.  If so, we just delete the temp file and leave it to\n\t * the next backend to try again.  (Our own relcache entries will be\n\t * updated by SI message processing, but we can't be sure whether what we\n\t * wrote out was up-to-date.)\n\t *\n\t * This mustn't run concurrently with the code that unlinks an init file\n\t * and sends SI messages, so grab a serialization lock for the duration.\n\t */\n\tLWLockAcquire(RelCacheInitLock, LW_EXCLUSIVE);\n\n\t/* Make sure we have seen all incoming SI messages */\n\tAcceptInvalidationMessages();\n\n\t/*\n\t * If we have received any SI relcache invals since backend start, assume\n\t * we may have written out-of-date data.\n\t */\n\tif (relcacheInvalsReceived == 0L)\n\t{\n\t\t/*\n\t\t * OK, rename the temp file to its final name, deleting any\n\t\t * previously-existing init file.\n\t\t *\n\t\t * Note: a failure here is possible under Cygwin, if some other\n\t\t * backend is holding open an unlinked-but-not-yet-gone init file. So\n\t\t * treat this as a noncritical failure; just remove the useless temp\n\t\t * file on failure.\n\t\t */\n\t\tif (rename(tempfilename, finalfilename) < 0)\n\t\t\tunlink(tempfilename);\n\t}\n\telse\n\t{\n\t\t/* Delete the already-obsolete temp file */\n\t\tunlink(tempfilename);\n\t}\n\n\tLWLockRelease(RelCacheInitLock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "InitCatalogCachePhase2",
          "args": [],
          "line": 3854
        },
        "resolved": true,
        "details": {
          "function_name": "InitCatalogCachePhase2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1070-1079",
          "snippet": "void\nInitCatalogCachePhase2(void)\n{\n\tint\t\t\tcacheId;\n\n\tAssert(CacheInitialized);\n\n\tfor (cacheId = 0; cacheId < SysCacheSize; cacheId++)\n\t\tInitCatCachePhase2(SysCache[cacheId], true);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];",
            "static bool CacheInitialized = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\nstatic bool CacheInitialized = false;\n\nvoid\nInitCatalogCachePhase2(void)\n{\n\tint\t\t\tcacheId;\n\n\tAssert(CacheInitialized);\n\n\tfor (cacheId = 0; cacheId < SysCacheSize; cacheId++)\n\t\tInitCatCachePhase2(SysCache[cacheId], true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_init",
          "args": [
            "&status",
            "RelationIdCache"
          ],
          "line": 3838
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1378-1386",
          "snippet": "void\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_term",
          "args": [
            "&status"
          ],
          "line": 3837
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_term",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1464-1469",
          "snippet": "void\nhash_seq_term(HASH_SEQ_STATUS *status)\n{\n\tif (!status->hashp->frozen)\n\t\tderegister_seq_scan(status->hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_term(HASH_SEQ_STATUS *status)\n{\n\tif (!status->hashp->frozen)\n\t\tderegister_seq_scan(status->hashp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationDecrementReferenceCount",
          "args": [
            "relation"
          ],
          "line": 3832
        },
        "resolved": true,
        "details": {
          "function_name": "RelationDecrementReferenceCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1988-1995",
          "snippet": "void\nRelationDecrementReferenceCount(Relation rel)\n{\n\tAssert(rel->rd_refcnt > 0);\n\trel->rd_refcnt -= 1;\n\tif (!IsBootstrapProcessingMode())\n\t\tResourceOwnerForgetRelationRef(CurrentResourceOwner, rel);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nvoid\nRelationDecrementReferenceCount(Relation rel)\n{\n\tAssert(rel->rd_refcnt > 0);\n\trel->rd_refcnt -= 1;\n\tif (!IsBootstrapProcessingMode())\n\t\tResourceOwnerForgetRelationRef(CurrentResourceOwner, rel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relation->rd_partdesc != NULL"
          ],
          "line": 3826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationBuildPartitionDesc",
          "args": [
            "relation"
          ],
          "line": 3825
        },
        "resolved": true,
        "details": {
          "function_name": "RelationBuildPartitionDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/partcache.c",
          "lines": "266-798",
          "snippet": "void\nRelationBuildPartitionDesc(Relation rel)\n{\n\tList\t   *inhoids,\n\t\t\t   *partoids;\n\tOid\t\t   *oids = NULL;\n\tList\t   *boundspecs = NIL;\n\tListCell   *cell;\n\tint\t\t\ti,\n\t\t\t\tnparts;\n\tPartitionKey key = RelationGetPartitionKey(rel);\n\tPartitionDesc result;\n\tMemoryContext oldcxt;\n\n\tint\t\t\tndatums = 0;\n\tint\t\t\tdefault_index = -1;\n\n\t/* Hash partitioning specific */\n\tPartitionHashBound **hbounds = NULL;\n\n\t/* List partitioning specific */\n\tPartitionListValue **all_values = NULL;\n\tint\t\t\tnull_index = -1;\n\n\t/* Range partitioning specific */\n\tPartitionRangeBound **rbounds = NULL;\n\n\t/* Get partition oids from pg_inherits */\n\tinhoids = find_inheritance_children(RelationGetRelid(rel), NoLock);\n\n\t/* Collect bound spec nodes in a list */\n\ti = 0;\n\tpartoids = NIL;\n\tforeach(cell, inhoids)\n\t{\n\t\tOid\t\t\tinhrelid = lfirst_oid(cell);\n\t\tHeapTuple\ttuple;\n\t\tDatum\t\tdatum;\n\t\tbool\t\tisnull;\n\t\tNode\t   *boundspec;\n\n\t\ttuple = SearchSysCache1(RELOID, inhrelid);\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", inhrelid);\n\n\t\tdatum = SysCacheGetAttr(RELOID, tuple,\n\t\t\t\t\t\t\t\tAnum_pg_class_relpartbound,\n\t\t\t\t\t\t\t\t&isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null relpartbound for relation %u\", inhrelid);\n\t\tboundspec = (Node *) stringToNode(TextDatumGetCString(datum));\n\n\t\t/*\n\t\t * Sanity check: If the PartitionBoundSpec says this is the default\n\t\t * partition, its OID should correspond to whatever's stored in\n\t\t * pg_partitioned_table.partdefid; if not, the catalog is corrupt.\n\t\t */\n\t\tif (castNode(PartitionBoundSpec, boundspec)->is_default)\n\t\t{\n\t\t\tOid\t\t\tpartdefid;\n\n\t\t\tpartdefid = get_default_partition_oid(RelationGetRelid(rel));\n\t\t\tif (partdefid != inhrelid)\n\t\t\t\telog(ERROR, \"expected partdefid %u, but got %u\",\n\t\t\t\t\t inhrelid, partdefid);\n\t\t}\n\n\t\tboundspecs = lappend(boundspecs, boundspec);\n\t\tpartoids = lappend_oid(partoids, inhrelid);\n\t\tReleaseSysCache(tuple);\n\t}\n\n\tnparts = list_length(partoids);\n\n\tif (nparts > 0)\n\t{\n\t\toids = (Oid *) palloc(nparts * sizeof(Oid));\n\t\ti = 0;\n\t\tforeach(cell, partoids)\n\t\t\toids[i++] = lfirst_oid(cell);\n\n\t\t/* Convert from node to the internal representation */\n\t\tif (key->strategy == PARTITION_STRATEGY_HASH)\n\t\t{\n\t\t\tndatums = nparts;\n\t\t\thbounds = (PartitionHashBound **)\n\t\t\t\tpalloc(nparts * sizeof(PartitionHashBound *));\n\n\t\t\ti = 0;\n\t\t\tforeach(cell, boundspecs)\n\t\t\t{\n\t\t\t\tPartitionBoundSpec *spec = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlfirst(cell));\n\n\t\t\t\tif (spec->strategy != PARTITION_STRATEGY_HASH)\n\t\t\t\t\telog(ERROR, \"invalid strategy in partition bound spec\");\n\n\t\t\t\thbounds[i] = (PartitionHashBound *)\n\t\t\t\t\tpalloc(sizeof(PartitionHashBound));\n\n\t\t\t\thbounds[i]->modulus = spec->modulus;\n\t\t\t\thbounds[i]->remainder = spec->remainder;\n\t\t\t\thbounds[i]->index = i;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\t/* Sort all the bounds in ascending order */\n\t\t\tqsort(hbounds, nparts, sizeof(PartitionHashBound *),\n\t\t\t\t  qsort_partition_hbound_cmp);\n\t\t}\n\t\telse if (key->strategy == PARTITION_STRATEGY_LIST)\n\t\t{\n\t\t\tList\t   *non_null_values = NIL;\n\n\t\t\t/*\n\t\t\t * Create a unified list of non-null values across all partitions.\n\t\t\t */\n\t\t\ti = 0;\n\t\t\tnull_index = -1;\n\t\t\tforeach(cell, boundspecs)\n\t\t\t{\n\t\t\t\tPartitionBoundSpec *spec = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlfirst(cell));\n\t\t\t\tListCell   *c;\n\n\t\t\t\tif (spec->strategy != PARTITION_STRATEGY_LIST)\n\t\t\t\t\telog(ERROR, \"invalid strategy in partition bound spec\");\n\n\t\t\t\t/*\n\t\t\t\t * Note the index of the partition bound spec for the default\n\t\t\t\t * partition. There's no datum to add to the list of non-null\n\t\t\t\t * datums for this partition.\n\t\t\t\t */\n\t\t\t\tif (spec->is_default)\n\t\t\t\t{\n\t\t\t\t\tdefault_index = i;\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tforeach(c, spec->listdatums)\n\t\t\t\t{\n\t\t\t\t\tConst\t   *val = castNode(Const, lfirst(c));\n\t\t\t\t\tPartitionListValue *list_value = NULL;\n\n\t\t\t\t\tif (!val->constisnull)\n\t\t\t\t\t{\n\t\t\t\t\t\tlist_value = (PartitionListValue *)\n\t\t\t\t\t\t\tpalloc0(sizeof(PartitionListValue));\n\t\t\t\t\t\tlist_value->index = i;\n\t\t\t\t\t\tlist_value->value = val->constvalue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Never put a null into the values array, flag\n\t\t\t\t\t\t * instead for the code further down below where we\n\t\t\t\t\t\t * construct the actual relcache struct.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (null_index != -1)\n\t\t\t\t\t\t\telog(ERROR, \"found null more than once\");\n\t\t\t\t\t\tnull_index = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (list_value)\n\t\t\t\t\t\tnon_null_values = lappend(non_null_values,\n\t\t\t\t\t\t\t\t\t\t\t\t  list_value);\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tndatums = list_length(non_null_values);\n\n\t\t\t/*\n\t\t\t * Collect all list values in one array. Alongside the value, we\n\t\t\t * also save the index of partition the value comes from.\n\t\t\t */\n\t\t\tall_values = (PartitionListValue **) palloc(ndatums *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(PartitionListValue *));\n\t\t\ti = 0;\n\t\t\tforeach(cell, non_null_values)\n\t\t\t{\n\t\t\t\tPartitionListValue *src = lfirst(cell);\n\n\t\t\t\tall_values[i] = (PartitionListValue *)\n\t\t\t\t\tpalloc(sizeof(PartitionListValue));\n\t\t\t\tall_values[i]->value = src->value;\n\t\t\t\tall_values[i]->index = src->index;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tqsort_arg(all_values, ndatums, sizeof(PartitionListValue *),\n\t\t\t\t\t  qsort_partition_list_value_cmp, (void *) key);\n\t\t}\n\t\telse if (key->strategy == PARTITION_STRATEGY_RANGE)\n\t\t{\n\t\t\tint\t\t\tk;\n\t\t\tPartitionRangeBound **all_bounds,\n\t\t\t\t\t   *prev;\n\n\t\t\tall_bounds = (PartitionRangeBound **) palloc0(2 * nparts *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(PartitionRangeBound *));\n\n\t\t\t/*\n\t\t\t * Create a unified list of range bounds across all the\n\t\t\t * partitions.\n\t\t\t */\n\t\t\ti = ndatums = 0;\n\t\t\tforeach(cell, boundspecs)\n\t\t\t{\n\t\t\t\tPartitionBoundSpec *spec = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlfirst(cell));\n\t\t\t\tPartitionRangeBound *lower,\n\t\t\t\t\t\t   *upper;\n\n\t\t\t\tif (spec->strategy != PARTITION_STRATEGY_RANGE)\n\t\t\t\t\telog(ERROR, \"invalid strategy in partition bound spec\");\n\n\t\t\t\t/*\n\t\t\t\t * Note the index of the partition bound spec for the default\n\t\t\t\t * partition. There's no datum to add to the allbounds array\n\t\t\t\t * for this partition.\n\t\t\t\t */\n\t\t\t\tif (spec->is_default)\n\t\t\t\t{\n\t\t\t\t\tdefault_index = i++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlower = make_one_partition_rbound(key, i, spec->lowerdatums,\n\t\t\t\t\t\t\t\t\t\t\t\t  true);\n\t\t\t\tupper = make_one_partition_rbound(key, i, spec->upperdatums,\n\t\t\t\t\t\t\t\t\t\t\t\t  false);\n\t\t\t\tall_bounds[ndatums++] = lower;\n\t\t\t\tall_bounds[ndatums++] = upper;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tAssert(ndatums == nparts * 2 ||\n\t\t\t\t   (default_index != -1 && ndatums == (nparts - 1) * 2));\n\n\t\t\t/* Sort all the bounds in ascending order */\n\t\t\tqsort_arg(all_bounds, ndatums,\n\t\t\t\t\t  sizeof(PartitionRangeBound *),\n\t\t\t\t\t  qsort_partition_rbound_cmp,\n\t\t\t\t\t  (void *) key);\n\n\t\t\t/* Save distinct bounds from all_bounds into rbounds. */\n\t\t\trbounds = (PartitionRangeBound **)\n\t\t\t\tpalloc(ndatums * sizeof(PartitionRangeBound *));\n\t\t\tk = 0;\n\t\t\tprev = NULL;\n\t\t\tfor (i = 0; i < ndatums; i++)\n\t\t\t{\n\t\t\t\tPartitionRangeBound *cur = all_bounds[i];\n\t\t\t\tbool\t\tis_distinct = false;\n\t\t\t\tint\t\t\tj;\n\n\t\t\t\t/* Is the current bound distinct from the previous one? */\n\t\t\t\tfor (j = 0; j < key->partnatts; j++)\n\t\t\t\t{\n\t\t\t\t\tDatum\t\tcmpval;\n\n\t\t\t\t\tif (prev == NULL || cur->kind[j] != prev->kind[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tis_distinct = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If the bounds are both MINVALUE or MAXVALUE, stop now\n\t\t\t\t\t * and treat them as equal, since any values after this\n\t\t\t\t\t * point must be ignored.\n\t\t\t\t\t */\n\t\t\t\t\tif (cur->kind[j] != PARTITION_RANGE_DATUM_VALUE)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcmpval = FunctionCall2Coll(&key->partsupfunc[j],\n\t\t\t\t\t\t\t\t\t\t\t   key->partcollation[j],\n\t\t\t\t\t\t\t\t\t\t\t   cur->datums[j],\n\t\t\t\t\t\t\t\t\t\t\t   prev->datums[j]);\n\t\t\t\t\tif (DatumGetInt32(cmpval) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tis_distinct = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Only if the bound is distinct save it into a temporary\n\t\t\t\t * array i.e. rbounds which is later copied into boundinfo\n\t\t\t\t * datums array.\n\t\t\t\t */\n\t\t\t\tif (is_distinct)\n\t\t\t\t\trbounds[k++] = all_bounds[i];\n\n\t\t\t\tprev = cur;\n\t\t\t}\n\n\t\t\t/* Update ndatums to hold the count of distinct datums. */\n\t\t\tndatums = k;\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"unexpected partition strategy: %d\",\n\t\t\t\t (int) key->strategy);\n\t}\n\n\t/* Assert we aren't about to leak any old data structure */\n\tAssert(rel->rd_pdcxt == NULL);\n\tAssert(rel->rd_partdesc == NULL);\n\n\t/*\n\t * Now build the actual relcache partition descriptor.  Note that the\n\t * order of operations here is fairly critical.  If we fail partway\n\t * through this code, we won't have leaked memory because the rd_pdcxt is\n\t * attached to the relcache entry immediately, so it'll be freed whenever\n\t * the entry is rebuilt or destroyed.  However, we don't assign to\n\t * rd_partdesc until the cached data structure is fully complete and\n\t * valid, so that no other code might try to use it.\n\t */\n\trel->rd_pdcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t  \"partition descriptor\",\n\t\t\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\tMemoryContextCopyAndSetIdentifier(rel->rd_pdcxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(rel));\n\n\toldcxt = MemoryContextSwitchTo(rel->rd_pdcxt);\n\n\tresult = (PartitionDescData *) palloc0(sizeof(PartitionDescData));\n\tresult->nparts = nparts;\n\tif (nparts > 0)\n\t{\n\t\tPartitionBoundInfo boundinfo;\n\t\tint\t\t   *mapping;\n\t\tint\t\t\tnext_index = 0;\n\n\t\tresult->oids = (Oid *) palloc0(nparts * sizeof(Oid));\n\n\t\tboundinfo = (PartitionBoundInfoData *)\n\t\t\tpalloc0(sizeof(PartitionBoundInfoData));\n\t\tboundinfo->strategy = key->strategy;\n\t\tboundinfo->default_index = -1;\n\t\tboundinfo->ndatums = ndatums;\n\t\tboundinfo->null_index = -1;\n\t\tboundinfo->datums = (Datum **) palloc0(ndatums * sizeof(Datum *));\n\n\t\t/* Initialize mapping array with invalid values */\n\t\tmapping = (int *) palloc(sizeof(int) * nparts);\n\t\tfor (i = 0; i < nparts; i++)\n\t\t\tmapping[i] = -1;\n\n\t\tswitch (key->strategy)\n\t\t{\n\t\t\tcase PARTITION_STRATEGY_HASH:\n\t\t\t\t{\n\t\t\t\t\t/* Moduli are stored in ascending order */\n\t\t\t\t\tint\t\t\tgreatest_modulus = hbounds[ndatums - 1]->modulus;\n\n\t\t\t\t\tboundinfo->indexes = (int *) palloc(greatest_modulus *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int));\n\n\t\t\t\t\tfor (i = 0; i < greatest_modulus; i++)\n\t\t\t\t\t\tboundinfo->indexes[i] = -1;\n\n\t\t\t\t\tfor (i = 0; i < nparts; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\tmodulus = hbounds[i]->modulus;\n\t\t\t\t\t\tint\t\t\tremainder = hbounds[i]->remainder;\n\n\t\t\t\t\t\tboundinfo->datums[i] = (Datum *) palloc(2 *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(Datum));\n\t\t\t\t\t\tboundinfo->datums[i][0] = Int32GetDatum(modulus);\n\t\t\t\t\t\tboundinfo->datums[i][1] = Int32GetDatum(remainder);\n\n\t\t\t\t\t\twhile (remainder < greatest_modulus)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* overlap? */\n\t\t\t\t\t\t\tAssert(boundinfo->indexes[remainder] == -1);\n\t\t\t\t\t\t\tboundinfo->indexes[remainder] = i;\n\t\t\t\t\t\t\tremainder += modulus;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmapping[hbounds[i]->index] = i;\n\t\t\t\t\t\tpfree(hbounds[i]);\n\t\t\t\t\t}\n\t\t\t\t\tpfree(hbounds);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase PARTITION_STRATEGY_LIST:\n\t\t\t\t{\n\t\t\t\t\tboundinfo->indexes = (int *) palloc(ndatums * sizeof(int));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Copy values.  Indexes of individual values are mapped\n\t\t\t\t\t * to canonical values so that they match for any two list\n\t\t\t\t\t * partitioned tables with same number of partitions and\n\t\t\t\t\t * same lists per partition.  One way to canonicalize is\n\t\t\t\t\t * to assign the index in all_values[] of the smallest\n\t\t\t\t\t * value of each partition, as the index of all of the\n\t\t\t\t\t * partition's values.\n\t\t\t\t\t */\n\t\t\t\t\tfor (i = 0; i < ndatums; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tboundinfo->datums[i] = (Datum *) palloc(sizeof(Datum));\n\t\t\t\t\t\tboundinfo->datums[i][0] = datumCopy(all_values[i]->value,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey->parttypbyval[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey->parttyplen[0]);\n\n\t\t\t\t\t\t/* If the old index has no mapping, assign one */\n\t\t\t\t\t\tif (mapping[all_values[i]->index] == -1)\n\t\t\t\t\t\t\tmapping[all_values[i]->index] = next_index++;\n\n\t\t\t\t\t\tboundinfo->indexes[i] = mapping[all_values[i]->index];\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If null-accepting partition has no mapped index yet,\n\t\t\t\t\t * assign one.  This could happen if such partition\n\t\t\t\t\t * accepts only null and hence not covered in the above\n\t\t\t\t\t * loop which only handled non-null values.\n\t\t\t\t\t */\n\t\t\t\t\tif (null_index != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert(null_index >= 0);\n\t\t\t\t\t\tif (mapping[null_index] == -1)\n\t\t\t\t\t\t\tmapping[null_index] = next_index++;\n\t\t\t\t\t\tboundinfo->null_index = mapping[null_index];\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Assign mapped index for the default partition. */\n\t\t\t\t\tif (default_index != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The default partition accepts any value not\n\t\t\t\t\t\t * specified in the lists of other partitions, hence\n\t\t\t\t\t\t * it should not get mapped index while assigning\n\t\t\t\t\t\t * those for non-null datums.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tAssert(default_index >= 0 &&\n\t\t\t\t\t\t\t   mapping[default_index] == -1);\n\t\t\t\t\t\tmapping[default_index] = next_index++;\n\t\t\t\t\t\tboundinfo->default_index = mapping[default_index];\n\t\t\t\t\t}\n\n\t\t\t\t\t/* All partition must now have a valid mapping */\n\t\t\t\t\tAssert(next_index == nparts);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase PARTITION_STRATEGY_RANGE:\n\t\t\t\t{\n\t\t\t\t\tboundinfo->kind = (PartitionRangeDatumKind **)\n\t\t\t\t\t\tpalloc(ndatums *\n\t\t\t\t\t\t\t   sizeof(PartitionRangeDatumKind *));\n\t\t\t\t\tboundinfo->indexes = (int *) palloc((ndatums + 1) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int));\n\n\t\t\t\t\tfor (i = 0; i < ndatums; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\tj;\n\n\t\t\t\t\t\tboundinfo->datums[i] = (Datum *) palloc(key->partnatts *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(Datum));\n\t\t\t\t\t\tboundinfo->kind[i] = (PartitionRangeDatumKind *)\n\t\t\t\t\t\t\tpalloc(key->partnatts *\n\t\t\t\t\t\t\t\t   sizeof(PartitionRangeDatumKind));\n\t\t\t\t\t\tfor (j = 0; j < key->partnatts; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (rbounds[i]->kind[j] == PARTITION_RANGE_DATUM_VALUE)\n\t\t\t\t\t\t\t\tboundinfo->datums[i][j] =\n\t\t\t\t\t\t\t\t\tdatumCopy(rbounds[i]->datums[j],\n\t\t\t\t\t\t\t\t\t\t\t  key->parttypbyval[j],\n\t\t\t\t\t\t\t\t\t\t\t  key->parttyplen[j]);\n\t\t\t\t\t\t\tboundinfo->kind[i][j] = rbounds[i]->kind[j];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * There is no mapping for invalid indexes.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Any lower bounds in the rbounds array have invalid\n\t\t\t\t\t\t * indexes assigned, because the values between the\n\t\t\t\t\t\t * previous bound (if there is one) and this (lower)\n\t\t\t\t\t\t * bound are not part of the range of any existing\n\t\t\t\t\t\t * partition.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (rbounds[i]->lower)\n\t\t\t\t\t\t\tboundinfo->indexes[i] = -1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint\t\t\torig_index = rbounds[i]->index;\n\n\t\t\t\t\t\t\t/* If the old index has no mapping, assign one */\n\t\t\t\t\t\t\tif (mapping[orig_index] == -1)\n\t\t\t\t\t\t\t\tmapping[orig_index] = next_index++;\n\n\t\t\t\t\t\t\tboundinfo->indexes[i] = mapping[orig_index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Assign mapped index for the default partition. */\n\t\t\t\t\tif (default_index != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert(default_index >= 0 && mapping[default_index] == -1);\n\t\t\t\t\t\tmapping[default_index] = next_index++;\n\t\t\t\t\t\tboundinfo->default_index = mapping[default_index];\n\t\t\t\t\t}\n\t\t\t\t\tboundinfo->indexes[i] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected partition strategy: %d\",\n\t\t\t\t\t (int) key->strategy);\n\t\t}\n\n\t\tresult->boundinfo = boundinfo;\n\n\t\t/*\n\t\t * Now assign OIDs from the original array into mapped indexes of the\n\t\t * result array.  Order of OIDs in the former is defined by the\n\t\t * catalog scan that retrieved them, whereas that in the latter is\n\t\t * defined by canonicalized representation of the partition bounds.\n\t\t */\n\t\tfor (i = 0; i < nparts; i++)\n\t\t\tresult->oids[mapping[i]] = oids[i];\n\t\tpfree(mapping);\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n\trel->rd_partdesc = result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_inherits.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static List *generate_partition_qual(Relation rel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/planner.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_inherits.h\"\n#include \"catalog/partition.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic List *generate_partition_qual(Relation rel);\n\nvoid\nRelationBuildPartitionDesc(Relation rel)\n{\n\tList\t   *inhoids,\n\t\t\t   *partoids;\n\tOid\t\t   *oids = NULL;\n\tList\t   *boundspecs = NIL;\n\tListCell   *cell;\n\tint\t\t\ti,\n\t\t\t\tnparts;\n\tPartitionKey key = RelationGetPartitionKey(rel);\n\tPartitionDesc result;\n\tMemoryContext oldcxt;\n\n\tint\t\t\tndatums = 0;\n\tint\t\t\tdefault_index = -1;\n\n\t/* Hash partitioning specific */\n\tPartitionHashBound **hbounds = NULL;\n\n\t/* List partitioning specific */\n\tPartitionListValue **all_values = NULL;\n\tint\t\t\tnull_index = -1;\n\n\t/* Range partitioning specific */\n\tPartitionRangeBound **rbounds = NULL;\n\n\t/* Get partition oids from pg_inherits */\n\tinhoids = find_inheritance_children(RelationGetRelid(rel), NoLock);\n\n\t/* Collect bound spec nodes in a list */\n\ti = 0;\n\tpartoids = NIL;\n\tforeach(cell, inhoids)\n\t{\n\t\tOid\t\t\tinhrelid = lfirst_oid(cell);\n\t\tHeapTuple\ttuple;\n\t\tDatum\t\tdatum;\n\t\tbool\t\tisnull;\n\t\tNode\t   *boundspec;\n\n\t\ttuple = SearchSysCache1(RELOID, inhrelid);\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", inhrelid);\n\n\t\tdatum = SysCacheGetAttr(RELOID, tuple,\n\t\t\t\t\t\t\t\tAnum_pg_class_relpartbound,\n\t\t\t\t\t\t\t\t&isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null relpartbound for relation %u\", inhrelid);\n\t\tboundspec = (Node *) stringToNode(TextDatumGetCString(datum));\n\n\t\t/*\n\t\t * Sanity check: If the PartitionBoundSpec says this is the default\n\t\t * partition, its OID should correspond to whatever's stored in\n\t\t * pg_partitioned_table.partdefid; if not, the catalog is corrupt.\n\t\t */\n\t\tif (castNode(PartitionBoundSpec, boundspec)->is_default)\n\t\t{\n\t\t\tOid\t\t\tpartdefid;\n\n\t\t\tpartdefid = get_default_partition_oid(RelationGetRelid(rel));\n\t\t\tif (partdefid != inhrelid)\n\t\t\t\telog(ERROR, \"expected partdefid %u, but got %u\",\n\t\t\t\t\t inhrelid, partdefid);\n\t\t}\n\n\t\tboundspecs = lappend(boundspecs, boundspec);\n\t\tpartoids = lappend_oid(partoids, inhrelid);\n\t\tReleaseSysCache(tuple);\n\t}\n\n\tnparts = list_length(partoids);\n\n\tif (nparts > 0)\n\t{\n\t\toids = (Oid *) palloc(nparts * sizeof(Oid));\n\t\ti = 0;\n\t\tforeach(cell, partoids)\n\t\t\toids[i++] = lfirst_oid(cell);\n\n\t\t/* Convert from node to the internal representation */\n\t\tif (key->strategy == PARTITION_STRATEGY_HASH)\n\t\t{\n\t\t\tndatums = nparts;\n\t\t\thbounds = (PartitionHashBound **)\n\t\t\t\tpalloc(nparts * sizeof(PartitionHashBound *));\n\n\t\t\ti = 0;\n\t\t\tforeach(cell, boundspecs)\n\t\t\t{\n\t\t\t\tPartitionBoundSpec *spec = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlfirst(cell));\n\n\t\t\t\tif (spec->strategy != PARTITION_STRATEGY_HASH)\n\t\t\t\t\telog(ERROR, \"invalid strategy in partition bound spec\");\n\n\t\t\t\thbounds[i] = (PartitionHashBound *)\n\t\t\t\t\tpalloc(sizeof(PartitionHashBound));\n\n\t\t\t\thbounds[i]->modulus = spec->modulus;\n\t\t\t\thbounds[i]->remainder = spec->remainder;\n\t\t\t\thbounds[i]->index = i;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\t/* Sort all the bounds in ascending order */\n\t\t\tqsort(hbounds, nparts, sizeof(PartitionHashBound *),\n\t\t\t\t  qsort_partition_hbound_cmp);\n\t\t}\n\t\telse if (key->strategy == PARTITION_STRATEGY_LIST)\n\t\t{\n\t\t\tList\t   *non_null_values = NIL;\n\n\t\t\t/*\n\t\t\t * Create a unified list of non-null values across all partitions.\n\t\t\t */\n\t\t\ti = 0;\n\t\t\tnull_index = -1;\n\t\t\tforeach(cell, boundspecs)\n\t\t\t{\n\t\t\t\tPartitionBoundSpec *spec = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlfirst(cell));\n\t\t\t\tListCell   *c;\n\n\t\t\t\tif (spec->strategy != PARTITION_STRATEGY_LIST)\n\t\t\t\t\telog(ERROR, \"invalid strategy in partition bound spec\");\n\n\t\t\t\t/*\n\t\t\t\t * Note the index of the partition bound spec for the default\n\t\t\t\t * partition. There's no datum to add to the list of non-null\n\t\t\t\t * datums for this partition.\n\t\t\t\t */\n\t\t\t\tif (spec->is_default)\n\t\t\t\t{\n\t\t\t\t\tdefault_index = i;\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tforeach(c, spec->listdatums)\n\t\t\t\t{\n\t\t\t\t\tConst\t   *val = castNode(Const, lfirst(c));\n\t\t\t\t\tPartitionListValue *list_value = NULL;\n\n\t\t\t\t\tif (!val->constisnull)\n\t\t\t\t\t{\n\t\t\t\t\t\tlist_value = (PartitionListValue *)\n\t\t\t\t\t\t\tpalloc0(sizeof(PartitionListValue));\n\t\t\t\t\t\tlist_value->index = i;\n\t\t\t\t\t\tlist_value->value = val->constvalue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Never put a null into the values array, flag\n\t\t\t\t\t\t * instead for the code further down below where we\n\t\t\t\t\t\t * construct the actual relcache struct.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (null_index != -1)\n\t\t\t\t\t\t\telog(ERROR, \"found null more than once\");\n\t\t\t\t\t\tnull_index = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (list_value)\n\t\t\t\t\t\tnon_null_values = lappend(non_null_values,\n\t\t\t\t\t\t\t\t\t\t\t\t  list_value);\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tndatums = list_length(non_null_values);\n\n\t\t\t/*\n\t\t\t * Collect all list values in one array. Alongside the value, we\n\t\t\t * also save the index of partition the value comes from.\n\t\t\t */\n\t\t\tall_values = (PartitionListValue **) palloc(ndatums *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(PartitionListValue *));\n\t\t\ti = 0;\n\t\t\tforeach(cell, non_null_values)\n\t\t\t{\n\t\t\t\tPartitionListValue *src = lfirst(cell);\n\n\t\t\t\tall_values[i] = (PartitionListValue *)\n\t\t\t\t\tpalloc(sizeof(PartitionListValue));\n\t\t\t\tall_values[i]->value = src->value;\n\t\t\t\tall_values[i]->index = src->index;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tqsort_arg(all_values, ndatums, sizeof(PartitionListValue *),\n\t\t\t\t\t  qsort_partition_list_value_cmp, (void *) key);\n\t\t}\n\t\telse if (key->strategy == PARTITION_STRATEGY_RANGE)\n\t\t{\n\t\t\tint\t\t\tk;\n\t\t\tPartitionRangeBound **all_bounds,\n\t\t\t\t\t   *prev;\n\n\t\t\tall_bounds = (PartitionRangeBound **) palloc0(2 * nparts *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(PartitionRangeBound *));\n\n\t\t\t/*\n\t\t\t * Create a unified list of range bounds across all the\n\t\t\t * partitions.\n\t\t\t */\n\t\t\ti = ndatums = 0;\n\t\t\tforeach(cell, boundspecs)\n\t\t\t{\n\t\t\t\tPartitionBoundSpec *spec = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlfirst(cell));\n\t\t\t\tPartitionRangeBound *lower,\n\t\t\t\t\t\t   *upper;\n\n\t\t\t\tif (spec->strategy != PARTITION_STRATEGY_RANGE)\n\t\t\t\t\telog(ERROR, \"invalid strategy in partition bound spec\");\n\n\t\t\t\t/*\n\t\t\t\t * Note the index of the partition bound spec for the default\n\t\t\t\t * partition. There's no datum to add to the allbounds array\n\t\t\t\t * for this partition.\n\t\t\t\t */\n\t\t\t\tif (spec->is_default)\n\t\t\t\t{\n\t\t\t\t\tdefault_index = i++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlower = make_one_partition_rbound(key, i, spec->lowerdatums,\n\t\t\t\t\t\t\t\t\t\t\t\t  true);\n\t\t\t\tupper = make_one_partition_rbound(key, i, spec->upperdatums,\n\t\t\t\t\t\t\t\t\t\t\t\t  false);\n\t\t\t\tall_bounds[ndatums++] = lower;\n\t\t\t\tall_bounds[ndatums++] = upper;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tAssert(ndatums == nparts * 2 ||\n\t\t\t\t   (default_index != -1 && ndatums == (nparts - 1) * 2));\n\n\t\t\t/* Sort all the bounds in ascending order */\n\t\t\tqsort_arg(all_bounds, ndatums,\n\t\t\t\t\t  sizeof(PartitionRangeBound *),\n\t\t\t\t\t  qsort_partition_rbound_cmp,\n\t\t\t\t\t  (void *) key);\n\n\t\t\t/* Save distinct bounds from all_bounds into rbounds. */\n\t\t\trbounds = (PartitionRangeBound **)\n\t\t\t\tpalloc(ndatums * sizeof(PartitionRangeBound *));\n\t\t\tk = 0;\n\t\t\tprev = NULL;\n\t\t\tfor (i = 0; i < ndatums; i++)\n\t\t\t{\n\t\t\t\tPartitionRangeBound *cur = all_bounds[i];\n\t\t\t\tbool\t\tis_distinct = false;\n\t\t\t\tint\t\t\tj;\n\n\t\t\t\t/* Is the current bound distinct from the previous one? */\n\t\t\t\tfor (j = 0; j < key->partnatts; j++)\n\t\t\t\t{\n\t\t\t\t\tDatum\t\tcmpval;\n\n\t\t\t\t\tif (prev == NULL || cur->kind[j] != prev->kind[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tis_distinct = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If the bounds are both MINVALUE or MAXVALUE, stop now\n\t\t\t\t\t * and treat them as equal, since any values after this\n\t\t\t\t\t * point must be ignored.\n\t\t\t\t\t */\n\t\t\t\t\tif (cur->kind[j] != PARTITION_RANGE_DATUM_VALUE)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcmpval = FunctionCall2Coll(&key->partsupfunc[j],\n\t\t\t\t\t\t\t\t\t\t\t   key->partcollation[j],\n\t\t\t\t\t\t\t\t\t\t\t   cur->datums[j],\n\t\t\t\t\t\t\t\t\t\t\t   prev->datums[j]);\n\t\t\t\t\tif (DatumGetInt32(cmpval) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tis_distinct = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Only if the bound is distinct save it into a temporary\n\t\t\t\t * array i.e. rbounds which is later copied into boundinfo\n\t\t\t\t * datums array.\n\t\t\t\t */\n\t\t\t\tif (is_distinct)\n\t\t\t\t\trbounds[k++] = all_bounds[i];\n\n\t\t\t\tprev = cur;\n\t\t\t}\n\n\t\t\t/* Update ndatums to hold the count of distinct datums. */\n\t\t\tndatums = k;\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"unexpected partition strategy: %d\",\n\t\t\t\t (int) key->strategy);\n\t}\n\n\t/* Assert we aren't about to leak any old data structure */\n\tAssert(rel->rd_pdcxt == NULL);\n\tAssert(rel->rd_partdesc == NULL);\n\n\t/*\n\t * Now build the actual relcache partition descriptor.  Note that the\n\t * order of operations here is fairly critical.  If we fail partway\n\t * through this code, we won't have leaked memory because the rd_pdcxt is\n\t * attached to the relcache entry immediately, so it'll be freed whenever\n\t * the entry is rebuilt or destroyed.  However, we don't assign to\n\t * rd_partdesc until the cached data structure is fully complete and\n\t * valid, so that no other code might try to use it.\n\t */\n\trel->rd_pdcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t  \"partition descriptor\",\n\t\t\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\tMemoryContextCopyAndSetIdentifier(rel->rd_pdcxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(rel));\n\n\toldcxt = MemoryContextSwitchTo(rel->rd_pdcxt);\n\n\tresult = (PartitionDescData *) palloc0(sizeof(PartitionDescData));\n\tresult->nparts = nparts;\n\tif (nparts > 0)\n\t{\n\t\tPartitionBoundInfo boundinfo;\n\t\tint\t\t   *mapping;\n\t\tint\t\t\tnext_index = 0;\n\n\t\tresult->oids = (Oid *) palloc0(nparts * sizeof(Oid));\n\n\t\tboundinfo = (PartitionBoundInfoData *)\n\t\t\tpalloc0(sizeof(PartitionBoundInfoData));\n\t\tboundinfo->strategy = key->strategy;\n\t\tboundinfo->default_index = -1;\n\t\tboundinfo->ndatums = ndatums;\n\t\tboundinfo->null_index = -1;\n\t\tboundinfo->datums = (Datum **) palloc0(ndatums * sizeof(Datum *));\n\n\t\t/* Initialize mapping array with invalid values */\n\t\tmapping = (int *) palloc(sizeof(int) * nparts);\n\t\tfor (i = 0; i < nparts; i++)\n\t\t\tmapping[i] = -1;\n\n\t\tswitch (key->strategy)\n\t\t{\n\t\t\tcase PARTITION_STRATEGY_HASH:\n\t\t\t\t{\n\t\t\t\t\t/* Moduli are stored in ascending order */\n\t\t\t\t\tint\t\t\tgreatest_modulus = hbounds[ndatums - 1]->modulus;\n\n\t\t\t\t\tboundinfo->indexes = (int *) palloc(greatest_modulus *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int));\n\n\t\t\t\t\tfor (i = 0; i < greatest_modulus; i++)\n\t\t\t\t\t\tboundinfo->indexes[i] = -1;\n\n\t\t\t\t\tfor (i = 0; i < nparts; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\tmodulus = hbounds[i]->modulus;\n\t\t\t\t\t\tint\t\t\tremainder = hbounds[i]->remainder;\n\n\t\t\t\t\t\tboundinfo->datums[i] = (Datum *) palloc(2 *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(Datum));\n\t\t\t\t\t\tboundinfo->datums[i][0] = Int32GetDatum(modulus);\n\t\t\t\t\t\tboundinfo->datums[i][1] = Int32GetDatum(remainder);\n\n\t\t\t\t\t\twhile (remainder < greatest_modulus)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* overlap? */\n\t\t\t\t\t\t\tAssert(boundinfo->indexes[remainder] == -1);\n\t\t\t\t\t\t\tboundinfo->indexes[remainder] = i;\n\t\t\t\t\t\t\tremainder += modulus;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmapping[hbounds[i]->index] = i;\n\t\t\t\t\t\tpfree(hbounds[i]);\n\t\t\t\t\t}\n\t\t\t\t\tpfree(hbounds);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase PARTITION_STRATEGY_LIST:\n\t\t\t\t{\n\t\t\t\t\tboundinfo->indexes = (int *) palloc(ndatums * sizeof(int));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Copy values.  Indexes of individual values are mapped\n\t\t\t\t\t * to canonical values so that they match for any two list\n\t\t\t\t\t * partitioned tables with same number of partitions and\n\t\t\t\t\t * same lists per partition.  One way to canonicalize is\n\t\t\t\t\t * to assign the index in all_values[] of the smallest\n\t\t\t\t\t * value of each partition, as the index of all of the\n\t\t\t\t\t * partition's values.\n\t\t\t\t\t */\n\t\t\t\t\tfor (i = 0; i < ndatums; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tboundinfo->datums[i] = (Datum *) palloc(sizeof(Datum));\n\t\t\t\t\t\tboundinfo->datums[i][0] = datumCopy(all_values[i]->value,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey->parttypbyval[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey->parttyplen[0]);\n\n\t\t\t\t\t\t/* If the old index has no mapping, assign one */\n\t\t\t\t\t\tif (mapping[all_values[i]->index] == -1)\n\t\t\t\t\t\t\tmapping[all_values[i]->index] = next_index++;\n\n\t\t\t\t\t\tboundinfo->indexes[i] = mapping[all_values[i]->index];\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If null-accepting partition has no mapped index yet,\n\t\t\t\t\t * assign one.  This could happen if such partition\n\t\t\t\t\t * accepts only null and hence not covered in the above\n\t\t\t\t\t * loop which only handled non-null values.\n\t\t\t\t\t */\n\t\t\t\t\tif (null_index != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert(null_index >= 0);\n\t\t\t\t\t\tif (mapping[null_index] == -1)\n\t\t\t\t\t\t\tmapping[null_index] = next_index++;\n\t\t\t\t\t\tboundinfo->null_index = mapping[null_index];\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Assign mapped index for the default partition. */\n\t\t\t\t\tif (default_index != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The default partition accepts any value not\n\t\t\t\t\t\t * specified in the lists of other partitions, hence\n\t\t\t\t\t\t * it should not get mapped index while assigning\n\t\t\t\t\t\t * those for non-null datums.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tAssert(default_index >= 0 &&\n\t\t\t\t\t\t\t   mapping[default_index] == -1);\n\t\t\t\t\t\tmapping[default_index] = next_index++;\n\t\t\t\t\t\tboundinfo->default_index = mapping[default_index];\n\t\t\t\t\t}\n\n\t\t\t\t\t/* All partition must now have a valid mapping */\n\t\t\t\t\tAssert(next_index == nparts);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase PARTITION_STRATEGY_RANGE:\n\t\t\t\t{\n\t\t\t\t\tboundinfo->kind = (PartitionRangeDatumKind **)\n\t\t\t\t\t\tpalloc(ndatums *\n\t\t\t\t\t\t\t   sizeof(PartitionRangeDatumKind *));\n\t\t\t\t\tboundinfo->indexes = (int *) palloc((ndatums + 1) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int));\n\n\t\t\t\t\tfor (i = 0; i < ndatums; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\tj;\n\n\t\t\t\t\t\tboundinfo->datums[i] = (Datum *) palloc(key->partnatts *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(Datum));\n\t\t\t\t\t\tboundinfo->kind[i] = (PartitionRangeDatumKind *)\n\t\t\t\t\t\t\tpalloc(key->partnatts *\n\t\t\t\t\t\t\t\t   sizeof(PartitionRangeDatumKind));\n\t\t\t\t\t\tfor (j = 0; j < key->partnatts; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (rbounds[i]->kind[j] == PARTITION_RANGE_DATUM_VALUE)\n\t\t\t\t\t\t\t\tboundinfo->datums[i][j] =\n\t\t\t\t\t\t\t\t\tdatumCopy(rbounds[i]->datums[j],\n\t\t\t\t\t\t\t\t\t\t\t  key->parttypbyval[j],\n\t\t\t\t\t\t\t\t\t\t\t  key->parttyplen[j]);\n\t\t\t\t\t\t\tboundinfo->kind[i][j] = rbounds[i]->kind[j];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * There is no mapping for invalid indexes.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Any lower bounds in the rbounds array have invalid\n\t\t\t\t\t\t * indexes assigned, because the values between the\n\t\t\t\t\t\t * previous bound (if there is one) and this (lower)\n\t\t\t\t\t\t * bound are not part of the range of any existing\n\t\t\t\t\t\t * partition.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (rbounds[i]->lower)\n\t\t\t\t\t\t\tboundinfo->indexes[i] = -1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint\t\t\torig_index = rbounds[i]->index;\n\n\t\t\t\t\t\t\t/* If the old index has no mapping, assign one */\n\t\t\t\t\t\t\tif (mapping[orig_index] == -1)\n\t\t\t\t\t\t\t\tmapping[orig_index] = next_index++;\n\n\t\t\t\t\t\t\tboundinfo->indexes[i] = mapping[orig_index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Assign mapped index for the default partition. */\n\t\t\t\t\tif (default_index != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert(default_index >= 0 && mapping[default_index] == -1);\n\t\t\t\t\t\tmapping[default_index] = next_index++;\n\t\t\t\t\t\tboundinfo->default_index = mapping[default_index];\n\t\t\t\t\t}\n\t\t\t\t\tboundinfo->indexes[i] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected partition strategy: %d\",\n\t\t\t\t\t (int) key->strategy);\n\t\t}\n\n\t\tresult->boundinfo = boundinfo;\n\n\t\t/*\n\t\t * Now assign OIDs from the original array into mapped indexes of the\n\t\t * result array.  Order of OIDs in the former is defined by the\n\t\t * catalog scan that retrieved them, whereas that in the latter is\n\t\t * defined by canonicalized representation of the partition bounds.\n\t\t */\n\t\tfor (i = 0; i < nparts; i++)\n\t\t\tresult->oids[mapping[i]] = oids[i];\n\t\tpfree(mapping);\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n\trel->rd_partdesc = result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relation->rd_partkey != NULL"
          ],
          "line": 3817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationBuildPartitionKey",
          "args": [
            "relation"
          ],
          "line": 3816
        },
        "resolved": true,
        "details": {
          "function_name": "RelationBuildPartitionKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/partcache.c",
          "lines": "63-254",
          "snippet": "void\nRelationBuildPartitionKey(Relation relation)\n{\n\tForm_pg_partitioned_table form;\n\tHeapTuple\ttuple;\n\tbool\t\tisnull;\n\tint\t\t\ti;\n\tPartitionKey key;\n\tAttrNumber *attrs;\n\toidvector  *opclass;\n\toidvector  *collation;\n\tListCell   *partexprs_item;\n\tDatum\t\tdatum;\n\tMemoryContext partkeycxt,\n\t\t\t\toldcxt;\n\tint16\t\tprocnum;\n\n\ttuple = SearchSysCache1(PARTRELID,\n\t\t\t\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\t/*\n\t * The following happens when we have created our pg_class entry but not\n\t * the pg_partitioned_table entry yet.\n\t */\n\tif (!HeapTupleIsValid(tuple))\n\t\treturn;\n\n\tpartkeycxt = AllocSetContextCreate(CurTransactionContext,\n\t\t\t\t\t\t\t\t\t   \"partition key\",\n\t\t\t\t\t\t\t\t\t   ALLOCSET_SMALL_SIZES);\n\tMemoryContextCopyAndSetIdentifier(partkeycxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(relation));\n\n\tkey = (PartitionKey) MemoryContextAllocZero(partkeycxt,\n\t\t\t\t\t\t\t\t\t\t\t\tsizeof(PartitionKeyData));\n\n\t/* Fixed-length attributes */\n\tform = (Form_pg_partitioned_table) GETSTRUCT(tuple);\n\tkey->strategy = form->partstrat;\n\tkey->partnatts = form->partnatts;\n\n\t/*\n\t * We can rely on the first variable-length attribute being mapped to the\n\t * relevant field of the catalog's C struct, because all previous\n\t * attributes are non-nullable and fixed-length.\n\t */\n\tattrs = form->partattrs.values;\n\n\t/* But use the hard way to retrieve further variable-length attributes */\n\t/* Operator class */\n\tdatum = SysCacheGetAttr(PARTRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_partitioned_table_partclass, &isnull);\n\tAssert(!isnull);\n\topclass = (oidvector *) DatumGetPointer(datum);\n\n\t/* Collation */\n\tdatum = SysCacheGetAttr(PARTRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_partitioned_table_partcollation, &isnull);\n\tAssert(!isnull);\n\tcollation = (oidvector *) DatumGetPointer(datum);\n\n\t/* Expressions */\n\tdatum = SysCacheGetAttr(PARTRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_partitioned_table_partexprs, &isnull);\n\tif (!isnull)\n\t{\n\t\tchar\t   *exprString;\n\t\tNode\t   *expr;\n\n\t\texprString = TextDatumGetCString(datum);\n\t\texpr = stringToNode(exprString);\n\t\tpfree(exprString);\n\n\t\t/*\n\t\t * Run the expressions through const-simplification since the planner\n\t\t * will be comparing them to similarly-processed qual clause operands,\n\t\t * and may fail to detect valid matches without this step; fix\n\t\t * opfuncids while at it.  We don't need to bother with\n\t\t * canonicalize_qual() though, because partition expressions should be\n\t\t * in canonical form already (ie, no need for OR-merging or constant\n\t\t * elimination).\n\t\t */\n\t\texpr = eval_const_expressions(NULL, expr);\n\t\tfix_opfuncids(expr);\n\n\t\toldcxt = MemoryContextSwitchTo(partkeycxt);\n\t\tkey->partexprs = (List *) copyObject(expr);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/* Allocate assorted arrays in the partkeycxt, which we'll fill below */\n\toldcxt = MemoryContextSwitchTo(partkeycxt);\n\tkey->partattrs = (AttrNumber *) palloc0(key->partnatts * sizeof(AttrNumber));\n\tkey->partopfamily = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->partopcintype = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->partsupfunc = (FmgrInfo *) palloc0(key->partnatts * sizeof(FmgrInfo));\n\n\tkey->partcollation = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->parttypid = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->parttypmod = (int32 *) palloc0(key->partnatts * sizeof(int32));\n\tkey->parttyplen = (int16 *) palloc0(key->partnatts * sizeof(int16));\n\tkey->parttypbyval = (bool *) palloc0(key->partnatts * sizeof(bool));\n\tkey->parttypalign = (char *) palloc0(key->partnatts * sizeof(char));\n\tkey->parttypcoll = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* determine support function number to search for */\n\tprocnum = (key->strategy == PARTITION_STRATEGY_HASH) ?\n\t\tHASHEXTENDED_PROC : BTORDER_PROC;\n\n\t/* Copy partattrs and fill other per-attribute info */\n\tmemcpy(key->partattrs, attrs, key->partnatts * sizeof(int16));\n\tpartexprs_item = list_head(key->partexprs);\n\tfor (i = 0; i < key->partnatts; i++)\n\t{\n\t\tAttrNumber\tattno = key->partattrs[i];\n\t\tHeapTuple\topclasstup;\n\t\tForm_pg_opclass opclassform;\n\t\tOid\t\t\tfuncid;\n\n\t\t/* Collect opfamily information */\n\t\topclasstup = SearchSysCache1(CLAOID,\n\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(opclass->values[i]));\n\t\tif (!HeapTupleIsValid(opclasstup))\n\t\t\telog(ERROR, \"cache lookup failed for opclass %u\", opclass->values[i]);\n\n\t\topclassform = (Form_pg_opclass) GETSTRUCT(opclasstup);\n\t\tkey->partopfamily[i] = opclassform->opcfamily;\n\t\tkey->partopcintype[i] = opclassform->opcintype;\n\n\t\t/* Get a support function for the specified opfamily and datatypes */\n\t\tfuncid = get_opfamily_proc(opclassform->opcfamily,\n\t\t\t\t\t\t\t\t   opclassform->opcintype,\n\t\t\t\t\t\t\t\t   opclassform->opcintype,\n\t\t\t\t\t\t\t\t   procnum);\n\t\tif (!OidIsValid(funcid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t\t errmsg(\"operator class \\\"%s\\\" of access method %s is missing support function %d for type %s\",\n\t\t\t\t\t\t\tNameStr(opclassform->opcname),\n\t\t\t\t\t\t\t(key->strategy == PARTITION_STRATEGY_HASH) ?\n\t\t\t\t\t\t\t\"hash\" : \"btree\",\n\t\t\t\t\t\t\tprocnum,\n\t\t\t\t\t\t\tformat_type_be(opclassform->opcintype))));\n\n\t\tfmgr_info_cxt(funcid, &key->partsupfunc[i], partkeycxt);\n\n\t\t/* Collation */\n\t\tkey->partcollation[i] = collation->values[i];\n\n\t\t/* Collect type information */\n\t\tif (attno != 0)\n\t\t{\n\t\t\tForm_pg_attribute att = TupleDescAttr(relation->rd_att, attno - 1);\n\n\t\t\tkey->parttypid[i] = att->atttypid;\n\t\t\tkey->parttypmod[i] = att->atttypmod;\n\t\t\tkey->parttypcoll[i] = att->attcollation;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (partexprs_item == NULL)\n\t\t\t\telog(ERROR, \"wrong number of partition key expressions\");\n\n\t\t\tkey->parttypid[i] = exprType(lfirst(partexprs_item));\n\t\t\tkey->parttypmod[i] = exprTypmod(lfirst(partexprs_item));\n\t\t\tkey->parttypcoll[i] = exprCollation(lfirst(partexprs_item));\n\n\t\t\tpartexprs_item = lnext(partexprs_item);\n\t\t}\n\t\tget_typlenbyvalalign(key->parttypid[i],\n\t\t\t\t\t\t\t &key->parttyplen[i],\n\t\t\t\t\t\t\t &key->parttypbyval[i],\n\t\t\t\t\t\t\t &key->parttypalign[i]);\n\n\t\tReleaseSysCache(opclasstup);\n\t}\n\n\tReleaseSysCache(tuple);\n\n\t/* Assert that we're not leaking any old data during assignments below */\n\tAssert(relation->rd_partkeycxt == NULL);\n\tAssert(relation->rd_partkey == NULL);\n\n\t/*\n\t * Success --- reparent our context and make the relcache point to the\n\t * newly constructed key\n\t */\n\tMemoryContextSetParent(partkeycxt, CacheMemoryContext);\n\trelation->rd_partkeycxt = partkeycxt;\n\trelation->rd_partkey = key;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_inherits.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/planner.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_inherits.h\"\n#include \"catalog/partition.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nRelationBuildPartitionKey(Relation relation)\n{\n\tForm_pg_partitioned_table form;\n\tHeapTuple\ttuple;\n\tbool\t\tisnull;\n\tint\t\t\ti;\n\tPartitionKey key;\n\tAttrNumber *attrs;\n\toidvector  *opclass;\n\toidvector  *collation;\n\tListCell   *partexprs_item;\n\tDatum\t\tdatum;\n\tMemoryContext partkeycxt,\n\t\t\t\toldcxt;\n\tint16\t\tprocnum;\n\n\ttuple = SearchSysCache1(PARTRELID,\n\t\t\t\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\t/*\n\t * The following happens when we have created our pg_class entry but not\n\t * the pg_partitioned_table entry yet.\n\t */\n\tif (!HeapTupleIsValid(tuple))\n\t\treturn;\n\n\tpartkeycxt = AllocSetContextCreate(CurTransactionContext,\n\t\t\t\t\t\t\t\t\t   \"partition key\",\n\t\t\t\t\t\t\t\t\t   ALLOCSET_SMALL_SIZES);\n\tMemoryContextCopyAndSetIdentifier(partkeycxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(relation));\n\n\tkey = (PartitionKey) MemoryContextAllocZero(partkeycxt,\n\t\t\t\t\t\t\t\t\t\t\t\tsizeof(PartitionKeyData));\n\n\t/* Fixed-length attributes */\n\tform = (Form_pg_partitioned_table) GETSTRUCT(tuple);\n\tkey->strategy = form->partstrat;\n\tkey->partnatts = form->partnatts;\n\n\t/*\n\t * We can rely on the first variable-length attribute being mapped to the\n\t * relevant field of the catalog's C struct, because all previous\n\t * attributes are non-nullable and fixed-length.\n\t */\n\tattrs = form->partattrs.values;\n\n\t/* But use the hard way to retrieve further variable-length attributes */\n\t/* Operator class */\n\tdatum = SysCacheGetAttr(PARTRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_partitioned_table_partclass, &isnull);\n\tAssert(!isnull);\n\topclass = (oidvector *) DatumGetPointer(datum);\n\n\t/* Collation */\n\tdatum = SysCacheGetAttr(PARTRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_partitioned_table_partcollation, &isnull);\n\tAssert(!isnull);\n\tcollation = (oidvector *) DatumGetPointer(datum);\n\n\t/* Expressions */\n\tdatum = SysCacheGetAttr(PARTRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_partitioned_table_partexprs, &isnull);\n\tif (!isnull)\n\t{\n\t\tchar\t   *exprString;\n\t\tNode\t   *expr;\n\n\t\texprString = TextDatumGetCString(datum);\n\t\texpr = stringToNode(exprString);\n\t\tpfree(exprString);\n\n\t\t/*\n\t\t * Run the expressions through const-simplification since the planner\n\t\t * will be comparing them to similarly-processed qual clause operands,\n\t\t * and may fail to detect valid matches without this step; fix\n\t\t * opfuncids while at it.  We don't need to bother with\n\t\t * canonicalize_qual() though, because partition expressions should be\n\t\t * in canonical form already (ie, no need for OR-merging or constant\n\t\t * elimination).\n\t\t */\n\t\texpr = eval_const_expressions(NULL, expr);\n\t\tfix_opfuncids(expr);\n\n\t\toldcxt = MemoryContextSwitchTo(partkeycxt);\n\t\tkey->partexprs = (List *) copyObject(expr);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/* Allocate assorted arrays in the partkeycxt, which we'll fill below */\n\toldcxt = MemoryContextSwitchTo(partkeycxt);\n\tkey->partattrs = (AttrNumber *) palloc0(key->partnatts * sizeof(AttrNumber));\n\tkey->partopfamily = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->partopcintype = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->partsupfunc = (FmgrInfo *) palloc0(key->partnatts * sizeof(FmgrInfo));\n\n\tkey->partcollation = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->parttypid = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->parttypmod = (int32 *) palloc0(key->partnatts * sizeof(int32));\n\tkey->parttyplen = (int16 *) palloc0(key->partnatts * sizeof(int16));\n\tkey->parttypbyval = (bool *) palloc0(key->partnatts * sizeof(bool));\n\tkey->parttypalign = (char *) palloc0(key->partnatts * sizeof(char));\n\tkey->parttypcoll = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* determine support function number to search for */\n\tprocnum = (key->strategy == PARTITION_STRATEGY_HASH) ?\n\t\tHASHEXTENDED_PROC : BTORDER_PROC;\n\n\t/* Copy partattrs and fill other per-attribute info */\n\tmemcpy(key->partattrs, attrs, key->partnatts * sizeof(int16));\n\tpartexprs_item = list_head(key->partexprs);\n\tfor (i = 0; i < key->partnatts; i++)\n\t{\n\t\tAttrNumber\tattno = key->partattrs[i];\n\t\tHeapTuple\topclasstup;\n\t\tForm_pg_opclass opclassform;\n\t\tOid\t\t\tfuncid;\n\n\t\t/* Collect opfamily information */\n\t\topclasstup = SearchSysCache1(CLAOID,\n\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(opclass->values[i]));\n\t\tif (!HeapTupleIsValid(opclasstup))\n\t\t\telog(ERROR, \"cache lookup failed for opclass %u\", opclass->values[i]);\n\n\t\topclassform = (Form_pg_opclass) GETSTRUCT(opclasstup);\n\t\tkey->partopfamily[i] = opclassform->opcfamily;\n\t\tkey->partopcintype[i] = opclassform->opcintype;\n\n\t\t/* Get a support function for the specified opfamily and datatypes */\n\t\tfuncid = get_opfamily_proc(opclassform->opcfamily,\n\t\t\t\t\t\t\t\t   opclassform->opcintype,\n\t\t\t\t\t\t\t\t   opclassform->opcintype,\n\t\t\t\t\t\t\t\t   procnum);\n\t\tif (!OidIsValid(funcid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t\t errmsg(\"operator class \\\"%s\\\" of access method %s is missing support function %d for type %s\",\n\t\t\t\t\t\t\tNameStr(opclassform->opcname),\n\t\t\t\t\t\t\t(key->strategy == PARTITION_STRATEGY_HASH) ?\n\t\t\t\t\t\t\t\"hash\" : \"btree\",\n\t\t\t\t\t\t\tprocnum,\n\t\t\t\t\t\t\tformat_type_be(opclassform->opcintype))));\n\n\t\tfmgr_info_cxt(funcid, &key->partsupfunc[i], partkeycxt);\n\n\t\t/* Collation */\n\t\tkey->partcollation[i] = collation->values[i];\n\n\t\t/* Collect type information */\n\t\tif (attno != 0)\n\t\t{\n\t\t\tForm_pg_attribute att = TupleDescAttr(relation->rd_att, attno - 1);\n\n\t\t\tkey->parttypid[i] = att->atttypid;\n\t\t\tkey->parttypmod[i] = att->atttypmod;\n\t\t\tkey->parttypcoll[i] = att->attcollation;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (partexprs_item == NULL)\n\t\t\t\telog(ERROR, \"wrong number of partition key expressions\");\n\n\t\t\tkey->parttypid[i] = exprType(lfirst(partexprs_item));\n\t\t\tkey->parttypmod[i] = exprTypmod(lfirst(partexprs_item));\n\t\t\tkey->parttypcoll[i] = exprCollation(lfirst(partexprs_item));\n\n\t\t\tpartexprs_item = lnext(partexprs_item);\n\t\t}\n\t\tget_typlenbyvalalign(key->parttypid[i],\n\t\t\t\t\t\t\t &key->parttyplen[i],\n\t\t\t\t\t\t\t &key->parttypbyval[i],\n\t\t\t\t\t\t\t &key->parttypalign[i]);\n\n\t\tReleaseSysCache(opclasstup);\n\t}\n\n\tReleaseSysCache(tuple);\n\n\t/* Assert that we're not leaking any old data during assignments below */\n\tAssert(relation->rd_partkeycxt == NULL);\n\tAssert(relation->rd_partkey == NULL);\n\n\t/*\n\t * Success --- reparent our context and make the relcache point to the\n\t * newly constructed key\n\t */\n\tMemoryContextSetParent(partkeycxt, CacheMemoryContext);\n\trelation->rd_partkeycxt = partkeycxt;\n\trelation->rd_partkey = key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relation->rd_rsdesc != NULL"
          ],
          "line": 3806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationBuildRowSecurity",
          "args": [
            "relation"
          ],
          "line": 3804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationBuildTriggers",
          "args": [
            "relation"
          ],
          "line": 3789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationBuildRuleLock",
          "args": [
            "relation"
          ],
          "line": 3782
        },
        "resolved": true,
        "details": {
          "function_name": "RelationBuildRuleLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "723-875",
          "snippet": "static void\nRelationBuildRuleLock(Relation relation)\n{\n\tMemoryContext rulescxt;\n\tMemoryContext oldcxt;\n\tHeapTuple\trewrite_tuple;\n\tRelation\trewrite_desc;\n\tTupleDesc\trewrite_tupdesc;\n\tSysScanDesc rewrite_scan;\n\tScanKeyData key;\n\tRuleLock   *rulelock;\n\tint\t\t\tnumlocks;\n\tRewriteRule **rules;\n\tint\t\t\tmaxlocks;\n\n\t/*\n\t * Make the private context.  Assume it'll not contain much data.\n\t */\n\trulescxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t \"relation rules\",\n\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\trelation->rd_rulescxt = rulescxt;\n\tMemoryContextCopyAndSetIdentifier(rulescxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(relation));\n\n\t/*\n\t * allocate an array to hold the rewrite rules (the array is extended if\n\t * necessary)\n\t */\n\tmaxlocks = 4;\n\trules = (RewriteRule **)\n\t\tMemoryContextAlloc(rulescxt, sizeof(RewriteRule *) * maxlocks);\n\tnumlocks = 0;\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key,\n\t\t\t\tAnum_pg_rewrite_ev_class,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\t/*\n\t * open pg_rewrite and begin a scan\n\t *\n\t * Note: since we scan the rules using RewriteRelRulenameIndexId, we will\n\t * be reading the rules in name order, except possibly during\n\t * emergency-recovery operations (ie, IgnoreSystemIndexes). This in turn\n\t * ensures that rules will be fired in name order.\n\t */\n\trewrite_desc = heap_open(RewriteRelationId, AccessShareLock);\n\trewrite_tupdesc = RelationGetDescr(rewrite_desc);\n\trewrite_scan = systable_beginscan(rewrite_desc,\n\t\t\t\t\t\t\t\t\t  RewriteRelRulenameIndexId,\n\t\t\t\t\t\t\t\t\t  true, NULL,\n\t\t\t\t\t\t\t\t\t  1, &key);\n\n\twhile (HeapTupleIsValid(rewrite_tuple = systable_getnext(rewrite_scan)))\n\t{\n\t\tForm_pg_rewrite rewrite_form = (Form_pg_rewrite) GETSTRUCT(rewrite_tuple);\n\t\tbool\t\tisnull;\n\t\tDatum\t\trule_datum;\n\t\tchar\t   *rule_str;\n\t\tRewriteRule *rule;\n\n\t\trule = (RewriteRule *) MemoryContextAlloc(rulescxt,\n\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(RewriteRule));\n\n\t\trule->ruleId = HeapTupleGetOid(rewrite_tuple);\n\n\t\trule->event = rewrite_form->ev_type - '0';\n\t\trule->enabled = rewrite_form->ev_enabled;\n\t\trule->isInstead = rewrite_form->is_instead;\n\n\t\t/*\n\t\t * Must use heap_getattr to fetch ev_action and ev_qual.  Also, the\n\t\t * rule strings are often large enough to be toasted.  To avoid\n\t\t * leaking memory in the caller's context, do the detoasting here so\n\t\t * we can free the detoasted version.\n\t\t */\n\t\trule_datum = heap_getattr(rewrite_tuple,\n\t\t\t\t\t\t\t\t  Anum_pg_rewrite_ev_action,\n\t\t\t\t\t\t\t\t  rewrite_tupdesc,\n\t\t\t\t\t\t\t\t  &isnull);\n\t\tAssert(!isnull);\n\t\trule_str = TextDatumGetCString(rule_datum);\n\t\toldcxt = MemoryContextSwitchTo(rulescxt);\n\t\trule->actions = (List *) stringToNode(rule_str);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t\tpfree(rule_str);\n\n\t\trule_datum = heap_getattr(rewrite_tuple,\n\t\t\t\t\t\t\t\t  Anum_pg_rewrite_ev_qual,\n\t\t\t\t\t\t\t\t  rewrite_tupdesc,\n\t\t\t\t\t\t\t\t  &isnull);\n\t\tAssert(!isnull);\n\t\trule_str = TextDatumGetCString(rule_datum);\n\t\toldcxt = MemoryContextSwitchTo(rulescxt);\n\t\trule->qual = (Node *) stringToNode(rule_str);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t\tpfree(rule_str);\n\n\t\t/*\n\t\t * We want the rule's table references to be checked as though by the\n\t\t * table owner, not the user referencing the rule.  Therefore, scan\n\t\t * through the rule's actions and set the checkAsUser field on all\n\t\t * rtable entries.  We have to look at the qual as well, in case it\n\t\t * contains sublinks.\n\t\t *\n\t\t * The reason for doing this when the rule is loaded, rather than when\n\t\t * it is stored, is that otherwise ALTER TABLE OWNER would have to\n\t\t * grovel through stored rules to update checkAsUser fields. Scanning\n\t\t * the rule tree during load is relatively cheap (compared to\n\t\t * constructing it in the first place), so we do it here.\n\t\t */\n\t\tsetRuleCheckAsUser((Node *) rule->actions, relation->rd_rel->relowner);\n\t\tsetRuleCheckAsUser(rule->qual, relation->rd_rel->relowner);\n\n\t\tif (numlocks >= maxlocks)\n\t\t{\n\t\t\tmaxlocks *= 2;\n\t\t\trules = (RewriteRule **)\n\t\t\t\trepalloc(rules, sizeof(RewriteRule *) * maxlocks);\n\t\t}\n\t\trules[numlocks++] = rule;\n\t}\n\n\t/*\n\t * end the scan and close the attribute relation\n\t */\n\tsystable_endscan(rewrite_scan);\n\theap_close(rewrite_desc, AccessShareLock);\n\n\t/*\n\t * there might not be any rules (if relhasrules is out-of-date)\n\t */\n\tif (numlocks == 0)\n\t{\n\t\trelation->rd_rules = NULL;\n\t\trelation->rd_rulescxt = NULL;\n\t\tMemoryContextDelete(rulescxt);\n\t\treturn;\n\t}\n\n\t/*\n\t * form a RuleLock and insert into relation\n\t */\n\trulelock = (RuleLock *) MemoryContextAlloc(rulescxt, sizeof(RuleLock));\n\trulelock->numLocks = numlocks;\n\trulelock->rules = rules;\n\n\trelation->rd_rules = rulelock;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationBuildRuleLock(Relation relation)\n{\n\tMemoryContext rulescxt;\n\tMemoryContext oldcxt;\n\tHeapTuple\trewrite_tuple;\n\tRelation\trewrite_desc;\n\tTupleDesc\trewrite_tupdesc;\n\tSysScanDesc rewrite_scan;\n\tScanKeyData key;\n\tRuleLock   *rulelock;\n\tint\t\t\tnumlocks;\n\tRewriteRule **rules;\n\tint\t\t\tmaxlocks;\n\n\t/*\n\t * Make the private context.  Assume it'll not contain much data.\n\t */\n\trulescxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t \"relation rules\",\n\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\trelation->rd_rulescxt = rulescxt;\n\tMemoryContextCopyAndSetIdentifier(rulescxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(relation));\n\n\t/*\n\t * allocate an array to hold the rewrite rules (the array is extended if\n\t * necessary)\n\t */\n\tmaxlocks = 4;\n\trules = (RewriteRule **)\n\t\tMemoryContextAlloc(rulescxt, sizeof(RewriteRule *) * maxlocks);\n\tnumlocks = 0;\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key,\n\t\t\t\tAnum_pg_rewrite_ev_class,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\t/*\n\t * open pg_rewrite and begin a scan\n\t *\n\t * Note: since we scan the rules using RewriteRelRulenameIndexId, we will\n\t * be reading the rules in name order, except possibly during\n\t * emergency-recovery operations (ie, IgnoreSystemIndexes). This in turn\n\t * ensures that rules will be fired in name order.\n\t */\n\trewrite_desc = heap_open(RewriteRelationId, AccessShareLock);\n\trewrite_tupdesc = RelationGetDescr(rewrite_desc);\n\trewrite_scan = systable_beginscan(rewrite_desc,\n\t\t\t\t\t\t\t\t\t  RewriteRelRulenameIndexId,\n\t\t\t\t\t\t\t\t\t  true, NULL,\n\t\t\t\t\t\t\t\t\t  1, &key);\n\n\twhile (HeapTupleIsValid(rewrite_tuple = systable_getnext(rewrite_scan)))\n\t{\n\t\tForm_pg_rewrite rewrite_form = (Form_pg_rewrite) GETSTRUCT(rewrite_tuple);\n\t\tbool\t\tisnull;\n\t\tDatum\t\trule_datum;\n\t\tchar\t   *rule_str;\n\t\tRewriteRule *rule;\n\n\t\trule = (RewriteRule *) MemoryContextAlloc(rulescxt,\n\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(RewriteRule));\n\n\t\trule->ruleId = HeapTupleGetOid(rewrite_tuple);\n\n\t\trule->event = rewrite_form->ev_type - '0';\n\t\trule->enabled = rewrite_form->ev_enabled;\n\t\trule->isInstead = rewrite_form->is_instead;\n\n\t\t/*\n\t\t * Must use heap_getattr to fetch ev_action and ev_qual.  Also, the\n\t\t * rule strings are often large enough to be toasted.  To avoid\n\t\t * leaking memory in the caller's context, do the detoasting here so\n\t\t * we can free the detoasted version.\n\t\t */\n\t\trule_datum = heap_getattr(rewrite_tuple,\n\t\t\t\t\t\t\t\t  Anum_pg_rewrite_ev_action,\n\t\t\t\t\t\t\t\t  rewrite_tupdesc,\n\t\t\t\t\t\t\t\t  &isnull);\n\t\tAssert(!isnull);\n\t\trule_str = TextDatumGetCString(rule_datum);\n\t\toldcxt = MemoryContextSwitchTo(rulescxt);\n\t\trule->actions = (List *) stringToNode(rule_str);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t\tpfree(rule_str);\n\n\t\trule_datum = heap_getattr(rewrite_tuple,\n\t\t\t\t\t\t\t\t  Anum_pg_rewrite_ev_qual,\n\t\t\t\t\t\t\t\t  rewrite_tupdesc,\n\t\t\t\t\t\t\t\t  &isnull);\n\t\tAssert(!isnull);\n\t\trule_str = TextDatumGetCString(rule_datum);\n\t\toldcxt = MemoryContextSwitchTo(rulescxt);\n\t\trule->qual = (Node *) stringToNode(rule_str);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t\tpfree(rule_str);\n\n\t\t/*\n\t\t * We want the rule's table references to be checked as though by the\n\t\t * table owner, not the user referencing the rule.  Therefore, scan\n\t\t * through the rule's actions and set the checkAsUser field on all\n\t\t * rtable entries.  We have to look at the qual as well, in case it\n\t\t * contains sublinks.\n\t\t *\n\t\t * The reason for doing this when the rule is loaded, rather than when\n\t\t * it is stored, is that otherwise ALTER TABLE OWNER would have to\n\t\t * grovel through stored rules to update checkAsUser fields. Scanning\n\t\t * the rule tree during load is relatively cheap (compared to\n\t\t * constructing it in the first place), so we do it here.\n\t\t */\n\t\tsetRuleCheckAsUser((Node *) rule->actions, relation->rd_rel->relowner);\n\t\tsetRuleCheckAsUser(rule->qual, relation->rd_rel->relowner);\n\n\t\tif (numlocks >= maxlocks)\n\t\t{\n\t\t\tmaxlocks *= 2;\n\t\t\trules = (RewriteRule **)\n\t\t\t\trepalloc(rules, sizeof(RewriteRule *) * maxlocks);\n\t\t}\n\t\trules[numlocks++] = rule;\n\t}\n\n\t/*\n\t * end the scan and close the attribute relation\n\t */\n\tsystable_endscan(rewrite_scan);\n\theap_close(rewrite_desc, AccessShareLock);\n\n\t/*\n\t * there might not be any rules (if relhasrules is out-of-date)\n\t */\n\tif (numlocks == 0)\n\t{\n\t\trelation->rd_rules = NULL;\n\t\trelation->rd_rulescxt = NULL;\n\t\tMemoryContextDelete(rulescxt);\n\t\treturn;\n\t}\n\n\t/*\n\t * form a RuleLock and insert into relation\n\t */\n\trulelock = (RuleLock *) MemoryContextAlloc(rulescxt, sizeof(RuleLock));\n\trulelock->numLocks = numlocks;\n\trulelock->rules = rules;\n\n\trelation->rd_rules = rulelock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid relowner in pg_class entry for \\\"%s\\\"\"",
            "RelationGetRelationName(relation)"
          ],
          "line": 3766
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "relation"
          ],
          "line": 3767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "htup"
          ],
          "line": 3762
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relation->rd_att->tdhasoid == relp->relhasoids"
          ],
          "line": 3760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relation->rd_att->tdtypmod == -1"
          ],
          "line": 3759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relation->rd_att->tdtypeid == relp->reltype"
          ],
          "line": 3758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationParseRelOptions",
          "args": [
            "relation",
            "htup"
          ],
          "line": 3750
        },
        "resolved": true,
        "details": {
          "function_name": "RelationParseRelOptions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "434-483",
          "snippet": "static void\nRelationParseRelOptions(Relation relation, HeapTuple tuple)\n{\n\tbytea\t   *options;\n\tamoptions_function amoptsfn;\n\n\trelation->rd_options = NULL;\n\n\t/*\n\t * Look up any AM-specific parse function; fall out if relkind should not\n\t * have options.\n\t */\n\tswitch (relation->rd_rel->relkind)\n\t{\n\t\tcase RELKIND_RELATION:\n\t\tcase RELKIND_TOASTVALUE:\n\t\tcase RELKIND_VIEW:\n\t\tcase RELKIND_MATVIEW:\n\t\tcase RELKIND_PARTITIONED_TABLE:\n\t\t\tamoptsfn = NULL;\n\t\t\tbreak;\n\t\tcase RELKIND_INDEX:\n\t\tcase RELKIND_PARTITIONED_INDEX:\n\t\t\tamoptsfn = relation->rd_amroutine->amoptions;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Fetch reloptions from tuple; have to use a hardwired descriptor because\n\t * we might not have any other for pg_class yet (consider executing this\n\t * code for pg_class itself)\n\t */\n\toptions = extractRelOptions(tuple, GetPgClassDescriptor(), amoptsfn);\n\n\t/*\n\t * Copy parsed data into CacheMemoryContext.  To guard against the\n\t * possibility of leaks in the reloptions code, we want to do the actual\n\t * parsing in the caller's memory context and copy the results into\n\t * CacheMemoryContext after the fact.\n\t */\n\tif (options)\n\t{\n\t\trelation->rd_options = MemoryContextAlloc(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t  VARSIZE(options));\n\t\tmemcpy(relation->rd_options, options, VARSIZE(options));\n\t\tpfree(options);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static TupleDesc GetPgClassDescriptor(void);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic TupleDesc GetPgClassDescriptor(void);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationParseRelOptions(Relation relation, HeapTuple tuple)\n{\n\tbytea\t   *options;\n\tamoptions_function amoptsfn;\n\n\trelation->rd_options = NULL;\n\n\t/*\n\t * Look up any AM-specific parse function; fall out if relkind should not\n\t * have options.\n\t */\n\tswitch (relation->rd_rel->relkind)\n\t{\n\t\tcase RELKIND_RELATION:\n\t\tcase RELKIND_TOASTVALUE:\n\t\tcase RELKIND_VIEW:\n\t\tcase RELKIND_MATVIEW:\n\t\tcase RELKIND_PARTITIONED_TABLE:\n\t\t\tamoptsfn = NULL;\n\t\t\tbreak;\n\t\tcase RELKIND_INDEX:\n\t\tcase RELKIND_PARTITIONED_INDEX:\n\t\t\tamoptsfn = relation->rd_amroutine->amoptions;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Fetch reloptions from tuple; have to use a hardwired descriptor because\n\t * we might not have any other for pg_class yet (consider executing this\n\t * code for pg_class itself)\n\t */\n\toptions = extractRelOptions(tuple, GetPgClassDescriptor(), amoptsfn);\n\n\t/*\n\t * Copy parsed data into CacheMemoryContext.  To guard against the\n\t * possibility of leaks in the reloptions code, we want to do the actual\n\t * parsing in the caller's memory context and copy the results into\n\t * CacheMemoryContext after the fact.\n\t */\n\tif (options)\n\t{\n\t\trelation->rd_options = MemoryContextAlloc(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t  VARSIZE(options));\n\t\tmemcpy(relation->rd_options, options, VARSIZE(options));\n\t\tpfree(options);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "relation->rd_options"
          ],
          "line": 3749
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) relation->rd_rel",
            "(char *) relp",
            "CLASS_TUPLE_SIZE"
          ],
          "line": 3745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "htup"
          ],
          "line": 3739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 3738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "htup"
          ],
          "line": 3736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "RELOID",
            "ObjectIdGetDatum(RelationGetRelid(relation))"
          ],
          "line": 3734
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "RelationGetRelid(relation)"
          ],
          "line": 3735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 3735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationIncrementReferenceCount",
          "args": [
            "relation"
          ],
          "line": 3724
        },
        "resolved": true,
        "details": {
          "function_name": "RelationIncrementReferenceCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1975-1982",
          "snippet": "void\nRelationIncrementReferenceCount(Relation rel)\n{\n\tResourceOwnerEnlargeRelationRefs(CurrentResourceOwner);\n\trel->rd_refcnt += 1;\n\tif (!IsBootstrapProcessingMode())\n\t\tResourceOwnerRememberRelationRef(CurrentResourceOwner, rel);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nvoid\nRelationIncrementReferenceCount(Relation rel)\n{\n\tResourceOwnerEnlargeRelationRefs(CurrentResourceOwner);\n\trel->rd_refcnt += 1;\n\tif (!IsBootstrapProcessingMode())\n\t\tResourceOwnerRememberRelationRef(CurrentResourceOwner, rel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_search",
          "args": [
            "&status"
          ],
          "line": 3716
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1388-1462",
          "snippet": "void *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_critical_index",
          "args": [
            "SharedSecLabelObjectIndexId",
            "SharedSecLabelRelationId"
          ],
          "line": 3690
        },
        "resolved": true,
        "details": {
          "function_name": "load_critical_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "3868-3888",
          "snippet": "static void\nload_critical_index(Oid indexoid, Oid heapoid)\n{\n\tRelation\tird;\n\n\t/*\n\t * We must lock the underlying catalog before locking the index to avoid\n\t * deadlock, since RelationBuildDesc might well need to read the catalog,\n\t * and if anyone else is exclusive-locking this catalog and index they'll\n\t * be doing it in that order.\n\t */\n\tLockRelationOid(heapoid, AccessShareLock);\n\tLockRelationOid(indexoid, AccessShareLock);\n\tird = RelationBuildDesc(indexoid, true);\n\tif (ird == NULL)\n\t\telog(PANIC, \"could not open critical system index %u\", indexoid);\n\tird->rd_isnailed = true;\n\tird->rd_refcnt = 1;\n\tUnlockRelationOid(indexoid, AccessShareLock);\n\tUnlockRelationOid(heapoid, AccessShareLock);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void load_critical_index(Oid indexoid, Oid heapoid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void load_critical_index(Oid indexoid, Oid heapoid);\n\nstatic void\nload_critical_index(Oid indexoid, Oid heapoid)\n{\n\tRelation\tird;\n\n\t/*\n\t * We must lock the underlying catalog before locking the index to avoid\n\t * deadlock, since RelationBuildDesc might well need to read the catalog,\n\t * and if anyone else is exclusive-locking this catalog and index they'll\n\t * be doing it in that order.\n\t */\n\tLockRelationOid(heapoid, AccessShareLock);\n\tLockRelationOid(indexoid, AccessShareLock);\n\tird = RelationBuildDesc(indexoid, true);\n\tif (ird == NULL)\n\t\telog(PANIC, \"could not open critical system index %u\", indexoid);\n\tird->rd_isnailed = true;\n\tird->rd_refcnt = 1;\n\tUnlockRelationOid(indexoid, AccessShareLock);\n\tUnlockRelationOid(heapoid, AccessShareLock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 3616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 3613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "formrdesc",
          "args": [
            "\"pg_type\"",
            "TypeRelation_Rowtype_Id",
            "false",
            "true",
            "Natts_pg_type",
            "Desc_pg_type"
          ],
          "line": 3607
        },
        "resolved": true,
        "details": {
          "function_name": "formrdesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1729-1885",
          "snippet": "static void\nformrdesc(const char *relationName, Oid relationReltype,\n\t\t  bool isshared, bool hasoids,\n\t\t  int natts, const FormData_pg_attribute *attrs)\n{\n\tRelation\trelation;\n\tint\t\t\ti;\n\tbool\t\thas_not_null;\n\n\t/*\n\t * allocate new relation desc, clear all fields of reldesc\n\t */\n\trelation = (Relation) palloc0(sizeof(RelationData));\n\n\t/* make sure relation is marked as having no open file yet */\n\trelation->rd_smgr = NULL;\n\n\t/*\n\t * initialize reference count: 1 because it is nailed in cache\n\t */\n\trelation->rd_refcnt = 1;\n\n\t/*\n\t * all entries built with this routine are nailed-in-cache; none are for\n\t * new or temp relations.\n\t */\n\trelation->rd_isnailed = true;\n\trelation->rd_createSubid = InvalidSubTransactionId;\n\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\trelation->rd_backend = InvalidBackendId;\n\trelation->rd_islocaltemp = false;\n\n\t/*\n\t * initialize relation tuple form\n\t *\n\t * The data we insert here is pretty incomplete/bogus, but it'll serve to\n\t * get us launched.  RelationCacheInitializePhase3() will read the real\n\t * data from pg_class and replace what we've done here.  Note in\n\t * particular that relowner is left as zero; this cues\n\t * RelationCacheInitializePhase3 that the real data isn't there yet.\n\t */\n\trelation->rd_rel = (Form_pg_class) palloc0(CLASS_TUPLE_SIZE);\n\n\tnamestrcpy(&relation->rd_rel->relname, relationName);\n\trelation->rd_rel->relnamespace = PG_CATALOG_NAMESPACE;\n\trelation->rd_rel->reltype = relationReltype;\n\n\t/*\n\t * It's important to distinguish between shared and non-shared relations,\n\t * even at bootstrap time, to make sure we know where they are stored.\n\t */\n\trelation->rd_rel->relisshared = isshared;\n\tif (isshared)\n\t\trelation->rd_rel->reltablespace = GLOBALTABLESPACE_OID;\n\n\t/* formrdesc is used only for permanent relations */\n\trelation->rd_rel->relpersistence = RELPERSISTENCE_PERMANENT;\n\n\t/* ... and they're always populated, too */\n\trelation->rd_rel->relispopulated = true;\n\n\trelation->rd_rel->relreplident = REPLICA_IDENTITY_NOTHING;\n\trelation->rd_rel->relpages = 0;\n\trelation->rd_rel->reltuples = 0;\n\trelation->rd_rel->relallvisible = 0;\n\trelation->rd_rel->relkind = RELKIND_RELATION;\n\trelation->rd_rel->relhasoids = hasoids;\n\trelation->rd_rel->relnatts = (int16) natts;\n\n\t/*\n\t * initialize attribute tuple form\n\t *\n\t * Unlike the case with the relation tuple, this data had better be right\n\t * because it will never be replaced.  The data comes from\n\t * src/include/catalog/ headers via genbki.pl.\n\t */\n\trelation->rd_att = CreateTemplateTupleDesc(natts, hasoids);\n\trelation->rd_att->tdrefcount = 1;\t/* mark as refcounted */\n\n\trelation->rd_att->tdtypeid = relationReltype;\n\trelation->rd_att->tdtypmod = -1;\t/* unnecessary, but... */\n\n\t/*\n\t * initialize tuple desc info\n\t */\n\thas_not_null = false;\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tmemcpy(TupleDescAttr(relation->rd_att, i),\n\t\t\t   &attrs[i],\n\t\t\t   ATTRIBUTE_FIXED_PART_SIZE);\n\t\thas_not_null |= attrs[i].attnotnull;\n\t\t/* make sure attcacheoff is valid */\n\t\tTupleDescAttr(relation->rd_att, i)->attcacheoff = -1;\n\t}\n\n\t/* initialize first attribute's attcacheoff, cf RelationBuildTupleDesc */\n\tTupleDescAttr(relation->rd_att, 0)->attcacheoff = 0;\n\n\t/* mark not-null status */\n\tif (has_not_null)\n\t{\n\t\tTupleConstr *constr = (TupleConstr *) palloc0(sizeof(TupleConstr));\n\n\t\tconstr->has_not_null = true;\n\t\trelation->rd_att->constr = constr;\n\t}\n\n\t/*\n\t * initialize relation id from info in att array (my, this is ugly)\n\t */\n\tRelationGetRelid(relation) = TupleDescAttr(relation->rd_att, 0)->attrelid;\n\n\t/*\n\t * All relations made with formrdesc are mapped.  This is necessarily so\n\t * because there is no other way to know what filenode they currently\n\t * have.  In bootstrap mode, add them to the initial relation mapper data,\n\t * specifying that the initial filenode is the same as the OID.\n\t */\n\trelation->rd_rel->relfilenode = InvalidOid;\n\tif (IsBootstrapProcessingMode())\n\t\tRelationMapUpdateMap(RelationGetRelid(relation),\n\t\t\t\t\t\t\t RelationGetRelid(relation),\n\t\t\t\t\t\t\t isshared, true);\n\n\t/*\n\t * initialize the relation lock manager information\n\t */\n\tRelationInitLockInfo(relation); /* see lmgr.c */\n\n\t/*\n\t * initialize physical addressing information for the relation\n\t */\n\tRelationInitPhysicalAddr(relation);\n\n\t/*\n\t * initialize the rel-has-index flag, using hardwired knowledge\n\t */\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\t/* In bootstrap mode, we have no indexes */\n\t\trelation->rd_rel->relhasindex = false;\n\t}\n\telse\n\t{\n\t\t/* Otherwise, all the rels formrdesc is used for have indexes */\n\t\trelation->rd_rel->relhasindex = true;\n\t}\n\n\t/*\n\t * add new reldesc to relcache\n\t */\n\tRelationCacheInsert(relation, false);\n\n\t/* It's fully valid */\n\trelation->rd_isvalid = true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static bool load_relcache_init_file(bool shared);",
            "static void write_relcache_init_file(bool shared);",
            "static void formrdesc(const char *relationName, Oid relationReltype,\n\t\t  bool isshared, bool hasoids,\n\t\t  int natts, const FormData_pg_attribute *attrs);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic bool load_relcache_init_file(bool shared);\nstatic void write_relcache_init_file(bool shared);\nstatic void formrdesc(const char *relationName, Oid relationReltype,\n\t\t  bool isshared, bool hasoids,\n\t\t  int natts, const FormData_pg_attribute *attrs);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nformrdesc(const char *relationName, Oid relationReltype,\n\t\t  bool isshared, bool hasoids,\n\t\t  int natts, const FormData_pg_attribute *attrs)\n{\n\tRelation\trelation;\n\tint\t\t\ti;\n\tbool\t\thas_not_null;\n\n\t/*\n\t * allocate new relation desc, clear all fields of reldesc\n\t */\n\trelation = (Relation) palloc0(sizeof(RelationData));\n\n\t/* make sure relation is marked as having no open file yet */\n\trelation->rd_smgr = NULL;\n\n\t/*\n\t * initialize reference count: 1 because it is nailed in cache\n\t */\n\trelation->rd_refcnt = 1;\n\n\t/*\n\t * all entries built with this routine are nailed-in-cache; none are for\n\t * new or temp relations.\n\t */\n\trelation->rd_isnailed = true;\n\trelation->rd_createSubid = InvalidSubTransactionId;\n\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\trelation->rd_backend = InvalidBackendId;\n\trelation->rd_islocaltemp = false;\n\n\t/*\n\t * initialize relation tuple form\n\t *\n\t * The data we insert here is pretty incomplete/bogus, but it'll serve to\n\t * get us launched.  RelationCacheInitializePhase3() will read the real\n\t * data from pg_class and replace what we've done here.  Note in\n\t * particular that relowner is left as zero; this cues\n\t * RelationCacheInitializePhase3 that the real data isn't there yet.\n\t */\n\trelation->rd_rel = (Form_pg_class) palloc0(CLASS_TUPLE_SIZE);\n\n\tnamestrcpy(&relation->rd_rel->relname, relationName);\n\trelation->rd_rel->relnamespace = PG_CATALOG_NAMESPACE;\n\trelation->rd_rel->reltype = relationReltype;\n\n\t/*\n\t * It's important to distinguish between shared and non-shared relations,\n\t * even at bootstrap time, to make sure we know where they are stored.\n\t */\n\trelation->rd_rel->relisshared = isshared;\n\tif (isshared)\n\t\trelation->rd_rel->reltablespace = GLOBALTABLESPACE_OID;\n\n\t/* formrdesc is used only for permanent relations */\n\trelation->rd_rel->relpersistence = RELPERSISTENCE_PERMANENT;\n\n\t/* ... and they're always populated, too */\n\trelation->rd_rel->relispopulated = true;\n\n\trelation->rd_rel->relreplident = REPLICA_IDENTITY_NOTHING;\n\trelation->rd_rel->relpages = 0;\n\trelation->rd_rel->reltuples = 0;\n\trelation->rd_rel->relallvisible = 0;\n\trelation->rd_rel->relkind = RELKIND_RELATION;\n\trelation->rd_rel->relhasoids = hasoids;\n\trelation->rd_rel->relnatts = (int16) natts;\n\n\t/*\n\t * initialize attribute tuple form\n\t *\n\t * Unlike the case with the relation tuple, this data had better be right\n\t * because it will never be replaced.  The data comes from\n\t * src/include/catalog/ headers via genbki.pl.\n\t */\n\trelation->rd_att = CreateTemplateTupleDesc(natts, hasoids);\n\trelation->rd_att->tdrefcount = 1;\t/* mark as refcounted */\n\n\trelation->rd_att->tdtypeid = relationReltype;\n\trelation->rd_att->tdtypmod = -1;\t/* unnecessary, but... */\n\n\t/*\n\t * initialize tuple desc info\n\t */\n\thas_not_null = false;\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tmemcpy(TupleDescAttr(relation->rd_att, i),\n\t\t\t   &attrs[i],\n\t\t\t   ATTRIBUTE_FIXED_PART_SIZE);\n\t\thas_not_null |= attrs[i].attnotnull;\n\t\t/* make sure attcacheoff is valid */\n\t\tTupleDescAttr(relation->rd_att, i)->attcacheoff = -1;\n\t}\n\n\t/* initialize first attribute's attcacheoff, cf RelationBuildTupleDesc */\n\tTupleDescAttr(relation->rd_att, 0)->attcacheoff = 0;\n\n\t/* mark not-null status */\n\tif (has_not_null)\n\t{\n\t\tTupleConstr *constr = (TupleConstr *) palloc0(sizeof(TupleConstr));\n\n\t\tconstr->has_not_null = true;\n\t\trelation->rd_att->constr = constr;\n\t}\n\n\t/*\n\t * initialize relation id from info in att array (my, this is ugly)\n\t */\n\tRelationGetRelid(relation) = TupleDescAttr(relation->rd_att, 0)->attrelid;\n\n\t/*\n\t * All relations made with formrdesc are mapped.  This is necessarily so\n\t * because there is no other way to know what filenode they currently\n\t * have.  In bootstrap mode, add them to the initial relation mapper data,\n\t * specifying that the initial filenode is the same as the OID.\n\t */\n\trelation->rd_rel->relfilenode = InvalidOid;\n\tif (IsBootstrapProcessingMode())\n\t\tRelationMapUpdateMap(RelationGetRelid(relation),\n\t\t\t\t\t\t\t RelationGetRelid(relation),\n\t\t\t\t\t\t\t isshared, true);\n\n\t/*\n\t * initialize the relation lock manager information\n\t */\n\tRelationInitLockInfo(relation); /* see lmgr.c */\n\n\t/*\n\t * initialize physical addressing information for the relation\n\t */\n\tRelationInitPhysicalAddr(relation);\n\n\t/*\n\t * initialize the rel-has-index flag, using hardwired knowledge\n\t */\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\t/* In bootstrap mode, we have no indexes */\n\t\trelation->rd_rel->relhasindex = false;\n\t}\n\telse\n\t{\n\t\t/* Otherwise, all the rels formrdesc is used for have indexes */\n\t\trelation->rd_rel->relhasindex = true;\n\t}\n\n\t/*\n\t * add new reldesc to relcache\n\t */\n\tRelationCacheInsert(relation, false);\n\n\t/* It's fully valid */\n\trelation->rd_isvalid = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_relcache_init_file",
          "args": [
            "false"
          ],
          "line": 3597
        },
        "resolved": true,
        "details": {
          "function_name": "load_relcache_init_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "5400-5787",
          "snippet": "static bool\nload_relcache_init_file(bool shared)\n{\n\tFILE\t   *fp;\n\tchar\t\tinitfilename[MAXPGPATH];\n\tRelation   *rels;\n\tint\t\t\trelno,\n\t\t\t\tnum_rels,\n\t\t\t\tmax_rels,\n\t\t\t\tnailed_rels,\n\t\t\t\tnailed_indexes,\n\t\t\t\tmagic;\n\tint\t\t\ti;\n\n\tif (shared)\n\t\tsnprintf(initfilename, sizeof(initfilename), \"global/%s\",\n\t\t\t\t RELCACHE_INIT_FILENAME);\n\telse\n\t\tsnprintf(initfilename, sizeof(initfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELCACHE_INIT_FILENAME);\n\n\tfp = AllocateFile(initfilename, PG_BINARY_R);\n\tif (fp == NULL)\n\t\treturn false;\n\n\t/*\n\t * Read the index relcache entries from the file.  Note we will not enter\n\t * any of them into the cache if the read fails partway through; this\n\t * helps to guard against broken init files.\n\t */\n\tmax_rels = 100;\n\trels = (Relation *) palloc(max_rels * sizeof(Relation));\n\tnum_rels = 0;\n\tnailed_rels = nailed_indexes = 0;\n\n\t/* check for correct magic number (compatible version) */\n\tif (fread(&magic, 1, sizeof(magic), fp) != sizeof(magic))\n\t\tgoto read_failed;\n\tif (magic != RELCACHE_INIT_FILEMAGIC)\n\t\tgoto read_failed;\n\n\tfor (relno = 0;; relno++)\n\t{\n\t\tSize\t\tlen;\n\t\tsize_t\t\tnread;\n\t\tRelation\trel;\n\t\tForm_pg_class relform;\n\t\tbool\t\thas_not_null;\n\n\t\t/* first read the relation descriptor length */\n\t\tnread = fread(&len, 1, sizeof(len), fp);\n\t\tif (nread != sizeof(len))\n\t\t{\n\t\t\tif (nread == 0)\n\t\t\t\tbreak;\t\t\t/* end of file */\n\t\t\tgoto read_failed;\n\t\t}\n\n\t\t/* safety check for incompatible relcache layout */\n\t\tif (len != sizeof(RelationData))\n\t\t\tgoto read_failed;\n\n\t\t/* allocate another relcache header */\n\t\tif (num_rels >= max_rels)\n\t\t{\n\t\t\tmax_rels *= 2;\n\t\t\trels = (Relation *) repalloc(rels, max_rels * sizeof(Relation));\n\t\t}\n\n\t\trel = rels[num_rels++] = (Relation) palloc(len);\n\n\t\t/* then, read the Relation structure */\n\t\tif (fread(rel, 1, len, fp) != len)\n\t\t\tgoto read_failed;\n\n\t\t/* next read the relation tuple form */\n\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\tgoto read_failed;\n\n\t\trelform = (Form_pg_class) palloc(len);\n\t\tif (fread(relform, 1, len, fp) != len)\n\t\t\tgoto read_failed;\n\n\t\trel->rd_rel = relform;\n\n\t\t/* initialize attribute tuple forms */\n\t\trel->rd_att = CreateTemplateTupleDesc(relform->relnatts,\n\t\t\t\t\t\t\t\t\t\t\t  relform->relhasoids);\n\t\trel->rd_att->tdrefcount = 1;\t/* mark as refcounted */\n\n\t\trel->rd_att->tdtypeid = relform->reltype;\n\t\trel->rd_att->tdtypmod = -1; /* unnecessary, but... */\n\n\t\t/* next read all the attribute tuple form data entries */\n\t\thas_not_null = false;\n\t\tfor (i = 0; i < relform->relnatts; i++)\n\t\t{\n\t\t\tForm_pg_attribute attr = TupleDescAttr(rel->rd_att, i);\n\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\t\t\tif (len != ATTRIBUTE_FIXED_PART_SIZE)\n\t\t\t\tgoto read_failed;\n\t\t\tif (fread(attr, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\thas_not_null |= attr->attnotnull;\n\t\t}\n\n\t\t/* next read the access method specific field */\n\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\tgoto read_failed;\n\t\tif (len > 0)\n\t\t{\n\t\t\trel->rd_options = palloc(len);\n\t\t\tif (fread(rel->rd_options, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\t\t\tif (len != VARSIZE(rel->rd_options))\n\t\t\t\tgoto read_failed;\t/* sanity check */\n\t\t}\n\t\telse\n\t\t{\n\t\t\trel->rd_options = NULL;\n\t\t}\n\n\t\t/* mark not-null status */\n\t\tif (has_not_null)\n\t\t{\n\t\t\tTupleConstr *constr = (TupleConstr *) palloc0(sizeof(TupleConstr));\n\n\t\t\tconstr->has_not_null = true;\n\t\t\trel->rd_att->constr = constr;\n\t\t}\n\n\t\t/*\n\t\t * If it's an index, there's more to do.  Note we explicitly ignore\n\t\t * partitioned indexes here.\n\t\t */\n\t\tif (rel->rd_rel->relkind == RELKIND_INDEX)\n\t\t{\n\t\t\tMemoryContext indexcxt;\n\t\t\tOid\t\t   *opfamily;\n\t\t\tOid\t\t   *opcintype;\n\t\t\tRegProcedure *support;\n\t\t\tint\t\t\tnsupport;\n\t\t\tint16\t   *indoption;\n\t\t\tOid\t\t   *indcollation;\n\n\t\t\t/* Count nailed indexes to ensure we have 'em all */\n\t\t\tif (rel->rd_isnailed)\n\t\t\t\tnailed_indexes++;\n\n\t\t\t/* next, read the pg_index tuple */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_indextuple = (HeapTuple) palloc(len);\n\t\t\tif (fread(rel->rd_indextuple, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\t/* Fix up internal pointers in the tuple -- see heap_copytuple */\n\t\t\trel->rd_indextuple->t_data = (HeapTupleHeader) ((char *) rel->rd_indextuple + HEAPTUPLESIZE);\n\t\t\trel->rd_index = (Form_pg_index) GETSTRUCT(rel->rd_indextuple);\n\n\t\t\t/*\n\t\t\t * prepare index info context --- parameters should match\n\t\t\t * RelationInitIndexAccessInfo\n\t\t\t */\n\t\t\tindexcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t \"index info\",\n\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\t\t\trel->rd_indexcxt = indexcxt;\n\t\t\tMemoryContextCopyAndSetIdentifier(indexcxt,\n\t\t\t\t\t\t\t\t\t\t\t  RelationGetRelationName(rel));\n\n\t\t\t/*\n\t\t\t * Now we can fetch the index AM's API struct.  (We can't store\n\t\t\t * that in the init file, since it contains function pointers that\n\t\t\t * might vary across server executions.  Fortunately, it should be\n\t\t\t * safe to call the amhandler even while bootstrapping indexes.)\n\t\t\t */\n\t\t\tInitIndexAmRoutine(rel);\n\n\t\t\t/* next, read the vector of opfamily OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\topfamily = (Oid *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(opfamily, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_opfamily = opfamily;\n\n\t\t\t/* next, read the vector of opcintype OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\topcintype = (Oid *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(opcintype, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_opcintype = opcintype;\n\n\t\t\t/* next, read the vector of support procedure OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\t\t\tsupport = (RegProcedure *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(support, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_support = support;\n\n\t\t\t/* next, read the vector of collation OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\tindcollation = (Oid *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(indcollation, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_indcollation = indcollation;\n\n\t\t\t/* finally, read the vector of indoption values */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\tindoption = (int16 *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(indoption, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_indoption = indoption;\n\n\t\t\t/* set up zeroed fmgr-info vector */\n\t\t\tnsupport = relform->relnatts * rel->rd_amroutine->amsupport;\n\t\t\trel->rd_supportinfo = (FmgrInfo *)\n\t\t\t\tMemoryContextAllocZero(indexcxt, nsupport * sizeof(FmgrInfo));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Count nailed rels to ensure we have 'em all */\n\t\t\tif (rel->rd_isnailed)\n\t\t\t\tnailed_rels++;\n\n\t\t\tAssert(rel->rd_index == NULL);\n\t\t\tAssert(rel->rd_indextuple == NULL);\n\t\t\tAssert(rel->rd_indexcxt == NULL);\n\t\t\tAssert(rel->rd_amroutine == NULL);\n\t\t\tAssert(rel->rd_opfamily == NULL);\n\t\t\tAssert(rel->rd_opcintype == NULL);\n\t\t\tAssert(rel->rd_support == NULL);\n\t\t\tAssert(rel->rd_supportinfo == NULL);\n\t\t\tAssert(rel->rd_indoption == NULL);\n\t\t\tAssert(rel->rd_indcollation == NULL);\n\t\t}\n\n\t\t/*\n\t\t * Rules and triggers are not saved (mainly because the internal\n\t\t * format is complex and subject to change).  They must be rebuilt if\n\t\t * needed by RelationCacheInitializePhase3.  This is not expected to\n\t\t * be a big performance hit since few system catalogs have such. Ditto\n\t\t * for RLS policy data, partition info, index expressions, predicates,\n\t\t * exclusion info, and FDW info.\n\t\t */\n\t\trel->rd_rules = NULL;\n\t\trel->rd_rulescxt = NULL;\n\t\trel->trigdesc = NULL;\n\t\trel->rd_rsdesc = NULL;\n\t\trel->rd_partkey = NULL;\n\t\trel->rd_partkeycxt = NULL;\n\t\trel->rd_partdesc = NULL;\n\t\trel->rd_pdcxt = NULL;\n\t\trel->rd_partcheck = NIL;\n\t\trel->rd_partcheckvalid = false;\n\t\trel->rd_partcheckcxt = NULL;\n\t\trel->rd_indexprs = NIL;\n\t\trel->rd_indpred = NIL;\n\t\trel->rd_exclops = NULL;\n\t\trel->rd_exclprocs = NULL;\n\t\trel->rd_exclstrats = NULL;\n\t\trel->rd_fdwroutine = NULL;\n\n\t\t/*\n\t\t * Reset transient-state fields in the relcache entry\n\t\t */\n\t\trel->rd_smgr = NULL;\n\t\tif (rel->rd_isnailed)\n\t\t\trel->rd_refcnt = 1;\n\t\telse\n\t\t\trel->rd_refcnt = 0;\n\t\trel->rd_indexvalid = 0;\n\t\trel->rd_fkeylist = NIL;\n\t\trel->rd_fkeyvalid = false;\n\t\trel->rd_indexlist = NIL;\n\t\trel->rd_oidindex = InvalidOid;\n\t\trel->rd_pkindex = InvalidOid;\n\t\trel->rd_replidindex = InvalidOid;\n\t\trel->rd_indexattr = NULL;\n\t\trel->rd_projindexattr = NULL;\n\t\trel->rd_keyattr = NULL;\n\t\trel->rd_pkattr = NULL;\n\t\trel->rd_idattr = NULL;\n\t\trel->rd_projidx = NULL;\n\t\trel->rd_pubactions = NULL;\n\t\trel->rd_statvalid = false;\n\t\trel->rd_statlist = NIL;\n\t\trel->rd_createSubid = InvalidSubTransactionId;\n\t\trel->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\t\trel->rd_amcache = NULL;\n\t\tMemSet(&rel->pgstat_info, 0, sizeof(rel->pgstat_info));\n\n\t\t/*\n\t\t * Recompute lock and physical addressing info.  This is needed in\n\t\t * case the pg_internal.init file was copied from some other database\n\t\t * by CREATE DATABASE.\n\t\t */\n\t\tRelationInitLockInfo(rel);\n\t\tRelationInitPhysicalAddr(rel);\n\t}\n\n\t/*\n\t * We reached the end of the init file without apparent problem.  Did we\n\t * get the right number of nailed items?  This is a useful crosscheck in\n\t * case the set of critical rels or indexes changes.  However, that should\n\t * not happen in a normally-running system, so let's bleat if it does.\n\t *\n\t * For the shared init file, we're called before client authentication is\n\t * done, which means that elog(WARNING) will go only to the postmaster\n\t * log, where it's easily missed.  To ensure that developers notice bad\n\t * values of NUM_CRITICAL_SHARED_RELS/NUM_CRITICAL_SHARED_INDEXES, we put\n\t * an Assert(false) there.\n\t */\n\tif (shared)\n\t{\n\t\tif (nailed_rels != NUM_CRITICAL_SHARED_RELS ||\n\t\t\tnailed_indexes != NUM_CRITICAL_SHARED_INDEXES)\n\t\t{\n\t\t\telog(WARNING, \"found %d nailed shared rels and %d nailed shared indexes in init file, but expected %d and %d respectively\",\n\t\t\t\t nailed_rels, nailed_indexes,\n\t\t\t\t NUM_CRITICAL_SHARED_RELS, NUM_CRITICAL_SHARED_INDEXES);\n\t\t\t/* Make sure we get developers' attention about this */\n\t\t\tAssert(false);\n\t\t\t/* In production builds, recover by bootstrapping the relcache */\n\t\t\tgoto read_failed;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (nailed_rels != NUM_CRITICAL_LOCAL_RELS ||\n\t\t\tnailed_indexes != NUM_CRITICAL_LOCAL_INDEXES)\n\t\t{\n\t\t\telog(WARNING, \"found %d nailed rels and %d nailed indexes in init file, but expected %d and %d respectively\",\n\t\t\t\t nailed_rels, nailed_indexes,\n\t\t\t\t NUM_CRITICAL_LOCAL_RELS, NUM_CRITICAL_LOCAL_INDEXES);\n\t\t\t/* We don't need an Assert() in this case */\n\t\t\tgoto read_failed;\n\t\t}\n\t}\n\n\t/*\n\t * OK, all appears well.\n\t *\n\t * Now insert all the new relcache entries into the cache.\n\t */\n\tfor (relno = 0; relno < num_rels; relno++)\n\t{\n\t\tRelationCacheInsert(rels[relno], false);\n\t}\n\n\tpfree(rels);\n\tFreeFile(fp);\n\n\tif (shared)\n\t\tcriticalSharedRelcachesBuilt = true;\n\telse\n\t\tcriticalRelcachesBuilt = true;\n\treturn true;\n\n\t/*\n\t * init file is broken, so do it the hard way.  We don't bother trying to\n\t * free the clutter we just allocated; it's not in the relcache so it\n\t * won't hurt.\n\t */\nread_failed:\n\tpfree(rels);\n\tFreeFile(fp);\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_CRITICAL_SHARED_INDEXES 6\t/* fix if you change list above */",
            "#define NUM_CRITICAL_LOCAL_INDEXES\t7\t/* fix if you change list above */",
            "#define NUM_CRITICAL_LOCAL_RELS 4\t/* fix if you change list above */",
            "#define NUM_CRITICAL_SHARED_RELS\t5\t/* fix if you change list above */",
            "#define RELCACHE_INIT_FILEMAGIC\t\t0x573266\t/* version ID value */"
          ],
          "globals_used": [
            "bool\t\tcriticalRelcachesBuilt = false;",
            "bool\t\tcriticalSharedRelcachesBuilt = false;",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static bool load_relcache_init_file(bool shared);",
            "static void write_relcache_init_file(bool shared);",
            "static void write_item(const void *data, Size len, FILE *fp);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\n#define NUM_CRITICAL_SHARED_INDEXES 6\t/* fix if you change list above */\n#define NUM_CRITICAL_LOCAL_INDEXES\t7\t/* fix if you change list above */\n#define NUM_CRITICAL_LOCAL_RELS 4\t/* fix if you change list above */\n#define NUM_CRITICAL_SHARED_RELS\t5\t/* fix if you change list above */\n#define RELCACHE_INIT_FILEMAGIC\t\t0x573266\t/* version ID value */\n\nbool\t\tcriticalRelcachesBuilt = false;\nbool\t\tcriticalSharedRelcachesBuilt = false;\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic bool load_relcache_init_file(bool shared);\nstatic void write_relcache_init_file(bool shared);\nstatic void write_item(const void *data, Size len, FILE *fp);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic bool\nload_relcache_init_file(bool shared)\n{\n\tFILE\t   *fp;\n\tchar\t\tinitfilename[MAXPGPATH];\n\tRelation   *rels;\n\tint\t\t\trelno,\n\t\t\t\tnum_rels,\n\t\t\t\tmax_rels,\n\t\t\t\tnailed_rels,\n\t\t\t\tnailed_indexes,\n\t\t\t\tmagic;\n\tint\t\t\ti;\n\n\tif (shared)\n\t\tsnprintf(initfilename, sizeof(initfilename), \"global/%s\",\n\t\t\t\t RELCACHE_INIT_FILENAME);\n\telse\n\t\tsnprintf(initfilename, sizeof(initfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELCACHE_INIT_FILENAME);\n\n\tfp = AllocateFile(initfilename, PG_BINARY_R);\n\tif (fp == NULL)\n\t\treturn false;\n\n\t/*\n\t * Read the index relcache entries from the file.  Note we will not enter\n\t * any of them into the cache if the read fails partway through; this\n\t * helps to guard against broken init files.\n\t */\n\tmax_rels = 100;\n\trels = (Relation *) palloc(max_rels * sizeof(Relation));\n\tnum_rels = 0;\n\tnailed_rels = nailed_indexes = 0;\n\n\t/* check for correct magic number (compatible version) */\n\tif (fread(&magic, 1, sizeof(magic), fp) != sizeof(magic))\n\t\tgoto read_failed;\n\tif (magic != RELCACHE_INIT_FILEMAGIC)\n\t\tgoto read_failed;\n\n\tfor (relno = 0;; relno++)\n\t{\n\t\tSize\t\tlen;\n\t\tsize_t\t\tnread;\n\t\tRelation\trel;\n\t\tForm_pg_class relform;\n\t\tbool\t\thas_not_null;\n\n\t\t/* first read the relation descriptor length */\n\t\tnread = fread(&len, 1, sizeof(len), fp);\n\t\tif (nread != sizeof(len))\n\t\t{\n\t\t\tif (nread == 0)\n\t\t\t\tbreak;\t\t\t/* end of file */\n\t\t\tgoto read_failed;\n\t\t}\n\n\t\t/* safety check for incompatible relcache layout */\n\t\tif (len != sizeof(RelationData))\n\t\t\tgoto read_failed;\n\n\t\t/* allocate another relcache header */\n\t\tif (num_rels >= max_rels)\n\t\t{\n\t\t\tmax_rels *= 2;\n\t\t\trels = (Relation *) repalloc(rels, max_rels * sizeof(Relation));\n\t\t}\n\n\t\trel = rels[num_rels++] = (Relation) palloc(len);\n\n\t\t/* then, read the Relation structure */\n\t\tif (fread(rel, 1, len, fp) != len)\n\t\t\tgoto read_failed;\n\n\t\t/* next read the relation tuple form */\n\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\tgoto read_failed;\n\n\t\trelform = (Form_pg_class) palloc(len);\n\t\tif (fread(relform, 1, len, fp) != len)\n\t\t\tgoto read_failed;\n\n\t\trel->rd_rel = relform;\n\n\t\t/* initialize attribute tuple forms */\n\t\trel->rd_att = CreateTemplateTupleDesc(relform->relnatts,\n\t\t\t\t\t\t\t\t\t\t\t  relform->relhasoids);\n\t\trel->rd_att->tdrefcount = 1;\t/* mark as refcounted */\n\n\t\trel->rd_att->tdtypeid = relform->reltype;\n\t\trel->rd_att->tdtypmod = -1; /* unnecessary, but... */\n\n\t\t/* next read all the attribute tuple form data entries */\n\t\thas_not_null = false;\n\t\tfor (i = 0; i < relform->relnatts; i++)\n\t\t{\n\t\t\tForm_pg_attribute attr = TupleDescAttr(rel->rd_att, i);\n\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\t\t\tif (len != ATTRIBUTE_FIXED_PART_SIZE)\n\t\t\t\tgoto read_failed;\n\t\t\tif (fread(attr, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\thas_not_null |= attr->attnotnull;\n\t\t}\n\n\t\t/* next read the access method specific field */\n\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\tgoto read_failed;\n\t\tif (len > 0)\n\t\t{\n\t\t\trel->rd_options = palloc(len);\n\t\t\tif (fread(rel->rd_options, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\t\t\tif (len != VARSIZE(rel->rd_options))\n\t\t\t\tgoto read_failed;\t/* sanity check */\n\t\t}\n\t\telse\n\t\t{\n\t\t\trel->rd_options = NULL;\n\t\t}\n\n\t\t/* mark not-null status */\n\t\tif (has_not_null)\n\t\t{\n\t\t\tTupleConstr *constr = (TupleConstr *) palloc0(sizeof(TupleConstr));\n\n\t\t\tconstr->has_not_null = true;\n\t\t\trel->rd_att->constr = constr;\n\t\t}\n\n\t\t/*\n\t\t * If it's an index, there's more to do.  Note we explicitly ignore\n\t\t * partitioned indexes here.\n\t\t */\n\t\tif (rel->rd_rel->relkind == RELKIND_INDEX)\n\t\t{\n\t\t\tMemoryContext indexcxt;\n\t\t\tOid\t\t   *opfamily;\n\t\t\tOid\t\t   *opcintype;\n\t\t\tRegProcedure *support;\n\t\t\tint\t\t\tnsupport;\n\t\t\tint16\t   *indoption;\n\t\t\tOid\t\t   *indcollation;\n\n\t\t\t/* Count nailed indexes to ensure we have 'em all */\n\t\t\tif (rel->rd_isnailed)\n\t\t\t\tnailed_indexes++;\n\n\t\t\t/* next, read the pg_index tuple */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_indextuple = (HeapTuple) palloc(len);\n\t\t\tif (fread(rel->rd_indextuple, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\t/* Fix up internal pointers in the tuple -- see heap_copytuple */\n\t\t\trel->rd_indextuple->t_data = (HeapTupleHeader) ((char *) rel->rd_indextuple + HEAPTUPLESIZE);\n\t\t\trel->rd_index = (Form_pg_index) GETSTRUCT(rel->rd_indextuple);\n\n\t\t\t/*\n\t\t\t * prepare index info context --- parameters should match\n\t\t\t * RelationInitIndexAccessInfo\n\t\t\t */\n\t\t\tindexcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t \"index info\",\n\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\t\t\trel->rd_indexcxt = indexcxt;\n\t\t\tMemoryContextCopyAndSetIdentifier(indexcxt,\n\t\t\t\t\t\t\t\t\t\t\t  RelationGetRelationName(rel));\n\n\t\t\t/*\n\t\t\t * Now we can fetch the index AM's API struct.  (We can't store\n\t\t\t * that in the init file, since it contains function pointers that\n\t\t\t * might vary across server executions.  Fortunately, it should be\n\t\t\t * safe to call the amhandler even while bootstrapping indexes.)\n\t\t\t */\n\t\t\tInitIndexAmRoutine(rel);\n\n\t\t\t/* next, read the vector of opfamily OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\topfamily = (Oid *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(opfamily, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_opfamily = opfamily;\n\n\t\t\t/* next, read the vector of opcintype OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\topcintype = (Oid *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(opcintype, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_opcintype = opcintype;\n\n\t\t\t/* next, read the vector of support procedure OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\t\t\tsupport = (RegProcedure *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(support, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_support = support;\n\n\t\t\t/* next, read the vector of collation OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\tindcollation = (Oid *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(indcollation, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_indcollation = indcollation;\n\n\t\t\t/* finally, read the vector of indoption values */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\tindoption = (int16 *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(indoption, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_indoption = indoption;\n\n\t\t\t/* set up zeroed fmgr-info vector */\n\t\t\tnsupport = relform->relnatts * rel->rd_amroutine->amsupport;\n\t\t\trel->rd_supportinfo = (FmgrInfo *)\n\t\t\t\tMemoryContextAllocZero(indexcxt, nsupport * sizeof(FmgrInfo));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Count nailed rels to ensure we have 'em all */\n\t\t\tif (rel->rd_isnailed)\n\t\t\t\tnailed_rels++;\n\n\t\t\tAssert(rel->rd_index == NULL);\n\t\t\tAssert(rel->rd_indextuple == NULL);\n\t\t\tAssert(rel->rd_indexcxt == NULL);\n\t\t\tAssert(rel->rd_amroutine == NULL);\n\t\t\tAssert(rel->rd_opfamily == NULL);\n\t\t\tAssert(rel->rd_opcintype == NULL);\n\t\t\tAssert(rel->rd_support == NULL);\n\t\t\tAssert(rel->rd_supportinfo == NULL);\n\t\t\tAssert(rel->rd_indoption == NULL);\n\t\t\tAssert(rel->rd_indcollation == NULL);\n\t\t}\n\n\t\t/*\n\t\t * Rules and triggers are not saved (mainly because the internal\n\t\t * format is complex and subject to change).  They must be rebuilt if\n\t\t * needed by RelationCacheInitializePhase3.  This is not expected to\n\t\t * be a big performance hit since few system catalogs have such. Ditto\n\t\t * for RLS policy data, partition info, index expressions, predicates,\n\t\t * exclusion info, and FDW info.\n\t\t */\n\t\trel->rd_rules = NULL;\n\t\trel->rd_rulescxt = NULL;\n\t\trel->trigdesc = NULL;\n\t\trel->rd_rsdesc = NULL;\n\t\trel->rd_partkey = NULL;\n\t\trel->rd_partkeycxt = NULL;\n\t\trel->rd_partdesc = NULL;\n\t\trel->rd_pdcxt = NULL;\n\t\trel->rd_partcheck = NIL;\n\t\trel->rd_partcheckvalid = false;\n\t\trel->rd_partcheckcxt = NULL;\n\t\trel->rd_indexprs = NIL;\n\t\trel->rd_indpred = NIL;\n\t\trel->rd_exclops = NULL;\n\t\trel->rd_exclprocs = NULL;\n\t\trel->rd_exclstrats = NULL;\n\t\trel->rd_fdwroutine = NULL;\n\n\t\t/*\n\t\t * Reset transient-state fields in the relcache entry\n\t\t */\n\t\trel->rd_smgr = NULL;\n\t\tif (rel->rd_isnailed)\n\t\t\trel->rd_refcnt = 1;\n\t\telse\n\t\t\trel->rd_refcnt = 0;\n\t\trel->rd_indexvalid = 0;\n\t\trel->rd_fkeylist = NIL;\n\t\trel->rd_fkeyvalid = false;\n\t\trel->rd_indexlist = NIL;\n\t\trel->rd_oidindex = InvalidOid;\n\t\trel->rd_pkindex = InvalidOid;\n\t\trel->rd_replidindex = InvalidOid;\n\t\trel->rd_indexattr = NULL;\n\t\trel->rd_projindexattr = NULL;\n\t\trel->rd_keyattr = NULL;\n\t\trel->rd_pkattr = NULL;\n\t\trel->rd_idattr = NULL;\n\t\trel->rd_projidx = NULL;\n\t\trel->rd_pubactions = NULL;\n\t\trel->rd_statvalid = false;\n\t\trel->rd_statlist = NIL;\n\t\trel->rd_createSubid = InvalidSubTransactionId;\n\t\trel->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\t\trel->rd_amcache = NULL;\n\t\tMemSet(&rel->pgstat_info, 0, sizeof(rel->pgstat_info));\n\n\t\t/*\n\t\t * Recompute lock and physical addressing info.  This is needed in\n\t\t * case the pg_internal.init file was copied from some other database\n\t\t * by CREATE DATABASE.\n\t\t */\n\t\tRelationInitLockInfo(rel);\n\t\tRelationInitPhysicalAddr(rel);\n\t}\n\n\t/*\n\t * We reached the end of the init file without apparent problem.  Did we\n\t * get the right number of nailed items?  This is a useful crosscheck in\n\t * case the set of critical rels or indexes changes.  However, that should\n\t * not happen in a normally-running system, so let's bleat if it does.\n\t *\n\t * For the shared init file, we're called before client authentication is\n\t * done, which means that elog(WARNING) will go only to the postmaster\n\t * log, where it's easily missed.  To ensure that developers notice bad\n\t * values of NUM_CRITICAL_SHARED_RELS/NUM_CRITICAL_SHARED_INDEXES, we put\n\t * an Assert(false) there.\n\t */\n\tif (shared)\n\t{\n\t\tif (nailed_rels != NUM_CRITICAL_SHARED_RELS ||\n\t\t\tnailed_indexes != NUM_CRITICAL_SHARED_INDEXES)\n\t\t{\n\t\t\telog(WARNING, \"found %d nailed shared rels and %d nailed shared indexes in init file, but expected %d and %d respectively\",\n\t\t\t\t nailed_rels, nailed_indexes,\n\t\t\t\t NUM_CRITICAL_SHARED_RELS, NUM_CRITICAL_SHARED_INDEXES);\n\t\t\t/* Make sure we get developers' attention about this */\n\t\t\tAssert(false);\n\t\t\t/* In production builds, recover by bootstrapping the relcache */\n\t\t\tgoto read_failed;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (nailed_rels != NUM_CRITICAL_LOCAL_RELS ||\n\t\t\tnailed_indexes != NUM_CRITICAL_LOCAL_INDEXES)\n\t\t{\n\t\t\telog(WARNING, \"found %d nailed rels and %d nailed indexes in init file, but expected %d and %d respectively\",\n\t\t\t\t nailed_rels, nailed_indexes,\n\t\t\t\t NUM_CRITICAL_LOCAL_RELS, NUM_CRITICAL_LOCAL_INDEXES);\n\t\t\t/* We don't need an Assert() in this case */\n\t\t\tgoto read_failed;\n\t\t}\n\t}\n\n\t/*\n\t * OK, all appears well.\n\t *\n\t * Now insert all the new relcache entries into the cache.\n\t */\n\tfor (relno = 0; relno < num_rels; relno++)\n\t{\n\t\tRelationCacheInsert(rels[relno], false);\n\t}\n\n\tpfree(rels);\n\tFreeFile(fp);\n\n\tif (shared)\n\t\tcriticalSharedRelcachesBuilt = true;\n\telse\n\t\tcriticalRelcachesBuilt = true;\n\treturn true;\n\n\t/*\n\t * init file is broken, so do it the hard way.  We don't bother trying to\n\t * free the clutter we just allocated; it's not in the relcache so it\n\t * won't hurt.\n\t */\nread_failed:\n\tpfree(rels);\n\tFreeFile(fp);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 3596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 3589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationMapInitializePhase3",
          "args": [],
          "line": 3584
        },
        "resolved": true,
        "details": {
          "function_name": "RelationMapInitializePhase3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "606-619",
          "snippet": "void\nRelationMapInitializePhase3(void)\n{\n\t/*\n\t * In bootstrap mode, the map file isn't there yet, so do nothing.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t\treturn;\n\n\t/*\n\t * Load the local map file, die on error.\n\t */\n\tload_relmap_file(false);\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nvoid\nRelationMapInitializePhase3(void)\n{\n\t/*\n\t * In bootstrap mode, the map file isn't there yet, so do nothing.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t\treturn;\n\n\t/*\n\t * Load the local map file, die on error.\n\t */\n\tload_relmap_file(false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\n#define NUM_CRITICAL_SHARED_INDEXES 6\t/* fix if you change list above */\n#define NUM_CRITICAL_LOCAL_INDEXES\t7\t/* fix if you change list above */\n#define NUM_CRITICAL_LOCAL_RELS 4\t/* fix if you change list above */\n\nstatic const FormData_pg_attribute Desc_pg_class[Natts_pg_class] = {Schema_pg_class};\nstatic const FormData_pg_attribute Desc_pg_attribute[Natts_pg_attribute] = {Schema_pg_attribute};\nstatic const FormData_pg_attribute Desc_pg_proc[Natts_pg_proc] = {Schema_pg_proc};\nstatic const FormData_pg_attribute Desc_pg_type[Natts_pg_type] = {Schema_pg_type};\nstatic HTAB *RelationIdCache;\nbool\t\tcriticalRelcachesBuilt = false;\nbool\t\tcriticalSharedRelcachesBuilt = false;\nstatic void RelationClearRelation(Relation relation, bool rebuild);\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic bool load_relcache_init_file(bool shared);\nstatic void write_relcache_init_file(bool shared);\nstatic Relation AllocateRelationDesc(Form_pg_class relp);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationCacheInitializePhase3(void)\n{\n\tHASH_SEQ_STATUS status;\n\tRelIdCacheEnt *idhentry;\n\tMemoryContext oldcxt;\n\tbool\t\tneedNewCacheFile = !criticalSharedRelcachesBuilt;\n\n\t/*\n\t * relation mapper needs initialized too\n\t */\n\tRelationMapInitializePhase3();\n\n\t/*\n\t * switch to cache memory context\n\t */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * Try to load the local relcache cache file.  If unsuccessful, bootstrap\n\t * the cache with pre-made descriptors for the critical \"nailed-in\" system\n\t * catalogs.\n\t */\n\tif (IsBootstrapProcessingMode() ||\n\t\t!load_relcache_init_file(false))\n\t{\n\t\tneedNewCacheFile = true;\n\n\t\tformrdesc(\"pg_class\", RelationRelation_Rowtype_Id, false,\n\t\t\t\t  true, Natts_pg_class, Desc_pg_class);\n\t\tformrdesc(\"pg_attribute\", AttributeRelation_Rowtype_Id, false,\n\t\t\t\t  false, Natts_pg_attribute, Desc_pg_attribute);\n\t\tformrdesc(\"pg_proc\", ProcedureRelation_Rowtype_Id, false,\n\t\t\t\t  true, Natts_pg_proc, Desc_pg_proc);\n\t\tformrdesc(\"pg_type\", TypeRelation_Rowtype_Id, false,\n\t\t\t\t  true, Natts_pg_type, Desc_pg_type);\n\n#define NUM_CRITICAL_LOCAL_RELS 4\t/* fix if you change list above */\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* In bootstrap mode, the faked-up formrdesc info is all we'll have */\n\tif (IsBootstrapProcessingMode())\n\t\treturn;\n\n\t/*\n\t * If we didn't get the critical system indexes loaded into relcache, do\n\t * so now.  These are critical because the catcache and/or opclass cache\n\t * depend on them for fetches done during relcache load.  Thus, we have an\n\t * infinite-recursion problem.  We can break the recursion by doing\n\t * heapscans instead of indexscans at certain key spots. To avoid hobbling\n\t * performance, we only want to do that until we have the critical indexes\n\t * loaded into relcache.  Thus, the flag criticalRelcachesBuilt is used to\n\t * decide whether to do heapscan or indexscan at the key spots, and we set\n\t * it true after we've loaded the critical indexes.\n\t *\n\t * The critical indexes are marked as \"nailed in cache\", partly to make it\n\t * easy for load_relcache_init_file to count them, but mainly because we\n\t * cannot flush and rebuild them once we've set criticalRelcachesBuilt to\n\t * true.  (NOTE: perhaps it would be possible to reload them by\n\t * temporarily setting criticalRelcachesBuilt to false again.  For now,\n\t * though, we just nail 'em in.)\n\t *\n\t * RewriteRelRulenameIndexId and TriggerRelidNameIndexId are not critical\n\t * in the same way as the others, because the critical catalogs don't\n\t * (currently) have any rules or triggers, and so these indexes can be\n\t * rebuilt without inducing recursion.  However they are used during\n\t * relcache load when a rel does have rules or triggers, so we choose to\n\t * nail them for performance reasons.\n\t */\n\tif (!criticalRelcachesBuilt)\n\t{\n\t\tload_critical_index(ClassOidIndexId,\n\t\t\t\t\t\t\tRelationRelationId);\n\t\tload_critical_index(AttributeRelidNumIndexId,\n\t\t\t\t\t\t\tAttributeRelationId);\n\t\tload_critical_index(IndexRelidIndexId,\n\t\t\t\t\t\t\tIndexRelationId);\n\t\tload_critical_index(OpclassOidIndexId,\n\t\t\t\t\t\t\tOperatorClassRelationId);\n\t\tload_critical_index(AccessMethodProcedureIndexId,\n\t\t\t\t\t\t\tAccessMethodProcedureRelationId);\n\t\tload_critical_index(RewriteRelRulenameIndexId,\n\t\t\t\t\t\t\tRewriteRelationId);\n\t\tload_critical_index(TriggerRelidNameIndexId,\n\t\t\t\t\t\t\tTriggerRelationId);\n\n#define NUM_CRITICAL_LOCAL_INDEXES\t7\t/* fix if you change list above */\n\n\t\tcriticalRelcachesBuilt = true;\n\t}\n\n\t/*\n\t * Process critical shared indexes too.\n\t *\n\t * DatabaseNameIndexId isn't critical for relcache loading, but rather for\n\t * initial lookup of MyDatabaseId, without which we'll never find any\n\t * non-shared catalogs at all.  Autovacuum calls InitPostgres with a\n\t * database OID, so it instead depends on DatabaseOidIndexId.  We also\n\t * need to nail up some indexes on pg_authid and pg_auth_members for use\n\t * during client authentication.  SharedSecLabelObjectIndexId isn't\n\t * critical for the core system, but authentication hooks might be\n\t * interested in it.\n\t */\n\tif (!criticalSharedRelcachesBuilt)\n\t{\n\t\tload_critical_index(DatabaseNameIndexId,\n\t\t\t\t\t\t\tDatabaseRelationId);\n\t\tload_critical_index(DatabaseOidIndexId,\n\t\t\t\t\t\t\tDatabaseRelationId);\n\t\tload_critical_index(AuthIdRolnameIndexId,\n\t\t\t\t\t\t\tAuthIdRelationId);\n\t\tload_critical_index(AuthIdOidIndexId,\n\t\t\t\t\t\t\tAuthIdRelationId);\n\t\tload_critical_index(AuthMemMemRoleIndexId,\n\t\t\t\t\t\t\tAuthMemRelationId);\n\t\tload_critical_index(SharedSecLabelObjectIndexId,\n\t\t\t\t\t\t\tSharedSecLabelRelationId);\n\n#define NUM_CRITICAL_SHARED_INDEXES 6\t/* fix if you change list above */\n\n\t\tcriticalSharedRelcachesBuilt = true;\n\t}\n\n\t/*\n\t * Now, scan all the relcache entries and update anything that might be\n\t * wrong in the results from formrdesc or the relcache cache file. If we\n\t * faked up relcache entries using formrdesc, then read the real pg_class\n\t * rows and replace the fake entries with them. Also, if any of the\n\t * relcache entries have rules, triggers, or security policies, load that\n\t * info the hard way since it isn't recorded in the cache file.\n\t *\n\t * Whenever we access the catalogs to read data, there is a possibility of\n\t * a shared-inval cache flush causing relcache entries to be removed.\n\t * Since hash_seq_search only guarantees to still work after the *current*\n\t * entry is removed, it's unsafe to continue the hashtable scan afterward.\n\t * We handle this by restarting the scan from scratch after each access.\n\t * This is theoretically O(N^2), but the number of entries that actually\n\t * need to be fixed is small enough that it doesn't matter.\n\t */\n\thash_seq_init(&status, RelationIdCache);\n\n\twhile ((idhentry = (RelIdCacheEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\tRelation\trelation = idhentry->reldesc;\n\t\tbool\t\trestart = false;\n\n\t\t/*\n\t\t * Make sure *this* entry doesn't get flushed while we work with it.\n\t\t */\n\t\tRelationIncrementReferenceCount(relation);\n\n\t\t/*\n\t\t * If it's a faked-up entry, read the real pg_class tuple.\n\t\t */\n\t\tif (relation->rd_rel->relowner == InvalidOid)\n\t\t{\n\t\t\tHeapTuple\thtup;\n\t\t\tForm_pg_class relp;\n\n\t\t\thtup = SearchSysCache1(RELOID,\n\t\t\t\t\t\t\t\t   ObjectIdGetDatum(RelationGetRelid(relation)));\n\t\t\tif (!HeapTupleIsValid(htup))\n\t\t\t\telog(FATAL, \"cache lookup failed for relation %u\",\n\t\t\t\t\t RelationGetRelid(relation));\n\t\t\trelp = (Form_pg_class) GETSTRUCT(htup);\n\n\t\t\t/*\n\t\t\t * Copy tuple to relation->rd_rel. (See notes in\n\t\t\t * AllocateRelationDesc())\n\t\t\t */\n\t\t\tmemcpy((char *) relation->rd_rel, (char *) relp, CLASS_TUPLE_SIZE);\n\n\t\t\t/* Update rd_options while we have the tuple */\n\t\t\tif (relation->rd_options)\n\t\t\t\tpfree(relation->rd_options);\n\t\t\tRelationParseRelOptions(relation, htup);\n\n\t\t\t/*\n\t\t\t * Check the values in rd_att were set up correctly.  (We cannot\n\t\t\t * just copy them over now: formrdesc must have set up the rd_att\n\t\t\t * data correctly to start with, because it may already have been\n\t\t\t * copied into one or more catcache entries.)\n\t\t\t */\n\t\t\tAssert(relation->rd_att->tdtypeid == relp->reltype);\n\t\t\tAssert(relation->rd_att->tdtypmod == -1);\n\t\t\tAssert(relation->rd_att->tdhasoid == relp->relhasoids);\n\n\t\t\tReleaseSysCache(htup);\n\n\t\t\t/* relowner had better be OK now, else we'll loop forever */\n\t\t\tif (relation->rd_rel->relowner == InvalidOid)\n\t\t\t\telog(ERROR, \"invalid relowner in pg_class entry for \\\"%s\\\"\",\n\t\t\t\t\t RelationGetRelationName(relation));\n\n\t\t\trestart = true;\n\t\t}\n\n\t\t/*\n\t\t * Fix data that isn't saved in relcache cache file.\n\t\t *\n\t\t * relhasrules or relhastriggers could possibly be wrong or out of\n\t\t * date.  If we don't actually find any rules or triggers, clear the\n\t\t * local copy of the flag so that we don't get into an infinite loop\n\t\t * here.  We don't make any attempt to fix the pg_class entry, though.\n\t\t */\n\t\tif (relation->rd_rel->relhasrules && relation->rd_rules == NULL)\n\t\t{\n\t\t\tRelationBuildRuleLock(relation);\n\t\t\tif (relation->rd_rules == NULL)\n\t\t\t\trelation->rd_rel->relhasrules = false;\n\t\t\trestart = true;\n\t\t}\n\t\tif (relation->rd_rel->relhastriggers && relation->trigdesc == NULL)\n\t\t{\n\t\t\tRelationBuildTriggers(relation);\n\t\t\tif (relation->trigdesc == NULL)\n\t\t\t\trelation->rd_rel->relhastriggers = false;\n\t\t\trestart = true;\n\t\t}\n\n\t\t/*\n\t\t * Re-load the row security policies if the relation has them, since\n\t\t * they are not preserved in the cache.  Note that we can never NOT\n\t\t * have a policy while relrowsecurity is true,\n\t\t * RelationBuildRowSecurity will create a single default-deny policy\n\t\t * if there is no policy defined in pg_policy.\n\t\t */\n\t\tif (relation->rd_rel->relrowsecurity && relation->rd_rsdesc == NULL)\n\t\t{\n\t\t\tRelationBuildRowSecurity(relation);\n\n\t\t\tAssert(relation->rd_rsdesc != NULL);\n\t\t\trestart = true;\n\t\t}\n\n\t\t/*\n\t\t * Reload the partition key and descriptor for a partitioned table.\n\t\t */\n\t\tif (relation->rd_rel->relkind == RELKIND_PARTITIONED_TABLE &&\n\t\t\trelation->rd_partkey == NULL)\n\t\t{\n\t\t\tRelationBuildPartitionKey(relation);\n\t\t\tAssert(relation->rd_partkey != NULL);\n\n\t\t\trestart = true;\n\t\t}\n\n\t\tif (relation->rd_rel->relkind == RELKIND_PARTITIONED_TABLE &&\n\t\t\trelation->rd_partdesc == NULL)\n\t\t{\n\t\t\tRelationBuildPartitionDesc(relation);\n\t\t\tAssert(relation->rd_partdesc != NULL);\n\n\t\t\trestart = true;\n\t\t}\n\n\t\t/* Release hold on the relation */\n\t\tRelationDecrementReferenceCount(relation);\n\n\t\t/* Now, restart the hashtable scan if needed */\n\t\tif (restart)\n\t\t{\n\t\t\thash_seq_term(&status);\n\t\t\thash_seq_init(&status, RelationIdCache);\n\t\t}\n\t}\n\n\t/*\n\t * Lastly, write out new relcache cache files if needed.  We don't bother\n\t * to distinguish cases where only one of the two needs an update.\n\t */\n\tif (needNewCacheFile)\n\t{\n\t\t/*\n\t\t * Force all the catcaches to finish initializing and thereby open the\n\t\t * catalogs and indexes they use.  This will preload the relcache with\n\t\t * entries for all the most important system catalogs and indexes, so\n\t\t * that the init files will be most useful for future backends.\n\t\t */\n\t\tInitCatalogCachePhase2();\n\n\t\t/* now write the files */\n\t\twrite_relcache_init_file(true);\n\t\twrite_relcache_init_file(false);\n\t}\n}"
  },
  {
    "function_name": "RelationCacheInitializePhase2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "3514-3557",
    "snippet": "void\nRelationCacheInitializePhase2(void)\n{\n\tMemoryContext oldcxt;\n\n\t/*\n\t * relation mapper needs initialized too\n\t */\n\tRelationMapInitializePhase2();\n\n\t/*\n\t * In bootstrap mode, the shared catalogs aren't there yet anyway, so do\n\t * nothing.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t\treturn;\n\n\t/*\n\t * switch to cache memory context\n\t */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * Try to load the shared relcache cache file.  If unsuccessful, bootstrap\n\t * the cache with pre-made descriptors for the critical shared catalogs.\n\t */\n\tif (!load_relcache_init_file(true))\n\t{\n\t\tformrdesc(\"pg_database\", DatabaseRelation_Rowtype_Id, true,\n\t\t\t\t  true, Natts_pg_database, Desc_pg_database);\n\t\tformrdesc(\"pg_authid\", AuthIdRelation_Rowtype_Id, true,\n\t\t\t\t  true, Natts_pg_authid, Desc_pg_authid);\n\t\tformrdesc(\"pg_auth_members\", AuthMemRelation_Rowtype_Id, true,\n\t\t\t\t  false, Natts_pg_auth_members, Desc_pg_auth_members);\n\t\tformrdesc(\"pg_shseclabel\", SharedSecLabelRelation_Rowtype_Id, true,\n\t\t\t\t  false, Natts_pg_shseclabel, Desc_pg_shseclabel);\n\t\tformrdesc(\"pg_subscription\", SubscriptionRelation_Rowtype_Id, true,\n\t\t\t\t  true, Natts_pg_subscription, Desc_pg_subscription);\n\n#define NUM_CRITICAL_SHARED_RELS\t5\t/* fix if you change list above */\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define NUM_CRITICAL_SHARED_RELS\t5\t/* fix if you change list above */"
    ],
    "globals_used": [
      "static const FormData_pg_attribute Desc_pg_database[Natts_pg_database] = {Schema_pg_database};",
      "static const FormData_pg_attribute Desc_pg_authid[Natts_pg_authid] = {Schema_pg_authid};",
      "static const FormData_pg_attribute Desc_pg_auth_members[Natts_pg_auth_members] = {Schema_pg_auth_members};",
      "static const FormData_pg_attribute Desc_pg_shseclabel[Natts_pg_shseclabel] = {Schema_pg_shseclabel};",
      "static const FormData_pg_attribute Desc_pg_subscription[Natts_pg_subscription] = {Schema_pg_subscription};",
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static bool load_relcache_init_file(bool shared);",
      "static void write_relcache_init_file(bool shared);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 3556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "formrdesc",
          "args": [
            "\"pg_subscription\"",
            "SubscriptionRelation_Rowtype_Id",
            "true",
            "true",
            "Natts_pg_subscription",
            "Desc_pg_subscription"
          ],
          "line": 3550
        },
        "resolved": true,
        "details": {
          "function_name": "formrdesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1729-1885",
          "snippet": "static void\nformrdesc(const char *relationName, Oid relationReltype,\n\t\t  bool isshared, bool hasoids,\n\t\t  int natts, const FormData_pg_attribute *attrs)\n{\n\tRelation\trelation;\n\tint\t\t\ti;\n\tbool\t\thas_not_null;\n\n\t/*\n\t * allocate new relation desc, clear all fields of reldesc\n\t */\n\trelation = (Relation) palloc0(sizeof(RelationData));\n\n\t/* make sure relation is marked as having no open file yet */\n\trelation->rd_smgr = NULL;\n\n\t/*\n\t * initialize reference count: 1 because it is nailed in cache\n\t */\n\trelation->rd_refcnt = 1;\n\n\t/*\n\t * all entries built with this routine are nailed-in-cache; none are for\n\t * new or temp relations.\n\t */\n\trelation->rd_isnailed = true;\n\trelation->rd_createSubid = InvalidSubTransactionId;\n\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\trelation->rd_backend = InvalidBackendId;\n\trelation->rd_islocaltemp = false;\n\n\t/*\n\t * initialize relation tuple form\n\t *\n\t * The data we insert here is pretty incomplete/bogus, but it'll serve to\n\t * get us launched.  RelationCacheInitializePhase3() will read the real\n\t * data from pg_class and replace what we've done here.  Note in\n\t * particular that relowner is left as zero; this cues\n\t * RelationCacheInitializePhase3 that the real data isn't there yet.\n\t */\n\trelation->rd_rel = (Form_pg_class) palloc0(CLASS_TUPLE_SIZE);\n\n\tnamestrcpy(&relation->rd_rel->relname, relationName);\n\trelation->rd_rel->relnamespace = PG_CATALOG_NAMESPACE;\n\trelation->rd_rel->reltype = relationReltype;\n\n\t/*\n\t * It's important to distinguish between shared and non-shared relations,\n\t * even at bootstrap time, to make sure we know where they are stored.\n\t */\n\trelation->rd_rel->relisshared = isshared;\n\tif (isshared)\n\t\trelation->rd_rel->reltablespace = GLOBALTABLESPACE_OID;\n\n\t/* formrdesc is used only for permanent relations */\n\trelation->rd_rel->relpersistence = RELPERSISTENCE_PERMANENT;\n\n\t/* ... and they're always populated, too */\n\trelation->rd_rel->relispopulated = true;\n\n\trelation->rd_rel->relreplident = REPLICA_IDENTITY_NOTHING;\n\trelation->rd_rel->relpages = 0;\n\trelation->rd_rel->reltuples = 0;\n\trelation->rd_rel->relallvisible = 0;\n\trelation->rd_rel->relkind = RELKIND_RELATION;\n\trelation->rd_rel->relhasoids = hasoids;\n\trelation->rd_rel->relnatts = (int16) natts;\n\n\t/*\n\t * initialize attribute tuple form\n\t *\n\t * Unlike the case with the relation tuple, this data had better be right\n\t * because it will never be replaced.  The data comes from\n\t * src/include/catalog/ headers via genbki.pl.\n\t */\n\trelation->rd_att = CreateTemplateTupleDesc(natts, hasoids);\n\trelation->rd_att->tdrefcount = 1;\t/* mark as refcounted */\n\n\trelation->rd_att->tdtypeid = relationReltype;\n\trelation->rd_att->tdtypmod = -1;\t/* unnecessary, but... */\n\n\t/*\n\t * initialize tuple desc info\n\t */\n\thas_not_null = false;\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tmemcpy(TupleDescAttr(relation->rd_att, i),\n\t\t\t   &attrs[i],\n\t\t\t   ATTRIBUTE_FIXED_PART_SIZE);\n\t\thas_not_null |= attrs[i].attnotnull;\n\t\t/* make sure attcacheoff is valid */\n\t\tTupleDescAttr(relation->rd_att, i)->attcacheoff = -1;\n\t}\n\n\t/* initialize first attribute's attcacheoff, cf RelationBuildTupleDesc */\n\tTupleDescAttr(relation->rd_att, 0)->attcacheoff = 0;\n\n\t/* mark not-null status */\n\tif (has_not_null)\n\t{\n\t\tTupleConstr *constr = (TupleConstr *) palloc0(sizeof(TupleConstr));\n\n\t\tconstr->has_not_null = true;\n\t\trelation->rd_att->constr = constr;\n\t}\n\n\t/*\n\t * initialize relation id from info in att array (my, this is ugly)\n\t */\n\tRelationGetRelid(relation) = TupleDescAttr(relation->rd_att, 0)->attrelid;\n\n\t/*\n\t * All relations made with formrdesc are mapped.  This is necessarily so\n\t * because there is no other way to know what filenode they currently\n\t * have.  In bootstrap mode, add them to the initial relation mapper data,\n\t * specifying that the initial filenode is the same as the OID.\n\t */\n\trelation->rd_rel->relfilenode = InvalidOid;\n\tif (IsBootstrapProcessingMode())\n\t\tRelationMapUpdateMap(RelationGetRelid(relation),\n\t\t\t\t\t\t\t RelationGetRelid(relation),\n\t\t\t\t\t\t\t isshared, true);\n\n\t/*\n\t * initialize the relation lock manager information\n\t */\n\tRelationInitLockInfo(relation); /* see lmgr.c */\n\n\t/*\n\t * initialize physical addressing information for the relation\n\t */\n\tRelationInitPhysicalAddr(relation);\n\n\t/*\n\t * initialize the rel-has-index flag, using hardwired knowledge\n\t */\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\t/* In bootstrap mode, we have no indexes */\n\t\trelation->rd_rel->relhasindex = false;\n\t}\n\telse\n\t{\n\t\t/* Otherwise, all the rels formrdesc is used for have indexes */\n\t\trelation->rd_rel->relhasindex = true;\n\t}\n\n\t/*\n\t * add new reldesc to relcache\n\t */\n\tRelationCacheInsert(relation, false);\n\n\t/* It's fully valid */\n\trelation->rd_isvalid = true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static bool load_relcache_init_file(bool shared);",
            "static void write_relcache_init_file(bool shared);",
            "static void formrdesc(const char *relationName, Oid relationReltype,\n\t\t  bool isshared, bool hasoids,\n\t\t  int natts, const FormData_pg_attribute *attrs);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic bool load_relcache_init_file(bool shared);\nstatic void write_relcache_init_file(bool shared);\nstatic void formrdesc(const char *relationName, Oid relationReltype,\n\t\t  bool isshared, bool hasoids,\n\t\t  int natts, const FormData_pg_attribute *attrs);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nformrdesc(const char *relationName, Oid relationReltype,\n\t\t  bool isshared, bool hasoids,\n\t\t  int natts, const FormData_pg_attribute *attrs)\n{\n\tRelation\trelation;\n\tint\t\t\ti;\n\tbool\t\thas_not_null;\n\n\t/*\n\t * allocate new relation desc, clear all fields of reldesc\n\t */\n\trelation = (Relation) palloc0(sizeof(RelationData));\n\n\t/* make sure relation is marked as having no open file yet */\n\trelation->rd_smgr = NULL;\n\n\t/*\n\t * initialize reference count: 1 because it is nailed in cache\n\t */\n\trelation->rd_refcnt = 1;\n\n\t/*\n\t * all entries built with this routine are nailed-in-cache; none are for\n\t * new or temp relations.\n\t */\n\trelation->rd_isnailed = true;\n\trelation->rd_createSubid = InvalidSubTransactionId;\n\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\trelation->rd_backend = InvalidBackendId;\n\trelation->rd_islocaltemp = false;\n\n\t/*\n\t * initialize relation tuple form\n\t *\n\t * The data we insert here is pretty incomplete/bogus, but it'll serve to\n\t * get us launched.  RelationCacheInitializePhase3() will read the real\n\t * data from pg_class and replace what we've done here.  Note in\n\t * particular that relowner is left as zero; this cues\n\t * RelationCacheInitializePhase3 that the real data isn't there yet.\n\t */\n\trelation->rd_rel = (Form_pg_class) palloc0(CLASS_TUPLE_SIZE);\n\n\tnamestrcpy(&relation->rd_rel->relname, relationName);\n\trelation->rd_rel->relnamespace = PG_CATALOG_NAMESPACE;\n\trelation->rd_rel->reltype = relationReltype;\n\n\t/*\n\t * It's important to distinguish between shared and non-shared relations,\n\t * even at bootstrap time, to make sure we know where they are stored.\n\t */\n\trelation->rd_rel->relisshared = isshared;\n\tif (isshared)\n\t\trelation->rd_rel->reltablespace = GLOBALTABLESPACE_OID;\n\n\t/* formrdesc is used only for permanent relations */\n\trelation->rd_rel->relpersistence = RELPERSISTENCE_PERMANENT;\n\n\t/* ... and they're always populated, too */\n\trelation->rd_rel->relispopulated = true;\n\n\trelation->rd_rel->relreplident = REPLICA_IDENTITY_NOTHING;\n\trelation->rd_rel->relpages = 0;\n\trelation->rd_rel->reltuples = 0;\n\trelation->rd_rel->relallvisible = 0;\n\trelation->rd_rel->relkind = RELKIND_RELATION;\n\trelation->rd_rel->relhasoids = hasoids;\n\trelation->rd_rel->relnatts = (int16) natts;\n\n\t/*\n\t * initialize attribute tuple form\n\t *\n\t * Unlike the case with the relation tuple, this data had better be right\n\t * because it will never be replaced.  The data comes from\n\t * src/include/catalog/ headers via genbki.pl.\n\t */\n\trelation->rd_att = CreateTemplateTupleDesc(natts, hasoids);\n\trelation->rd_att->tdrefcount = 1;\t/* mark as refcounted */\n\n\trelation->rd_att->tdtypeid = relationReltype;\n\trelation->rd_att->tdtypmod = -1;\t/* unnecessary, but... */\n\n\t/*\n\t * initialize tuple desc info\n\t */\n\thas_not_null = false;\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tmemcpy(TupleDescAttr(relation->rd_att, i),\n\t\t\t   &attrs[i],\n\t\t\t   ATTRIBUTE_FIXED_PART_SIZE);\n\t\thas_not_null |= attrs[i].attnotnull;\n\t\t/* make sure attcacheoff is valid */\n\t\tTupleDescAttr(relation->rd_att, i)->attcacheoff = -1;\n\t}\n\n\t/* initialize first attribute's attcacheoff, cf RelationBuildTupleDesc */\n\tTupleDescAttr(relation->rd_att, 0)->attcacheoff = 0;\n\n\t/* mark not-null status */\n\tif (has_not_null)\n\t{\n\t\tTupleConstr *constr = (TupleConstr *) palloc0(sizeof(TupleConstr));\n\n\t\tconstr->has_not_null = true;\n\t\trelation->rd_att->constr = constr;\n\t}\n\n\t/*\n\t * initialize relation id from info in att array (my, this is ugly)\n\t */\n\tRelationGetRelid(relation) = TupleDescAttr(relation->rd_att, 0)->attrelid;\n\n\t/*\n\t * All relations made with formrdesc are mapped.  This is necessarily so\n\t * because there is no other way to know what filenode they currently\n\t * have.  In bootstrap mode, add them to the initial relation mapper data,\n\t * specifying that the initial filenode is the same as the OID.\n\t */\n\trelation->rd_rel->relfilenode = InvalidOid;\n\tif (IsBootstrapProcessingMode())\n\t\tRelationMapUpdateMap(RelationGetRelid(relation),\n\t\t\t\t\t\t\t RelationGetRelid(relation),\n\t\t\t\t\t\t\t isshared, true);\n\n\t/*\n\t * initialize the relation lock manager information\n\t */\n\tRelationInitLockInfo(relation); /* see lmgr.c */\n\n\t/*\n\t * initialize physical addressing information for the relation\n\t */\n\tRelationInitPhysicalAddr(relation);\n\n\t/*\n\t * initialize the rel-has-index flag, using hardwired knowledge\n\t */\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\t/* In bootstrap mode, we have no indexes */\n\t\trelation->rd_rel->relhasindex = false;\n\t}\n\telse\n\t{\n\t\t/* Otherwise, all the rels formrdesc is used for have indexes */\n\t\trelation->rd_rel->relhasindex = true;\n\t}\n\n\t/*\n\t * add new reldesc to relcache\n\t */\n\tRelationCacheInsert(relation, false);\n\n\t/* It's fully valid */\n\trelation->rd_isvalid = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_relcache_init_file",
          "args": [
            "true"
          ],
          "line": 3540
        },
        "resolved": true,
        "details": {
          "function_name": "load_relcache_init_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "5400-5787",
          "snippet": "static bool\nload_relcache_init_file(bool shared)\n{\n\tFILE\t   *fp;\n\tchar\t\tinitfilename[MAXPGPATH];\n\tRelation   *rels;\n\tint\t\t\trelno,\n\t\t\t\tnum_rels,\n\t\t\t\tmax_rels,\n\t\t\t\tnailed_rels,\n\t\t\t\tnailed_indexes,\n\t\t\t\tmagic;\n\tint\t\t\ti;\n\n\tif (shared)\n\t\tsnprintf(initfilename, sizeof(initfilename), \"global/%s\",\n\t\t\t\t RELCACHE_INIT_FILENAME);\n\telse\n\t\tsnprintf(initfilename, sizeof(initfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELCACHE_INIT_FILENAME);\n\n\tfp = AllocateFile(initfilename, PG_BINARY_R);\n\tif (fp == NULL)\n\t\treturn false;\n\n\t/*\n\t * Read the index relcache entries from the file.  Note we will not enter\n\t * any of them into the cache if the read fails partway through; this\n\t * helps to guard against broken init files.\n\t */\n\tmax_rels = 100;\n\trels = (Relation *) palloc(max_rels * sizeof(Relation));\n\tnum_rels = 0;\n\tnailed_rels = nailed_indexes = 0;\n\n\t/* check for correct magic number (compatible version) */\n\tif (fread(&magic, 1, sizeof(magic), fp) != sizeof(magic))\n\t\tgoto read_failed;\n\tif (magic != RELCACHE_INIT_FILEMAGIC)\n\t\tgoto read_failed;\n\n\tfor (relno = 0;; relno++)\n\t{\n\t\tSize\t\tlen;\n\t\tsize_t\t\tnread;\n\t\tRelation\trel;\n\t\tForm_pg_class relform;\n\t\tbool\t\thas_not_null;\n\n\t\t/* first read the relation descriptor length */\n\t\tnread = fread(&len, 1, sizeof(len), fp);\n\t\tif (nread != sizeof(len))\n\t\t{\n\t\t\tif (nread == 0)\n\t\t\t\tbreak;\t\t\t/* end of file */\n\t\t\tgoto read_failed;\n\t\t}\n\n\t\t/* safety check for incompatible relcache layout */\n\t\tif (len != sizeof(RelationData))\n\t\t\tgoto read_failed;\n\n\t\t/* allocate another relcache header */\n\t\tif (num_rels >= max_rels)\n\t\t{\n\t\t\tmax_rels *= 2;\n\t\t\trels = (Relation *) repalloc(rels, max_rels * sizeof(Relation));\n\t\t}\n\n\t\trel = rels[num_rels++] = (Relation) palloc(len);\n\n\t\t/* then, read the Relation structure */\n\t\tif (fread(rel, 1, len, fp) != len)\n\t\t\tgoto read_failed;\n\n\t\t/* next read the relation tuple form */\n\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\tgoto read_failed;\n\n\t\trelform = (Form_pg_class) palloc(len);\n\t\tif (fread(relform, 1, len, fp) != len)\n\t\t\tgoto read_failed;\n\n\t\trel->rd_rel = relform;\n\n\t\t/* initialize attribute tuple forms */\n\t\trel->rd_att = CreateTemplateTupleDesc(relform->relnatts,\n\t\t\t\t\t\t\t\t\t\t\t  relform->relhasoids);\n\t\trel->rd_att->tdrefcount = 1;\t/* mark as refcounted */\n\n\t\trel->rd_att->tdtypeid = relform->reltype;\n\t\trel->rd_att->tdtypmod = -1; /* unnecessary, but... */\n\n\t\t/* next read all the attribute tuple form data entries */\n\t\thas_not_null = false;\n\t\tfor (i = 0; i < relform->relnatts; i++)\n\t\t{\n\t\t\tForm_pg_attribute attr = TupleDescAttr(rel->rd_att, i);\n\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\t\t\tif (len != ATTRIBUTE_FIXED_PART_SIZE)\n\t\t\t\tgoto read_failed;\n\t\t\tif (fread(attr, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\thas_not_null |= attr->attnotnull;\n\t\t}\n\n\t\t/* next read the access method specific field */\n\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\tgoto read_failed;\n\t\tif (len > 0)\n\t\t{\n\t\t\trel->rd_options = palloc(len);\n\t\t\tif (fread(rel->rd_options, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\t\t\tif (len != VARSIZE(rel->rd_options))\n\t\t\t\tgoto read_failed;\t/* sanity check */\n\t\t}\n\t\telse\n\t\t{\n\t\t\trel->rd_options = NULL;\n\t\t}\n\n\t\t/* mark not-null status */\n\t\tif (has_not_null)\n\t\t{\n\t\t\tTupleConstr *constr = (TupleConstr *) palloc0(sizeof(TupleConstr));\n\n\t\t\tconstr->has_not_null = true;\n\t\t\trel->rd_att->constr = constr;\n\t\t}\n\n\t\t/*\n\t\t * If it's an index, there's more to do.  Note we explicitly ignore\n\t\t * partitioned indexes here.\n\t\t */\n\t\tif (rel->rd_rel->relkind == RELKIND_INDEX)\n\t\t{\n\t\t\tMemoryContext indexcxt;\n\t\t\tOid\t\t   *opfamily;\n\t\t\tOid\t\t   *opcintype;\n\t\t\tRegProcedure *support;\n\t\t\tint\t\t\tnsupport;\n\t\t\tint16\t   *indoption;\n\t\t\tOid\t\t   *indcollation;\n\n\t\t\t/* Count nailed indexes to ensure we have 'em all */\n\t\t\tif (rel->rd_isnailed)\n\t\t\t\tnailed_indexes++;\n\n\t\t\t/* next, read the pg_index tuple */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_indextuple = (HeapTuple) palloc(len);\n\t\t\tif (fread(rel->rd_indextuple, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\t/* Fix up internal pointers in the tuple -- see heap_copytuple */\n\t\t\trel->rd_indextuple->t_data = (HeapTupleHeader) ((char *) rel->rd_indextuple + HEAPTUPLESIZE);\n\t\t\trel->rd_index = (Form_pg_index) GETSTRUCT(rel->rd_indextuple);\n\n\t\t\t/*\n\t\t\t * prepare index info context --- parameters should match\n\t\t\t * RelationInitIndexAccessInfo\n\t\t\t */\n\t\t\tindexcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t \"index info\",\n\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\t\t\trel->rd_indexcxt = indexcxt;\n\t\t\tMemoryContextCopyAndSetIdentifier(indexcxt,\n\t\t\t\t\t\t\t\t\t\t\t  RelationGetRelationName(rel));\n\n\t\t\t/*\n\t\t\t * Now we can fetch the index AM's API struct.  (We can't store\n\t\t\t * that in the init file, since it contains function pointers that\n\t\t\t * might vary across server executions.  Fortunately, it should be\n\t\t\t * safe to call the amhandler even while bootstrapping indexes.)\n\t\t\t */\n\t\t\tInitIndexAmRoutine(rel);\n\n\t\t\t/* next, read the vector of opfamily OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\topfamily = (Oid *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(opfamily, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_opfamily = opfamily;\n\n\t\t\t/* next, read the vector of opcintype OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\topcintype = (Oid *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(opcintype, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_opcintype = opcintype;\n\n\t\t\t/* next, read the vector of support procedure OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\t\t\tsupport = (RegProcedure *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(support, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_support = support;\n\n\t\t\t/* next, read the vector of collation OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\tindcollation = (Oid *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(indcollation, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_indcollation = indcollation;\n\n\t\t\t/* finally, read the vector of indoption values */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\tindoption = (int16 *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(indoption, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_indoption = indoption;\n\n\t\t\t/* set up zeroed fmgr-info vector */\n\t\t\tnsupport = relform->relnatts * rel->rd_amroutine->amsupport;\n\t\t\trel->rd_supportinfo = (FmgrInfo *)\n\t\t\t\tMemoryContextAllocZero(indexcxt, nsupport * sizeof(FmgrInfo));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Count nailed rels to ensure we have 'em all */\n\t\t\tif (rel->rd_isnailed)\n\t\t\t\tnailed_rels++;\n\n\t\t\tAssert(rel->rd_index == NULL);\n\t\t\tAssert(rel->rd_indextuple == NULL);\n\t\t\tAssert(rel->rd_indexcxt == NULL);\n\t\t\tAssert(rel->rd_amroutine == NULL);\n\t\t\tAssert(rel->rd_opfamily == NULL);\n\t\t\tAssert(rel->rd_opcintype == NULL);\n\t\t\tAssert(rel->rd_support == NULL);\n\t\t\tAssert(rel->rd_supportinfo == NULL);\n\t\t\tAssert(rel->rd_indoption == NULL);\n\t\t\tAssert(rel->rd_indcollation == NULL);\n\t\t}\n\n\t\t/*\n\t\t * Rules and triggers are not saved (mainly because the internal\n\t\t * format is complex and subject to change).  They must be rebuilt if\n\t\t * needed by RelationCacheInitializePhase3.  This is not expected to\n\t\t * be a big performance hit since few system catalogs have such. Ditto\n\t\t * for RLS policy data, partition info, index expressions, predicates,\n\t\t * exclusion info, and FDW info.\n\t\t */\n\t\trel->rd_rules = NULL;\n\t\trel->rd_rulescxt = NULL;\n\t\trel->trigdesc = NULL;\n\t\trel->rd_rsdesc = NULL;\n\t\trel->rd_partkey = NULL;\n\t\trel->rd_partkeycxt = NULL;\n\t\trel->rd_partdesc = NULL;\n\t\trel->rd_pdcxt = NULL;\n\t\trel->rd_partcheck = NIL;\n\t\trel->rd_partcheckvalid = false;\n\t\trel->rd_partcheckcxt = NULL;\n\t\trel->rd_indexprs = NIL;\n\t\trel->rd_indpred = NIL;\n\t\trel->rd_exclops = NULL;\n\t\trel->rd_exclprocs = NULL;\n\t\trel->rd_exclstrats = NULL;\n\t\trel->rd_fdwroutine = NULL;\n\n\t\t/*\n\t\t * Reset transient-state fields in the relcache entry\n\t\t */\n\t\trel->rd_smgr = NULL;\n\t\tif (rel->rd_isnailed)\n\t\t\trel->rd_refcnt = 1;\n\t\telse\n\t\t\trel->rd_refcnt = 0;\n\t\trel->rd_indexvalid = 0;\n\t\trel->rd_fkeylist = NIL;\n\t\trel->rd_fkeyvalid = false;\n\t\trel->rd_indexlist = NIL;\n\t\trel->rd_oidindex = InvalidOid;\n\t\trel->rd_pkindex = InvalidOid;\n\t\trel->rd_replidindex = InvalidOid;\n\t\trel->rd_indexattr = NULL;\n\t\trel->rd_projindexattr = NULL;\n\t\trel->rd_keyattr = NULL;\n\t\trel->rd_pkattr = NULL;\n\t\trel->rd_idattr = NULL;\n\t\trel->rd_projidx = NULL;\n\t\trel->rd_pubactions = NULL;\n\t\trel->rd_statvalid = false;\n\t\trel->rd_statlist = NIL;\n\t\trel->rd_createSubid = InvalidSubTransactionId;\n\t\trel->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\t\trel->rd_amcache = NULL;\n\t\tMemSet(&rel->pgstat_info, 0, sizeof(rel->pgstat_info));\n\n\t\t/*\n\t\t * Recompute lock and physical addressing info.  This is needed in\n\t\t * case the pg_internal.init file was copied from some other database\n\t\t * by CREATE DATABASE.\n\t\t */\n\t\tRelationInitLockInfo(rel);\n\t\tRelationInitPhysicalAddr(rel);\n\t}\n\n\t/*\n\t * We reached the end of the init file without apparent problem.  Did we\n\t * get the right number of nailed items?  This is a useful crosscheck in\n\t * case the set of critical rels or indexes changes.  However, that should\n\t * not happen in a normally-running system, so let's bleat if it does.\n\t *\n\t * For the shared init file, we're called before client authentication is\n\t * done, which means that elog(WARNING) will go only to the postmaster\n\t * log, where it's easily missed.  To ensure that developers notice bad\n\t * values of NUM_CRITICAL_SHARED_RELS/NUM_CRITICAL_SHARED_INDEXES, we put\n\t * an Assert(false) there.\n\t */\n\tif (shared)\n\t{\n\t\tif (nailed_rels != NUM_CRITICAL_SHARED_RELS ||\n\t\t\tnailed_indexes != NUM_CRITICAL_SHARED_INDEXES)\n\t\t{\n\t\t\telog(WARNING, \"found %d nailed shared rels and %d nailed shared indexes in init file, but expected %d and %d respectively\",\n\t\t\t\t nailed_rels, nailed_indexes,\n\t\t\t\t NUM_CRITICAL_SHARED_RELS, NUM_CRITICAL_SHARED_INDEXES);\n\t\t\t/* Make sure we get developers' attention about this */\n\t\t\tAssert(false);\n\t\t\t/* In production builds, recover by bootstrapping the relcache */\n\t\t\tgoto read_failed;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (nailed_rels != NUM_CRITICAL_LOCAL_RELS ||\n\t\t\tnailed_indexes != NUM_CRITICAL_LOCAL_INDEXES)\n\t\t{\n\t\t\telog(WARNING, \"found %d nailed rels and %d nailed indexes in init file, but expected %d and %d respectively\",\n\t\t\t\t nailed_rels, nailed_indexes,\n\t\t\t\t NUM_CRITICAL_LOCAL_RELS, NUM_CRITICAL_LOCAL_INDEXES);\n\t\t\t/* We don't need an Assert() in this case */\n\t\t\tgoto read_failed;\n\t\t}\n\t}\n\n\t/*\n\t * OK, all appears well.\n\t *\n\t * Now insert all the new relcache entries into the cache.\n\t */\n\tfor (relno = 0; relno < num_rels; relno++)\n\t{\n\t\tRelationCacheInsert(rels[relno], false);\n\t}\n\n\tpfree(rels);\n\tFreeFile(fp);\n\n\tif (shared)\n\t\tcriticalSharedRelcachesBuilt = true;\n\telse\n\t\tcriticalRelcachesBuilt = true;\n\treturn true;\n\n\t/*\n\t * init file is broken, so do it the hard way.  We don't bother trying to\n\t * free the clutter we just allocated; it's not in the relcache so it\n\t * won't hurt.\n\t */\nread_failed:\n\tpfree(rels);\n\tFreeFile(fp);\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_CRITICAL_SHARED_INDEXES 6\t/* fix if you change list above */",
            "#define NUM_CRITICAL_LOCAL_INDEXES\t7\t/* fix if you change list above */",
            "#define NUM_CRITICAL_LOCAL_RELS 4\t/* fix if you change list above */",
            "#define NUM_CRITICAL_SHARED_RELS\t5\t/* fix if you change list above */",
            "#define RELCACHE_INIT_FILEMAGIC\t\t0x573266\t/* version ID value */"
          ],
          "globals_used": [
            "bool\t\tcriticalRelcachesBuilt = false;",
            "bool\t\tcriticalSharedRelcachesBuilt = false;",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static bool load_relcache_init_file(bool shared);",
            "static void write_relcache_init_file(bool shared);",
            "static void write_item(const void *data, Size len, FILE *fp);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\n#define NUM_CRITICAL_SHARED_INDEXES 6\t/* fix if you change list above */\n#define NUM_CRITICAL_LOCAL_INDEXES\t7\t/* fix if you change list above */\n#define NUM_CRITICAL_LOCAL_RELS 4\t/* fix if you change list above */\n#define NUM_CRITICAL_SHARED_RELS\t5\t/* fix if you change list above */\n#define RELCACHE_INIT_FILEMAGIC\t\t0x573266\t/* version ID value */\n\nbool\t\tcriticalRelcachesBuilt = false;\nbool\t\tcriticalSharedRelcachesBuilt = false;\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic bool load_relcache_init_file(bool shared);\nstatic void write_relcache_init_file(bool shared);\nstatic void write_item(const void *data, Size len, FILE *fp);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic bool\nload_relcache_init_file(bool shared)\n{\n\tFILE\t   *fp;\n\tchar\t\tinitfilename[MAXPGPATH];\n\tRelation   *rels;\n\tint\t\t\trelno,\n\t\t\t\tnum_rels,\n\t\t\t\tmax_rels,\n\t\t\t\tnailed_rels,\n\t\t\t\tnailed_indexes,\n\t\t\t\tmagic;\n\tint\t\t\ti;\n\n\tif (shared)\n\t\tsnprintf(initfilename, sizeof(initfilename), \"global/%s\",\n\t\t\t\t RELCACHE_INIT_FILENAME);\n\telse\n\t\tsnprintf(initfilename, sizeof(initfilename), \"%s/%s\",\n\t\t\t\t DatabasePath, RELCACHE_INIT_FILENAME);\n\n\tfp = AllocateFile(initfilename, PG_BINARY_R);\n\tif (fp == NULL)\n\t\treturn false;\n\n\t/*\n\t * Read the index relcache entries from the file.  Note we will not enter\n\t * any of them into the cache if the read fails partway through; this\n\t * helps to guard against broken init files.\n\t */\n\tmax_rels = 100;\n\trels = (Relation *) palloc(max_rels * sizeof(Relation));\n\tnum_rels = 0;\n\tnailed_rels = nailed_indexes = 0;\n\n\t/* check for correct magic number (compatible version) */\n\tif (fread(&magic, 1, sizeof(magic), fp) != sizeof(magic))\n\t\tgoto read_failed;\n\tif (magic != RELCACHE_INIT_FILEMAGIC)\n\t\tgoto read_failed;\n\n\tfor (relno = 0;; relno++)\n\t{\n\t\tSize\t\tlen;\n\t\tsize_t\t\tnread;\n\t\tRelation\trel;\n\t\tForm_pg_class relform;\n\t\tbool\t\thas_not_null;\n\n\t\t/* first read the relation descriptor length */\n\t\tnread = fread(&len, 1, sizeof(len), fp);\n\t\tif (nread != sizeof(len))\n\t\t{\n\t\t\tif (nread == 0)\n\t\t\t\tbreak;\t\t\t/* end of file */\n\t\t\tgoto read_failed;\n\t\t}\n\n\t\t/* safety check for incompatible relcache layout */\n\t\tif (len != sizeof(RelationData))\n\t\t\tgoto read_failed;\n\n\t\t/* allocate another relcache header */\n\t\tif (num_rels >= max_rels)\n\t\t{\n\t\t\tmax_rels *= 2;\n\t\t\trels = (Relation *) repalloc(rels, max_rels * sizeof(Relation));\n\t\t}\n\n\t\trel = rels[num_rels++] = (Relation) palloc(len);\n\n\t\t/* then, read the Relation structure */\n\t\tif (fread(rel, 1, len, fp) != len)\n\t\t\tgoto read_failed;\n\n\t\t/* next read the relation tuple form */\n\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\tgoto read_failed;\n\n\t\trelform = (Form_pg_class) palloc(len);\n\t\tif (fread(relform, 1, len, fp) != len)\n\t\t\tgoto read_failed;\n\n\t\trel->rd_rel = relform;\n\n\t\t/* initialize attribute tuple forms */\n\t\trel->rd_att = CreateTemplateTupleDesc(relform->relnatts,\n\t\t\t\t\t\t\t\t\t\t\t  relform->relhasoids);\n\t\trel->rd_att->tdrefcount = 1;\t/* mark as refcounted */\n\n\t\trel->rd_att->tdtypeid = relform->reltype;\n\t\trel->rd_att->tdtypmod = -1; /* unnecessary, but... */\n\n\t\t/* next read all the attribute tuple form data entries */\n\t\thas_not_null = false;\n\t\tfor (i = 0; i < relform->relnatts; i++)\n\t\t{\n\t\t\tForm_pg_attribute attr = TupleDescAttr(rel->rd_att, i);\n\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\t\t\tif (len != ATTRIBUTE_FIXED_PART_SIZE)\n\t\t\t\tgoto read_failed;\n\t\t\tif (fread(attr, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\thas_not_null |= attr->attnotnull;\n\t\t}\n\n\t\t/* next read the access method specific field */\n\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\tgoto read_failed;\n\t\tif (len > 0)\n\t\t{\n\t\t\trel->rd_options = palloc(len);\n\t\t\tif (fread(rel->rd_options, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\t\t\tif (len != VARSIZE(rel->rd_options))\n\t\t\t\tgoto read_failed;\t/* sanity check */\n\t\t}\n\t\telse\n\t\t{\n\t\t\trel->rd_options = NULL;\n\t\t}\n\n\t\t/* mark not-null status */\n\t\tif (has_not_null)\n\t\t{\n\t\t\tTupleConstr *constr = (TupleConstr *) palloc0(sizeof(TupleConstr));\n\n\t\t\tconstr->has_not_null = true;\n\t\t\trel->rd_att->constr = constr;\n\t\t}\n\n\t\t/*\n\t\t * If it's an index, there's more to do.  Note we explicitly ignore\n\t\t * partitioned indexes here.\n\t\t */\n\t\tif (rel->rd_rel->relkind == RELKIND_INDEX)\n\t\t{\n\t\t\tMemoryContext indexcxt;\n\t\t\tOid\t\t   *opfamily;\n\t\t\tOid\t\t   *opcintype;\n\t\t\tRegProcedure *support;\n\t\t\tint\t\t\tnsupport;\n\t\t\tint16\t   *indoption;\n\t\t\tOid\t\t   *indcollation;\n\n\t\t\t/* Count nailed indexes to ensure we have 'em all */\n\t\t\tif (rel->rd_isnailed)\n\t\t\t\tnailed_indexes++;\n\n\t\t\t/* next, read the pg_index tuple */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_indextuple = (HeapTuple) palloc(len);\n\t\t\tif (fread(rel->rd_indextuple, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\t/* Fix up internal pointers in the tuple -- see heap_copytuple */\n\t\t\trel->rd_indextuple->t_data = (HeapTupleHeader) ((char *) rel->rd_indextuple + HEAPTUPLESIZE);\n\t\t\trel->rd_index = (Form_pg_index) GETSTRUCT(rel->rd_indextuple);\n\n\t\t\t/*\n\t\t\t * prepare index info context --- parameters should match\n\t\t\t * RelationInitIndexAccessInfo\n\t\t\t */\n\t\t\tindexcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t \"index info\",\n\t\t\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\t\t\trel->rd_indexcxt = indexcxt;\n\t\t\tMemoryContextCopyAndSetIdentifier(indexcxt,\n\t\t\t\t\t\t\t\t\t\t\t  RelationGetRelationName(rel));\n\n\t\t\t/*\n\t\t\t * Now we can fetch the index AM's API struct.  (We can't store\n\t\t\t * that in the init file, since it contains function pointers that\n\t\t\t * might vary across server executions.  Fortunately, it should be\n\t\t\t * safe to call the amhandler even while bootstrapping indexes.)\n\t\t\t */\n\t\t\tInitIndexAmRoutine(rel);\n\n\t\t\t/* next, read the vector of opfamily OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\topfamily = (Oid *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(opfamily, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_opfamily = opfamily;\n\n\t\t\t/* next, read the vector of opcintype OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\topcintype = (Oid *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(opcintype, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_opcintype = opcintype;\n\n\t\t\t/* next, read the vector of support procedure OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\t\t\tsupport = (RegProcedure *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(support, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_support = support;\n\n\t\t\t/* next, read the vector of collation OIDs */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\tindcollation = (Oid *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(indcollation, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_indcollation = indcollation;\n\n\t\t\t/* finally, read the vector of indoption values */\n\t\t\tif (fread(&len, 1, sizeof(len), fp) != sizeof(len))\n\t\t\t\tgoto read_failed;\n\n\t\t\tindoption = (int16 *) MemoryContextAlloc(indexcxt, len);\n\t\t\tif (fread(indoption, 1, len, fp) != len)\n\t\t\t\tgoto read_failed;\n\n\t\t\trel->rd_indoption = indoption;\n\n\t\t\t/* set up zeroed fmgr-info vector */\n\t\t\tnsupport = relform->relnatts * rel->rd_amroutine->amsupport;\n\t\t\trel->rd_supportinfo = (FmgrInfo *)\n\t\t\t\tMemoryContextAllocZero(indexcxt, nsupport * sizeof(FmgrInfo));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Count nailed rels to ensure we have 'em all */\n\t\t\tif (rel->rd_isnailed)\n\t\t\t\tnailed_rels++;\n\n\t\t\tAssert(rel->rd_index == NULL);\n\t\t\tAssert(rel->rd_indextuple == NULL);\n\t\t\tAssert(rel->rd_indexcxt == NULL);\n\t\t\tAssert(rel->rd_amroutine == NULL);\n\t\t\tAssert(rel->rd_opfamily == NULL);\n\t\t\tAssert(rel->rd_opcintype == NULL);\n\t\t\tAssert(rel->rd_support == NULL);\n\t\t\tAssert(rel->rd_supportinfo == NULL);\n\t\t\tAssert(rel->rd_indoption == NULL);\n\t\t\tAssert(rel->rd_indcollation == NULL);\n\t\t}\n\n\t\t/*\n\t\t * Rules and triggers are not saved (mainly because the internal\n\t\t * format is complex and subject to change).  They must be rebuilt if\n\t\t * needed by RelationCacheInitializePhase3.  This is not expected to\n\t\t * be a big performance hit since few system catalogs have such. Ditto\n\t\t * for RLS policy data, partition info, index expressions, predicates,\n\t\t * exclusion info, and FDW info.\n\t\t */\n\t\trel->rd_rules = NULL;\n\t\trel->rd_rulescxt = NULL;\n\t\trel->trigdesc = NULL;\n\t\trel->rd_rsdesc = NULL;\n\t\trel->rd_partkey = NULL;\n\t\trel->rd_partkeycxt = NULL;\n\t\trel->rd_partdesc = NULL;\n\t\trel->rd_pdcxt = NULL;\n\t\trel->rd_partcheck = NIL;\n\t\trel->rd_partcheckvalid = false;\n\t\trel->rd_partcheckcxt = NULL;\n\t\trel->rd_indexprs = NIL;\n\t\trel->rd_indpred = NIL;\n\t\trel->rd_exclops = NULL;\n\t\trel->rd_exclprocs = NULL;\n\t\trel->rd_exclstrats = NULL;\n\t\trel->rd_fdwroutine = NULL;\n\n\t\t/*\n\t\t * Reset transient-state fields in the relcache entry\n\t\t */\n\t\trel->rd_smgr = NULL;\n\t\tif (rel->rd_isnailed)\n\t\t\trel->rd_refcnt = 1;\n\t\telse\n\t\t\trel->rd_refcnt = 0;\n\t\trel->rd_indexvalid = 0;\n\t\trel->rd_fkeylist = NIL;\n\t\trel->rd_fkeyvalid = false;\n\t\trel->rd_indexlist = NIL;\n\t\trel->rd_oidindex = InvalidOid;\n\t\trel->rd_pkindex = InvalidOid;\n\t\trel->rd_replidindex = InvalidOid;\n\t\trel->rd_indexattr = NULL;\n\t\trel->rd_projindexattr = NULL;\n\t\trel->rd_keyattr = NULL;\n\t\trel->rd_pkattr = NULL;\n\t\trel->rd_idattr = NULL;\n\t\trel->rd_projidx = NULL;\n\t\trel->rd_pubactions = NULL;\n\t\trel->rd_statvalid = false;\n\t\trel->rd_statlist = NIL;\n\t\trel->rd_createSubid = InvalidSubTransactionId;\n\t\trel->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\t\trel->rd_amcache = NULL;\n\t\tMemSet(&rel->pgstat_info, 0, sizeof(rel->pgstat_info));\n\n\t\t/*\n\t\t * Recompute lock and physical addressing info.  This is needed in\n\t\t * case the pg_internal.init file was copied from some other database\n\t\t * by CREATE DATABASE.\n\t\t */\n\t\tRelationInitLockInfo(rel);\n\t\tRelationInitPhysicalAddr(rel);\n\t}\n\n\t/*\n\t * We reached the end of the init file without apparent problem.  Did we\n\t * get the right number of nailed items?  This is a useful crosscheck in\n\t * case the set of critical rels or indexes changes.  However, that should\n\t * not happen in a normally-running system, so let's bleat if it does.\n\t *\n\t * For the shared init file, we're called before client authentication is\n\t * done, which means that elog(WARNING) will go only to the postmaster\n\t * log, where it's easily missed.  To ensure that developers notice bad\n\t * values of NUM_CRITICAL_SHARED_RELS/NUM_CRITICAL_SHARED_INDEXES, we put\n\t * an Assert(false) there.\n\t */\n\tif (shared)\n\t{\n\t\tif (nailed_rels != NUM_CRITICAL_SHARED_RELS ||\n\t\t\tnailed_indexes != NUM_CRITICAL_SHARED_INDEXES)\n\t\t{\n\t\t\telog(WARNING, \"found %d nailed shared rels and %d nailed shared indexes in init file, but expected %d and %d respectively\",\n\t\t\t\t nailed_rels, nailed_indexes,\n\t\t\t\t NUM_CRITICAL_SHARED_RELS, NUM_CRITICAL_SHARED_INDEXES);\n\t\t\t/* Make sure we get developers' attention about this */\n\t\t\tAssert(false);\n\t\t\t/* In production builds, recover by bootstrapping the relcache */\n\t\t\tgoto read_failed;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (nailed_rels != NUM_CRITICAL_LOCAL_RELS ||\n\t\t\tnailed_indexes != NUM_CRITICAL_LOCAL_INDEXES)\n\t\t{\n\t\t\telog(WARNING, \"found %d nailed rels and %d nailed indexes in init file, but expected %d and %d respectively\",\n\t\t\t\t nailed_rels, nailed_indexes,\n\t\t\t\t NUM_CRITICAL_LOCAL_RELS, NUM_CRITICAL_LOCAL_INDEXES);\n\t\t\t/* We don't need an Assert() in this case */\n\t\t\tgoto read_failed;\n\t\t}\n\t}\n\n\t/*\n\t * OK, all appears well.\n\t *\n\t * Now insert all the new relcache entries into the cache.\n\t */\n\tfor (relno = 0; relno < num_rels; relno++)\n\t{\n\t\tRelationCacheInsert(rels[relno], false);\n\t}\n\n\tpfree(rels);\n\tFreeFile(fp);\n\n\tif (shared)\n\t\tcriticalSharedRelcachesBuilt = true;\n\telse\n\t\tcriticalRelcachesBuilt = true;\n\treturn true;\n\n\t/*\n\t * init file is broken, so do it the hard way.  We don't bother trying to\n\t * free the clutter we just allocated; it's not in the relcache so it\n\t * won't hurt.\n\t */\nread_failed:\n\tpfree(rels);\n\tFreeFile(fp);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 3534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 3528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationMapInitializePhase2",
          "args": [],
          "line": 3522
        },
        "resolved": true,
        "details": {
          "function_name": "RelationMapInitializePhase2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "585-598",
          "snippet": "void\nRelationMapInitializePhase2(void)\n{\n\t/*\n\t * In bootstrap mode, the map file isn't there yet, so do nothing.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t\treturn;\n\n\t/*\n\t * Load the shared map file, die on error.\n\t */\n\tload_relmap_file(true);\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void load_relmap_file(bool shared);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void load_relmap_file(bool shared);\n\nvoid\nRelationMapInitializePhase2(void)\n{\n\t/*\n\t * In bootstrap mode, the map file isn't there yet, so do nothing.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t\treturn;\n\n\t/*\n\t * Load the shared map file, die on error.\n\t */\n\tload_relmap_file(true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\n#define NUM_CRITICAL_SHARED_RELS\t5\t/* fix if you change list above */\n\nstatic const FormData_pg_attribute Desc_pg_database[Natts_pg_database] = {Schema_pg_database};\nstatic const FormData_pg_attribute Desc_pg_authid[Natts_pg_authid] = {Schema_pg_authid};\nstatic const FormData_pg_attribute Desc_pg_auth_members[Natts_pg_auth_members] = {Schema_pg_auth_members};\nstatic const FormData_pg_attribute Desc_pg_shseclabel[Natts_pg_shseclabel] = {Schema_pg_shseclabel};\nstatic const FormData_pg_attribute Desc_pg_subscription[Natts_pg_subscription] = {Schema_pg_subscription};\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic bool load_relcache_init_file(bool shared);\nstatic void write_relcache_init_file(bool shared);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationCacheInitializePhase2(void)\n{\n\tMemoryContext oldcxt;\n\n\t/*\n\t * relation mapper needs initialized too\n\t */\n\tRelationMapInitializePhase2();\n\n\t/*\n\t * In bootstrap mode, the shared catalogs aren't there yet anyway, so do\n\t * nothing.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t\treturn;\n\n\t/*\n\t * switch to cache memory context\n\t */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * Try to load the shared relcache cache file.  If unsuccessful, bootstrap\n\t * the cache with pre-made descriptors for the critical shared catalogs.\n\t */\n\tif (!load_relcache_init_file(true))\n\t{\n\t\tformrdesc(\"pg_database\", DatabaseRelation_Rowtype_Id, true,\n\t\t\t\t  true, Natts_pg_database, Desc_pg_database);\n\t\tformrdesc(\"pg_authid\", AuthIdRelation_Rowtype_Id, true,\n\t\t\t\t  true, Natts_pg_authid, Desc_pg_authid);\n\t\tformrdesc(\"pg_auth_members\", AuthMemRelation_Rowtype_Id, true,\n\t\t\t\t  false, Natts_pg_auth_members, Desc_pg_auth_members);\n\t\tformrdesc(\"pg_shseclabel\", SharedSecLabelRelation_Rowtype_Id, true,\n\t\t\t\t  false, Natts_pg_shseclabel, Desc_pg_shseclabel);\n\t\tformrdesc(\"pg_subscription\", SubscriptionRelation_Rowtype_Id, true,\n\t\t\t\t  true, Natts_pg_subscription, Desc_pg_subscription);\n\n#define NUM_CRITICAL_SHARED_RELS\t5\t/* fix if you change list above */\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n}"
  },
  {
    "function_name": "RelationCacheInitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "3477-3501",
    "snippet": "void\nRelationCacheInitialize(void)\n{\n\tHASHCTL\t\tctl;\n\n\t/*\n\t * make sure cache memory context exists\n\t */\n\tif (!CacheMemoryContext)\n\t\tCreateCacheMemoryContext();\n\n\t/*\n\t * create hashtable that indexes the relcache\n\t */\n\tMemSet(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(Oid);\n\tctl.entrysize = sizeof(RelIdCacheEnt);\n\tRelationIdCache = hash_create(\"Relcache by OID\", INITRELCACHESIZE,\n\t\t\t\t\t\t\t\t  &ctl, HASH_ELEM | HASH_BLOBS);\n\n\t/*\n\t * relation mapper needs to be initialized too\n\t */\n\tRelationMapInitialize();\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define INITRELCACHESIZE\t\t400"
    ],
    "globals_used": [
      "static HTAB *RelationIdCache;",
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RelationMapInitialize",
          "args": [],
          "line": 3500
        },
        "resolved": true,
        "details": {
          "function_name": "RelationMapInitializePhase3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "606-619",
          "snippet": "void\nRelationMapInitializePhase3(void)\n{\n\t/*\n\t * In bootstrap mode, the map file isn't there yet, so do nothing.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t\treturn;\n\n\t/*\n\t * Load the local map file, die on error.\n\t */\n\tload_relmap_file(false);\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nvoid\nRelationMapInitializePhase3(void)\n{\n\t/*\n\t * In bootstrap mode, the map file isn't there yet, so do nothing.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t\treturn;\n\n\t/*\n\t * Load the local map file, die on error.\n\t */\n\tload_relmap_file(false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_create",
          "args": [
            "\"Relcache by OID\"",
            "INITRELCACHESIZE",
            "&ctl",
            "HASH_ELEM | HASH_BLOBS"
          ],
          "line": 3494
        },
        "resolved": true,
        "details": {
          "function_name": "hash_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "315-564",
          "snippet": "HTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_FREELISTS\t\t\t32"
          ],
          "globals_used": [
            "static void *DynaHashAlloc(Size size);",
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static int\tchoose_nelem_alloc(Size entrysize);",
            "static bool init_htab(HTAB *hashp, long nelem);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);",
            "static MemoryContext CurrentDynaHashCxt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define NUM_FREELISTS\t\t\t32\n\nstatic void *DynaHashAlloc(Size size);\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic int\tchoose_nelem_alloc(Size entrysize);\nstatic bool init_htab(HTAB *hashp, long nelem);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\nstatic MemoryContext CurrentDynaHashCxt = NULL;\n\nHTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&ctl",
            "0",
            "sizeof(ctl)"
          ],
          "line": 3491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateCacheMemoryContext",
          "args": [],
          "line": 3486
        },
        "resolved": true,
        "details": {
          "function_name": "CreateCacheMemoryContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "635-646",
          "snippet": "void\nCreateCacheMemoryContext(void)\n{\n\t/*\n\t * Purely for paranoia, check that context doesn't exist; caller probably\n\t * did so already.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCacheMemoryContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"CacheMemoryContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nvoid\nCreateCacheMemoryContext(void)\n{\n\t/*\n\t * Purely for paranoia, check that context doesn't exist; caller probably\n\t * did so already.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCacheMemoryContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"CacheMemoryContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\n#define INITRELCACHESIZE\t\t400\n\nstatic HTAB *RelationIdCache;\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationCacheInitialize(void)\n{\n\tHASHCTL\t\tctl;\n\n\t/*\n\t * make sure cache memory context exists\n\t */\n\tif (!CacheMemoryContext)\n\t\tCreateCacheMemoryContext();\n\n\t/*\n\t * create hashtable that indexes the relcache\n\t */\n\tMemSet(&ctl, 0, sizeof(ctl));\n\tctl.keysize = sizeof(Oid);\n\tctl.entrysize = sizeof(RelIdCacheEnt);\n\tRelationIdCache = hash_create(\"Relcache by OID\", INITRELCACHESIZE,\n\t\t\t\t\t\t\t\t  &ctl, HASH_ELEM | HASH_BLOBS);\n\n\t/*\n\t * relation mapper needs to be initialized too\n\t */\n\tRelationMapInitialize();\n}"
  },
  {
    "function_name": "RelationSetNewRelfilenode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "3336-3460",
    "snippet": "void\nRelationSetNewRelfilenode(Relation relation, char persistence,\n\t\t\t\t\t\t  TransactionId freezeXid, MultiXactId minmulti)\n{\n\tOid\t\t\tnewrelfilenode;\n\tRelFileNodeBackend newrnode;\n\tRelation\tpg_class;\n\tHeapTuple\ttuple;\n\tForm_pg_class classform;\n\n\t/* Indexes, sequences must have Invalid frozenxid; other rels must not */\n\tAssert((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t\trelation->rd_rel->relkind == RELKIND_SEQUENCE) ?\n\t\t   freezeXid == InvalidTransactionId :\n\t\t   TransactionIdIsNormal(freezeXid));\n\tAssert(TransactionIdIsNormal(freezeXid) == MultiXactIdIsValid(minmulti));\n\n\t/* Allocate a new relfilenode */\n\tnewrelfilenode = GetNewRelFileNode(relation->rd_rel->reltablespace, NULL,\n\t\t\t\t\t\t\t\t\t   persistence);\n\n\t/*\n\t * Get a writable copy of the pg_class tuple for the given relation.\n\t */\n\tpg_class = heap_open(RelationRelationId, RowExclusiveLock);\n\n\ttuple = SearchSysCacheCopy1(RELOID,\n\t\t\t\t\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"could not find tuple for relation %u\",\n\t\t\t RelationGetRelid(relation));\n\tclassform = (Form_pg_class) GETSTRUCT(tuple);\n\n\t/*\n\t * Create storage for the main fork of the new relfilenode.\n\t *\n\t * NOTE: any conflict in relfilenode value will be caught here, if\n\t * GetNewRelFileNode messes up for any reason.\n\t */\n\tnewrnode.node = relation->rd_node;\n\tnewrnode.node.relNode = newrelfilenode;\n\tnewrnode.backend = relation->rd_backend;\n\tRelationCreateStorage(newrnode.node, persistence);\n\tsmgrclosenode(newrnode);\n\n\t/*\n\t * Schedule unlinking of the old storage at transaction commit.\n\t */\n\tRelationDropStorage(relation);\n\n\t/*\n\t * If we're dealing with a mapped index, pg_class.relfilenode doesn't\n\t * change; instead we have to send the update to the relation mapper.\n\t *\n\t * For mapped indexes, we don't actually change the pg_class entry at all;\n\t * this is essential when reindexing pg_class itself.  That leaves us with\n\t * possibly-inaccurate values of relpages etc, but those will be fixed up\n\t * later.\n\t */\n\tif (RelationIsMapped(relation))\n\t{\n\t\t/* This case is only supported for indexes */\n\t\tAssert(relation->rd_rel->relkind == RELKIND_INDEX);\n\n\t\t/* Since we're not updating pg_class, these had better not change */\n\t\tAssert(classform->relfrozenxid == freezeXid);\n\t\tAssert(classform->relminmxid == minmulti);\n\t\tAssert(classform->relpersistence == persistence);\n\n\t\t/*\n\t\t * In some code paths it's possible that the tuple update we'd\n\t\t * otherwise do here is the only thing that would assign an XID for\n\t\t * the current transaction.  However, we must have an XID to delete\n\t\t * files, so make sure one is assigned.\n\t\t */\n\t\t(void) GetCurrentTransactionId();\n\n\t\t/* Do the deed */\n\t\tRelationMapUpdateMap(RelationGetRelid(relation),\n\t\t\t\t\t\t\t newrelfilenode,\n\t\t\t\t\t\t\t relation->rd_rel->relisshared,\n\t\t\t\t\t\t\t false);\n\n\t\t/* Since we're not updating pg_class, must trigger inval manually */\n\t\tCacheInvalidateRelcache(relation);\n\t}\n\telse\n\t{\n\t\t/* Normal case, update the pg_class entry */\n\t\tclassform->relfilenode = newrelfilenode;\n\n\t\t/* relpages etc. never change for sequences */\n\t\tif (relation->rd_rel->relkind != RELKIND_SEQUENCE)\n\t\t{\n\t\t\tclassform->relpages = 0;\t/* it's empty until further notice */\n\t\t\tclassform->reltuples = 0;\n\t\t\tclassform->relallvisible = 0;\n\t\t}\n\t\tclassform->relfrozenxid = freezeXid;\n\t\tclassform->relminmxid = minmulti;\n\t\tclassform->relpersistence = persistence;\n\n\t\tCatalogTupleUpdate(pg_class, &tuple->t_self, tuple);\n\t}\n\n\theap_freetuple(tuple);\n\n\theap_close(pg_class, RowExclusiveLock);\n\n\t/*\n\t * Make the pg_class row change or relation map change visible.  This will\n\t * cause the relcache entry to get updated, too.\n\t */\n\tCommandCounterIncrement();\n\n\t/*\n\t * Mark the rel as having been given a new relfilenode in the current\n\t * (sub) transaction.  This is a hint that can be used to optimize later\n\t * operations on the rel in the same transaction.\n\t */\n\trelation->rd_newRelfilenodeSubid = GetCurrentSubTransactionId();\n\n\t/* Flag relation as needing eoxact cleanup (to remove the hint) */\n\tEOXactListAdd(relation);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EOXactListAdd",
          "args": [
            "relation"
          ],
          "line": 3459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentSubTransactionId",
          "args": [],
          "line": 3456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CommandCounterIncrement",
          "args": [],
          "line": 3449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "pg_class",
            "RowExclusiveLock"
          ],
          "line": 3443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_freetuple",
          "args": [
            "tuple"
          ],
          "line": 3441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CatalogTupleUpdate",
          "args": [
            "pg_class",
            "&tuple->t_self",
            "tuple"
          ],
          "line": 3438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CacheInvalidateRelcache",
          "args": [
            "relation"
          ],
          "line": 3420
        },
        "resolved": true,
        "details": {
          "function_name": "CacheInvalidateRelcacheByRelid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/inval.c",
          "lines": "1328-1340",
          "snippet": "void\nCacheInvalidateRelcacheByRelid(Oid relid)\n{\n\tHeapTuple\ttup;\n\n\tPrepareInvalidationState();\n\n\ttup = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for relation %u\", relid);\n\tCacheInvalidateRelcacheByTuple(tup);\n\tReleaseSysCache(tup);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"storage/smgr.h\"\n#include \"storage/sinval.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nvoid\nCacheInvalidateRelcacheByRelid(Oid relid)\n{\n\tHeapTuple\ttup;\n\n\tPrepareInvalidationState();\n\n\ttup = SearchSysCache1(RELOID, ObjectIdGetDatum(relid));\n\tif (!HeapTupleIsValid(tup))\n\t\telog(ERROR, \"cache lookup failed for relation %u\", relid);\n\tCacheInvalidateRelcacheByTuple(tup);\n\tReleaseSysCache(tup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationMapUpdateMap",
          "args": [
            "RelationGetRelid(relation)",
            "newrelfilenode",
            "relation->rd_rel->relisshared",
            "false"
          ],
          "line": 3414
        },
        "resolved": true,
        "details": {
          "function_name": "RelationMapUpdateMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "247-295",
          "snippet": "void\nRelationMapUpdateMap(Oid relationId, Oid fileNode, bool shared,\n\t\t\t\t\t bool immediate)\n{\n\tRelMapFile *map;\n\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\t/*\n\t\t * In bootstrap mode, the mapping gets installed in permanent map.\n\t\t */\n\t\tif (shared)\n\t\t\tmap = &shared_map;\n\t\telse\n\t\t\tmap = &local_map;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't currently support map changes within subtransactions, and\n\t\t * parallel workers must avoid relying on mapping state, since it\n\t\t * isn't propagated from the leader.  This could be done with more\n\t\t * bookkeeping infrastructure, but it doesn't presently seem worth it.\n\t\t */\n\t\tif (GetCurrentTransactionNestLevel() > 1)\n\t\t\telog(ERROR, \"cannot change relation mapping within subtransaction\");\n\n\t\tif (IsInParallelMode())\n\t\t\telog(ERROR, \"cannot change relation mapping in parallel mode\");\n\n\t\tif (immediate)\n\t\t{\n\t\t\t/* Make it active, but only locally */\n\t\t\tif (shared)\n\t\t\t\tmap = &active_shared_updates;\n\t\t\telse\n\t\t\t\tmap = &active_local_updates;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Make it pending */\n\t\t\tif (shared)\n\t\t\t\tmap = &pending_shared_updates;\n\t\t\telse\n\t\t\t\tmap = &pending_local_updates;\n\t\t}\n\t}\n\tapply_map_update(map, relationId, fileNode, true);\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RelMapFile shared_map;",
            "static RelMapFile local_map;",
            "static RelMapFile active_shared_updates;",
            "static RelMapFile active_local_updates;",
            "static RelMapFile pending_shared_updates;",
            "static RelMapFile pending_local_updates;",
            "static void load_relmap_file(bool shared);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic RelMapFile active_shared_updates;\nstatic RelMapFile active_local_updates;\nstatic RelMapFile pending_shared_updates;\nstatic RelMapFile pending_local_updates;\nstatic void load_relmap_file(bool shared);\n\nvoid\nRelationMapUpdateMap(Oid relationId, Oid fileNode, bool shared,\n\t\t\t\t\t bool immediate)\n{\n\tRelMapFile *map;\n\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\t/*\n\t\t * In bootstrap mode, the mapping gets installed in permanent map.\n\t\t */\n\t\tif (shared)\n\t\t\tmap = &shared_map;\n\t\telse\n\t\t\tmap = &local_map;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't currently support map changes within subtransactions, and\n\t\t * parallel workers must avoid relying on mapping state, since it\n\t\t * isn't propagated from the leader.  This could be done with more\n\t\t * bookkeeping infrastructure, but it doesn't presently seem worth it.\n\t\t */\n\t\tif (GetCurrentTransactionNestLevel() > 1)\n\t\t\telog(ERROR, \"cannot change relation mapping within subtransaction\");\n\n\t\tif (IsInParallelMode())\n\t\t\telog(ERROR, \"cannot change relation mapping in parallel mode\");\n\n\t\tif (immediate)\n\t\t{\n\t\t\t/* Make it active, but only locally */\n\t\t\tif (shared)\n\t\t\t\tmap = &active_shared_updates;\n\t\t\telse\n\t\t\t\tmap = &active_local_updates;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Make it pending */\n\t\t\tif (shared)\n\t\t\t\tmap = &pending_shared_updates;\n\t\t\telse\n\t\t\t\tmap = &pending_local_updates;\n\t\t}\n\t}\n\tapply_map_update(map, relationId, fileNode, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 3414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentTransactionId",
          "args": [],
          "line": 3411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "classform->relpersistence == persistence"
          ],
          "line": 3403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "classform->relminmxid == minmulti"
          ],
          "line": 3402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "classform->relfrozenxid == freezeXid"
          ],
          "line": 3401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relation->rd_rel->relkind == RELKIND_INDEX"
          ],
          "line": 3398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationIsMapped",
          "args": [
            "relation"
          ],
          "line": 3395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationDropStorage",
          "args": [
            "relation"
          ],
          "line": 3384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smgrclosenode",
          "args": [
            "newrnode"
          ],
          "line": 3379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationCreateStorage",
          "args": [
            "newrnode.node",
            "persistence"
          ],
          "line": 3378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 3367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"could not find tuple for relation %u\"",
            "RelationGetRelid(relation)"
          ],
          "line": 3365
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 3366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCacheCopy1",
          "args": [
            "RELOID",
            "ObjectIdGetDatum(RelationGetRelid(relation))"
          ],
          "line": 3362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "RelationGetRelid(relation)"
          ],
          "line": 3363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 3363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "RelationRelationId",
            "RowExclusiveLock"
          ],
          "line": 3360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetNewRelFileNode",
          "args": [
            "relation->rd_rel->reltablespace",
            "NULL",
            "persistence"
          ],
          "line": 3354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "TransactionIdIsNormal(freezeXid) == MultiXactIdIsValid(minmulti)"
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MultiXactIdIsValid",
          "args": [
            "minmulti"
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsNormal",
          "args": [
            "freezeXid"
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "(relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t\trelation->rd_rel->relkind == RELKIND_SEQUENCE) ?\n\t\t   freezeXid == InvalidTransactionId :\n\t\t   TransactionIdIsNormal(freezeXid)"
          ],
          "line": 3347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TransactionIdIsNormal",
          "args": [
            "freezeXid"
          ],
          "line": 3350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationSetNewRelfilenode(Relation relation, char persistence,\n\t\t\t\t\t\t  TransactionId freezeXid, MultiXactId minmulti)\n{\n\tOid\t\t\tnewrelfilenode;\n\tRelFileNodeBackend newrnode;\n\tRelation\tpg_class;\n\tHeapTuple\ttuple;\n\tForm_pg_class classform;\n\n\t/* Indexes, sequences must have Invalid frozenxid; other rels must not */\n\tAssert((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t\trelation->rd_rel->relkind == RELKIND_SEQUENCE) ?\n\t\t   freezeXid == InvalidTransactionId :\n\t\t   TransactionIdIsNormal(freezeXid));\n\tAssert(TransactionIdIsNormal(freezeXid) == MultiXactIdIsValid(minmulti));\n\n\t/* Allocate a new relfilenode */\n\tnewrelfilenode = GetNewRelFileNode(relation->rd_rel->reltablespace, NULL,\n\t\t\t\t\t\t\t\t\t   persistence);\n\n\t/*\n\t * Get a writable copy of the pg_class tuple for the given relation.\n\t */\n\tpg_class = heap_open(RelationRelationId, RowExclusiveLock);\n\n\ttuple = SearchSysCacheCopy1(RELOID,\n\t\t\t\t\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"could not find tuple for relation %u\",\n\t\t\t RelationGetRelid(relation));\n\tclassform = (Form_pg_class) GETSTRUCT(tuple);\n\n\t/*\n\t * Create storage for the main fork of the new relfilenode.\n\t *\n\t * NOTE: any conflict in relfilenode value will be caught here, if\n\t * GetNewRelFileNode messes up for any reason.\n\t */\n\tnewrnode.node = relation->rd_node;\n\tnewrnode.node.relNode = newrelfilenode;\n\tnewrnode.backend = relation->rd_backend;\n\tRelationCreateStorage(newrnode.node, persistence);\n\tsmgrclosenode(newrnode);\n\n\t/*\n\t * Schedule unlinking of the old storage at transaction commit.\n\t */\n\tRelationDropStorage(relation);\n\n\t/*\n\t * If we're dealing with a mapped index, pg_class.relfilenode doesn't\n\t * change; instead we have to send the update to the relation mapper.\n\t *\n\t * For mapped indexes, we don't actually change the pg_class entry at all;\n\t * this is essential when reindexing pg_class itself.  That leaves us with\n\t * possibly-inaccurate values of relpages etc, but those will be fixed up\n\t * later.\n\t */\n\tif (RelationIsMapped(relation))\n\t{\n\t\t/* This case is only supported for indexes */\n\t\tAssert(relation->rd_rel->relkind == RELKIND_INDEX);\n\n\t\t/* Since we're not updating pg_class, these had better not change */\n\t\tAssert(classform->relfrozenxid == freezeXid);\n\t\tAssert(classform->relminmxid == minmulti);\n\t\tAssert(classform->relpersistence == persistence);\n\n\t\t/*\n\t\t * In some code paths it's possible that the tuple update we'd\n\t\t * otherwise do here is the only thing that would assign an XID for\n\t\t * the current transaction.  However, we must have an XID to delete\n\t\t * files, so make sure one is assigned.\n\t\t */\n\t\t(void) GetCurrentTransactionId();\n\n\t\t/* Do the deed */\n\t\tRelationMapUpdateMap(RelationGetRelid(relation),\n\t\t\t\t\t\t\t newrelfilenode,\n\t\t\t\t\t\t\t relation->rd_rel->relisshared,\n\t\t\t\t\t\t\t false);\n\n\t\t/* Since we're not updating pg_class, must trigger inval manually */\n\t\tCacheInvalidateRelcache(relation);\n\t}\n\telse\n\t{\n\t\t/* Normal case, update the pg_class entry */\n\t\tclassform->relfilenode = newrelfilenode;\n\n\t\t/* relpages etc. never change for sequences */\n\t\tif (relation->rd_rel->relkind != RELKIND_SEQUENCE)\n\t\t{\n\t\t\tclassform->relpages = 0;\t/* it's empty until further notice */\n\t\t\tclassform->reltuples = 0;\n\t\t\tclassform->relallvisible = 0;\n\t\t}\n\t\tclassform->relfrozenxid = freezeXid;\n\t\tclassform->relminmxid = minmulti;\n\t\tclassform->relpersistence = persistence;\n\n\t\tCatalogTupleUpdate(pg_class, &tuple->t_self, tuple);\n\t}\n\n\theap_freetuple(tuple);\n\n\theap_close(pg_class, RowExclusiveLock);\n\n\t/*\n\t * Make the pg_class row change or relation map change visible.  This will\n\t * cause the relcache entry to get updated, too.\n\t */\n\tCommandCounterIncrement();\n\n\t/*\n\t * Mark the rel as having been given a new relfilenode in the current\n\t * (sub) transaction.  This is a hint that can be used to optimize later\n\t * operations on the rel in the same transaction.\n\t */\n\trelation->rd_newRelfilenodeSubid = GetCurrentSubTransactionId();\n\n\t/* Flag relation as needing eoxact cleanup (to remove the hint) */\n\tEOXactListAdd(relation);\n}"
  },
  {
    "function_name": "RelationBuildLocalRelation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "3096-3312",
    "snippet": "Relation\nRelationBuildLocalRelation(const char *relname,\n\t\t\t\t\t\t   Oid relnamespace,\n\t\t\t\t\t\t   TupleDesc tupDesc,\n\t\t\t\t\t\t   Oid relid,\n\t\t\t\t\t\t   Oid relfilenode,\n\t\t\t\t\t\t   Oid reltablespace,\n\t\t\t\t\t\t   bool shared_relation,\n\t\t\t\t\t\t   bool mapped_relation,\n\t\t\t\t\t\t   char relpersistence,\n\t\t\t\t\t\t   char relkind)\n{\n\tRelation\trel;\n\tMemoryContext oldcxt;\n\tint\t\t\tnatts = tupDesc->natts;\n\tint\t\t\ti;\n\tbool\t\thas_not_null;\n\tbool\t\tnailit;\n\n\tAssertArg(natts >= 0);\n\n\t/*\n\t * check for creation of a rel that must be nailed in cache.\n\t *\n\t * XXX this list had better match the relations specially handled in\n\t * RelationCacheInitializePhase2/3.\n\t */\n\tswitch (relid)\n\t{\n\t\tcase DatabaseRelationId:\n\t\tcase AuthIdRelationId:\n\t\tcase AuthMemRelationId:\n\t\tcase RelationRelationId:\n\t\tcase AttributeRelationId:\n\t\tcase ProcedureRelationId:\n\t\tcase TypeRelationId:\n\t\t\tnailit = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnailit = false;\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * check that hardwired list of shared rels matches what's in the\n\t * bootstrap .bki file.  If you get a failure here during initdb, you\n\t * probably need to fix IsSharedRelation() to match whatever you've done\n\t * to the set of shared relations.\n\t */\n\tif (shared_relation != IsSharedRelation(relid))\n\t\telog(ERROR, \"shared_relation flag for \\\"%s\\\" does not match IsSharedRelation(%u)\",\n\t\t\t relname, relid);\n\n\t/* Shared relations had better be mapped, too */\n\tAssert(mapped_relation || !shared_relation);\n\n\t/*\n\t * switch to the cache context to create the relcache entry.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCreateCacheMemoryContext();\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * allocate a new relation descriptor and fill in basic state fields.\n\t */\n\trel = (Relation) palloc0(sizeof(RelationData));\n\n\t/* make sure relation is marked as having no open file yet */\n\trel->rd_smgr = NULL;\n\n\t/* mark it nailed if appropriate */\n\trel->rd_isnailed = nailit;\n\n\trel->rd_refcnt = nailit ? 1 : 0;\n\n\t/* it's being created in this transaction */\n\trel->rd_createSubid = GetCurrentSubTransactionId();\n\trel->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\n\t/*\n\t * create a new tuple descriptor from the one passed in.  We do this\n\t * partly to copy it into the cache context, and partly because the new\n\t * relation can't have any defaults or constraints yet; they have to be\n\t * added in later steps, because they require additions to multiple system\n\t * catalogs.  We can copy attnotnull constraints here, however.\n\t */\n\trel->rd_att = CreateTupleDescCopy(tupDesc);\n\trel->rd_att->tdrefcount = 1;\t/* mark as refcounted */\n\thas_not_null = false;\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tForm_pg_attribute satt = TupleDescAttr(tupDesc, i);\n\t\tForm_pg_attribute datt = TupleDescAttr(rel->rd_att, i);\n\n\t\tdatt->attidentity = satt->attidentity;\n\t\tdatt->attnotnull = satt->attnotnull;\n\t\thas_not_null |= satt->attnotnull;\n\t}\n\n\tif (has_not_null)\n\t{\n\t\tTupleConstr *constr = (TupleConstr *) palloc0(sizeof(TupleConstr));\n\n\t\tconstr->has_not_null = true;\n\t\trel->rd_att->constr = constr;\n\t}\n\n\t/*\n\t * initialize relation tuple form (caller may add/override data later)\n\t */\n\trel->rd_rel = (Form_pg_class) palloc0(CLASS_TUPLE_SIZE);\n\n\tnamestrcpy(&rel->rd_rel->relname, relname);\n\trel->rd_rel->relnamespace = relnamespace;\n\n\trel->rd_rel->relkind = relkind;\n\trel->rd_rel->relhasoids = rel->rd_att->tdhasoid;\n\trel->rd_rel->relnatts = natts;\n\trel->rd_rel->reltype = InvalidOid;\n\t/* needed when bootstrapping: */\n\trel->rd_rel->relowner = BOOTSTRAP_SUPERUSERID;\n\n\t/* set up persistence and relcache fields dependent on it */\n\trel->rd_rel->relpersistence = relpersistence;\n\tswitch (relpersistence)\n\t{\n\t\tcase RELPERSISTENCE_UNLOGGED:\n\t\tcase RELPERSISTENCE_PERMANENT:\n\t\t\trel->rd_backend = InvalidBackendId;\n\t\t\trel->rd_islocaltemp = false;\n\t\t\tbreak;\n\t\tcase RELPERSISTENCE_TEMP:\n\t\t\tAssert(isTempOrTempToastNamespace(relnamespace));\n\t\t\trel->rd_backend = BackendIdForTempRelations();\n\t\t\trel->rd_islocaltemp = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid relpersistence: %c\", relpersistence);\n\t\t\tbreak;\n\t}\n\n\t/* if it's a materialized view, it's not populated initially */\n\tif (relkind == RELKIND_MATVIEW)\n\t\trel->rd_rel->relispopulated = false;\n\telse\n\t\trel->rd_rel->relispopulated = true;\n\n\t/* system relations and non-table objects don't have one */\n\tif (!IsSystemNamespace(relnamespace) &&\n\t\t(relkind == RELKIND_RELATION ||\n\t\t relkind == RELKIND_MATVIEW ||\n\t\t relkind == RELKIND_PARTITIONED_TABLE))\n\t\trel->rd_rel->relreplident = REPLICA_IDENTITY_DEFAULT;\n\telse\n\t\trel->rd_rel->relreplident = REPLICA_IDENTITY_NOTHING;\n\n\t/*\n\t * Insert relation physical and logical identifiers (OIDs) into the right\n\t * places.  For a mapped relation, we set relfilenode to zero and rely on\n\t * RelationInitPhysicalAddr to consult the map.\n\t */\n\trel->rd_rel->relisshared = shared_relation;\n\n\tRelationGetRelid(rel) = relid;\n\n\tfor (i = 0; i < natts; i++)\n\t\tTupleDescAttr(rel->rd_att, i)->attrelid = relid;\n\n\trel->rd_rel->reltablespace = reltablespace;\n\n\tif (mapped_relation)\n\t{\n\t\trel->rd_rel->relfilenode = InvalidOid;\n\t\t/* Add it to the active mapping information */\n\t\tRelationMapUpdateMap(relid, relfilenode, shared_relation, true);\n\t}\n\telse\n\t\trel->rd_rel->relfilenode = relfilenode;\n\n\tRelationInitLockInfo(rel);\t/* see lmgr.c */\n\n\tRelationInitPhysicalAddr(rel);\n\n\t/*\n\t * Okay to insert into the relcache hash table.\n\t *\n\t * Ordinarily, there should certainly not be an existing hash entry for\n\t * the same OID; but during bootstrap, when we create a \"real\" relcache\n\t * entry for one of the bootstrap relations, we'll be overwriting the\n\t * phony one created with formrdesc.  So allow that to happen for nailed\n\t * rels.\n\t */\n\tRelationCacheInsert(rel, nailit);\n\n\t/*\n\t * Flag relation as needing eoxact cleanup (to clear rd_createSubid). We\n\t * can't do this before storing relid in it.\n\t */\n\tEOXactListAdd(rel);\n\n\t/*\n\t * done building relcache entry.\n\t */\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* It's fully valid */\n\trel->rd_isvalid = true;\n\n\t/*\n\t * Caller expects us to pin the returned entry.\n\t */\n\tRelationIncrementReferenceCount(rel);\n\n\treturn rel;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static bool load_relcache_init_file(bool shared);",
      "static void write_relcache_init_file(bool shared);",
      "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RelationIncrementReferenceCount",
          "args": [
            "rel"
          ],
          "line": 3309
        },
        "resolved": true,
        "details": {
          "function_name": "RelationIncrementReferenceCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1975-1982",
          "snippet": "void\nRelationIncrementReferenceCount(Relation rel)\n{\n\tResourceOwnerEnlargeRelationRefs(CurrentResourceOwner);\n\trel->rd_refcnt += 1;\n\tif (!IsBootstrapProcessingMode())\n\t\tResourceOwnerRememberRelationRef(CurrentResourceOwner, rel);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nvoid\nRelationIncrementReferenceCount(Relation rel)\n{\n\tResourceOwnerEnlargeRelationRefs(CurrentResourceOwner);\n\trel->rd_refcnt += 1;\n\tif (!IsBootstrapProcessingMode())\n\t\tResourceOwnerRememberRelationRef(CurrentResourceOwner, rel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 3301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EOXactListAdd",
          "args": [
            "rel"
          ],
          "line": 3296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationCacheInsert",
          "args": [
            "rel",
            "nailit"
          ],
          "line": 3290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationInitPhysicalAddr",
          "args": [
            "rel"
          ],
          "line": 3279
        },
        "resolved": true,
        "details": {
          "function_name": "RelationInitPhysicalAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1259-1315",
          "snippet": "static void\nRelationInitPhysicalAddr(Relation relation)\n{\n\tif (relation->rd_rel->reltablespace)\n\t\trelation->rd_node.spcNode = relation->rd_rel->reltablespace;\n\telse\n\t\trelation->rd_node.spcNode = MyDatabaseTableSpace;\n\tif (relation->rd_node.spcNode == GLOBALTABLESPACE_OID)\n\t\trelation->rd_node.dbNode = InvalidOid;\n\telse\n\t\trelation->rd_node.dbNode = MyDatabaseId;\n\n\tif (relation->rd_rel->relfilenode)\n\t{\n\t\t/*\n\t\t * Even if we are using a decoding snapshot that doesn't represent the\n\t\t * current state of the catalog we need to make sure the filenode\n\t\t * points to the current file since the older file will be gone (or\n\t\t * truncated). The new file will still contain older rows so lookups\n\t\t * in them will work correctly. This wouldn't work correctly if\n\t\t * rewrites were allowed to change the schema in an incompatible way,\n\t\t * but those are prevented both on catalog tables and on user tables\n\t\t * declared as additional catalog tables.\n\t\t */\n\t\tif (HistoricSnapshotActive()\n\t\t\t&& RelationIsAccessibleInLogicalDecoding(relation)\n\t\t\t&& IsTransactionState())\n\t\t{\n\t\t\tHeapTuple\tphys_tuple;\n\t\t\tForm_pg_class physrel;\n\n\t\t\tphys_tuple = ScanPgRelation(RelationGetRelid(relation),\n\t\t\t\t\t\t\t\t\t\tRelationGetRelid(relation) != ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t\ttrue);\n\t\t\tif (!HeapTupleIsValid(phys_tuple))\n\t\t\t\telog(ERROR, \"could not find pg_class entry for %u\",\n\t\t\t\t\t RelationGetRelid(relation));\n\t\t\tphysrel = (Form_pg_class) GETSTRUCT(phys_tuple);\n\n\t\t\trelation->rd_rel->reltablespace = physrel->reltablespace;\n\t\t\trelation->rd_rel->relfilenode = physrel->relfilenode;\n\t\t\theap_freetuple(phys_tuple);\n\t\t}\n\n\t\trelation->rd_node.relNode = relation->rd_rel->relfilenode;\n\t}\n\telse\n\t{\n\t\t/* Consult the relation mapper */\n\t\trelation->rd_node.relNode =\n\t\t\tRelationMapOidToFilenode(relation->rd_id,\n\t\t\t\t\t\t\t\t\t relation->rd_rel->relisshared);\n\t\tif (!OidIsValid(relation->rd_node.relNode))\n\t\t\telog(ERROR, \"could not find relation mapping for relation \\\"%s\\\", OID %u\",\n\t\t\t\t RelationGetRelationName(relation), relation->rd_id);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationInitPhysicalAddr(Relation relation)\n{\n\tif (relation->rd_rel->reltablespace)\n\t\trelation->rd_node.spcNode = relation->rd_rel->reltablespace;\n\telse\n\t\trelation->rd_node.spcNode = MyDatabaseTableSpace;\n\tif (relation->rd_node.spcNode == GLOBALTABLESPACE_OID)\n\t\trelation->rd_node.dbNode = InvalidOid;\n\telse\n\t\trelation->rd_node.dbNode = MyDatabaseId;\n\n\tif (relation->rd_rel->relfilenode)\n\t{\n\t\t/*\n\t\t * Even if we are using a decoding snapshot that doesn't represent the\n\t\t * current state of the catalog we need to make sure the filenode\n\t\t * points to the current file since the older file will be gone (or\n\t\t * truncated). The new file will still contain older rows so lookups\n\t\t * in them will work correctly. This wouldn't work correctly if\n\t\t * rewrites were allowed to change the schema in an incompatible way,\n\t\t * but those are prevented both on catalog tables and on user tables\n\t\t * declared as additional catalog tables.\n\t\t */\n\t\tif (HistoricSnapshotActive()\n\t\t\t&& RelationIsAccessibleInLogicalDecoding(relation)\n\t\t\t&& IsTransactionState())\n\t\t{\n\t\t\tHeapTuple\tphys_tuple;\n\t\t\tForm_pg_class physrel;\n\n\t\t\tphys_tuple = ScanPgRelation(RelationGetRelid(relation),\n\t\t\t\t\t\t\t\t\t\tRelationGetRelid(relation) != ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t\ttrue);\n\t\t\tif (!HeapTupleIsValid(phys_tuple))\n\t\t\t\telog(ERROR, \"could not find pg_class entry for %u\",\n\t\t\t\t\t RelationGetRelid(relation));\n\t\t\tphysrel = (Form_pg_class) GETSTRUCT(phys_tuple);\n\n\t\t\trelation->rd_rel->reltablespace = physrel->reltablespace;\n\t\t\trelation->rd_rel->relfilenode = physrel->relfilenode;\n\t\t\theap_freetuple(phys_tuple);\n\t\t}\n\n\t\trelation->rd_node.relNode = relation->rd_rel->relfilenode;\n\t}\n\telse\n\t{\n\t\t/* Consult the relation mapper */\n\t\trelation->rd_node.relNode =\n\t\t\tRelationMapOidToFilenode(relation->rd_id,\n\t\t\t\t\t\t\t\t\t relation->rd_rel->relisshared);\n\t\tif (!OidIsValid(relation->rd_node.relNode))\n\t\t\telog(ERROR, \"could not find relation mapping for relation \\\"%s\\\", OID %u\",\n\t\t\t\t RelationGetRelationName(relation), relation->rd_id);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationInitLockInfo",
          "args": [
            "rel"
          ],
          "line": 3277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationMapUpdateMap",
          "args": [
            "relid",
            "relfilenode",
            "shared_relation",
            "true"
          ],
          "line": 3272
        },
        "resolved": true,
        "details": {
          "function_name": "RelationMapUpdateMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "247-295",
          "snippet": "void\nRelationMapUpdateMap(Oid relationId, Oid fileNode, bool shared,\n\t\t\t\t\t bool immediate)\n{\n\tRelMapFile *map;\n\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\t/*\n\t\t * In bootstrap mode, the mapping gets installed in permanent map.\n\t\t */\n\t\tif (shared)\n\t\t\tmap = &shared_map;\n\t\telse\n\t\t\tmap = &local_map;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't currently support map changes within subtransactions, and\n\t\t * parallel workers must avoid relying on mapping state, since it\n\t\t * isn't propagated from the leader.  This could be done with more\n\t\t * bookkeeping infrastructure, but it doesn't presently seem worth it.\n\t\t */\n\t\tif (GetCurrentTransactionNestLevel() > 1)\n\t\t\telog(ERROR, \"cannot change relation mapping within subtransaction\");\n\n\t\tif (IsInParallelMode())\n\t\t\telog(ERROR, \"cannot change relation mapping in parallel mode\");\n\n\t\tif (immediate)\n\t\t{\n\t\t\t/* Make it active, but only locally */\n\t\t\tif (shared)\n\t\t\t\tmap = &active_shared_updates;\n\t\t\telse\n\t\t\t\tmap = &active_local_updates;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Make it pending */\n\t\t\tif (shared)\n\t\t\t\tmap = &pending_shared_updates;\n\t\t\telse\n\t\t\t\tmap = &pending_local_updates;\n\t\t}\n\t}\n\tapply_map_update(map, relationId, fileNode, true);\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RelMapFile shared_map;",
            "static RelMapFile local_map;",
            "static RelMapFile active_shared_updates;",
            "static RelMapFile active_local_updates;",
            "static RelMapFile pending_shared_updates;",
            "static RelMapFile pending_local_updates;",
            "static void load_relmap_file(bool shared);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic RelMapFile active_shared_updates;\nstatic RelMapFile active_local_updates;\nstatic RelMapFile pending_shared_updates;\nstatic RelMapFile pending_local_updates;\nstatic void load_relmap_file(bool shared);\n\nvoid\nRelationMapUpdateMap(Oid relationId, Oid fileNode, bool shared,\n\t\t\t\t\t bool immediate)\n{\n\tRelMapFile *map;\n\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\t/*\n\t\t * In bootstrap mode, the mapping gets installed in permanent map.\n\t\t */\n\t\tif (shared)\n\t\t\tmap = &shared_map;\n\t\telse\n\t\t\tmap = &local_map;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't currently support map changes within subtransactions, and\n\t\t * parallel workers must avoid relying on mapping state, since it\n\t\t * isn't propagated from the leader.  This could be done with more\n\t\t * bookkeeping infrastructure, but it doesn't presently seem worth it.\n\t\t */\n\t\tif (GetCurrentTransactionNestLevel() > 1)\n\t\t\telog(ERROR, \"cannot change relation mapping within subtransaction\");\n\n\t\tif (IsInParallelMode())\n\t\t\telog(ERROR, \"cannot change relation mapping in parallel mode\");\n\n\t\tif (immediate)\n\t\t{\n\t\t\t/* Make it active, but only locally */\n\t\t\tif (shared)\n\t\t\t\tmap = &active_shared_updates;\n\t\t\telse\n\t\t\t\tmap = &active_local_updates;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Make it pending */\n\t\t\tif (shared)\n\t\t\t\tmap = &pending_shared_updates;\n\t\t\telse\n\t\t\t\tmap = &pending_local_updates;\n\t\t}\n\t}\n\tapply_map_update(map, relationId, fileNode, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "rel->rd_att",
            "i"
          ],
          "line": 3264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "rel"
          ],
          "line": 3261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsSystemNamespace",
          "args": [
            "relnamespace"
          ],
          "line": 3246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid relpersistence: %c\"",
            "relpersistence"
          ],
          "line": 3235
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BackendIdForTempRelations",
          "args": [],
          "line": 3231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "isTempOrTempToastNamespace(relnamespace)"
          ],
          "line": 3230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isTempOrTempToastNamespace",
          "args": [
            "relnamespace"
          ],
          "line": 3230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namestrcpy",
          "args": [
            "&rel->rd_rel->relname",
            "relname"
          ],
          "line": 3210
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "CLASS_TUPLE_SIZE"
          ],
          "line": 3208
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "rel->rd_att",
            "i"
          ],
          "line": 3190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupDesc",
            "i"
          ],
          "line": 3189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTupleDescCopy",
          "args": [
            "tupDesc"
          ],
          "line": 3184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentSubTransactionId",
          "args": [],
          "line": 3174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 3158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateCacheMemoryContext",
          "args": [],
          "line": 3156
        },
        "resolved": true,
        "details": {
          "function_name": "CreateCacheMemoryContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "635-646",
          "snippet": "void\nCreateCacheMemoryContext(void)\n{\n\t/*\n\t * Purely for paranoia, check that context doesn't exist; caller probably\n\t * did so already.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCacheMemoryContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"CacheMemoryContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nvoid\nCreateCacheMemoryContext(void)\n{\n\t/*\n\t * Purely for paranoia, check that context doesn't exist; caller probably\n\t * did so already.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCacheMemoryContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"CacheMemoryContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "mapped_relation || !shared_relation"
          ],
          "line": 3150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsSharedRelation",
          "args": [
            "relid"
          ],
          "line": 3145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AssertArg",
          "args": [
            "natts >= 0"
          ],
          "line": 3115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic bool load_relcache_init_file(bool shared);\nstatic void write_relcache_init_file(bool shared);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nRelation\nRelationBuildLocalRelation(const char *relname,\n\t\t\t\t\t\t   Oid relnamespace,\n\t\t\t\t\t\t   TupleDesc tupDesc,\n\t\t\t\t\t\t   Oid relid,\n\t\t\t\t\t\t   Oid relfilenode,\n\t\t\t\t\t\t   Oid reltablespace,\n\t\t\t\t\t\t   bool shared_relation,\n\t\t\t\t\t\t   bool mapped_relation,\n\t\t\t\t\t\t   char relpersistence,\n\t\t\t\t\t\t   char relkind)\n{\n\tRelation\trel;\n\tMemoryContext oldcxt;\n\tint\t\t\tnatts = tupDesc->natts;\n\tint\t\t\ti;\n\tbool\t\thas_not_null;\n\tbool\t\tnailit;\n\n\tAssertArg(natts >= 0);\n\n\t/*\n\t * check for creation of a rel that must be nailed in cache.\n\t *\n\t * XXX this list had better match the relations specially handled in\n\t * RelationCacheInitializePhase2/3.\n\t */\n\tswitch (relid)\n\t{\n\t\tcase DatabaseRelationId:\n\t\tcase AuthIdRelationId:\n\t\tcase AuthMemRelationId:\n\t\tcase RelationRelationId:\n\t\tcase AttributeRelationId:\n\t\tcase ProcedureRelationId:\n\t\tcase TypeRelationId:\n\t\t\tnailit = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnailit = false;\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * check that hardwired list of shared rels matches what's in the\n\t * bootstrap .bki file.  If you get a failure here during initdb, you\n\t * probably need to fix IsSharedRelation() to match whatever you've done\n\t * to the set of shared relations.\n\t */\n\tif (shared_relation != IsSharedRelation(relid))\n\t\telog(ERROR, \"shared_relation flag for \\\"%s\\\" does not match IsSharedRelation(%u)\",\n\t\t\t relname, relid);\n\n\t/* Shared relations had better be mapped, too */\n\tAssert(mapped_relation || !shared_relation);\n\n\t/*\n\t * switch to the cache context to create the relcache entry.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCreateCacheMemoryContext();\n\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * allocate a new relation descriptor and fill in basic state fields.\n\t */\n\trel = (Relation) palloc0(sizeof(RelationData));\n\n\t/* make sure relation is marked as having no open file yet */\n\trel->rd_smgr = NULL;\n\n\t/* mark it nailed if appropriate */\n\trel->rd_isnailed = nailit;\n\n\trel->rd_refcnt = nailit ? 1 : 0;\n\n\t/* it's being created in this transaction */\n\trel->rd_createSubid = GetCurrentSubTransactionId();\n\trel->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\n\t/*\n\t * create a new tuple descriptor from the one passed in.  We do this\n\t * partly to copy it into the cache context, and partly because the new\n\t * relation can't have any defaults or constraints yet; they have to be\n\t * added in later steps, because they require additions to multiple system\n\t * catalogs.  We can copy attnotnull constraints here, however.\n\t */\n\trel->rd_att = CreateTupleDescCopy(tupDesc);\n\trel->rd_att->tdrefcount = 1;\t/* mark as refcounted */\n\thas_not_null = false;\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tForm_pg_attribute satt = TupleDescAttr(tupDesc, i);\n\t\tForm_pg_attribute datt = TupleDescAttr(rel->rd_att, i);\n\n\t\tdatt->attidentity = satt->attidentity;\n\t\tdatt->attnotnull = satt->attnotnull;\n\t\thas_not_null |= satt->attnotnull;\n\t}\n\n\tif (has_not_null)\n\t{\n\t\tTupleConstr *constr = (TupleConstr *) palloc0(sizeof(TupleConstr));\n\n\t\tconstr->has_not_null = true;\n\t\trel->rd_att->constr = constr;\n\t}\n\n\t/*\n\t * initialize relation tuple form (caller may add/override data later)\n\t */\n\trel->rd_rel = (Form_pg_class) palloc0(CLASS_TUPLE_SIZE);\n\n\tnamestrcpy(&rel->rd_rel->relname, relname);\n\trel->rd_rel->relnamespace = relnamespace;\n\n\trel->rd_rel->relkind = relkind;\n\trel->rd_rel->relhasoids = rel->rd_att->tdhasoid;\n\trel->rd_rel->relnatts = natts;\n\trel->rd_rel->reltype = InvalidOid;\n\t/* needed when bootstrapping: */\n\trel->rd_rel->relowner = BOOTSTRAP_SUPERUSERID;\n\n\t/* set up persistence and relcache fields dependent on it */\n\trel->rd_rel->relpersistence = relpersistence;\n\tswitch (relpersistence)\n\t{\n\t\tcase RELPERSISTENCE_UNLOGGED:\n\t\tcase RELPERSISTENCE_PERMANENT:\n\t\t\trel->rd_backend = InvalidBackendId;\n\t\t\trel->rd_islocaltemp = false;\n\t\t\tbreak;\n\t\tcase RELPERSISTENCE_TEMP:\n\t\t\tAssert(isTempOrTempToastNamespace(relnamespace));\n\t\t\trel->rd_backend = BackendIdForTempRelations();\n\t\t\trel->rd_islocaltemp = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid relpersistence: %c\", relpersistence);\n\t\t\tbreak;\n\t}\n\n\t/* if it's a materialized view, it's not populated initially */\n\tif (relkind == RELKIND_MATVIEW)\n\t\trel->rd_rel->relispopulated = false;\n\telse\n\t\trel->rd_rel->relispopulated = true;\n\n\t/* system relations and non-table objects don't have one */\n\tif (!IsSystemNamespace(relnamespace) &&\n\t\t(relkind == RELKIND_RELATION ||\n\t\t relkind == RELKIND_MATVIEW ||\n\t\t relkind == RELKIND_PARTITIONED_TABLE))\n\t\trel->rd_rel->relreplident = REPLICA_IDENTITY_DEFAULT;\n\telse\n\t\trel->rd_rel->relreplident = REPLICA_IDENTITY_NOTHING;\n\n\t/*\n\t * Insert relation physical and logical identifiers (OIDs) into the right\n\t * places.  For a mapped relation, we set relfilenode to zero and rely on\n\t * RelationInitPhysicalAddr to consult the map.\n\t */\n\trel->rd_rel->relisshared = shared_relation;\n\n\tRelationGetRelid(rel) = relid;\n\n\tfor (i = 0; i < natts; i++)\n\t\tTupleDescAttr(rel->rd_att, i)->attrelid = relid;\n\n\trel->rd_rel->reltablespace = reltablespace;\n\n\tif (mapped_relation)\n\t{\n\t\trel->rd_rel->relfilenode = InvalidOid;\n\t\t/* Add it to the active mapping information */\n\t\tRelationMapUpdateMap(relid, relfilenode, shared_relation, true);\n\t}\n\telse\n\t\trel->rd_rel->relfilenode = relfilenode;\n\n\tRelationInitLockInfo(rel);\t/* see lmgr.c */\n\n\tRelationInitPhysicalAddr(rel);\n\n\t/*\n\t * Okay to insert into the relcache hash table.\n\t *\n\t * Ordinarily, there should certainly not be an existing hash entry for\n\t * the same OID; but during bootstrap, when we create a \"real\" relcache\n\t * entry for one of the bootstrap relations, we'll be overwriting the\n\t * phony one created with formrdesc.  So allow that to happen for nailed\n\t * rels.\n\t */\n\tRelationCacheInsert(rel, nailit);\n\n\t/*\n\t * Flag relation as needing eoxact cleanup (to clear rd_createSubid). We\n\t * can't do this before storing relid in it.\n\t */\n\tEOXactListAdd(rel);\n\n\t/*\n\t * done building relcache entry.\n\t */\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* It's fully valid */\n\trel->rd_isvalid = true;\n\n\t/*\n\t * Caller expects us to pin the returned entry.\n\t */\n\tRelationIncrementReferenceCount(rel);\n\n\treturn rel;\n}"
  },
  {
    "function_name": "AtEOSubXact_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "3031-3088",
    "snippet": "static void\nAtEOSubXact_cleanup(Relation relation, bool isCommit,\n\t\t\t\t\tSubTransactionId mySubid, SubTransactionId parentSubid)\n{\n\t/*\n\t * Is it a relation created in the current subtransaction?\n\t *\n\t * During subcommit, mark it as belonging to the parent, instead. During\n\t * subabort, simply delete the relcache entry.\n\t */\n\tif (relation->rd_createSubid == mySubid)\n\t{\n\t\tif (isCommit)\n\t\t\trelation->rd_createSubid = parentSubid;\n\t\telse if (RelationHasReferenceCountZero(relation))\n\t\t{\n\t\t\tRelationClearRelation(relation, false);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Hmm, somewhere there's a (leaked?) reference to the relation.\n\t\t\t * We daren't remove the entry for fear of dereferencing a\n\t\t\t * dangling pointer later.  Bleat, and transfer it to the parent\n\t\t\t * subtransaction so we can try again later.  This must be just a\n\t\t\t * WARNING to avoid error-during-error-recovery loops.\n\t\t\t */\n\t\t\trelation->rd_createSubid = parentSubid;\n\t\t\telog(WARNING, \"cannot remove relcache entry for \\\"%s\\\" because it has nonzero refcount\",\n\t\t\t\t RelationGetRelationName(relation));\n\t\t}\n\t}\n\n\t/*\n\t * Likewise, update or drop any new-relfilenode-in-subtransaction hint.\n\t */\n\tif (relation->rd_newRelfilenodeSubid == mySubid)\n\t{\n\t\tif (isCommit)\n\t\t\trelation->rd_newRelfilenodeSubid = parentSubid;\n\t\telse\n\t\t\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\t}\n\n\t/*\n\t * Flush any temporary index list.\n\t */\n\tif (relation->rd_indexvalid == 2)\n\t{\n\t\tlist_free(relation->rd_indexlist);\n\t\trelation->rd_indexlist = NIL;\n\t\trelation->rd_oidindex = InvalidOid;\n\t\trelation->rd_pkindex = InvalidOid;\n\t\trelation->rd_replidindex = InvalidOid;\n\t\trelation->rd_indexvalid = 0;\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void AtEOXact_cleanup(Relation relation, bool isCommit);",
      "static void AtEOSubXact_cleanup(Relation relation, bool isCommit,\n\t\t\t\t\tSubTransactionId mySubid, SubTransactionId parentSubid);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_free",
          "args": [
            "relation->rd_indexlist"
          ],
          "line": 3081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"cannot remove relcache entry for \\\"%s\\\" because it has nonzero refcount\"",
            "RelationGetRelationName(relation)"
          ],
          "line": 3060
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "relation"
          ],
          "line": 3061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationClearRelation",
          "args": [
            "relation",
            "false"
          ],
          "line": 3047
        },
        "resolved": true,
        "details": {
          "function_name": "RelationClearRelation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2318-2553",
          "snippet": "static void\nRelationClearRelation(Relation relation, bool rebuild)\n{\n\t/*\n\t * As per notes above, a rel to be rebuilt MUST have refcnt > 0; while of\n\t * course it would be an equally bad idea to blow away one with nonzero\n\t * refcnt, since that would leave someone somewhere with a dangling\n\t * pointer.  All callers are expected to have verified that this holds.\n\t */\n\tAssert(rebuild ?\n\t\t   !RelationHasReferenceCountZero(relation) :\n\t\t   RelationHasReferenceCountZero(relation));\n\n\t/*\n\t * Make sure smgr and lower levels close the relation's files, if they\n\t * weren't closed already.  If the relation is not getting deleted, the\n\t * next smgr access should reopen the files automatically.  This ensures\n\t * that the low-level file access state is updated after, say, a vacuum\n\t * truncation.\n\t */\n\tRelationCloseSmgr(relation);\n\n\t/*\n\t * Treat nailed-in system relations separately, they always need to be\n\t * accessible, so we can't blow them away.\n\t */\n\tif (relation->rd_isnailed)\n\t{\n\t\tRelationReloadNailed(relation);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even non-system indexes should not be blown away if they are open and\n\t * have valid index support information.  This avoids problems with active\n\t * use of the index support information.  As with nailed indexes, we\n\t * re-read the pg_class row to handle possible physical relocation of the\n\t * index, and we check for pg_index updates too.\n\t */\n\tif ((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t relation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\trelation->rd_refcnt > 0 &&\n\t\trelation->rd_indexcxt != NULL)\n\t{\n\t\trelation->rd_isvalid = false;\t/* needs to be revalidated */\n\t\tif (IsTransactionState())\n\t\t\tRelationReloadIndexInfo(relation);\n\t\treturn;\n\t}\n\n\t/* Mark it invalid until we've finished rebuild */\n\trelation->rd_isvalid = false;\n\n\t/*\n\t * If we're really done with the relcache entry, blow it away. But if\n\t * someone is still using it, reconstruct the whole deal without moving\n\t * the physical RelationData record (so that the someone's pointer is\n\t * still valid).\n\t */\n\tif (!rebuild)\n\t{\n\t\t/* Remove it from the hash table */\n\t\tRelationCacheDelete(relation);\n\n\t\t/* And release storage */\n\t\tRelationDestroyRelation(relation, false);\n\t}\n\telse if (!IsTransactionState())\n\t{\n\t\t/*\n\t\t * If we're not inside a valid transaction, we can't do any catalog\n\t\t * access so it's not possible to rebuild yet.  Just exit, leaving\n\t\t * rd_isvalid = false so that the rebuild will occur when the entry is\n\t\t * next opened.\n\t\t *\n\t\t * Note: it's possible that we come here during subtransaction abort,\n\t\t * and the reason for wanting to rebuild is that the rel is open in\n\t\t * the outer transaction.  In that case it might seem unsafe to not\n\t\t * rebuild immediately, since whatever code has the rel already open\n\t\t * will keep on using the relcache entry as-is.  However, in such a\n\t\t * case the outer transaction should be holding a lock that's\n\t\t * sufficient to prevent any significant change in the rel's schema,\n\t\t * so the existing entry contents should be good enough for its\n\t\t * purposes; at worst we might be behind on statistics updates or the\n\t\t * like.  (See also CheckTableNotInUse() and its callers.)\tThese same\n\t\t * remarks also apply to the cases above where we exit without having\n\t\t * done RelationReloadIndexInfo() yet.\n\t\t */\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Our strategy for rebuilding an open relcache entry is to build a\n\t\t * new entry from scratch, swap its contents with the old entry, and\n\t\t * finally delete the new entry (along with any infrastructure swapped\n\t\t * over from the old entry).  This is to avoid trouble in case an\n\t\t * error causes us to lose control partway through.  The old entry\n\t\t * will still be marked !rd_isvalid, so we'll try to rebuild it again\n\t\t * on next access.  Meanwhile it's not any less valid than it was\n\t\t * before, so any code that might expect to continue accessing it\n\t\t * isn't hurt by the rebuild failure.  (Consider for example a\n\t\t * subtransaction that ALTERs a table and then gets canceled partway\n\t\t * through the cache entry rebuild.  The outer transaction should\n\t\t * still see the not-modified cache entry as valid.)  The worst\n\t\t * consequence of an error is leaking the necessarily-unreferenced new\n\t\t * entry, and this shouldn't happen often enough for that to be a big\n\t\t * problem.\n\t\t *\n\t\t * When rebuilding an open relcache entry, we must preserve ref count,\n\t\t * rd_createSubid/rd_newRelfilenodeSubid, and rd_toastoid state.  Also\n\t\t * attempt to preserve the pg_class entry (rd_rel), tupledesc,\n\t\t * rewrite-rule, partition key, and partition descriptor substructures\n\t\t * in place, because various places assume that these structures won't\n\t\t * move while they are working with an open relcache entry.  (Note:\n\t\t * the refcount mechanism for tupledescs might someday allow us to\n\t\t * remove this hack for the tupledesc.)\n\t\t *\n\t\t * Note that this process does not touch CurrentResourceOwner; which\n\t\t * is good because whatever ref counts the entry may have do not\n\t\t * necessarily belong to that resource owner.\n\t\t */\n\t\tRelation\tnewrel;\n\t\tOid\t\t\tsave_relid = RelationGetRelid(relation);\n\t\tbool\t\tkeep_tupdesc;\n\t\tbool\t\tkeep_rules;\n\t\tbool\t\tkeep_policies;\n\t\tbool\t\tkeep_partkey;\n\t\tbool\t\tkeep_partdesc;\n\n\t\t/* Build temporary entry, but don't link it into hashtable */\n\t\tnewrel = RelationBuildDesc(save_relid, false);\n\t\tif (newrel == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * We can validly get here, if we're using a historic snapshot in\n\t\t\t * which a relation, accessed from outside logical decoding, is\n\t\t\t * still invisible. In that case it's fine to just mark the\n\t\t\t * relation as invalid and return - it'll fully get reloaded by\n\t\t\t * the cache reset at the end of logical decoding (or at the next\n\t\t\t * access).  During normal processing we don't want to ignore this\n\t\t\t * case as it shouldn't happen there, as explained below.\n\t\t\t */\n\t\t\tif (HistoricSnapshotActive())\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * This shouldn't happen as dropping a relation is intended to be\n\t\t\t * impossible if still referenced (cf. CheckTableNotInUse()). But\n\t\t\t * if we get here anyway, we can't just delete the relcache entry,\n\t\t\t * as it possibly could get accessed later (as e.g. the error\n\t\t\t * might get trapped and handled via a subtransaction rollback).\n\t\t\t */\n\t\t\telog(ERROR, \"relation %u deleted while still in use\", save_relid);\n\t\t}\n\n\t\tkeep_tupdesc = equalTupleDescs(relation->rd_att, newrel->rd_att);\n\t\tkeep_rules = equalRuleLocks(relation->rd_rules, newrel->rd_rules);\n\t\tkeep_policies = equalRSDesc(relation->rd_rsdesc, newrel->rd_rsdesc);\n\t\t/* partkey is immutable once set up, so we can always keep it */\n\t\tkeep_partkey = (relation->rd_partkey != NULL);\n\t\tkeep_partdesc = equalPartitionDescs(relation->rd_partkey,\n\t\t\t\t\t\t\t\t\t\t\trelation->rd_partdesc,\n\t\t\t\t\t\t\t\t\t\t\tnewrel->rd_partdesc);\n\n\t\t/*\n\t\t * Perform swapping of the relcache entry contents.  Within this\n\t\t * process the old entry is momentarily invalid, so there *must* be no\n\t\t * possibility of CHECK_FOR_INTERRUPTS within this sequence. Do it in\n\t\t * all-in-line code for safety.\n\t\t *\n\t\t * Since the vast majority of fields should be swapped, our method is\n\t\t * to swap the whole structures and then re-swap those few fields we\n\t\t * didn't want swapped.\n\t\t */\n#define SWAPFIELD(fldtype, fldname) \\\n\t\tdo { \\\n\t\t\tfldtype _tmp = newrel->fldname; \\\n\t\t\tnewrel->fldname = relation->fldname; \\\n\t\t\trelation->fldname = _tmp; \\\n\t\t} while (0)\n\n\t\t/* swap all Relation struct fields */\n\t\t{\n\t\t\tRelationData tmpstruct;\n\n\t\t\tmemcpy(&tmpstruct, newrel, sizeof(RelationData));\n\t\t\tmemcpy(newrel, relation, sizeof(RelationData));\n\t\t\tmemcpy(relation, &tmpstruct, sizeof(RelationData));\n\t\t}\n\n\t\t/* rd_smgr must not be swapped, due to back-links from smgr level */\n\t\tSWAPFIELD(SMgrRelation, rd_smgr);\n\t\t/* rd_refcnt must be preserved */\n\t\tSWAPFIELD(int, rd_refcnt);\n\t\t/* isnailed shouldn't change */\n\t\tAssert(newrel->rd_isnailed == relation->rd_isnailed);\n\t\t/* creation sub-XIDs must be preserved */\n\t\tSWAPFIELD(SubTransactionId, rd_createSubid);\n\t\tSWAPFIELD(SubTransactionId, rd_newRelfilenodeSubid);\n\t\t/* un-swap rd_rel pointers, swap contents instead */\n\t\tSWAPFIELD(Form_pg_class, rd_rel);\n\t\t/* ... but actually, we don't have to update newrel->rd_rel */\n\t\tmemcpy(relation->rd_rel, newrel->rd_rel, CLASS_TUPLE_SIZE);\n\t\t/* preserve old tupledesc, rules, policies if no logical change */\n\t\tif (keep_tupdesc)\n\t\t\tSWAPFIELD(TupleDesc, rd_att);\n\t\tif (keep_rules)\n\t\t{\n\t\t\tSWAPFIELD(RuleLock *, rd_rules);\n\t\t\tSWAPFIELD(MemoryContext, rd_rulescxt);\n\t\t}\n\t\tif (keep_policies)\n\t\t\tSWAPFIELD(RowSecurityDesc *, rd_rsdesc);\n\t\t/* toast OID override must be preserved */\n\t\tSWAPFIELD(Oid, rd_toastoid);\n\t\t/* pgstat_info must be preserved */\n\t\tSWAPFIELD(struct PgStat_TableStatus *, pgstat_info);\n\t\t/* preserve old partitioning info if no logical change */\n\t\tif (keep_partkey)\n\t\t{\n\t\t\tSWAPFIELD(PartitionKey, rd_partkey);\n\t\t\tSWAPFIELD(MemoryContext, rd_partkeycxt);\n\t\t}\n\t\tif (keep_partdesc)\n\t\t{\n\t\t\tSWAPFIELD(PartitionDesc, rd_partdesc);\n\t\t\tSWAPFIELD(MemoryContext, rd_pdcxt);\n\t\t}\n\n#undef SWAPFIELD\n\n\t\t/* And now we can throw away the temporary entry */\n\t\tRelationDestroyRelation(newrel, !keep_tupdesc);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationClearRelation(Relation relation, bool rebuild);",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationClearRelation(Relation relation, bool rebuild);\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationClearRelation(Relation relation, bool rebuild)\n{\n\t/*\n\t * As per notes above, a rel to be rebuilt MUST have refcnt > 0; while of\n\t * course it would be an equally bad idea to blow away one with nonzero\n\t * refcnt, since that would leave someone somewhere with a dangling\n\t * pointer.  All callers are expected to have verified that this holds.\n\t */\n\tAssert(rebuild ?\n\t\t   !RelationHasReferenceCountZero(relation) :\n\t\t   RelationHasReferenceCountZero(relation));\n\n\t/*\n\t * Make sure smgr and lower levels close the relation's files, if they\n\t * weren't closed already.  If the relation is not getting deleted, the\n\t * next smgr access should reopen the files automatically.  This ensures\n\t * that the low-level file access state is updated after, say, a vacuum\n\t * truncation.\n\t */\n\tRelationCloseSmgr(relation);\n\n\t/*\n\t * Treat nailed-in system relations separately, they always need to be\n\t * accessible, so we can't blow them away.\n\t */\n\tif (relation->rd_isnailed)\n\t{\n\t\tRelationReloadNailed(relation);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even non-system indexes should not be blown away if they are open and\n\t * have valid index support information.  This avoids problems with active\n\t * use of the index support information.  As with nailed indexes, we\n\t * re-read the pg_class row to handle possible physical relocation of the\n\t * index, and we check for pg_index updates too.\n\t */\n\tif ((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t relation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\trelation->rd_refcnt > 0 &&\n\t\trelation->rd_indexcxt != NULL)\n\t{\n\t\trelation->rd_isvalid = false;\t/* needs to be revalidated */\n\t\tif (IsTransactionState())\n\t\t\tRelationReloadIndexInfo(relation);\n\t\treturn;\n\t}\n\n\t/* Mark it invalid until we've finished rebuild */\n\trelation->rd_isvalid = false;\n\n\t/*\n\t * If we're really done with the relcache entry, blow it away. But if\n\t * someone is still using it, reconstruct the whole deal without moving\n\t * the physical RelationData record (so that the someone's pointer is\n\t * still valid).\n\t */\n\tif (!rebuild)\n\t{\n\t\t/* Remove it from the hash table */\n\t\tRelationCacheDelete(relation);\n\n\t\t/* And release storage */\n\t\tRelationDestroyRelation(relation, false);\n\t}\n\telse if (!IsTransactionState())\n\t{\n\t\t/*\n\t\t * If we're not inside a valid transaction, we can't do any catalog\n\t\t * access so it's not possible to rebuild yet.  Just exit, leaving\n\t\t * rd_isvalid = false so that the rebuild will occur when the entry is\n\t\t * next opened.\n\t\t *\n\t\t * Note: it's possible that we come here during subtransaction abort,\n\t\t * and the reason for wanting to rebuild is that the rel is open in\n\t\t * the outer transaction.  In that case it might seem unsafe to not\n\t\t * rebuild immediately, since whatever code has the rel already open\n\t\t * will keep on using the relcache entry as-is.  However, in such a\n\t\t * case the outer transaction should be holding a lock that's\n\t\t * sufficient to prevent any significant change in the rel's schema,\n\t\t * so the existing entry contents should be good enough for its\n\t\t * purposes; at worst we might be behind on statistics updates or the\n\t\t * like.  (See also CheckTableNotInUse() and its callers.)\tThese same\n\t\t * remarks also apply to the cases above where we exit without having\n\t\t * done RelationReloadIndexInfo() yet.\n\t\t */\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Our strategy for rebuilding an open relcache entry is to build a\n\t\t * new entry from scratch, swap its contents with the old entry, and\n\t\t * finally delete the new entry (along with any infrastructure swapped\n\t\t * over from the old entry).  This is to avoid trouble in case an\n\t\t * error causes us to lose control partway through.  The old entry\n\t\t * will still be marked !rd_isvalid, so we'll try to rebuild it again\n\t\t * on next access.  Meanwhile it's not any less valid than it was\n\t\t * before, so any code that might expect to continue accessing it\n\t\t * isn't hurt by the rebuild failure.  (Consider for example a\n\t\t * subtransaction that ALTERs a table and then gets canceled partway\n\t\t * through the cache entry rebuild.  The outer transaction should\n\t\t * still see the not-modified cache entry as valid.)  The worst\n\t\t * consequence of an error is leaking the necessarily-unreferenced new\n\t\t * entry, and this shouldn't happen often enough for that to be a big\n\t\t * problem.\n\t\t *\n\t\t * When rebuilding an open relcache entry, we must preserve ref count,\n\t\t * rd_createSubid/rd_newRelfilenodeSubid, and rd_toastoid state.  Also\n\t\t * attempt to preserve the pg_class entry (rd_rel), tupledesc,\n\t\t * rewrite-rule, partition key, and partition descriptor substructures\n\t\t * in place, because various places assume that these structures won't\n\t\t * move while they are working with an open relcache entry.  (Note:\n\t\t * the refcount mechanism for tupledescs might someday allow us to\n\t\t * remove this hack for the tupledesc.)\n\t\t *\n\t\t * Note that this process does not touch CurrentResourceOwner; which\n\t\t * is good because whatever ref counts the entry may have do not\n\t\t * necessarily belong to that resource owner.\n\t\t */\n\t\tRelation\tnewrel;\n\t\tOid\t\t\tsave_relid = RelationGetRelid(relation);\n\t\tbool\t\tkeep_tupdesc;\n\t\tbool\t\tkeep_rules;\n\t\tbool\t\tkeep_policies;\n\t\tbool\t\tkeep_partkey;\n\t\tbool\t\tkeep_partdesc;\n\n\t\t/* Build temporary entry, but don't link it into hashtable */\n\t\tnewrel = RelationBuildDesc(save_relid, false);\n\t\tif (newrel == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * We can validly get here, if we're using a historic snapshot in\n\t\t\t * which a relation, accessed from outside logical decoding, is\n\t\t\t * still invisible. In that case it's fine to just mark the\n\t\t\t * relation as invalid and return - it'll fully get reloaded by\n\t\t\t * the cache reset at the end of logical decoding (or at the next\n\t\t\t * access).  During normal processing we don't want to ignore this\n\t\t\t * case as it shouldn't happen there, as explained below.\n\t\t\t */\n\t\t\tif (HistoricSnapshotActive())\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * This shouldn't happen as dropping a relation is intended to be\n\t\t\t * impossible if still referenced (cf. CheckTableNotInUse()). But\n\t\t\t * if we get here anyway, we can't just delete the relcache entry,\n\t\t\t * as it possibly could get accessed later (as e.g. the error\n\t\t\t * might get trapped and handled via a subtransaction rollback).\n\t\t\t */\n\t\t\telog(ERROR, \"relation %u deleted while still in use\", save_relid);\n\t\t}\n\n\t\tkeep_tupdesc = equalTupleDescs(relation->rd_att, newrel->rd_att);\n\t\tkeep_rules = equalRuleLocks(relation->rd_rules, newrel->rd_rules);\n\t\tkeep_policies = equalRSDesc(relation->rd_rsdesc, newrel->rd_rsdesc);\n\t\t/* partkey is immutable once set up, so we can always keep it */\n\t\tkeep_partkey = (relation->rd_partkey != NULL);\n\t\tkeep_partdesc = equalPartitionDescs(relation->rd_partkey,\n\t\t\t\t\t\t\t\t\t\t\trelation->rd_partdesc,\n\t\t\t\t\t\t\t\t\t\t\tnewrel->rd_partdesc);\n\n\t\t/*\n\t\t * Perform swapping of the relcache entry contents.  Within this\n\t\t * process the old entry is momentarily invalid, so there *must* be no\n\t\t * possibility of CHECK_FOR_INTERRUPTS within this sequence. Do it in\n\t\t * all-in-line code for safety.\n\t\t *\n\t\t * Since the vast majority of fields should be swapped, our method is\n\t\t * to swap the whole structures and then re-swap those few fields we\n\t\t * didn't want swapped.\n\t\t */\n#define SWAPFIELD(fldtype, fldname) \\\n\t\tdo { \\\n\t\t\tfldtype _tmp = newrel->fldname; \\\n\t\t\tnewrel->fldname = relation->fldname; \\\n\t\t\trelation->fldname = _tmp; \\\n\t\t} while (0)\n\n\t\t/* swap all Relation struct fields */\n\t\t{\n\t\t\tRelationData tmpstruct;\n\n\t\t\tmemcpy(&tmpstruct, newrel, sizeof(RelationData));\n\t\t\tmemcpy(newrel, relation, sizeof(RelationData));\n\t\t\tmemcpy(relation, &tmpstruct, sizeof(RelationData));\n\t\t}\n\n\t\t/* rd_smgr must not be swapped, due to back-links from smgr level */\n\t\tSWAPFIELD(SMgrRelation, rd_smgr);\n\t\t/* rd_refcnt must be preserved */\n\t\tSWAPFIELD(int, rd_refcnt);\n\t\t/* isnailed shouldn't change */\n\t\tAssert(newrel->rd_isnailed == relation->rd_isnailed);\n\t\t/* creation sub-XIDs must be preserved */\n\t\tSWAPFIELD(SubTransactionId, rd_createSubid);\n\t\tSWAPFIELD(SubTransactionId, rd_newRelfilenodeSubid);\n\t\t/* un-swap rd_rel pointers, swap contents instead */\n\t\tSWAPFIELD(Form_pg_class, rd_rel);\n\t\t/* ... but actually, we don't have to update newrel->rd_rel */\n\t\tmemcpy(relation->rd_rel, newrel->rd_rel, CLASS_TUPLE_SIZE);\n\t\t/* preserve old tupledesc, rules, policies if no logical change */\n\t\tif (keep_tupdesc)\n\t\t\tSWAPFIELD(TupleDesc, rd_att);\n\t\tif (keep_rules)\n\t\t{\n\t\t\tSWAPFIELD(RuleLock *, rd_rules);\n\t\t\tSWAPFIELD(MemoryContext, rd_rulescxt);\n\t\t}\n\t\tif (keep_policies)\n\t\t\tSWAPFIELD(RowSecurityDesc *, rd_rsdesc);\n\t\t/* toast OID override must be preserved */\n\t\tSWAPFIELD(Oid, rd_toastoid);\n\t\t/* pgstat_info must be preserved */\n\t\tSWAPFIELD(struct PgStat_TableStatus *, pgstat_info);\n\t\t/* preserve old partitioning info if no logical change */\n\t\tif (keep_partkey)\n\t\t{\n\t\t\tSWAPFIELD(PartitionKey, rd_partkey);\n\t\t\tSWAPFIELD(MemoryContext, rd_partkeycxt);\n\t\t}\n\t\tif (keep_partdesc)\n\t\t{\n\t\t\tSWAPFIELD(PartitionDesc, rd_partdesc);\n\t\t\tSWAPFIELD(MemoryContext, rd_pdcxt);\n\t\t}\n\n#undef SWAPFIELD\n\n\t\t/* And now we can throw away the temporary entry */\n\t\tRelationDestroyRelation(newrel, !keep_tupdesc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationHasReferenceCountZero",
          "args": [
            "relation"
          ],
          "line": 3045
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void AtEOXact_cleanup(Relation relation, bool isCommit);\nstatic void AtEOSubXact_cleanup(Relation relation, bool isCommit,\n\t\t\t\t\tSubTransactionId mySubid, SubTransactionId parentSubid);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nAtEOSubXact_cleanup(Relation relation, bool isCommit,\n\t\t\t\t\tSubTransactionId mySubid, SubTransactionId parentSubid)\n{\n\t/*\n\t * Is it a relation created in the current subtransaction?\n\t *\n\t * During subcommit, mark it as belonging to the parent, instead. During\n\t * subabort, simply delete the relcache entry.\n\t */\n\tif (relation->rd_createSubid == mySubid)\n\t{\n\t\tif (isCommit)\n\t\t\trelation->rd_createSubid = parentSubid;\n\t\telse if (RelationHasReferenceCountZero(relation))\n\t\t{\n\t\t\tRelationClearRelation(relation, false);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Hmm, somewhere there's a (leaked?) reference to the relation.\n\t\t\t * We daren't remove the entry for fear of dereferencing a\n\t\t\t * dangling pointer later.  Bleat, and transfer it to the parent\n\t\t\t * subtransaction so we can try again later.  This must be just a\n\t\t\t * WARNING to avoid error-during-error-recovery loops.\n\t\t\t */\n\t\t\trelation->rd_createSubid = parentSubid;\n\t\t\telog(WARNING, \"cannot remove relcache entry for \\\"%s\\\" because it has nonzero refcount\",\n\t\t\t\t RelationGetRelationName(relation));\n\t\t}\n\t}\n\n\t/*\n\t * Likewise, update or drop any new-relfilenode-in-subtransaction hint.\n\t */\n\tif (relation->rd_newRelfilenodeSubid == mySubid)\n\t{\n\t\tif (isCommit)\n\t\t\trelation->rd_newRelfilenodeSubid = parentSubid;\n\t\telse\n\t\t\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\t}\n\n\t/*\n\t * Flush any temporary index list.\n\t */\n\tif (relation->rd_indexvalid == 2)\n\t{\n\t\tlist_free(relation->rd_indexlist);\n\t\trelation->rd_indexlist = NIL;\n\t\trelation->rd_oidindex = InvalidOid;\n\t\trelation->rd_pkindex = InvalidOid;\n\t\trelation->rd_replidindex = InvalidOid;\n\t\trelation->rd_indexvalid = 0;\n\t}\n}"
  },
  {
    "function_name": "AtEOSubXact_RelationCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "2984-3021",
    "snippet": "void\nAtEOSubXact_RelationCache(bool isCommit, SubTransactionId mySubid,\n\t\t\t\t\t\t  SubTransactionId parentSubid)\n{\n\tHASH_SEQ_STATUS status;\n\tRelIdCacheEnt *idhentry;\n\tint\t\t\ti;\n\n\t/*\n\t * Unless the eoxact_list[] overflowed, we only need to examine the rels\n\t * listed in it.  Otherwise fall back on a hash_seq_search scan.  Same\n\t * logic as in AtEOXact_RelationCache.\n\t */\n\tif (eoxact_list_overflowed)\n\t{\n\t\thash_seq_init(&status, RelationIdCache);\n\t\twhile ((idhentry = (RelIdCacheEnt *) hash_seq_search(&status)) != NULL)\n\t\t{\n\t\t\tAtEOSubXact_cleanup(idhentry->reldesc, isCommit,\n\t\t\t\t\t\t\t\tmySubid, parentSubid);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < eoxact_list_len; i++)\n\t\t{\n\t\t\tidhentry = (RelIdCacheEnt *) hash_search(RelationIdCache,\n\t\t\t\t\t\t\t\t\t\t\t\t\t (void *) &eoxact_list[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t HASH_FIND,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NULL);\n\t\t\tif (idhentry != NULL)\n\t\t\t\tAtEOSubXact_cleanup(idhentry->reldesc, isCommit,\n\t\t\t\t\t\t\t\t\tmySubid, parentSubid);\n\t\t}\n\t}\n\n\t/* Don't reset the list; we still need more cleanup later */\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *RelationIdCache;",
      "static Oid\teoxact_list[MAX_EOXACT_LIST];",
      "static int\teoxact_list_len = 0;",
      "static bool eoxact_list_overflowed = false;",
      "static void AtEOXact_cleanup(Relation relation, bool isCommit);",
      "static void AtEOSubXact_cleanup(Relation relation, bool isCommit,\n\t\t\t\t\tSubTransactionId mySubid, SubTransactionId parentSubid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AtEOSubXact_cleanup",
          "args": [
            "idhentry->reldesc",
            "isCommit",
            "mySubid",
            "parentSubid"
          ],
          "line": 3015
        },
        "resolved": true,
        "details": {
          "function_name": "AtEOSubXact_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "3031-3088",
          "snippet": "static void\nAtEOSubXact_cleanup(Relation relation, bool isCommit,\n\t\t\t\t\tSubTransactionId mySubid, SubTransactionId parentSubid)\n{\n\t/*\n\t * Is it a relation created in the current subtransaction?\n\t *\n\t * During subcommit, mark it as belonging to the parent, instead. During\n\t * subabort, simply delete the relcache entry.\n\t */\n\tif (relation->rd_createSubid == mySubid)\n\t{\n\t\tif (isCommit)\n\t\t\trelation->rd_createSubid = parentSubid;\n\t\telse if (RelationHasReferenceCountZero(relation))\n\t\t{\n\t\t\tRelationClearRelation(relation, false);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Hmm, somewhere there's a (leaked?) reference to the relation.\n\t\t\t * We daren't remove the entry for fear of dereferencing a\n\t\t\t * dangling pointer later.  Bleat, and transfer it to the parent\n\t\t\t * subtransaction so we can try again later.  This must be just a\n\t\t\t * WARNING to avoid error-during-error-recovery loops.\n\t\t\t */\n\t\t\trelation->rd_createSubid = parentSubid;\n\t\t\telog(WARNING, \"cannot remove relcache entry for \\\"%s\\\" because it has nonzero refcount\",\n\t\t\t\t RelationGetRelationName(relation));\n\t\t}\n\t}\n\n\t/*\n\t * Likewise, update or drop any new-relfilenode-in-subtransaction hint.\n\t */\n\tif (relation->rd_newRelfilenodeSubid == mySubid)\n\t{\n\t\tif (isCommit)\n\t\t\trelation->rd_newRelfilenodeSubid = parentSubid;\n\t\telse\n\t\t\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\t}\n\n\t/*\n\t * Flush any temporary index list.\n\t */\n\tif (relation->rd_indexvalid == 2)\n\t{\n\t\tlist_free(relation->rd_indexlist);\n\t\trelation->rd_indexlist = NIL;\n\t\trelation->rd_oidindex = InvalidOid;\n\t\trelation->rd_pkindex = InvalidOid;\n\t\trelation->rd_replidindex = InvalidOid;\n\t\trelation->rd_indexvalid = 0;\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void AtEOXact_cleanup(Relation relation, bool isCommit);",
            "static void AtEOSubXact_cleanup(Relation relation, bool isCommit,\n\t\t\t\t\tSubTransactionId mySubid, SubTransactionId parentSubid);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void AtEOXact_cleanup(Relation relation, bool isCommit);\nstatic void AtEOSubXact_cleanup(Relation relation, bool isCommit,\n\t\t\t\t\tSubTransactionId mySubid, SubTransactionId parentSubid);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nAtEOSubXact_cleanup(Relation relation, bool isCommit,\n\t\t\t\t\tSubTransactionId mySubid, SubTransactionId parentSubid)\n{\n\t/*\n\t * Is it a relation created in the current subtransaction?\n\t *\n\t * During subcommit, mark it as belonging to the parent, instead. During\n\t * subabort, simply delete the relcache entry.\n\t */\n\tif (relation->rd_createSubid == mySubid)\n\t{\n\t\tif (isCommit)\n\t\t\trelation->rd_createSubid = parentSubid;\n\t\telse if (RelationHasReferenceCountZero(relation))\n\t\t{\n\t\t\tRelationClearRelation(relation, false);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Hmm, somewhere there's a (leaked?) reference to the relation.\n\t\t\t * We daren't remove the entry for fear of dereferencing a\n\t\t\t * dangling pointer later.  Bleat, and transfer it to the parent\n\t\t\t * subtransaction so we can try again later.  This must be just a\n\t\t\t * WARNING to avoid error-during-error-recovery loops.\n\t\t\t */\n\t\t\trelation->rd_createSubid = parentSubid;\n\t\t\telog(WARNING, \"cannot remove relcache entry for \\\"%s\\\" because it has nonzero refcount\",\n\t\t\t\t RelationGetRelationName(relation));\n\t\t}\n\t}\n\n\t/*\n\t * Likewise, update or drop any new-relfilenode-in-subtransaction hint.\n\t */\n\tif (relation->rd_newRelfilenodeSubid == mySubid)\n\t{\n\t\tif (isCommit)\n\t\t\trelation->rd_newRelfilenodeSubid = parentSubid;\n\t\telse\n\t\t\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\t}\n\n\t/*\n\t * Flush any temporary index list.\n\t */\n\tif (relation->rd_indexvalid == 2)\n\t{\n\t\tlist_free(relation->rd_indexlist);\n\t\trelation->rd_indexlist = NIL;\n\t\trelation->rd_oidindex = InvalidOid;\n\t\trelation->rd_pkindex = InvalidOid;\n\t\trelation->rd_replidindex = InvalidOid;\n\t\trelation->rd_indexvalid = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "RelationIdCache",
            "(void *) &eoxact_list[i]",
            "HASH_FIND",
            "NULL"
          ],
          "line": 3010
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_search",
          "args": [
            "&status"
          ],
          "line": 3000
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1388-1462",
          "snippet": "void *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_init",
          "args": [
            "&status",
            "RelationIdCache"
          ],
          "line": 2999
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1378-1386",
          "snippet": "void\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic HTAB *RelationIdCache;\nstatic Oid\teoxact_list[MAX_EOXACT_LIST];\nstatic int\teoxact_list_len = 0;\nstatic bool eoxact_list_overflowed = false;\nstatic void AtEOXact_cleanup(Relation relation, bool isCommit);\nstatic void AtEOSubXact_cleanup(Relation relation, bool isCommit,\n\t\t\t\t\tSubTransactionId mySubid, SubTransactionId parentSubid);\n\nvoid\nAtEOSubXact_RelationCache(bool isCommit, SubTransactionId mySubid,\n\t\t\t\t\t\t  SubTransactionId parentSubid)\n{\n\tHASH_SEQ_STATUS status;\n\tRelIdCacheEnt *idhentry;\n\tint\t\t\ti;\n\n\t/*\n\t * Unless the eoxact_list[] overflowed, we only need to examine the rels\n\t * listed in it.  Otherwise fall back on a hash_seq_search scan.  Same\n\t * logic as in AtEOXact_RelationCache.\n\t */\n\tif (eoxact_list_overflowed)\n\t{\n\t\thash_seq_init(&status, RelationIdCache);\n\t\twhile ((idhentry = (RelIdCacheEnt *) hash_seq_search(&status)) != NULL)\n\t\t{\n\t\t\tAtEOSubXact_cleanup(idhentry->reldesc, isCommit,\n\t\t\t\t\t\t\t\tmySubid, parentSubid);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < eoxact_list_len; i++)\n\t\t{\n\t\t\tidhentry = (RelIdCacheEnt *) hash_search(RelationIdCache,\n\t\t\t\t\t\t\t\t\t\t\t\t\t (void *) &eoxact_list[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t HASH_FIND,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NULL);\n\t\t\tif (idhentry != NULL)\n\t\t\t\tAtEOSubXact_cleanup(idhentry->reldesc, isCommit,\n\t\t\t\t\t\t\t\t\tmySubid, parentSubid);\n\t\t}\n\t}\n\n\t/* Don't reset the list; we still need more cleanup later */\n}"
  },
  {
    "function_name": "AtEOXact_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "2896-2975",
    "snippet": "static void\nAtEOXact_cleanup(Relation relation, bool isCommit)\n{\n\t/*\n\t * The relcache entry's ref count should be back to its normal\n\t * not-in-a-transaction state: 0 unless it's nailed in cache.\n\t *\n\t * In bootstrap mode, this is NOT true, so don't check it --- the\n\t * bootstrap code expects relations to stay open across start/commit\n\t * transaction calls.  (That seems bogus, but it's not worth fixing.)\n\t *\n\t * Note: ideally this check would be applied to every relcache entry, not\n\t * just those that have eoxact work to do.  But it's not worth forcing a\n\t * scan of the whole relcache just for this.  (Moreover, doing so would\n\t * mean that assert-enabled testing never tests the hash_search code path\n\t * above, which seems a bad idea.)\n\t */\n#ifdef USE_ASSERT_CHECKING\n\tif (!IsBootstrapProcessingMode())\n\t{\n\t\tint\t\t\texpected_refcnt;\n\n\t\texpected_refcnt = relation->rd_isnailed ? 1 : 0;\n\t\tAssert(relation->rd_refcnt == expected_refcnt);\n\t}\n#endif\n\n\t/*\n\t * Is it a relation created in the current transaction?\n\t *\n\t * During commit, reset the flag to zero, since we are now out of the\n\t * creating transaction.  During abort, simply delete the relcache entry\n\t * --- it isn't interesting any longer.  (NOTE: if we have forgotten the\n\t * new-ness of a new relation due to a forced cache flush, the entry will\n\t * get deleted anyway by shared-cache-inval processing of the aborted\n\t * pg_class insertion.)\n\t */\n\tif (relation->rd_createSubid != InvalidSubTransactionId)\n\t{\n\t\tif (isCommit)\n\t\t\trelation->rd_createSubid = InvalidSubTransactionId;\n\t\telse if (RelationHasReferenceCountZero(relation))\n\t\t{\n\t\t\tRelationClearRelation(relation, false);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Hmm, somewhere there's a (leaked?) reference to the relation.\n\t\t\t * We daren't remove the entry for fear of dereferencing a\n\t\t\t * dangling pointer later.  Bleat, and mark it as not belonging to\n\t\t\t * the current transaction.  Hopefully it'll get cleaned up\n\t\t\t * eventually.  This must be just a WARNING to avoid\n\t\t\t * error-during-error-recovery loops.\n\t\t\t */\n\t\t\trelation->rd_createSubid = InvalidSubTransactionId;\n\t\t\telog(WARNING, \"cannot remove relcache entry for \\\"%s\\\" because it has nonzero refcount\",\n\t\t\t\t RelationGetRelationName(relation));\n\t\t}\n\t}\n\n\t/*\n\t * Likewise, reset the hint about the relfilenode being new.\n\t */\n\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\n\t/*\n\t * Flush any temporary index list.\n\t */\n\tif (relation->rd_indexvalid == 2)\n\t{\n\t\tlist_free(relation->rd_indexlist);\n\t\trelation->rd_indexlist = NIL;\n\t\trelation->rd_oidindex = InvalidOid;\n\t\trelation->rd_pkindex = InvalidOid;\n\t\trelation->rd_replidindex = InvalidOid;\n\t\trelation->rd_indexvalid = 0;\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void AtEOXact_cleanup(Relation relation, bool isCommit);",
      "static bool load_relcache_init_file(bool shared);",
      "static void write_relcache_init_file(bool shared);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_free",
          "args": [
            "relation->rd_indexlist"
          ],
          "line": 2968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "WARNING",
            "\"cannot remove relcache entry for \\\"%s\\\" because it has nonzero refcount\"",
            "RelationGetRelationName(relation)"
          ],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "relation"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationClearRelation",
          "args": [
            "relation",
            "false"
          ],
          "line": 2939
        },
        "resolved": true,
        "details": {
          "function_name": "RelationClearRelation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2318-2553",
          "snippet": "static void\nRelationClearRelation(Relation relation, bool rebuild)\n{\n\t/*\n\t * As per notes above, a rel to be rebuilt MUST have refcnt > 0; while of\n\t * course it would be an equally bad idea to blow away one with nonzero\n\t * refcnt, since that would leave someone somewhere with a dangling\n\t * pointer.  All callers are expected to have verified that this holds.\n\t */\n\tAssert(rebuild ?\n\t\t   !RelationHasReferenceCountZero(relation) :\n\t\t   RelationHasReferenceCountZero(relation));\n\n\t/*\n\t * Make sure smgr and lower levels close the relation's files, if they\n\t * weren't closed already.  If the relation is not getting deleted, the\n\t * next smgr access should reopen the files automatically.  This ensures\n\t * that the low-level file access state is updated after, say, a vacuum\n\t * truncation.\n\t */\n\tRelationCloseSmgr(relation);\n\n\t/*\n\t * Treat nailed-in system relations separately, they always need to be\n\t * accessible, so we can't blow them away.\n\t */\n\tif (relation->rd_isnailed)\n\t{\n\t\tRelationReloadNailed(relation);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even non-system indexes should not be blown away if they are open and\n\t * have valid index support information.  This avoids problems with active\n\t * use of the index support information.  As with nailed indexes, we\n\t * re-read the pg_class row to handle possible physical relocation of the\n\t * index, and we check for pg_index updates too.\n\t */\n\tif ((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t relation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\trelation->rd_refcnt > 0 &&\n\t\trelation->rd_indexcxt != NULL)\n\t{\n\t\trelation->rd_isvalid = false;\t/* needs to be revalidated */\n\t\tif (IsTransactionState())\n\t\t\tRelationReloadIndexInfo(relation);\n\t\treturn;\n\t}\n\n\t/* Mark it invalid until we've finished rebuild */\n\trelation->rd_isvalid = false;\n\n\t/*\n\t * If we're really done with the relcache entry, blow it away. But if\n\t * someone is still using it, reconstruct the whole deal without moving\n\t * the physical RelationData record (so that the someone's pointer is\n\t * still valid).\n\t */\n\tif (!rebuild)\n\t{\n\t\t/* Remove it from the hash table */\n\t\tRelationCacheDelete(relation);\n\n\t\t/* And release storage */\n\t\tRelationDestroyRelation(relation, false);\n\t}\n\telse if (!IsTransactionState())\n\t{\n\t\t/*\n\t\t * If we're not inside a valid transaction, we can't do any catalog\n\t\t * access so it's not possible to rebuild yet.  Just exit, leaving\n\t\t * rd_isvalid = false so that the rebuild will occur when the entry is\n\t\t * next opened.\n\t\t *\n\t\t * Note: it's possible that we come here during subtransaction abort,\n\t\t * and the reason for wanting to rebuild is that the rel is open in\n\t\t * the outer transaction.  In that case it might seem unsafe to not\n\t\t * rebuild immediately, since whatever code has the rel already open\n\t\t * will keep on using the relcache entry as-is.  However, in such a\n\t\t * case the outer transaction should be holding a lock that's\n\t\t * sufficient to prevent any significant change in the rel's schema,\n\t\t * so the existing entry contents should be good enough for its\n\t\t * purposes; at worst we might be behind on statistics updates or the\n\t\t * like.  (See also CheckTableNotInUse() and its callers.)\tThese same\n\t\t * remarks also apply to the cases above where we exit without having\n\t\t * done RelationReloadIndexInfo() yet.\n\t\t */\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Our strategy for rebuilding an open relcache entry is to build a\n\t\t * new entry from scratch, swap its contents with the old entry, and\n\t\t * finally delete the new entry (along with any infrastructure swapped\n\t\t * over from the old entry).  This is to avoid trouble in case an\n\t\t * error causes us to lose control partway through.  The old entry\n\t\t * will still be marked !rd_isvalid, so we'll try to rebuild it again\n\t\t * on next access.  Meanwhile it's not any less valid than it was\n\t\t * before, so any code that might expect to continue accessing it\n\t\t * isn't hurt by the rebuild failure.  (Consider for example a\n\t\t * subtransaction that ALTERs a table and then gets canceled partway\n\t\t * through the cache entry rebuild.  The outer transaction should\n\t\t * still see the not-modified cache entry as valid.)  The worst\n\t\t * consequence of an error is leaking the necessarily-unreferenced new\n\t\t * entry, and this shouldn't happen often enough for that to be a big\n\t\t * problem.\n\t\t *\n\t\t * When rebuilding an open relcache entry, we must preserve ref count,\n\t\t * rd_createSubid/rd_newRelfilenodeSubid, and rd_toastoid state.  Also\n\t\t * attempt to preserve the pg_class entry (rd_rel), tupledesc,\n\t\t * rewrite-rule, partition key, and partition descriptor substructures\n\t\t * in place, because various places assume that these structures won't\n\t\t * move while they are working with an open relcache entry.  (Note:\n\t\t * the refcount mechanism for tupledescs might someday allow us to\n\t\t * remove this hack for the tupledesc.)\n\t\t *\n\t\t * Note that this process does not touch CurrentResourceOwner; which\n\t\t * is good because whatever ref counts the entry may have do not\n\t\t * necessarily belong to that resource owner.\n\t\t */\n\t\tRelation\tnewrel;\n\t\tOid\t\t\tsave_relid = RelationGetRelid(relation);\n\t\tbool\t\tkeep_tupdesc;\n\t\tbool\t\tkeep_rules;\n\t\tbool\t\tkeep_policies;\n\t\tbool\t\tkeep_partkey;\n\t\tbool\t\tkeep_partdesc;\n\n\t\t/* Build temporary entry, but don't link it into hashtable */\n\t\tnewrel = RelationBuildDesc(save_relid, false);\n\t\tif (newrel == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * We can validly get here, if we're using a historic snapshot in\n\t\t\t * which a relation, accessed from outside logical decoding, is\n\t\t\t * still invisible. In that case it's fine to just mark the\n\t\t\t * relation as invalid and return - it'll fully get reloaded by\n\t\t\t * the cache reset at the end of logical decoding (or at the next\n\t\t\t * access).  During normal processing we don't want to ignore this\n\t\t\t * case as it shouldn't happen there, as explained below.\n\t\t\t */\n\t\t\tif (HistoricSnapshotActive())\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * This shouldn't happen as dropping a relation is intended to be\n\t\t\t * impossible if still referenced (cf. CheckTableNotInUse()). But\n\t\t\t * if we get here anyway, we can't just delete the relcache entry,\n\t\t\t * as it possibly could get accessed later (as e.g. the error\n\t\t\t * might get trapped and handled via a subtransaction rollback).\n\t\t\t */\n\t\t\telog(ERROR, \"relation %u deleted while still in use\", save_relid);\n\t\t}\n\n\t\tkeep_tupdesc = equalTupleDescs(relation->rd_att, newrel->rd_att);\n\t\tkeep_rules = equalRuleLocks(relation->rd_rules, newrel->rd_rules);\n\t\tkeep_policies = equalRSDesc(relation->rd_rsdesc, newrel->rd_rsdesc);\n\t\t/* partkey is immutable once set up, so we can always keep it */\n\t\tkeep_partkey = (relation->rd_partkey != NULL);\n\t\tkeep_partdesc = equalPartitionDescs(relation->rd_partkey,\n\t\t\t\t\t\t\t\t\t\t\trelation->rd_partdesc,\n\t\t\t\t\t\t\t\t\t\t\tnewrel->rd_partdesc);\n\n\t\t/*\n\t\t * Perform swapping of the relcache entry contents.  Within this\n\t\t * process the old entry is momentarily invalid, so there *must* be no\n\t\t * possibility of CHECK_FOR_INTERRUPTS within this sequence. Do it in\n\t\t * all-in-line code for safety.\n\t\t *\n\t\t * Since the vast majority of fields should be swapped, our method is\n\t\t * to swap the whole structures and then re-swap those few fields we\n\t\t * didn't want swapped.\n\t\t */\n#define SWAPFIELD(fldtype, fldname) \\\n\t\tdo { \\\n\t\t\tfldtype _tmp = newrel->fldname; \\\n\t\t\tnewrel->fldname = relation->fldname; \\\n\t\t\trelation->fldname = _tmp; \\\n\t\t} while (0)\n\n\t\t/* swap all Relation struct fields */\n\t\t{\n\t\t\tRelationData tmpstruct;\n\n\t\t\tmemcpy(&tmpstruct, newrel, sizeof(RelationData));\n\t\t\tmemcpy(newrel, relation, sizeof(RelationData));\n\t\t\tmemcpy(relation, &tmpstruct, sizeof(RelationData));\n\t\t}\n\n\t\t/* rd_smgr must not be swapped, due to back-links from smgr level */\n\t\tSWAPFIELD(SMgrRelation, rd_smgr);\n\t\t/* rd_refcnt must be preserved */\n\t\tSWAPFIELD(int, rd_refcnt);\n\t\t/* isnailed shouldn't change */\n\t\tAssert(newrel->rd_isnailed == relation->rd_isnailed);\n\t\t/* creation sub-XIDs must be preserved */\n\t\tSWAPFIELD(SubTransactionId, rd_createSubid);\n\t\tSWAPFIELD(SubTransactionId, rd_newRelfilenodeSubid);\n\t\t/* un-swap rd_rel pointers, swap contents instead */\n\t\tSWAPFIELD(Form_pg_class, rd_rel);\n\t\t/* ... but actually, we don't have to update newrel->rd_rel */\n\t\tmemcpy(relation->rd_rel, newrel->rd_rel, CLASS_TUPLE_SIZE);\n\t\t/* preserve old tupledesc, rules, policies if no logical change */\n\t\tif (keep_tupdesc)\n\t\t\tSWAPFIELD(TupleDesc, rd_att);\n\t\tif (keep_rules)\n\t\t{\n\t\t\tSWAPFIELD(RuleLock *, rd_rules);\n\t\t\tSWAPFIELD(MemoryContext, rd_rulescxt);\n\t\t}\n\t\tif (keep_policies)\n\t\t\tSWAPFIELD(RowSecurityDesc *, rd_rsdesc);\n\t\t/* toast OID override must be preserved */\n\t\tSWAPFIELD(Oid, rd_toastoid);\n\t\t/* pgstat_info must be preserved */\n\t\tSWAPFIELD(struct PgStat_TableStatus *, pgstat_info);\n\t\t/* preserve old partitioning info if no logical change */\n\t\tif (keep_partkey)\n\t\t{\n\t\t\tSWAPFIELD(PartitionKey, rd_partkey);\n\t\t\tSWAPFIELD(MemoryContext, rd_partkeycxt);\n\t\t}\n\t\tif (keep_partdesc)\n\t\t{\n\t\t\tSWAPFIELD(PartitionDesc, rd_partdesc);\n\t\t\tSWAPFIELD(MemoryContext, rd_pdcxt);\n\t\t}\n\n#undef SWAPFIELD\n\n\t\t/* And now we can throw away the temporary entry */\n\t\tRelationDestroyRelation(newrel, !keep_tupdesc);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationClearRelation(Relation relation, bool rebuild);",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationClearRelation(Relation relation, bool rebuild);\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationClearRelation(Relation relation, bool rebuild)\n{\n\t/*\n\t * As per notes above, a rel to be rebuilt MUST have refcnt > 0; while of\n\t * course it would be an equally bad idea to blow away one with nonzero\n\t * refcnt, since that would leave someone somewhere with a dangling\n\t * pointer.  All callers are expected to have verified that this holds.\n\t */\n\tAssert(rebuild ?\n\t\t   !RelationHasReferenceCountZero(relation) :\n\t\t   RelationHasReferenceCountZero(relation));\n\n\t/*\n\t * Make sure smgr and lower levels close the relation's files, if they\n\t * weren't closed already.  If the relation is not getting deleted, the\n\t * next smgr access should reopen the files automatically.  This ensures\n\t * that the low-level file access state is updated after, say, a vacuum\n\t * truncation.\n\t */\n\tRelationCloseSmgr(relation);\n\n\t/*\n\t * Treat nailed-in system relations separately, they always need to be\n\t * accessible, so we can't blow them away.\n\t */\n\tif (relation->rd_isnailed)\n\t{\n\t\tRelationReloadNailed(relation);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even non-system indexes should not be blown away if they are open and\n\t * have valid index support information.  This avoids problems with active\n\t * use of the index support information.  As with nailed indexes, we\n\t * re-read the pg_class row to handle possible physical relocation of the\n\t * index, and we check for pg_index updates too.\n\t */\n\tif ((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t relation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\trelation->rd_refcnt > 0 &&\n\t\trelation->rd_indexcxt != NULL)\n\t{\n\t\trelation->rd_isvalid = false;\t/* needs to be revalidated */\n\t\tif (IsTransactionState())\n\t\t\tRelationReloadIndexInfo(relation);\n\t\treturn;\n\t}\n\n\t/* Mark it invalid until we've finished rebuild */\n\trelation->rd_isvalid = false;\n\n\t/*\n\t * If we're really done with the relcache entry, blow it away. But if\n\t * someone is still using it, reconstruct the whole deal without moving\n\t * the physical RelationData record (so that the someone's pointer is\n\t * still valid).\n\t */\n\tif (!rebuild)\n\t{\n\t\t/* Remove it from the hash table */\n\t\tRelationCacheDelete(relation);\n\n\t\t/* And release storage */\n\t\tRelationDestroyRelation(relation, false);\n\t}\n\telse if (!IsTransactionState())\n\t{\n\t\t/*\n\t\t * If we're not inside a valid transaction, we can't do any catalog\n\t\t * access so it's not possible to rebuild yet.  Just exit, leaving\n\t\t * rd_isvalid = false so that the rebuild will occur when the entry is\n\t\t * next opened.\n\t\t *\n\t\t * Note: it's possible that we come here during subtransaction abort,\n\t\t * and the reason for wanting to rebuild is that the rel is open in\n\t\t * the outer transaction.  In that case it might seem unsafe to not\n\t\t * rebuild immediately, since whatever code has the rel already open\n\t\t * will keep on using the relcache entry as-is.  However, in such a\n\t\t * case the outer transaction should be holding a lock that's\n\t\t * sufficient to prevent any significant change in the rel's schema,\n\t\t * so the existing entry contents should be good enough for its\n\t\t * purposes; at worst we might be behind on statistics updates or the\n\t\t * like.  (See also CheckTableNotInUse() and its callers.)\tThese same\n\t\t * remarks also apply to the cases above where we exit without having\n\t\t * done RelationReloadIndexInfo() yet.\n\t\t */\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Our strategy for rebuilding an open relcache entry is to build a\n\t\t * new entry from scratch, swap its contents with the old entry, and\n\t\t * finally delete the new entry (along with any infrastructure swapped\n\t\t * over from the old entry).  This is to avoid trouble in case an\n\t\t * error causes us to lose control partway through.  The old entry\n\t\t * will still be marked !rd_isvalid, so we'll try to rebuild it again\n\t\t * on next access.  Meanwhile it's not any less valid than it was\n\t\t * before, so any code that might expect to continue accessing it\n\t\t * isn't hurt by the rebuild failure.  (Consider for example a\n\t\t * subtransaction that ALTERs a table and then gets canceled partway\n\t\t * through the cache entry rebuild.  The outer transaction should\n\t\t * still see the not-modified cache entry as valid.)  The worst\n\t\t * consequence of an error is leaking the necessarily-unreferenced new\n\t\t * entry, and this shouldn't happen often enough for that to be a big\n\t\t * problem.\n\t\t *\n\t\t * When rebuilding an open relcache entry, we must preserve ref count,\n\t\t * rd_createSubid/rd_newRelfilenodeSubid, and rd_toastoid state.  Also\n\t\t * attempt to preserve the pg_class entry (rd_rel), tupledesc,\n\t\t * rewrite-rule, partition key, and partition descriptor substructures\n\t\t * in place, because various places assume that these structures won't\n\t\t * move while they are working with an open relcache entry.  (Note:\n\t\t * the refcount mechanism for tupledescs might someday allow us to\n\t\t * remove this hack for the tupledesc.)\n\t\t *\n\t\t * Note that this process does not touch CurrentResourceOwner; which\n\t\t * is good because whatever ref counts the entry may have do not\n\t\t * necessarily belong to that resource owner.\n\t\t */\n\t\tRelation\tnewrel;\n\t\tOid\t\t\tsave_relid = RelationGetRelid(relation);\n\t\tbool\t\tkeep_tupdesc;\n\t\tbool\t\tkeep_rules;\n\t\tbool\t\tkeep_policies;\n\t\tbool\t\tkeep_partkey;\n\t\tbool\t\tkeep_partdesc;\n\n\t\t/* Build temporary entry, but don't link it into hashtable */\n\t\tnewrel = RelationBuildDesc(save_relid, false);\n\t\tif (newrel == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * We can validly get here, if we're using a historic snapshot in\n\t\t\t * which a relation, accessed from outside logical decoding, is\n\t\t\t * still invisible. In that case it's fine to just mark the\n\t\t\t * relation as invalid and return - it'll fully get reloaded by\n\t\t\t * the cache reset at the end of logical decoding (or at the next\n\t\t\t * access).  During normal processing we don't want to ignore this\n\t\t\t * case as it shouldn't happen there, as explained below.\n\t\t\t */\n\t\t\tif (HistoricSnapshotActive())\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * This shouldn't happen as dropping a relation is intended to be\n\t\t\t * impossible if still referenced (cf. CheckTableNotInUse()). But\n\t\t\t * if we get here anyway, we can't just delete the relcache entry,\n\t\t\t * as it possibly could get accessed later (as e.g. the error\n\t\t\t * might get trapped and handled via a subtransaction rollback).\n\t\t\t */\n\t\t\telog(ERROR, \"relation %u deleted while still in use\", save_relid);\n\t\t}\n\n\t\tkeep_tupdesc = equalTupleDescs(relation->rd_att, newrel->rd_att);\n\t\tkeep_rules = equalRuleLocks(relation->rd_rules, newrel->rd_rules);\n\t\tkeep_policies = equalRSDesc(relation->rd_rsdesc, newrel->rd_rsdesc);\n\t\t/* partkey is immutable once set up, so we can always keep it */\n\t\tkeep_partkey = (relation->rd_partkey != NULL);\n\t\tkeep_partdesc = equalPartitionDescs(relation->rd_partkey,\n\t\t\t\t\t\t\t\t\t\t\trelation->rd_partdesc,\n\t\t\t\t\t\t\t\t\t\t\tnewrel->rd_partdesc);\n\n\t\t/*\n\t\t * Perform swapping of the relcache entry contents.  Within this\n\t\t * process the old entry is momentarily invalid, so there *must* be no\n\t\t * possibility of CHECK_FOR_INTERRUPTS within this sequence. Do it in\n\t\t * all-in-line code for safety.\n\t\t *\n\t\t * Since the vast majority of fields should be swapped, our method is\n\t\t * to swap the whole structures and then re-swap those few fields we\n\t\t * didn't want swapped.\n\t\t */\n#define SWAPFIELD(fldtype, fldname) \\\n\t\tdo { \\\n\t\t\tfldtype _tmp = newrel->fldname; \\\n\t\t\tnewrel->fldname = relation->fldname; \\\n\t\t\trelation->fldname = _tmp; \\\n\t\t} while (0)\n\n\t\t/* swap all Relation struct fields */\n\t\t{\n\t\t\tRelationData tmpstruct;\n\n\t\t\tmemcpy(&tmpstruct, newrel, sizeof(RelationData));\n\t\t\tmemcpy(newrel, relation, sizeof(RelationData));\n\t\t\tmemcpy(relation, &tmpstruct, sizeof(RelationData));\n\t\t}\n\n\t\t/* rd_smgr must not be swapped, due to back-links from smgr level */\n\t\tSWAPFIELD(SMgrRelation, rd_smgr);\n\t\t/* rd_refcnt must be preserved */\n\t\tSWAPFIELD(int, rd_refcnt);\n\t\t/* isnailed shouldn't change */\n\t\tAssert(newrel->rd_isnailed == relation->rd_isnailed);\n\t\t/* creation sub-XIDs must be preserved */\n\t\tSWAPFIELD(SubTransactionId, rd_createSubid);\n\t\tSWAPFIELD(SubTransactionId, rd_newRelfilenodeSubid);\n\t\t/* un-swap rd_rel pointers, swap contents instead */\n\t\tSWAPFIELD(Form_pg_class, rd_rel);\n\t\t/* ... but actually, we don't have to update newrel->rd_rel */\n\t\tmemcpy(relation->rd_rel, newrel->rd_rel, CLASS_TUPLE_SIZE);\n\t\t/* preserve old tupledesc, rules, policies if no logical change */\n\t\tif (keep_tupdesc)\n\t\t\tSWAPFIELD(TupleDesc, rd_att);\n\t\tif (keep_rules)\n\t\t{\n\t\t\tSWAPFIELD(RuleLock *, rd_rules);\n\t\t\tSWAPFIELD(MemoryContext, rd_rulescxt);\n\t\t}\n\t\tif (keep_policies)\n\t\t\tSWAPFIELD(RowSecurityDesc *, rd_rsdesc);\n\t\t/* toast OID override must be preserved */\n\t\tSWAPFIELD(Oid, rd_toastoid);\n\t\t/* pgstat_info must be preserved */\n\t\tSWAPFIELD(struct PgStat_TableStatus *, pgstat_info);\n\t\t/* preserve old partitioning info if no logical change */\n\t\tif (keep_partkey)\n\t\t{\n\t\t\tSWAPFIELD(PartitionKey, rd_partkey);\n\t\t\tSWAPFIELD(MemoryContext, rd_partkeycxt);\n\t\t}\n\t\tif (keep_partdesc)\n\t\t{\n\t\t\tSWAPFIELD(PartitionDesc, rd_partdesc);\n\t\t\tSWAPFIELD(MemoryContext, rd_pdcxt);\n\t\t}\n\n#undef SWAPFIELD\n\n\t\t/* And now we can throw away the temporary entry */\n\t\tRelationDestroyRelation(newrel, !keep_tupdesc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationHasReferenceCountZero",
          "args": [
            "relation"
          ],
          "line": 2937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relation->rd_refcnt == expected_refcnt"
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void AtEOXact_cleanup(Relation relation, bool isCommit);\nstatic bool load_relcache_init_file(bool shared);\nstatic void write_relcache_init_file(bool shared);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nAtEOXact_cleanup(Relation relation, bool isCommit)\n{\n\t/*\n\t * The relcache entry's ref count should be back to its normal\n\t * not-in-a-transaction state: 0 unless it's nailed in cache.\n\t *\n\t * In bootstrap mode, this is NOT true, so don't check it --- the\n\t * bootstrap code expects relations to stay open across start/commit\n\t * transaction calls.  (That seems bogus, but it's not worth fixing.)\n\t *\n\t * Note: ideally this check would be applied to every relcache entry, not\n\t * just those that have eoxact work to do.  But it's not worth forcing a\n\t * scan of the whole relcache just for this.  (Moreover, doing so would\n\t * mean that assert-enabled testing never tests the hash_search code path\n\t * above, which seems a bad idea.)\n\t */\n#ifdef USE_ASSERT_CHECKING\n\tif (!IsBootstrapProcessingMode())\n\t{\n\t\tint\t\t\texpected_refcnt;\n\n\t\texpected_refcnt = relation->rd_isnailed ? 1 : 0;\n\t\tAssert(relation->rd_refcnt == expected_refcnt);\n\t}\n#endif\n\n\t/*\n\t * Is it a relation created in the current transaction?\n\t *\n\t * During commit, reset the flag to zero, since we are now out of the\n\t * creating transaction.  During abort, simply delete the relcache entry\n\t * --- it isn't interesting any longer.  (NOTE: if we have forgotten the\n\t * new-ness of a new relation due to a forced cache flush, the entry will\n\t * get deleted anyway by shared-cache-inval processing of the aborted\n\t * pg_class insertion.)\n\t */\n\tif (relation->rd_createSubid != InvalidSubTransactionId)\n\t{\n\t\tif (isCommit)\n\t\t\trelation->rd_createSubid = InvalidSubTransactionId;\n\t\telse if (RelationHasReferenceCountZero(relation))\n\t\t{\n\t\t\tRelationClearRelation(relation, false);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Hmm, somewhere there's a (leaked?) reference to the relation.\n\t\t\t * We daren't remove the entry for fear of dereferencing a\n\t\t\t * dangling pointer later.  Bleat, and mark it as not belonging to\n\t\t\t * the current transaction.  Hopefully it'll get cleaned up\n\t\t\t * eventually.  This must be just a WARNING to avoid\n\t\t\t * error-during-error-recovery loops.\n\t\t\t */\n\t\t\trelation->rd_createSubid = InvalidSubTransactionId;\n\t\t\telog(WARNING, \"cannot remove relcache entry for \\\"%s\\\" because it has nonzero refcount\",\n\t\t\t\t RelationGetRelationName(relation));\n\t\t}\n\t}\n\n\t/*\n\t * Likewise, reset the hint about the relfilenode being new.\n\t */\n\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\n\t/*\n\t * Flush any temporary index list.\n\t */\n\tif (relation->rd_indexvalid == 2)\n\t{\n\t\tlist_free(relation->rd_indexlist);\n\t\trelation->rd_indexlist = NIL;\n\t\trelation->rd_oidindex = InvalidOid;\n\t\trelation->rd_pkindex = InvalidOid;\n\t\trelation->rd_replidindex = InvalidOid;\n\t\trelation->rd_indexvalid = 0;\n\t}\n}"
  },
  {
    "function_name": "AtEOXact_RelationCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "2833-2886",
    "snippet": "void\nAtEOXact_RelationCache(bool isCommit)\n{\n\tHASH_SEQ_STATUS status;\n\tRelIdCacheEnt *idhentry;\n\tint\t\t\ti;\n\n\t/*\n\t * Unless the eoxact_list[] overflowed, we only need to examine the rels\n\t * listed in it.  Otherwise fall back on a hash_seq_search scan.\n\t *\n\t * For simplicity, eoxact_list[] entries are not deleted till end of\n\t * top-level transaction, even though we could remove them at\n\t * subtransaction end in some cases, or remove relations from the list if\n\t * they are cleared for other reasons.  Therefore we should expect the\n\t * case that list entries are not found in the hashtable; if not, there's\n\t * nothing to do for them.\n\t */\n\tif (eoxact_list_overflowed)\n\t{\n\t\thash_seq_init(&status, RelationIdCache);\n\t\twhile ((idhentry = (RelIdCacheEnt *) hash_seq_search(&status)) != NULL)\n\t\t{\n\t\t\tAtEOXact_cleanup(idhentry->reldesc, isCommit);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < eoxact_list_len; i++)\n\t\t{\n\t\t\tidhentry = (RelIdCacheEnt *) hash_search(RelationIdCache,\n\t\t\t\t\t\t\t\t\t\t\t\t\t (void *) &eoxact_list[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t HASH_FIND,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NULL);\n\t\t\tif (idhentry != NULL)\n\t\t\t\tAtEOXact_cleanup(idhentry->reldesc, isCommit);\n\t\t}\n\t}\n\n\tif (EOXactTupleDescArrayLen > 0)\n\t{\n\t\tAssert(EOXactTupleDescArray != NULL);\n\t\tfor (i = 0; i < NextEOXactTupleDescNum; i++)\n\t\t\tFreeTupleDesc(EOXactTupleDescArray[i]);\n\t\tpfree(EOXactTupleDescArray);\n\t\tEOXactTupleDescArray = NULL;\n\t}\n\n\t/* Now we're out of the transaction and can clear the lists */\n\teoxact_list_len = 0;\n\teoxact_list_overflowed = false;\n\tNextEOXactTupleDescNum = 0;\n\tEOXactTupleDescArrayLen = 0;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *RelationIdCache;",
      "static Oid\teoxact_list[MAX_EOXACT_LIST];",
      "static int\teoxact_list_len = 0;",
      "static bool eoxact_list_overflowed = false;",
      "static TupleDesc *EOXactTupleDescArray;",
      "static int\tNextEOXactTupleDescNum = 0;",
      "static int\tEOXactTupleDescArrayLen = 0;",
      "static void AtEOXact_cleanup(Relation relation, bool isCommit);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "EOXactTupleDescArray"
          ],
          "line": 2877
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreeTupleDesc",
          "args": [
            "EOXactTupleDescArray[i]"
          ],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "RememberToFreeTupleDescAtEOX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2789-2815",
          "snippet": "static void\nRememberToFreeTupleDescAtEOX(TupleDesc td)\n{\n\tif (EOXactTupleDescArray == NULL)\n\t{\n\t\tMemoryContext oldcxt;\n\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) palloc(16 * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = 16;\n\t\tNextEOXactTupleDescNum = 0;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse if (NextEOXactTupleDescNum >= EOXactTupleDescArrayLen)\n\t{\n\t\tint32\t\tnewlen = EOXactTupleDescArrayLen * 2;\n\n\t\tAssert(EOXactTupleDescArrayLen > 0);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) repalloc(EOXactTupleDescArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = newlen;\n\t}\n\n\tEOXactTupleDescArray[NextEOXactTupleDescNum++] = td;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc *EOXactTupleDescArray;",
            "static int\tNextEOXactTupleDescNum = 0;",
            "static int\tEOXactTupleDescArrayLen = 0;",
            "static void RememberToFreeTupleDescAtEOX(TupleDesc td);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic TupleDesc *EOXactTupleDescArray;\nstatic int\tNextEOXactTupleDescNum = 0;\nstatic int\tEOXactTupleDescArrayLen = 0;\nstatic void RememberToFreeTupleDescAtEOX(TupleDesc td);\n\nstatic void\nRememberToFreeTupleDescAtEOX(TupleDesc td)\n{\n\tif (EOXactTupleDescArray == NULL)\n\t{\n\t\tMemoryContext oldcxt;\n\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) palloc(16 * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = 16;\n\t\tNextEOXactTupleDescNum = 0;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse if (NextEOXactTupleDescNum >= EOXactTupleDescArrayLen)\n\t{\n\t\tint32\t\tnewlen = EOXactTupleDescArrayLen * 2;\n\n\t\tAssert(EOXactTupleDescArrayLen > 0);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) repalloc(EOXactTupleDescArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = newlen;\n\t}\n\n\tEOXactTupleDescArray[NextEOXactTupleDescNum++] = td;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "EOXactTupleDescArray != NULL"
          ],
          "line": 2874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AtEOXact_cleanup",
          "args": [
            "idhentry->reldesc",
            "isCommit"
          ],
          "line": 2868
        },
        "resolved": true,
        "details": {
          "function_name": "AtEOXact_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2896-2975",
          "snippet": "static void\nAtEOXact_cleanup(Relation relation, bool isCommit)\n{\n\t/*\n\t * The relcache entry's ref count should be back to its normal\n\t * not-in-a-transaction state: 0 unless it's nailed in cache.\n\t *\n\t * In bootstrap mode, this is NOT true, so don't check it --- the\n\t * bootstrap code expects relations to stay open across start/commit\n\t * transaction calls.  (That seems bogus, but it's not worth fixing.)\n\t *\n\t * Note: ideally this check would be applied to every relcache entry, not\n\t * just those that have eoxact work to do.  But it's not worth forcing a\n\t * scan of the whole relcache just for this.  (Moreover, doing so would\n\t * mean that assert-enabled testing never tests the hash_search code path\n\t * above, which seems a bad idea.)\n\t */\n#ifdef USE_ASSERT_CHECKING\n\tif (!IsBootstrapProcessingMode())\n\t{\n\t\tint\t\t\texpected_refcnt;\n\n\t\texpected_refcnt = relation->rd_isnailed ? 1 : 0;\n\t\tAssert(relation->rd_refcnt == expected_refcnt);\n\t}\n#endif\n\n\t/*\n\t * Is it a relation created in the current transaction?\n\t *\n\t * During commit, reset the flag to zero, since we are now out of the\n\t * creating transaction.  During abort, simply delete the relcache entry\n\t * --- it isn't interesting any longer.  (NOTE: if we have forgotten the\n\t * new-ness of a new relation due to a forced cache flush, the entry will\n\t * get deleted anyway by shared-cache-inval processing of the aborted\n\t * pg_class insertion.)\n\t */\n\tif (relation->rd_createSubid != InvalidSubTransactionId)\n\t{\n\t\tif (isCommit)\n\t\t\trelation->rd_createSubid = InvalidSubTransactionId;\n\t\telse if (RelationHasReferenceCountZero(relation))\n\t\t{\n\t\t\tRelationClearRelation(relation, false);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Hmm, somewhere there's a (leaked?) reference to the relation.\n\t\t\t * We daren't remove the entry for fear of dereferencing a\n\t\t\t * dangling pointer later.  Bleat, and mark it as not belonging to\n\t\t\t * the current transaction.  Hopefully it'll get cleaned up\n\t\t\t * eventually.  This must be just a WARNING to avoid\n\t\t\t * error-during-error-recovery loops.\n\t\t\t */\n\t\t\trelation->rd_createSubid = InvalidSubTransactionId;\n\t\t\telog(WARNING, \"cannot remove relcache entry for \\\"%s\\\" because it has nonzero refcount\",\n\t\t\t\t RelationGetRelationName(relation));\n\t\t}\n\t}\n\n\t/*\n\t * Likewise, reset the hint about the relfilenode being new.\n\t */\n\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\n\t/*\n\t * Flush any temporary index list.\n\t */\n\tif (relation->rd_indexvalid == 2)\n\t{\n\t\tlist_free(relation->rd_indexlist);\n\t\trelation->rd_indexlist = NIL;\n\t\trelation->rd_oidindex = InvalidOid;\n\t\trelation->rd_pkindex = InvalidOid;\n\t\trelation->rd_replidindex = InvalidOid;\n\t\trelation->rd_indexvalid = 0;\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void AtEOXact_cleanup(Relation relation, bool isCommit);",
            "static bool load_relcache_init_file(bool shared);",
            "static void write_relcache_init_file(bool shared);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void AtEOXact_cleanup(Relation relation, bool isCommit);\nstatic bool load_relcache_init_file(bool shared);\nstatic void write_relcache_init_file(bool shared);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nAtEOXact_cleanup(Relation relation, bool isCommit)\n{\n\t/*\n\t * The relcache entry's ref count should be back to its normal\n\t * not-in-a-transaction state: 0 unless it's nailed in cache.\n\t *\n\t * In bootstrap mode, this is NOT true, so don't check it --- the\n\t * bootstrap code expects relations to stay open across start/commit\n\t * transaction calls.  (That seems bogus, but it's not worth fixing.)\n\t *\n\t * Note: ideally this check would be applied to every relcache entry, not\n\t * just those that have eoxact work to do.  But it's not worth forcing a\n\t * scan of the whole relcache just for this.  (Moreover, doing so would\n\t * mean that assert-enabled testing never tests the hash_search code path\n\t * above, which seems a bad idea.)\n\t */\n#ifdef USE_ASSERT_CHECKING\n\tif (!IsBootstrapProcessingMode())\n\t{\n\t\tint\t\t\texpected_refcnt;\n\n\t\texpected_refcnt = relation->rd_isnailed ? 1 : 0;\n\t\tAssert(relation->rd_refcnt == expected_refcnt);\n\t}\n#endif\n\n\t/*\n\t * Is it a relation created in the current transaction?\n\t *\n\t * During commit, reset the flag to zero, since we are now out of the\n\t * creating transaction.  During abort, simply delete the relcache entry\n\t * --- it isn't interesting any longer.  (NOTE: if we have forgotten the\n\t * new-ness of a new relation due to a forced cache flush, the entry will\n\t * get deleted anyway by shared-cache-inval processing of the aborted\n\t * pg_class insertion.)\n\t */\n\tif (relation->rd_createSubid != InvalidSubTransactionId)\n\t{\n\t\tif (isCommit)\n\t\t\trelation->rd_createSubid = InvalidSubTransactionId;\n\t\telse if (RelationHasReferenceCountZero(relation))\n\t\t{\n\t\t\tRelationClearRelation(relation, false);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Hmm, somewhere there's a (leaked?) reference to the relation.\n\t\t\t * We daren't remove the entry for fear of dereferencing a\n\t\t\t * dangling pointer later.  Bleat, and mark it as not belonging to\n\t\t\t * the current transaction.  Hopefully it'll get cleaned up\n\t\t\t * eventually.  This must be just a WARNING to avoid\n\t\t\t * error-during-error-recovery loops.\n\t\t\t */\n\t\t\trelation->rd_createSubid = InvalidSubTransactionId;\n\t\t\telog(WARNING, \"cannot remove relcache entry for \\\"%s\\\" because it has nonzero refcount\",\n\t\t\t\t RelationGetRelationName(relation));\n\t\t}\n\t}\n\n\t/*\n\t * Likewise, reset the hint about the relfilenode being new.\n\t */\n\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\n\t/*\n\t * Flush any temporary index list.\n\t */\n\tif (relation->rd_indexvalid == 2)\n\t{\n\t\tlist_free(relation->rd_indexlist);\n\t\trelation->rd_indexlist = NIL;\n\t\trelation->rd_oidindex = InvalidOid;\n\t\trelation->rd_pkindex = InvalidOid;\n\t\trelation->rd_replidindex = InvalidOid;\n\t\trelation->rd_indexvalid = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "RelationIdCache",
            "(void *) &eoxact_list[i]",
            "HASH_FIND",
            "NULL"
          ],
          "line": 2863
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_search",
          "args": [
            "&status"
          ],
          "line": 2854
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1388-1462",
          "snippet": "void *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_init",
          "args": [
            "&status",
            "RelationIdCache"
          ],
          "line": 2853
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1378-1386",
          "snippet": "void\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic HTAB *RelationIdCache;\nstatic Oid\teoxact_list[MAX_EOXACT_LIST];\nstatic int\teoxact_list_len = 0;\nstatic bool eoxact_list_overflowed = false;\nstatic TupleDesc *EOXactTupleDescArray;\nstatic int\tNextEOXactTupleDescNum = 0;\nstatic int\tEOXactTupleDescArrayLen = 0;\nstatic void AtEOXact_cleanup(Relation relation, bool isCommit);\n\nvoid\nAtEOXact_RelationCache(bool isCommit)\n{\n\tHASH_SEQ_STATUS status;\n\tRelIdCacheEnt *idhentry;\n\tint\t\t\ti;\n\n\t/*\n\t * Unless the eoxact_list[] overflowed, we only need to examine the rels\n\t * listed in it.  Otherwise fall back on a hash_seq_search scan.\n\t *\n\t * For simplicity, eoxact_list[] entries are not deleted till end of\n\t * top-level transaction, even though we could remove them at\n\t * subtransaction end in some cases, or remove relations from the list if\n\t * they are cleared for other reasons.  Therefore we should expect the\n\t * case that list entries are not found in the hashtable; if not, there's\n\t * nothing to do for them.\n\t */\n\tif (eoxact_list_overflowed)\n\t{\n\t\thash_seq_init(&status, RelationIdCache);\n\t\twhile ((idhentry = (RelIdCacheEnt *) hash_seq_search(&status)) != NULL)\n\t\t{\n\t\t\tAtEOXact_cleanup(idhentry->reldesc, isCommit);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor (i = 0; i < eoxact_list_len; i++)\n\t\t{\n\t\t\tidhentry = (RelIdCacheEnt *) hash_search(RelationIdCache,\n\t\t\t\t\t\t\t\t\t\t\t\t\t (void *) &eoxact_list[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t HASH_FIND,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NULL);\n\t\t\tif (idhentry != NULL)\n\t\t\t\tAtEOXact_cleanup(idhentry->reldesc, isCommit);\n\t\t}\n\t}\n\n\tif (EOXactTupleDescArrayLen > 0)\n\t{\n\t\tAssert(EOXactTupleDescArray != NULL);\n\t\tfor (i = 0; i < NextEOXactTupleDescNum; i++)\n\t\t\tFreeTupleDesc(EOXactTupleDescArray[i]);\n\t\tpfree(EOXactTupleDescArray);\n\t\tEOXactTupleDescArray = NULL;\n\t}\n\n\t/* Now we're out of the transaction and can clear the lists */\n\teoxact_list_len = 0;\n\teoxact_list_overflowed = false;\n\tNextEOXactTupleDescNum = 0;\n\tEOXactTupleDescArrayLen = 0;\n}"
  },
  {
    "function_name": "RememberToFreeTupleDescAtEOX",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "2789-2815",
    "snippet": "static void\nRememberToFreeTupleDescAtEOX(TupleDesc td)\n{\n\tif (EOXactTupleDescArray == NULL)\n\t{\n\t\tMemoryContext oldcxt;\n\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) palloc(16 * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = 16;\n\t\tNextEOXactTupleDescNum = 0;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse if (NextEOXactTupleDescNum >= EOXactTupleDescArrayLen)\n\t{\n\t\tint32\t\tnewlen = EOXactTupleDescArrayLen * 2;\n\n\t\tAssert(EOXactTupleDescArrayLen > 0);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) repalloc(EOXactTupleDescArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = newlen;\n\t}\n\n\tEOXactTupleDescArray[NextEOXactTupleDescNum++] = td;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static TupleDesc *EOXactTupleDescArray;",
      "static int\tNextEOXactTupleDescNum = 0;",
      "static int\tEOXactTupleDescArrayLen = 0;",
      "static void RememberToFreeTupleDescAtEOX(TupleDesc td);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "EOXactTupleDescArray",
            "newlen * sizeof(TupleDesc)"
          ],
          "line": 2809
        },
        "resolved": true,
        "details": {
          "function_name": "repalloc_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1113-1141",
          "snippet": "void *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "EOXactTupleDescArrayLen > 0"
          ],
          "line": 2807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "16 * sizeof(TupleDesc)"
          ],
          "line": 2798
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic TupleDesc *EOXactTupleDescArray;\nstatic int\tNextEOXactTupleDescNum = 0;\nstatic int\tEOXactTupleDescArrayLen = 0;\nstatic void RememberToFreeTupleDescAtEOX(TupleDesc td);\n\nstatic void\nRememberToFreeTupleDescAtEOX(TupleDesc td)\n{\n\tif (EOXactTupleDescArray == NULL)\n\t{\n\t\tMemoryContext oldcxt;\n\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) palloc(16 * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = 16;\n\t\tNextEOXactTupleDescNum = 0;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse if (NextEOXactTupleDescNum >= EOXactTupleDescArrayLen)\n\t{\n\t\tint32\t\tnewlen = EOXactTupleDescArrayLen * 2;\n\n\t\tAssert(EOXactTupleDescArrayLen > 0);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) repalloc(EOXactTupleDescArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = newlen;\n\t}\n\n\tEOXactTupleDescArray[NextEOXactTupleDescNum++] = td;\n}"
  },
  {
    "function_name": "RelationCloseSmgrByOid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "2776-2787",
    "snippet": "void\nRelationCloseSmgrByOid(Oid relationId)\n{\n\tRelation\trelation;\n\n\tRelationIdCacheLookup(relationId, relation);\n\n\tif (!PointerIsValid(relation))\n\t\treturn;\t\t\t\t\t/* not in cache, nothing to do */\n\n\tRelationCloseSmgr(relation);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RelationCloseSmgr",
          "args": [
            "relation"
          ],
          "line": 2786
        },
        "resolved": true,
        "details": {
          "function_name": "RelationCloseSmgrByOid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2776-2787",
          "snippet": "void\nRelationCloseSmgrByOid(Oid relationId)\n{\n\tRelation\trelation;\n\n\tRelationIdCacheLookup(relationId, relation);\n\n\tif (!PointerIsValid(relation))\n\t\treturn;\t\t\t\t\t/* not in cache, nothing to do */\n\n\tRelationCloseSmgr(relation);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "relation"
          ],
          "line": 2783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationIdCacheLookup",
          "args": [
            "relationId",
            "relation"
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationCloseSmgrByOid(Oid relationId)\n{\n\tRelation\trelation;\n\n\tRelationIdCacheLookup(relationId, relation);\n\n\tif (!PointerIsValid(relation))\n\t\treturn;\t\t\t\t\t/* not in cache, nothing to do */\n\n\tRelationCloseSmgr(relation);\n}"
  },
  {
    "function_name": "RelationCacheInvalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "2673-2768",
    "snippet": "void\nRelationCacheInvalidate(void)\n{\n\tHASH_SEQ_STATUS status;\n\tRelIdCacheEnt *idhentry;\n\tRelation\trelation;\n\tList\t   *rebuildFirstList = NIL;\n\tList\t   *rebuildList = NIL;\n\tListCell   *l;\n\n\t/*\n\t * Reload relation mapping data before starting to reconstruct cache.\n\t */\n\tRelationMapInvalidateAll();\n\n\t/* Phase 1 */\n\thash_seq_init(&status, RelationIdCache);\n\n\twhile ((idhentry = (RelIdCacheEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\trelation = idhentry->reldesc;\n\n\t\t/* Must close all smgr references to avoid leaving dangling ptrs */\n\t\tRelationCloseSmgr(relation);\n\n\t\t/*\n\t\t * Ignore new relations; no other backend will manipulate them before\n\t\t * we commit.  Likewise, before replacing a relation's relfilenode, we\n\t\t * shall have acquired AccessExclusiveLock and drained any applicable\n\t\t * pending invalidations.\n\t\t */\n\t\tif (relation->rd_createSubid != InvalidSubTransactionId ||\n\t\t\trelation->rd_newRelfilenodeSubid != InvalidSubTransactionId)\n\t\t\tcontinue;\n\n\t\trelcacheInvalsReceived++;\n\n\t\tif (RelationHasReferenceCountZero(relation))\n\t\t{\n\t\t\t/* Delete this entry immediately */\n\t\t\tAssert(!relation->rd_isnailed);\n\t\t\tRelationClearRelation(relation, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If it's a mapped relation, immediately update its rd_node in\n\t\t\t * case its relfilenode changed.  We must do this during phase 1\n\t\t\t * in case the relation is consulted during rebuild of other\n\t\t\t * relcache entries in phase 2.  It's safe since consulting the\n\t\t\t * map doesn't involve any access to relcache entries.\n\t\t\t */\n\t\t\tif (RelationIsMapped(relation))\n\t\t\t\tRelationInitPhysicalAddr(relation);\n\n\t\t\t/*\n\t\t\t * Add this entry to list of stuff to rebuild in second pass.\n\t\t\t * pg_class goes to the front of rebuildFirstList while\n\t\t\t * pg_class_oid_index goes to the back of rebuildFirstList, so\n\t\t\t * they are done first and second respectively.  Other nailed\n\t\t\t * relations go to the front of rebuildList, so they'll be done\n\t\t\t * next in no particular order; and everything else goes to the\n\t\t\t * back of rebuildList.\n\t\t\t */\n\t\t\tif (RelationGetRelid(relation) == RelationRelationId)\n\t\t\t\trebuildFirstList = lcons(relation, rebuildFirstList);\n\t\t\telse if (RelationGetRelid(relation) == ClassOidIndexId)\n\t\t\t\trebuildFirstList = lappend(rebuildFirstList, relation);\n\t\t\telse if (relation->rd_isnailed)\n\t\t\t\trebuildList = lcons(relation, rebuildList);\n\t\t\telse\n\t\t\t\trebuildList = lappend(rebuildList, relation);\n\t\t}\n\t}\n\n\t/*\n\t * Now zap any remaining smgr cache entries.  This must happen before we\n\t * start to rebuild entries, since that may involve catalog fetches which\n\t * will re-open catalog files.\n\t */\n\tsmgrcloseall();\n\n\t/* Phase 2: rebuild the items found to need rebuild in phase 1 */\n\tforeach(l, rebuildFirstList)\n\t{\n\t\trelation = (Relation) lfirst(l);\n\t\tRelationClearRelation(relation, true);\n\t}\n\tlist_free(rebuildFirstList);\n\tforeach(l, rebuildList)\n\t{\n\t\trelation = (Relation) lfirst(l);\n\t\tRelationClearRelation(relation, true);\n\t}\n\tlist_free(rebuildList);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static HTAB *RelationIdCache;",
      "static long relcacheInvalsReceived = 0L;",
      "static void RelationClearRelation(Relation relation, bool rebuild);",
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_free",
          "args": [
            "rebuildList"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationClearRelation",
          "args": [
            "relation",
            "true"
          ],
          "line": 2765
        },
        "resolved": true,
        "details": {
          "function_name": "RelationClearRelation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2318-2553",
          "snippet": "static void\nRelationClearRelation(Relation relation, bool rebuild)\n{\n\t/*\n\t * As per notes above, a rel to be rebuilt MUST have refcnt > 0; while of\n\t * course it would be an equally bad idea to blow away one with nonzero\n\t * refcnt, since that would leave someone somewhere with a dangling\n\t * pointer.  All callers are expected to have verified that this holds.\n\t */\n\tAssert(rebuild ?\n\t\t   !RelationHasReferenceCountZero(relation) :\n\t\t   RelationHasReferenceCountZero(relation));\n\n\t/*\n\t * Make sure smgr and lower levels close the relation's files, if they\n\t * weren't closed already.  If the relation is not getting deleted, the\n\t * next smgr access should reopen the files automatically.  This ensures\n\t * that the low-level file access state is updated after, say, a vacuum\n\t * truncation.\n\t */\n\tRelationCloseSmgr(relation);\n\n\t/*\n\t * Treat nailed-in system relations separately, they always need to be\n\t * accessible, so we can't blow them away.\n\t */\n\tif (relation->rd_isnailed)\n\t{\n\t\tRelationReloadNailed(relation);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even non-system indexes should not be blown away if they are open and\n\t * have valid index support information.  This avoids problems with active\n\t * use of the index support information.  As with nailed indexes, we\n\t * re-read the pg_class row to handle possible physical relocation of the\n\t * index, and we check for pg_index updates too.\n\t */\n\tif ((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t relation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\trelation->rd_refcnt > 0 &&\n\t\trelation->rd_indexcxt != NULL)\n\t{\n\t\trelation->rd_isvalid = false;\t/* needs to be revalidated */\n\t\tif (IsTransactionState())\n\t\t\tRelationReloadIndexInfo(relation);\n\t\treturn;\n\t}\n\n\t/* Mark it invalid until we've finished rebuild */\n\trelation->rd_isvalid = false;\n\n\t/*\n\t * If we're really done with the relcache entry, blow it away. But if\n\t * someone is still using it, reconstruct the whole deal without moving\n\t * the physical RelationData record (so that the someone's pointer is\n\t * still valid).\n\t */\n\tif (!rebuild)\n\t{\n\t\t/* Remove it from the hash table */\n\t\tRelationCacheDelete(relation);\n\n\t\t/* And release storage */\n\t\tRelationDestroyRelation(relation, false);\n\t}\n\telse if (!IsTransactionState())\n\t{\n\t\t/*\n\t\t * If we're not inside a valid transaction, we can't do any catalog\n\t\t * access so it's not possible to rebuild yet.  Just exit, leaving\n\t\t * rd_isvalid = false so that the rebuild will occur when the entry is\n\t\t * next opened.\n\t\t *\n\t\t * Note: it's possible that we come here during subtransaction abort,\n\t\t * and the reason for wanting to rebuild is that the rel is open in\n\t\t * the outer transaction.  In that case it might seem unsafe to not\n\t\t * rebuild immediately, since whatever code has the rel already open\n\t\t * will keep on using the relcache entry as-is.  However, in such a\n\t\t * case the outer transaction should be holding a lock that's\n\t\t * sufficient to prevent any significant change in the rel's schema,\n\t\t * so the existing entry contents should be good enough for its\n\t\t * purposes; at worst we might be behind on statistics updates or the\n\t\t * like.  (See also CheckTableNotInUse() and its callers.)\tThese same\n\t\t * remarks also apply to the cases above where we exit without having\n\t\t * done RelationReloadIndexInfo() yet.\n\t\t */\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Our strategy for rebuilding an open relcache entry is to build a\n\t\t * new entry from scratch, swap its contents with the old entry, and\n\t\t * finally delete the new entry (along with any infrastructure swapped\n\t\t * over from the old entry).  This is to avoid trouble in case an\n\t\t * error causes us to lose control partway through.  The old entry\n\t\t * will still be marked !rd_isvalid, so we'll try to rebuild it again\n\t\t * on next access.  Meanwhile it's not any less valid than it was\n\t\t * before, so any code that might expect to continue accessing it\n\t\t * isn't hurt by the rebuild failure.  (Consider for example a\n\t\t * subtransaction that ALTERs a table and then gets canceled partway\n\t\t * through the cache entry rebuild.  The outer transaction should\n\t\t * still see the not-modified cache entry as valid.)  The worst\n\t\t * consequence of an error is leaking the necessarily-unreferenced new\n\t\t * entry, and this shouldn't happen often enough for that to be a big\n\t\t * problem.\n\t\t *\n\t\t * When rebuilding an open relcache entry, we must preserve ref count,\n\t\t * rd_createSubid/rd_newRelfilenodeSubid, and rd_toastoid state.  Also\n\t\t * attempt to preserve the pg_class entry (rd_rel), tupledesc,\n\t\t * rewrite-rule, partition key, and partition descriptor substructures\n\t\t * in place, because various places assume that these structures won't\n\t\t * move while they are working with an open relcache entry.  (Note:\n\t\t * the refcount mechanism for tupledescs might someday allow us to\n\t\t * remove this hack for the tupledesc.)\n\t\t *\n\t\t * Note that this process does not touch CurrentResourceOwner; which\n\t\t * is good because whatever ref counts the entry may have do not\n\t\t * necessarily belong to that resource owner.\n\t\t */\n\t\tRelation\tnewrel;\n\t\tOid\t\t\tsave_relid = RelationGetRelid(relation);\n\t\tbool\t\tkeep_tupdesc;\n\t\tbool\t\tkeep_rules;\n\t\tbool\t\tkeep_policies;\n\t\tbool\t\tkeep_partkey;\n\t\tbool\t\tkeep_partdesc;\n\n\t\t/* Build temporary entry, but don't link it into hashtable */\n\t\tnewrel = RelationBuildDesc(save_relid, false);\n\t\tif (newrel == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * We can validly get here, if we're using a historic snapshot in\n\t\t\t * which a relation, accessed from outside logical decoding, is\n\t\t\t * still invisible. In that case it's fine to just mark the\n\t\t\t * relation as invalid and return - it'll fully get reloaded by\n\t\t\t * the cache reset at the end of logical decoding (or at the next\n\t\t\t * access).  During normal processing we don't want to ignore this\n\t\t\t * case as it shouldn't happen there, as explained below.\n\t\t\t */\n\t\t\tif (HistoricSnapshotActive())\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * This shouldn't happen as dropping a relation is intended to be\n\t\t\t * impossible if still referenced (cf. CheckTableNotInUse()). But\n\t\t\t * if we get here anyway, we can't just delete the relcache entry,\n\t\t\t * as it possibly could get accessed later (as e.g. the error\n\t\t\t * might get trapped and handled via a subtransaction rollback).\n\t\t\t */\n\t\t\telog(ERROR, \"relation %u deleted while still in use\", save_relid);\n\t\t}\n\n\t\tkeep_tupdesc = equalTupleDescs(relation->rd_att, newrel->rd_att);\n\t\tkeep_rules = equalRuleLocks(relation->rd_rules, newrel->rd_rules);\n\t\tkeep_policies = equalRSDesc(relation->rd_rsdesc, newrel->rd_rsdesc);\n\t\t/* partkey is immutable once set up, so we can always keep it */\n\t\tkeep_partkey = (relation->rd_partkey != NULL);\n\t\tkeep_partdesc = equalPartitionDescs(relation->rd_partkey,\n\t\t\t\t\t\t\t\t\t\t\trelation->rd_partdesc,\n\t\t\t\t\t\t\t\t\t\t\tnewrel->rd_partdesc);\n\n\t\t/*\n\t\t * Perform swapping of the relcache entry contents.  Within this\n\t\t * process the old entry is momentarily invalid, so there *must* be no\n\t\t * possibility of CHECK_FOR_INTERRUPTS within this sequence. Do it in\n\t\t * all-in-line code for safety.\n\t\t *\n\t\t * Since the vast majority of fields should be swapped, our method is\n\t\t * to swap the whole structures and then re-swap those few fields we\n\t\t * didn't want swapped.\n\t\t */\n#define SWAPFIELD(fldtype, fldname) \\\n\t\tdo { \\\n\t\t\tfldtype _tmp = newrel->fldname; \\\n\t\t\tnewrel->fldname = relation->fldname; \\\n\t\t\trelation->fldname = _tmp; \\\n\t\t} while (0)\n\n\t\t/* swap all Relation struct fields */\n\t\t{\n\t\t\tRelationData tmpstruct;\n\n\t\t\tmemcpy(&tmpstruct, newrel, sizeof(RelationData));\n\t\t\tmemcpy(newrel, relation, sizeof(RelationData));\n\t\t\tmemcpy(relation, &tmpstruct, sizeof(RelationData));\n\t\t}\n\n\t\t/* rd_smgr must not be swapped, due to back-links from smgr level */\n\t\tSWAPFIELD(SMgrRelation, rd_smgr);\n\t\t/* rd_refcnt must be preserved */\n\t\tSWAPFIELD(int, rd_refcnt);\n\t\t/* isnailed shouldn't change */\n\t\tAssert(newrel->rd_isnailed == relation->rd_isnailed);\n\t\t/* creation sub-XIDs must be preserved */\n\t\tSWAPFIELD(SubTransactionId, rd_createSubid);\n\t\tSWAPFIELD(SubTransactionId, rd_newRelfilenodeSubid);\n\t\t/* un-swap rd_rel pointers, swap contents instead */\n\t\tSWAPFIELD(Form_pg_class, rd_rel);\n\t\t/* ... but actually, we don't have to update newrel->rd_rel */\n\t\tmemcpy(relation->rd_rel, newrel->rd_rel, CLASS_TUPLE_SIZE);\n\t\t/* preserve old tupledesc, rules, policies if no logical change */\n\t\tif (keep_tupdesc)\n\t\t\tSWAPFIELD(TupleDesc, rd_att);\n\t\tif (keep_rules)\n\t\t{\n\t\t\tSWAPFIELD(RuleLock *, rd_rules);\n\t\t\tSWAPFIELD(MemoryContext, rd_rulescxt);\n\t\t}\n\t\tif (keep_policies)\n\t\t\tSWAPFIELD(RowSecurityDesc *, rd_rsdesc);\n\t\t/* toast OID override must be preserved */\n\t\tSWAPFIELD(Oid, rd_toastoid);\n\t\t/* pgstat_info must be preserved */\n\t\tSWAPFIELD(struct PgStat_TableStatus *, pgstat_info);\n\t\t/* preserve old partitioning info if no logical change */\n\t\tif (keep_partkey)\n\t\t{\n\t\t\tSWAPFIELD(PartitionKey, rd_partkey);\n\t\t\tSWAPFIELD(MemoryContext, rd_partkeycxt);\n\t\t}\n\t\tif (keep_partdesc)\n\t\t{\n\t\t\tSWAPFIELD(PartitionDesc, rd_partdesc);\n\t\t\tSWAPFIELD(MemoryContext, rd_pdcxt);\n\t\t}\n\n#undef SWAPFIELD\n\n\t\t/* And now we can throw away the temporary entry */\n\t\tRelationDestroyRelation(newrel, !keep_tupdesc);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationClearRelation(Relation relation, bool rebuild);",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationClearRelation(Relation relation, bool rebuild);\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationClearRelation(Relation relation, bool rebuild)\n{\n\t/*\n\t * As per notes above, a rel to be rebuilt MUST have refcnt > 0; while of\n\t * course it would be an equally bad idea to blow away one with nonzero\n\t * refcnt, since that would leave someone somewhere with a dangling\n\t * pointer.  All callers are expected to have verified that this holds.\n\t */\n\tAssert(rebuild ?\n\t\t   !RelationHasReferenceCountZero(relation) :\n\t\t   RelationHasReferenceCountZero(relation));\n\n\t/*\n\t * Make sure smgr and lower levels close the relation's files, if they\n\t * weren't closed already.  If the relation is not getting deleted, the\n\t * next smgr access should reopen the files automatically.  This ensures\n\t * that the low-level file access state is updated after, say, a vacuum\n\t * truncation.\n\t */\n\tRelationCloseSmgr(relation);\n\n\t/*\n\t * Treat nailed-in system relations separately, they always need to be\n\t * accessible, so we can't blow them away.\n\t */\n\tif (relation->rd_isnailed)\n\t{\n\t\tRelationReloadNailed(relation);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even non-system indexes should not be blown away if they are open and\n\t * have valid index support information.  This avoids problems with active\n\t * use of the index support information.  As with nailed indexes, we\n\t * re-read the pg_class row to handle possible physical relocation of the\n\t * index, and we check for pg_index updates too.\n\t */\n\tif ((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t relation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\trelation->rd_refcnt > 0 &&\n\t\trelation->rd_indexcxt != NULL)\n\t{\n\t\trelation->rd_isvalid = false;\t/* needs to be revalidated */\n\t\tif (IsTransactionState())\n\t\t\tRelationReloadIndexInfo(relation);\n\t\treturn;\n\t}\n\n\t/* Mark it invalid until we've finished rebuild */\n\trelation->rd_isvalid = false;\n\n\t/*\n\t * If we're really done with the relcache entry, blow it away. But if\n\t * someone is still using it, reconstruct the whole deal without moving\n\t * the physical RelationData record (so that the someone's pointer is\n\t * still valid).\n\t */\n\tif (!rebuild)\n\t{\n\t\t/* Remove it from the hash table */\n\t\tRelationCacheDelete(relation);\n\n\t\t/* And release storage */\n\t\tRelationDestroyRelation(relation, false);\n\t}\n\telse if (!IsTransactionState())\n\t{\n\t\t/*\n\t\t * If we're not inside a valid transaction, we can't do any catalog\n\t\t * access so it's not possible to rebuild yet.  Just exit, leaving\n\t\t * rd_isvalid = false so that the rebuild will occur when the entry is\n\t\t * next opened.\n\t\t *\n\t\t * Note: it's possible that we come here during subtransaction abort,\n\t\t * and the reason for wanting to rebuild is that the rel is open in\n\t\t * the outer transaction.  In that case it might seem unsafe to not\n\t\t * rebuild immediately, since whatever code has the rel already open\n\t\t * will keep on using the relcache entry as-is.  However, in such a\n\t\t * case the outer transaction should be holding a lock that's\n\t\t * sufficient to prevent any significant change in the rel's schema,\n\t\t * so the existing entry contents should be good enough for its\n\t\t * purposes; at worst we might be behind on statistics updates or the\n\t\t * like.  (See also CheckTableNotInUse() and its callers.)\tThese same\n\t\t * remarks also apply to the cases above where we exit without having\n\t\t * done RelationReloadIndexInfo() yet.\n\t\t */\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Our strategy for rebuilding an open relcache entry is to build a\n\t\t * new entry from scratch, swap its contents with the old entry, and\n\t\t * finally delete the new entry (along with any infrastructure swapped\n\t\t * over from the old entry).  This is to avoid trouble in case an\n\t\t * error causes us to lose control partway through.  The old entry\n\t\t * will still be marked !rd_isvalid, so we'll try to rebuild it again\n\t\t * on next access.  Meanwhile it's not any less valid than it was\n\t\t * before, so any code that might expect to continue accessing it\n\t\t * isn't hurt by the rebuild failure.  (Consider for example a\n\t\t * subtransaction that ALTERs a table and then gets canceled partway\n\t\t * through the cache entry rebuild.  The outer transaction should\n\t\t * still see the not-modified cache entry as valid.)  The worst\n\t\t * consequence of an error is leaking the necessarily-unreferenced new\n\t\t * entry, and this shouldn't happen often enough for that to be a big\n\t\t * problem.\n\t\t *\n\t\t * When rebuilding an open relcache entry, we must preserve ref count,\n\t\t * rd_createSubid/rd_newRelfilenodeSubid, and rd_toastoid state.  Also\n\t\t * attempt to preserve the pg_class entry (rd_rel), tupledesc,\n\t\t * rewrite-rule, partition key, and partition descriptor substructures\n\t\t * in place, because various places assume that these structures won't\n\t\t * move while they are working with an open relcache entry.  (Note:\n\t\t * the refcount mechanism for tupledescs might someday allow us to\n\t\t * remove this hack for the tupledesc.)\n\t\t *\n\t\t * Note that this process does not touch CurrentResourceOwner; which\n\t\t * is good because whatever ref counts the entry may have do not\n\t\t * necessarily belong to that resource owner.\n\t\t */\n\t\tRelation\tnewrel;\n\t\tOid\t\t\tsave_relid = RelationGetRelid(relation);\n\t\tbool\t\tkeep_tupdesc;\n\t\tbool\t\tkeep_rules;\n\t\tbool\t\tkeep_policies;\n\t\tbool\t\tkeep_partkey;\n\t\tbool\t\tkeep_partdesc;\n\n\t\t/* Build temporary entry, but don't link it into hashtable */\n\t\tnewrel = RelationBuildDesc(save_relid, false);\n\t\tif (newrel == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * We can validly get here, if we're using a historic snapshot in\n\t\t\t * which a relation, accessed from outside logical decoding, is\n\t\t\t * still invisible. In that case it's fine to just mark the\n\t\t\t * relation as invalid and return - it'll fully get reloaded by\n\t\t\t * the cache reset at the end of logical decoding (or at the next\n\t\t\t * access).  During normal processing we don't want to ignore this\n\t\t\t * case as it shouldn't happen there, as explained below.\n\t\t\t */\n\t\t\tif (HistoricSnapshotActive())\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * This shouldn't happen as dropping a relation is intended to be\n\t\t\t * impossible if still referenced (cf. CheckTableNotInUse()). But\n\t\t\t * if we get here anyway, we can't just delete the relcache entry,\n\t\t\t * as it possibly could get accessed later (as e.g. the error\n\t\t\t * might get trapped and handled via a subtransaction rollback).\n\t\t\t */\n\t\t\telog(ERROR, \"relation %u deleted while still in use\", save_relid);\n\t\t}\n\n\t\tkeep_tupdesc = equalTupleDescs(relation->rd_att, newrel->rd_att);\n\t\tkeep_rules = equalRuleLocks(relation->rd_rules, newrel->rd_rules);\n\t\tkeep_policies = equalRSDesc(relation->rd_rsdesc, newrel->rd_rsdesc);\n\t\t/* partkey is immutable once set up, so we can always keep it */\n\t\tkeep_partkey = (relation->rd_partkey != NULL);\n\t\tkeep_partdesc = equalPartitionDescs(relation->rd_partkey,\n\t\t\t\t\t\t\t\t\t\t\trelation->rd_partdesc,\n\t\t\t\t\t\t\t\t\t\t\tnewrel->rd_partdesc);\n\n\t\t/*\n\t\t * Perform swapping of the relcache entry contents.  Within this\n\t\t * process the old entry is momentarily invalid, so there *must* be no\n\t\t * possibility of CHECK_FOR_INTERRUPTS within this sequence. Do it in\n\t\t * all-in-line code for safety.\n\t\t *\n\t\t * Since the vast majority of fields should be swapped, our method is\n\t\t * to swap the whole structures and then re-swap those few fields we\n\t\t * didn't want swapped.\n\t\t */\n#define SWAPFIELD(fldtype, fldname) \\\n\t\tdo { \\\n\t\t\tfldtype _tmp = newrel->fldname; \\\n\t\t\tnewrel->fldname = relation->fldname; \\\n\t\t\trelation->fldname = _tmp; \\\n\t\t} while (0)\n\n\t\t/* swap all Relation struct fields */\n\t\t{\n\t\t\tRelationData tmpstruct;\n\n\t\t\tmemcpy(&tmpstruct, newrel, sizeof(RelationData));\n\t\t\tmemcpy(newrel, relation, sizeof(RelationData));\n\t\t\tmemcpy(relation, &tmpstruct, sizeof(RelationData));\n\t\t}\n\n\t\t/* rd_smgr must not be swapped, due to back-links from smgr level */\n\t\tSWAPFIELD(SMgrRelation, rd_smgr);\n\t\t/* rd_refcnt must be preserved */\n\t\tSWAPFIELD(int, rd_refcnt);\n\t\t/* isnailed shouldn't change */\n\t\tAssert(newrel->rd_isnailed == relation->rd_isnailed);\n\t\t/* creation sub-XIDs must be preserved */\n\t\tSWAPFIELD(SubTransactionId, rd_createSubid);\n\t\tSWAPFIELD(SubTransactionId, rd_newRelfilenodeSubid);\n\t\t/* un-swap rd_rel pointers, swap contents instead */\n\t\tSWAPFIELD(Form_pg_class, rd_rel);\n\t\t/* ... but actually, we don't have to update newrel->rd_rel */\n\t\tmemcpy(relation->rd_rel, newrel->rd_rel, CLASS_TUPLE_SIZE);\n\t\t/* preserve old tupledesc, rules, policies if no logical change */\n\t\tif (keep_tupdesc)\n\t\t\tSWAPFIELD(TupleDesc, rd_att);\n\t\tif (keep_rules)\n\t\t{\n\t\t\tSWAPFIELD(RuleLock *, rd_rules);\n\t\t\tSWAPFIELD(MemoryContext, rd_rulescxt);\n\t\t}\n\t\tif (keep_policies)\n\t\t\tSWAPFIELD(RowSecurityDesc *, rd_rsdesc);\n\t\t/* toast OID override must be preserved */\n\t\tSWAPFIELD(Oid, rd_toastoid);\n\t\t/* pgstat_info must be preserved */\n\t\tSWAPFIELD(struct PgStat_TableStatus *, pgstat_info);\n\t\t/* preserve old partitioning info if no logical change */\n\t\tif (keep_partkey)\n\t\t{\n\t\t\tSWAPFIELD(PartitionKey, rd_partkey);\n\t\t\tSWAPFIELD(MemoryContext, rd_partkeycxt);\n\t\t}\n\t\tif (keep_partdesc)\n\t\t{\n\t\t\tSWAPFIELD(PartitionDesc, rd_partdesc);\n\t\t\tSWAPFIELD(MemoryContext, rd_pdcxt);\n\t\t}\n\n#undef SWAPFIELD\n\n\t\t/* And now we can throw away the temporary entry */\n\t\tRelationDestroyRelation(newrel, !keep_tupdesc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "l"
          ],
          "line": 2764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "l",
            "rebuildList"
          ],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_free",
          "args": [
            "rebuildFirstList"
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "l"
          ],
          "line": 2758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "l",
            "rebuildFirstList"
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smgrcloseall",
          "args": [],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "rebuildList",
            "relation"
          ],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lcons",
          "args": [
            "relation",
            "rebuildList"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "rebuildFirstList",
            "relation"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lcons",
          "args": [
            "relation",
            "rebuildFirstList"
          ],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 2737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationInitPhysicalAddr",
          "args": [
            "relation"
          ],
          "line": 2726
        },
        "resolved": true,
        "details": {
          "function_name": "RelationInitPhysicalAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1259-1315",
          "snippet": "static void\nRelationInitPhysicalAddr(Relation relation)\n{\n\tif (relation->rd_rel->reltablespace)\n\t\trelation->rd_node.spcNode = relation->rd_rel->reltablespace;\n\telse\n\t\trelation->rd_node.spcNode = MyDatabaseTableSpace;\n\tif (relation->rd_node.spcNode == GLOBALTABLESPACE_OID)\n\t\trelation->rd_node.dbNode = InvalidOid;\n\telse\n\t\trelation->rd_node.dbNode = MyDatabaseId;\n\n\tif (relation->rd_rel->relfilenode)\n\t{\n\t\t/*\n\t\t * Even if we are using a decoding snapshot that doesn't represent the\n\t\t * current state of the catalog we need to make sure the filenode\n\t\t * points to the current file since the older file will be gone (or\n\t\t * truncated). The new file will still contain older rows so lookups\n\t\t * in them will work correctly. This wouldn't work correctly if\n\t\t * rewrites were allowed to change the schema in an incompatible way,\n\t\t * but those are prevented both on catalog tables and on user tables\n\t\t * declared as additional catalog tables.\n\t\t */\n\t\tif (HistoricSnapshotActive()\n\t\t\t&& RelationIsAccessibleInLogicalDecoding(relation)\n\t\t\t&& IsTransactionState())\n\t\t{\n\t\t\tHeapTuple\tphys_tuple;\n\t\t\tForm_pg_class physrel;\n\n\t\t\tphys_tuple = ScanPgRelation(RelationGetRelid(relation),\n\t\t\t\t\t\t\t\t\t\tRelationGetRelid(relation) != ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t\ttrue);\n\t\t\tif (!HeapTupleIsValid(phys_tuple))\n\t\t\t\telog(ERROR, \"could not find pg_class entry for %u\",\n\t\t\t\t\t RelationGetRelid(relation));\n\t\t\tphysrel = (Form_pg_class) GETSTRUCT(phys_tuple);\n\n\t\t\trelation->rd_rel->reltablespace = physrel->reltablespace;\n\t\t\trelation->rd_rel->relfilenode = physrel->relfilenode;\n\t\t\theap_freetuple(phys_tuple);\n\t\t}\n\n\t\trelation->rd_node.relNode = relation->rd_rel->relfilenode;\n\t}\n\telse\n\t{\n\t\t/* Consult the relation mapper */\n\t\trelation->rd_node.relNode =\n\t\t\tRelationMapOidToFilenode(relation->rd_id,\n\t\t\t\t\t\t\t\t\t relation->rd_rel->relisshared);\n\t\tif (!OidIsValid(relation->rd_node.relNode))\n\t\t\telog(ERROR, \"could not find relation mapping for relation \\\"%s\\\", OID %u\",\n\t\t\t\t RelationGetRelationName(relation), relation->rd_id);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationInitPhysicalAddr(Relation relation)\n{\n\tif (relation->rd_rel->reltablespace)\n\t\trelation->rd_node.spcNode = relation->rd_rel->reltablespace;\n\telse\n\t\trelation->rd_node.spcNode = MyDatabaseTableSpace;\n\tif (relation->rd_node.spcNode == GLOBALTABLESPACE_OID)\n\t\trelation->rd_node.dbNode = InvalidOid;\n\telse\n\t\trelation->rd_node.dbNode = MyDatabaseId;\n\n\tif (relation->rd_rel->relfilenode)\n\t{\n\t\t/*\n\t\t * Even if we are using a decoding snapshot that doesn't represent the\n\t\t * current state of the catalog we need to make sure the filenode\n\t\t * points to the current file since the older file will be gone (or\n\t\t * truncated). The new file will still contain older rows so lookups\n\t\t * in them will work correctly. This wouldn't work correctly if\n\t\t * rewrites were allowed to change the schema in an incompatible way,\n\t\t * but those are prevented both on catalog tables and on user tables\n\t\t * declared as additional catalog tables.\n\t\t */\n\t\tif (HistoricSnapshotActive()\n\t\t\t&& RelationIsAccessibleInLogicalDecoding(relation)\n\t\t\t&& IsTransactionState())\n\t\t{\n\t\t\tHeapTuple\tphys_tuple;\n\t\t\tForm_pg_class physrel;\n\n\t\t\tphys_tuple = ScanPgRelation(RelationGetRelid(relation),\n\t\t\t\t\t\t\t\t\t\tRelationGetRelid(relation) != ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t\ttrue);\n\t\t\tif (!HeapTupleIsValid(phys_tuple))\n\t\t\t\telog(ERROR, \"could not find pg_class entry for %u\",\n\t\t\t\t\t RelationGetRelid(relation));\n\t\t\tphysrel = (Form_pg_class) GETSTRUCT(phys_tuple);\n\n\t\t\trelation->rd_rel->reltablespace = physrel->reltablespace;\n\t\t\trelation->rd_rel->relfilenode = physrel->relfilenode;\n\t\t\theap_freetuple(phys_tuple);\n\t\t}\n\n\t\trelation->rd_node.relNode = relation->rd_rel->relfilenode;\n\t}\n\telse\n\t{\n\t\t/* Consult the relation mapper */\n\t\trelation->rd_node.relNode =\n\t\t\tRelationMapOidToFilenode(relation->rd_id,\n\t\t\t\t\t\t\t\t\t relation->rd_rel->relisshared);\n\t\tif (!OidIsValid(relation->rd_node.relNode))\n\t\t\telog(ERROR, \"could not find relation mapping for relation \\\"%s\\\", OID %u\",\n\t\t\t\t RelationGetRelationName(relation), relation->rd_id);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationIsMapped",
          "args": [
            "relation"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!relation->rd_isnailed"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationHasReferenceCountZero",
          "args": [
            "relation"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationCloseSmgr",
          "args": [
            "relation"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "RelationCloseSmgrByOid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2776-2787",
          "snippet": "void\nRelationCloseSmgrByOid(Oid relationId)\n{\n\tRelation\trelation;\n\n\tRelationIdCacheLookup(relationId, relation);\n\n\tif (!PointerIsValid(relation))\n\t\treturn;\t\t\t\t\t/* not in cache, nothing to do */\n\n\tRelationCloseSmgr(relation);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationCloseSmgrByOid(Oid relationId)\n{\n\tRelation\trelation;\n\n\tRelationIdCacheLookup(relationId, relation);\n\n\tif (!PointerIsValid(relation))\n\t\treturn;\t\t\t\t\t/* not in cache, nothing to do */\n\n\tRelationCloseSmgr(relation);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_search",
          "args": [
            "&status"
          ],
          "line": 2691
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1388-1462",
          "snippet": "void *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_seq_search(HASH_SEQ_STATUS *status)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\tuint32\t\tmax_bucket;\n\tlong\t\tssize;\n\tlong\t\tsegment_num;\n\tlong\t\tsegment_ndx;\n\tHASHSEGMENT segp;\n\tuint32\t\tcurBucket;\n\tHASHELEMENT *curElem;\n\n\tif ((curElem = status->curEntry) != NULL)\n\t{\n\t\t/* Continuing scan of curBucket... */\n\t\tstatus->curEntry = curElem->link;\n\t\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t\t++status->curBucket;\n\t\treturn (void *) ELEMENTKEY(curElem);\n\t}\n\n\t/*\n\t * Search for next nonempty bucket starting at curBucket.\n\t */\n\tcurBucket = status->curBucket;\n\thashp = status->hashp;\n\thctl = hashp->hctl;\n\tssize = hashp->ssize;\n\tmax_bucket = hctl->max_bucket;\n\n\tif (curBucket > max_bucket)\n\t{\n\t\thash_seq_term(status);\n\t\treturn NULL;\t\t\t/* search is done */\n\t}\n\n\t/*\n\t * first find the right segment in the table directory.\n\t */\n\tsegment_num = curBucket >> hashp->sshift;\n\tsegment_ndx = MOD(curBucket, ssize);\n\n\tsegp = hashp->dir[segment_num];\n\n\t/*\n\t * Pick up the first item in this bucket's chain.  If chain is not empty\n\t * we can begin searching it.  Otherwise we have to advance to find the\n\t * next nonempty bucket.  We try to optimize that case since searching a\n\t * near-empty hashtable has to iterate this loop a lot.\n\t */\n\twhile ((curElem = segp[segment_ndx]) == NULL)\n\t{\n\t\t/* empty bucket, advance to next */\n\t\tif (++curBucket > max_bucket)\n\t\t{\n\t\t\tstatus->curBucket = curBucket;\n\t\t\thash_seq_term(status);\n\t\t\treturn NULL;\t\t/* search is done */\n\t\t}\n\t\tif (++segment_ndx >= ssize)\n\t\t{\n\t\t\tsegment_num++;\n\t\t\tsegment_ndx = 0;\n\t\t\tsegp = hashp->dir[segment_num];\n\t\t}\n\t}\n\n\t/* Begin scan of curBucket... */\n\tstatus->curEntry = curElem->link;\n\tif (status->curEntry == NULL)\t/* end of this bucket */\n\t\t++curBucket;\n\tstatus->curBucket = curBucket;\n\treturn (void *) ELEMENTKEY(curElem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_seq_init",
          "args": [
            "&status",
            "RelationIdCache"
          ],
          "line": 2689
        },
        "resolved": true,
        "details": {
          "function_name": "hash_seq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "1378-1386",
          "snippet": "void\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid\nhash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp)\n{\n\tstatus->hashp = hashp;\n\tstatus->curBucket = 0;\n\tstatus->curEntry = NULL;\n\tif (!hashp->frozen)\n\t\tregister_seq_scan(hashp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationMapInvalidateAll",
          "args": [],
          "line": 2686
        },
        "resolved": true,
        "details": {
          "function_name": "RelationMapInvalidateAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "412-419",
          "snippet": "void\nRelationMapInvalidateAll(void)\n{\n\tif (shared_map.magic == RELMAPPER_FILEMAGIC)\n\t\tload_relmap_file(true);\n\tif (local_map.magic == RELMAPPER_FILEMAGIC)\n\t\tload_relmap_file(false);\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */"
          ],
          "globals_used": [
            "static RelMapFile shared_map;",
            "static RelMapFile local_map;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define RELMAPPER_FILEMAGIC\t\t0x592717\t/* version ID value */\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\n\nvoid\nRelationMapInvalidateAll(void)\n{\n\tif (shared_map.magic == RELMAPPER_FILEMAGIC)\n\t\tload_relmap_file(true);\n\tif (local_map.magic == RELMAPPER_FILEMAGIC)\n\t\tload_relmap_file(false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic HTAB *RelationIdCache;\nstatic long relcacheInvalsReceived = 0L;\nstatic void RelationClearRelation(Relation relation, bool rebuild);\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationCacheInvalidate(void)\n{\n\tHASH_SEQ_STATUS status;\n\tRelIdCacheEnt *idhentry;\n\tRelation\trelation;\n\tList\t   *rebuildFirstList = NIL;\n\tList\t   *rebuildList = NIL;\n\tListCell   *l;\n\n\t/*\n\t * Reload relation mapping data before starting to reconstruct cache.\n\t */\n\tRelationMapInvalidateAll();\n\n\t/* Phase 1 */\n\thash_seq_init(&status, RelationIdCache);\n\n\twhile ((idhentry = (RelIdCacheEnt *) hash_seq_search(&status)) != NULL)\n\t{\n\t\trelation = idhentry->reldesc;\n\n\t\t/* Must close all smgr references to avoid leaving dangling ptrs */\n\t\tRelationCloseSmgr(relation);\n\n\t\t/*\n\t\t * Ignore new relations; no other backend will manipulate them before\n\t\t * we commit.  Likewise, before replacing a relation's relfilenode, we\n\t\t * shall have acquired AccessExclusiveLock and drained any applicable\n\t\t * pending invalidations.\n\t\t */\n\t\tif (relation->rd_createSubid != InvalidSubTransactionId ||\n\t\t\trelation->rd_newRelfilenodeSubid != InvalidSubTransactionId)\n\t\t\tcontinue;\n\n\t\trelcacheInvalsReceived++;\n\n\t\tif (RelationHasReferenceCountZero(relation))\n\t\t{\n\t\t\t/* Delete this entry immediately */\n\t\t\tAssert(!relation->rd_isnailed);\n\t\t\tRelationClearRelation(relation, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If it's a mapped relation, immediately update its rd_node in\n\t\t\t * case its relfilenode changed.  We must do this during phase 1\n\t\t\t * in case the relation is consulted during rebuild of other\n\t\t\t * relcache entries in phase 2.  It's safe since consulting the\n\t\t\t * map doesn't involve any access to relcache entries.\n\t\t\t */\n\t\t\tif (RelationIsMapped(relation))\n\t\t\t\tRelationInitPhysicalAddr(relation);\n\n\t\t\t/*\n\t\t\t * Add this entry to list of stuff to rebuild in second pass.\n\t\t\t * pg_class goes to the front of rebuildFirstList while\n\t\t\t * pg_class_oid_index goes to the back of rebuildFirstList, so\n\t\t\t * they are done first and second respectively.  Other nailed\n\t\t\t * relations go to the front of rebuildList, so they'll be done\n\t\t\t * next in no particular order; and everything else goes to the\n\t\t\t * back of rebuildList.\n\t\t\t */\n\t\t\tif (RelationGetRelid(relation) == RelationRelationId)\n\t\t\t\trebuildFirstList = lcons(relation, rebuildFirstList);\n\t\t\telse if (RelationGetRelid(relation) == ClassOidIndexId)\n\t\t\t\trebuildFirstList = lappend(rebuildFirstList, relation);\n\t\t\telse if (relation->rd_isnailed)\n\t\t\t\trebuildList = lcons(relation, rebuildList);\n\t\t\telse\n\t\t\t\trebuildList = lappend(rebuildList, relation);\n\t\t}\n\t}\n\n\t/*\n\t * Now zap any remaining smgr cache entries.  This must happen before we\n\t * start to rebuild entries, since that may involve catalog fetches which\n\t * will re-open catalog files.\n\t */\n\tsmgrcloseall();\n\n\t/* Phase 2: rebuild the items found to need rebuild in phase 1 */\n\tforeach(l, rebuildFirstList)\n\t{\n\t\trelation = (Relation) lfirst(l);\n\t\tRelationClearRelation(relation, true);\n\t}\n\tlist_free(rebuildFirstList);\n\tforeach(l, rebuildList)\n\t{\n\t\trelation = (Relation) lfirst(l);\n\t\tRelationClearRelation(relation, true);\n\t}\n\tlist_free(rebuildList);\n}"
  },
  {
    "function_name": "RelationCacheInvalidateEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "2629-2641",
    "snippet": "void\nRelationCacheInvalidateEntry(Oid relationId)\n{\n\tRelation\trelation;\n\n\tRelationIdCacheLookup(relationId, relation);\n\n\tif (PointerIsValid(relation))\n\t{\n\t\trelcacheInvalsReceived++;\n\t\tRelationFlushRelation(relation);\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static long relcacheInvalsReceived = 0L;",
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RelationFlushRelation",
          "args": [
            "relation"
          ],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "RelationFlushRelation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2561-2589",
          "snippet": "static void\nRelationFlushRelation(Relation relation)\n{\n\tif (relation->rd_createSubid != InvalidSubTransactionId ||\n\t\trelation->rd_newRelfilenodeSubid != InvalidSubTransactionId)\n\t{\n\t\t/*\n\t\t * New relcache entries are always rebuilt, not flushed; else we'd\n\t\t * forget the \"new\" status of the relation, which is a useful\n\t\t * optimization to have.  Ditto for the new-relfilenode status.\n\t\t *\n\t\t * The rel could have zero refcnt here, so temporarily increment the\n\t\t * refcnt to ensure it's safe to rebuild it.  We can assume that the\n\t\t * current transaction has some lock on the rel already.\n\t\t */\n\t\tRelationIncrementReferenceCount(relation);\n\t\tRelationClearRelation(relation, true);\n\t\tRelationDecrementReferenceCount(relation);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Pre-existing rels can be dropped from the relcache if not open.\n\t\t */\n\t\tbool\t\trebuild = !RelationHasReferenceCountZero(relation);\n\n\t\tRelationClearRelation(relation, rebuild);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationClearRelation(Relation relation, bool rebuild);",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationClearRelation(Relation relation, bool rebuild);\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationFlushRelation(Relation relation)\n{\n\tif (relation->rd_createSubid != InvalidSubTransactionId ||\n\t\trelation->rd_newRelfilenodeSubid != InvalidSubTransactionId)\n\t{\n\t\t/*\n\t\t * New relcache entries are always rebuilt, not flushed; else we'd\n\t\t * forget the \"new\" status of the relation, which is a useful\n\t\t * optimization to have.  Ditto for the new-relfilenode status.\n\t\t *\n\t\t * The rel could have zero refcnt here, so temporarily increment the\n\t\t * refcnt to ensure it's safe to rebuild it.  We can assume that the\n\t\t * current transaction has some lock on the rel already.\n\t\t */\n\t\tRelationIncrementReferenceCount(relation);\n\t\tRelationClearRelation(relation, true);\n\t\tRelationDecrementReferenceCount(relation);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Pre-existing rels can be dropped from the relcache if not open.\n\t\t */\n\t\tbool\t\trebuild = !RelationHasReferenceCountZero(relation);\n\n\t\tRelationClearRelation(relation, rebuild);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "relation"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationIdCacheLookup",
          "args": [
            "relationId",
            "relation"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic long relcacheInvalsReceived = 0L;\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationCacheInvalidateEntry(Oid relationId)\n{\n\tRelation\trelation;\n\n\tRelationIdCacheLookup(relationId, relation);\n\n\tif (PointerIsValid(relation))\n\t{\n\t\trelcacheInvalsReceived++;\n\t\tRelationFlushRelation(relation);\n\t}\n}"
  },
  {
    "function_name": "RelationForgetRelation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "2597-2612",
    "snippet": "void\nRelationForgetRelation(Oid rid)\n{\n\tRelation\trelation;\n\n\tRelationIdCacheLookup(rid, relation);\n\n\tif (!PointerIsValid(relation))\n\t\treturn;\t\t\t\t\t/* not in cache, nothing to do */\n\n\tif (!RelationHasReferenceCountZero(relation))\n\t\telog(ERROR, \"relation %u is still open\", rid);\n\n\t/* Unconditionally destroy the relcache entry */\n\tRelationClearRelation(relation, false);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RelationClearRelation",
          "args": [
            "relation",
            "false"
          ],
          "line": 2611
        },
        "resolved": true,
        "details": {
          "function_name": "RelationClearRelation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2318-2553",
          "snippet": "static void\nRelationClearRelation(Relation relation, bool rebuild)\n{\n\t/*\n\t * As per notes above, a rel to be rebuilt MUST have refcnt > 0; while of\n\t * course it would be an equally bad idea to blow away one with nonzero\n\t * refcnt, since that would leave someone somewhere with a dangling\n\t * pointer.  All callers are expected to have verified that this holds.\n\t */\n\tAssert(rebuild ?\n\t\t   !RelationHasReferenceCountZero(relation) :\n\t\t   RelationHasReferenceCountZero(relation));\n\n\t/*\n\t * Make sure smgr and lower levels close the relation's files, if they\n\t * weren't closed already.  If the relation is not getting deleted, the\n\t * next smgr access should reopen the files automatically.  This ensures\n\t * that the low-level file access state is updated after, say, a vacuum\n\t * truncation.\n\t */\n\tRelationCloseSmgr(relation);\n\n\t/*\n\t * Treat nailed-in system relations separately, they always need to be\n\t * accessible, so we can't blow them away.\n\t */\n\tif (relation->rd_isnailed)\n\t{\n\t\tRelationReloadNailed(relation);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even non-system indexes should not be blown away if they are open and\n\t * have valid index support information.  This avoids problems with active\n\t * use of the index support information.  As with nailed indexes, we\n\t * re-read the pg_class row to handle possible physical relocation of the\n\t * index, and we check for pg_index updates too.\n\t */\n\tif ((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t relation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\trelation->rd_refcnt > 0 &&\n\t\trelation->rd_indexcxt != NULL)\n\t{\n\t\trelation->rd_isvalid = false;\t/* needs to be revalidated */\n\t\tif (IsTransactionState())\n\t\t\tRelationReloadIndexInfo(relation);\n\t\treturn;\n\t}\n\n\t/* Mark it invalid until we've finished rebuild */\n\trelation->rd_isvalid = false;\n\n\t/*\n\t * If we're really done with the relcache entry, blow it away. But if\n\t * someone is still using it, reconstruct the whole deal without moving\n\t * the physical RelationData record (so that the someone's pointer is\n\t * still valid).\n\t */\n\tif (!rebuild)\n\t{\n\t\t/* Remove it from the hash table */\n\t\tRelationCacheDelete(relation);\n\n\t\t/* And release storage */\n\t\tRelationDestroyRelation(relation, false);\n\t}\n\telse if (!IsTransactionState())\n\t{\n\t\t/*\n\t\t * If we're not inside a valid transaction, we can't do any catalog\n\t\t * access so it's not possible to rebuild yet.  Just exit, leaving\n\t\t * rd_isvalid = false so that the rebuild will occur when the entry is\n\t\t * next opened.\n\t\t *\n\t\t * Note: it's possible that we come here during subtransaction abort,\n\t\t * and the reason for wanting to rebuild is that the rel is open in\n\t\t * the outer transaction.  In that case it might seem unsafe to not\n\t\t * rebuild immediately, since whatever code has the rel already open\n\t\t * will keep on using the relcache entry as-is.  However, in such a\n\t\t * case the outer transaction should be holding a lock that's\n\t\t * sufficient to prevent any significant change in the rel's schema,\n\t\t * so the existing entry contents should be good enough for its\n\t\t * purposes; at worst we might be behind on statistics updates or the\n\t\t * like.  (See also CheckTableNotInUse() and its callers.)\tThese same\n\t\t * remarks also apply to the cases above where we exit without having\n\t\t * done RelationReloadIndexInfo() yet.\n\t\t */\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Our strategy for rebuilding an open relcache entry is to build a\n\t\t * new entry from scratch, swap its contents with the old entry, and\n\t\t * finally delete the new entry (along with any infrastructure swapped\n\t\t * over from the old entry).  This is to avoid trouble in case an\n\t\t * error causes us to lose control partway through.  The old entry\n\t\t * will still be marked !rd_isvalid, so we'll try to rebuild it again\n\t\t * on next access.  Meanwhile it's not any less valid than it was\n\t\t * before, so any code that might expect to continue accessing it\n\t\t * isn't hurt by the rebuild failure.  (Consider for example a\n\t\t * subtransaction that ALTERs a table and then gets canceled partway\n\t\t * through the cache entry rebuild.  The outer transaction should\n\t\t * still see the not-modified cache entry as valid.)  The worst\n\t\t * consequence of an error is leaking the necessarily-unreferenced new\n\t\t * entry, and this shouldn't happen often enough for that to be a big\n\t\t * problem.\n\t\t *\n\t\t * When rebuilding an open relcache entry, we must preserve ref count,\n\t\t * rd_createSubid/rd_newRelfilenodeSubid, and rd_toastoid state.  Also\n\t\t * attempt to preserve the pg_class entry (rd_rel), tupledesc,\n\t\t * rewrite-rule, partition key, and partition descriptor substructures\n\t\t * in place, because various places assume that these structures won't\n\t\t * move while they are working with an open relcache entry.  (Note:\n\t\t * the refcount mechanism for tupledescs might someday allow us to\n\t\t * remove this hack for the tupledesc.)\n\t\t *\n\t\t * Note that this process does not touch CurrentResourceOwner; which\n\t\t * is good because whatever ref counts the entry may have do not\n\t\t * necessarily belong to that resource owner.\n\t\t */\n\t\tRelation\tnewrel;\n\t\tOid\t\t\tsave_relid = RelationGetRelid(relation);\n\t\tbool\t\tkeep_tupdesc;\n\t\tbool\t\tkeep_rules;\n\t\tbool\t\tkeep_policies;\n\t\tbool\t\tkeep_partkey;\n\t\tbool\t\tkeep_partdesc;\n\n\t\t/* Build temporary entry, but don't link it into hashtable */\n\t\tnewrel = RelationBuildDesc(save_relid, false);\n\t\tif (newrel == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * We can validly get here, if we're using a historic snapshot in\n\t\t\t * which a relation, accessed from outside logical decoding, is\n\t\t\t * still invisible. In that case it's fine to just mark the\n\t\t\t * relation as invalid and return - it'll fully get reloaded by\n\t\t\t * the cache reset at the end of logical decoding (or at the next\n\t\t\t * access).  During normal processing we don't want to ignore this\n\t\t\t * case as it shouldn't happen there, as explained below.\n\t\t\t */\n\t\t\tif (HistoricSnapshotActive())\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * This shouldn't happen as dropping a relation is intended to be\n\t\t\t * impossible if still referenced (cf. CheckTableNotInUse()). But\n\t\t\t * if we get here anyway, we can't just delete the relcache entry,\n\t\t\t * as it possibly could get accessed later (as e.g. the error\n\t\t\t * might get trapped and handled via a subtransaction rollback).\n\t\t\t */\n\t\t\telog(ERROR, \"relation %u deleted while still in use\", save_relid);\n\t\t}\n\n\t\tkeep_tupdesc = equalTupleDescs(relation->rd_att, newrel->rd_att);\n\t\tkeep_rules = equalRuleLocks(relation->rd_rules, newrel->rd_rules);\n\t\tkeep_policies = equalRSDesc(relation->rd_rsdesc, newrel->rd_rsdesc);\n\t\t/* partkey is immutable once set up, so we can always keep it */\n\t\tkeep_partkey = (relation->rd_partkey != NULL);\n\t\tkeep_partdesc = equalPartitionDescs(relation->rd_partkey,\n\t\t\t\t\t\t\t\t\t\t\trelation->rd_partdesc,\n\t\t\t\t\t\t\t\t\t\t\tnewrel->rd_partdesc);\n\n\t\t/*\n\t\t * Perform swapping of the relcache entry contents.  Within this\n\t\t * process the old entry is momentarily invalid, so there *must* be no\n\t\t * possibility of CHECK_FOR_INTERRUPTS within this sequence. Do it in\n\t\t * all-in-line code for safety.\n\t\t *\n\t\t * Since the vast majority of fields should be swapped, our method is\n\t\t * to swap the whole structures and then re-swap those few fields we\n\t\t * didn't want swapped.\n\t\t */\n#define SWAPFIELD(fldtype, fldname) \\\n\t\tdo { \\\n\t\t\tfldtype _tmp = newrel->fldname; \\\n\t\t\tnewrel->fldname = relation->fldname; \\\n\t\t\trelation->fldname = _tmp; \\\n\t\t} while (0)\n\n\t\t/* swap all Relation struct fields */\n\t\t{\n\t\t\tRelationData tmpstruct;\n\n\t\t\tmemcpy(&tmpstruct, newrel, sizeof(RelationData));\n\t\t\tmemcpy(newrel, relation, sizeof(RelationData));\n\t\t\tmemcpy(relation, &tmpstruct, sizeof(RelationData));\n\t\t}\n\n\t\t/* rd_smgr must not be swapped, due to back-links from smgr level */\n\t\tSWAPFIELD(SMgrRelation, rd_smgr);\n\t\t/* rd_refcnt must be preserved */\n\t\tSWAPFIELD(int, rd_refcnt);\n\t\t/* isnailed shouldn't change */\n\t\tAssert(newrel->rd_isnailed == relation->rd_isnailed);\n\t\t/* creation sub-XIDs must be preserved */\n\t\tSWAPFIELD(SubTransactionId, rd_createSubid);\n\t\tSWAPFIELD(SubTransactionId, rd_newRelfilenodeSubid);\n\t\t/* un-swap rd_rel pointers, swap contents instead */\n\t\tSWAPFIELD(Form_pg_class, rd_rel);\n\t\t/* ... but actually, we don't have to update newrel->rd_rel */\n\t\tmemcpy(relation->rd_rel, newrel->rd_rel, CLASS_TUPLE_SIZE);\n\t\t/* preserve old tupledesc, rules, policies if no logical change */\n\t\tif (keep_tupdesc)\n\t\t\tSWAPFIELD(TupleDesc, rd_att);\n\t\tif (keep_rules)\n\t\t{\n\t\t\tSWAPFIELD(RuleLock *, rd_rules);\n\t\t\tSWAPFIELD(MemoryContext, rd_rulescxt);\n\t\t}\n\t\tif (keep_policies)\n\t\t\tSWAPFIELD(RowSecurityDesc *, rd_rsdesc);\n\t\t/* toast OID override must be preserved */\n\t\tSWAPFIELD(Oid, rd_toastoid);\n\t\t/* pgstat_info must be preserved */\n\t\tSWAPFIELD(struct PgStat_TableStatus *, pgstat_info);\n\t\t/* preserve old partitioning info if no logical change */\n\t\tif (keep_partkey)\n\t\t{\n\t\t\tSWAPFIELD(PartitionKey, rd_partkey);\n\t\t\tSWAPFIELD(MemoryContext, rd_partkeycxt);\n\t\t}\n\t\tif (keep_partdesc)\n\t\t{\n\t\t\tSWAPFIELD(PartitionDesc, rd_partdesc);\n\t\t\tSWAPFIELD(MemoryContext, rd_pdcxt);\n\t\t}\n\n#undef SWAPFIELD\n\n\t\t/* And now we can throw away the temporary entry */\n\t\tRelationDestroyRelation(newrel, !keep_tupdesc);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationClearRelation(Relation relation, bool rebuild);",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationClearRelation(Relation relation, bool rebuild);\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationClearRelation(Relation relation, bool rebuild)\n{\n\t/*\n\t * As per notes above, a rel to be rebuilt MUST have refcnt > 0; while of\n\t * course it would be an equally bad idea to blow away one with nonzero\n\t * refcnt, since that would leave someone somewhere with a dangling\n\t * pointer.  All callers are expected to have verified that this holds.\n\t */\n\tAssert(rebuild ?\n\t\t   !RelationHasReferenceCountZero(relation) :\n\t\t   RelationHasReferenceCountZero(relation));\n\n\t/*\n\t * Make sure smgr and lower levels close the relation's files, if they\n\t * weren't closed already.  If the relation is not getting deleted, the\n\t * next smgr access should reopen the files automatically.  This ensures\n\t * that the low-level file access state is updated after, say, a vacuum\n\t * truncation.\n\t */\n\tRelationCloseSmgr(relation);\n\n\t/*\n\t * Treat nailed-in system relations separately, they always need to be\n\t * accessible, so we can't blow them away.\n\t */\n\tif (relation->rd_isnailed)\n\t{\n\t\tRelationReloadNailed(relation);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even non-system indexes should not be blown away if they are open and\n\t * have valid index support information.  This avoids problems with active\n\t * use of the index support information.  As with nailed indexes, we\n\t * re-read the pg_class row to handle possible physical relocation of the\n\t * index, and we check for pg_index updates too.\n\t */\n\tif ((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t relation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\trelation->rd_refcnt > 0 &&\n\t\trelation->rd_indexcxt != NULL)\n\t{\n\t\trelation->rd_isvalid = false;\t/* needs to be revalidated */\n\t\tif (IsTransactionState())\n\t\t\tRelationReloadIndexInfo(relation);\n\t\treturn;\n\t}\n\n\t/* Mark it invalid until we've finished rebuild */\n\trelation->rd_isvalid = false;\n\n\t/*\n\t * If we're really done with the relcache entry, blow it away. But if\n\t * someone is still using it, reconstruct the whole deal without moving\n\t * the physical RelationData record (so that the someone's pointer is\n\t * still valid).\n\t */\n\tif (!rebuild)\n\t{\n\t\t/* Remove it from the hash table */\n\t\tRelationCacheDelete(relation);\n\n\t\t/* And release storage */\n\t\tRelationDestroyRelation(relation, false);\n\t}\n\telse if (!IsTransactionState())\n\t{\n\t\t/*\n\t\t * If we're not inside a valid transaction, we can't do any catalog\n\t\t * access so it's not possible to rebuild yet.  Just exit, leaving\n\t\t * rd_isvalid = false so that the rebuild will occur when the entry is\n\t\t * next opened.\n\t\t *\n\t\t * Note: it's possible that we come here during subtransaction abort,\n\t\t * and the reason for wanting to rebuild is that the rel is open in\n\t\t * the outer transaction.  In that case it might seem unsafe to not\n\t\t * rebuild immediately, since whatever code has the rel already open\n\t\t * will keep on using the relcache entry as-is.  However, in such a\n\t\t * case the outer transaction should be holding a lock that's\n\t\t * sufficient to prevent any significant change in the rel's schema,\n\t\t * so the existing entry contents should be good enough for its\n\t\t * purposes; at worst we might be behind on statistics updates or the\n\t\t * like.  (See also CheckTableNotInUse() and its callers.)\tThese same\n\t\t * remarks also apply to the cases above where we exit without having\n\t\t * done RelationReloadIndexInfo() yet.\n\t\t */\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Our strategy for rebuilding an open relcache entry is to build a\n\t\t * new entry from scratch, swap its contents with the old entry, and\n\t\t * finally delete the new entry (along with any infrastructure swapped\n\t\t * over from the old entry).  This is to avoid trouble in case an\n\t\t * error causes us to lose control partway through.  The old entry\n\t\t * will still be marked !rd_isvalid, so we'll try to rebuild it again\n\t\t * on next access.  Meanwhile it's not any less valid than it was\n\t\t * before, so any code that might expect to continue accessing it\n\t\t * isn't hurt by the rebuild failure.  (Consider for example a\n\t\t * subtransaction that ALTERs a table and then gets canceled partway\n\t\t * through the cache entry rebuild.  The outer transaction should\n\t\t * still see the not-modified cache entry as valid.)  The worst\n\t\t * consequence of an error is leaking the necessarily-unreferenced new\n\t\t * entry, and this shouldn't happen often enough for that to be a big\n\t\t * problem.\n\t\t *\n\t\t * When rebuilding an open relcache entry, we must preserve ref count,\n\t\t * rd_createSubid/rd_newRelfilenodeSubid, and rd_toastoid state.  Also\n\t\t * attempt to preserve the pg_class entry (rd_rel), tupledesc,\n\t\t * rewrite-rule, partition key, and partition descriptor substructures\n\t\t * in place, because various places assume that these structures won't\n\t\t * move while they are working with an open relcache entry.  (Note:\n\t\t * the refcount mechanism for tupledescs might someday allow us to\n\t\t * remove this hack for the tupledesc.)\n\t\t *\n\t\t * Note that this process does not touch CurrentResourceOwner; which\n\t\t * is good because whatever ref counts the entry may have do not\n\t\t * necessarily belong to that resource owner.\n\t\t */\n\t\tRelation\tnewrel;\n\t\tOid\t\t\tsave_relid = RelationGetRelid(relation);\n\t\tbool\t\tkeep_tupdesc;\n\t\tbool\t\tkeep_rules;\n\t\tbool\t\tkeep_policies;\n\t\tbool\t\tkeep_partkey;\n\t\tbool\t\tkeep_partdesc;\n\n\t\t/* Build temporary entry, but don't link it into hashtable */\n\t\tnewrel = RelationBuildDesc(save_relid, false);\n\t\tif (newrel == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * We can validly get here, if we're using a historic snapshot in\n\t\t\t * which a relation, accessed from outside logical decoding, is\n\t\t\t * still invisible. In that case it's fine to just mark the\n\t\t\t * relation as invalid and return - it'll fully get reloaded by\n\t\t\t * the cache reset at the end of logical decoding (or at the next\n\t\t\t * access).  During normal processing we don't want to ignore this\n\t\t\t * case as it shouldn't happen there, as explained below.\n\t\t\t */\n\t\t\tif (HistoricSnapshotActive())\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * This shouldn't happen as dropping a relation is intended to be\n\t\t\t * impossible if still referenced (cf. CheckTableNotInUse()). But\n\t\t\t * if we get here anyway, we can't just delete the relcache entry,\n\t\t\t * as it possibly could get accessed later (as e.g. the error\n\t\t\t * might get trapped and handled via a subtransaction rollback).\n\t\t\t */\n\t\t\telog(ERROR, \"relation %u deleted while still in use\", save_relid);\n\t\t}\n\n\t\tkeep_tupdesc = equalTupleDescs(relation->rd_att, newrel->rd_att);\n\t\tkeep_rules = equalRuleLocks(relation->rd_rules, newrel->rd_rules);\n\t\tkeep_policies = equalRSDesc(relation->rd_rsdesc, newrel->rd_rsdesc);\n\t\t/* partkey is immutable once set up, so we can always keep it */\n\t\tkeep_partkey = (relation->rd_partkey != NULL);\n\t\tkeep_partdesc = equalPartitionDescs(relation->rd_partkey,\n\t\t\t\t\t\t\t\t\t\t\trelation->rd_partdesc,\n\t\t\t\t\t\t\t\t\t\t\tnewrel->rd_partdesc);\n\n\t\t/*\n\t\t * Perform swapping of the relcache entry contents.  Within this\n\t\t * process the old entry is momentarily invalid, so there *must* be no\n\t\t * possibility of CHECK_FOR_INTERRUPTS within this sequence. Do it in\n\t\t * all-in-line code for safety.\n\t\t *\n\t\t * Since the vast majority of fields should be swapped, our method is\n\t\t * to swap the whole structures and then re-swap those few fields we\n\t\t * didn't want swapped.\n\t\t */\n#define SWAPFIELD(fldtype, fldname) \\\n\t\tdo { \\\n\t\t\tfldtype _tmp = newrel->fldname; \\\n\t\t\tnewrel->fldname = relation->fldname; \\\n\t\t\trelation->fldname = _tmp; \\\n\t\t} while (0)\n\n\t\t/* swap all Relation struct fields */\n\t\t{\n\t\t\tRelationData tmpstruct;\n\n\t\t\tmemcpy(&tmpstruct, newrel, sizeof(RelationData));\n\t\t\tmemcpy(newrel, relation, sizeof(RelationData));\n\t\t\tmemcpy(relation, &tmpstruct, sizeof(RelationData));\n\t\t}\n\n\t\t/* rd_smgr must not be swapped, due to back-links from smgr level */\n\t\tSWAPFIELD(SMgrRelation, rd_smgr);\n\t\t/* rd_refcnt must be preserved */\n\t\tSWAPFIELD(int, rd_refcnt);\n\t\t/* isnailed shouldn't change */\n\t\tAssert(newrel->rd_isnailed == relation->rd_isnailed);\n\t\t/* creation sub-XIDs must be preserved */\n\t\tSWAPFIELD(SubTransactionId, rd_createSubid);\n\t\tSWAPFIELD(SubTransactionId, rd_newRelfilenodeSubid);\n\t\t/* un-swap rd_rel pointers, swap contents instead */\n\t\tSWAPFIELD(Form_pg_class, rd_rel);\n\t\t/* ... but actually, we don't have to update newrel->rd_rel */\n\t\tmemcpy(relation->rd_rel, newrel->rd_rel, CLASS_TUPLE_SIZE);\n\t\t/* preserve old tupledesc, rules, policies if no logical change */\n\t\tif (keep_tupdesc)\n\t\t\tSWAPFIELD(TupleDesc, rd_att);\n\t\tif (keep_rules)\n\t\t{\n\t\t\tSWAPFIELD(RuleLock *, rd_rules);\n\t\t\tSWAPFIELD(MemoryContext, rd_rulescxt);\n\t\t}\n\t\tif (keep_policies)\n\t\t\tSWAPFIELD(RowSecurityDesc *, rd_rsdesc);\n\t\t/* toast OID override must be preserved */\n\t\tSWAPFIELD(Oid, rd_toastoid);\n\t\t/* pgstat_info must be preserved */\n\t\tSWAPFIELD(struct PgStat_TableStatus *, pgstat_info);\n\t\t/* preserve old partitioning info if no logical change */\n\t\tif (keep_partkey)\n\t\t{\n\t\t\tSWAPFIELD(PartitionKey, rd_partkey);\n\t\t\tSWAPFIELD(MemoryContext, rd_partkeycxt);\n\t\t}\n\t\tif (keep_partdesc)\n\t\t{\n\t\t\tSWAPFIELD(PartitionDesc, rd_partdesc);\n\t\t\tSWAPFIELD(MemoryContext, rd_pdcxt);\n\t\t}\n\n#undef SWAPFIELD\n\n\t\t/* And now we can throw away the temporary entry */\n\t\tRelationDestroyRelation(newrel, !keep_tupdesc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"relation %u is still open\"",
            "rid"
          ],
          "line": 2608
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationHasReferenceCountZero",
          "args": [
            "relation"
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerIsValid",
          "args": [
            "relation"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationIdCacheLookup",
          "args": [
            "rid",
            "relation"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationForgetRelation(Oid rid)\n{\n\tRelation\trelation;\n\n\tRelationIdCacheLookup(rid, relation);\n\n\tif (!PointerIsValid(relation))\n\t\treturn;\t\t\t\t\t/* not in cache, nothing to do */\n\n\tif (!RelationHasReferenceCountZero(relation))\n\t\telog(ERROR, \"relation %u is still open\", rid);\n\n\t/* Unconditionally destroy the relcache entry */\n\tRelationClearRelation(relation, false);\n}"
  },
  {
    "function_name": "RelationFlushRelation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "2561-2589",
    "snippet": "static void\nRelationFlushRelation(Relation relation)\n{\n\tif (relation->rd_createSubid != InvalidSubTransactionId ||\n\t\trelation->rd_newRelfilenodeSubid != InvalidSubTransactionId)\n\t{\n\t\t/*\n\t\t * New relcache entries are always rebuilt, not flushed; else we'd\n\t\t * forget the \"new\" status of the relation, which is a useful\n\t\t * optimization to have.  Ditto for the new-relfilenode status.\n\t\t *\n\t\t * The rel could have zero refcnt here, so temporarily increment the\n\t\t * refcnt to ensure it's safe to rebuild it.  We can assume that the\n\t\t * current transaction has some lock on the rel already.\n\t\t */\n\t\tRelationIncrementReferenceCount(relation);\n\t\tRelationClearRelation(relation, true);\n\t\tRelationDecrementReferenceCount(relation);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Pre-existing rels can be dropped from the relcache if not open.\n\t\t */\n\t\tbool\t\trebuild = !RelationHasReferenceCountZero(relation);\n\n\t\tRelationClearRelation(relation, rebuild);\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationClearRelation(Relation relation, bool rebuild);",
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RelationClearRelation",
          "args": [
            "relation",
            "rebuild"
          ],
          "line": 2587
        },
        "resolved": true,
        "details": {
          "function_name": "RelationClearRelation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2318-2553",
          "snippet": "static void\nRelationClearRelation(Relation relation, bool rebuild)\n{\n\t/*\n\t * As per notes above, a rel to be rebuilt MUST have refcnt > 0; while of\n\t * course it would be an equally bad idea to blow away one with nonzero\n\t * refcnt, since that would leave someone somewhere with a dangling\n\t * pointer.  All callers are expected to have verified that this holds.\n\t */\n\tAssert(rebuild ?\n\t\t   !RelationHasReferenceCountZero(relation) :\n\t\t   RelationHasReferenceCountZero(relation));\n\n\t/*\n\t * Make sure smgr and lower levels close the relation's files, if they\n\t * weren't closed already.  If the relation is not getting deleted, the\n\t * next smgr access should reopen the files automatically.  This ensures\n\t * that the low-level file access state is updated after, say, a vacuum\n\t * truncation.\n\t */\n\tRelationCloseSmgr(relation);\n\n\t/*\n\t * Treat nailed-in system relations separately, they always need to be\n\t * accessible, so we can't blow them away.\n\t */\n\tif (relation->rd_isnailed)\n\t{\n\t\tRelationReloadNailed(relation);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even non-system indexes should not be blown away if they are open and\n\t * have valid index support information.  This avoids problems with active\n\t * use of the index support information.  As with nailed indexes, we\n\t * re-read the pg_class row to handle possible physical relocation of the\n\t * index, and we check for pg_index updates too.\n\t */\n\tif ((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t relation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\trelation->rd_refcnt > 0 &&\n\t\trelation->rd_indexcxt != NULL)\n\t{\n\t\trelation->rd_isvalid = false;\t/* needs to be revalidated */\n\t\tif (IsTransactionState())\n\t\t\tRelationReloadIndexInfo(relation);\n\t\treturn;\n\t}\n\n\t/* Mark it invalid until we've finished rebuild */\n\trelation->rd_isvalid = false;\n\n\t/*\n\t * If we're really done with the relcache entry, blow it away. But if\n\t * someone is still using it, reconstruct the whole deal without moving\n\t * the physical RelationData record (so that the someone's pointer is\n\t * still valid).\n\t */\n\tif (!rebuild)\n\t{\n\t\t/* Remove it from the hash table */\n\t\tRelationCacheDelete(relation);\n\n\t\t/* And release storage */\n\t\tRelationDestroyRelation(relation, false);\n\t}\n\telse if (!IsTransactionState())\n\t{\n\t\t/*\n\t\t * If we're not inside a valid transaction, we can't do any catalog\n\t\t * access so it's not possible to rebuild yet.  Just exit, leaving\n\t\t * rd_isvalid = false so that the rebuild will occur when the entry is\n\t\t * next opened.\n\t\t *\n\t\t * Note: it's possible that we come here during subtransaction abort,\n\t\t * and the reason for wanting to rebuild is that the rel is open in\n\t\t * the outer transaction.  In that case it might seem unsafe to not\n\t\t * rebuild immediately, since whatever code has the rel already open\n\t\t * will keep on using the relcache entry as-is.  However, in such a\n\t\t * case the outer transaction should be holding a lock that's\n\t\t * sufficient to prevent any significant change in the rel's schema,\n\t\t * so the existing entry contents should be good enough for its\n\t\t * purposes; at worst we might be behind on statistics updates or the\n\t\t * like.  (See also CheckTableNotInUse() and its callers.)\tThese same\n\t\t * remarks also apply to the cases above where we exit without having\n\t\t * done RelationReloadIndexInfo() yet.\n\t\t */\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Our strategy for rebuilding an open relcache entry is to build a\n\t\t * new entry from scratch, swap its contents with the old entry, and\n\t\t * finally delete the new entry (along with any infrastructure swapped\n\t\t * over from the old entry).  This is to avoid trouble in case an\n\t\t * error causes us to lose control partway through.  The old entry\n\t\t * will still be marked !rd_isvalid, so we'll try to rebuild it again\n\t\t * on next access.  Meanwhile it's not any less valid than it was\n\t\t * before, so any code that might expect to continue accessing it\n\t\t * isn't hurt by the rebuild failure.  (Consider for example a\n\t\t * subtransaction that ALTERs a table and then gets canceled partway\n\t\t * through the cache entry rebuild.  The outer transaction should\n\t\t * still see the not-modified cache entry as valid.)  The worst\n\t\t * consequence of an error is leaking the necessarily-unreferenced new\n\t\t * entry, and this shouldn't happen often enough for that to be a big\n\t\t * problem.\n\t\t *\n\t\t * When rebuilding an open relcache entry, we must preserve ref count,\n\t\t * rd_createSubid/rd_newRelfilenodeSubid, and rd_toastoid state.  Also\n\t\t * attempt to preserve the pg_class entry (rd_rel), tupledesc,\n\t\t * rewrite-rule, partition key, and partition descriptor substructures\n\t\t * in place, because various places assume that these structures won't\n\t\t * move while they are working with an open relcache entry.  (Note:\n\t\t * the refcount mechanism for tupledescs might someday allow us to\n\t\t * remove this hack for the tupledesc.)\n\t\t *\n\t\t * Note that this process does not touch CurrentResourceOwner; which\n\t\t * is good because whatever ref counts the entry may have do not\n\t\t * necessarily belong to that resource owner.\n\t\t */\n\t\tRelation\tnewrel;\n\t\tOid\t\t\tsave_relid = RelationGetRelid(relation);\n\t\tbool\t\tkeep_tupdesc;\n\t\tbool\t\tkeep_rules;\n\t\tbool\t\tkeep_policies;\n\t\tbool\t\tkeep_partkey;\n\t\tbool\t\tkeep_partdesc;\n\n\t\t/* Build temporary entry, but don't link it into hashtable */\n\t\tnewrel = RelationBuildDesc(save_relid, false);\n\t\tif (newrel == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * We can validly get here, if we're using a historic snapshot in\n\t\t\t * which a relation, accessed from outside logical decoding, is\n\t\t\t * still invisible. In that case it's fine to just mark the\n\t\t\t * relation as invalid and return - it'll fully get reloaded by\n\t\t\t * the cache reset at the end of logical decoding (or at the next\n\t\t\t * access).  During normal processing we don't want to ignore this\n\t\t\t * case as it shouldn't happen there, as explained below.\n\t\t\t */\n\t\t\tif (HistoricSnapshotActive())\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * This shouldn't happen as dropping a relation is intended to be\n\t\t\t * impossible if still referenced (cf. CheckTableNotInUse()). But\n\t\t\t * if we get here anyway, we can't just delete the relcache entry,\n\t\t\t * as it possibly could get accessed later (as e.g. the error\n\t\t\t * might get trapped and handled via a subtransaction rollback).\n\t\t\t */\n\t\t\telog(ERROR, \"relation %u deleted while still in use\", save_relid);\n\t\t}\n\n\t\tkeep_tupdesc = equalTupleDescs(relation->rd_att, newrel->rd_att);\n\t\tkeep_rules = equalRuleLocks(relation->rd_rules, newrel->rd_rules);\n\t\tkeep_policies = equalRSDesc(relation->rd_rsdesc, newrel->rd_rsdesc);\n\t\t/* partkey is immutable once set up, so we can always keep it */\n\t\tkeep_partkey = (relation->rd_partkey != NULL);\n\t\tkeep_partdesc = equalPartitionDescs(relation->rd_partkey,\n\t\t\t\t\t\t\t\t\t\t\trelation->rd_partdesc,\n\t\t\t\t\t\t\t\t\t\t\tnewrel->rd_partdesc);\n\n\t\t/*\n\t\t * Perform swapping of the relcache entry contents.  Within this\n\t\t * process the old entry is momentarily invalid, so there *must* be no\n\t\t * possibility of CHECK_FOR_INTERRUPTS within this sequence. Do it in\n\t\t * all-in-line code for safety.\n\t\t *\n\t\t * Since the vast majority of fields should be swapped, our method is\n\t\t * to swap the whole structures and then re-swap those few fields we\n\t\t * didn't want swapped.\n\t\t */\n#define SWAPFIELD(fldtype, fldname) \\\n\t\tdo { \\\n\t\t\tfldtype _tmp = newrel->fldname; \\\n\t\t\tnewrel->fldname = relation->fldname; \\\n\t\t\trelation->fldname = _tmp; \\\n\t\t} while (0)\n\n\t\t/* swap all Relation struct fields */\n\t\t{\n\t\t\tRelationData tmpstruct;\n\n\t\t\tmemcpy(&tmpstruct, newrel, sizeof(RelationData));\n\t\t\tmemcpy(newrel, relation, sizeof(RelationData));\n\t\t\tmemcpy(relation, &tmpstruct, sizeof(RelationData));\n\t\t}\n\n\t\t/* rd_smgr must not be swapped, due to back-links from smgr level */\n\t\tSWAPFIELD(SMgrRelation, rd_smgr);\n\t\t/* rd_refcnt must be preserved */\n\t\tSWAPFIELD(int, rd_refcnt);\n\t\t/* isnailed shouldn't change */\n\t\tAssert(newrel->rd_isnailed == relation->rd_isnailed);\n\t\t/* creation sub-XIDs must be preserved */\n\t\tSWAPFIELD(SubTransactionId, rd_createSubid);\n\t\tSWAPFIELD(SubTransactionId, rd_newRelfilenodeSubid);\n\t\t/* un-swap rd_rel pointers, swap contents instead */\n\t\tSWAPFIELD(Form_pg_class, rd_rel);\n\t\t/* ... but actually, we don't have to update newrel->rd_rel */\n\t\tmemcpy(relation->rd_rel, newrel->rd_rel, CLASS_TUPLE_SIZE);\n\t\t/* preserve old tupledesc, rules, policies if no logical change */\n\t\tif (keep_tupdesc)\n\t\t\tSWAPFIELD(TupleDesc, rd_att);\n\t\tif (keep_rules)\n\t\t{\n\t\t\tSWAPFIELD(RuleLock *, rd_rules);\n\t\t\tSWAPFIELD(MemoryContext, rd_rulescxt);\n\t\t}\n\t\tif (keep_policies)\n\t\t\tSWAPFIELD(RowSecurityDesc *, rd_rsdesc);\n\t\t/* toast OID override must be preserved */\n\t\tSWAPFIELD(Oid, rd_toastoid);\n\t\t/* pgstat_info must be preserved */\n\t\tSWAPFIELD(struct PgStat_TableStatus *, pgstat_info);\n\t\t/* preserve old partitioning info if no logical change */\n\t\tif (keep_partkey)\n\t\t{\n\t\t\tSWAPFIELD(PartitionKey, rd_partkey);\n\t\t\tSWAPFIELD(MemoryContext, rd_partkeycxt);\n\t\t}\n\t\tif (keep_partdesc)\n\t\t{\n\t\t\tSWAPFIELD(PartitionDesc, rd_partdesc);\n\t\t\tSWAPFIELD(MemoryContext, rd_pdcxt);\n\t\t}\n\n#undef SWAPFIELD\n\n\t\t/* And now we can throw away the temporary entry */\n\t\tRelationDestroyRelation(newrel, !keep_tupdesc);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationClearRelation(Relation relation, bool rebuild);",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationClearRelation(Relation relation, bool rebuild);\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationClearRelation(Relation relation, bool rebuild)\n{\n\t/*\n\t * As per notes above, a rel to be rebuilt MUST have refcnt > 0; while of\n\t * course it would be an equally bad idea to blow away one with nonzero\n\t * refcnt, since that would leave someone somewhere with a dangling\n\t * pointer.  All callers are expected to have verified that this holds.\n\t */\n\tAssert(rebuild ?\n\t\t   !RelationHasReferenceCountZero(relation) :\n\t\t   RelationHasReferenceCountZero(relation));\n\n\t/*\n\t * Make sure smgr and lower levels close the relation's files, if they\n\t * weren't closed already.  If the relation is not getting deleted, the\n\t * next smgr access should reopen the files automatically.  This ensures\n\t * that the low-level file access state is updated after, say, a vacuum\n\t * truncation.\n\t */\n\tRelationCloseSmgr(relation);\n\n\t/*\n\t * Treat nailed-in system relations separately, they always need to be\n\t * accessible, so we can't blow them away.\n\t */\n\tif (relation->rd_isnailed)\n\t{\n\t\tRelationReloadNailed(relation);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even non-system indexes should not be blown away if they are open and\n\t * have valid index support information.  This avoids problems with active\n\t * use of the index support information.  As with nailed indexes, we\n\t * re-read the pg_class row to handle possible physical relocation of the\n\t * index, and we check for pg_index updates too.\n\t */\n\tif ((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t relation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\trelation->rd_refcnt > 0 &&\n\t\trelation->rd_indexcxt != NULL)\n\t{\n\t\trelation->rd_isvalid = false;\t/* needs to be revalidated */\n\t\tif (IsTransactionState())\n\t\t\tRelationReloadIndexInfo(relation);\n\t\treturn;\n\t}\n\n\t/* Mark it invalid until we've finished rebuild */\n\trelation->rd_isvalid = false;\n\n\t/*\n\t * If we're really done with the relcache entry, blow it away. But if\n\t * someone is still using it, reconstruct the whole deal without moving\n\t * the physical RelationData record (so that the someone's pointer is\n\t * still valid).\n\t */\n\tif (!rebuild)\n\t{\n\t\t/* Remove it from the hash table */\n\t\tRelationCacheDelete(relation);\n\n\t\t/* And release storage */\n\t\tRelationDestroyRelation(relation, false);\n\t}\n\telse if (!IsTransactionState())\n\t{\n\t\t/*\n\t\t * If we're not inside a valid transaction, we can't do any catalog\n\t\t * access so it's not possible to rebuild yet.  Just exit, leaving\n\t\t * rd_isvalid = false so that the rebuild will occur when the entry is\n\t\t * next opened.\n\t\t *\n\t\t * Note: it's possible that we come here during subtransaction abort,\n\t\t * and the reason for wanting to rebuild is that the rel is open in\n\t\t * the outer transaction.  In that case it might seem unsafe to not\n\t\t * rebuild immediately, since whatever code has the rel already open\n\t\t * will keep on using the relcache entry as-is.  However, in such a\n\t\t * case the outer transaction should be holding a lock that's\n\t\t * sufficient to prevent any significant change in the rel's schema,\n\t\t * so the existing entry contents should be good enough for its\n\t\t * purposes; at worst we might be behind on statistics updates or the\n\t\t * like.  (See also CheckTableNotInUse() and its callers.)\tThese same\n\t\t * remarks also apply to the cases above where we exit without having\n\t\t * done RelationReloadIndexInfo() yet.\n\t\t */\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Our strategy for rebuilding an open relcache entry is to build a\n\t\t * new entry from scratch, swap its contents with the old entry, and\n\t\t * finally delete the new entry (along with any infrastructure swapped\n\t\t * over from the old entry).  This is to avoid trouble in case an\n\t\t * error causes us to lose control partway through.  The old entry\n\t\t * will still be marked !rd_isvalid, so we'll try to rebuild it again\n\t\t * on next access.  Meanwhile it's not any less valid than it was\n\t\t * before, so any code that might expect to continue accessing it\n\t\t * isn't hurt by the rebuild failure.  (Consider for example a\n\t\t * subtransaction that ALTERs a table and then gets canceled partway\n\t\t * through the cache entry rebuild.  The outer transaction should\n\t\t * still see the not-modified cache entry as valid.)  The worst\n\t\t * consequence of an error is leaking the necessarily-unreferenced new\n\t\t * entry, and this shouldn't happen often enough for that to be a big\n\t\t * problem.\n\t\t *\n\t\t * When rebuilding an open relcache entry, we must preserve ref count,\n\t\t * rd_createSubid/rd_newRelfilenodeSubid, and rd_toastoid state.  Also\n\t\t * attempt to preserve the pg_class entry (rd_rel), tupledesc,\n\t\t * rewrite-rule, partition key, and partition descriptor substructures\n\t\t * in place, because various places assume that these structures won't\n\t\t * move while they are working with an open relcache entry.  (Note:\n\t\t * the refcount mechanism for tupledescs might someday allow us to\n\t\t * remove this hack for the tupledesc.)\n\t\t *\n\t\t * Note that this process does not touch CurrentResourceOwner; which\n\t\t * is good because whatever ref counts the entry may have do not\n\t\t * necessarily belong to that resource owner.\n\t\t */\n\t\tRelation\tnewrel;\n\t\tOid\t\t\tsave_relid = RelationGetRelid(relation);\n\t\tbool\t\tkeep_tupdesc;\n\t\tbool\t\tkeep_rules;\n\t\tbool\t\tkeep_policies;\n\t\tbool\t\tkeep_partkey;\n\t\tbool\t\tkeep_partdesc;\n\n\t\t/* Build temporary entry, but don't link it into hashtable */\n\t\tnewrel = RelationBuildDesc(save_relid, false);\n\t\tif (newrel == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * We can validly get here, if we're using a historic snapshot in\n\t\t\t * which a relation, accessed from outside logical decoding, is\n\t\t\t * still invisible. In that case it's fine to just mark the\n\t\t\t * relation as invalid and return - it'll fully get reloaded by\n\t\t\t * the cache reset at the end of logical decoding (or at the next\n\t\t\t * access).  During normal processing we don't want to ignore this\n\t\t\t * case as it shouldn't happen there, as explained below.\n\t\t\t */\n\t\t\tif (HistoricSnapshotActive())\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * This shouldn't happen as dropping a relation is intended to be\n\t\t\t * impossible if still referenced (cf. CheckTableNotInUse()). But\n\t\t\t * if we get here anyway, we can't just delete the relcache entry,\n\t\t\t * as it possibly could get accessed later (as e.g. the error\n\t\t\t * might get trapped and handled via a subtransaction rollback).\n\t\t\t */\n\t\t\telog(ERROR, \"relation %u deleted while still in use\", save_relid);\n\t\t}\n\n\t\tkeep_tupdesc = equalTupleDescs(relation->rd_att, newrel->rd_att);\n\t\tkeep_rules = equalRuleLocks(relation->rd_rules, newrel->rd_rules);\n\t\tkeep_policies = equalRSDesc(relation->rd_rsdesc, newrel->rd_rsdesc);\n\t\t/* partkey is immutable once set up, so we can always keep it */\n\t\tkeep_partkey = (relation->rd_partkey != NULL);\n\t\tkeep_partdesc = equalPartitionDescs(relation->rd_partkey,\n\t\t\t\t\t\t\t\t\t\t\trelation->rd_partdesc,\n\t\t\t\t\t\t\t\t\t\t\tnewrel->rd_partdesc);\n\n\t\t/*\n\t\t * Perform swapping of the relcache entry contents.  Within this\n\t\t * process the old entry is momentarily invalid, so there *must* be no\n\t\t * possibility of CHECK_FOR_INTERRUPTS within this sequence. Do it in\n\t\t * all-in-line code for safety.\n\t\t *\n\t\t * Since the vast majority of fields should be swapped, our method is\n\t\t * to swap the whole structures and then re-swap those few fields we\n\t\t * didn't want swapped.\n\t\t */\n#define SWAPFIELD(fldtype, fldname) \\\n\t\tdo { \\\n\t\t\tfldtype _tmp = newrel->fldname; \\\n\t\t\tnewrel->fldname = relation->fldname; \\\n\t\t\trelation->fldname = _tmp; \\\n\t\t} while (0)\n\n\t\t/* swap all Relation struct fields */\n\t\t{\n\t\t\tRelationData tmpstruct;\n\n\t\t\tmemcpy(&tmpstruct, newrel, sizeof(RelationData));\n\t\t\tmemcpy(newrel, relation, sizeof(RelationData));\n\t\t\tmemcpy(relation, &tmpstruct, sizeof(RelationData));\n\t\t}\n\n\t\t/* rd_smgr must not be swapped, due to back-links from smgr level */\n\t\tSWAPFIELD(SMgrRelation, rd_smgr);\n\t\t/* rd_refcnt must be preserved */\n\t\tSWAPFIELD(int, rd_refcnt);\n\t\t/* isnailed shouldn't change */\n\t\tAssert(newrel->rd_isnailed == relation->rd_isnailed);\n\t\t/* creation sub-XIDs must be preserved */\n\t\tSWAPFIELD(SubTransactionId, rd_createSubid);\n\t\tSWAPFIELD(SubTransactionId, rd_newRelfilenodeSubid);\n\t\t/* un-swap rd_rel pointers, swap contents instead */\n\t\tSWAPFIELD(Form_pg_class, rd_rel);\n\t\t/* ... but actually, we don't have to update newrel->rd_rel */\n\t\tmemcpy(relation->rd_rel, newrel->rd_rel, CLASS_TUPLE_SIZE);\n\t\t/* preserve old tupledesc, rules, policies if no logical change */\n\t\tif (keep_tupdesc)\n\t\t\tSWAPFIELD(TupleDesc, rd_att);\n\t\tif (keep_rules)\n\t\t{\n\t\t\tSWAPFIELD(RuleLock *, rd_rules);\n\t\t\tSWAPFIELD(MemoryContext, rd_rulescxt);\n\t\t}\n\t\tif (keep_policies)\n\t\t\tSWAPFIELD(RowSecurityDesc *, rd_rsdesc);\n\t\t/* toast OID override must be preserved */\n\t\tSWAPFIELD(Oid, rd_toastoid);\n\t\t/* pgstat_info must be preserved */\n\t\tSWAPFIELD(struct PgStat_TableStatus *, pgstat_info);\n\t\t/* preserve old partitioning info if no logical change */\n\t\tif (keep_partkey)\n\t\t{\n\t\t\tSWAPFIELD(PartitionKey, rd_partkey);\n\t\t\tSWAPFIELD(MemoryContext, rd_partkeycxt);\n\t\t}\n\t\tif (keep_partdesc)\n\t\t{\n\t\t\tSWAPFIELD(PartitionDesc, rd_partdesc);\n\t\t\tSWAPFIELD(MemoryContext, rd_pdcxt);\n\t\t}\n\n#undef SWAPFIELD\n\n\t\t/* And now we can throw away the temporary entry */\n\t\tRelationDestroyRelation(newrel, !keep_tupdesc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationHasReferenceCountZero",
          "args": [
            "relation"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationDecrementReferenceCount",
          "args": [
            "relation"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "RelationDecrementReferenceCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1988-1995",
          "snippet": "void\nRelationDecrementReferenceCount(Relation rel)\n{\n\tAssert(rel->rd_refcnt > 0);\n\trel->rd_refcnt -= 1;\n\tif (!IsBootstrapProcessingMode())\n\t\tResourceOwnerForgetRelationRef(CurrentResourceOwner, rel);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nvoid\nRelationDecrementReferenceCount(Relation rel)\n{\n\tAssert(rel->rd_refcnt > 0);\n\trel->rd_refcnt -= 1;\n\tif (!IsBootstrapProcessingMode())\n\t\tResourceOwnerForgetRelationRef(CurrentResourceOwner, rel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationIncrementReferenceCount",
          "args": [
            "relation"
          ],
          "line": 2576
        },
        "resolved": true,
        "details": {
          "function_name": "RelationIncrementReferenceCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1975-1982",
          "snippet": "void\nRelationIncrementReferenceCount(Relation rel)\n{\n\tResourceOwnerEnlargeRelationRefs(CurrentResourceOwner);\n\trel->rd_refcnt += 1;\n\tif (!IsBootstrapProcessingMode())\n\t\tResourceOwnerRememberRelationRef(CurrentResourceOwner, rel);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nvoid\nRelationIncrementReferenceCount(Relation rel)\n{\n\tResourceOwnerEnlargeRelationRefs(CurrentResourceOwner);\n\trel->rd_refcnt += 1;\n\tif (!IsBootstrapProcessingMode())\n\t\tResourceOwnerRememberRelationRef(CurrentResourceOwner, rel);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationClearRelation(Relation relation, bool rebuild);\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationFlushRelation(Relation relation)\n{\n\tif (relation->rd_createSubid != InvalidSubTransactionId ||\n\t\trelation->rd_newRelfilenodeSubid != InvalidSubTransactionId)\n\t{\n\t\t/*\n\t\t * New relcache entries are always rebuilt, not flushed; else we'd\n\t\t * forget the \"new\" status of the relation, which is a useful\n\t\t * optimization to have.  Ditto for the new-relfilenode status.\n\t\t *\n\t\t * The rel could have zero refcnt here, so temporarily increment the\n\t\t * refcnt to ensure it's safe to rebuild it.  We can assume that the\n\t\t * current transaction has some lock on the rel already.\n\t\t */\n\t\tRelationIncrementReferenceCount(relation);\n\t\tRelationClearRelation(relation, true);\n\t\tRelationDecrementReferenceCount(relation);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Pre-existing rels can be dropped from the relcache if not open.\n\t\t */\n\t\tbool\t\trebuild = !RelationHasReferenceCountZero(relation);\n\n\t\tRelationClearRelation(relation, rebuild);\n\t}\n}"
  },
  {
    "function_name": "RelationClearRelation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "2318-2553",
    "snippet": "static void\nRelationClearRelation(Relation relation, bool rebuild)\n{\n\t/*\n\t * As per notes above, a rel to be rebuilt MUST have refcnt > 0; while of\n\t * course it would be an equally bad idea to blow away one with nonzero\n\t * refcnt, since that would leave someone somewhere with a dangling\n\t * pointer.  All callers are expected to have verified that this holds.\n\t */\n\tAssert(rebuild ?\n\t\t   !RelationHasReferenceCountZero(relation) :\n\t\t   RelationHasReferenceCountZero(relation));\n\n\t/*\n\t * Make sure smgr and lower levels close the relation's files, if they\n\t * weren't closed already.  If the relation is not getting deleted, the\n\t * next smgr access should reopen the files automatically.  This ensures\n\t * that the low-level file access state is updated after, say, a vacuum\n\t * truncation.\n\t */\n\tRelationCloseSmgr(relation);\n\n\t/*\n\t * Treat nailed-in system relations separately, they always need to be\n\t * accessible, so we can't blow them away.\n\t */\n\tif (relation->rd_isnailed)\n\t{\n\t\tRelationReloadNailed(relation);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even non-system indexes should not be blown away if they are open and\n\t * have valid index support information.  This avoids problems with active\n\t * use of the index support information.  As with nailed indexes, we\n\t * re-read the pg_class row to handle possible physical relocation of the\n\t * index, and we check for pg_index updates too.\n\t */\n\tif ((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t relation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\trelation->rd_refcnt > 0 &&\n\t\trelation->rd_indexcxt != NULL)\n\t{\n\t\trelation->rd_isvalid = false;\t/* needs to be revalidated */\n\t\tif (IsTransactionState())\n\t\t\tRelationReloadIndexInfo(relation);\n\t\treturn;\n\t}\n\n\t/* Mark it invalid until we've finished rebuild */\n\trelation->rd_isvalid = false;\n\n\t/*\n\t * If we're really done with the relcache entry, blow it away. But if\n\t * someone is still using it, reconstruct the whole deal without moving\n\t * the physical RelationData record (so that the someone's pointer is\n\t * still valid).\n\t */\n\tif (!rebuild)\n\t{\n\t\t/* Remove it from the hash table */\n\t\tRelationCacheDelete(relation);\n\n\t\t/* And release storage */\n\t\tRelationDestroyRelation(relation, false);\n\t}\n\telse if (!IsTransactionState())\n\t{\n\t\t/*\n\t\t * If we're not inside a valid transaction, we can't do any catalog\n\t\t * access so it's not possible to rebuild yet.  Just exit, leaving\n\t\t * rd_isvalid = false so that the rebuild will occur when the entry is\n\t\t * next opened.\n\t\t *\n\t\t * Note: it's possible that we come here during subtransaction abort,\n\t\t * and the reason for wanting to rebuild is that the rel is open in\n\t\t * the outer transaction.  In that case it might seem unsafe to not\n\t\t * rebuild immediately, since whatever code has the rel already open\n\t\t * will keep on using the relcache entry as-is.  However, in such a\n\t\t * case the outer transaction should be holding a lock that's\n\t\t * sufficient to prevent any significant change in the rel's schema,\n\t\t * so the existing entry contents should be good enough for its\n\t\t * purposes; at worst we might be behind on statistics updates or the\n\t\t * like.  (See also CheckTableNotInUse() and its callers.)\tThese same\n\t\t * remarks also apply to the cases above where we exit without having\n\t\t * done RelationReloadIndexInfo() yet.\n\t\t */\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Our strategy for rebuilding an open relcache entry is to build a\n\t\t * new entry from scratch, swap its contents with the old entry, and\n\t\t * finally delete the new entry (along with any infrastructure swapped\n\t\t * over from the old entry).  This is to avoid trouble in case an\n\t\t * error causes us to lose control partway through.  The old entry\n\t\t * will still be marked !rd_isvalid, so we'll try to rebuild it again\n\t\t * on next access.  Meanwhile it's not any less valid than it was\n\t\t * before, so any code that might expect to continue accessing it\n\t\t * isn't hurt by the rebuild failure.  (Consider for example a\n\t\t * subtransaction that ALTERs a table and then gets canceled partway\n\t\t * through the cache entry rebuild.  The outer transaction should\n\t\t * still see the not-modified cache entry as valid.)  The worst\n\t\t * consequence of an error is leaking the necessarily-unreferenced new\n\t\t * entry, and this shouldn't happen often enough for that to be a big\n\t\t * problem.\n\t\t *\n\t\t * When rebuilding an open relcache entry, we must preserve ref count,\n\t\t * rd_createSubid/rd_newRelfilenodeSubid, and rd_toastoid state.  Also\n\t\t * attempt to preserve the pg_class entry (rd_rel), tupledesc,\n\t\t * rewrite-rule, partition key, and partition descriptor substructures\n\t\t * in place, because various places assume that these structures won't\n\t\t * move while they are working with an open relcache entry.  (Note:\n\t\t * the refcount mechanism for tupledescs might someday allow us to\n\t\t * remove this hack for the tupledesc.)\n\t\t *\n\t\t * Note that this process does not touch CurrentResourceOwner; which\n\t\t * is good because whatever ref counts the entry may have do not\n\t\t * necessarily belong to that resource owner.\n\t\t */\n\t\tRelation\tnewrel;\n\t\tOid\t\t\tsave_relid = RelationGetRelid(relation);\n\t\tbool\t\tkeep_tupdesc;\n\t\tbool\t\tkeep_rules;\n\t\tbool\t\tkeep_policies;\n\t\tbool\t\tkeep_partkey;\n\t\tbool\t\tkeep_partdesc;\n\n\t\t/* Build temporary entry, but don't link it into hashtable */\n\t\tnewrel = RelationBuildDesc(save_relid, false);\n\t\tif (newrel == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * We can validly get here, if we're using a historic snapshot in\n\t\t\t * which a relation, accessed from outside logical decoding, is\n\t\t\t * still invisible. In that case it's fine to just mark the\n\t\t\t * relation as invalid and return - it'll fully get reloaded by\n\t\t\t * the cache reset at the end of logical decoding (or at the next\n\t\t\t * access).  During normal processing we don't want to ignore this\n\t\t\t * case as it shouldn't happen there, as explained below.\n\t\t\t */\n\t\t\tif (HistoricSnapshotActive())\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * This shouldn't happen as dropping a relation is intended to be\n\t\t\t * impossible if still referenced (cf. CheckTableNotInUse()). But\n\t\t\t * if we get here anyway, we can't just delete the relcache entry,\n\t\t\t * as it possibly could get accessed later (as e.g. the error\n\t\t\t * might get trapped and handled via a subtransaction rollback).\n\t\t\t */\n\t\t\telog(ERROR, \"relation %u deleted while still in use\", save_relid);\n\t\t}\n\n\t\tkeep_tupdesc = equalTupleDescs(relation->rd_att, newrel->rd_att);\n\t\tkeep_rules = equalRuleLocks(relation->rd_rules, newrel->rd_rules);\n\t\tkeep_policies = equalRSDesc(relation->rd_rsdesc, newrel->rd_rsdesc);\n\t\t/* partkey is immutable once set up, so we can always keep it */\n\t\tkeep_partkey = (relation->rd_partkey != NULL);\n\t\tkeep_partdesc = equalPartitionDescs(relation->rd_partkey,\n\t\t\t\t\t\t\t\t\t\t\trelation->rd_partdesc,\n\t\t\t\t\t\t\t\t\t\t\tnewrel->rd_partdesc);\n\n\t\t/*\n\t\t * Perform swapping of the relcache entry contents.  Within this\n\t\t * process the old entry is momentarily invalid, so there *must* be no\n\t\t * possibility of CHECK_FOR_INTERRUPTS within this sequence. Do it in\n\t\t * all-in-line code for safety.\n\t\t *\n\t\t * Since the vast majority of fields should be swapped, our method is\n\t\t * to swap the whole structures and then re-swap those few fields we\n\t\t * didn't want swapped.\n\t\t */\n#define SWAPFIELD(fldtype, fldname) \\\n\t\tdo { \\\n\t\t\tfldtype _tmp = newrel->fldname; \\\n\t\t\tnewrel->fldname = relation->fldname; \\\n\t\t\trelation->fldname = _tmp; \\\n\t\t} while (0)\n\n\t\t/* swap all Relation struct fields */\n\t\t{\n\t\t\tRelationData tmpstruct;\n\n\t\t\tmemcpy(&tmpstruct, newrel, sizeof(RelationData));\n\t\t\tmemcpy(newrel, relation, sizeof(RelationData));\n\t\t\tmemcpy(relation, &tmpstruct, sizeof(RelationData));\n\t\t}\n\n\t\t/* rd_smgr must not be swapped, due to back-links from smgr level */\n\t\tSWAPFIELD(SMgrRelation, rd_smgr);\n\t\t/* rd_refcnt must be preserved */\n\t\tSWAPFIELD(int, rd_refcnt);\n\t\t/* isnailed shouldn't change */\n\t\tAssert(newrel->rd_isnailed == relation->rd_isnailed);\n\t\t/* creation sub-XIDs must be preserved */\n\t\tSWAPFIELD(SubTransactionId, rd_createSubid);\n\t\tSWAPFIELD(SubTransactionId, rd_newRelfilenodeSubid);\n\t\t/* un-swap rd_rel pointers, swap contents instead */\n\t\tSWAPFIELD(Form_pg_class, rd_rel);\n\t\t/* ... but actually, we don't have to update newrel->rd_rel */\n\t\tmemcpy(relation->rd_rel, newrel->rd_rel, CLASS_TUPLE_SIZE);\n\t\t/* preserve old tupledesc, rules, policies if no logical change */\n\t\tif (keep_tupdesc)\n\t\t\tSWAPFIELD(TupleDesc, rd_att);\n\t\tif (keep_rules)\n\t\t{\n\t\t\tSWAPFIELD(RuleLock *, rd_rules);\n\t\t\tSWAPFIELD(MemoryContext, rd_rulescxt);\n\t\t}\n\t\tif (keep_policies)\n\t\t\tSWAPFIELD(RowSecurityDesc *, rd_rsdesc);\n\t\t/* toast OID override must be preserved */\n\t\tSWAPFIELD(Oid, rd_toastoid);\n\t\t/* pgstat_info must be preserved */\n\t\tSWAPFIELD(struct PgStat_TableStatus *, pgstat_info);\n\t\t/* preserve old partitioning info if no logical change */\n\t\tif (keep_partkey)\n\t\t{\n\t\t\tSWAPFIELD(PartitionKey, rd_partkey);\n\t\t\tSWAPFIELD(MemoryContext, rd_partkeycxt);\n\t\t}\n\t\tif (keep_partdesc)\n\t\t{\n\t\t\tSWAPFIELD(PartitionDesc, rd_partdesc);\n\t\t\tSWAPFIELD(MemoryContext, rd_pdcxt);\n\t\t}\n\n#undef SWAPFIELD\n\n\t\t/* And now we can throw away the temporary entry */\n\t\tRelationDestroyRelation(newrel, !keep_tupdesc);\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationClearRelation(Relation relation, bool rebuild);",
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RelationDestroyRelation",
          "args": [
            "newrel",
            "!keep_tupdesc"
          ],
          "line": 2551
        },
        "resolved": true,
        "details": {
          "function_name": "RelationDestroyRelation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2232-2297",
          "snippet": "static void\nRelationDestroyRelation(Relation relation, bool remember_tupdesc)\n{\n\tAssert(RelationHasReferenceCountZero(relation));\n\n\t/*\n\t * Make sure smgr and lower levels close the relation's files, if they\n\t * weren't closed already.  (This was probably done by caller, but let's\n\t * just be real sure.)\n\t */\n\tRelationCloseSmgr(relation);\n\n\t/*\n\t * Free all the subsidiary data structures of the relcache entry, then the\n\t * entry itself.\n\t */\n\tif (relation->rd_rel)\n\t\tpfree(relation->rd_rel);\n\t/* can't use DecrTupleDescRefCount here */\n\tAssert(relation->rd_att->tdrefcount > 0);\n\tif (--relation->rd_att->tdrefcount == 0)\n\t{\n\t\t/*\n\t\t * If we Rebuilt a relcache entry during a transaction then its\n\t\t * possible we did that because the TupDesc changed as the result of\n\t\t * an ALTER TABLE that ran at less than AccessExclusiveLock. It's\n\t\t * possible someone copied that TupDesc, in which case the copy would\n\t\t * point to free'd memory. So if we rebuild an entry we keep the\n\t\t * TupDesc around until end of transaction, to be safe.\n\t\t */\n\t\tif (remember_tupdesc)\n\t\t\tRememberToFreeTupleDescAtEOX(relation->rd_att);\n\t\telse\n\t\t\tFreeTupleDesc(relation->rd_att);\n\t}\n\tFreeTriggerDesc(relation->trigdesc);\n\tlist_free_deep(relation->rd_fkeylist);\n\tlist_free(relation->rd_indexlist);\n\tbms_free(relation->rd_indexattr);\n\tbms_free(relation->rd_projindexattr);\n\tbms_free(relation->rd_keyattr);\n\tbms_free(relation->rd_pkattr);\n\tbms_free(relation->rd_idattr);\n\tbms_free(relation->rd_projidx);\n\tif (relation->rd_pubactions)\n\t\tpfree(relation->rd_pubactions);\n\tif (relation->rd_options)\n\t\tpfree(relation->rd_options);\n\tif (relation->rd_indextuple)\n\t\tpfree(relation->rd_indextuple);\n\tif (relation->rd_indexcxt)\n\t\tMemoryContextDelete(relation->rd_indexcxt);\n\tif (relation->rd_rulescxt)\n\t\tMemoryContextDelete(relation->rd_rulescxt);\n\tif (relation->rd_rsdesc)\n\t\tMemoryContextDelete(relation->rd_rsdesc->rscxt);\n\tif (relation->rd_partkeycxt)\n\t\tMemoryContextDelete(relation->rd_partkeycxt);\n\tif (relation->rd_pdcxt)\n\t\tMemoryContextDelete(relation->rd_pdcxt);\n\tif (relation->rd_partcheckcxt)\n\t\tMemoryContextDelete(relation->rd_partcheckcxt);\n\tif (relation->rd_fdwroutine)\n\t\tpfree(relation->rd_fdwroutine);\n\tpfree(relation);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationDestroyRelation(Relation relation, bool remember_tupdesc);",
            "static void RelationClearRelation(Relation relation, bool rebuild);",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationDestroyRelation(Relation relation, bool remember_tupdesc);\nstatic void RelationClearRelation(Relation relation, bool rebuild);\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationDestroyRelation(Relation relation, bool remember_tupdesc)\n{\n\tAssert(RelationHasReferenceCountZero(relation));\n\n\t/*\n\t * Make sure smgr and lower levels close the relation's files, if they\n\t * weren't closed already.  (This was probably done by caller, but let's\n\t * just be real sure.)\n\t */\n\tRelationCloseSmgr(relation);\n\n\t/*\n\t * Free all the subsidiary data structures of the relcache entry, then the\n\t * entry itself.\n\t */\n\tif (relation->rd_rel)\n\t\tpfree(relation->rd_rel);\n\t/* can't use DecrTupleDescRefCount here */\n\tAssert(relation->rd_att->tdrefcount > 0);\n\tif (--relation->rd_att->tdrefcount == 0)\n\t{\n\t\t/*\n\t\t * If we Rebuilt a relcache entry during a transaction then its\n\t\t * possible we did that because the TupDesc changed as the result of\n\t\t * an ALTER TABLE that ran at less than AccessExclusiveLock. It's\n\t\t * possible someone copied that TupDesc, in which case the copy would\n\t\t * point to free'd memory. So if we rebuild an entry we keep the\n\t\t * TupDesc around until end of transaction, to be safe.\n\t\t */\n\t\tif (remember_tupdesc)\n\t\t\tRememberToFreeTupleDescAtEOX(relation->rd_att);\n\t\telse\n\t\t\tFreeTupleDesc(relation->rd_att);\n\t}\n\tFreeTriggerDesc(relation->trigdesc);\n\tlist_free_deep(relation->rd_fkeylist);\n\tlist_free(relation->rd_indexlist);\n\tbms_free(relation->rd_indexattr);\n\tbms_free(relation->rd_projindexattr);\n\tbms_free(relation->rd_keyattr);\n\tbms_free(relation->rd_pkattr);\n\tbms_free(relation->rd_idattr);\n\tbms_free(relation->rd_projidx);\n\tif (relation->rd_pubactions)\n\t\tpfree(relation->rd_pubactions);\n\tif (relation->rd_options)\n\t\tpfree(relation->rd_options);\n\tif (relation->rd_indextuple)\n\t\tpfree(relation->rd_indextuple);\n\tif (relation->rd_indexcxt)\n\t\tMemoryContextDelete(relation->rd_indexcxt);\n\tif (relation->rd_rulescxt)\n\t\tMemoryContextDelete(relation->rd_rulescxt);\n\tif (relation->rd_rsdesc)\n\t\tMemoryContextDelete(relation->rd_rsdesc->rscxt);\n\tif (relation->rd_partkeycxt)\n\t\tMemoryContextDelete(relation->rd_partkeycxt);\n\tif (relation->rd_pdcxt)\n\t\tMemoryContextDelete(relation->rd_pdcxt);\n\tif (relation->rd_partcheckcxt)\n\t\tMemoryContextDelete(relation->rd_partcheckcxt);\n\tif (relation->rd_fdwroutine)\n\t\tpfree(relation->rd_fdwroutine);\n\tpfree(relation);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SWAPFIELD",
          "args": [
            "MemoryContext",
            "rd_pdcxt"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAPFIELD",
          "args": [
            "PartitionDesc",
            "rd_partdesc"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAPFIELD",
          "args": [
            "MemoryContext",
            "rd_partkeycxt"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAPFIELD",
          "args": [
            "PartitionKey",
            "rd_partkey"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAPFIELD",
          "args": [
            "Oid",
            "rd_toastoid"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAPFIELD",
          "args": [
            "RowSecurityDesc *, rd_rsdesc"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAPFIELD",
          "args": [
            "MemoryContext",
            "rd_rulescxt"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAPFIELD",
          "args": [
            "TupleDesc",
            "rd_att"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "relation->rd_rel",
            "newrel->rd_rel",
            "CLASS_TUPLE_SIZE"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAPFIELD",
          "args": [
            "Form_pg_class",
            "rd_rel"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAPFIELD",
          "args": [
            "SubTransactionId",
            "rd_newRelfilenodeSubid"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAPFIELD",
          "args": [
            "SubTransactionId",
            "rd_createSubid"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "newrel->rd_isnailed == relation->rd_isnailed"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAPFIELD",
          "args": [
            "int",
            "rd_refcnt"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWAPFIELD",
          "args": [
            "SMgrRelation",
            "rd_smgr"
          ],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "relation",
            "&tmpstruct",
            "sizeof(RelationData)"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "newrel",
            "relation",
            "sizeof(RelationData)"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tmpstruct",
            "newrel",
            "sizeof(RelationData)"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "equalPartitionDescs",
          "args": [
            "relation->rd_partkey",
            "relation->rd_partdesc",
            "newrel->rd_partdesc"
          ],
          "line": 2479
        },
        "resolved": true,
        "details": {
          "function_name": "equalPartitionDescs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1008-1056",
          "snippet": "static bool\nequalPartitionDescs(PartitionKey key, PartitionDesc partdesc1,\n\t\t\t\t\tPartitionDesc partdesc2)\n{\n\tint\t\t\ti;\n\n\tif (partdesc1 != NULL)\n\t{\n\t\tif (partdesc2 == NULL)\n\t\t\treturn false;\n\t\tif (partdesc1->nparts != partdesc2->nparts)\n\t\t\treturn false;\n\n\t\tAssert(key != NULL || partdesc1->nparts == 0);\n\n\t\t/*\n\t\t * Same oids? If the partitioning structure did not change, that is,\n\t\t * no partitions were added or removed to the relation, the oids array\n\t\t * should still match element-by-element.\n\t\t */\n\t\tfor (i = 0; i < partdesc1->nparts; i++)\n\t\t{\n\t\t\tif (partdesc1->oids[i] != partdesc2->oids[i])\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t * Now compare partition bound collections.  The logic to iterate over\n\t\t * the collections is private to partition.c.\n\t\t */\n\t\tif (partdesc1->boundinfo != NULL)\n\t\t{\n\t\t\tif (partdesc2->boundinfo == NULL)\n\t\t\t\treturn false;\n\n\t\t\tif (!partition_bounds_equal(key->partnatts, key->parttyplen,\n\t\t\t\t\t\t\t\t\t\tkey->parttypbyval,\n\t\t\t\t\t\t\t\t\t\tpartdesc1->boundinfo,\n\t\t\t\t\t\t\t\t\t\tpartdesc2->boundinfo))\n\t\t\t\treturn false;\n\t\t}\n\t\telse if (partdesc2->boundinfo != NULL)\n\t\t\treturn false;\n\t}\n\telse if (partdesc2 != NULL)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);",
            "static bool equalPartitionDescs(PartitionKey key, PartitionDesc partdesc1,\n\t\t\t\t\tPartitionDesc partdesc2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\nstatic bool equalPartitionDescs(PartitionKey key, PartitionDesc partdesc1,\n\t\t\t\t\tPartitionDesc partdesc2);\n\nstatic bool\nequalPartitionDescs(PartitionKey key, PartitionDesc partdesc1,\n\t\t\t\t\tPartitionDesc partdesc2)\n{\n\tint\t\t\ti;\n\n\tif (partdesc1 != NULL)\n\t{\n\t\tif (partdesc2 == NULL)\n\t\t\treturn false;\n\t\tif (partdesc1->nparts != partdesc2->nparts)\n\t\t\treturn false;\n\n\t\tAssert(key != NULL || partdesc1->nparts == 0);\n\n\t\t/*\n\t\t * Same oids? If the partitioning structure did not change, that is,\n\t\t * no partitions were added or removed to the relation, the oids array\n\t\t * should still match element-by-element.\n\t\t */\n\t\tfor (i = 0; i < partdesc1->nparts; i++)\n\t\t{\n\t\t\tif (partdesc1->oids[i] != partdesc2->oids[i])\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t * Now compare partition bound collections.  The logic to iterate over\n\t\t * the collections is private to partition.c.\n\t\t */\n\t\tif (partdesc1->boundinfo != NULL)\n\t\t{\n\t\t\tif (partdesc2->boundinfo == NULL)\n\t\t\t\treturn false;\n\n\t\t\tif (!partition_bounds_equal(key->partnatts, key->parttyplen,\n\t\t\t\t\t\t\t\t\t\tkey->parttypbyval,\n\t\t\t\t\t\t\t\t\t\tpartdesc1->boundinfo,\n\t\t\t\t\t\t\t\t\t\tpartdesc2->boundinfo))\n\t\t\t\treturn false;\n\t\t}\n\t\telse if (partdesc2->boundinfo != NULL)\n\t\t\treturn false;\n\t}\n\telse if (partdesc2 != NULL)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "equalRSDesc",
          "args": [
            "relation->rd_rsdesc",
            "newrel->rd_rsdesc"
          ],
          "line": 2476
        },
        "resolved": true,
        "details": {
          "function_name": "equalRSDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "975-1002",
          "snippet": "static bool\nequalRSDesc(RowSecurityDesc *rsdesc1, RowSecurityDesc *rsdesc2)\n{\n\tListCell   *lc,\n\t\t\t   *rc;\n\n\tif (rsdesc1 == NULL && rsdesc2 == NULL)\n\t\treturn true;\n\n\tif ((rsdesc1 != NULL && rsdesc2 == NULL) ||\n\t\t(rsdesc1 == NULL && rsdesc2 != NULL))\n\t\treturn false;\n\n\tif (list_length(rsdesc1->policies) != list_length(rsdesc2->policies))\n\t\treturn false;\n\n\t/* RelationBuildRowSecurity should build policies in order */\n\tforboth(lc, rsdesc1->policies, rc, rsdesc2->policies)\n\t{\n\t\tRowSecurityPolicy *l = (RowSecurityPolicy *) lfirst(lc);\n\t\tRowSecurityPolicy *r = (RowSecurityPolicy *) lfirst(rc);\n\n\t\tif (!equalPolicy(l, r))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic bool\nequalRSDesc(RowSecurityDesc *rsdesc1, RowSecurityDesc *rsdesc2)\n{\n\tListCell   *lc,\n\t\t\t   *rc;\n\n\tif (rsdesc1 == NULL && rsdesc2 == NULL)\n\t\treturn true;\n\n\tif ((rsdesc1 != NULL && rsdesc2 == NULL) ||\n\t\t(rsdesc1 == NULL && rsdesc2 != NULL))\n\t\treturn false;\n\n\tif (list_length(rsdesc1->policies) != list_length(rsdesc2->policies))\n\t\treturn false;\n\n\t/* RelationBuildRowSecurity should build policies in order */\n\tforboth(lc, rsdesc1->policies, rc, rsdesc2->policies)\n\t{\n\t\tRowSecurityPolicy *l = (RowSecurityPolicy *) lfirst(lc);\n\t\tRowSecurityPolicy *r = (RowSecurityPolicy *) lfirst(rc);\n\n\t\tif (!equalPolicy(l, r))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "equalRuleLocks",
          "args": [
            "relation->rd_rules",
            "newrel->rd_rules"
          ],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "equalRuleLocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "884-922",
          "snippet": "static bool\nequalRuleLocks(RuleLock *rlock1, RuleLock *rlock2)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * As of 7.3 we assume the rule ordering is repeatable, because\n\t * RelationBuildRuleLock should read 'em in a consistent order.  So just\n\t * compare corresponding slots.\n\t */\n\tif (rlock1 != NULL)\n\t{\n\t\tif (rlock2 == NULL)\n\t\t\treturn false;\n\t\tif (rlock1->numLocks != rlock2->numLocks)\n\t\t\treturn false;\n\t\tfor (i = 0; i < rlock1->numLocks; i++)\n\t\t{\n\t\t\tRewriteRule *rule1 = rlock1->rules[i];\n\t\t\tRewriteRule *rule2 = rlock2->rules[i];\n\n\t\t\tif (rule1->ruleId != rule2->ruleId)\n\t\t\t\treturn false;\n\t\t\tif (rule1->event != rule2->event)\n\t\t\t\treturn false;\n\t\t\tif (rule1->enabled != rule2->enabled)\n\t\t\t\treturn false;\n\t\t\tif (rule1->isInstead != rule2->isInstead)\n\t\t\t\treturn false;\n\t\t\tif (!equal(rule1->qual, rule2->qual))\n\t\t\t\treturn false;\n\t\t\tif (!equal(rule1->actions, rule2->actions))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\telse if (rlock2 != NULL)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic bool\nequalRuleLocks(RuleLock *rlock1, RuleLock *rlock2)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * As of 7.3 we assume the rule ordering is repeatable, because\n\t * RelationBuildRuleLock should read 'em in a consistent order.  So just\n\t * compare corresponding slots.\n\t */\n\tif (rlock1 != NULL)\n\t{\n\t\tif (rlock2 == NULL)\n\t\t\treturn false;\n\t\tif (rlock1->numLocks != rlock2->numLocks)\n\t\t\treturn false;\n\t\tfor (i = 0; i < rlock1->numLocks; i++)\n\t\t{\n\t\t\tRewriteRule *rule1 = rlock1->rules[i];\n\t\t\tRewriteRule *rule2 = rlock2->rules[i];\n\n\t\t\tif (rule1->ruleId != rule2->ruleId)\n\t\t\t\treturn false;\n\t\t\tif (rule1->event != rule2->event)\n\t\t\t\treturn false;\n\t\t\tif (rule1->enabled != rule2->enabled)\n\t\t\t\treturn false;\n\t\t\tif (rule1->isInstead != rule2->isInstead)\n\t\t\t\treturn false;\n\t\t\tif (!equal(rule1->qual, rule2->qual))\n\t\t\t\treturn false;\n\t\t\tif (!equal(rule1->actions, rule2->actions))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\telse if (rlock2 != NULL)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "equalTupleDescs",
          "args": [
            "relation->rd_att",
            "newrel->rd_att"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"relation %u deleted while still in use\"",
            "save_relid"
          ],
          "line": 2471
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HistoricSnapshotActive",
          "args": [],
          "line": 2461
        },
        "resolved": true,
        "details": {
          "function_name": "HistoricSnapshotActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "2023-2027",
          "snippet": "bool\nHistoricSnapshotActive(void)\n{\n\treturn HistoricSnapshot != NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot HistoricSnapshot = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot HistoricSnapshot = NULL;\n\nbool\nHistoricSnapshotActive(void)\n{\n\treturn HistoricSnapshot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationBuildDesc",
          "args": [
            "save_relid",
            "false"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "RelationBuildDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1070-1250",
          "snippet": "static Relation\nRelationBuildDesc(Oid targetRelId, bool insertIt)\n{\n\tRelation\trelation;\n\tOid\t\t\trelid;\n\tHeapTuple\tpg_class_tuple;\n\tForm_pg_class relp;\n\n\t/*\n\t * find the tuple in pg_class corresponding to the given relation id\n\t */\n\tpg_class_tuple = ScanPgRelation(targetRelId, true, false);\n\n\t/*\n\t * if no such tuple exists, return NULL\n\t */\n\tif (!HeapTupleIsValid(pg_class_tuple))\n\t\treturn NULL;\n\n\t/*\n\t * get information from the pg_class_tuple\n\t */\n\trelid = HeapTupleGetOid(pg_class_tuple);\n\trelp = (Form_pg_class) GETSTRUCT(pg_class_tuple);\n\tAssert(relid == targetRelId);\n\n\t/*\n\t * allocate storage for the relation descriptor, and copy pg_class_tuple\n\t * to relation->rd_rel.\n\t */\n\trelation = AllocateRelationDesc(relp);\n\n\t/*\n\t * initialize the relation's relation id (relation->rd_id)\n\t */\n\tRelationGetRelid(relation) = relid;\n\n\t/*\n\t * normal relations are not nailed into the cache; nor can a pre-existing\n\t * relation be new.  It could be temp though.  (Actually, it could be new\n\t * too, but it's okay to forget that fact if forced to flush the entry.)\n\t */\n\trelation->rd_refcnt = 0;\n\trelation->rd_isnailed = false;\n\trelation->rd_createSubid = InvalidSubTransactionId;\n\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\tswitch (relation->rd_rel->relpersistence)\n\t{\n\t\tcase RELPERSISTENCE_UNLOGGED:\n\t\tcase RELPERSISTENCE_PERMANENT:\n\t\t\trelation->rd_backend = InvalidBackendId;\n\t\t\trelation->rd_islocaltemp = false;\n\t\t\tbreak;\n\t\tcase RELPERSISTENCE_TEMP:\n\t\t\tif (isTempOrTempToastNamespace(relation->rd_rel->relnamespace))\n\t\t\t{\n\t\t\t\trelation->rd_backend = BackendIdForTempRelations();\n\t\t\t\trelation->rd_islocaltemp = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If it's a temp table, but not one of ours, we have to use\n\t\t\t\t * the slow, grotty method to figure out the owning backend.\n\t\t\t\t *\n\t\t\t\t * Note: it's possible that rd_backend gets set to MyBackendId\n\t\t\t\t * here, in case we are looking at a pg_class entry left over\n\t\t\t\t * from a crashed backend that coincidentally had the same\n\t\t\t\t * BackendId we're using.  We should *not* consider such a\n\t\t\t\t * table to be \"ours\"; this is why we need the separate\n\t\t\t\t * rd_islocaltemp flag.  The pg_class entry will get flushed\n\t\t\t\t * if/when we clean out the corresponding temp table namespace\n\t\t\t\t * in preparation for using it.\n\t\t\t\t */\n\t\t\t\trelation->rd_backend =\n\t\t\t\t\tGetTempNamespaceBackendId(relation->rd_rel->relnamespace);\n\t\t\t\tAssert(relation->rd_backend != InvalidBackendId);\n\t\t\t\trelation->rd_islocaltemp = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid relpersistence: %c\",\n\t\t\t\t relation->rd_rel->relpersistence);\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * initialize the tuple descriptor (relation->rd_att).\n\t */\n\tRelationBuildTupleDesc(relation);\n\n\t/*\n\t * Fetch rules and triggers that affect this relation\n\t */\n\tif (relation->rd_rel->relhasrules)\n\t\tRelationBuildRuleLock(relation);\n\telse\n\t{\n\t\trelation->rd_rules = NULL;\n\t\trelation->rd_rulescxt = NULL;\n\t}\n\n\tif (relation->rd_rel->relhastriggers)\n\t\tRelationBuildTriggers(relation);\n\telse\n\t\trelation->trigdesc = NULL;\n\n\tif (relation->rd_rel->relrowsecurity)\n\t\tRelationBuildRowSecurity(relation);\n\telse\n\t\trelation->rd_rsdesc = NULL;\n\n\t/* foreign key data is not loaded till asked for */\n\trelation->rd_fkeylist = NIL;\n\trelation->rd_fkeyvalid = false;\n\n\t/* if a partitioned table, initialize key and partition descriptor info */\n\tif (relation->rd_rel->relkind == RELKIND_PARTITIONED_TABLE)\n\t{\n\t\tRelationBuildPartitionKey(relation);\n\t\tRelationBuildPartitionDesc(relation);\n\t}\n\telse\n\t{\n\t\trelation->rd_partkey = NULL;\n\t\trelation->rd_partkeycxt = NULL;\n\t\trelation->rd_partdesc = NULL;\n\t\trelation->rd_pdcxt = NULL;\n\t}\n\t/* ... but partcheck is not loaded till asked for */\n\trelation->rd_partcheck = NIL;\n\trelation->rd_partcheckvalid = false;\n\trelation->rd_partcheckcxt = NULL;\n\n\t/*\n\t * if it's an index, initialize index-related information\n\t */\n\tif (OidIsValid(relation->rd_rel->relam))\n\t\tRelationInitIndexAccessInfo(relation);\n\n\t/* extract reloptions if any */\n\tRelationParseRelOptions(relation, pg_class_tuple);\n\n\t/*\n\t * initialize the relation lock manager information\n\t */\n\tRelationInitLockInfo(relation); /* see lmgr.c */\n\n\t/*\n\t * initialize physical addressing information for the relation\n\t */\n\tRelationInitPhysicalAddr(relation);\n\n\t/* make sure relation is marked as having no open file yet */\n\trelation->rd_smgr = NULL;\n\n\t/*\n\t * now we can free the memory allocated for pg_class_tuple\n\t */\n\theap_freetuple(pg_class_tuple);\n\n\t/*\n\t * Insert newly created relation into relcache hash table, if requested.\n\t *\n\t * There is one scenario in which we might find a hashtable entry already\n\t * present, even though our caller failed to find it: if the relation is a\n\t * system catalog or index that's used during relcache load, we might have\n\t * recursively created the same relcache entry during the preceding steps.\n\t * So allow RelationCacheInsert to delete any already-present relcache\n\t * entry for the same OID.  The already-present entry should have refcount\n\t * zero (else somebody forgot to close it); in the event that it doesn't,\n\t * we'll elog a WARNING and leak the already-present entry.\n\t */\n\tif (insertIt)\n\t\tRelationCacheInsert(relation, true);\n\n\t/* It's fully valid */\n\trelation->rd_isvalid = true;\n\n\treturn relation;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static Relation AllocateRelationDesc(Form_pg_class relp);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static Relation RelationBuildDesc(Oid targetRelId, bool insertIt);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic Relation AllocateRelationDesc(Form_pg_class relp);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic Relation RelationBuildDesc(Oid targetRelId, bool insertIt);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic Relation\nRelationBuildDesc(Oid targetRelId, bool insertIt)\n{\n\tRelation\trelation;\n\tOid\t\t\trelid;\n\tHeapTuple\tpg_class_tuple;\n\tForm_pg_class relp;\n\n\t/*\n\t * find the tuple in pg_class corresponding to the given relation id\n\t */\n\tpg_class_tuple = ScanPgRelation(targetRelId, true, false);\n\n\t/*\n\t * if no such tuple exists, return NULL\n\t */\n\tif (!HeapTupleIsValid(pg_class_tuple))\n\t\treturn NULL;\n\n\t/*\n\t * get information from the pg_class_tuple\n\t */\n\trelid = HeapTupleGetOid(pg_class_tuple);\n\trelp = (Form_pg_class) GETSTRUCT(pg_class_tuple);\n\tAssert(relid == targetRelId);\n\n\t/*\n\t * allocate storage for the relation descriptor, and copy pg_class_tuple\n\t * to relation->rd_rel.\n\t */\n\trelation = AllocateRelationDesc(relp);\n\n\t/*\n\t * initialize the relation's relation id (relation->rd_id)\n\t */\n\tRelationGetRelid(relation) = relid;\n\n\t/*\n\t * normal relations are not nailed into the cache; nor can a pre-existing\n\t * relation be new.  It could be temp though.  (Actually, it could be new\n\t * too, but it's okay to forget that fact if forced to flush the entry.)\n\t */\n\trelation->rd_refcnt = 0;\n\trelation->rd_isnailed = false;\n\trelation->rd_createSubid = InvalidSubTransactionId;\n\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\tswitch (relation->rd_rel->relpersistence)\n\t{\n\t\tcase RELPERSISTENCE_UNLOGGED:\n\t\tcase RELPERSISTENCE_PERMANENT:\n\t\t\trelation->rd_backend = InvalidBackendId;\n\t\t\trelation->rd_islocaltemp = false;\n\t\t\tbreak;\n\t\tcase RELPERSISTENCE_TEMP:\n\t\t\tif (isTempOrTempToastNamespace(relation->rd_rel->relnamespace))\n\t\t\t{\n\t\t\t\trelation->rd_backend = BackendIdForTempRelations();\n\t\t\t\trelation->rd_islocaltemp = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If it's a temp table, but not one of ours, we have to use\n\t\t\t\t * the slow, grotty method to figure out the owning backend.\n\t\t\t\t *\n\t\t\t\t * Note: it's possible that rd_backend gets set to MyBackendId\n\t\t\t\t * here, in case we are looking at a pg_class entry left over\n\t\t\t\t * from a crashed backend that coincidentally had the same\n\t\t\t\t * BackendId we're using.  We should *not* consider such a\n\t\t\t\t * table to be \"ours\"; this is why we need the separate\n\t\t\t\t * rd_islocaltemp flag.  The pg_class entry will get flushed\n\t\t\t\t * if/when we clean out the corresponding temp table namespace\n\t\t\t\t * in preparation for using it.\n\t\t\t\t */\n\t\t\t\trelation->rd_backend =\n\t\t\t\t\tGetTempNamespaceBackendId(relation->rd_rel->relnamespace);\n\t\t\t\tAssert(relation->rd_backend != InvalidBackendId);\n\t\t\t\trelation->rd_islocaltemp = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid relpersistence: %c\",\n\t\t\t\t relation->rd_rel->relpersistence);\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * initialize the tuple descriptor (relation->rd_att).\n\t */\n\tRelationBuildTupleDesc(relation);\n\n\t/*\n\t * Fetch rules and triggers that affect this relation\n\t */\n\tif (relation->rd_rel->relhasrules)\n\t\tRelationBuildRuleLock(relation);\n\telse\n\t{\n\t\trelation->rd_rules = NULL;\n\t\trelation->rd_rulescxt = NULL;\n\t}\n\n\tif (relation->rd_rel->relhastriggers)\n\t\tRelationBuildTriggers(relation);\n\telse\n\t\trelation->trigdesc = NULL;\n\n\tif (relation->rd_rel->relrowsecurity)\n\t\tRelationBuildRowSecurity(relation);\n\telse\n\t\trelation->rd_rsdesc = NULL;\n\n\t/* foreign key data is not loaded till asked for */\n\trelation->rd_fkeylist = NIL;\n\trelation->rd_fkeyvalid = false;\n\n\t/* if a partitioned table, initialize key and partition descriptor info */\n\tif (relation->rd_rel->relkind == RELKIND_PARTITIONED_TABLE)\n\t{\n\t\tRelationBuildPartitionKey(relation);\n\t\tRelationBuildPartitionDesc(relation);\n\t}\n\telse\n\t{\n\t\trelation->rd_partkey = NULL;\n\t\trelation->rd_partkeycxt = NULL;\n\t\trelation->rd_partdesc = NULL;\n\t\trelation->rd_pdcxt = NULL;\n\t}\n\t/* ... but partcheck is not loaded till asked for */\n\trelation->rd_partcheck = NIL;\n\trelation->rd_partcheckvalid = false;\n\trelation->rd_partcheckcxt = NULL;\n\n\t/*\n\t * if it's an index, initialize index-related information\n\t */\n\tif (OidIsValid(relation->rd_rel->relam))\n\t\tRelationInitIndexAccessInfo(relation);\n\n\t/* extract reloptions if any */\n\tRelationParseRelOptions(relation, pg_class_tuple);\n\n\t/*\n\t * initialize the relation lock manager information\n\t */\n\tRelationInitLockInfo(relation); /* see lmgr.c */\n\n\t/*\n\t * initialize physical addressing information for the relation\n\t */\n\tRelationInitPhysicalAddr(relation);\n\n\t/* make sure relation is marked as having no open file yet */\n\trelation->rd_smgr = NULL;\n\n\t/*\n\t * now we can free the memory allocated for pg_class_tuple\n\t */\n\theap_freetuple(pg_class_tuple);\n\n\t/*\n\t * Insert newly created relation into relcache hash table, if requested.\n\t *\n\t * There is one scenario in which we might find a hashtable entry already\n\t * present, even though our caller failed to find it: if the relation is a\n\t * system catalog or index that's used during relcache load, we might have\n\t * recursively created the same relcache entry during the preceding steps.\n\t * So allow RelationCacheInsert to delete any already-present relcache\n\t * entry for the same OID.  The already-present entry should have refcount\n\t * zero (else somebody forgot to close it); in the event that it doesn't,\n\t * we'll elog a WARNING and leak the already-present entry.\n\t */\n\tif (insertIt)\n\t\tRelationCacheInsert(relation, true);\n\n\t/* It's fully valid */\n\trelation->rd_isvalid = true;\n\n\treturn relation;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsTransactionState",
          "args": [],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationCacheDelete",
          "args": [
            "relation"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationReloadIndexInfo",
          "args": [
            "relation"
          ],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "RelationReloadIndexInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2049-2149",
          "snippet": "static void\nRelationReloadIndexInfo(Relation relation)\n{\n\tbool\t\tindexOK;\n\tHeapTuple\tpg_class_tuple;\n\tForm_pg_class relp;\n\n\t/* Should be called only for invalidated indexes */\n\tAssert((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t\trelation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\t   !relation->rd_isvalid);\n\n\t/* Ensure it's closed at smgr level */\n\tRelationCloseSmgr(relation);\n\n\t/* Must free any AM cached data upon relcache flush */\n\tif (relation->rd_amcache)\n\t\tpfree(relation->rd_amcache);\n\trelation->rd_amcache = NULL;\n\n\t/*\n\t * If it's a shared index, we might be called before backend startup has\n\t * finished selecting a database, in which case we have no way to read\n\t * pg_class yet.  However, a shared index can never have any significant\n\t * schema updates, so it's okay to ignore the invalidation signal.  Just\n\t * mark it valid and return without doing anything more.\n\t */\n\tif (relation->rd_rel->relisshared && !criticalRelcachesBuilt)\n\t{\n\t\trelation->rd_isvalid = true;\n\t\treturn;\n\t}\n\n\t/*\n\t * Read the pg_class row\n\t *\n\t * Don't try to use an indexscan of pg_class_oid_index to reload the info\n\t * for pg_class_oid_index ...\n\t */\n\tindexOK = (RelationGetRelid(relation) != ClassOidIndexId);\n\tpg_class_tuple = ScanPgRelation(RelationGetRelid(relation), indexOK, false);\n\tif (!HeapTupleIsValid(pg_class_tuple))\n\t\telog(ERROR, \"could not find pg_class tuple for index %u\",\n\t\t\t RelationGetRelid(relation));\n\trelp = (Form_pg_class) GETSTRUCT(pg_class_tuple);\n\tmemcpy(relation->rd_rel, relp, CLASS_TUPLE_SIZE);\n\t/* Reload reloptions in case they changed */\n\tif (relation->rd_options)\n\t\tpfree(relation->rd_options);\n\tRelationParseRelOptions(relation, pg_class_tuple);\n\t/* done with pg_class tuple */\n\theap_freetuple(pg_class_tuple);\n\t/* We must recalculate physical address in case it changed */\n\tRelationInitPhysicalAddr(relation);\n\n\t/*\n\t * For a non-system index, there are fields of the pg_index row that are\n\t * allowed to change, so re-read that row and update the relcache entry.\n\t * Most of the info derived from pg_index (such as support function lookup\n\t * info) cannot change, and indeed the whole point of this routine is to\n\t * update the relcache entry without clobbering that data; so wholesale\n\t * replacement is not appropriate.\n\t */\n\tif (!IsSystemRelation(relation))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_index index;\n\n\t\ttuple = SearchSysCache1(INDEXRELID,\n\t\t\t\t\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for index %u\",\n\t\t\t\t RelationGetRelid(relation));\n\t\tindex = (Form_pg_index) GETSTRUCT(tuple);\n\n\t\t/*\n\t\t * Basically, let's just copy all the bool fields.  There are one or\n\t\t * two of these that can't actually change in the current code, but\n\t\t * it's not worth it to track exactly which ones they are.  None of\n\t\t * the array fields are allowed to change, though.\n\t\t */\n\t\trelation->rd_index->indisunique = index->indisunique;\n\t\trelation->rd_index->indisprimary = index->indisprimary;\n\t\trelation->rd_index->indisexclusion = index->indisexclusion;\n\t\trelation->rd_index->indimmediate = index->indimmediate;\n\t\trelation->rd_index->indisclustered = index->indisclustered;\n\t\trelation->rd_index->indisvalid = index->indisvalid;\n\t\trelation->rd_index->indcheckxmin = index->indcheckxmin;\n\t\trelation->rd_index->indisready = index->indisready;\n\t\trelation->rd_index->indislive = index->indislive;\n\n\t\t/* Copy xmin too, as that is needed to make sense of indcheckxmin */\n\t\tHeapTupleHeaderSetXmin(relation->rd_indextuple->t_data,\n\t\t\t\t\t\t\t   HeapTupleHeaderGetXmin(tuple->t_data));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\n\t/* Okay, now it's valid again */\n\trelation->rd_isvalid = true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool\t\tcriticalRelcachesBuilt = false;",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static bool load_relcache_init_file(bool shared);",
            "static void write_relcache_init_file(bool shared);",
            "static Relation AllocateRelationDesc(Form_pg_class relp);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nbool\t\tcriticalRelcachesBuilt = false;\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic bool load_relcache_init_file(bool shared);\nstatic void write_relcache_init_file(bool shared);\nstatic Relation AllocateRelationDesc(Form_pg_class relp);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationReloadIndexInfo(Relation relation)\n{\n\tbool\t\tindexOK;\n\tHeapTuple\tpg_class_tuple;\n\tForm_pg_class relp;\n\n\t/* Should be called only for invalidated indexes */\n\tAssert((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t\trelation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\t   !relation->rd_isvalid);\n\n\t/* Ensure it's closed at smgr level */\n\tRelationCloseSmgr(relation);\n\n\t/* Must free any AM cached data upon relcache flush */\n\tif (relation->rd_amcache)\n\t\tpfree(relation->rd_amcache);\n\trelation->rd_amcache = NULL;\n\n\t/*\n\t * If it's a shared index, we might be called before backend startup has\n\t * finished selecting a database, in which case we have no way to read\n\t * pg_class yet.  However, a shared index can never have any significant\n\t * schema updates, so it's okay to ignore the invalidation signal.  Just\n\t * mark it valid and return without doing anything more.\n\t */\n\tif (relation->rd_rel->relisshared && !criticalRelcachesBuilt)\n\t{\n\t\trelation->rd_isvalid = true;\n\t\treturn;\n\t}\n\n\t/*\n\t * Read the pg_class row\n\t *\n\t * Don't try to use an indexscan of pg_class_oid_index to reload the info\n\t * for pg_class_oid_index ...\n\t */\n\tindexOK = (RelationGetRelid(relation) != ClassOidIndexId);\n\tpg_class_tuple = ScanPgRelation(RelationGetRelid(relation), indexOK, false);\n\tif (!HeapTupleIsValid(pg_class_tuple))\n\t\telog(ERROR, \"could not find pg_class tuple for index %u\",\n\t\t\t RelationGetRelid(relation));\n\trelp = (Form_pg_class) GETSTRUCT(pg_class_tuple);\n\tmemcpy(relation->rd_rel, relp, CLASS_TUPLE_SIZE);\n\t/* Reload reloptions in case they changed */\n\tif (relation->rd_options)\n\t\tpfree(relation->rd_options);\n\tRelationParseRelOptions(relation, pg_class_tuple);\n\t/* done with pg_class tuple */\n\theap_freetuple(pg_class_tuple);\n\t/* We must recalculate physical address in case it changed */\n\tRelationInitPhysicalAddr(relation);\n\n\t/*\n\t * For a non-system index, there are fields of the pg_index row that are\n\t * allowed to change, so re-read that row and update the relcache entry.\n\t * Most of the info derived from pg_index (such as support function lookup\n\t * info) cannot change, and indeed the whole point of this routine is to\n\t * update the relcache entry without clobbering that data; so wholesale\n\t * replacement is not appropriate.\n\t */\n\tif (!IsSystemRelation(relation))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_index index;\n\n\t\ttuple = SearchSysCache1(INDEXRELID,\n\t\t\t\t\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for index %u\",\n\t\t\t\t RelationGetRelid(relation));\n\t\tindex = (Form_pg_index) GETSTRUCT(tuple);\n\n\t\t/*\n\t\t * Basically, let's just copy all the bool fields.  There are one or\n\t\t * two of these that can't actually change in the current code, but\n\t\t * it's not worth it to track exactly which ones they are.  None of\n\t\t * the array fields are allowed to change, though.\n\t\t */\n\t\trelation->rd_index->indisunique = index->indisunique;\n\t\trelation->rd_index->indisprimary = index->indisprimary;\n\t\trelation->rd_index->indisexclusion = index->indisexclusion;\n\t\trelation->rd_index->indimmediate = index->indimmediate;\n\t\trelation->rd_index->indisclustered = index->indisclustered;\n\t\trelation->rd_index->indisvalid = index->indisvalid;\n\t\trelation->rd_index->indcheckxmin = index->indcheckxmin;\n\t\trelation->rd_index->indisready = index->indisready;\n\t\trelation->rd_index->indislive = index->indislive;\n\n\t\t/* Copy xmin too, as that is needed to make sense of indcheckxmin */\n\t\tHeapTupleHeaderSetXmin(relation->rd_indextuple->t_data,\n\t\t\t\t\t\t\t   HeapTupleHeaderGetXmin(tuple->t_data));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\n\t/* Okay, now it's valid again */\n\trelation->rd_isvalid = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsTransactionState",
          "args": [],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationReloadNailed",
          "args": [
            "relation"
          ],
          "line": 2346
        },
        "resolved": true,
        "details": {
          "function_name": "RelationReloadNailed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2160-2224",
          "snippet": "static void\nRelationReloadNailed(Relation relation)\n{\n\tAssert(relation->rd_isnailed);\n\n\t/*\n\t * Redo RelationInitPhysicalAddr in case it is a mapped relation whose\n\t * mapping changed.\n\t */\n\tRelationInitPhysicalAddr(relation);\n\n\t/* flag as needing to be revalidated */\n\trelation->rd_isvalid = false;\n\n\t/*\n\t * Can only reread catalog contents if in a transaction.  If the relation\n\t * is currently open (not counting the nailed refcount), do so\n\t * immediately. Otherwise we've already marked the entry as possibly\n\t * invalid, and it'll be fixed when next opened.\n\t */\n\tif (!IsTransactionState() || relation->rd_refcnt <= 1)\n\t\treturn;\n\n\tif (relation->rd_rel->relkind == RELKIND_INDEX)\n\t{\n\t\t/*\n\t\t * If it's a nailed-but-not-mapped index, then we need to re-read the\n\t\t * pg_class row to see if its relfilenode changed.\n\t\t */\n\t\tRelationReloadIndexInfo(relation);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Reload a non-index entry.  We can't easily do so if relcaches\n\t\t * aren't yet built, but that's fine because at that stage the\n\t\t * attributes that need to be current (like relfrozenxid) aren't yet\n\t\t * accessed.  To ensure the entry will later be revalidated, we leave\n\t\t * it in invalid state, but allow use (cf. RelationIdGetRelation()).\n\t\t */\n\t\tif (criticalRelcachesBuilt)\n\t\t{\n\t\t\tHeapTuple\tpg_class_tuple;\n\t\t\tForm_pg_class relp;\n\n\t\t\t/*\n\t\t\t * NB: Mark the entry as valid before starting to scan, to avoid\n\t\t\t * self-recursion when re-building pg_class.\n\t\t\t */\n\t\t\trelation->rd_isvalid = true;\n\n\t\t\tpg_class_tuple = ScanPgRelation(RelationGetRelid(relation),\n\t\t\t\t\t\t\t\t\t\t\ttrue, false);\n\t\t\trelp = (Form_pg_class) GETSTRUCT(pg_class_tuple);\n\t\t\tmemcpy(relation->rd_rel, relp, CLASS_TUPLE_SIZE);\n\t\t\theap_freetuple(pg_class_tuple);\n\n\t\t\t/*\n\t\t\t * Again mark as valid, to protect against concurrently arriving\n\t\t\t * invalidations.\n\t\t\t */\n\t\t\trelation->rd_isvalid = true;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool\t\tcriticalRelcachesBuilt = false;",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static Relation AllocateRelationDesc(Form_pg_class relp);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nbool\t\tcriticalRelcachesBuilt = false;\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic Relation AllocateRelationDesc(Form_pg_class relp);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationReloadNailed(Relation relation)\n{\n\tAssert(relation->rd_isnailed);\n\n\t/*\n\t * Redo RelationInitPhysicalAddr in case it is a mapped relation whose\n\t * mapping changed.\n\t */\n\tRelationInitPhysicalAddr(relation);\n\n\t/* flag as needing to be revalidated */\n\trelation->rd_isvalid = false;\n\n\t/*\n\t * Can only reread catalog contents if in a transaction.  If the relation\n\t * is currently open (not counting the nailed refcount), do so\n\t * immediately. Otherwise we've already marked the entry as possibly\n\t * invalid, and it'll be fixed when next opened.\n\t */\n\tif (!IsTransactionState() || relation->rd_refcnt <= 1)\n\t\treturn;\n\n\tif (relation->rd_rel->relkind == RELKIND_INDEX)\n\t{\n\t\t/*\n\t\t * If it's a nailed-but-not-mapped index, then we need to re-read the\n\t\t * pg_class row to see if its relfilenode changed.\n\t\t */\n\t\tRelationReloadIndexInfo(relation);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Reload a non-index entry.  We can't easily do so if relcaches\n\t\t * aren't yet built, but that's fine because at that stage the\n\t\t * attributes that need to be current (like relfrozenxid) aren't yet\n\t\t * accessed.  To ensure the entry will later be revalidated, we leave\n\t\t * it in invalid state, but allow use (cf. RelationIdGetRelation()).\n\t\t */\n\t\tif (criticalRelcachesBuilt)\n\t\t{\n\t\t\tHeapTuple\tpg_class_tuple;\n\t\t\tForm_pg_class relp;\n\n\t\t\t/*\n\t\t\t * NB: Mark the entry as valid before starting to scan, to avoid\n\t\t\t * self-recursion when re-building pg_class.\n\t\t\t */\n\t\t\trelation->rd_isvalid = true;\n\n\t\t\tpg_class_tuple = ScanPgRelation(RelationGetRelid(relation),\n\t\t\t\t\t\t\t\t\t\t\ttrue, false);\n\t\t\trelp = (Form_pg_class) GETSTRUCT(pg_class_tuple);\n\t\t\tmemcpy(relation->rd_rel, relp, CLASS_TUPLE_SIZE);\n\t\t\theap_freetuple(pg_class_tuple);\n\n\t\t\t/*\n\t\t\t * Again mark as valid, to protect against concurrently arriving\n\t\t\t * invalidations.\n\t\t\t */\n\t\t\trelation->rd_isvalid = true;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationCloseSmgr",
          "args": [
            "relation"
          ],
          "line": 2338
        },
        "resolved": true,
        "details": {
          "function_name": "RelationCloseSmgrByOid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2776-2787",
          "snippet": "void\nRelationCloseSmgrByOid(Oid relationId)\n{\n\tRelation\trelation;\n\n\tRelationIdCacheLookup(relationId, relation);\n\n\tif (!PointerIsValid(relation))\n\t\treturn;\t\t\t\t\t/* not in cache, nothing to do */\n\n\tRelationCloseSmgr(relation);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationCloseSmgrByOid(Oid relationId)\n{\n\tRelation\trelation;\n\n\tRelationIdCacheLookup(relationId, relation);\n\n\tif (!PointerIsValid(relation))\n\t\treturn;\t\t\t\t\t/* not in cache, nothing to do */\n\n\tRelationCloseSmgr(relation);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rebuild ?\n\t\t   !RelationHasReferenceCountZero(relation) :\n\t\t   RelationHasReferenceCountZero(relation)"
          ],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationHasReferenceCountZero",
          "args": [
            "relation"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationHasReferenceCountZero",
          "args": [
            "relation"
          ],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationClearRelation(Relation relation, bool rebuild);\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationClearRelation(Relation relation, bool rebuild)\n{\n\t/*\n\t * As per notes above, a rel to be rebuilt MUST have refcnt > 0; while of\n\t * course it would be an equally bad idea to blow away one with nonzero\n\t * refcnt, since that would leave someone somewhere with a dangling\n\t * pointer.  All callers are expected to have verified that this holds.\n\t */\n\tAssert(rebuild ?\n\t\t   !RelationHasReferenceCountZero(relation) :\n\t\t   RelationHasReferenceCountZero(relation));\n\n\t/*\n\t * Make sure smgr and lower levels close the relation's files, if they\n\t * weren't closed already.  If the relation is not getting deleted, the\n\t * next smgr access should reopen the files automatically.  This ensures\n\t * that the low-level file access state is updated after, say, a vacuum\n\t * truncation.\n\t */\n\tRelationCloseSmgr(relation);\n\n\t/*\n\t * Treat nailed-in system relations separately, they always need to be\n\t * accessible, so we can't blow them away.\n\t */\n\tif (relation->rd_isnailed)\n\t{\n\t\tRelationReloadNailed(relation);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even non-system indexes should not be blown away if they are open and\n\t * have valid index support information.  This avoids problems with active\n\t * use of the index support information.  As with nailed indexes, we\n\t * re-read the pg_class row to handle possible physical relocation of the\n\t * index, and we check for pg_index updates too.\n\t */\n\tif ((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t relation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\trelation->rd_refcnt > 0 &&\n\t\trelation->rd_indexcxt != NULL)\n\t{\n\t\trelation->rd_isvalid = false;\t/* needs to be revalidated */\n\t\tif (IsTransactionState())\n\t\t\tRelationReloadIndexInfo(relation);\n\t\treturn;\n\t}\n\n\t/* Mark it invalid until we've finished rebuild */\n\trelation->rd_isvalid = false;\n\n\t/*\n\t * If we're really done with the relcache entry, blow it away. But if\n\t * someone is still using it, reconstruct the whole deal without moving\n\t * the physical RelationData record (so that the someone's pointer is\n\t * still valid).\n\t */\n\tif (!rebuild)\n\t{\n\t\t/* Remove it from the hash table */\n\t\tRelationCacheDelete(relation);\n\n\t\t/* And release storage */\n\t\tRelationDestroyRelation(relation, false);\n\t}\n\telse if (!IsTransactionState())\n\t{\n\t\t/*\n\t\t * If we're not inside a valid transaction, we can't do any catalog\n\t\t * access so it's not possible to rebuild yet.  Just exit, leaving\n\t\t * rd_isvalid = false so that the rebuild will occur when the entry is\n\t\t * next opened.\n\t\t *\n\t\t * Note: it's possible that we come here during subtransaction abort,\n\t\t * and the reason for wanting to rebuild is that the rel is open in\n\t\t * the outer transaction.  In that case it might seem unsafe to not\n\t\t * rebuild immediately, since whatever code has the rel already open\n\t\t * will keep on using the relcache entry as-is.  However, in such a\n\t\t * case the outer transaction should be holding a lock that's\n\t\t * sufficient to prevent any significant change in the rel's schema,\n\t\t * so the existing entry contents should be good enough for its\n\t\t * purposes; at worst we might be behind on statistics updates or the\n\t\t * like.  (See also CheckTableNotInUse() and its callers.)\tThese same\n\t\t * remarks also apply to the cases above where we exit without having\n\t\t * done RelationReloadIndexInfo() yet.\n\t\t */\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Our strategy for rebuilding an open relcache entry is to build a\n\t\t * new entry from scratch, swap its contents with the old entry, and\n\t\t * finally delete the new entry (along with any infrastructure swapped\n\t\t * over from the old entry).  This is to avoid trouble in case an\n\t\t * error causes us to lose control partway through.  The old entry\n\t\t * will still be marked !rd_isvalid, so we'll try to rebuild it again\n\t\t * on next access.  Meanwhile it's not any less valid than it was\n\t\t * before, so any code that might expect to continue accessing it\n\t\t * isn't hurt by the rebuild failure.  (Consider for example a\n\t\t * subtransaction that ALTERs a table and then gets canceled partway\n\t\t * through the cache entry rebuild.  The outer transaction should\n\t\t * still see the not-modified cache entry as valid.)  The worst\n\t\t * consequence of an error is leaking the necessarily-unreferenced new\n\t\t * entry, and this shouldn't happen often enough for that to be a big\n\t\t * problem.\n\t\t *\n\t\t * When rebuilding an open relcache entry, we must preserve ref count,\n\t\t * rd_createSubid/rd_newRelfilenodeSubid, and rd_toastoid state.  Also\n\t\t * attempt to preserve the pg_class entry (rd_rel), tupledesc,\n\t\t * rewrite-rule, partition key, and partition descriptor substructures\n\t\t * in place, because various places assume that these structures won't\n\t\t * move while they are working with an open relcache entry.  (Note:\n\t\t * the refcount mechanism for tupledescs might someday allow us to\n\t\t * remove this hack for the tupledesc.)\n\t\t *\n\t\t * Note that this process does not touch CurrentResourceOwner; which\n\t\t * is good because whatever ref counts the entry may have do not\n\t\t * necessarily belong to that resource owner.\n\t\t */\n\t\tRelation\tnewrel;\n\t\tOid\t\t\tsave_relid = RelationGetRelid(relation);\n\t\tbool\t\tkeep_tupdesc;\n\t\tbool\t\tkeep_rules;\n\t\tbool\t\tkeep_policies;\n\t\tbool\t\tkeep_partkey;\n\t\tbool\t\tkeep_partdesc;\n\n\t\t/* Build temporary entry, but don't link it into hashtable */\n\t\tnewrel = RelationBuildDesc(save_relid, false);\n\t\tif (newrel == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * We can validly get here, if we're using a historic snapshot in\n\t\t\t * which a relation, accessed from outside logical decoding, is\n\t\t\t * still invisible. In that case it's fine to just mark the\n\t\t\t * relation as invalid and return - it'll fully get reloaded by\n\t\t\t * the cache reset at the end of logical decoding (or at the next\n\t\t\t * access).  During normal processing we don't want to ignore this\n\t\t\t * case as it shouldn't happen there, as explained below.\n\t\t\t */\n\t\t\tif (HistoricSnapshotActive())\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * This shouldn't happen as dropping a relation is intended to be\n\t\t\t * impossible if still referenced (cf. CheckTableNotInUse()). But\n\t\t\t * if we get here anyway, we can't just delete the relcache entry,\n\t\t\t * as it possibly could get accessed later (as e.g. the error\n\t\t\t * might get trapped and handled via a subtransaction rollback).\n\t\t\t */\n\t\t\telog(ERROR, \"relation %u deleted while still in use\", save_relid);\n\t\t}\n\n\t\tkeep_tupdesc = equalTupleDescs(relation->rd_att, newrel->rd_att);\n\t\tkeep_rules = equalRuleLocks(relation->rd_rules, newrel->rd_rules);\n\t\tkeep_policies = equalRSDesc(relation->rd_rsdesc, newrel->rd_rsdesc);\n\t\t/* partkey is immutable once set up, so we can always keep it */\n\t\tkeep_partkey = (relation->rd_partkey != NULL);\n\t\tkeep_partdesc = equalPartitionDescs(relation->rd_partkey,\n\t\t\t\t\t\t\t\t\t\t\trelation->rd_partdesc,\n\t\t\t\t\t\t\t\t\t\t\tnewrel->rd_partdesc);\n\n\t\t/*\n\t\t * Perform swapping of the relcache entry contents.  Within this\n\t\t * process the old entry is momentarily invalid, so there *must* be no\n\t\t * possibility of CHECK_FOR_INTERRUPTS within this sequence. Do it in\n\t\t * all-in-line code for safety.\n\t\t *\n\t\t * Since the vast majority of fields should be swapped, our method is\n\t\t * to swap the whole structures and then re-swap those few fields we\n\t\t * didn't want swapped.\n\t\t */\n#define SWAPFIELD(fldtype, fldname) \\\n\t\tdo { \\\n\t\t\tfldtype _tmp = newrel->fldname; \\\n\t\t\tnewrel->fldname = relation->fldname; \\\n\t\t\trelation->fldname = _tmp; \\\n\t\t} while (0)\n\n\t\t/* swap all Relation struct fields */\n\t\t{\n\t\t\tRelationData tmpstruct;\n\n\t\t\tmemcpy(&tmpstruct, newrel, sizeof(RelationData));\n\t\t\tmemcpy(newrel, relation, sizeof(RelationData));\n\t\t\tmemcpy(relation, &tmpstruct, sizeof(RelationData));\n\t\t}\n\n\t\t/* rd_smgr must not be swapped, due to back-links from smgr level */\n\t\tSWAPFIELD(SMgrRelation, rd_smgr);\n\t\t/* rd_refcnt must be preserved */\n\t\tSWAPFIELD(int, rd_refcnt);\n\t\t/* isnailed shouldn't change */\n\t\tAssert(newrel->rd_isnailed == relation->rd_isnailed);\n\t\t/* creation sub-XIDs must be preserved */\n\t\tSWAPFIELD(SubTransactionId, rd_createSubid);\n\t\tSWAPFIELD(SubTransactionId, rd_newRelfilenodeSubid);\n\t\t/* un-swap rd_rel pointers, swap contents instead */\n\t\tSWAPFIELD(Form_pg_class, rd_rel);\n\t\t/* ... but actually, we don't have to update newrel->rd_rel */\n\t\tmemcpy(relation->rd_rel, newrel->rd_rel, CLASS_TUPLE_SIZE);\n\t\t/* preserve old tupledesc, rules, policies if no logical change */\n\t\tif (keep_tupdesc)\n\t\t\tSWAPFIELD(TupleDesc, rd_att);\n\t\tif (keep_rules)\n\t\t{\n\t\t\tSWAPFIELD(RuleLock *, rd_rules);\n\t\t\tSWAPFIELD(MemoryContext, rd_rulescxt);\n\t\t}\n\t\tif (keep_policies)\n\t\t\tSWAPFIELD(RowSecurityDesc *, rd_rsdesc);\n\t\t/* toast OID override must be preserved */\n\t\tSWAPFIELD(Oid, rd_toastoid);\n\t\t/* pgstat_info must be preserved */\n\t\tSWAPFIELD(struct PgStat_TableStatus *, pgstat_info);\n\t\t/* preserve old partitioning info if no logical change */\n\t\tif (keep_partkey)\n\t\t{\n\t\t\tSWAPFIELD(PartitionKey, rd_partkey);\n\t\t\tSWAPFIELD(MemoryContext, rd_partkeycxt);\n\t\t}\n\t\tif (keep_partdesc)\n\t\t{\n\t\t\tSWAPFIELD(PartitionDesc, rd_partdesc);\n\t\t\tSWAPFIELD(MemoryContext, rd_pdcxt);\n\t\t}\n\n#undef SWAPFIELD\n\n\t\t/* And now we can throw away the temporary entry */\n\t\tRelationDestroyRelation(newrel, !keep_tupdesc);\n\t}\n}"
  },
  {
    "function_name": "RelationDestroyRelation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "2232-2297",
    "snippet": "static void\nRelationDestroyRelation(Relation relation, bool remember_tupdesc)\n{\n\tAssert(RelationHasReferenceCountZero(relation));\n\n\t/*\n\t * Make sure smgr and lower levels close the relation's files, if they\n\t * weren't closed already.  (This was probably done by caller, but let's\n\t * just be real sure.)\n\t */\n\tRelationCloseSmgr(relation);\n\n\t/*\n\t * Free all the subsidiary data structures of the relcache entry, then the\n\t * entry itself.\n\t */\n\tif (relation->rd_rel)\n\t\tpfree(relation->rd_rel);\n\t/* can't use DecrTupleDescRefCount here */\n\tAssert(relation->rd_att->tdrefcount > 0);\n\tif (--relation->rd_att->tdrefcount == 0)\n\t{\n\t\t/*\n\t\t * If we Rebuilt a relcache entry during a transaction then its\n\t\t * possible we did that because the TupDesc changed as the result of\n\t\t * an ALTER TABLE that ran at less than AccessExclusiveLock. It's\n\t\t * possible someone copied that TupDesc, in which case the copy would\n\t\t * point to free'd memory. So if we rebuild an entry we keep the\n\t\t * TupDesc around until end of transaction, to be safe.\n\t\t */\n\t\tif (remember_tupdesc)\n\t\t\tRememberToFreeTupleDescAtEOX(relation->rd_att);\n\t\telse\n\t\t\tFreeTupleDesc(relation->rd_att);\n\t}\n\tFreeTriggerDesc(relation->trigdesc);\n\tlist_free_deep(relation->rd_fkeylist);\n\tlist_free(relation->rd_indexlist);\n\tbms_free(relation->rd_indexattr);\n\tbms_free(relation->rd_projindexattr);\n\tbms_free(relation->rd_keyattr);\n\tbms_free(relation->rd_pkattr);\n\tbms_free(relation->rd_idattr);\n\tbms_free(relation->rd_projidx);\n\tif (relation->rd_pubactions)\n\t\tpfree(relation->rd_pubactions);\n\tif (relation->rd_options)\n\t\tpfree(relation->rd_options);\n\tif (relation->rd_indextuple)\n\t\tpfree(relation->rd_indextuple);\n\tif (relation->rd_indexcxt)\n\t\tMemoryContextDelete(relation->rd_indexcxt);\n\tif (relation->rd_rulescxt)\n\t\tMemoryContextDelete(relation->rd_rulescxt);\n\tif (relation->rd_rsdesc)\n\t\tMemoryContextDelete(relation->rd_rsdesc->rscxt);\n\tif (relation->rd_partkeycxt)\n\t\tMemoryContextDelete(relation->rd_partkeycxt);\n\tif (relation->rd_pdcxt)\n\t\tMemoryContextDelete(relation->rd_pdcxt);\n\tif (relation->rd_partcheckcxt)\n\t\tMemoryContextDelete(relation->rd_partcheckcxt);\n\tif (relation->rd_fdwroutine)\n\t\tpfree(relation->rd_fdwroutine);\n\tpfree(relation);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationDestroyRelation(Relation relation, bool remember_tupdesc);",
      "static void RelationClearRelation(Relation relation, bool rebuild);",
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "relation"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextDelete",
          "args": [
            "relation->rd_partcheckcxt"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextDeleteChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "255-266",
          "snippet": "void\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "relation->rd_projidx"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "relation->rd_idattr"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "relation->rd_pkattr"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "relation->rd_keyattr"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "relation->rd_projindexattr"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bms_free",
          "args": [
            "relation->rd_indexattr"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_free",
          "args": [
            "relation->rd_indexlist"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_free_deep",
          "args": [
            "relation->rd_fkeylist"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeTriggerDesc",
          "args": [
            "relation->trigdesc"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeTupleDesc",
          "args": [
            "relation->rd_att"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "RememberToFreeTupleDescAtEOX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2789-2815",
          "snippet": "static void\nRememberToFreeTupleDescAtEOX(TupleDesc td)\n{\n\tif (EOXactTupleDescArray == NULL)\n\t{\n\t\tMemoryContext oldcxt;\n\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) palloc(16 * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = 16;\n\t\tNextEOXactTupleDescNum = 0;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse if (NextEOXactTupleDescNum >= EOXactTupleDescArrayLen)\n\t{\n\t\tint32\t\tnewlen = EOXactTupleDescArrayLen * 2;\n\n\t\tAssert(EOXactTupleDescArrayLen > 0);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) repalloc(EOXactTupleDescArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = newlen;\n\t}\n\n\tEOXactTupleDescArray[NextEOXactTupleDescNum++] = td;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TupleDesc *EOXactTupleDescArray;",
            "static int\tNextEOXactTupleDescNum = 0;",
            "static int\tEOXactTupleDescArrayLen = 0;",
            "static void RememberToFreeTupleDescAtEOX(TupleDesc td);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic TupleDesc *EOXactTupleDescArray;\nstatic int\tNextEOXactTupleDescNum = 0;\nstatic int\tEOXactTupleDescArrayLen = 0;\nstatic void RememberToFreeTupleDescAtEOX(TupleDesc td);\n\nstatic void\nRememberToFreeTupleDescAtEOX(TupleDesc td)\n{\n\tif (EOXactTupleDescArray == NULL)\n\t{\n\t\tMemoryContext oldcxt;\n\n\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) palloc(16 * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = 16;\n\t\tNextEOXactTupleDescNum = 0;\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\telse if (NextEOXactTupleDescNum >= EOXactTupleDescArrayLen)\n\t{\n\t\tint32\t\tnewlen = EOXactTupleDescArrayLen * 2;\n\n\t\tAssert(EOXactTupleDescArrayLen > 0);\n\n\t\tEOXactTupleDescArray = (TupleDesc *) repalloc(EOXactTupleDescArray,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  newlen * sizeof(TupleDesc));\n\t\tEOXactTupleDescArrayLen = newlen;\n\t}\n\n\tEOXactTupleDescArray[NextEOXactTupleDescNum++] = td;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relation->rd_att->tdrefcount > 0"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationCloseSmgr",
          "args": [
            "relation"
          ],
          "line": 2242
        },
        "resolved": true,
        "details": {
          "function_name": "RelationCloseSmgrByOid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2776-2787",
          "snippet": "void\nRelationCloseSmgrByOid(Oid relationId)\n{\n\tRelation\trelation;\n\n\tRelationIdCacheLookup(relationId, relation);\n\n\tif (!PointerIsValid(relation))\n\t\treturn;\t\t\t\t\t/* not in cache, nothing to do */\n\n\tRelationCloseSmgr(relation);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationCloseSmgrByOid(Oid relationId)\n{\n\tRelation\trelation;\n\n\tRelationIdCacheLookup(relationId, relation);\n\n\tif (!PointerIsValid(relation))\n\t\treturn;\t\t\t\t\t/* not in cache, nothing to do */\n\n\tRelationCloseSmgr(relation);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "RelationHasReferenceCountZero(relation)"
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationHasReferenceCountZero",
          "args": [
            "relation"
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationDestroyRelation(Relation relation, bool remember_tupdesc);\nstatic void RelationClearRelation(Relation relation, bool rebuild);\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationDestroyRelation(Relation relation, bool remember_tupdesc)\n{\n\tAssert(RelationHasReferenceCountZero(relation));\n\n\t/*\n\t * Make sure smgr and lower levels close the relation's files, if they\n\t * weren't closed already.  (This was probably done by caller, but let's\n\t * just be real sure.)\n\t */\n\tRelationCloseSmgr(relation);\n\n\t/*\n\t * Free all the subsidiary data structures of the relcache entry, then the\n\t * entry itself.\n\t */\n\tif (relation->rd_rel)\n\t\tpfree(relation->rd_rel);\n\t/* can't use DecrTupleDescRefCount here */\n\tAssert(relation->rd_att->tdrefcount > 0);\n\tif (--relation->rd_att->tdrefcount == 0)\n\t{\n\t\t/*\n\t\t * If we Rebuilt a relcache entry during a transaction then its\n\t\t * possible we did that because the TupDesc changed as the result of\n\t\t * an ALTER TABLE that ran at less than AccessExclusiveLock. It's\n\t\t * possible someone copied that TupDesc, in which case the copy would\n\t\t * point to free'd memory. So if we rebuild an entry we keep the\n\t\t * TupDesc around until end of transaction, to be safe.\n\t\t */\n\t\tif (remember_tupdesc)\n\t\t\tRememberToFreeTupleDescAtEOX(relation->rd_att);\n\t\telse\n\t\t\tFreeTupleDesc(relation->rd_att);\n\t}\n\tFreeTriggerDesc(relation->trigdesc);\n\tlist_free_deep(relation->rd_fkeylist);\n\tlist_free(relation->rd_indexlist);\n\tbms_free(relation->rd_indexattr);\n\tbms_free(relation->rd_projindexattr);\n\tbms_free(relation->rd_keyattr);\n\tbms_free(relation->rd_pkattr);\n\tbms_free(relation->rd_idattr);\n\tbms_free(relation->rd_projidx);\n\tif (relation->rd_pubactions)\n\t\tpfree(relation->rd_pubactions);\n\tif (relation->rd_options)\n\t\tpfree(relation->rd_options);\n\tif (relation->rd_indextuple)\n\t\tpfree(relation->rd_indextuple);\n\tif (relation->rd_indexcxt)\n\t\tMemoryContextDelete(relation->rd_indexcxt);\n\tif (relation->rd_rulescxt)\n\t\tMemoryContextDelete(relation->rd_rulescxt);\n\tif (relation->rd_rsdesc)\n\t\tMemoryContextDelete(relation->rd_rsdesc->rscxt);\n\tif (relation->rd_partkeycxt)\n\t\tMemoryContextDelete(relation->rd_partkeycxt);\n\tif (relation->rd_pdcxt)\n\t\tMemoryContextDelete(relation->rd_pdcxt);\n\tif (relation->rd_partcheckcxt)\n\t\tMemoryContextDelete(relation->rd_partcheckcxt);\n\tif (relation->rd_fdwroutine)\n\t\tpfree(relation->rd_fdwroutine);\n\tpfree(relation);\n}"
  },
  {
    "function_name": "RelationReloadNailed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "2160-2224",
    "snippet": "static void\nRelationReloadNailed(Relation relation)\n{\n\tAssert(relation->rd_isnailed);\n\n\t/*\n\t * Redo RelationInitPhysicalAddr in case it is a mapped relation whose\n\t * mapping changed.\n\t */\n\tRelationInitPhysicalAddr(relation);\n\n\t/* flag as needing to be revalidated */\n\trelation->rd_isvalid = false;\n\n\t/*\n\t * Can only reread catalog contents if in a transaction.  If the relation\n\t * is currently open (not counting the nailed refcount), do so\n\t * immediately. Otherwise we've already marked the entry as possibly\n\t * invalid, and it'll be fixed when next opened.\n\t */\n\tif (!IsTransactionState() || relation->rd_refcnt <= 1)\n\t\treturn;\n\n\tif (relation->rd_rel->relkind == RELKIND_INDEX)\n\t{\n\t\t/*\n\t\t * If it's a nailed-but-not-mapped index, then we need to re-read the\n\t\t * pg_class row to see if its relfilenode changed.\n\t\t */\n\t\tRelationReloadIndexInfo(relation);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Reload a non-index entry.  We can't easily do so if relcaches\n\t\t * aren't yet built, but that's fine because at that stage the\n\t\t * attributes that need to be current (like relfrozenxid) aren't yet\n\t\t * accessed.  To ensure the entry will later be revalidated, we leave\n\t\t * it in invalid state, but allow use (cf. RelationIdGetRelation()).\n\t\t */\n\t\tif (criticalRelcachesBuilt)\n\t\t{\n\t\t\tHeapTuple\tpg_class_tuple;\n\t\t\tForm_pg_class relp;\n\n\t\t\t/*\n\t\t\t * NB: Mark the entry as valid before starting to scan, to avoid\n\t\t\t * self-recursion when re-building pg_class.\n\t\t\t */\n\t\t\trelation->rd_isvalid = true;\n\n\t\t\tpg_class_tuple = ScanPgRelation(RelationGetRelid(relation),\n\t\t\t\t\t\t\t\t\t\t\ttrue, false);\n\t\t\trelp = (Form_pg_class) GETSTRUCT(pg_class_tuple);\n\t\t\tmemcpy(relation->rd_rel, relp, CLASS_TUPLE_SIZE);\n\t\t\theap_freetuple(pg_class_tuple);\n\n\t\t\t/*\n\t\t\t * Again mark as valid, to protect against concurrently arriving\n\t\t\t * invalidations.\n\t\t\t */\n\t\t\trelation->rd_isvalid = true;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool\t\tcriticalRelcachesBuilt = false;",
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static Relation AllocateRelationDesc(Form_pg_class relp);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_freetuple",
          "args": [
            "pg_class_tuple"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "relation->rd_rel",
            "relp",
            "CLASS_TUPLE_SIZE"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "pg_class_tuple"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanPgRelation",
          "args": [
            "RelationGetRelid(relation)",
            "true",
            "false"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "ScanPgRelation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "308-370",
          "snippet": "static HeapTuple\nScanPgRelation(Oid targetRelId, bool indexOK, bool force_non_historic)\n{\n\tHeapTuple\tpg_class_tuple;\n\tRelation\tpg_class_desc;\n\tSysScanDesc pg_class_scan;\n\tScanKeyData key[1];\n\tSnapshot\tsnapshot;\n\n\t/*\n\t * If something goes wrong during backend startup, we might find ourselves\n\t * trying to read pg_class before we've selected a database.  That ain't\n\t * gonna work, so bail out with a useful error message.  If this happens,\n\t * it probably means a relcache entry that needs to be nailed isn't.\n\t */\n\tif (!OidIsValid(MyDatabaseId))\n\t\telog(FATAL, \"cannot read pg_class without having selected a database\");\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(targetRelId));\n\n\t/*\n\t * Open pg_class and fetch a tuple.  Force heap scan if we haven't yet\n\t * built the critical relcache entries (this includes initdb and startup\n\t * without a pg_internal.init file).  The caller can also force a heap\n\t * scan by setting indexOK == false.\n\t */\n\tpg_class_desc = heap_open(RelationRelationId, AccessShareLock);\n\n\t/*\n\t * The caller might need a tuple that's newer than the one the historic\n\t * snapshot; currently the only case requiring to do so is looking up the\n\t * relfilenode of non mapped system relations during decoding.\n\t */\n\tif (force_non_historic)\n\t\tsnapshot = GetNonHistoricCatalogSnapshot(RelationRelationId);\n\telse\n\t\tsnapshot = GetCatalogSnapshot(RelationRelationId);\n\n\tpg_class_scan = systable_beginscan(pg_class_desc, ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t   indexOK && criticalRelcachesBuilt,\n\t\t\t\t\t\t\t\t\t   snapshot,\n\t\t\t\t\t\t\t\t\t   1, key);\n\n\tpg_class_tuple = systable_getnext(pg_class_scan);\n\n\t/*\n\t * Must copy tuple before releasing buffer.\n\t */\n\tif (HeapTupleIsValid(pg_class_tuple))\n\t\tpg_class_tuple = heap_copytuple(pg_class_tuple);\n\n\t/* all done */\n\tsystable_endscan(pg_class_scan);\n\theap_close(pg_class_desc, AccessShareLock);\n\n\treturn pg_class_tuple;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool\t\tcriticalRelcachesBuilt = false;",
            "static HeapTuple ScanPgRelation(Oid targetRelId, bool indexOK, bool force_non_historic);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nbool\t\tcriticalRelcachesBuilt = false;\nstatic HeapTuple ScanPgRelation(Oid targetRelId, bool indexOK, bool force_non_historic);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\n\nstatic HeapTuple\nScanPgRelation(Oid targetRelId, bool indexOK, bool force_non_historic)\n{\n\tHeapTuple\tpg_class_tuple;\n\tRelation\tpg_class_desc;\n\tSysScanDesc pg_class_scan;\n\tScanKeyData key[1];\n\tSnapshot\tsnapshot;\n\n\t/*\n\t * If something goes wrong during backend startup, we might find ourselves\n\t * trying to read pg_class before we've selected a database.  That ain't\n\t * gonna work, so bail out with a useful error message.  If this happens,\n\t * it probably means a relcache entry that needs to be nailed isn't.\n\t */\n\tif (!OidIsValid(MyDatabaseId))\n\t\telog(FATAL, \"cannot read pg_class without having selected a database\");\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(targetRelId));\n\n\t/*\n\t * Open pg_class and fetch a tuple.  Force heap scan if we haven't yet\n\t * built the critical relcache entries (this includes initdb and startup\n\t * without a pg_internal.init file).  The caller can also force a heap\n\t * scan by setting indexOK == false.\n\t */\n\tpg_class_desc = heap_open(RelationRelationId, AccessShareLock);\n\n\t/*\n\t * The caller might need a tuple that's newer than the one the historic\n\t * snapshot; currently the only case requiring to do so is looking up the\n\t * relfilenode of non mapped system relations during decoding.\n\t */\n\tif (force_non_historic)\n\t\tsnapshot = GetNonHistoricCatalogSnapshot(RelationRelationId);\n\telse\n\t\tsnapshot = GetCatalogSnapshot(RelationRelationId);\n\n\tpg_class_scan = systable_beginscan(pg_class_desc, ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t   indexOK && criticalRelcachesBuilt,\n\t\t\t\t\t\t\t\t\t   snapshot,\n\t\t\t\t\t\t\t\t\t   1, key);\n\n\tpg_class_tuple = systable_getnext(pg_class_scan);\n\n\t/*\n\t * Must copy tuple before releasing buffer.\n\t */\n\tif (HeapTupleIsValid(pg_class_tuple))\n\t\tpg_class_tuple = heap_copytuple(pg_class_tuple);\n\n\t/* all done */\n\tsystable_endscan(pg_class_scan);\n\theap_close(pg_class_desc, AccessShareLock);\n\n\treturn pg_class_tuple;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationReloadIndexInfo",
          "args": [
            "relation"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "RelationReloadIndexInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2049-2149",
          "snippet": "static void\nRelationReloadIndexInfo(Relation relation)\n{\n\tbool\t\tindexOK;\n\tHeapTuple\tpg_class_tuple;\n\tForm_pg_class relp;\n\n\t/* Should be called only for invalidated indexes */\n\tAssert((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t\trelation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\t   !relation->rd_isvalid);\n\n\t/* Ensure it's closed at smgr level */\n\tRelationCloseSmgr(relation);\n\n\t/* Must free any AM cached data upon relcache flush */\n\tif (relation->rd_amcache)\n\t\tpfree(relation->rd_amcache);\n\trelation->rd_amcache = NULL;\n\n\t/*\n\t * If it's a shared index, we might be called before backend startup has\n\t * finished selecting a database, in which case we have no way to read\n\t * pg_class yet.  However, a shared index can never have any significant\n\t * schema updates, so it's okay to ignore the invalidation signal.  Just\n\t * mark it valid and return without doing anything more.\n\t */\n\tif (relation->rd_rel->relisshared && !criticalRelcachesBuilt)\n\t{\n\t\trelation->rd_isvalid = true;\n\t\treturn;\n\t}\n\n\t/*\n\t * Read the pg_class row\n\t *\n\t * Don't try to use an indexscan of pg_class_oid_index to reload the info\n\t * for pg_class_oid_index ...\n\t */\n\tindexOK = (RelationGetRelid(relation) != ClassOidIndexId);\n\tpg_class_tuple = ScanPgRelation(RelationGetRelid(relation), indexOK, false);\n\tif (!HeapTupleIsValid(pg_class_tuple))\n\t\telog(ERROR, \"could not find pg_class tuple for index %u\",\n\t\t\t RelationGetRelid(relation));\n\trelp = (Form_pg_class) GETSTRUCT(pg_class_tuple);\n\tmemcpy(relation->rd_rel, relp, CLASS_TUPLE_SIZE);\n\t/* Reload reloptions in case they changed */\n\tif (relation->rd_options)\n\t\tpfree(relation->rd_options);\n\tRelationParseRelOptions(relation, pg_class_tuple);\n\t/* done with pg_class tuple */\n\theap_freetuple(pg_class_tuple);\n\t/* We must recalculate physical address in case it changed */\n\tRelationInitPhysicalAddr(relation);\n\n\t/*\n\t * For a non-system index, there are fields of the pg_index row that are\n\t * allowed to change, so re-read that row and update the relcache entry.\n\t * Most of the info derived from pg_index (such as support function lookup\n\t * info) cannot change, and indeed the whole point of this routine is to\n\t * update the relcache entry without clobbering that data; so wholesale\n\t * replacement is not appropriate.\n\t */\n\tif (!IsSystemRelation(relation))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_index index;\n\n\t\ttuple = SearchSysCache1(INDEXRELID,\n\t\t\t\t\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for index %u\",\n\t\t\t\t RelationGetRelid(relation));\n\t\tindex = (Form_pg_index) GETSTRUCT(tuple);\n\n\t\t/*\n\t\t * Basically, let's just copy all the bool fields.  There are one or\n\t\t * two of these that can't actually change in the current code, but\n\t\t * it's not worth it to track exactly which ones they are.  None of\n\t\t * the array fields are allowed to change, though.\n\t\t */\n\t\trelation->rd_index->indisunique = index->indisunique;\n\t\trelation->rd_index->indisprimary = index->indisprimary;\n\t\trelation->rd_index->indisexclusion = index->indisexclusion;\n\t\trelation->rd_index->indimmediate = index->indimmediate;\n\t\trelation->rd_index->indisclustered = index->indisclustered;\n\t\trelation->rd_index->indisvalid = index->indisvalid;\n\t\trelation->rd_index->indcheckxmin = index->indcheckxmin;\n\t\trelation->rd_index->indisready = index->indisready;\n\t\trelation->rd_index->indislive = index->indislive;\n\n\t\t/* Copy xmin too, as that is needed to make sense of indcheckxmin */\n\t\tHeapTupleHeaderSetXmin(relation->rd_indextuple->t_data,\n\t\t\t\t\t\t\t   HeapTupleHeaderGetXmin(tuple->t_data));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\n\t/* Okay, now it's valid again */\n\trelation->rd_isvalid = true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool\t\tcriticalRelcachesBuilt = false;",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static bool load_relcache_init_file(bool shared);",
            "static void write_relcache_init_file(bool shared);",
            "static Relation AllocateRelationDesc(Form_pg_class relp);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nbool\t\tcriticalRelcachesBuilt = false;\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic bool load_relcache_init_file(bool shared);\nstatic void write_relcache_init_file(bool shared);\nstatic Relation AllocateRelationDesc(Form_pg_class relp);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationReloadIndexInfo(Relation relation)\n{\n\tbool\t\tindexOK;\n\tHeapTuple\tpg_class_tuple;\n\tForm_pg_class relp;\n\n\t/* Should be called only for invalidated indexes */\n\tAssert((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t\trelation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\t   !relation->rd_isvalid);\n\n\t/* Ensure it's closed at smgr level */\n\tRelationCloseSmgr(relation);\n\n\t/* Must free any AM cached data upon relcache flush */\n\tif (relation->rd_amcache)\n\t\tpfree(relation->rd_amcache);\n\trelation->rd_amcache = NULL;\n\n\t/*\n\t * If it's a shared index, we might be called before backend startup has\n\t * finished selecting a database, in which case we have no way to read\n\t * pg_class yet.  However, a shared index can never have any significant\n\t * schema updates, so it's okay to ignore the invalidation signal.  Just\n\t * mark it valid and return without doing anything more.\n\t */\n\tif (relation->rd_rel->relisshared && !criticalRelcachesBuilt)\n\t{\n\t\trelation->rd_isvalid = true;\n\t\treturn;\n\t}\n\n\t/*\n\t * Read the pg_class row\n\t *\n\t * Don't try to use an indexscan of pg_class_oid_index to reload the info\n\t * for pg_class_oid_index ...\n\t */\n\tindexOK = (RelationGetRelid(relation) != ClassOidIndexId);\n\tpg_class_tuple = ScanPgRelation(RelationGetRelid(relation), indexOK, false);\n\tif (!HeapTupleIsValid(pg_class_tuple))\n\t\telog(ERROR, \"could not find pg_class tuple for index %u\",\n\t\t\t RelationGetRelid(relation));\n\trelp = (Form_pg_class) GETSTRUCT(pg_class_tuple);\n\tmemcpy(relation->rd_rel, relp, CLASS_TUPLE_SIZE);\n\t/* Reload reloptions in case they changed */\n\tif (relation->rd_options)\n\t\tpfree(relation->rd_options);\n\tRelationParseRelOptions(relation, pg_class_tuple);\n\t/* done with pg_class tuple */\n\theap_freetuple(pg_class_tuple);\n\t/* We must recalculate physical address in case it changed */\n\tRelationInitPhysicalAddr(relation);\n\n\t/*\n\t * For a non-system index, there are fields of the pg_index row that are\n\t * allowed to change, so re-read that row and update the relcache entry.\n\t * Most of the info derived from pg_index (such as support function lookup\n\t * info) cannot change, and indeed the whole point of this routine is to\n\t * update the relcache entry without clobbering that data; so wholesale\n\t * replacement is not appropriate.\n\t */\n\tif (!IsSystemRelation(relation))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_index index;\n\n\t\ttuple = SearchSysCache1(INDEXRELID,\n\t\t\t\t\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for index %u\",\n\t\t\t\t RelationGetRelid(relation));\n\t\tindex = (Form_pg_index) GETSTRUCT(tuple);\n\n\t\t/*\n\t\t * Basically, let's just copy all the bool fields.  There are one or\n\t\t * two of these that can't actually change in the current code, but\n\t\t * it's not worth it to track exactly which ones they are.  None of\n\t\t * the array fields are allowed to change, though.\n\t\t */\n\t\trelation->rd_index->indisunique = index->indisunique;\n\t\trelation->rd_index->indisprimary = index->indisprimary;\n\t\trelation->rd_index->indisexclusion = index->indisexclusion;\n\t\trelation->rd_index->indimmediate = index->indimmediate;\n\t\trelation->rd_index->indisclustered = index->indisclustered;\n\t\trelation->rd_index->indisvalid = index->indisvalid;\n\t\trelation->rd_index->indcheckxmin = index->indcheckxmin;\n\t\trelation->rd_index->indisready = index->indisready;\n\t\trelation->rd_index->indislive = index->indislive;\n\n\t\t/* Copy xmin too, as that is needed to make sense of indcheckxmin */\n\t\tHeapTupleHeaderSetXmin(relation->rd_indextuple->t_data,\n\t\t\t\t\t\t\t   HeapTupleHeaderGetXmin(tuple->t_data));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\n\t/* Okay, now it's valid again */\n\trelation->rd_isvalid = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsTransactionState",
          "args": [],
          "line": 2180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationInitPhysicalAddr",
          "args": [
            "relation"
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "RelationInitPhysicalAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1259-1315",
          "snippet": "static void\nRelationInitPhysicalAddr(Relation relation)\n{\n\tif (relation->rd_rel->reltablespace)\n\t\trelation->rd_node.spcNode = relation->rd_rel->reltablespace;\n\telse\n\t\trelation->rd_node.spcNode = MyDatabaseTableSpace;\n\tif (relation->rd_node.spcNode == GLOBALTABLESPACE_OID)\n\t\trelation->rd_node.dbNode = InvalidOid;\n\telse\n\t\trelation->rd_node.dbNode = MyDatabaseId;\n\n\tif (relation->rd_rel->relfilenode)\n\t{\n\t\t/*\n\t\t * Even if we are using a decoding snapshot that doesn't represent the\n\t\t * current state of the catalog we need to make sure the filenode\n\t\t * points to the current file since the older file will be gone (or\n\t\t * truncated). The new file will still contain older rows so lookups\n\t\t * in them will work correctly. This wouldn't work correctly if\n\t\t * rewrites were allowed to change the schema in an incompatible way,\n\t\t * but those are prevented both on catalog tables and on user tables\n\t\t * declared as additional catalog tables.\n\t\t */\n\t\tif (HistoricSnapshotActive()\n\t\t\t&& RelationIsAccessibleInLogicalDecoding(relation)\n\t\t\t&& IsTransactionState())\n\t\t{\n\t\t\tHeapTuple\tphys_tuple;\n\t\t\tForm_pg_class physrel;\n\n\t\t\tphys_tuple = ScanPgRelation(RelationGetRelid(relation),\n\t\t\t\t\t\t\t\t\t\tRelationGetRelid(relation) != ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t\ttrue);\n\t\t\tif (!HeapTupleIsValid(phys_tuple))\n\t\t\t\telog(ERROR, \"could not find pg_class entry for %u\",\n\t\t\t\t\t RelationGetRelid(relation));\n\t\t\tphysrel = (Form_pg_class) GETSTRUCT(phys_tuple);\n\n\t\t\trelation->rd_rel->reltablespace = physrel->reltablespace;\n\t\t\trelation->rd_rel->relfilenode = physrel->relfilenode;\n\t\t\theap_freetuple(phys_tuple);\n\t\t}\n\n\t\trelation->rd_node.relNode = relation->rd_rel->relfilenode;\n\t}\n\telse\n\t{\n\t\t/* Consult the relation mapper */\n\t\trelation->rd_node.relNode =\n\t\t\tRelationMapOidToFilenode(relation->rd_id,\n\t\t\t\t\t\t\t\t\t relation->rd_rel->relisshared);\n\t\tif (!OidIsValid(relation->rd_node.relNode))\n\t\t\telog(ERROR, \"could not find relation mapping for relation \\\"%s\\\", OID %u\",\n\t\t\t\t RelationGetRelationName(relation), relation->rd_id);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationInitPhysicalAddr(Relation relation)\n{\n\tif (relation->rd_rel->reltablespace)\n\t\trelation->rd_node.spcNode = relation->rd_rel->reltablespace;\n\telse\n\t\trelation->rd_node.spcNode = MyDatabaseTableSpace;\n\tif (relation->rd_node.spcNode == GLOBALTABLESPACE_OID)\n\t\trelation->rd_node.dbNode = InvalidOid;\n\telse\n\t\trelation->rd_node.dbNode = MyDatabaseId;\n\n\tif (relation->rd_rel->relfilenode)\n\t{\n\t\t/*\n\t\t * Even if we are using a decoding snapshot that doesn't represent the\n\t\t * current state of the catalog we need to make sure the filenode\n\t\t * points to the current file since the older file will be gone (or\n\t\t * truncated). The new file will still contain older rows so lookups\n\t\t * in them will work correctly. This wouldn't work correctly if\n\t\t * rewrites were allowed to change the schema in an incompatible way,\n\t\t * but those are prevented both on catalog tables and on user tables\n\t\t * declared as additional catalog tables.\n\t\t */\n\t\tif (HistoricSnapshotActive()\n\t\t\t&& RelationIsAccessibleInLogicalDecoding(relation)\n\t\t\t&& IsTransactionState())\n\t\t{\n\t\t\tHeapTuple\tphys_tuple;\n\t\t\tForm_pg_class physrel;\n\n\t\t\tphys_tuple = ScanPgRelation(RelationGetRelid(relation),\n\t\t\t\t\t\t\t\t\t\tRelationGetRelid(relation) != ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t\ttrue);\n\t\t\tif (!HeapTupleIsValid(phys_tuple))\n\t\t\t\telog(ERROR, \"could not find pg_class entry for %u\",\n\t\t\t\t\t RelationGetRelid(relation));\n\t\t\tphysrel = (Form_pg_class) GETSTRUCT(phys_tuple);\n\n\t\t\trelation->rd_rel->reltablespace = physrel->reltablespace;\n\t\t\trelation->rd_rel->relfilenode = physrel->relfilenode;\n\t\t\theap_freetuple(phys_tuple);\n\t\t}\n\n\t\trelation->rd_node.relNode = relation->rd_rel->relfilenode;\n\t}\n\telse\n\t{\n\t\t/* Consult the relation mapper */\n\t\trelation->rd_node.relNode =\n\t\t\tRelationMapOidToFilenode(relation->rd_id,\n\t\t\t\t\t\t\t\t\t relation->rd_rel->relisshared);\n\t\tif (!OidIsValid(relation->rd_node.relNode))\n\t\t\telog(ERROR, \"could not find relation mapping for relation \\\"%s\\\", OID %u\",\n\t\t\t\t RelationGetRelationName(relation), relation->rd_id);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relation->rd_isnailed"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nbool\t\tcriticalRelcachesBuilt = false;\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic Relation AllocateRelationDesc(Form_pg_class relp);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationReloadNailed(Relation relation)\n{\n\tAssert(relation->rd_isnailed);\n\n\t/*\n\t * Redo RelationInitPhysicalAddr in case it is a mapped relation whose\n\t * mapping changed.\n\t */\n\tRelationInitPhysicalAddr(relation);\n\n\t/* flag as needing to be revalidated */\n\trelation->rd_isvalid = false;\n\n\t/*\n\t * Can only reread catalog contents if in a transaction.  If the relation\n\t * is currently open (not counting the nailed refcount), do so\n\t * immediately. Otherwise we've already marked the entry as possibly\n\t * invalid, and it'll be fixed when next opened.\n\t */\n\tif (!IsTransactionState() || relation->rd_refcnt <= 1)\n\t\treturn;\n\n\tif (relation->rd_rel->relkind == RELKIND_INDEX)\n\t{\n\t\t/*\n\t\t * If it's a nailed-but-not-mapped index, then we need to re-read the\n\t\t * pg_class row to see if its relfilenode changed.\n\t\t */\n\t\tRelationReloadIndexInfo(relation);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Reload a non-index entry.  We can't easily do so if relcaches\n\t\t * aren't yet built, but that's fine because at that stage the\n\t\t * attributes that need to be current (like relfrozenxid) aren't yet\n\t\t * accessed.  To ensure the entry will later be revalidated, we leave\n\t\t * it in invalid state, but allow use (cf. RelationIdGetRelation()).\n\t\t */\n\t\tif (criticalRelcachesBuilt)\n\t\t{\n\t\t\tHeapTuple\tpg_class_tuple;\n\t\t\tForm_pg_class relp;\n\n\t\t\t/*\n\t\t\t * NB: Mark the entry as valid before starting to scan, to avoid\n\t\t\t * self-recursion when re-building pg_class.\n\t\t\t */\n\t\t\trelation->rd_isvalid = true;\n\n\t\t\tpg_class_tuple = ScanPgRelation(RelationGetRelid(relation),\n\t\t\t\t\t\t\t\t\t\t\ttrue, false);\n\t\t\trelp = (Form_pg_class) GETSTRUCT(pg_class_tuple);\n\t\t\tmemcpy(relation->rd_rel, relp, CLASS_TUPLE_SIZE);\n\t\t\theap_freetuple(pg_class_tuple);\n\n\t\t\t/*\n\t\t\t * Again mark as valid, to protect against concurrently arriving\n\t\t\t * invalidations.\n\t\t\t */\n\t\t\trelation->rd_isvalid = true;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "RelationReloadIndexInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "2049-2149",
    "snippet": "static void\nRelationReloadIndexInfo(Relation relation)\n{\n\tbool\t\tindexOK;\n\tHeapTuple\tpg_class_tuple;\n\tForm_pg_class relp;\n\n\t/* Should be called only for invalidated indexes */\n\tAssert((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t\trelation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\t   !relation->rd_isvalid);\n\n\t/* Ensure it's closed at smgr level */\n\tRelationCloseSmgr(relation);\n\n\t/* Must free any AM cached data upon relcache flush */\n\tif (relation->rd_amcache)\n\t\tpfree(relation->rd_amcache);\n\trelation->rd_amcache = NULL;\n\n\t/*\n\t * If it's a shared index, we might be called before backend startup has\n\t * finished selecting a database, in which case we have no way to read\n\t * pg_class yet.  However, a shared index can never have any significant\n\t * schema updates, so it's okay to ignore the invalidation signal.  Just\n\t * mark it valid and return without doing anything more.\n\t */\n\tif (relation->rd_rel->relisshared && !criticalRelcachesBuilt)\n\t{\n\t\trelation->rd_isvalid = true;\n\t\treturn;\n\t}\n\n\t/*\n\t * Read the pg_class row\n\t *\n\t * Don't try to use an indexscan of pg_class_oid_index to reload the info\n\t * for pg_class_oid_index ...\n\t */\n\tindexOK = (RelationGetRelid(relation) != ClassOidIndexId);\n\tpg_class_tuple = ScanPgRelation(RelationGetRelid(relation), indexOK, false);\n\tif (!HeapTupleIsValid(pg_class_tuple))\n\t\telog(ERROR, \"could not find pg_class tuple for index %u\",\n\t\t\t RelationGetRelid(relation));\n\trelp = (Form_pg_class) GETSTRUCT(pg_class_tuple);\n\tmemcpy(relation->rd_rel, relp, CLASS_TUPLE_SIZE);\n\t/* Reload reloptions in case they changed */\n\tif (relation->rd_options)\n\t\tpfree(relation->rd_options);\n\tRelationParseRelOptions(relation, pg_class_tuple);\n\t/* done with pg_class tuple */\n\theap_freetuple(pg_class_tuple);\n\t/* We must recalculate physical address in case it changed */\n\tRelationInitPhysicalAddr(relation);\n\n\t/*\n\t * For a non-system index, there are fields of the pg_index row that are\n\t * allowed to change, so re-read that row and update the relcache entry.\n\t * Most of the info derived from pg_index (such as support function lookup\n\t * info) cannot change, and indeed the whole point of this routine is to\n\t * update the relcache entry without clobbering that data; so wholesale\n\t * replacement is not appropriate.\n\t */\n\tif (!IsSystemRelation(relation))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_index index;\n\n\t\ttuple = SearchSysCache1(INDEXRELID,\n\t\t\t\t\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for index %u\",\n\t\t\t\t RelationGetRelid(relation));\n\t\tindex = (Form_pg_index) GETSTRUCT(tuple);\n\n\t\t/*\n\t\t * Basically, let's just copy all the bool fields.  There are one or\n\t\t * two of these that can't actually change in the current code, but\n\t\t * it's not worth it to track exactly which ones they are.  None of\n\t\t * the array fields are allowed to change, though.\n\t\t */\n\t\trelation->rd_index->indisunique = index->indisunique;\n\t\trelation->rd_index->indisprimary = index->indisprimary;\n\t\trelation->rd_index->indisexclusion = index->indisexclusion;\n\t\trelation->rd_index->indimmediate = index->indimmediate;\n\t\trelation->rd_index->indisclustered = index->indisclustered;\n\t\trelation->rd_index->indisvalid = index->indisvalid;\n\t\trelation->rd_index->indcheckxmin = index->indcheckxmin;\n\t\trelation->rd_index->indisready = index->indisready;\n\t\trelation->rd_index->indislive = index->indislive;\n\n\t\t/* Copy xmin too, as that is needed to make sense of indcheckxmin */\n\t\tHeapTupleHeaderSetXmin(relation->rd_indextuple->t_data,\n\t\t\t\t\t\t\t   HeapTupleHeaderGetXmin(tuple->t_data));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\n\t/* Okay, now it's valid again */\n\trelation->rd_isvalid = true;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool\t\tcriticalRelcachesBuilt = false;",
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static bool load_relcache_init_file(bool shared);",
      "static void write_relcache_init_file(bool shared);",
      "static Relation AllocateRelationDesc(Form_pg_class relp);",
      "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tuple"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderSetXmin",
          "args": [
            "relation->rd_indextuple->t_data",
            "HeapTupleHeaderGetXmin(tuple->t_data)"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleHeaderGetXmin",
          "args": [
            "tuple->t_data"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for index %u\"",
            "RelationGetRelid(relation)"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "INDEXRELID",
            "ObjectIdGetDatum(RelationGetRelid(relation))"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "RelationGetRelid(relation)"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsSystemRelation",
          "args": [
            "relation"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationInitPhysicalAddr",
          "args": [
            "relation"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "RelationInitPhysicalAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1259-1315",
          "snippet": "static void\nRelationInitPhysicalAddr(Relation relation)\n{\n\tif (relation->rd_rel->reltablespace)\n\t\trelation->rd_node.spcNode = relation->rd_rel->reltablespace;\n\telse\n\t\trelation->rd_node.spcNode = MyDatabaseTableSpace;\n\tif (relation->rd_node.spcNode == GLOBALTABLESPACE_OID)\n\t\trelation->rd_node.dbNode = InvalidOid;\n\telse\n\t\trelation->rd_node.dbNode = MyDatabaseId;\n\n\tif (relation->rd_rel->relfilenode)\n\t{\n\t\t/*\n\t\t * Even if we are using a decoding snapshot that doesn't represent the\n\t\t * current state of the catalog we need to make sure the filenode\n\t\t * points to the current file since the older file will be gone (or\n\t\t * truncated). The new file will still contain older rows so lookups\n\t\t * in them will work correctly. This wouldn't work correctly if\n\t\t * rewrites were allowed to change the schema in an incompatible way,\n\t\t * but those are prevented both on catalog tables and on user tables\n\t\t * declared as additional catalog tables.\n\t\t */\n\t\tif (HistoricSnapshotActive()\n\t\t\t&& RelationIsAccessibleInLogicalDecoding(relation)\n\t\t\t&& IsTransactionState())\n\t\t{\n\t\t\tHeapTuple\tphys_tuple;\n\t\t\tForm_pg_class physrel;\n\n\t\t\tphys_tuple = ScanPgRelation(RelationGetRelid(relation),\n\t\t\t\t\t\t\t\t\t\tRelationGetRelid(relation) != ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t\ttrue);\n\t\t\tif (!HeapTupleIsValid(phys_tuple))\n\t\t\t\telog(ERROR, \"could not find pg_class entry for %u\",\n\t\t\t\t\t RelationGetRelid(relation));\n\t\t\tphysrel = (Form_pg_class) GETSTRUCT(phys_tuple);\n\n\t\t\trelation->rd_rel->reltablespace = physrel->reltablespace;\n\t\t\trelation->rd_rel->relfilenode = physrel->relfilenode;\n\t\t\theap_freetuple(phys_tuple);\n\t\t}\n\n\t\trelation->rd_node.relNode = relation->rd_rel->relfilenode;\n\t}\n\telse\n\t{\n\t\t/* Consult the relation mapper */\n\t\trelation->rd_node.relNode =\n\t\t\tRelationMapOidToFilenode(relation->rd_id,\n\t\t\t\t\t\t\t\t\t relation->rd_rel->relisshared);\n\t\tif (!OidIsValid(relation->rd_node.relNode))\n\t\t\telog(ERROR, \"could not find relation mapping for relation \\\"%s\\\", OID %u\",\n\t\t\t\t RelationGetRelationName(relation), relation->rd_id);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationInitPhysicalAddr(Relation relation)\n{\n\tif (relation->rd_rel->reltablespace)\n\t\trelation->rd_node.spcNode = relation->rd_rel->reltablespace;\n\telse\n\t\trelation->rd_node.spcNode = MyDatabaseTableSpace;\n\tif (relation->rd_node.spcNode == GLOBALTABLESPACE_OID)\n\t\trelation->rd_node.dbNode = InvalidOid;\n\telse\n\t\trelation->rd_node.dbNode = MyDatabaseId;\n\n\tif (relation->rd_rel->relfilenode)\n\t{\n\t\t/*\n\t\t * Even if we are using a decoding snapshot that doesn't represent the\n\t\t * current state of the catalog we need to make sure the filenode\n\t\t * points to the current file since the older file will be gone (or\n\t\t * truncated). The new file will still contain older rows so lookups\n\t\t * in them will work correctly. This wouldn't work correctly if\n\t\t * rewrites were allowed to change the schema in an incompatible way,\n\t\t * but those are prevented both on catalog tables and on user tables\n\t\t * declared as additional catalog tables.\n\t\t */\n\t\tif (HistoricSnapshotActive()\n\t\t\t&& RelationIsAccessibleInLogicalDecoding(relation)\n\t\t\t&& IsTransactionState())\n\t\t{\n\t\t\tHeapTuple\tphys_tuple;\n\t\t\tForm_pg_class physrel;\n\n\t\t\tphys_tuple = ScanPgRelation(RelationGetRelid(relation),\n\t\t\t\t\t\t\t\t\t\tRelationGetRelid(relation) != ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t\ttrue);\n\t\t\tif (!HeapTupleIsValid(phys_tuple))\n\t\t\t\telog(ERROR, \"could not find pg_class entry for %u\",\n\t\t\t\t\t RelationGetRelid(relation));\n\t\t\tphysrel = (Form_pg_class) GETSTRUCT(phys_tuple);\n\n\t\t\trelation->rd_rel->reltablespace = physrel->reltablespace;\n\t\t\trelation->rd_rel->relfilenode = physrel->relfilenode;\n\t\t\theap_freetuple(phys_tuple);\n\t\t}\n\n\t\trelation->rd_node.relNode = relation->rd_rel->relfilenode;\n\t}\n\telse\n\t{\n\t\t/* Consult the relation mapper */\n\t\trelation->rd_node.relNode =\n\t\t\tRelationMapOidToFilenode(relation->rd_id,\n\t\t\t\t\t\t\t\t\t relation->rd_rel->relisshared);\n\t\tif (!OidIsValid(relation->rd_node.relNode))\n\t\t\telog(ERROR, \"could not find relation mapping for relation \\\"%s\\\", OID %u\",\n\t\t\t\t RelationGetRelationName(relation), relation->rd_id);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_freetuple",
          "args": [
            "pg_class_tuple"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationParseRelOptions",
          "args": [
            "relation",
            "pg_class_tuple"
          ],
          "line": 2098
        },
        "resolved": true,
        "details": {
          "function_name": "RelationParseRelOptions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "434-483",
          "snippet": "static void\nRelationParseRelOptions(Relation relation, HeapTuple tuple)\n{\n\tbytea\t   *options;\n\tamoptions_function amoptsfn;\n\n\trelation->rd_options = NULL;\n\n\t/*\n\t * Look up any AM-specific parse function; fall out if relkind should not\n\t * have options.\n\t */\n\tswitch (relation->rd_rel->relkind)\n\t{\n\t\tcase RELKIND_RELATION:\n\t\tcase RELKIND_TOASTVALUE:\n\t\tcase RELKIND_VIEW:\n\t\tcase RELKIND_MATVIEW:\n\t\tcase RELKIND_PARTITIONED_TABLE:\n\t\t\tamoptsfn = NULL;\n\t\t\tbreak;\n\t\tcase RELKIND_INDEX:\n\t\tcase RELKIND_PARTITIONED_INDEX:\n\t\t\tamoptsfn = relation->rd_amroutine->amoptions;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Fetch reloptions from tuple; have to use a hardwired descriptor because\n\t * we might not have any other for pg_class yet (consider executing this\n\t * code for pg_class itself)\n\t */\n\toptions = extractRelOptions(tuple, GetPgClassDescriptor(), amoptsfn);\n\n\t/*\n\t * Copy parsed data into CacheMemoryContext.  To guard against the\n\t * possibility of leaks in the reloptions code, we want to do the actual\n\t * parsing in the caller's memory context and copy the results into\n\t * CacheMemoryContext after the fact.\n\t */\n\tif (options)\n\t{\n\t\trelation->rd_options = MemoryContextAlloc(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t  VARSIZE(options));\n\t\tmemcpy(relation->rd_options, options, VARSIZE(options));\n\t\tpfree(options);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static TupleDesc GetPgClassDescriptor(void);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic TupleDesc GetPgClassDescriptor(void);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationParseRelOptions(Relation relation, HeapTuple tuple)\n{\n\tbytea\t   *options;\n\tamoptions_function amoptsfn;\n\n\trelation->rd_options = NULL;\n\n\t/*\n\t * Look up any AM-specific parse function; fall out if relkind should not\n\t * have options.\n\t */\n\tswitch (relation->rd_rel->relkind)\n\t{\n\t\tcase RELKIND_RELATION:\n\t\tcase RELKIND_TOASTVALUE:\n\t\tcase RELKIND_VIEW:\n\t\tcase RELKIND_MATVIEW:\n\t\tcase RELKIND_PARTITIONED_TABLE:\n\t\t\tamoptsfn = NULL;\n\t\t\tbreak;\n\t\tcase RELKIND_INDEX:\n\t\tcase RELKIND_PARTITIONED_INDEX:\n\t\t\tamoptsfn = relation->rd_amroutine->amoptions;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Fetch reloptions from tuple; have to use a hardwired descriptor because\n\t * we might not have any other for pg_class yet (consider executing this\n\t * code for pg_class itself)\n\t */\n\toptions = extractRelOptions(tuple, GetPgClassDescriptor(), amoptsfn);\n\n\t/*\n\t * Copy parsed data into CacheMemoryContext.  To guard against the\n\t * possibility of leaks in the reloptions code, we want to do the actual\n\t * parsing in the caller's memory context and copy the results into\n\t * CacheMemoryContext after the fact.\n\t */\n\tif (options)\n\t{\n\t\trelation->rd_options = MemoryContextAlloc(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t  VARSIZE(options));\n\t\tmemcpy(relation->rd_options, options, VARSIZE(options));\n\t\tpfree(options);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "relation->rd_options"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "relation->rd_rel",
            "relp",
            "CLASS_TUPLE_SIZE"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "pg_class_tuple"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "pg_class_tuple"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanPgRelation",
          "args": [
            "RelationGetRelid(relation)",
            "indexOK",
            "false"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "ScanPgRelation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "308-370",
          "snippet": "static HeapTuple\nScanPgRelation(Oid targetRelId, bool indexOK, bool force_non_historic)\n{\n\tHeapTuple\tpg_class_tuple;\n\tRelation\tpg_class_desc;\n\tSysScanDesc pg_class_scan;\n\tScanKeyData key[1];\n\tSnapshot\tsnapshot;\n\n\t/*\n\t * If something goes wrong during backend startup, we might find ourselves\n\t * trying to read pg_class before we've selected a database.  That ain't\n\t * gonna work, so bail out with a useful error message.  If this happens,\n\t * it probably means a relcache entry that needs to be nailed isn't.\n\t */\n\tif (!OidIsValid(MyDatabaseId))\n\t\telog(FATAL, \"cannot read pg_class without having selected a database\");\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(targetRelId));\n\n\t/*\n\t * Open pg_class and fetch a tuple.  Force heap scan if we haven't yet\n\t * built the critical relcache entries (this includes initdb and startup\n\t * without a pg_internal.init file).  The caller can also force a heap\n\t * scan by setting indexOK == false.\n\t */\n\tpg_class_desc = heap_open(RelationRelationId, AccessShareLock);\n\n\t/*\n\t * The caller might need a tuple that's newer than the one the historic\n\t * snapshot; currently the only case requiring to do so is looking up the\n\t * relfilenode of non mapped system relations during decoding.\n\t */\n\tif (force_non_historic)\n\t\tsnapshot = GetNonHistoricCatalogSnapshot(RelationRelationId);\n\telse\n\t\tsnapshot = GetCatalogSnapshot(RelationRelationId);\n\n\tpg_class_scan = systable_beginscan(pg_class_desc, ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t   indexOK && criticalRelcachesBuilt,\n\t\t\t\t\t\t\t\t\t   snapshot,\n\t\t\t\t\t\t\t\t\t   1, key);\n\n\tpg_class_tuple = systable_getnext(pg_class_scan);\n\n\t/*\n\t * Must copy tuple before releasing buffer.\n\t */\n\tif (HeapTupleIsValid(pg_class_tuple))\n\t\tpg_class_tuple = heap_copytuple(pg_class_tuple);\n\n\t/* all done */\n\tsystable_endscan(pg_class_scan);\n\theap_close(pg_class_desc, AccessShareLock);\n\n\treturn pg_class_tuple;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool\t\tcriticalRelcachesBuilt = false;",
            "static HeapTuple ScanPgRelation(Oid targetRelId, bool indexOK, bool force_non_historic);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nbool\t\tcriticalRelcachesBuilt = false;\nstatic HeapTuple ScanPgRelation(Oid targetRelId, bool indexOK, bool force_non_historic);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\n\nstatic HeapTuple\nScanPgRelation(Oid targetRelId, bool indexOK, bool force_non_historic)\n{\n\tHeapTuple\tpg_class_tuple;\n\tRelation\tpg_class_desc;\n\tSysScanDesc pg_class_scan;\n\tScanKeyData key[1];\n\tSnapshot\tsnapshot;\n\n\t/*\n\t * If something goes wrong during backend startup, we might find ourselves\n\t * trying to read pg_class before we've selected a database.  That ain't\n\t * gonna work, so bail out with a useful error message.  If this happens,\n\t * it probably means a relcache entry that needs to be nailed isn't.\n\t */\n\tif (!OidIsValid(MyDatabaseId))\n\t\telog(FATAL, \"cannot read pg_class without having selected a database\");\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(targetRelId));\n\n\t/*\n\t * Open pg_class and fetch a tuple.  Force heap scan if we haven't yet\n\t * built the critical relcache entries (this includes initdb and startup\n\t * without a pg_internal.init file).  The caller can also force a heap\n\t * scan by setting indexOK == false.\n\t */\n\tpg_class_desc = heap_open(RelationRelationId, AccessShareLock);\n\n\t/*\n\t * The caller might need a tuple that's newer than the one the historic\n\t * snapshot; currently the only case requiring to do so is looking up the\n\t * relfilenode of non mapped system relations during decoding.\n\t */\n\tif (force_non_historic)\n\t\tsnapshot = GetNonHistoricCatalogSnapshot(RelationRelationId);\n\telse\n\t\tsnapshot = GetCatalogSnapshot(RelationRelationId);\n\n\tpg_class_scan = systable_beginscan(pg_class_desc, ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t   indexOK && criticalRelcachesBuilt,\n\t\t\t\t\t\t\t\t\t   snapshot,\n\t\t\t\t\t\t\t\t\t   1, key);\n\n\tpg_class_tuple = systable_getnext(pg_class_scan);\n\n\t/*\n\t * Must copy tuple before releasing buffer.\n\t */\n\tif (HeapTupleIsValid(pg_class_tuple))\n\t\tpg_class_tuple = heap_copytuple(pg_class_tuple);\n\n\t/* all done */\n\tsystable_endscan(pg_class_scan);\n\theap_close(pg_class_desc, AccessShareLock);\n\n\treturn pg_class_tuple;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationCloseSmgr",
          "args": [
            "relation"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "RelationCloseSmgrByOid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2776-2787",
          "snippet": "void\nRelationCloseSmgrByOid(Oid relationId)\n{\n\tRelation\trelation;\n\n\tRelationIdCacheLookup(relationId, relation);\n\n\tif (!PointerIsValid(relation))\n\t\treturn;\t\t\t\t\t/* not in cache, nothing to do */\n\n\tRelationCloseSmgr(relation);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationCloseSmgrByOid(Oid relationId)\n{\n\tRelation\trelation;\n\n\tRelationIdCacheLookup(relationId, relation);\n\n\tif (!PointerIsValid(relation))\n\t\treturn;\t\t\t\t\t/* not in cache, nothing to do */\n\n\tRelationCloseSmgr(relation);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "(relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t\trelation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\t   !relation->rd_isvalid"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nbool\t\tcriticalRelcachesBuilt = false;\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic bool load_relcache_init_file(bool shared);\nstatic void write_relcache_init_file(bool shared);\nstatic Relation AllocateRelationDesc(Form_pg_class relp);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationReloadIndexInfo(Relation relation)\n{\n\tbool\t\tindexOK;\n\tHeapTuple\tpg_class_tuple;\n\tForm_pg_class relp;\n\n\t/* Should be called only for invalidated indexes */\n\tAssert((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t\trelation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\t   !relation->rd_isvalid);\n\n\t/* Ensure it's closed at smgr level */\n\tRelationCloseSmgr(relation);\n\n\t/* Must free any AM cached data upon relcache flush */\n\tif (relation->rd_amcache)\n\t\tpfree(relation->rd_amcache);\n\trelation->rd_amcache = NULL;\n\n\t/*\n\t * If it's a shared index, we might be called before backend startup has\n\t * finished selecting a database, in which case we have no way to read\n\t * pg_class yet.  However, a shared index can never have any significant\n\t * schema updates, so it's okay to ignore the invalidation signal.  Just\n\t * mark it valid and return without doing anything more.\n\t */\n\tif (relation->rd_rel->relisshared && !criticalRelcachesBuilt)\n\t{\n\t\trelation->rd_isvalid = true;\n\t\treturn;\n\t}\n\n\t/*\n\t * Read the pg_class row\n\t *\n\t * Don't try to use an indexscan of pg_class_oid_index to reload the info\n\t * for pg_class_oid_index ...\n\t */\n\tindexOK = (RelationGetRelid(relation) != ClassOidIndexId);\n\tpg_class_tuple = ScanPgRelation(RelationGetRelid(relation), indexOK, false);\n\tif (!HeapTupleIsValid(pg_class_tuple))\n\t\telog(ERROR, \"could not find pg_class tuple for index %u\",\n\t\t\t RelationGetRelid(relation));\n\trelp = (Form_pg_class) GETSTRUCT(pg_class_tuple);\n\tmemcpy(relation->rd_rel, relp, CLASS_TUPLE_SIZE);\n\t/* Reload reloptions in case they changed */\n\tif (relation->rd_options)\n\t\tpfree(relation->rd_options);\n\tRelationParseRelOptions(relation, pg_class_tuple);\n\t/* done with pg_class tuple */\n\theap_freetuple(pg_class_tuple);\n\t/* We must recalculate physical address in case it changed */\n\tRelationInitPhysicalAddr(relation);\n\n\t/*\n\t * For a non-system index, there are fields of the pg_index row that are\n\t * allowed to change, so re-read that row and update the relcache entry.\n\t * Most of the info derived from pg_index (such as support function lookup\n\t * info) cannot change, and indeed the whole point of this routine is to\n\t * update the relcache entry without clobbering that data; so wholesale\n\t * replacement is not appropriate.\n\t */\n\tif (!IsSystemRelation(relation))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_index index;\n\n\t\ttuple = SearchSysCache1(INDEXRELID,\n\t\t\t\t\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for index %u\",\n\t\t\t\t RelationGetRelid(relation));\n\t\tindex = (Form_pg_index) GETSTRUCT(tuple);\n\n\t\t/*\n\t\t * Basically, let's just copy all the bool fields.  There are one or\n\t\t * two of these that can't actually change in the current code, but\n\t\t * it's not worth it to track exactly which ones they are.  None of\n\t\t * the array fields are allowed to change, though.\n\t\t */\n\t\trelation->rd_index->indisunique = index->indisunique;\n\t\trelation->rd_index->indisprimary = index->indisprimary;\n\t\trelation->rd_index->indisexclusion = index->indisexclusion;\n\t\trelation->rd_index->indimmediate = index->indimmediate;\n\t\trelation->rd_index->indisclustered = index->indisclustered;\n\t\trelation->rd_index->indisvalid = index->indisvalid;\n\t\trelation->rd_index->indcheckxmin = index->indcheckxmin;\n\t\trelation->rd_index->indisready = index->indisready;\n\t\trelation->rd_index->indislive = index->indislive;\n\n\t\t/* Copy xmin too, as that is needed to make sense of indcheckxmin */\n\t\tHeapTupleHeaderSetXmin(relation->rd_indextuple->t_data,\n\t\t\t\t\t\t\t   HeapTupleHeaderGetXmin(tuple->t_data));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\n\t/* Okay, now it's valid again */\n\trelation->rd_isvalid = true;\n}"
  },
  {
    "function_name": "RelationClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "2008-2020",
    "snippet": "void\nRelationClose(Relation relation)\n{\n\t/* Note: no locking manipulations needed */\n\tRelationDecrementReferenceCount(relation);\n\n#ifdef RELCACHE_FORCE_RELEASE\n\tif (RelationHasReferenceCountZero(relation) &&\n\t\trelation->rd_createSubid == InvalidSubTransactionId &&\n\t\trelation->rd_newRelfilenodeSubid == InvalidSubTransactionId)\n\t\tRelationClearRelation(relation, false);\n#endif\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RelationClearRelation",
          "args": [
            "relation",
            "false"
          ],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "RelationClearRelation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2318-2553",
          "snippet": "static void\nRelationClearRelation(Relation relation, bool rebuild)\n{\n\t/*\n\t * As per notes above, a rel to be rebuilt MUST have refcnt > 0; while of\n\t * course it would be an equally bad idea to blow away one with nonzero\n\t * refcnt, since that would leave someone somewhere with a dangling\n\t * pointer.  All callers are expected to have verified that this holds.\n\t */\n\tAssert(rebuild ?\n\t\t   !RelationHasReferenceCountZero(relation) :\n\t\t   RelationHasReferenceCountZero(relation));\n\n\t/*\n\t * Make sure smgr and lower levels close the relation's files, if they\n\t * weren't closed already.  If the relation is not getting deleted, the\n\t * next smgr access should reopen the files automatically.  This ensures\n\t * that the low-level file access state is updated after, say, a vacuum\n\t * truncation.\n\t */\n\tRelationCloseSmgr(relation);\n\n\t/*\n\t * Treat nailed-in system relations separately, they always need to be\n\t * accessible, so we can't blow them away.\n\t */\n\tif (relation->rd_isnailed)\n\t{\n\t\tRelationReloadNailed(relation);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even non-system indexes should not be blown away if they are open and\n\t * have valid index support information.  This avoids problems with active\n\t * use of the index support information.  As with nailed indexes, we\n\t * re-read the pg_class row to handle possible physical relocation of the\n\t * index, and we check for pg_index updates too.\n\t */\n\tif ((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t relation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\trelation->rd_refcnt > 0 &&\n\t\trelation->rd_indexcxt != NULL)\n\t{\n\t\trelation->rd_isvalid = false;\t/* needs to be revalidated */\n\t\tif (IsTransactionState())\n\t\t\tRelationReloadIndexInfo(relation);\n\t\treturn;\n\t}\n\n\t/* Mark it invalid until we've finished rebuild */\n\trelation->rd_isvalid = false;\n\n\t/*\n\t * If we're really done with the relcache entry, blow it away. But if\n\t * someone is still using it, reconstruct the whole deal without moving\n\t * the physical RelationData record (so that the someone's pointer is\n\t * still valid).\n\t */\n\tif (!rebuild)\n\t{\n\t\t/* Remove it from the hash table */\n\t\tRelationCacheDelete(relation);\n\n\t\t/* And release storage */\n\t\tRelationDestroyRelation(relation, false);\n\t}\n\telse if (!IsTransactionState())\n\t{\n\t\t/*\n\t\t * If we're not inside a valid transaction, we can't do any catalog\n\t\t * access so it's not possible to rebuild yet.  Just exit, leaving\n\t\t * rd_isvalid = false so that the rebuild will occur when the entry is\n\t\t * next opened.\n\t\t *\n\t\t * Note: it's possible that we come here during subtransaction abort,\n\t\t * and the reason for wanting to rebuild is that the rel is open in\n\t\t * the outer transaction.  In that case it might seem unsafe to not\n\t\t * rebuild immediately, since whatever code has the rel already open\n\t\t * will keep on using the relcache entry as-is.  However, in such a\n\t\t * case the outer transaction should be holding a lock that's\n\t\t * sufficient to prevent any significant change in the rel's schema,\n\t\t * so the existing entry contents should be good enough for its\n\t\t * purposes; at worst we might be behind on statistics updates or the\n\t\t * like.  (See also CheckTableNotInUse() and its callers.)\tThese same\n\t\t * remarks also apply to the cases above where we exit without having\n\t\t * done RelationReloadIndexInfo() yet.\n\t\t */\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Our strategy for rebuilding an open relcache entry is to build a\n\t\t * new entry from scratch, swap its contents with the old entry, and\n\t\t * finally delete the new entry (along with any infrastructure swapped\n\t\t * over from the old entry).  This is to avoid trouble in case an\n\t\t * error causes us to lose control partway through.  The old entry\n\t\t * will still be marked !rd_isvalid, so we'll try to rebuild it again\n\t\t * on next access.  Meanwhile it's not any less valid than it was\n\t\t * before, so any code that might expect to continue accessing it\n\t\t * isn't hurt by the rebuild failure.  (Consider for example a\n\t\t * subtransaction that ALTERs a table and then gets canceled partway\n\t\t * through the cache entry rebuild.  The outer transaction should\n\t\t * still see the not-modified cache entry as valid.)  The worst\n\t\t * consequence of an error is leaking the necessarily-unreferenced new\n\t\t * entry, and this shouldn't happen often enough for that to be a big\n\t\t * problem.\n\t\t *\n\t\t * When rebuilding an open relcache entry, we must preserve ref count,\n\t\t * rd_createSubid/rd_newRelfilenodeSubid, and rd_toastoid state.  Also\n\t\t * attempt to preserve the pg_class entry (rd_rel), tupledesc,\n\t\t * rewrite-rule, partition key, and partition descriptor substructures\n\t\t * in place, because various places assume that these structures won't\n\t\t * move while they are working with an open relcache entry.  (Note:\n\t\t * the refcount mechanism for tupledescs might someday allow us to\n\t\t * remove this hack for the tupledesc.)\n\t\t *\n\t\t * Note that this process does not touch CurrentResourceOwner; which\n\t\t * is good because whatever ref counts the entry may have do not\n\t\t * necessarily belong to that resource owner.\n\t\t */\n\t\tRelation\tnewrel;\n\t\tOid\t\t\tsave_relid = RelationGetRelid(relation);\n\t\tbool\t\tkeep_tupdesc;\n\t\tbool\t\tkeep_rules;\n\t\tbool\t\tkeep_policies;\n\t\tbool\t\tkeep_partkey;\n\t\tbool\t\tkeep_partdesc;\n\n\t\t/* Build temporary entry, but don't link it into hashtable */\n\t\tnewrel = RelationBuildDesc(save_relid, false);\n\t\tif (newrel == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * We can validly get here, if we're using a historic snapshot in\n\t\t\t * which a relation, accessed from outside logical decoding, is\n\t\t\t * still invisible. In that case it's fine to just mark the\n\t\t\t * relation as invalid and return - it'll fully get reloaded by\n\t\t\t * the cache reset at the end of logical decoding (or at the next\n\t\t\t * access).  During normal processing we don't want to ignore this\n\t\t\t * case as it shouldn't happen there, as explained below.\n\t\t\t */\n\t\t\tif (HistoricSnapshotActive())\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * This shouldn't happen as dropping a relation is intended to be\n\t\t\t * impossible if still referenced (cf. CheckTableNotInUse()). But\n\t\t\t * if we get here anyway, we can't just delete the relcache entry,\n\t\t\t * as it possibly could get accessed later (as e.g. the error\n\t\t\t * might get trapped and handled via a subtransaction rollback).\n\t\t\t */\n\t\t\telog(ERROR, \"relation %u deleted while still in use\", save_relid);\n\t\t}\n\n\t\tkeep_tupdesc = equalTupleDescs(relation->rd_att, newrel->rd_att);\n\t\tkeep_rules = equalRuleLocks(relation->rd_rules, newrel->rd_rules);\n\t\tkeep_policies = equalRSDesc(relation->rd_rsdesc, newrel->rd_rsdesc);\n\t\t/* partkey is immutable once set up, so we can always keep it */\n\t\tkeep_partkey = (relation->rd_partkey != NULL);\n\t\tkeep_partdesc = equalPartitionDescs(relation->rd_partkey,\n\t\t\t\t\t\t\t\t\t\t\trelation->rd_partdesc,\n\t\t\t\t\t\t\t\t\t\t\tnewrel->rd_partdesc);\n\n\t\t/*\n\t\t * Perform swapping of the relcache entry contents.  Within this\n\t\t * process the old entry is momentarily invalid, so there *must* be no\n\t\t * possibility of CHECK_FOR_INTERRUPTS within this sequence. Do it in\n\t\t * all-in-line code for safety.\n\t\t *\n\t\t * Since the vast majority of fields should be swapped, our method is\n\t\t * to swap the whole structures and then re-swap those few fields we\n\t\t * didn't want swapped.\n\t\t */\n#define SWAPFIELD(fldtype, fldname) \\\n\t\tdo { \\\n\t\t\tfldtype _tmp = newrel->fldname; \\\n\t\t\tnewrel->fldname = relation->fldname; \\\n\t\t\trelation->fldname = _tmp; \\\n\t\t} while (0)\n\n\t\t/* swap all Relation struct fields */\n\t\t{\n\t\t\tRelationData tmpstruct;\n\n\t\t\tmemcpy(&tmpstruct, newrel, sizeof(RelationData));\n\t\t\tmemcpy(newrel, relation, sizeof(RelationData));\n\t\t\tmemcpy(relation, &tmpstruct, sizeof(RelationData));\n\t\t}\n\n\t\t/* rd_smgr must not be swapped, due to back-links from smgr level */\n\t\tSWAPFIELD(SMgrRelation, rd_smgr);\n\t\t/* rd_refcnt must be preserved */\n\t\tSWAPFIELD(int, rd_refcnt);\n\t\t/* isnailed shouldn't change */\n\t\tAssert(newrel->rd_isnailed == relation->rd_isnailed);\n\t\t/* creation sub-XIDs must be preserved */\n\t\tSWAPFIELD(SubTransactionId, rd_createSubid);\n\t\tSWAPFIELD(SubTransactionId, rd_newRelfilenodeSubid);\n\t\t/* un-swap rd_rel pointers, swap contents instead */\n\t\tSWAPFIELD(Form_pg_class, rd_rel);\n\t\t/* ... but actually, we don't have to update newrel->rd_rel */\n\t\tmemcpy(relation->rd_rel, newrel->rd_rel, CLASS_TUPLE_SIZE);\n\t\t/* preserve old tupledesc, rules, policies if no logical change */\n\t\tif (keep_tupdesc)\n\t\t\tSWAPFIELD(TupleDesc, rd_att);\n\t\tif (keep_rules)\n\t\t{\n\t\t\tSWAPFIELD(RuleLock *, rd_rules);\n\t\t\tSWAPFIELD(MemoryContext, rd_rulescxt);\n\t\t}\n\t\tif (keep_policies)\n\t\t\tSWAPFIELD(RowSecurityDesc *, rd_rsdesc);\n\t\t/* toast OID override must be preserved */\n\t\tSWAPFIELD(Oid, rd_toastoid);\n\t\t/* pgstat_info must be preserved */\n\t\tSWAPFIELD(struct PgStat_TableStatus *, pgstat_info);\n\t\t/* preserve old partitioning info if no logical change */\n\t\tif (keep_partkey)\n\t\t{\n\t\t\tSWAPFIELD(PartitionKey, rd_partkey);\n\t\t\tSWAPFIELD(MemoryContext, rd_partkeycxt);\n\t\t}\n\t\tif (keep_partdesc)\n\t\t{\n\t\t\tSWAPFIELD(PartitionDesc, rd_partdesc);\n\t\t\tSWAPFIELD(MemoryContext, rd_pdcxt);\n\t\t}\n\n#undef SWAPFIELD\n\n\t\t/* And now we can throw away the temporary entry */\n\t\tRelationDestroyRelation(newrel, !keep_tupdesc);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationClearRelation(Relation relation, bool rebuild);",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationClearRelation(Relation relation, bool rebuild);\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationClearRelation(Relation relation, bool rebuild)\n{\n\t/*\n\t * As per notes above, a rel to be rebuilt MUST have refcnt > 0; while of\n\t * course it would be an equally bad idea to blow away one with nonzero\n\t * refcnt, since that would leave someone somewhere with a dangling\n\t * pointer.  All callers are expected to have verified that this holds.\n\t */\n\tAssert(rebuild ?\n\t\t   !RelationHasReferenceCountZero(relation) :\n\t\t   RelationHasReferenceCountZero(relation));\n\n\t/*\n\t * Make sure smgr and lower levels close the relation's files, if they\n\t * weren't closed already.  If the relation is not getting deleted, the\n\t * next smgr access should reopen the files automatically.  This ensures\n\t * that the low-level file access state is updated after, say, a vacuum\n\t * truncation.\n\t */\n\tRelationCloseSmgr(relation);\n\n\t/*\n\t * Treat nailed-in system relations separately, they always need to be\n\t * accessible, so we can't blow them away.\n\t */\n\tif (relation->rd_isnailed)\n\t{\n\t\tRelationReloadNailed(relation);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even non-system indexes should not be blown away if they are open and\n\t * have valid index support information.  This avoids problems with active\n\t * use of the index support information.  As with nailed indexes, we\n\t * re-read the pg_class row to handle possible physical relocation of the\n\t * index, and we check for pg_index updates too.\n\t */\n\tif ((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t relation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\trelation->rd_refcnt > 0 &&\n\t\trelation->rd_indexcxt != NULL)\n\t{\n\t\trelation->rd_isvalid = false;\t/* needs to be revalidated */\n\t\tif (IsTransactionState())\n\t\t\tRelationReloadIndexInfo(relation);\n\t\treturn;\n\t}\n\n\t/* Mark it invalid until we've finished rebuild */\n\trelation->rd_isvalid = false;\n\n\t/*\n\t * If we're really done with the relcache entry, blow it away. But if\n\t * someone is still using it, reconstruct the whole deal without moving\n\t * the physical RelationData record (so that the someone's pointer is\n\t * still valid).\n\t */\n\tif (!rebuild)\n\t{\n\t\t/* Remove it from the hash table */\n\t\tRelationCacheDelete(relation);\n\n\t\t/* And release storage */\n\t\tRelationDestroyRelation(relation, false);\n\t}\n\telse if (!IsTransactionState())\n\t{\n\t\t/*\n\t\t * If we're not inside a valid transaction, we can't do any catalog\n\t\t * access so it's not possible to rebuild yet.  Just exit, leaving\n\t\t * rd_isvalid = false so that the rebuild will occur when the entry is\n\t\t * next opened.\n\t\t *\n\t\t * Note: it's possible that we come here during subtransaction abort,\n\t\t * and the reason for wanting to rebuild is that the rel is open in\n\t\t * the outer transaction.  In that case it might seem unsafe to not\n\t\t * rebuild immediately, since whatever code has the rel already open\n\t\t * will keep on using the relcache entry as-is.  However, in such a\n\t\t * case the outer transaction should be holding a lock that's\n\t\t * sufficient to prevent any significant change in the rel's schema,\n\t\t * so the existing entry contents should be good enough for its\n\t\t * purposes; at worst we might be behind on statistics updates or the\n\t\t * like.  (See also CheckTableNotInUse() and its callers.)\tThese same\n\t\t * remarks also apply to the cases above where we exit without having\n\t\t * done RelationReloadIndexInfo() yet.\n\t\t */\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Our strategy for rebuilding an open relcache entry is to build a\n\t\t * new entry from scratch, swap its contents with the old entry, and\n\t\t * finally delete the new entry (along with any infrastructure swapped\n\t\t * over from the old entry).  This is to avoid trouble in case an\n\t\t * error causes us to lose control partway through.  The old entry\n\t\t * will still be marked !rd_isvalid, so we'll try to rebuild it again\n\t\t * on next access.  Meanwhile it's not any less valid than it was\n\t\t * before, so any code that might expect to continue accessing it\n\t\t * isn't hurt by the rebuild failure.  (Consider for example a\n\t\t * subtransaction that ALTERs a table and then gets canceled partway\n\t\t * through the cache entry rebuild.  The outer transaction should\n\t\t * still see the not-modified cache entry as valid.)  The worst\n\t\t * consequence of an error is leaking the necessarily-unreferenced new\n\t\t * entry, and this shouldn't happen often enough for that to be a big\n\t\t * problem.\n\t\t *\n\t\t * When rebuilding an open relcache entry, we must preserve ref count,\n\t\t * rd_createSubid/rd_newRelfilenodeSubid, and rd_toastoid state.  Also\n\t\t * attempt to preserve the pg_class entry (rd_rel), tupledesc,\n\t\t * rewrite-rule, partition key, and partition descriptor substructures\n\t\t * in place, because various places assume that these structures won't\n\t\t * move while they are working with an open relcache entry.  (Note:\n\t\t * the refcount mechanism for tupledescs might someday allow us to\n\t\t * remove this hack for the tupledesc.)\n\t\t *\n\t\t * Note that this process does not touch CurrentResourceOwner; which\n\t\t * is good because whatever ref counts the entry may have do not\n\t\t * necessarily belong to that resource owner.\n\t\t */\n\t\tRelation\tnewrel;\n\t\tOid\t\t\tsave_relid = RelationGetRelid(relation);\n\t\tbool\t\tkeep_tupdesc;\n\t\tbool\t\tkeep_rules;\n\t\tbool\t\tkeep_policies;\n\t\tbool\t\tkeep_partkey;\n\t\tbool\t\tkeep_partdesc;\n\n\t\t/* Build temporary entry, but don't link it into hashtable */\n\t\tnewrel = RelationBuildDesc(save_relid, false);\n\t\tif (newrel == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * We can validly get here, if we're using a historic snapshot in\n\t\t\t * which a relation, accessed from outside logical decoding, is\n\t\t\t * still invisible. In that case it's fine to just mark the\n\t\t\t * relation as invalid and return - it'll fully get reloaded by\n\t\t\t * the cache reset at the end of logical decoding (or at the next\n\t\t\t * access).  During normal processing we don't want to ignore this\n\t\t\t * case as it shouldn't happen there, as explained below.\n\t\t\t */\n\t\t\tif (HistoricSnapshotActive())\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * This shouldn't happen as dropping a relation is intended to be\n\t\t\t * impossible if still referenced (cf. CheckTableNotInUse()). But\n\t\t\t * if we get here anyway, we can't just delete the relcache entry,\n\t\t\t * as it possibly could get accessed later (as e.g. the error\n\t\t\t * might get trapped and handled via a subtransaction rollback).\n\t\t\t */\n\t\t\telog(ERROR, \"relation %u deleted while still in use\", save_relid);\n\t\t}\n\n\t\tkeep_tupdesc = equalTupleDescs(relation->rd_att, newrel->rd_att);\n\t\tkeep_rules = equalRuleLocks(relation->rd_rules, newrel->rd_rules);\n\t\tkeep_policies = equalRSDesc(relation->rd_rsdesc, newrel->rd_rsdesc);\n\t\t/* partkey is immutable once set up, so we can always keep it */\n\t\tkeep_partkey = (relation->rd_partkey != NULL);\n\t\tkeep_partdesc = equalPartitionDescs(relation->rd_partkey,\n\t\t\t\t\t\t\t\t\t\t\trelation->rd_partdesc,\n\t\t\t\t\t\t\t\t\t\t\tnewrel->rd_partdesc);\n\n\t\t/*\n\t\t * Perform swapping of the relcache entry contents.  Within this\n\t\t * process the old entry is momentarily invalid, so there *must* be no\n\t\t * possibility of CHECK_FOR_INTERRUPTS within this sequence. Do it in\n\t\t * all-in-line code for safety.\n\t\t *\n\t\t * Since the vast majority of fields should be swapped, our method is\n\t\t * to swap the whole structures and then re-swap those few fields we\n\t\t * didn't want swapped.\n\t\t */\n#define SWAPFIELD(fldtype, fldname) \\\n\t\tdo { \\\n\t\t\tfldtype _tmp = newrel->fldname; \\\n\t\t\tnewrel->fldname = relation->fldname; \\\n\t\t\trelation->fldname = _tmp; \\\n\t\t} while (0)\n\n\t\t/* swap all Relation struct fields */\n\t\t{\n\t\t\tRelationData tmpstruct;\n\n\t\t\tmemcpy(&tmpstruct, newrel, sizeof(RelationData));\n\t\t\tmemcpy(newrel, relation, sizeof(RelationData));\n\t\t\tmemcpy(relation, &tmpstruct, sizeof(RelationData));\n\t\t}\n\n\t\t/* rd_smgr must not be swapped, due to back-links from smgr level */\n\t\tSWAPFIELD(SMgrRelation, rd_smgr);\n\t\t/* rd_refcnt must be preserved */\n\t\tSWAPFIELD(int, rd_refcnt);\n\t\t/* isnailed shouldn't change */\n\t\tAssert(newrel->rd_isnailed == relation->rd_isnailed);\n\t\t/* creation sub-XIDs must be preserved */\n\t\tSWAPFIELD(SubTransactionId, rd_createSubid);\n\t\tSWAPFIELD(SubTransactionId, rd_newRelfilenodeSubid);\n\t\t/* un-swap rd_rel pointers, swap contents instead */\n\t\tSWAPFIELD(Form_pg_class, rd_rel);\n\t\t/* ... but actually, we don't have to update newrel->rd_rel */\n\t\tmemcpy(relation->rd_rel, newrel->rd_rel, CLASS_TUPLE_SIZE);\n\t\t/* preserve old tupledesc, rules, policies if no logical change */\n\t\tif (keep_tupdesc)\n\t\t\tSWAPFIELD(TupleDesc, rd_att);\n\t\tif (keep_rules)\n\t\t{\n\t\t\tSWAPFIELD(RuleLock *, rd_rules);\n\t\t\tSWAPFIELD(MemoryContext, rd_rulescxt);\n\t\t}\n\t\tif (keep_policies)\n\t\t\tSWAPFIELD(RowSecurityDesc *, rd_rsdesc);\n\t\t/* toast OID override must be preserved */\n\t\tSWAPFIELD(Oid, rd_toastoid);\n\t\t/* pgstat_info must be preserved */\n\t\tSWAPFIELD(struct PgStat_TableStatus *, pgstat_info);\n\t\t/* preserve old partitioning info if no logical change */\n\t\tif (keep_partkey)\n\t\t{\n\t\t\tSWAPFIELD(PartitionKey, rd_partkey);\n\t\t\tSWAPFIELD(MemoryContext, rd_partkeycxt);\n\t\t}\n\t\tif (keep_partdesc)\n\t\t{\n\t\t\tSWAPFIELD(PartitionDesc, rd_partdesc);\n\t\t\tSWAPFIELD(MemoryContext, rd_pdcxt);\n\t\t}\n\n#undef SWAPFIELD\n\n\t\t/* And now we can throw away the temporary entry */\n\t\tRelationDestroyRelation(newrel, !keep_tupdesc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationHasReferenceCountZero",
          "args": [
            "relation"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationDecrementReferenceCount",
          "args": [
            "relation"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "RelationDecrementReferenceCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1988-1995",
          "snippet": "void\nRelationDecrementReferenceCount(Relation rel)\n{\n\tAssert(rel->rd_refcnt > 0);\n\trel->rd_refcnt -= 1;\n\tif (!IsBootstrapProcessingMode())\n\t\tResourceOwnerForgetRelationRef(CurrentResourceOwner, rel);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nvoid\nRelationDecrementReferenceCount(Relation rel)\n{\n\tAssert(rel->rd_refcnt > 0);\n\trel->rd_refcnt -= 1;\n\tif (!IsBootstrapProcessingMode())\n\t\tResourceOwnerForgetRelationRef(CurrentResourceOwner, rel);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationClose(Relation relation)\n{\n\t/* Note: no locking manipulations needed */\n\tRelationDecrementReferenceCount(relation);\n\n#ifdef RELCACHE_FORCE_RELEASE\n\tif (RelationHasReferenceCountZero(relation) &&\n\t\trelation->rd_createSubid == InvalidSubTransactionId &&\n\t\trelation->rd_newRelfilenodeSubid == InvalidSubTransactionId)\n\t\tRelationClearRelation(relation, false);\n#endif\n}"
  },
  {
    "function_name": "RelationDecrementReferenceCount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "1988-1995",
    "snippet": "void\nRelationDecrementReferenceCount(Relation rel)\n{\n\tAssert(rel->rd_refcnt > 0);\n\trel->rd_refcnt -= 1;\n\tif (!IsBootstrapProcessingMode())\n\t\tResourceOwnerForgetRelationRef(CurrentResourceOwner, rel);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceOwnerForgetRelationRef",
          "args": [
            "CurrentResourceOwner",
            "rel"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerForgetRelationRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "1026-1032",
          "snippet": "void\nResourceOwnerForgetRelationRef(ResourceOwner owner, Relation rel)\n{\n\tif (!ResourceArrayRemove(&(owner->relrefarr), PointerGetDatum(rel)))\n\t\telog(ERROR, \"relcache reference %s is not owned by resource owner %s\",\n\t\t\t RelationGetRelationName(rel), owner->name);\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void PrintRelCacheLeakWarning(Relation rel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintRelCacheLeakWarning(Relation rel);\n\nvoid\nResourceOwnerForgetRelationRef(ResourceOwner owner, Relation rel)\n{\n\tif (!ResourceArrayRemove(&(owner->relrefarr), PointerGetDatum(rel)))\n\t\telog(ERROR, \"relcache reference %s is not owned by resource owner %s\",\n\t\t\t RelationGetRelationName(rel), owner->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rel->rd_refcnt > 0"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nvoid\nRelationDecrementReferenceCount(Relation rel)\n{\n\tAssert(rel->rd_refcnt > 0);\n\trel->rd_refcnt -= 1;\n\tif (!IsBootstrapProcessingMode())\n\t\tResourceOwnerForgetRelationRef(CurrentResourceOwner, rel);\n}"
  },
  {
    "function_name": "RelationIncrementReferenceCount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "1975-1982",
    "snippet": "void\nRelationIncrementReferenceCount(Relation rel)\n{\n\tResourceOwnerEnlargeRelationRefs(CurrentResourceOwner);\n\trel->rd_refcnt += 1;\n\tif (!IsBootstrapProcessingMode())\n\t\tResourceOwnerRememberRelationRef(CurrentResourceOwner, rel);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ResourceOwnerRememberRelationRef",
          "args": [
            "CurrentResourceOwner",
            "rel"
          ],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerRememberRelationRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "1017-1021",
          "snippet": "void\nResourceOwnerRememberRelationRef(ResourceOwner owner, Relation rel)\n{\n\tResourceArrayAdd(&(owner->relrefarr), PointerGetDatum(rel));\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void PrintRelCacheLeakWarning(Relation rel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void PrintRelCacheLeakWarning(Relation rel);\n\nvoid\nResourceOwnerRememberRelationRef(ResourceOwner owner, Relation rel)\n{\n\tResourceArrayAdd(&(owner->relrefarr), PointerGetDatum(rel));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ResourceOwnerEnlargeRelationRefs",
          "args": [
            "CurrentResourceOwner"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "ResourceOwnerEnlargeRelationRefs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/resowner/resowner.c",
          "lines": "1006-1010",
          "snippet": "void\nResourceOwnerEnlargeRelationRefs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->relrefarr));\n}",
          "includes": [
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"jit/jit.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"jit/jit.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nResourceOwnerEnlargeRelationRefs(ResourceOwner owner)\n{\n\tResourceArrayEnlarge(&(owner->relrefarr));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nvoid\nRelationIncrementReferenceCount(Relation rel)\n{\n\tResourceOwnerEnlargeRelationRefs(CurrentResourceOwner);\n\trel->rd_refcnt += 1;\n\tif (!IsBootstrapProcessingMode())\n\t\tResourceOwnerRememberRelationRef(CurrentResourceOwner, rel);\n}"
  },
  {
    "function_name": "RelationIdGetRelation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "1909-1960",
    "snippet": "Relation\nRelationIdGetRelation(Oid relationId)\n{\n\tRelation\trd;\n\n\t/* Make sure we're in an xact, even if this ends up being a cache hit */\n\tAssert(IsTransactionState());\n\n\t/*\n\t * first try to find reldesc in the cache\n\t */\n\tRelationIdCacheLookup(relationId, rd);\n\n\tif (RelationIsValid(rd))\n\t{\n\t\tRelationIncrementReferenceCount(rd);\n\t\t/* revalidate cache entry if necessary */\n\t\tif (!rd->rd_isvalid)\n\t\t{\n\t\t\t/*\n\t\t\t * Indexes only have a limited number of possible schema changes,\n\t\t\t * and we don't want to use the full-blown procedure because it's\n\t\t\t * a headache for indexes that reload itself depends on.\n\t\t\t */\n\t\t\tif (rd->rd_rel->relkind == RELKIND_INDEX ||\n\t\t\t\trd->rd_rel->relkind == RELKIND_PARTITIONED_INDEX)\n\t\t\t\tRelationReloadIndexInfo(rd);\n\t\t\telse\n\t\t\t\tRelationClearRelation(rd, true);\n\n\t\t\t/*\n\t\t\t * Normally entries need to be valid here, but before the relcache\n\t\t\t * has been initialized, not enough infrastructure exists to\n\t\t\t * perform pg_class lookups. The structure of such entries doesn't\n\t\t\t * change, but we still want to update the rd_rel entry. So\n\t\t\t * rd_isvalid = false is left in place for a later lookup.\n\t\t\t */\n\t\t\tAssert(rd->rd_isvalid ||\n\t\t\t\t   (rd->rd_isnailed && !criticalRelcachesBuilt));\n\t\t}\n\t\treturn rd;\n\t}\n\n\t/*\n\t * no reldesc in the cache, so have RelationBuildDesc() build one and add\n\t * it.\n\t */\n\trd = RelationBuildDesc(relationId, true);\n\tif (RelationIsValid(rd))\n\t\tRelationIncrementReferenceCount(rd);\n\treturn rd;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool\t\tcriticalRelcachesBuilt = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RelationIncrementReferenceCount",
          "args": [
            "rd"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "RelationIncrementReferenceCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1975-1982",
          "snippet": "void\nRelationIncrementReferenceCount(Relation rel)\n{\n\tResourceOwnerEnlargeRelationRefs(CurrentResourceOwner);\n\trel->rd_refcnt += 1;\n\tif (!IsBootstrapProcessingMode())\n\t\tResourceOwnerRememberRelationRef(CurrentResourceOwner, rel);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nvoid\nRelationIncrementReferenceCount(Relation rel)\n{\n\tResourceOwnerEnlargeRelationRefs(CurrentResourceOwner);\n\trel->rd_refcnt += 1;\n\tif (!IsBootstrapProcessingMode())\n\t\tResourceOwnerRememberRelationRef(CurrentResourceOwner, rel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationIsValid",
          "args": [
            "rd"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationBuildDesc",
          "args": [
            "relationId",
            "true"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "RelationBuildDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1070-1250",
          "snippet": "static Relation\nRelationBuildDesc(Oid targetRelId, bool insertIt)\n{\n\tRelation\trelation;\n\tOid\t\t\trelid;\n\tHeapTuple\tpg_class_tuple;\n\tForm_pg_class relp;\n\n\t/*\n\t * find the tuple in pg_class corresponding to the given relation id\n\t */\n\tpg_class_tuple = ScanPgRelation(targetRelId, true, false);\n\n\t/*\n\t * if no such tuple exists, return NULL\n\t */\n\tif (!HeapTupleIsValid(pg_class_tuple))\n\t\treturn NULL;\n\n\t/*\n\t * get information from the pg_class_tuple\n\t */\n\trelid = HeapTupleGetOid(pg_class_tuple);\n\trelp = (Form_pg_class) GETSTRUCT(pg_class_tuple);\n\tAssert(relid == targetRelId);\n\n\t/*\n\t * allocate storage for the relation descriptor, and copy pg_class_tuple\n\t * to relation->rd_rel.\n\t */\n\trelation = AllocateRelationDesc(relp);\n\n\t/*\n\t * initialize the relation's relation id (relation->rd_id)\n\t */\n\tRelationGetRelid(relation) = relid;\n\n\t/*\n\t * normal relations are not nailed into the cache; nor can a pre-existing\n\t * relation be new.  It could be temp though.  (Actually, it could be new\n\t * too, but it's okay to forget that fact if forced to flush the entry.)\n\t */\n\trelation->rd_refcnt = 0;\n\trelation->rd_isnailed = false;\n\trelation->rd_createSubid = InvalidSubTransactionId;\n\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\tswitch (relation->rd_rel->relpersistence)\n\t{\n\t\tcase RELPERSISTENCE_UNLOGGED:\n\t\tcase RELPERSISTENCE_PERMANENT:\n\t\t\trelation->rd_backend = InvalidBackendId;\n\t\t\trelation->rd_islocaltemp = false;\n\t\t\tbreak;\n\t\tcase RELPERSISTENCE_TEMP:\n\t\t\tif (isTempOrTempToastNamespace(relation->rd_rel->relnamespace))\n\t\t\t{\n\t\t\t\trelation->rd_backend = BackendIdForTempRelations();\n\t\t\t\trelation->rd_islocaltemp = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If it's a temp table, but not one of ours, we have to use\n\t\t\t\t * the slow, grotty method to figure out the owning backend.\n\t\t\t\t *\n\t\t\t\t * Note: it's possible that rd_backend gets set to MyBackendId\n\t\t\t\t * here, in case we are looking at a pg_class entry left over\n\t\t\t\t * from a crashed backend that coincidentally had the same\n\t\t\t\t * BackendId we're using.  We should *not* consider such a\n\t\t\t\t * table to be \"ours\"; this is why we need the separate\n\t\t\t\t * rd_islocaltemp flag.  The pg_class entry will get flushed\n\t\t\t\t * if/when we clean out the corresponding temp table namespace\n\t\t\t\t * in preparation for using it.\n\t\t\t\t */\n\t\t\t\trelation->rd_backend =\n\t\t\t\t\tGetTempNamespaceBackendId(relation->rd_rel->relnamespace);\n\t\t\t\tAssert(relation->rd_backend != InvalidBackendId);\n\t\t\t\trelation->rd_islocaltemp = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid relpersistence: %c\",\n\t\t\t\t relation->rd_rel->relpersistence);\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * initialize the tuple descriptor (relation->rd_att).\n\t */\n\tRelationBuildTupleDesc(relation);\n\n\t/*\n\t * Fetch rules and triggers that affect this relation\n\t */\n\tif (relation->rd_rel->relhasrules)\n\t\tRelationBuildRuleLock(relation);\n\telse\n\t{\n\t\trelation->rd_rules = NULL;\n\t\trelation->rd_rulescxt = NULL;\n\t}\n\n\tif (relation->rd_rel->relhastriggers)\n\t\tRelationBuildTriggers(relation);\n\telse\n\t\trelation->trigdesc = NULL;\n\n\tif (relation->rd_rel->relrowsecurity)\n\t\tRelationBuildRowSecurity(relation);\n\telse\n\t\trelation->rd_rsdesc = NULL;\n\n\t/* foreign key data is not loaded till asked for */\n\trelation->rd_fkeylist = NIL;\n\trelation->rd_fkeyvalid = false;\n\n\t/* if a partitioned table, initialize key and partition descriptor info */\n\tif (relation->rd_rel->relkind == RELKIND_PARTITIONED_TABLE)\n\t{\n\t\tRelationBuildPartitionKey(relation);\n\t\tRelationBuildPartitionDesc(relation);\n\t}\n\telse\n\t{\n\t\trelation->rd_partkey = NULL;\n\t\trelation->rd_partkeycxt = NULL;\n\t\trelation->rd_partdesc = NULL;\n\t\trelation->rd_pdcxt = NULL;\n\t}\n\t/* ... but partcheck is not loaded till asked for */\n\trelation->rd_partcheck = NIL;\n\trelation->rd_partcheckvalid = false;\n\trelation->rd_partcheckcxt = NULL;\n\n\t/*\n\t * if it's an index, initialize index-related information\n\t */\n\tif (OidIsValid(relation->rd_rel->relam))\n\t\tRelationInitIndexAccessInfo(relation);\n\n\t/* extract reloptions if any */\n\tRelationParseRelOptions(relation, pg_class_tuple);\n\n\t/*\n\t * initialize the relation lock manager information\n\t */\n\tRelationInitLockInfo(relation); /* see lmgr.c */\n\n\t/*\n\t * initialize physical addressing information for the relation\n\t */\n\tRelationInitPhysicalAddr(relation);\n\n\t/* make sure relation is marked as having no open file yet */\n\trelation->rd_smgr = NULL;\n\n\t/*\n\t * now we can free the memory allocated for pg_class_tuple\n\t */\n\theap_freetuple(pg_class_tuple);\n\n\t/*\n\t * Insert newly created relation into relcache hash table, if requested.\n\t *\n\t * There is one scenario in which we might find a hashtable entry already\n\t * present, even though our caller failed to find it: if the relation is a\n\t * system catalog or index that's used during relcache load, we might have\n\t * recursively created the same relcache entry during the preceding steps.\n\t * So allow RelationCacheInsert to delete any already-present relcache\n\t * entry for the same OID.  The already-present entry should have refcount\n\t * zero (else somebody forgot to close it); in the event that it doesn't,\n\t * we'll elog a WARNING and leak the already-present entry.\n\t */\n\tif (insertIt)\n\t\tRelationCacheInsert(relation, true);\n\n\t/* It's fully valid */\n\trelation->rd_isvalid = true;\n\n\treturn relation;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static Relation AllocateRelationDesc(Form_pg_class relp);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static Relation RelationBuildDesc(Oid targetRelId, bool insertIt);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic Relation AllocateRelationDesc(Form_pg_class relp);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic Relation RelationBuildDesc(Oid targetRelId, bool insertIt);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic Relation\nRelationBuildDesc(Oid targetRelId, bool insertIt)\n{\n\tRelation\trelation;\n\tOid\t\t\trelid;\n\tHeapTuple\tpg_class_tuple;\n\tForm_pg_class relp;\n\n\t/*\n\t * find the tuple in pg_class corresponding to the given relation id\n\t */\n\tpg_class_tuple = ScanPgRelation(targetRelId, true, false);\n\n\t/*\n\t * if no such tuple exists, return NULL\n\t */\n\tif (!HeapTupleIsValid(pg_class_tuple))\n\t\treturn NULL;\n\n\t/*\n\t * get information from the pg_class_tuple\n\t */\n\trelid = HeapTupleGetOid(pg_class_tuple);\n\trelp = (Form_pg_class) GETSTRUCT(pg_class_tuple);\n\tAssert(relid == targetRelId);\n\n\t/*\n\t * allocate storage for the relation descriptor, and copy pg_class_tuple\n\t * to relation->rd_rel.\n\t */\n\trelation = AllocateRelationDesc(relp);\n\n\t/*\n\t * initialize the relation's relation id (relation->rd_id)\n\t */\n\tRelationGetRelid(relation) = relid;\n\n\t/*\n\t * normal relations are not nailed into the cache; nor can a pre-existing\n\t * relation be new.  It could be temp though.  (Actually, it could be new\n\t * too, but it's okay to forget that fact if forced to flush the entry.)\n\t */\n\trelation->rd_refcnt = 0;\n\trelation->rd_isnailed = false;\n\trelation->rd_createSubid = InvalidSubTransactionId;\n\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\tswitch (relation->rd_rel->relpersistence)\n\t{\n\t\tcase RELPERSISTENCE_UNLOGGED:\n\t\tcase RELPERSISTENCE_PERMANENT:\n\t\t\trelation->rd_backend = InvalidBackendId;\n\t\t\trelation->rd_islocaltemp = false;\n\t\t\tbreak;\n\t\tcase RELPERSISTENCE_TEMP:\n\t\t\tif (isTempOrTempToastNamespace(relation->rd_rel->relnamespace))\n\t\t\t{\n\t\t\t\trelation->rd_backend = BackendIdForTempRelations();\n\t\t\t\trelation->rd_islocaltemp = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If it's a temp table, but not one of ours, we have to use\n\t\t\t\t * the slow, grotty method to figure out the owning backend.\n\t\t\t\t *\n\t\t\t\t * Note: it's possible that rd_backend gets set to MyBackendId\n\t\t\t\t * here, in case we are looking at a pg_class entry left over\n\t\t\t\t * from a crashed backend that coincidentally had the same\n\t\t\t\t * BackendId we're using.  We should *not* consider such a\n\t\t\t\t * table to be \"ours\"; this is why we need the separate\n\t\t\t\t * rd_islocaltemp flag.  The pg_class entry will get flushed\n\t\t\t\t * if/when we clean out the corresponding temp table namespace\n\t\t\t\t * in preparation for using it.\n\t\t\t\t */\n\t\t\t\trelation->rd_backend =\n\t\t\t\t\tGetTempNamespaceBackendId(relation->rd_rel->relnamespace);\n\t\t\t\tAssert(relation->rd_backend != InvalidBackendId);\n\t\t\t\trelation->rd_islocaltemp = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid relpersistence: %c\",\n\t\t\t\t relation->rd_rel->relpersistence);\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * initialize the tuple descriptor (relation->rd_att).\n\t */\n\tRelationBuildTupleDesc(relation);\n\n\t/*\n\t * Fetch rules and triggers that affect this relation\n\t */\n\tif (relation->rd_rel->relhasrules)\n\t\tRelationBuildRuleLock(relation);\n\telse\n\t{\n\t\trelation->rd_rules = NULL;\n\t\trelation->rd_rulescxt = NULL;\n\t}\n\n\tif (relation->rd_rel->relhastriggers)\n\t\tRelationBuildTriggers(relation);\n\telse\n\t\trelation->trigdesc = NULL;\n\n\tif (relation->rd_rel->relrowsecurity)\n\t\tRelationBuildRowSecurity(relation);\n\telse\n\t\trelation->rd_rsdesc = NULL;\n\n\t/* foreign key data is not loaded till asked for */\n\trelation->rd_fkeylist = NIL;\n\trelation->rd_fkeyvalid = false;\n\n\t/* if a partitioned table, initialize key and partition descriptor info */\n\tif (relation->rd_rel->relkind == RELKIND_PARTITIONED_TABLE)\n\t{\n\t\tRelationBuildPartitionKey(relation);\n\t\tRelationBuildPartitionDesc(relation);\n\t}\n\telse\n\t{\n\t\trelation->rd_partkey = NULL;\n\t\trelation->rd_partkeycxt = NULL;\n\t\trelation->rd_partdesc = NULL;\n\t\trelation->rd_pdcxt = NULL;\n\t}\n\t/* ... but partcheck is not loaded till asked for */\n\trelation->rd_partcheck = NIL;\n\trelation->rd_partcheckvalid = false;\n\trelation->rd_partcheckcxt = NULL;\n\n\t/*\n\t * if it's an index, initialize index-related information\n\t */\n\tif (OidIsValid(relation->rd_rel->relam))\n\t\tRelationInitIndexAccessInfo(relation);\n\n\t/* extract reloptions if any */\n\tRelationParseRelOptions(relation, pg_class_tuple);\n\n\t/*\n\t * initialize the relation lock manager information\n\t */\n\tRelationInitLockInfo(relation); /* see lmgr.c */\n\n\t/*\n\t * initialize physical addressing information for the relation\n\t */\n\tRelationInitPhysicalAddr(relation);\n\n\t/* make sure relation is marked as having no open file yet */\n\trelation->rd_smgr = NULL;\n\n\t/*\n\t * now we can free the memory allocated for pg_class_tuple\n\t */\n\theap_freetuple(pg_class_tuple);\n\n\t/*\n\t * Insert newly created relation into relcache hash table, if requested.\n\t *\n\t * There is one scenario in which we might find a hashtable entry already\n\t * present, even though our caller failed to find it: if the relation is a\n\t * system catalog or index that's used during relcache load, we might have\n\t * recursively created the same relcache entry during the preceding steps.\n\t * So allow RelationCacheInsert to delete any already-present relcache\n\t * entry for the same OID.  The already-present entry should have refcount\n\t * zero (else somebody forgot to close it); in the event that it doesn't,\n\t * we'll elog a WARNING and leak the already-present entry.\n\t */\n\tif (insertIt)\n\t\tRelationCacheInsert(relation, true);\n\n\t/* It's fully valid */\n\trelation->rd_isvalid = true;\n\n\treturn relation;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "rd->rd_isvalid ||\n\t\t\t\t   (rd->rd_isnailed && !criticalRelcachesBuilt)"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationClearRelation",
          "args": [
            "rd",
            "true"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "RelationClearRelation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2318-2553",
          "snippet": "static void\nRelationClearRelation(Relation relation, bool rebuild)\n{\n\t/*\n\t * As per notes above, a rel to be rebuilt MUST have refcnt > 0; while of\n\t * course it would be an equally bad idea to blow away one with nonzero\n\t * refcnt, since that would leave someone somewhere with a dangling\n\t * pointer.  All callers are expected to have verified that this holds.\n\t */\n\tAssert(rebuild ?\n\t\t   !RelationHasReferenceCountZero(relation) :\n\t\t   RelationHasReferenceCountZero(relation));\n\n\t/*\n\t * Make sure smgr and lower levels close the relation's files, if they\n\t * weren't closed already.  If the relation is not getting deleted, the\n\t * next smgr access should reopen the files automatically.  This ensures\n\t * that the low-level file access state is updated after, say, a vacuum\n\t * truncation.\n\t */\n\tRelationCloseSmgr(relation);\n\n\t/*\n\t * Treat nailed-in system relations separately, they always need to be\n\t * accessible, so we can't blow them away.\n\t */\n\tif (relation->rd_isnailed)\n\t{\n\t\tRelationReloadNailed(relation);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even non-system indexes should not be blown away if they are open and\n\t * have valid index support information.  This avoids problems with active\n\t * use of the index support information.  As with nailed indexes, we\n\t * re-read the pg_class row to handle possible physical relocation of the\n\t * index, and we check for pg_index updates too.\n\t */\n\tif ((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t relation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\trelation->rd_refcnt > 0 &&\n\t\trelation->rd_indexcxt != NULL)\n\t{\n\t\trelation->rd_isvalid = false;\t/* needs to be revalidated */\n\t\tif (IsTransactionState())\n\t\t\tRelationReloadIndexInfo(relation);\n\t\treturn;\n\t}\n\n\t/* Mark it invalid until we've finished rebuild */\n\trelation->rd_isvalid = false;\n\n\t/*\n\t * If we're really done with the relcache entry, blow it away. But if\n\t * someone is still using it, reconstruct the whole deal without moving\n\t * the physical RelationData record (so that the someone's pointer is\n\t * still valid).\n\t */\n\tif (!rebuild)\n\t{\n\t\t/* Remove it from the hash table */\n\t\tRelationCacheDelete(relation);\n\n\t\t/* And release storage */\n\t\tRelationDestroyRelation(relation, false);\n\t}\n\telse if (!IsTransactionState())\n\t{\n\t\t/*\n\t\t * If we're not inside a valid transaction, we can't do any catalog\n\t\t * access so it's not possible to rebuild yet.  Just exit, leaving\n\t\t * rd_isvalid = false so that the rebuild will occur when the entry is\n\t\t * next opened.\n\t\t *\n\t\t * Note: it's possible that we come here during subtransaction abort,\n\t\t * and the reason for wanting to rebuild is that the rel is open in\n\t\t * the outer transaction.  In that case it might seem unsafe to not\n\t\t * rebuild immediately, since whatever code has the rel already open\n\t\t * will keep on using the relcache entry as-is.  However, in such a\n\t\t * case the outer transaction should be holding a lock that's\n\t\t * sufficient to prevent any significant change in the rel's schema,\n\t\t * so the existing entry contents should be good enough for its\n\t\t * purposes; at worst we might be behind on statistics updates or the\n\t\t * like.  (See also CheckTableNotInUse() and its callers.)\tThese same\n\t\t * remarks also apply to the cases above where we exit without having\n\t\t * done RelationReloadIndexInfo() yet.\n\t\t */\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Our strategy for rebuilding an open relcache entry is to build a\n\t\t * new entry from scratch, swap its contents with the old entry, and\n\t\t * finally delete the new entry (along with any infrastructure swapped\n\t\t * over from the old entry).  This is to avoid trouble in case an\n\t\t * error causes us to lose control partway through.  The old entry\n\t\t * will still be marked !rd_isvalid, so we'll try to rebuild it again\n\t\t * on next access.  Meanwhile it's not any less valid than it was\n\t\t * before, so any code that might expect to continue accessing it\n\t\t * isn't hurt by the rebuild failure.  (Consider for example a\n\t\t * subtransaction that ALTERs a table and then gets canceled partway\n\t\t * through the cache entry rebuild.  The outer transaction should\n\t\t * still see the not-modified cache entry as valid.)  The worst\n\t\t * consequence of an error is leaking the necessarily-unreferenced new\n\t\t * entry, and this shouldn't happen often enough for that to be a big\n\t\t * problem.\n\t\t *\n\t\t * When rebuilding an open relcache entry, we must preserve ref count,\n\t\t * rd_createSubid/rd_newRelfilenodeSubid, and rd_toastoid state.  Also\n\t\t * attempt to preserve the pg_class entry (rd_rel), tupledesc,\n\t\t * rewrite-rule, partition key, and partition descriptor substructures\n\t\t * in place, because various places assume that these structures won't\n\t\t * move while they are working with an open relcache entry.  (Note:\n\t\t * the refcount mechanism for tupledescs might someday allow us to\n\t\t * remove this hack for the tupledesc.)\n\t\t *\n\t\t * Note that this process does not touch CurrentResourceOwner; which\n\t\t * is good because whatever ref counts the entry may have do not\n\t\t * necessarily belong to that resource owner.\n\t\t */\n\t\tRelation\tnewrel;\n\t\tOid\t\t\tsave_relid = RelationGetRelid(relation);\n\t\tbool\t\tkeep_tupdesc;\n\t\tbool\t\tkeep_rules;\n\t\tbool\t\tkeep_policies;\n\t\tbool\t\tkeep_partkey;\n\t\tbool\t\tkeep_partdesc;\n\n\t\t/* Build temporary entry, but don't link it into hashtable */\n\t\tnewrel = RelationBuildDesc(save_relid, false);\n\t\tif (newrel == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * We can validly get here, if we're using a historic snapshot in\n\t\t\t * which a relation, accessed from outside logical decoding, is\n\t\t\t * still invisible. In that case it's fine to just mark the\n\t\t\t * relation as invalid and return - it'll fully get reloaded by\n\t\t\t * the cache reset at the end of logical decoding (or at the next\n\t\t\t * access).  During normal processing we don't want to ignore this\n\t\t\t * case as it shouldn't happen there, as explained below.\n\t\t\t */\n\t\t\tif (HistoricSnapshotActive())\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * This shouldn't happen as dropping a relation is intended to be\n\t\t\t * impossible if still referenced (cf. CheckTableNotInUse()). But\n\t\t\t * if we get here anyway, we can't just delete the relcache entry,\n\t\t\t * as it possibly could get accessed later (as e.g. the error\n\t\t\t * might get trapped and handled via a subtransaction rollback).\n\t\t\t */\n\t\t\telog(ERROR, \"relation %u deleted while still in use\", save_relid);\n\t\t}\n\n\t\tkeep_tupdesc = equalTupleDescs(relation->rd_att, newrel->rd_att);\n\t\tkeep_rules = equalRuleLocks(relation->rd_rules, newrel->rd_rules);\n\t\tkeep_policies = equalRSDesc(relation->rd_rsdesc, newrel->rd_rsdesc);\n\t\t/* partkey is immutable once set up, so we can always keep it */\n\t\tkeep_partkey = (relation->rd_partkey != NULL);\n\t\tkeep_partdesc = equalPartitionDescs(relation->rd_partkey,\n\t\t\t\t\t\t\t\t\t\t\trelation->rd_partdesc,\n\t\t\t\t\t\t\t\t\t\t\tnewrel->rd_partdesc);\n\n\t\t/*\n\t\t * Perform swapping of the relcache entry contents.  Within this\n\t\t * process the old entry is momentarily invalid, so there *must* be no\n\t\t * possibility of CHECK_FOR_INTERRUPTS within this sequence. Do it in\n\t\t * all-in-line code for safety.\n\t\t *\n\t\t * Since the vast majority of fields should be swapped, our method is\n\t\t * to swap the whole structures and then re-swap those few fields we\n\t\t * didn't want swapped.\n\t\t */\n#define SWAPFIELD(fldtype, fldname) \\\n\t\tdo { \\\n\t\t\tfldtype _tmp = newrel->fldname; \\\n\t\t\tnewrel->fldname = relation->fldname; \\\n\t\t\trelation->fldname = _tmp; \\\n\t\t} while (0)\n\n\t\t/* swap all Relation struct fields */\n\t\t{\n\t\t\tRelationData tmpstruct;\n\n\t\t\tmemcpy(&tmpstruct, newrel, sizeof(RelationData));\n\t\t\tmemcpy(newrel, relation, sizeof(RelationData));\n\t\t\tmemcpy(relation, &tmpstruct, sizeof(RelationData));\n\t\t}\n\n\t\t/* rd_smgr must not be swapped, due to back-links from smgr level */\n\t\tSWAPFIELD(SMgrRelation, rd_smgr);\n\t\t/* rd_refcnt must be preserved */\n\t\tSWAPFIELD(int, rd_refcnt);\n\t\t/* isnailed shouldn't change */\n\t\tAssert(newrel->rd_isnailed == relation->rd_isnailed);\n\t\t/* creation sub-XIDs must be preserved */\n\t\tSWAPFIELD(SubTransactionId, rd_createSubid);\n\t\tSWAPFIELD(SubTransactionId, rd_newRelfilenodeSubid);\n\t\t/* un-swap rd_rel pointers, swap contents instead */\n\t\tSWAPFIELD(Form_pg_class, rd_rel);\n\t\t/* ... but actually, we don't have to update newrel->rd_rel */\n\t\tmemcpy(relation->rd_rel, newrel->rd_rel, CLASS_TUPLE_SIZE);\n\t\t/* preserve old tupledesc, rules, policies if no logical change */\n\t\tif (keep_tupdesc)\n\t\t\tSWAPFIELD(TupleDesc, rd_att);\n\t\tif (keep_rules)\n\t\t{\n\t\t\tSWAPFIELD(RuleLock *, rd_rules);\n\t\t\tSWAPFIELD(MemoryContext, rd_rulescxt);\n\t\t}\n\t\tif (keep_policies)\n\t\t\tSWAPFIELD(RowSecurityDesc *, rd_rsdesc);\n\t\t/* toast OID override must be preserved */\n\t\tSWAPFIELD(Oid, rd_toastoid);\n\t\t/* pgstat_info must be preserved */\n\t\tSWAPFIELD(struct PgStat_TableStatus *, pgstat_info);\n\t\t/* preserve old partitioning info if no logical change */\n\t\tif (keep_partkey)\n\t\t{\n\t\t\tSWAPFIELD(PartitionKey, rd_partkey);\n\t\t\tSWAPFIELD(MemoryContext, rd_partkeycxt);\n\t\t}\n\t\tif (keep_partdesc)\n\t\t{\n\t\t\tSWAPFIELD(PartitionDesc, rd_partdesc);\n\t\t\tSWAPFIELD(MemoryContext, rd_pdcxt);\n\t\t}\n\n#undef SWAPFIELD\n\n\t\t/* And now we can throw away the temporary entry */\n\t\tRelationDestroyRelation(newrel, !keep_tupdesc);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationClearRelation(Relation relation, bool rebuild);",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationClearRelation(Relation relation, bool rebuild);\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationClearRelation(Relation relation, bool rebuild)\n{\n\t/*\n\t * As per notes above, a rel to be rebuilt MUST have refcnt > 0; while of\n\t * course it would be an equally bad idea to blow away one with nonzero\n\t * refcnt, since that would leave someone somewhere with a dangling\n\t * pointer.  All callers are expected to have verified that this holds.\n\t */\n\tAssert(rebuild ?\n\t\t   !RelationHasReferenceCountZero(relation) :\n\t\t   RelationHasReferenceCountZero(relation));\n\n\t/*\n\t * Make sure smgr and lower levels close the relation's files, if they\n\t * weren't closed already.  If the relation is not getting deleted, the\n\t * next smgr access should reopen the files automatically.  This ensures\n\t * that the low-level file access state is updated after, say, a vacuum\n\t * truncation.\n\t */\n\tRelationCloseSmgr(relation);\n\n\t/*\n\t * Treat nailed-in system relations separately, they always need to be\n\t * accessible, so we can't blow them away.\n\t */\n\tif (relation->rd_isnailed)\n\t{\n\t\tRelationReloadNailed(relation);\n\t\treturn;\n\t}\n\n\t/*\n\t * Even non-system indexes should not be blown away if they are open and\n\t * have valid index support information.  This avoids problems with active\n\t * use of the index support information.  As with nailed indexes, we\n\t * re-read the pg_class row to handle possible physical relocation of the\n\t * index, and we check for pg_index updates too.\n\t */\n\tif ((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t relation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\trelation->rd_refcnt > 0 &&\n\t\trelation->rd_indexcxt != NULL)\n\t{\n\t\trelation->rd_isvalid = false;\t/* needs to be revalidated */\n\t\tif (IsTransactionState())\n\t\t\tRelationReloadIndexInfo(relation);\n\t\treturn;\n\t}\n\n\t/* Mark it invalid until we've finished rebuild */\n\trelation->rd_isvalid = false;\n\n\t/*\n\t * If we're really done with the relcache entry, blow it away. But if\n\t * someone is still using it, reconstruct the whole deal without moving\n\t * the physical RelationData record (so that the someone's pointer is\n\t * still valid).\n\t */\n\tif (!rebuild)\n\t{\n\t\t/* Remove it from the hash table */\n\t\tRelationCacheDelete(relation);\n\n\t\t/* And release storage */\n\t\tRelationDestroyRelation(relation, false);\n\t}\n\telse if (!IsTransactionState())\n\t{\n\t\t/*\n\t\t * If we're not inside a valid transaction, we can't do any catalog\n\t\t * access so it's not possible to rebuild yet.  Just exit, leaving\n\t\t * rd_isvalid = false so that the rebuild will occur when the entry is\n\t\t * next opened.\n\t\t *\n\t\t * Note: it's possible that we come here during subtransaction abort,\n\t\t * and the reason for wanting to rebuild is that the rel is open in\n\t\t * the outer transaction.  In that case it might seem unsafe to not\n\t\t * rebuild immediately, since whatever code has the rel already open\n\t\t * will keep on using the relcache entry as-is.  However, in such a\n\t\t * case the outer transaction should be holding a lock that's\n\t\t * sufficient to prevent any significant change in the rel's schema,\n\t\t * so the existing entry contents should be good enough for its\n\t\t * purposes; at worst we might be behind on statistics updates or the\n\t\t * like.  (See also CheckTableNotInUse() and its callers.)\tThese same\n\t\t * remarks also apply to the cases above where we exit without having\n\t\t * done RelationReloadIndexInfo() yet.\n\t\t */\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Our strategy for rebuilding an open relcache entry is to build a\n\t\t * new entry from scratch, swap its contents with the old entry, and\n\t\t * finally delete the new entry (along with any infrastructure swapped\n\t\t * over from the old entry).  This is to avoid trouble in case an\n\t\t * error causes us to lose control partway through.  The old entry\n\t\t * will still be marked !rd_isvalid, so we'll try to rebuild it again\n\t\t * on next access.  Meanwhile it's not any less valid than it was\n\t\t * before, so any code that might expect to continue accessing it\n\t\t * isn't hurt by the rebuild failure.  (Consider for example a\n\t\t * subtransaction that ALTERs a table and then gets canceled partway\n\t\t * through the cache entry rebuild.  The outer transaction should\n\t\t * still see the not-modified cache entry as valid.)  The worst\n\t\t * consequence of an error is leaking the necessarily-unreferenced new\n\t\t * entry, and this shouldn't happen often enough for that to be a big\n\t\t * problem.\n\t\t *\n\t\t * When rebuilding an open relcache entry, we must preserve ref count,\n\t\t * rd_createSubid/rd_newRelfilenodeSubid, and rd_toastoid state.  Also\n\t\t * attempt to preserve the pg_class entry (rd_rel), tupledesc,\n\t\t * rewrite-rule, partition key, and partition descriptor substructures\n\t\t * in place, because various places assume that these structures won't\n\t\t * move while they are working with an open relcache entry.  (Note:\n\t\t * the refcount mechanism for tupledescs might someday allow us to\n\t\t * remove this hack for the tupledesc.)\n\t\t *\n\t\t * Note that this process does not touch CurrentResourceOwner; which\n\t\t * is good because whatever ref counts the entry may have do not\n\t\t * necessarily belong to that resource owner.\n\t\t */\n\t\tRelation\tnewrel;\n\t\tOid\t\t\tsave_relid = RelationGetRelid(relation);\n\t\tbool\t\tkeep_tupdesc;\n\t\tbool\t\tkeep_rules;\n\t\tbool\t\tkeep_policies;\n\t\tbool\t\tkeep_partkey;\n\t\tbool\t\tkeep_partdesc;\n\n\t\t/* Build temporary entry, but don't link it into hashtable */\n\t\tnewrel = RelationBuildDesc(save_relid, false);\n\t\tif (newrel == NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * We can validly get here, if we're using a historic snapshot in\n\t\t\t * which a relation, accessed from outside logical decoding, is\n\t\t\t * still invisible. In that case it's fine to just mark the\n\t\t\t * relation as invalid and return - it'll fully get reloaded by\n\t\t\t * the cache reset at the end of logical decoding (or at the next\n\t\t\t * access).  During normal processing we don't want to ignore this\n\t\t\t * case as it shouldn't happen there, as explained below.\n\t\t\t */\n\t\t\tif (HistoricSnapshotActive())\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * This shouldn't happen as dropping a relation is intended to be\n\t\t\t * impossible if still referenced (cf. CheckTableNotInUse()). But\n\t\t\t * if we get here anyway, we can't just delete the relcache entry,\n\t\t\t * as it possibly could get accessed later (as e.g. the error\n\t\t\t * might get trapped and handled via a subtransaction rollback).\n\t\t\t */\n\t\t\telog(ERROR, \"relation %u deleted while still in use\", save_relid);\n\t\t}\n\n\t\tkeep_tupdesc = equalTupleDescs(relation->rd_att, newrel->rd_att);\n\t\tkeep_rules = equalRuleLocks(relation->rd_rules, newrel->rd_rules);\n\t\tkeep_policies = equalRSDesc(relation->rd_rsdesc, newrel->rd_rsdesc);\n\t\t/* partkey is immutable once set up, so we can always keep it */\n\t\tkeep_partkey = (relation->rd_partkey != NULL);\n\t\tkeep_partdesc = equalPartitionDescs(relation->rd_partkey,\n\t\t\t\t\t\t\t\t\t\t\trelation->rd_partdesc,\n\t\t\t\t\t\t\t\t\t\t\tnewrel->rd_partdesc);\n\n\t\t/*\n\t\t * Perform swapping of the relcache entry contents.  Within this\n\t\t * process the old entry is momentarily invalid, so there *must* be no\n\t\t * possibility of CHECK_FOR_INTERRUPTS within this sequence. Do it in\n\t\t * all-in-line code for safety.\n\t\t *\n\t\t * Since the vast majority of fields should be swapped, our method is\n\t\t * to swap the whole structures and then re-swap those few fields we\n\t\t * didn't want swapped.\n\t\t */\n#define SWAPFIELD(fldtype, fldname) \\\n\t\tdo { \\\n\t\t\tfldtype _tmp = newrel->fldname; \\\n\t\t\tnewrel->fldname = relation->fldname; \\\n\t\t\trelation->fldname = _tmp; \\\n\t\t} while (0)\n\n\t\t/* swap all Relation struct fields */\n\t\t{\n\t\t\tRelationData tmpstruct;\n\n\t\t\tmemcpy(&tmpstruct, newrel, sizeof(RelationData));\n\t\t\tmemcpy(newrel, relation, sizeof(RelationData));\n\t\t\tmemcpy(relation, &tmpstruct, sizeof(RelationData));\n\t\t}\n\n\t\t/* rd_smgr must not be swapped, due to back-links from smgr level */\n\t\tSWAPFIELD(SMgrRelation, rd_smgr);\n\t\t/* rd_refcnt must be preserved */\n\t\tSWAPFIELD(int, rd_refcnt);\n\t\t/* isnailed shouldn't change */\n\t\tAssert(newrel->rd_isnailed == relation->rd_isnailed);\n\t\t/* creation sub-XIDs must be preserved */\n\t\tSWAPFIELD(SubTransactionId, rd_createSubid);\n\t\tSWAPFIELD(SubTransactionId, rd_newRelfilenodeSubid);\n\t\t/* un-swap rd_rel pointers, swap contents instead */\n\t\tSWAPFIELD(Form_pg_class, rd_rel);\n\t\t/* ... but actually, we don't have to update newrel->rd_rel */\n\t\tmemcpy(relation->rd_rel, newrel->rd_rel, CLASS_TUPLE_SIZE);\n\t\t/* preserve old tupledesc, rules, policies if no logical change */\n\t\tif (keep_tupdesc)\n\t\t\tSWAPFIELD(TupleDesc, rd_att);\n\t\tif (keep_rules)\n\t\t{\n\t\t\tSWAPFIELD(RuleLock *, rd_rules);\n\t\t\tSWAPFIELD(MemoryContext, rd_rulescxt);\n\t\t}\n\t\tif (keep_policies)\n\t\t\tSWAPFIELD(RowSecurityDesc *, rd_rsdesc);\n\t\t/* toast OID override must be preserved */\n\t\tSWAPFIELD(Oid, rd_toastoid);\n\t\t/* pgstat_info must be preserved */\n\t\tSWAPFIELD(struct PgStat_TableStatus *, pgstat_info);\n\t\t/* preserve old partitioning info if no logical change */\n\t\tif (keep_partkey)\n\t\t{\n\t\t\tSWAPFIELD(PartitionKey, rd_partkey);\n\t\t\tSWAPFIELD(MemoryContext, rd_partkeycxt);\n\t\t}\n\t\tif (keep_partdesc)\n\t\t{\n\t\t\tSWAPFIELD(PartitionDesc, rd_partdesc);\n\t\t\tSWAPFIELD(MemoryContext, rd_pdcxt);\n\t\t}\n\n#undef SWAPFIELD\n\n\t\t/* And now we can throw away the temporary entry */\n\t\tRelationDestroyRelation(newrel, !keep_tupdesc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationReloadIndexInfo",
          "args": [
            "rd"
          ],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "RelationReloadIndexInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "2049-2149",
          "snippet": "static void\nRelationReloadIndexInfo(Relation relation)\n{\n\tbool\t\tindexOK;\n\tHeapTuple\tpg_class_tuple;\n\tForm_pg_class relp;\n\n\t/* Should be called only for invalidated indexes */\n\tAssert((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t\trelation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\t   !relation->rd_isvalid);\n\n\t/* Ensure it's closed at smgr level */\n\tRelationCloseSmgr(relation);\n\n\t/* Must free any AM cached data upon relcache flush */\n\tif (relation->rd_amcache)\n\t\tpfree(relation->rd_amcache);\n\trelation->rd_amcache = NULL;\n\n\t/*\n\t * If it's a shared index, we might be called before backend startup has\n\t * finished selecting a database, in which case we have no way to read\n\t * pg_class yet.  However, a shared index can never have any significant\n\t * schema updates, so it's okay to ignore the invalidation signal.  Just\n\t * mark it valid and return without doing anything more.\n\t */\n\tif (relation->rd_rel->relisshared && !criticalRelcachesBuilt)\n\t{\n\t\trelation->rd_isvalid = true;\n\t\treturn;\n\t}\n\n\t/*\n\t * Read the pg_class row\n\t *\n\t * Don't try to use an indexscan of pg_class_oid_index to reload the info\n\t * for pg_class_oid_index ...\n\t */\n\tindexOK = (RelationGetRelid(relation) != ClassOidIndexId);\n\tpg_class_tuple = ScanPgRelation(RelationGetRelid(relation), indexOK, false);\n\tif (!HeapTupleIsValid(pg_class_tuple))\n\t\telog(ERROR, \"could not find pg_class tuple for index %u\",\n\t\t\t RelationGetRelid(relation));\n\trelp = (Form_pg_class) GETSTRUCT(pg_class_tuple);\n\tmemcpy(relation->rd_rel, relp, CLASS_TUPLE_SIZE);\n\t/* Reload reloptions in case they changed */\n\tif (relation->rd_options)\n\t\tpfree(relation->rd_options);\n\tRelationParseRelOptions(relation, pg_class_tuple);\n\t/* done with pg_class tuple */\n\theap_freetuple(pg_class_tuple);\n\t/* We must recalculate physical address in case it changed */\n\tRelationInitPhysicalAddr(relation);\n\n\t/*\n\t * For a non-system index, there are fields of the pg_index row that are\n\t * allowed to change, so re-read that row and update the relcache entry.\n\t * Most of the info derived from pg_index (such as support function lookup\n\t * info) cannot change, and indeed the whole point of this routine is to\n\t * update the relcache entry without clobbering that data; so wholesale\n\t * replacement is not appropriate.\n\t */\n\tif (!IsSystemRelation(relation))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_index index;\n\n\t\ttuple = SearchSysCache1(INDEXRELID,\n\t\t\t\t\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for index %u\",\n\t\t\t\t RelationGetRelid(relation));\n\t\tindex = (Form_pg_index) GETSTRUCT(tuple);\n\n\t\t/*\n\t\t * Basically, let's just copy all the bool fields.  There are one or\n\t\t * two of these that can't actually change in the current code, but\n\t\t * it's not worth it to track exactly which ones they are.  None of\n\t\t * the array fields are allowed to change, though.\n\t\t */\n\t\trelation->rd_index->indisunique = index->indisunique;\n\t\trelation->rd_index->indisprimary = index->indisprimary;\n\t\trelation->rd_index->indisexclusion = index->indisexclusion;\n\t\trelation->rd_index->indimmediate = index->indimmediate;\n\t\trelation->rd_index->indisclustered = index->indisclustered;\n\t\trelation->rd_index->indisvalid = index->indisvalid;\n\t\trelation->rd_index->indcheckxmin = index->indcheckxmin;\n\t\trelation->rd_index->indisready = index->indisready;\n\t\trelation->rd_index->indislive = index->indislive;\n\n\t\t/* Copy xmin too, as that is needed to make sense of indcheckxmin */\n\t\tHeapTupleHeaderSetXmin(relation->rd_indextuple->t_data,\n\t\t\t\t\t\t\t   HeapTupleHeaderGetXmin(tuple->t_data));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\n\t/* Okay, now it's valid again */\n\trelation->rd_isvalid = true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool\t\tcriticalRelcachesBuilt = false;",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static bool load_relcache_init_file(bool shared);",
            "static void write_relcache_init_file(bool shared);",
            "static Relation AllocateRelationDesc(Form_pg_class relp);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nbool\t\tcriticalRelcachesBuilt = false;\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic bool load_relcache_init_file(bool shared);\nstatic void write_relcache_init_file(bool shared);\nstatic Relation AllocateRelationDesc(Form_pg_class relp);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationReloadIndexInfo(Relation relation)\n{\n\tbool\t\tindexOK;\n\tHeapTuple\tpg_class_tuple;\n\tForm_pg_class relp;\n\n\t/* Should be called only for invalidated indexes */\n\tAssert((relation->rd_rel->relkind == RELKIND_INDEX ||\n\t\t\trelation->rd_rel->relkind == RELKIND_PARTITIONED_INDEX) &&\n\t\t   !relation->rd_isvalid);\n\n\t/* Ensure it's closed at smgr level */\n\tRelationCloseSmgr(relation);\n\n\t/* Must free any AM cached data upon relcache flush */\n\tif (relation->rd_amcache)\n\t\tpfree(relation->rd_amcache);\n\trelation->rd_amcache = NULL;\n\n\t/*\n\t * If it's a shared index, we might be called before backend startup has\n\t * finished selecting a database, in which case we have no way to read\n\t * pg_class yet.  However, a shared index can never have any significant\n\t * schema updates, so it's okay to ignore the invalidation signal.  Just\n\t * mark it valid and return without doing anything more.\n\t */\n\tif (relation->rd_rel->relisshared && !criticalRelcachesBuilt)\n\t{\n\t\trelation->rd_isvalid = true;\n\t\treturn;\n\t}\n\n\t/*\n\t * Read the pg_class row\n\t *\n\t * Don't try to use an indexscan of pg_class_oid_index to reload the info\n\t * for pg_class_oid_index ...\n\t */\n\tindexOK = (RelationGetRelid(relation) != ClassOidIndexId);\n\tpg_class_tuple = ScanPgRelation(RelationGetRelid(relation), indexOK, false);\n\tif (!HeapTupleIsValid(pg_class_tuple))\n\t\telog(ERROR, \"could not find pg_class tuple for index %u\",\n\t\t\t RelationGetRelid(relation));\n\trelp = (Form_pg_class) GETSTRUCT(pg_class_tuple);\n\tmemcpy(relation->rd_rel, relp, CLASS_TUPLE_SIZE);\n\t/* Reload reloptions in case they changed */\n\tif (relation->rd_options)\n\t\tpfree(relation->rd_options);\n\tRelationParseRelOptions(relation, pg_class_tuple);\n\t/* done with pg_class tuple */\n\theap_freetuple(pg_class_tuple);\n\t/* We must recalculate physical address in case it changed */\n\tRelationInitPhysicalAddr(relation);\n\n\t/*\n\t * For a non-system index, there are fields of the pg_index row that are\n\t * allowed to change, so re-read that row and update the relcache entry.\n\t * Most of the info derived from pg_index (such as support function lookup\n\t * info) cannot change, and indeed the whole point of this routine is to\n\t * update the relcache entry without clobbering that data; so wholesale\n\t * replacement is not appropriate.\n\t */\n\tif (!IsSystemRelation(relation))\n\t{\n\t\tHeapTuple\ttuple;\n\t\tForm_pg_index index;\n\n\t\ttuple = SearchSysCache1(INDEXRELID,\n\t\t\t\t\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for index %u\",\n\t\t\t\t RelationGetRelid(relation));\n\t\tindex = (Form_pg_index) GETSTRUCT(tuple);\n\n\t\t/*\n\t\t * Basically, let's just copy all the bool fields.  There are one or\n\t\t * two of these that can't actually change in the current code, but\n\t\t * it's not worth it to track exactly which ones they are.  None of\n\t\t * the array fields are allowed to change, though.\n\t\t */\n\t\trelation->rd_index->indisunique = index->indisunique;\n\t\trelation->rd_index->indisprimary = index->indisprimary;\n\t\trelation->rd_index->indisexclusion = index->indisexclusion;\n\t\trelation->rd_index->indimmediate = index->indimmediate;\n\t\trelation->rd_index->indisclustered = index->indisclustered;\n\t\trelation->rd_index->indisvalid = index->indisvalid;\n\t\trelation->rd_index->indcheckxmin = index->indcheckxmin;\n\t\trelation->rd_index->indisready = index->indisready;\n\t\trelation->rd_index->indislive = index->indislive;\n\n\t\t/* Copy xmin too, as that is needed to make sense of indcheckxmin */\n\t\tHeapTupleHeaderSetXmin(relation->rd_indextuple->t_data,\n\t\t\t\t\t\t\t   HeapTupleHeaderGetXmin(tuple->t_data));\n\n\t\tReleaseSysCache(tuple);\n\t}\n\n\t/* Okay, now it's valid again */\n\trelation->rd_isvalid = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationIsValid",
          "args": [
            "rd"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationIdCacheLookup",
          "args": [
            "relationId",
            "rd"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "IsTransactionState()"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsTransactionState",
          "args": [],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nbool\t\tcriticalRelcachesBuilt = false;\n\nRelation\nRelationIdGetRelation(Oid relationId)\n{\n\tRelation\trd;\n\n\t/* Make sure we're in an xact, even if this ends up being a cache hit */\n\tAssert(IsTransactionState());\n\n\t/*\n\t * first try to find reldesc in the cache\n\t */\n\tRelationIdCacheLookup(relationId, rd);\n\n\tif (RelationIsValid(rd))\n\t{\n\t\tRelationIncrementReferenceCount(rd);\n\t\t/* revalidate cache entry if necessary */\n\t\tif (!rd->rd_isvalid)\n\t\t{\n\t\t\t/*\n\t\t\t * Indexes only have a limited number of possible schema changes,\n\t\t\t * and we don't want to use the full-blown procedure because it's\n\t\t\t * a headache for indexes that reload itself depends on.\n\t\t\t */\n\t\t\tif (rd->rd_rel->relkind == RELKIND_INDEX ||\n\t\t\t\trd->rd_rel->relkind == RELKIND_PARTITIONED_INDEX)\n\t\t\t\tRelationReloadIndexInfo(rd);\n\t\t\telse\n\t\t\t\tRelationClearRelation(rd, true);\n\n\t\t\t/*\n\t\t\t * Normally entries need to be valid here, but before the relcache\n\t\t\t * has been initialized, not enough infrastructure exists to\n\t\t\t * perform pg_class lookups. The structure of such entries doesn't\n\t\t\t * change, but we still want to update the rd_rel entry. So\n\t\t\t * rd_isvalid = false is left in place for a later lookup.\n\t\t\t */\n\t\t\tAssert(rd->rd_isvalid ||\n\t\t\t\t   (rd->rd_isnailed && !criticalRelcachesBuilt));\n\t\t}\n\t\treturn rd;\n\t}\n\n\t/*\n\t * no reldesc in the cache, so have RelationBuildDesc() build one and add\n\t * it.\n\t */\n\trd = RelationBuildDesc(relationId, true);\n\tif (RelationIsValid(rd))\n\t\tRelationIncrementReferenceCount(rd);\n\treturn rd;\n}"
  },
  {
    "function_name": "formrdesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "1729-1885",
    "snippet": "static void\nformrdesc(const char *relationName, Oid relationReltype,\n\t\t  bool isshared, bool hasoids,\n\t\t  int natts, const FormData_pg_attribute *attrs)\n{\n\tRelation\trelation;\n\tint\t\t\ti;\n\tbool\t\thas_not_null;\n\n\t/*\n\t * allocate new relation desc, clear all fields of reldesc\n\t */\n\trelation = (Relation) palloc0(sizeof(RelationData));\n\n\t/* make sure relation is marked as having no open file yet */\n\trelation->rd_smgr = NULL;\n\n\t/*\n\t * initialize reference count: 1 because it is nailed in cache\n\t */\n\trelation->rd_refcnt = 1;\n\n\t/*\n\t * all entries built with this routine are nailed-in-cache; none are for\n\t * new or temp relations.\n\t */\n\trelation->rd_isnailed = true;\n\trelation->rd_createSubid = InvalidSubTransactionId;\n\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\trelation->rd_backend = InvalidBackendId;\n\trelation->rd_islocaltemp = false;\n\n\t/*\n\t * initialize relation tuple form\n\t *\n\t * The data we insert here is pretty incomplete/bogus, but it'll serve to\n\t * get us launched.  RelationCacheInitializePhase3() will read the real\n\t * data from pg_class and replace what we've done here.  Note in\n\t * particular that relowner is left as zero; this cues\n\t * RelationCacheInitializePhase3 that the real data isn't there yet.\n\t */\n\trelation->rd_rel = (Form_pg_class) palloc0(CLASS_TUPLE_SIZE);\n\n\tnamestrcpy(&relation->rd_rel->relname, relationName);\n\trelation->rd_rel->relnamespace = PG_CATALOG_NAMESPACE;\n\trelation->rd_rel->reltype = relationReltype;\n\n\t/*\n\t * It's important to distinguish between shared and non-shared relations,\n\t * even at bootstrap time, to make sure we know where they are stored.\n\t */\n\trelation->rd_rel->relisshared = isshared;\n\tif (isshared)\n\t\trelation->rd_rel->reltablespace = GLOBALTABLESPACE_OID;\n\n\t/* formrdesc is used only for permanent relations */\n\trelation->rd_rel->relpersistence = RELPERSISTENCE_PERMANENT;\n\n\t/* ... and they're always populated, too */\n\trelation->rd_rel->relispopulated = true;\n\n\trelation->rd_rel->relreplident = REPLICA_IDENTITY_NOTHING;\n\trelation->rd_rel->relpages = 0;\n\trelation->rd_rel->reltuples = 0;\n\trelation->rd_rel->relallvisible = 0;\n\trelation->rd_rel->relkind = RELKIND_RELATION;\n\trelation->rd_rel->relhasoids = hasoids;\n\trelation->rd_rel->relnatts = (int16) natts;\n\n\t/*\n\t * initialize attribute tuple form\n\t *\n\t * Unlike the case with the relation tuple, this data had better be right\n\t * because it will never be replaced.  The data comes from\n\t * src/include/catalog/ headers via genbki.pl.\n\t */\n\trelation->rd_att = CreateTemplateTupleDesc(natts, hasoids);\n\trelation->rd_att->tdrefcount = 1;\t/* mark as refcounted */\n\n\trelation->rd_att->tdtypeid = relationReltype;\n\trelation->rd_att->tdtypmod = -1;\t/* unnecessary, but... */\n\n\t/*\n\t * initialize tuple desc info\n\t */\n\thas_not_null = false;\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tmemcpy(TupleDescAttr(relation->rd_att, i),\n\t\t\t   &attrs[i],\n\t\t\t   ATTRIBUTE_FIXED_PART_SIZE);\n\t\thas_not_null |= attrs[i].attnotnull;\n\t\t/* make sure attcacheoff is valid */\n\t\tTupleDescAttr(relation->rd_att, i)->attcacheoff = -1;\n\t}\n\n\t/* initialize first attribute's attcacheoff, cf RelationBuildTupleDesc */\n\tTupleDescAttr(relation->rd_att, 0)->attcacheoff = 0;\n\n\t/* mark not-null status */\n\tif (has_not_null)\n\t{\n\t\tTupleConstr *constr = (TupleConstr *) palloc0(sizeof(TupleConstr));\n\n\t\tconstr->has_not_null = true;\n\t\trelation->rd_att->constr = constr;\n\t}\n\n\t/*\n\t * initialize relation id from info in att array (my, this is ugly)\n\t */\n\tRelationGetRelid(relation) = TupleDescAttr(relation->rd_att, 0)->attrelid;\n\n\t/*\n\t * All relations made with formrdesc are mapped.  This is necessarily so\n\t * because there is no other way to know what filenode they currently\n\t * have.  In bootstrap mode, add them to the initial relation mapper data,\n\t * specifying that the initial filenode is the same as the OID.\n\t */\n\trelation->rd_rel->relfilenode = InvalidOid;\n\tif (IsBootstrapProcessingMode())\n\t\tRelationMapUpdateMap(RelationGetRelid(relation),\n\t\t\t\t\t\t\t RelationGetRelid(relation),\n\t\t\t\t\t\t\t isshared, true);\n\n\t/*\n\t * initialize the relation lock manager information\n\t */\n\tRelationInitLockInfo(relation); /* see lmgr.c */\n\n\t/*\n\t * initialize physical addressing information for the relation\n\t */\n\tRelationInitPhysicalAddr(relation);\n\n\t/*\n\t * initialize the rel-has-index flag, using hardwired knowledge\n\t */\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\t/* In bootstrap mode, we have no indexes */\n\t\trelation->rd_rel->relhasindex = false;\n\t}\n\telse\n\t{\n\t\t/* Otherwise, all the rels formrdesc is used for have indexes */\n\t\trelation->rd_rel->relhasindex = true;\n\t}\n\n\t/*\n\t * add new reldesc to relcache\n\t */\n\tRelationCacheInsert(relation, false);\n\n\t/* It's fully valid */\n\trelation->rd_isvalid = true;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static bool load_relcache_init_file(bool shared);",
      "static void write_relcache_init_file(bool shared);",
      "static void formrdesc(const char *relationName, Oid relationReltype,\n\t\t  bool isshared, bool hasoids,\n\t\t  int natts, const FormData_pg_attribute *attrs);",
      "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RelationCacheInsert",
          "args": [
            "relation",
            "false"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationInitPhysicalAddr",
          "args": [
            "relation"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "RelationInitPhysicalAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1259-1315",
          "snippet": "static void\nRelationInitPhysicalAddr(Relation relation)\n{\n\tif (relation->rd_rel->reltablespace)\n\t\trelation->rd_node.spcNode = relation->rd_rel->reltablespace;\n\telse\n\t\trelation->rd_node.spcNode = MyDatabaseTableSpace;\n\tif (relation->rd_node.spcNode == GLOBALTABLESPACE_OID)\n\t\trelation->rd_node.dbNode = InvalidOid;\n\telse\n\t\trelation->rd_node.dbNode = MyDatabaseId;\n\n\tif (relation->rd_rel->relfilenode)\n\t{\n\t\t/*\n\t\t * Even if we are using a decoding snapshot that doesn't represent the\n\t\t * current state of the catalog we need to make sure the filenode\n\t\t * points to the current file since the older file will be gone (or\n\t\t * truncated). The new file will still contain older rows so lookups\n\t\t * in them will work correctly. This wouldn't work correctly if\n\t\t * rewrites were allowed to change the schema in an incompatible way,\n\t\t * but those are prevented both on catalog tables and on user tables\n\t\t * declared as additional catalog tables.\n\t\t */\n\t\tif (HistoricSnapshotActive()\n\t\t\t&& RelationIsAccessibleInLogicalDecoding(relation)\n\t\t\t&& IsTransactionState())\n\t\t{\n\t\t\tHeapTuple\tphys_tuple;\n\t\t\tForm_pg_class physrel;\n\n\t\t\tphys_tuple = ScanPgRelation(RelationGetRelid(relation),\n\t\t\t\t\t\t\t\t\t\tRelationGetRelid(relation) != ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t\ttrue);\n\t\t\tif (!HeapTupleIsValid(phys_tuple))\n\t\t\t\telog(ERROR, \"could not find pg_class entry for %u\",\n\t\t\t\t\t RelationGetRelid(relation));\n\t\t\tphysrel = (Form_pg_class) GETSTRUCT(phys_tuple);\n\n\t\t\trelation->rd_rel->reltablespace = physrel->reltablespace;\n\t\t\trelation->rd_rel->relfilenode = physrel->relfilenode;\n\t\t\theap_freetuple(phys_tuple);\n\t\t}\n\n\t\trelation->rd_node.relNode = relation->rd_rel->relfilenode;\n\t}\n\telse\n\t{\n\t\t/* Consult the relation mapper */\n\t\trelation->rd_node.relNode =\n\t\t\tRelationMapOidToFilenode(relation->rd_id,\n\t\t\t\t\t\t\t\t\t relation->rd_rel->relisshared);\n\t\tif (!OidIsValid(relation->rd_node.relNode))\n\t\t\telog(ERROR, \"could not find relation mapping for relation \\\"%s\\\", OID %u\",\n\t\t\t\t RelationGetRelationName(relation), relation->rd_id);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationInitPhysicalAddr(Relation relation)\n{\n\tif (relation->rd_rel->reltablespace)\n\t\trelation->rd_node.spcNode = relation->rd_rel->reltablespace;\n\telse\n\t\trelation->rd_node.spcNode = MyDatabaseTableSpace;\n\tif (relation->rd_node.spcNode == GLOBALTABLESPACE_OID)\n\t\trelation->rd_node.dbNode = InvalidOid;\n\telse\n\t\trelation->rd_node.dbNode = MyDatabaseId;\n\n\tif (relation->rd_rel->relfilenode)\n\t{\n\t\t/*\n\t\t * Even if we are using a decoding snapshot that doesn't represent the\n\t\t * current state of the catalog we need to make sure the filenode\n\t\t * points to the current file since the older file will be gone (or\n\t\t * truncated). The new file will still contain older rows so lookups\n\t\t * in them will work correctly. This wouldn't work correctly if\n\t\t * rewrites were allowed to change the schema in an incompatible way,\n\t\t * but those are prevented both on catalog tables and on user tables\n\t\t * declared as additional catalog tables.\n\t\t */\n\t\tif (HistoricSnapshotActive()\n\t\t\t&& RelationIsAccessibleInLogicalDecoding(relation)\n\t\t\t&& IsTransactionState())\n\t\t{\n\t\t\tHeapTuple\tphys_tuple;\n\t\t\tForm_pg_class physrel;\n\n\t\t\tphys_tuple = ScanPgRelation(RelationGetRelid(relation),\n\t\t\t\t\t\t\t\t\t\tRelationGetRelid(relation) != ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t\ttrue);\n\t\t\tif (!HeapTupleIsValid(phys_tuple))\n\t\t\t\telog(ERROR, \"could not find pg_class entry for %u\",\n\t\t\t\t\t RelationGetRelid(relation));\n\t\t\tphysrel = (Form_pg_class) GETSTRUCT(phys_tuple);\n\n\t\t\trelation->rd_rel->reltablespace = physrel->reltablespace;\n\t\t\trelation->rd_rel->relfilenode = physrel->relfilenode;\n\t\t\theap_freetuple(phys_tuple);\n\t\t}\n\n\t\trelation->rd_node.relNode = relation->rd_rel->relfilenode;\n\t}\n\telse\n\t{\n\t\t/* Consult the relation mapper */\n\t\trelation->rd_node.relNode =\n\t\t\tRelationMapOidToFilenode(relation->rd_id,\n\t\t\t\t\t\t\t\t\t relation->rd_rel->relisshared);\n\t\tif (!OidIsValid(relation->rd_node.relNode))\n\t\t\telog(ERROR, \"could not find relation mapping for relation \\\"%s\\\", OID %u\",\n\t\t\t\t RelationGetRelationName(relation), relation->rd_id);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationInitLockInfo",
          "args": [
            "relation"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationMapUpdateMap",
          "args": [
            "RelationGetRelid(relation)",
            "RelationGetRelid(relation)",
            "isshared",
            "true"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "RelationMapUpdateMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "247-295",
          "snippet": "void\nRelationMapUpdateMap(Oid relationId, Oid fileNode, bool shared,\n\t\t\t\t\t bool immediate)\n{\n\tRelMapFile *map;\n\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\t/*\n\t\t * In bootstrap mode, the mapping gets installed in permanent map.\n\t\t */\n\t\tif (shared)\n\t\t\tmap = &shared_map;\n\t\telse\n\t\t\tmap = &local_map;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't currently support map changes within subtransactions, and\n\t\t * parallel workers must avoid relying on mapping state, since it\n\t\t * isn't propagated from the leader.  This could be done with more\n\t\t * bookkeeping infrastructure, but it doesn't presently seem worth it.\n\t\t */\n\t\tif (GetCurrentTransactionNestLevel() > 1)\n\t\t\telog(ERROR, \"cannot change relation mapping within subtransaction\");\n\n\t\tif (IsInParallelMode())\n\t\t\telog(ERROR, \"cannot change relation mapping in parallel mode\");\n\n\t\tif (immediate)\n\t\t{\n\t\t\t/* Make it active, but only locally */\n\t\t\tif (shared)\n\t\t\t\tmap = &active_shared_updates;\n\t\t\telse\n\t\t\t\tmap = &active_local_updates;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Make it pending */\n\t\t\tif (shared)\n\t\t\t\tmap = &pending_shared_updates;\n\t\t\telse\n\t\t\t\tmap = &pending_local_updates;\n\t\t}\n\t}\n\tapply_map_update(map, relationId, fileNode, true);\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RelMapFile shared_map;",
            "static RelMapFile local_map;",
            "static RelMapFile active_shared_updates;",
            "static RelMapFile active_local_updates;",
            "static RelMapFile pending_shared_updates;",
            "static RelMapFile pending_local_updates;",
            "static void load_relmap_file(bool shared);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic RelMapFile active_shared_updates;\nstatic RelMapFile active_local_updates;\nstatic RelMapFile pending_shared_updates;\nstatic RelMapFile pending_local_updates;\nstatic void load_relmap_file(bool shared);\n\nvoid\nRelationMapUpdateMap(Oid relationId, Oid fileNode, bool shared,\n\t\t\t\t\t bool immediate)\n{\n\tRelMapFile *map;\n\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\t/*\n\t\t * In bootstrap mode, the mapping gets installed in permanent map.\n\t\t */\n\t\tif (shared)\n\t\t\tmap = &shared_map;\n\t\telse\n\t\t\tmap = &local_map;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * We don't currently support map changes within subtransactions, and\n\t\t * parallel workers must avoid relying on mapping state, since it\n\t\t * isn't propagated from the leader.  This could be done with more\n\t\t * bookkeeping infrastructure, but it doesn't presently seem worth it.\n\t\t */\n\t\tif (GetCurrentTransactionNestLevel() > 1)\n\t\t\telog(ERROR, \"cannot change relation mapping within subtransaction\");\n\n\t\tif (IsInParallelMode())\n\t\t\telog(ERROR, \"cannot change relation mapping in parallel mode\");\n\n\t\tif (immediate)\n\t\t{\n\t\t\t/* Make it active, but only locally */\n\t\t\tif (shared)\n\t\t\t\tmap = &active_shared_updates;\n\t\t\telse\n\t\t\t\tmap = &active_local_updates;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Make it pending */\n\t\t\tif (shared)\n\t\t\t\tmap = &pending_shared_updates;\n\t\t\telse\n\t\t\t\tmap = &pending_local_updates;\n\t\t}\n\t}\n\tapply_map_update(map, relationId, fileNode, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "relation->rd_att",
            "0"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(TupleConstr)"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "relation->rd_att",
            "0"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "relation->rd_att",
            "i"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "TupleDescAttr(relation->rd_att, i)",
            "&attrs[i]",
            "ATTRIBUTE_FIXED_PART_SIZE"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "relation->rd_att",
            "i"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTemplateTupleDesc",
          "args": [
            "natts",
            "hasoids"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "namestrcpy",
          "args": [
            "&relation->rd_rel->relname",
            "relationName"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic bool load_relcache_init_file(bool shared);\nstatic void write_relcache_init_file(bool shared);\nstatic void formrdesc(const char *relationName, Oid relationReltype,\n\t\t  bool isshared, bool hasoids,\n\t\t  int natts, const FormData_pg_attribute *attrs);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nformrdesc(const char *relationName, Oid relationReltype,\n\t\t  bool isshared, bool hasoids,\n\t\t  int natts, const FormData_pg_attribute *attrs)\n{\n\tRelation\trelation;\n\tint\t\t\ti;\n\tbool\t\thas_not_null;\n\n\t/*\n\t * allocate new relation desc, clear all fields of reldesc\n\t */\n\trelation = (Relation) palloc0(sizeof(RelationData));\n\n\t/* make sure relation is marked as having no open file yet */\n\trelation->rd_smgr = NULL;\n\n\t/*\n\t * initialize reference count: 1 because it is nailed in cache\n\t */\n\trelation->rd_refcnt = 1;\n\n\t/*\n\t * all entries built with this routine are nailed-in-cache; none are for\n\t * new or temp relations.\n\t */\n\trelation->rd_isnailed = true;\n\trelation->rd_createSubid = InvalidSubTransactionId;\n\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\trelation->rd_backend = InvalidBackendId;\n\trelation->rd_islocaltemp = false;\n\n\t/*\n\t * initialize relation tuple form\n\t *\n\t * The data we insert here is pretty incomplete/bogus, but it'll serve to\n\t * get us launched.  RelationCacheInitializePhase3() will read the real\n\t * data from pg_class and replace what we've done here.  Note in\n\t * particular that relowner is left as zero; this cues\n\t * RelationCacheInitializePhase3 that the real data isn't there yet.\n\t */\n\trelation->rd_rel = (Form_pg_class) palloc0(CLASS_TUPLE_SIZE);\n\n\tnamestrcpy(&relation->rd_rel->relname, relationName);\n\trelation->rd_rel->relnamespace = PG_CATALOG_NAMESPACE;\n\trelation->rd_rel->reltype = relationReltype;\n\n\t/*\n\t * It's important to distinguish between shared and non-shared relations,\n\t * even at bootstrap time, to make sure we know where they are stored.\n\t */\n\trelation->rd_rel->relisshared = isshared;\n\tif (isshared)\n\t\trelation->rd_rel->reltablespace = GLOBALTABLESPACE_OID;\n\n\t/* formrdesc is used only for permanent relations */\n\trelation->rd_rel->relpersistence = RELPERSISTENCE_PERMANENT;\n\n\t/* ... and they're always populated, too */\n\trelation->rd_rel->relispopulated = true;\n\n\trelation->rd_rel->relreplident = REPLICA_IDENTITY_NOTHING;\n\trelation->rd_rel->relpages = 0;\n\trelation->rd_rel->reltuples = 0;\n\trelation->rd_rel->relallvisible = 0;\n\trelation->rd_rel->relkind = RELKIND_RELATION;\n\trelation->rd_rel->relhasoids = hasoids;\n\trelation->rd_rel->relnatts = (int16) natts;\n\n\t/*\n\t * initialize attribute tuple form\n\t *\n\t * Unlike the case with the relation tuple, this data had better be right\n\t * because it will never be replaced.  The data comes from\n\t * src/include/catalog/ headers via genbki.pl.\n\t */\n\trelation->rd_att = CreateTemplateTupleDesc(natts, hasoids);\n\trelation->rd_att->tdrefcount = 1;\t/* mark as refcounted */\n\n\trelation->rd_att->tdtypeid = relationReltype;\n\trelation->rd_att->tdtypmod = -1;\t/* unnecessary, but... */\n\n\t/*\n\t * initialize tuple desc info\n\t */\n\thas_not_null = false;\n\tfor (i = 0; i < natts; i++)\n\t{\n\t\tmemcpy(TupleDescAttr(relation->rd_att, i),\n\t\t\t   &attrs[i],\n\t\t\t   ATTRIBUTE_FIXED_PART_SIZE);\n\t\thas_not_null |= attrs[i].attnotnull;\n\t\t/* make sure attcacheoff is valid */\n\t\tTupleDescAttr(relation->rd_att, i)->attcacheoff = -1;\n\t}\n\n\t/* initialize first attribute's attcacheoff, cf RelationBuildTupleDesc */\n\tTupleDescAttr(relation->rd_att, 0)->attcacheoff = 0;\n\n\t/* mark not-null status */\n\tif (has_not_null)\n\t{\n\t\tTupleConstr *constr = (TupleConstr *) palloc0(sizeof(TupleConstr));\n\n\t\tconstr->has_not_null = true;\n\t\trelation->rd_att->constr = constr;\n\t}\n\n\t/*\n\t * initialize relation id from info in att array (my, this is ugly)\n\t */\n\tRelationGetRelid(relation) = TupleDescAttr(relation->rd_att, 0)->attrelid;\n\n\t/*\n\t * All relations made with formrdesc are mapped.  This is necessarily so\n\t * because there is no other way to know what filenode they currently\n\t * have.  In bootstrap mode, add them to the initial relation mapper data,\n\t * specifying that the initial filenode is the same as the OID.\n\t */\n\trelation->rd_rel->relfilenode = InvalidOid;\n\tif (IsBootstrapProcessingMode())\n\t\tRelationMapUpdateMap(RelationGetRelid(relation),\n\t\t\t\t\t\t\t RelationGetRelid(relation),\n\t\t\t\t\t\t\t isshared, true);\n\n\t/*\n\t * initialize the relation lock manager information\n\t */\n\tRelationInitLockInfo(relation); /* see lmgr.c */\n\n\t/*\n\t * initialize physical addressing information for the relation\n\t */\n\tRelationInitPhysicalAddr(relation);\n\n\t/*\n\t * initialize the rel-has-index flag, using hardwired knowledge\n\t */\n\tif (IsBootstrapProcessingMode())\n\t{\n\t\t/* In bootstrap mode, we have no indexes */\n\t\trelation->rd_rel->relhasindex = false;\n\t}\n\telse\n\t{\n\t\t/* Otherwise, all the rels formrdesc is used for have indexes */\n\t\trelation->rd_rel->relhasindex = true;\n\t}\n\n\t/*\n\t * add new reldesc to relcache\n\t */\n\tRelationCacheInsert(relation, false);\n\n\t/* It's fully valid */\n\trelation->rd_isvalid = true;\n}"
  },
  {
    "function_name": "LookupOpclassInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "1565-1708",
    "snippet": "static OpClassCacheEnt *\nLookupOpclassInfo(Oid operatorClassOid,\n\t\t\t\t  StrategyNumber numSupport)\n{\n\tOpClassCacheEnt *opcentry;\n\tbool\t\tfound;\n\tRelation\trel;\n\tSysScanDesc scan;\n\tScanKeyData skey[3];\n\tHeapTuple\thtup;\n\tbool\t\tindexOK;\n\n\tif (OpClassCache == NULL)\n\t{\n\t\t/* First time through: initialize the opclass cache */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(OpClassCacheEnt);\n\t\tOpClassCache = hash_create(\"Operator class cache\", 64,\n\t\t\t\t\t\t\t\t   &ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\topcentry = (OpClassCacheEnt *) hash_search(OpClassCache,\n\t\t\t\t\t\t\t\t\t\t\t   (void *) &operatorClassOid,\n\t\t\t\t\t\t\t\t\t\t\t   HASH_ENTER, &found);\n\n\tif (!found)\n\t{\n\t\t/* Need to allocate memory for new entry */\n\t\topcentry->valid = false;\t/* until known OK */\n\t\topcentry->numSupport = numSupport;\n\n\t\tif (numSupport > 0)\n\t\t\topcentry->supportProcs = (RegProcedure *)\n\t\t\t\tMemoryContextAllocZero(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t   numSupport * sizeof(RegProcedure));\n\t\telse\n\t\t\topcentry->supportProcs = NULL;\n\t}\n\telse\n\t{\n\t\tAssert(numSupport == opcentry->numSupport);\n\t}\n\n\t/*\n\t * When testing for cache-flush hazards, we intentionally disable the\n\t * operator class cache and force reloading of the info on each call. This\n\t * is helpful because we want to test the case where a cache flush occurs\n\t * while we are loading the info, and it's very hard to provoke that if\n\t * this happens only once per opclass per backend.\n\t */\n#if defined(CLOBBER_CACHE_ALWAYS)\n\topcentry->valid = false;\n#endif\n\n\tif (opcentry->valid)\n\t\treturn opcentry;\n\n\t/*\n\t * Need to fill in new entry.\n\t *\n\t * To avoid infinite recursion during startup, force heap scans if we're\n\t * looking up info for the opclasses used by the indexes we would like to\n\t * reference here.\n\t */\n\tindexOK = criticalRelcachesBuilt ||\n\t\t(operatorClassOid != OID_BTREE_OPS_OID &&\n\t\t operatorClassOid != INT2_BTREE_OPS_OID);\n\n\t/*\n\t * We have to fetch the pg_opclass row to determine its opfamily and\n\t * opcintype, which are needed to look up related operators and functions.\n\t * It'd be convenient to use the syscache here, but that probably doesn't\n\t * work while bootstrapping.\n\t */\n\tScanKeyInit(&skey[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(operatorClassOid));\n\trel = heap_open(OperatorClassRelationId, AccessShareLock);\n\tscan = systable_beginscan(rel, OpclassOidIndexId, indexOK,\n\t\t\t\t\t\t\t  NULL, 1, skey);\n\n\tif (HeapTupleIsValid(htup = systable_getnext(scan)))\n\t{\n\t\tForm_pg_opclass opclassform = (Form_pg_opclass) GETSTRUCT(htup);\n\n\t\topcentry->opcfamily = opclassform->opcfamily;\n\t\topcentry->opcintype = opclassform->opcintype;\n\t}\n\telse\n\t\telog(ERROR, \"could not find tuple for opclass %u\", operatorClassOid);\n\n\tsystable_endscan(scan);\n\theap_close(rel, AccessShareLock);\n\n\t/*\n\t * Scan pg_amproc to obtain support procs for the opclass.  We only fetch\n\t * the default ones (those with lefttype = righttype = opcintype).\n\t */\n\tif (numSupport > 0)\n\t{\n\t\tScanKeyInit(&skey[0],\n\t\t\t\t\tAnum_pg_amproc_amprocfamily,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(opcentry->opcfamily));\n\t\tScanKeyInit(&skey[1],\n\t\t\t\t\tAnum_pg_amproc_amproclefttype,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(opcentry->opcintype));\n\t\tScanKeyInit(&skey[2],\n\t\t\t\t\tAnum_pg_amproc_amprocrighttype,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(opcentry->opcintype));\n\t\trel = heap_open(AccessMethodProcedureRelationId, AccessShareLock);\n\t\tscan = systable_beginscan(rel, AccessMethodProcedureIndexId, indexOK,\n\t\t\t\t\t\t\t\t  NULL, 3, skey);\n\n\t\twhile (HeapTupleIsValid(htup = systable_getnext(scan)))\n\t\t{\n\t\t\tForm_pg_amproc amprocform = (Form_pg_amproc) GETSTRUCT(htup);\n\n\t\t\tif (amprocform->amprocnum <= 0 ||\n\t\t\t\t(StrategyNumber) amprocform->amprocnum > numSupport)\n\t\t\t\telog(ERROR, \"invalid amproc number %d for opclass %u\",\n\t\t\t\t\t amprocform->amprocnum, operatorClassOid);\n\n\t\t\topcentry->supportProcs[amprocform->amprocnum - 1] =\n\t\t\t\tamprocform->amproc;\n\t\t}\n\n\t\tsystable_endscan(scan);\n\t\theap_close(rel, AccessShareLock);\n\t}\n\n\topcentry->valid = true;\n\treturn opcentry;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool\t\tcriticalRelcachesBuilt = false;",
      "static HTAB *OpClassCache = NULL;",
      "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
      "static OpClassCacheEnt *LookupOpclassInfo(Oid operatorClassOid,\n\t\t\t\t  StrategyNumber numSupport);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "rel",
            "AccessShareLock"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan",
          "args": [
            "scan"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid amproc number %d for opclass %u\"",
            "amprocform->amprocnum",
            "operatorClassOid"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "htup"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "htup = systable_getnext(scan)"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext",
          "args": [
            "scan"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_beginscan",
          "args": [
            "rel",
            "AccessMethodProcedureIndexId",
            "indexOK",
            "NULL",
            "3",
            "skey"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "AccessMethodProcedureRelationId",
            "AccessShareLock"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyInit",
          "args": [
            "&skey[2]",
            "Anum_pg_amproc_amprocrighttype",
            "BTEqualStrategyNumber",
            "F_OIDEQ",
            "ObjectIdGetDatum(opcentry->opcintype)"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "opcentry->opcintype"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyInit",
          "args": [
            "&skey[1]",
            "Anum_pg_amproc_amproclefttype",
            "BTEqualStrategyNumber",
            "F_OIDEQ",
            "ObjectIdGetDatum(opcentry->opcintype)"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "opcentry->opcintype"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyInit",
          "args": [
            "&skey[0]",
            "Anum_pg_amproc_amprocfamily",
            "BTEqualStrategyNumber",
            "F_OIDEQ",
            "ObjectIdGetDatum(opcentry->opcfamily)"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "opcentry->opcfamily"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "rel",
            "AccessShareLock"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan",
          "args": [
            "scan"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "htup"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "htup = systable_getnext(scan)"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext",
          "args": [
            "scan"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_beginscan",
          "args": [
            "rel",
            "OpclassOidIndexId",
            "indexOK",
            "NULL",
            "1",
            "skey"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "OperatorClassRelationId",
            "AccessShareLock"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyInit",
          "args": [
            "&skey[0]",
            "ObjectIdAttributeNumber",
            "BTEqualStrategyNumber",
            "F_OIDEQ",
            "ObjectIdGetDatum(operatorClassOid)"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "operatorClassOid"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "numSupport == opcentry->numSupport"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "CacheMemoryContext",
            "numSupport * sizeof(RegProcedure)"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_search",
          "args": [
            "OpClassCache",
            "(void *) &operatorClassOid",
            "HASH_ENTER",
            "&found"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "hash_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "905-916",
          "snippet": "void *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\n\nvoid *\nhash_search(HTAB *hashp,\n\t\t\tconst void *keyPtr,\n\t\t\tHASHACTION action,\n\t\t\tbool *foundPtr)\n{\n\treturn hash_search_with_hash_value(hashp,\n\t\t\t\t\t\t\t\t\t   keyPtr,\n\t\t\t\t\t\t\t\t\t   hashp->hash(keyPtr, hashp->keysize),\n\t\t\t\t\t\t\t\t\t   action,\n\t\t\t\t\t\t\t\t\t   foundPtr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CreateCacheMemoryContext",
          "args": [],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "CreateCacheMemoryContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/catcache.c",
          "lines": "635-646",
          "snippet": "void\nCreateCacheMemoryContext(void)\n{\n\t/*\n\t * Purely for paranoia, check that context doesn't exist; caller probably\n\t * did so already.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCacheMemoryContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"CacheMemoryContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/hashutils.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"storage/ipc.h\"\t\t/* for on_proc_exit */",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/valid.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/relscan.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"access/genam.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/inval.h\"\n#include \"utils/hashutils.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"storage/lmgr.h\"\n#include \"storage/ipc.h\"\t\t/* for on_proc_exit */\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/xact.h\"\n#include \"access/valid.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/sysattr.h\"\n#include \"access/relscan.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"access/genam.h\"\n#include \"postgres.h\"\n\nvoid\nCreateCacheMemoryContext(void)\n{\n\t/*\n\t * Purely for paranoia, check that context doesn't exist; caller probably\n\t * did so already.\n\t */\n\tif (!CacheMemoryContext)\n\t\tCacheMemoryContext = AllocSetContextCreate(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"CacheMemoryContext\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_create",
          "args": [
            "\"Operator class cache\"",
            "64",
            "&ctl",
            "HASH_ELEM | HASH_BLOBS"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "hash_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/hash/dynahash.c",
          "lines": "315-564",
          "snippet": "HTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/dynahash.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/shmem.h\"",
            "#include \"access/xact.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define NUM_FREELISTS\t\t\t32"
          ],
          "globals_used": [
            "static void *DynaHashAlloc(Size size);",
            "static HASHSEGMENT seg_alloc(HTAB *hashp);",
            "static bool dir_realloc(HTAB *hashp);",
            "static bool expand_table(HTAB *hashp);",
            "static void hdefault(HTAB *hashp);",
            "static int\tchoose_nelem_alloc(Size entrysize);",
            "static bool init_htab(HTAB *hashp, long nelem);",
            "static void hash_corrupted(HTAB *hashp);",
            "static void register_seq_scan(HTAB *hashp);",
            "static void deregister_seq_scan(HTAB *hashp);",
            "static bool has_seq_scans(HTAB *hashp);",
            "static MemoryContext CurrentDynaHashCxt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/dynahash.h\"\n#include \"storage/spin.h\"\n#include \"storage/shmem.h\"\n#include \"access/xact.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define NUM_FREELISTS\t\t\t32\n\nstatic void *DynaHashAlloc(Size size);\nstatic HASHSEGMENT seg_alloc(HTAB *hashp);\nstatic bool dir_realloc(HTAB *hashp);\nstatic bool expand_table(HTAB *hashp);\nstatic void hdefault(HTAB *hashp);\nstatic int\tchoose_nelem_alloc(Size entrysize);\nstatic bool init_htab(HTAB *hashp, long nelem);\nstatic void hash_corrupted(HTAB *hashp);\nstatic void register_seq_scan(HTAB *hashp);\nstatic void deregister_seq_scan(HTAB *hashp);\nstatic bool has_seq_scans(HTAB *hashp);\nstatic MemoryContext CurrentDynaHashCxt = NULL;\n\nHTAB *\nhash_create(const char *tabname, long nelem, HASHCTL *info, int flags)\n{\n\tHTAB\t   *hashp;\n\tHASHHDR    *hctl;\n\n\t/*\n\t * For shared hash tables, we have a local hash header (HTAB struct) that\n\t * we allocate in TopMemoryContext; all else is in shared memory.\n\t *\n\t * For non-shared hash tables, everything including the hash header is in\n\t * a memory context created specially for the hash table --- this makes\n\t * hash_destroy very simple.  The memory context is made a child of either\n\t * a context specified by the caller, or TopMemoryContext if nothing is\n\t * specified.\n\t */\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/* Set up to allocate the hash header */\n\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t}\n\telse\n\t{\n\t\t/* Create the hash table's private memory context */\n\t\tif (flags & HASH_CONTEXT)\n\t\t\tCurrentDynaHashCxt = info->hcxt;\n\t\telse\n\t\t\tCurrentDynaHashCxt = TopMemoryContext;\n\t\tCurrentDynaHashCxt = AllocSetContextCreate(CurrentDynaHashCxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"dynahash\",\n\t\t\t\t\t\t\t\t\t\t\t\t   ALLOCSET_DEFAULT_SIZES);\n\t}\n\n\t/* Initialize the hash header, plus a copy of the table name */\n\thashp = (HTAB *) DynaHashAlloc(sizeof(HTAB) + strlen(tabname) + 1);\n\tMemSet(hashp, 0, sizeof(HTAB));\n\n\thashp->tabname = (char *) (hashp + 1);\n\tstrcpy(hashp->tabname, tabname);\n\n\t/* If we have a private context, label it with hashtable's name */\n\tif (!(flags & HASH_SHARED_MEM))\n\t\tMemoryContextSetIdentifier(CurrentDynaHashCxt, hashp->tabname);\n\n\t/*\n\t * Select the appropriate hash function (see comments at head of file).\n\t */\n\tif (flags & HASH_FUNCTION)\n\t\thashp->hash = info->hash;\n\telse if (flags & HASH_BLOBS)\n\t{\n\t\t/* We can optimize hashing for common key sizes */\n\t\tAssert(flags & HASH_ELEM);\n\t\tif (info->keysize == sizeof(uint32))\n\t\t\thashp->hash = uint32_hash;\n\t\telse\n\t\t\thashp->hash = tag_hash;\n\t}\n\telse\n\t\thashp->hash = string_hash;\t/* default hash function */\n\n\t/*\n\t * If you don't specify a match function, it defaults to string_compare if\n\t * you used string_hash (either explicitly or by default) and to memcmp\n\t * otherwise.\n\t *\n\t * Note: explicitly specifying string_hash is deprecated, because this\n\t * might not work for callers in loadable modules on some platforms due to\n\t * referencing a trampoline instead of the string_hash function proper.\n\t * Just let it default, eh?\n\t */\n\tif (flags & HASH_COMPARE)\n\t\thashp->match = info->match;\n\telse if (hashp->hash == string_hash)\n\t\thashp->match = (HashCompareFunc) string_compare;\n\telse\n\t\thashp->match = memcmp;\n\n\t/*\n\t * Similarly, the key-copying function defaults to strlcpy or memcpy.\n\t */\n\tif (flags & HASH_KEYCOPY)\n\t\thashp->keycopy = info->keycopy;\n\telse if (hashp->hash == string_hash)\n\t\thashp->keycopy = (HashCopyFunc) strlcpy;\n\telse\n\t\thashp->keycopy = memcpy;\n\n\t/* And select the entry allocation function, too. */\n\tif (flags & HASH_ALLOC)\n\t\thashp->alloc = info->alloc;\n\telse\n\t\thashp->alloc = DynaHashAlloc;\n\n\tif (flags & HASH_SHARED_MEM)\n\t{\n\t\t/*\n\t\t * ctl structure and directory are preallocated for shared memory\n\t\t * tables.  Note that HASH_DIRSIZE and HASH_ALLOC had better be set as\n\t\t * well.\n\t\t */\n\t\thashp->hctl = info->hctl;\n\t\thashp->dir = (HASHSEGMENT *) (((char *) info->hctl) + sizeof(HASHHDR));\n\t\thashp->hcxt = NULL;\n\t\thashp->isshared = true;\n\n\t\t/* hash table already exists, we're just attaching to it */\n\t\tif (flags & HASH_ATTACH)\n\t\t{\n\t\t\t/* make local copies of some heavily-used values */\n\t\t\thctl = hashp->hctl;\n\t\t\thashp->keysize = hctl->keysize;\n\t\t\thashp->ssize = hctl->ssize;\n\t\t\thashp->sshift = hctl->sshift;\n\n\t\t\treturn hashp;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* setup hash table defaults */\n\t\thashp->hctl = NULL;\n\t\thashp->dir = NULL;\n\t\thashp->hcxt = CurrentDynaHashCxt;\n\t\thashp->isshared = false;\n\t}\n\n\tif (!hashp->hctl)\n\t{\n\t\thashp->hctl = (HASHHDR *) hashp->alloc(sizeof(HASHHDR));\n\t\tif (!hashp->hctl)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\t}\n\n\thashp->frozen = false;\n\n\thdefault(hashp);\n\n\thctl = hashp->hctl;\n\n\tif (flags & HASH_PARTITION)\n\t{\n\t\t/* Doesn't make sense to partition a local hash table */\n\t\tAssert(flags & HASH_SHARED_MEM);\n\n\t\t/*\n\t\t * The number of partitions had better be a power of 2. Also, it must\n\t\t * be less than INT_MAX (see init_htab()), so call the int version of\n\t\t * next_pow2.\n\t\t */\n\t\tAssert(info->num_partitions == next_pow2_int(info->num_partitions));\n\n\t\thctl->num_partitions = info->num_partitions;\n\t}\n\n\tif (flags & HASH_SEGMENT)\n\t{\n\t\thctl->ssize = info->ssize;\n\t\thctl->sshift = my_log2(info->ssize);\n\t\t/* ssize had better be a power of 2 */\n\t\tAssert(hctl->ssize == (1L << hctl->sshift));\n\t}\n\tif (flags & HASH_FFACTOR)\n\t\thctl->ffactor = info->ffactor;\n\n\t/*\n\t * SHM hash tables have fixed directory size passed by the caller.\n\t */\n\tif (flags & HASH_DIRSIZE)\n\t{\n\t\thctl->max_dsize = info->max_dsize;\n\t\thctl->dsize = info->dsize;\n\t}\n\n\t/*\n\t * hash table now allocates space for key and data but you have to say how\n\t * much space to allocate\n\t */\n\tif (flags & HASH_ELEM)\n\t{\n\t\tAssert(info->entrysize >= info->keysize);\n\t\thctl->keysize = info->keysize;\n\t\thctl->entrysize = info->entrysize;\n\t}\n\n\t/* make local copies of heavily-used constant fields */\n\thashp->keysize = hctl->keysize;\n\thashp->ssize = hctl->ssize;\n\thashp->sshift = hctl->sshift;\n\n\t/* Build the hash directory structure */\n\tif (!init_htab(hashp, nelem))\n\t\telog(ERROR, \"failed to initialize hash table \\\"%s\\\"\", hashp->tabname);\n\n\t/*\n\t * For a shared hash table, preallocate the requested number of elements.\n\t * This reduces problems with run-time out-of-shared-memory conditions.\n\t *\n\t * For a non-shared hash table, preallocate the requested number of\n\t * elements if it's less than our chosen nelem_alloc.  This avoids wasting\n\t * space if the caller correctly estimates a small table size.\n\t */\n\tif ((flags & HASH_SHARED_MEM) ||\n\t\tnelem < hctl->nelem_alloc)\n\t{\n\t\tint\t\t\ti,\n\t\t\t\t\tfreelist_partitions,\n\t\t\t\t\tnelem_alloc,\n\t\t\t\t\tnelem_alloc_first;\n\n\t\t/*\n\t\t * If hash table is partitioned, give each freelist an equal share of\n\t\t * the initial allocation.  Otherwise only freeList[0] is used.\n\t\t */\n\t\tif (IS_PARTITIONED(hashp->hctl))\n\t\t\tfreelist_partitions = NUM_FREELISTS;\n\t\telse\n\t\t\tfreelist_partitions = 1;\n\n\t\tnelem_alloc = nelem / freelist_partitions;\n\t\tif (nelem_alloc <= 0)\n\t\t\tnelem_alloc = 1;\n\n\t\t/*\n\t\t * Make sure we'll allocate all the requested elements; freeList[0]\n\t\t * gets the excess if the request isn't divisible by NUM_FREELISTS.\n\t\t */\n\t\tif (nelem_alloc * freelist_partitions < nelem)\n\t\t\tnelem_alloc_first =\n\t\t\t\tnelem - nelem_alloc * (freelist_partitions - 1);\n\t\telse\n\t\t\tnelem_alloc_first = nelem_alloc;\n\n\t\tfor (i = 0; i < freelist_partitions; i++)\n\t\t{\n\t\t\tint\t\t\ttemp = (i == 0) ? nelem_alloc_first : nelem_alloc;\n\n\t\t\tif (!element_alloc(hashp, temp, i))\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t errmsg(\"out of memory\")));\n\t\t}\n\t}\n\n\tif (flags & HASH_FIXED_SIZE)\n\t\thashp->isfixed = true;\n\treturn hashp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "&ctl",
            "0",
            "sizeof(ctl)"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nbool\t\tcriticalRelcachesBuilt = false;\nstatic HTAB *OpClassCache = NULL;\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic OpClassCacheEnt *LookupOpclassInfo(Oid operatorClassOid,\n\t\t\t\t  StrategyNumber numSupport);\n\nstatic OpClassCacheEnt *\nLookupOpclassInfo(Oid operatorClassOid,\n\t\t\t\t  StrategyNumber numSupport)\n{\n\tOpClassCacheEnt *opcentry;\n\tbool\t\tfound;\n\tRelation\trel;\n\tSysScanDesc scan;\n\tScanKeyData skey[3];\n\tHeapTuple\thtup;\n\tbool\t\tindexOK;\n\n\tif (OpClassCache == NULL)\n\t{\n\t\t/* First time through: initialize the opclass cache */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(OpClassCacheEnt);\n\t\tOpClassCache = hash_create(\"Operator class cache\", 64,\n\t\t\t\t\t\t\t\t   &ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\topcentry = (OpClassCacheEnt *) hash_search(OpClassCache,\n\t\t\t\t\t\t\t\t\t\t\t   (void *) &operatorClassOid,\n\t\t\t\t\t\t\t\t\t\t\t   HASH_ENTER, &found);\n\n\tif (!found)\n\t{\n\t\t/* Need to allocate memory for new entry */\n\t\topcentry->valid = false;\t/* until known OK */\n\t\topcentry->numSupport = numSupport;\n\n\t\tif (numSupport > 0)\n\t\t\topcentry->supportProcs = (RegProcedure *)\n\t\t\t\tMemoryContextAllocZero(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t   numSupport * sizeof(RegProcedure));\n\t\telse\n\t\t\topcentry->supportProcs = NULL;\n\t}\n\telse\n\t{\n\t\tAssert(numSupport == opcentry->numSupport);\n\t}\n\n\t/*\n\t * When testing for cache-flush hazards, we intentionally disable the\n\t * operator class cache and force reloading of the info on each call. This\n\t * is helpful because we want to test the case where a cache flush occurs\n\t * while we are loading the info, and it's very hard to provoke that if\n\t * this happens only once per opclass per backend.\n\t */\n#if defined(CLOBBER_CACHE_ALWAYS)\n\topcentry->valid = false;\n#endif\n\n\tif (opcentry->valid)\n\t\treturn opcentry;\n\n\t/*\n\t * Need to fill in new entry.\n\t *\n\t * To avoid infinite recursion during startup, force heap scans if we're\n\t * looking up info for the opclasses used by the indexes we would like to\n\t * reference here.\n\t */\n\tindexOK = criticalRelcachesBuilt ||\n\t\t(operatorClassOid != OID_BTREE_OPS_OID &&\n\t\t operatorClassOid != INT2_BTREE_OPS_OID);\n\n\t/*\n\t * We have to fetch the pg_opclass row to determine its opfamily and\n\t * opcintype, which are needed to look up related operators and functions.\n\t * It'd be convenient to use the syscache here, but that probably doesn't\n\t * work while bootstrapping.\n\t */\n\tScanKeyInit(&skey[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(operatorClassOid));\n\trel = heap_open(OperatorClassRelationId, AccessShareLock);\n\tscan = systable_beginscan(rel, OpclassOidIndexId, indexOK,\n\t\t\t\t\t\t\t  NULL, 1, skey);\n\n\tif (HeapTupleIsValid(htup = systable_getnext(scan)))\n\t{\n\t\tForm_pg_opclass opclassform = (Form_pg_opclass) GETSTRUCT(htup);\n\n\t\topcentry->opcfamily = opclassform->opcfamily;\n\t\topcentry->opcintype = opclassform->opcintype;\n\t}\n\telse\n\t\telog(ERROR, \"could not find tuple for opclass %u\", operatorClassOid);\n\n\tsystable_endscan(scan);\n\theap_close(rel, AccessShareLock);\n\n\t/*\n\t * Scan pg_amproc to obtain support procs for the opclass.  We only fetch\n\t * the default ones (those with lefttype = righttype = opcintype).\n\t */\n\tif (numSupport > 0)\n\t{\n\t\tScanKeyInit(&skey[0],\n\t\t\t\t\tAnum_pg_amproc_amprocfamily,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(opcentry->opcfamily));\n\t\tScanKeyInit(&skey[1],\n\t\t\t\t\tAnum_pg_amproc_amproclefttype,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(opcentry->opcintype));\n\t\tScanKeyInit(&skey[2],\n\t\t\t\t\tAnum_pg_amproc_amprocrighttype,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(opcentry->opcintype));\n\t\trel = heap_open(AccessMethodProcedureRelationId, AccessShareLock);\n\t\tscan = systable_beginscan(rel, AccessMethodProcedureIndexId, indexOK,\n\t\t\t\t\t\t\t\t  NULL, 3, skey);\n\n\t\twhile (HeapTupleIsValid(htup = systable_getnext(scan)))\n\t\t{\n\t\t\tForm_pg_amproc amprocform = (Form_pg_amproc) GETSTRUCT(htup);\n\n\t\t\tif (amprocform->amprocnum <= 0 ||\n\t\t\t\t(StrategyNumber) amprocform->amprocnum > numSupport)\n\t\t\t\telog(ERROR, \"invalid amproc number %d for opclass %u\",\n\t\t\t\t\t amprocform->amprocnum, operatorClassOid);\n\n\t\t\topcentry->supportProcs[amprocform->amprocnum - 1] =\n\t\t\t\tamprocform->amproc;\n\t\t}\n\n\t\tsystable_endscan(scan);\n\t\theap_close(rel, AccessShareLock);\n\t}\n\n\topcentry->valid = true;\n\treturn opcentry;\n}"
  },
  {
    "function_name": "IndexSupportInitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "1514-1543",
    "snippet": "static void\nIndexSupportInitialize(oidvector *indclass,\n\t\t\t\t\t   RegProcedure *indexSupport,\n\t\t\t\t\t   Oid *opFamily,\n\t\t\t\t\t   Oid *opcInType,\n\t\t\t\t\t   StrategyNumber maxSupportNumber,\n\t\t\t\t\t   AttrNumber maxAttributeNumber)\n{\n\tint\t\t\tattIndex;\n\n\tfor (attIndex = 0; attIndex < maxAttributeNumber; attIndex++)\n\t{\n\t\tOpClassCacheEnt *opcentry;\n\n\t\tif (!OidIsValid(indclass->values[attIndex]))\n\t\t\telog(ERROR, \"bogus pg_index tuple\");\n\n\t\t/* look up the info for this opclass, using a cache */\n\t\topcentry = LookupOpclassInfo(indclass->values[attIndex],\n\t\t\t\t\t\t\t\t\t maxSupportNumber);\n\n\t\t/* copy cached data into relcache entry */\n\t\topFamily[attIndex] = opcentry->opcfamily;\n\t\topcInType[attIndex] = opcentry->opcintype;\n\t\tif (maxSupportNumber > 0)\n\t\t\tmemcpy(&indexSupport[attIndex * maxSupportNumber],\n\t\t\t\t   opcentry->supportProcs,\n\t\t\t\t   maxSupportNumber * sizeof(RegProcedure));\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
      "static void IndexSupportInitialize(oidvector *indclass,\n\t\t\t\t\t   RegProcedure *indexSupport,\n\t\t\t\t\t   Oid *opFamily,\n\t\t\t\t\t   Oid *opcInType,\n\t\t\t\t\t   StrategyNumber maxSupportNumber,\n\t\t\t\t\t   AttrNumber maxAttributeNumber);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&indexSupport[attIndex * maxSupportNumber]",
            "opcentry->supportProcs",
            "maxSupportNumber * sizeof(RegProcedure)"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LookupOpclassInfo",
          "args": [
            "indclass->values[attIndex]",
            "maxSupportNumber"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "LookupOpclassInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1565-1708",
          "snippet": "static OpClassCacheEnt *\nLookupOpclassInfo(Oid operatorClassOid,\n\t\t\t\t  StrategyNumber numSupport)\n{\n\tOpClassCacheEnt *opcentry;\n\tbool\t\tfound;\n\tRelation\trel;\n\tSysScanDesc scan;\n\tScanKeyData skey[3];\n\tHeapTuple\thtup;\n\tbool\t\tindexOK;\n\n\tif (OpClassCache == NULL)\n\t{\n\t\t/* First time through: initialize the opclass cache */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(OpClassCacheEnt);\n\t\tOpClassCache = hash_create(\"Operator class cache\", 64,\n\t\t\t\t\t\t\t\t   &ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\topcentry = (OpClassCacheEnt *) hash_search(OpClassCache,\n\t\t\t\t\t\t\t\t\t\t\t   (void *) &operatorClassOid,\n\t\t\t\t\t\t\t\t\t\t\t   HASH_ENTER, &found);\n\n\tif (!found)\n\t{\n\t\t/* Need to allocate memory for new entry */\n\t\topcentry->valid = false;\t/* until known OK */\n\t\topcentry->numSupport = numSupport;\n\n\t\tif (numSupport > 0)\n\t\t\topcentry->supportProcs = (RegProcedure *)\n\t\t\t\tMemoryContextAllocZero(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t   numSupport * sizeof(RegProcedure));\n\t\telse\n\t\t\topcentry->supportProcs = NULL;\n\t}\n\telse\n\t{\n\t\tAssert(numSupport == opcentry->numSupport);\n\t}\n\n\t/*\n\t * When testing for cache-flush hazards, we intentionally disable the\n\t * operator class cache and force reloading of the info on each call. This\n\t * is helpful because we want to test the case where a cache flush occurs\n\t * while we are loading the info, and it's very hard to provoke that if\n\t * this happens only once per opclass per backend.\n\t */\n#if defined(CLOBBER_CACHE_ALWAYS)\n\topcentry->valid = false;\n#endif\n\n\tif (opcentry->valid)\n\t\treturn opcentry;\n\n\t/*\n\t * Need to fill in new entry.\n\t *\n\t * To avoid infinite recursion during startup, force heap scans if we're\n\t * looking up info for the opclasses used by the indexes we would like to\n\t * reference here.\n\t */\n\tindexOK = criticalRelcachesBuilt ||\n\t\t(operatorClassOid != OID_BTREE_OPS_OID &&\n\t\t operatorClassOid != INT2_BTREE_OPS_OID);\n\n\t/*\n\t * We have to fetch the pg_opclass row to determine its opfamily and\n\t * opcintype, which are needed to look up related operators and functions.\n\t * It'd be convenient to use the syscache here, but that probably doesn't\n\t * work while bootstrapping.\n\t */\n\tScanKeyInit(&skey[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(operatorClassOid));\n\trel = heap_open(OperatorClassRelationId, AccessShareLock);\n\tscan = systable_beginscan(rel, OpclassOidIndexId, indexOK,\n\t\t\t\t\t\t\t  NULL, 1, skey);\n\n\tif (HeapTupleIsValid(htup = systable_getnext(scan)))\n\t{\n\t\tForm_pg_opclass opclassform = (Form_pg_opclass) GETSTRUCT(htup);\n\n\t\topcentry->opcfamily = opclassform->opcfamily;\n\t\topcentry->opcintype = opclassform->opcintype;\n\t}\n\telse\n\t\telog(ERROR, \"could not find tuple for opclass %u\", operatorClassOid);\n\n\tsystable_endscan(scan);\n\theap_close(rel, AccessShareLock);\n\n\t/*\n\t * Scan pg_amproc to obtain support procs for the opclass.  We only fetch\n\t * the default ones (those with lefttype = righttype = opcintype).\n\t */\n\tif (numSupport > 0)\n\t{\n\t\tScanKeyInit(&skey[0],\n\t\t\t\t\tAnum_pg_amproc_amprocfamily,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(opcentry->opcfamily));\n\t\tScanKeyInit(&skey[1],\n\t\t\t\t\tAnum_pg_amproc_amproclefttype,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(opcentry->opcintype));\n\t\tScanKeyInit(&skey[2],\n\t\t\t\t\tAnum_pg_amproc_amprocrighttype,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(opcentry->opcintype));\n\t\trel = heap_open(AccessMethodProcedureRelationId, AccessShareLock);\n\t\tscan = systable_beginscan(rel, AccessMethodProcedureIndexId, indexOK,\n\t\t\t\t\t\t\t\t  NULL, 3, skey);\n\n\t\twhile (HeapTupleIsValid(htup = systable_getnext(scan)))\n\t\t{\n\t\t\tForm_pg_amproc amprocform = (Form_pg_amproc) GETSTRUCT(htup);\n\n\t\t\tif (amprocform->amprocnum <= 0 ||\n\t\t\t\t(StrategyNumber) amprocform->amprocnum > numSupport)\n\t\t\t\telog(ERROR, \"invalid amproc number %d for opclass %u\",\n\t\t\t\t\t amprocform->amprocnum, operatorClassOid);\n\n\t\t\topcentry->supportProcs[amprocform->amprocnum - 1] =\n\t\t\t\tamprocform->amproc;\n\t\t}\n\n\t\tsystable_endscan(scan);\n\t\theap_close(rel, AccessShareLock);\n\t}\n\n\topcentry->valid = true;\n\treturn opcentry;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool\t\tcriticalRelcachesBuilt = false;",
            "static HTAB *OpClassCache = NULL;",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static OpClassCacheEnt *LookupOpclassInfo(Oid operatorClassOid,\n\t\t\t\t  StrategyNumber numSupport);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nbool\t\tcriticalRelcachesBuilt = false;\nstatic HTAB *OpClassCache = NULL;\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic OpClassCacheEnt *LookupOpclassInfo(Oid operatorClassOid,\n\t\t\t\t  StrategyNumber numSupport);\n\nstatic OpClassCacheEnt *\nLookupOpclassInfo(Oid operatorClassOid,\n\t\t\t\t  StrategyNumber numSupport)\n{\n\tOpClassCacheEnt *opcentry;\n\tbool\t\tfound;\n\tRelation\trel;\n\tSysScanDesc scan;\n\tScanKeyData skey[3];\n\tHeapTuple\thtup;\n\tbool\t\tindexOK;\n\n\tif (OpClassCache == NULL)\n\t{\n\t\t/* First time through: initialize the opclass cache */\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = sizeof(Oid);\n\t\tctl.entrysize = sizeof(OpClassCacheEnt);\n\t\tOpClassCache = hash_create(\"Operator class cache\", 64,\n\t\t\t\t\t\t\t\t   &ctl, HASH_ELEM | HASH_BLOBS);\n\n\t\t/* Also make sure CacheMemoryContext exists */\n\t\tif (!CacheMemoryContext)\n\t\t\tCreateCacheMemoryContext();\n\t}\n\n\topcentry = (OpClassCacheEnt *) hash_search(OpClassCache,\n\t\t\t\t\t\t\t\t\t\t\t   (void *) &operatorClassOid,\n\t\t\t\t\t\t\t\t\t\t\t   HASH_ENTER, &found);\n\n\tif (!found)\n\t{\n\t\t/* Need to allocate memory for new entry */\n\t\topcentry->valid = false;\t/* until known OK */\n\t\topcentry->numSupport = numSupport;\n\n\t\tif (numSupport > 0)\n\t\t\topcentry->supportProcs = (RegProcedure *)\n\t\t\t\tMemoryContextAllocZero(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t   numSupport * sizeof(RegProcedure));\n\t\telse\n\t\t\topcentry->supportProcs = NULL;\n\t}\n\telse\n\t{\n\t\tAssert(numSupport == opcentry->numSupport);\n\t}\n\n\t/*\n\t * When testing for cache-flush hazards, we intentionally disable the\n\t * operator class cache and force reloading of the info on each call. This\n\t * is helpful because we want to test the case where a cache flush occurs\n\t * while we are loading the info, and it's very hard to provoke that if\n\t * this happens only once per opclass per backend.\n\t */\n#if defined(CLOBBER_CACHE_ALWAYS)\n\topcentry->valid = false;\n#endif\n\n\tif (opcentry->valid)\n\t\treturn opcentry;\n\n\t/*\n\t * Need to fill in new entry.\n\t *\n\t * To avoid infinite recursion during startup, force heap scans if we're\n\t * looking up info for the opclasses used by the indexes we would like to\n\t * reference here.\n\t */\n\tindexOK = criticalRelcachesBuilt ||\n\t\t(operatorClassOid != OID_BTREE_OPS_OID &&\n\t\t operatorClassOid != INT2_BTREE_OPS_OID);\n\n\t/*\n\t * We have to fetch the pg_opclass row to determine its opfamily and\n\t * opcintype, which are needed to look up related operators and functions.\n\t * It'd be convenient to use the syscache here, but that probably doesn't\n\t * work while bootstrapping.\n\t */\n\tScanKeyInit(&skey[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(operatorClassOid));\n\trel = heap_open(OperatorClassRelationId, AccessShareLock);\n\tscan = systable_beginscan(rel, OpclassOidIndexId, indexOK,\n\t\t\t\t\t\t\t  NULL, 1, skey);\n\n\tif (HeapTupleIsValid(htup = systable_getnext(scan)))\n\t{\n\t\tForm_pg_opclass opclassform = (Form_pg_opclass) GETSTRUCT(htup);\n\n\t\topcentry->opcfamily = opclassform->opcfamily;\n\t\topcentry->opcintype = opclassform->opcintype;\n\t}\n\telse\n\t\telog(ERROR, \"could not find tuple for opclass %u\", operatorClassOid);\n\n\tsystable_endscan(scan);\n\theap_close(rel, AccessShareLock);\n\n\t/*\n\t * Scan pg_amproc to obtain support procs for the opclass.  We only fetch\n\t * the default ones (those with lefttype = righttype = opcintype).\n\t */\n\tif (numSupport > 0)\n\t{\n\t\tScanKeyInit(&skey[0],\n\t\t\t\t\tAnum_pg_amproc_amprocfamily,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(opcentry->opcfamily));\n\t\tScanKeyInit(&skey[1],\n\t\t\t\t\tAnum_pg_amproc_amproclefttype,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(opcentry->opcintype));\n\t\tScanKeyInit(&skey[2],\n\t\t\t\t\tAnum_pg_amproc_amprocrighttype,\n\t\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\t\tObjectIdGetDatum(opcentry->opcintype));\n\t\trel = heap_open(AccessMethodProcedureRelationId, AccessShareLock);\n\t\tscan = systable_beginscan(rel, AccessMethodProcedureIndexId, indexOK,\n\t\t\t\t\t\t\t\t  NULL, 3, skey);\n\n\t\twhile (HeapTupleIsValid(htup = systable_getnext(scan)))\n\t\t{\n\t\t\tForm_pg_amproc amprocform = (Form_pg_amproc) GETSTRUCT(htup);\n\n\t\t\tif (amprocform->amprocnum <= 0 ||\n\t\t\t\t(StrategyNumber) amprocform->amprocnum > numSupport)\n\t\t\t\telog(ERROR, \"invalid amproc number %d for opclass %u\",\n\t\t\t\t\t amprocform->amprocnum, operatorClassOid);\n\n\t\t\topcentry->supportProcs[amprocform->amprocnum - 1] =\n\t\t\t\tamprocform->amproc;\n\t\t}\n\n\t\tsystable_endscan(scan);\n\t\theap_close(rel, AccessShareLock);\n\t}\n\n\topcentry->valid = true;\n\treturn opcentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"bogus pg_index tuple\""
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "indclass->values[attIndex]"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void IndexSupportInitialize(oidvector *indclass,\n\t\t\t\t\t   RegProcedure *indexSupport,\n\t\t\t\t\t   Oid *opFamily,\n\t\t\t\t\t   Oid *opcInType,\n\t\t\t\t\t   StrategyNumber maxSupportNumber,\n\t\t\t\t\t   AttrNumber maxAttributeNumber);\n\nstatic void\nIndexSupportInitialize(oidvector *indclass,\n\t\t\t\t\t   RegProcedure *indexSupport,\n\t\t\t\t\t   Oid *opFamily,\n\t\t\t\t\t   Oid *opcInType,\n\t\t\t\t\t   StrategyNumber maxSupportNumber,\n\t\t\t\t\t   AttrNumber maxAttributeNumber)\n{\n\tint\t\t\tattIndex;\n\n\tfor (attIndex = 0; attIndex < maxAttributeNumber; attIndex++)\n\t{\n\t\tOpClassCacheEnt *opcentry;\n\n\t\tif (!OidIsValid(indclass->values[attIndex]))\n\t\t\telog(ERROR, \"bogus pg_index tuple\");\n\n\t\t/* look up the info for this opclass, using a cache */\n\t\topcentry = LookupOpclassInfo(indclass->values[attIndex],\n\t\t\t\t\t\t\t\t\t maxSupportNumber);\n\n\t\t/* copy cached data into relcache entry */\n\t\topFamily[attIndex] = opcentry->opcfamily;\n\t\topcInType[attIndex] = opcentry->opcintype;\n\t\tif (maxSupportNumber > 0)\n\t\t\tmemcpy(&indexSupport[attIndex * maxSupportNumber],\n\t\t\t\t   opcentry->supportProcs,\n\t\t\t\t   maxSupportNumber * sizeof(RegProcedure));\n\t}\n}"
  },
  {
    "function_name": "RelationInitIndexAccessInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "1346-1499",
    "snippet": "void\nRelationInitIndexAccessInfo(Relation relation)\n{\n\tHeapTuple\ttuple;\n\tForm_pg_am\taform;\n\tDatum\t\tindcollDatum;\n\tDatum\t\tindclassDatum;\n\tDatum\t\tindoptionDatum;\n\tbool\t\tisnull;\n\toidvector  *indcoll;\n\toidvector  *indclass;\n\tint2vector *indoption;\n\tMemoryContext indexcxt;\n\tMemoryContext oldcontext;\n\tint\t\t\tindnatts;\n\tint\t\t\tindnkeyatts;\n\tuint16\t\tamsupport;\n\n\t/*\n\t * Make a copy of the pg_index entry for the index.  Since pg_index\n\t * contains variable-length and possibly-null fields, we have to do this\n\t * honestly rather than just treating it as a Form_pg_index struct.\n\t */\n\ttuple = SearchSysCache1(INDEXRELID,\n\t\t\t\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"cache lookup failed for index %u\",\n\t\t\t RelationGetRelid(relation));\n\toldcontext = MemoryContextSwitchTo(CacheMemoryContext);\n\trelation->rd_indextuple = heap_copytuple(tuple);\n\trelation->rd_index = (Form_pg_index) GETSTRUCT(relation->rd_indextuple);\n\tMemoryContextSwitchTo(oldcontext);\n\tReleaseSysCache(tuple);\n\n\t/*\n\t * Look up the index's access method, save the OID of its handler function\n\t */\n\ttuple = SearchSysCache1(AMOID, ObjectIdGetDatum(relation->rd_rel->relam));\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"cache lookup failed for access method %u\",\n\t\t\t relation->rd_rel->relam);\n\taform = (Form_pg_am) GETSTRUCT(tuple);\n\trelation->rd_amhandler = aform->amhandler;\n\tReleaseSysCache(tuple);\n\n\tindnatts = RelationGetNumberOfAttributes(relation);\n\tif (indnatts != IndexRelationGetNumberOfAttributes(relation))\n\t\telog(ERROR, \"relnatts disagrees with indnatts for index %u\",\n\t\t\t RelationGetRelid(relation));\n\tindnkeyatts = IndexRelationGetNumberOfKeyAttributes(relation);\n\n\t/*\n\t * Make the private context to hold index access info.  The reason we need\n\t * a context, and not just a couple of pallocs, is so that we won't leak\n\t * any subsidiary info attached to fmgr lookup records.\n\t */\n\tindexcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t \"index info\",\n\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\trelation->rd_indexcxt = indexcxt;\n\tMemoryContextCopyAndSetIdentifier(indexcxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(relation));\n\n\t/*\n\t * Now we can fetch the index AM's API struct\n\t */\n\tInitIndexAmRoutine(relation);\n\n\t/*\n\t * Allocate arrays to hold data. Opclasses are not used for included\n\t * columns, so allocate them for indnkeyatts only.\n\t */\n\trelation->rd_opfamily = (Oid *)\n\t\tMemoryContextAllocZero(indexcxt, indnkeyatts * sizeof(Oid));\n\trelation->rd_opcintype = (Oid *)\n\t\tMemoryContextAllocZero(indexcxt, indnkeyatts * sizeof(Oid));\n\n\tamsupport = relation->rd_amroutine->amsupport;\n\tif (amsupport > 0)\n\t{\n\t\tint\t\t\tnsupport = indnatts * amsupport;\n\n\t\trelation->rd_support = (RegProcedure *)\n\t\t\tMemoryContextAllocZero(indexcxt, nsupport * sizeof(RegProcedure));\n\t\trelation->rd_supportinfo = (FmgrInfo *)\n\t\t\tMemoryContextAllocZero(indexcxt, nsupport * sizeof(FmgrInfo));\n\t}\n\telse\n\t{\n\t\trelation->rd_support = NULL;\n\t\trelation->rd_supportinfo = NULL;\n\t}\n\n\trelation->rd_indcollation = (Oid *)\n\t\tMemoryContextAllocZero(indexcxt, indnkeyatts * sizeof(Oid));\n\n\trelation->rd_indoption = (int16 *)\n\t\tMemoryContextAllocZero(indexcxt, indnkeyatts * sizeof(int16));\n\n\t/*\n\t * indcollation cannot be referenced directly through the C struct,\n\t * because it comes after the variable-width indkey field.  Must extract\n\t * the datum the hard way...\n\t */\n\tindcollDatum = fastgetattr(relation->rd_indextuple,\n\t\t\t\t\t\t\t   Anum_pg_index_indcollation,\n\t\t\t\t\t\t\t   GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t   &isnull);\n\tAssert(!isnull);\n\tindcoll = (oidvector *) DatumGetPointer(indcollDatum);\n\tmemcpy(relation->rd_indcollation, indcoll->values, indnkeyatts * sizeof(Oid));\n\n\t/*\n\t * indclass cannot be referenced directly through the C struct, because it\n\t * comes after the variable-width indkey field.  Must extract the datum\n\t * the hard way...\n\t */\n\tindclassDatum = fastgetattr(relation->rd_indextuple,\n\t\t\t\t\t\t\t\tAnum_pg_index_indclass,\n\t\t\t\t\t\t\t\tGetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t&isnull);\n\tAssert(!isnull);\n\tindclass = (oidvector *) DatumGetPointer(indclassDatum);\n\n\t/*\n\t * Fill the support procedure OID array, as well as the info about\n\t * opfamilies and opclass input types.  (aminfo and supportinfo are left\n\t * as zeroes, and are filled on-the-fly when used)\n\t */\n\tIndexSupportInitialize(indclass, relation->rd_support,\n\t\t\t\t\t\t   relation->rd_opfamily, relation->rd_opcintype,\n\t\t\t\t\t\t   amsupport, indnkeyatts);\n\n\t/*\n\t * Similarly extract indoption and copy it to the cache entry\n\t */\n\tindoptionDatum = fastgetattr(relation->rd_indextuple,\n\t\t\t\t\t\t\t\t Anum_pg_index_indoption,\n\t\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t &isnull);\n\tAssert(!isnull);\n\tindoption = (int2vector *) DatumGetPointer(indoptionDatum);\n\tmemcpy(relation->rd_indoption, indoption->values, indnkeyatts * sizeof(int16));\n\n\t/*\n\t * expressions, predicate, exclusion caches will be filled later\n\t */\n\trelation->rd_indexprs = NIL;\n\trelation->rd_indpred = NIL;\n\trelation->rd_exclops = NULL;\n\trelation->rd_exclprocs = NULL;\n\trelation->rd_exclstrats = NULL;\n\trelation->rd_amcache = NULL;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static TupleDesc GetPgIndexDescriptor(void);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static List *insert_ordered_oid(List *list, Oid datum);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "relation->rd_indoption",
            "indoption->values",
            "indnkeyatts * sizeof(int16)"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "indoptionDatum"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isnull"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fastgetattr",
          "args": [
            "relation->rd_indextuple",
            "Anum_pg_index_indoption",
            "GetPgIndexDescriptor()",
            "&isnull"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetPgIndexDescriptor",
          "args": [],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "GetPgIndexDescriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "3947-3959",
          "snippet": "static TupleDesc\nGetPgIndexDescriptor(void)\n{\n\tstatic TupleDesc pgindexdesc = NULL;\n\n\t/* Already done? */\n\tif (pgindexdesc == NULL)\n\t\tpgindexdesc = BuildHardcodedDescriptor(Natts_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   Desc_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   false);\n\n\treturn pgindexdesc;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const FormData_pg_attribute Desc_pg_index[Natts_pg_index] = {Schema_pg_index};",
            "static TupleDesc GetPgIndexDescriptor(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic const FormData_pg_attribute Desc_pg_index[Natts_pg_index] = {Schema_pg_index};\nstatic TupleDesc GetPgIndexDescriptor(void);\n\nstatic TupleDesc\nGetPgIndexDescriptor(void)\n{\n\tstatic TupleDesc pgindexdesc = NULL;\n\n\t/* Already done? */\n\tif (pgindexdesc == NULL)\n\t\tpgindexdesc = BuildHardcodedDescriptor(Natts_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   Desc_pg_index,\n\t\t\t\t\t\t\t\t\t\t\t   false);\n\n\treturn pgindexdesc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IndexSupportInitialize",
          "args": [
            "indclass",
            "relation->rd_support",
            "relation->rd_opfamily",
            "relation->rd_opcintype",
            "amsupport",
            "indnkeyatts"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "IndexSupportInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1514-1543",
          "snippet": "static void\nIndexSupportInitialize(oidvector *indclass,\n\t\t\t\t\t   RegProcedure *indexSupport,\n\t\t\t\t\t   Oid *opFamily,\n\t\t\t\t\t   Oid *opcInType,\n\t\t\t\t\t   StrategyNumber maxSupportNumber,\n\t\t\t\t\t   AttrNumber maxAttributeNumber)\n{\n\tint\t\t\tattIndex;\n\n\tfor (attIndex = 0; attIndex < maxAttributeNumber; attIndex++)\n\t{\n\t\tOpClassCacheEnt *opcentry;\n\n\t\tif (!OidIsValid(indclass->values[attIndex]))\n\t\t\telog(ERROR, \"bogus pg_index tuple\");\n\n\t\t/* look up the info for this opclass, using a cache */\n\t\topcentry = LookupOpclassInfo(indclass->values[attIndex],\n\t\t\t\t\t\t\t\t\t maxSupportNumber);\n\n\t\t/* copy cached data into relcache entry */\n\t\topFamily[attIndex] = opcentry->opcfamily;\n\t\topcInType[attIndex] = opcentry->opcintype;\n\t\tif (maxSupportNumber > 0)\n\t\t\tmemcpy(&indexSupport[attIndex * maxSupportNumber],\n\t\t\t\t   opcentry->supportProcs,\n\t\t\t\t   maxSupportNumber * sizeof(RegProcedure));\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static void IndexSupportInitialize(oidvector *indclass,\n\t\t\t\t\t   RegProcedure *indexSupport,\n\t\t\t\t\t   Oid *opFamily,\n\t\t\t\t\t   Oid *opcInType,\n\t\t\t\t\t   StrategyNumber maxSupportNumber,\n\t\t\t\t\t   AttrNumber maxAttributeNumber);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void IndexSupportInitialize(oidvector *indclass,\n\t\t\t\t\t   RegProcedure *indexSupport,\n\t\t\t\t\t   Oid *opFamily,\n\t\t\t\t\t   Oid *opcInType,\n\t\t\t\t\t   StrategyNumber maxSupportNumber,\n\t\t\t\t\t   AttrNumber maxAttributeNumber);\n\nstatic void\nIndexSupportInitialize(oidvector *indclass,\n\t\t\t\t\t   RegProcedure *indexSupport,\n\t\t\t\t\t   Oid *opFamily,\n\t\t\t\t\t   Oid *opcInType,\n\t\t\t\t\t   StrategyNumber maxSupportNumber,\n\t\t\t\t\t   AttrNumber maxAttributeNumber)\n{\n\tint\t\t\tattIndex;\n\n\tfor (attIndex = 0; attIndex < maxAttributeNumber; attIndex++)\n\t{\n\t\tOpClassCacheEnt *opcentry;\n\n\t\tif (!OidIsValid(indclass->values[attIndex]))\n\t\t\telog(ERROR, \"bogus pg_index tuple\");\n\n\t\t/* look up the info for this opclass, using a cache */\n\t\topcentry = LookupOpclassInfo(indclass->values[attIndex],\n\t\t\t\t\t\t\t\t\t maxSupportNumber);\n\n\t\t/* copy cached data into relcache entry */\n\t\topFamily[attIndex] = opcentry->opcfamily;\n\t\topcInType[attIndex] = opcentry->opcintype;\n\t\tif (maxSupportNumber > 0)\n\t\t\tmemcpy(&indexSupport[attIndex * maxSupportNumber],\n\t\t\t\t   opcentry->supportProcs,\n\t\t\t\t   maxSupportNumber * sizeof(RegProcedure));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "indclassDatum"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isnull"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fastgetattr",
          "args": [
            "relation->rd_indextuple",
            "Anum_pg_index_indclass",
            "GetPgIndexDescriptor()",
            "&isnull"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "relation->rd_indcollation",
            "indcoll->values",
            "indnkeyatts * sizeof(Oid)"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "indcollDatum"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isnull"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fastgetattr",
          "args": [
            "relation->rd_indextuple",
            "Anum_pg_index_indcollation",
            "GetPgIndexDescriptor()",
            "&isnull"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "indexcxt",
            "indnkeyatts * sizeof(int16)"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "InitIndexAmRoutine",
          "args": [
            "relation"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "InitIndexAmRoutine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1322-1341",
          "snippet": "static void\nInitIndexAmRoutine(Relation relation)\n{\n\tIndexAmRoutine *cached,\n\t\t\t   *tmp;\n\n\t/*\n\t * Call the amhandler in current, short-lived memory context, just in case\n\t * it leaks anything (it probably won't, but let's be paranoid).\n\t */\n\ttmp = GetIndexAmRoutine(relation->rd_amhandler);\n\n\t/* OK, now transfer the data into relation's rd_indexcxt. */\n\tcached = (IndexAmRoutine *) MemoryContextAlloc(relation->rd_indexcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(IndexAmRoutine));\n\tmemcpy(cached, tmp, sizeof(IndexAmRoutine));\n\trelation->rd_amroutine = cached;\n\n\tpfree(tmp);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nInitIndexAmRoutine(Relation relation)\n{\n\tIndexAmRoutine *cached,\n\t\t\t   *tmp;\n\n\t/*\n\t * Call the amhandler in current, short-lived memory context, just in case\n\t * it leaks anything (it probably won't, but let's be paranoid).\n\t */\n\ttmp = GetIndexAmRoutine(relation->rd_amhandler);\n\n\t/* OK, now transfer the data into relation's rd_indexcxt. */\n\tcached = (IndexAmRoutine *) MemoryContextAlloc(relation->rd_indexcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(IndexAmRoutine));\n\tmemcpy(cached, tmp, sizeof(IndexAmRoutine));\n\trelation->rd_amroutine = cached;\n\n\tpfree(tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextCopyAndSetIdentifier",
          "args": [
            "indexcxt",
            "RelationGetRelationName(relation)"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "relation"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "CacheMemoryContext",
            "\"index info\"",
            "ALLOCSET_SMALL_SIZES"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IndexRelationGetNumberOfKeyAttributes",
          "args": [
            "relation"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"relnatts disagrees with indnatts for index %u\"",
            "RelationGetRelid(relation)"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IndexRelationGetNumberOfAttributes",
          "args": [
            "relation"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetNumberOfAttributes",
          "args": [
            "relation"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "tuple"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "tuple"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "AMOID",
            "ObjectIdGetDatum(relation->rd_rel->relam)"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "relation->rd_rel->relam"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "relation->rd_indextuple"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_copytuple",
          "args": [
            "tuple"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "tuple"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "RelationGetRelid(relation)"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic TupleDesc GetPgIndexDescriptor(void);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic List *insert_ordered_oid(List *list, Oid datum);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationInitIndexAccessInfo(Relation relation)\n{\n\tHeapTuple\ttuple;\n\tForm_pg_am\taform;\n\tDatum\t\tindcollDatum;\n\tDatum\t\tindclassDatum;\n\tDatum\t\tindoptionDatum;\n\tbool\t\tisnull;\n\toidvector  *indcoll;\n\toidvector  *indclass;\n\tint2vector *indoption;\n\tMemoryContext indexcxt;\n\tMemoryContext oldcontext;\n\tint\t\t\tindnatts;\n\tint\t\t\tindnkeyatts;\n\tuint16\t\tamsupport;\n\n\t/*\n\t * Make a copy of the pg_index entry for the index.  Since pg_index\n\t * contains variable-length and possibly-null fields, we have to do this\n\t * honestly rather than just treating it as a Form_pg_index struct.\n\t */\n\ttuple = SearchSysCache1(INDEXRELID,\n\t\t\t\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"cache lookup failed for index %u\",\n\t\t\t RelationGetRelid(relation));\n\toldcontext = MemoryContextSwitchTo(CacheMemoryContext);\n\trelation->rd_indextuple = heap_copytuple(tuple);\n\trelation->rd_index = (Form_pg_index) GETSTRUCT(relation->rd_indextuple);\n\tMemoryContextSwitchTo(oldcontext);\n\tReleaseSysCache(tuple);\n\n\t/*\n\t * Look up the index's access method, save the OID of its handler function\n\t */\n\ttuple = SearchSysCache1(AMOID, ObjectIdGetDatum(relation->rd_rel->relam));\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"cache lookup failed for access method %u\",\n\t\t\t relation->rd_rel->relam);\n\taform = (Form_pg_am) GETSTRUCT(tuple);\n\trelation->rd_amhandler = aform->amhandler;\n\tReleaseSysCache(tuple);\n\n\tindnatts = RelationGetNumberOfAttributes(relation);\n\tif (indnatts != IndexRelationGetNumberOfAttributes(relation))\n\t\telog(ERROR, \"relnatts disagrees with indnatts for index %u\",\n\t\t\t RelationGetRelid(relation));\n\tindnkeyatts = IndexRelationGetNumberOfKeyAttributes(relation);\n\n\t/*\n\t * Make the private context to hold index access info.  The reason we need\n\t * a context, and not just a couple of pallocs, is so that we won't leak\n\t * any subsidiary info attached to fmgr lookup records.\n\t */\n\tindexcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t \"index info\",\n\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\trelation->rd_indexcxt = indexcxt;\n\tMemoryContextCopyAndSetIdentifier(indexcxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(relation));\n\n\t/*\n\t * Now we can fetch the index AM's API struct\n\t */\n\tInitIndexAmRoutine(relation);\n\n\t/*\n\t * Allocate arrays to hold data. Opclasses are not used for included\n\t * columns, so allocate them for indnkeyatts only.\n\t */\n\trelation->rd_opfamily = (Oid *)\n\t\tMemoryContextAllocZero(indexcxt, indnkeyatts * sizeof(Oid));\n\trelation->rd_opcintype = (Oid *)\n\t\tMemoryContextAllocZero(indexcxt, indnkeyatts * sizeof(Oid));\n\n\tamsupport = relation->rd_amroutine->amsupport;\n\tif (amsupport > 0)\n\t{\n\t\tint\t\t\tnsupport = indnatts * amsupport;\n\n\t\trelation->rd_support = (RegProcedure *)\n\t\t\tMemoryContextAllocZero(indexcxt, nsupport * sizeof(RegProcedure));\n\t\trelation->rd_supportinfo = (FmgrInfo *)\n\t\t\tMemoryContextAllocZero(indexcxt, nsupport * sizeof(FmgrInfo));\n\t}\n\telse\n\t{\n\t\trelation->rd_support = NULL;\n\t\trelation->rd_supportinfo = NULL;\n\t}\n\n\trelation->rd_indcollation = (Oid *)\n\t\tMemoryContextAllocZero(indexcxt, indnkeyatts * sizeof(Oid));\n\n\trelation->rd_indoption = (int16 *)\n\t\tMemoryContextAllocZero(indexcxt, indnkeyatts * sizeof(int16));\n\n\t/*\n\t * indcollation cannot be referenced directly through the C struct,\n\t * because it comes after the variable-width indkey field.  Must extract\n\t * the datum the hard way...\n\t */\n\tindcollDatum = fastgetattr(relation->rd_indextuple,\n\t\t\t\t\t\t\t   Anum_pg_index_indcollation,\n\t\t\t\t\t\t\t   GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t   &isnull);\n\tAssert(!isnull);\n\tindcoll = (oidvector *) DatumGetPointer(indcollDatum);\n\tmemcpy(relation->rd_indcollation, indcoll->values, indnkeyatts * sizeof(Oid));\n\n\t/*\n\t * indclass cannot be referenced directly through the C struct, because it\n\t * comes after the variable-width indkey field.  Must extract the datum\n\t * the hard way...\n\t */\n\tindclassDatum = fastgetattr(relation->rd_indextuple,\n\t\t\t\t\t\t\t\tAnum_pg_index_indclass,\n\t\t\t\t\t\t\t\tGetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t&isnull);\n\tAssert(!isnull);\n\tindclass = (oidvector *) DatumGetPointer(indclassDatum);\n\n\t/*\n\t * Fill the support procedure OID array, as well as the info about\n\t * opfamilies and opclass input types.  (aminfo and supportinfo are left\n\t * as zeroes, and are filled on-the-fly when used)\n\t */\n\tIndexSupportInitialize(indclass, relation->rd_support,\n\t\t\t\t\t\t   relation->rd_opfamily, relation->rd_opcintype,\n\t\t\t\t\t\t   amsupport, indnkeyatts);\n\n\t/*\n\t * Similarly extract indoption and copy it to the cache entry\n\t */\n\tindoptionDatum = fastgetattr(relation->rd_indextuple,\n\t\t\t\t\t\t\t\t Anum_pg_index_indoption,\n\t\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t &isnull);\n\tAssert(!isnull);\n\tindoption = (int2vector *) DatumGetPointer(indoptionDatum);\n\tmemcpy(relation->rd_indoption, indoption->values, indnkeyatts * sizeof(int16));\n\n\t/*\n\t * expressions, predicate, exclusion caches will be filled later\n\t */\n\trelation->rd_indexprs = NIL;\n\trelation->rd_indpred = NIL;\n\trelation->rd_exclops = NULL;\n\trelation->rd_exclprocs = NULL;\n\trelation->rd_exclstrats = NULL;\n\trelation->rd_amcache = NULL;\n}"
  },
  {
    "function_name": "InitIndexAmRoutine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "1322-1341",
    "snippet": "static void\nInitIndexAmRoutine(Relation relation)\n{\n\tIndexAmRoutine *cached,\n\t\t\t   *tmp;\n\n\t/*\n\t * Call the amhandler in current, short-lived memory context, just in case\n\t * it leaks anything (it probably won't, but let's be paranoid).\n\t */\n\ttmp = GetIndexAmRoutine(relation->rd_amhandler);\n\n\t/* OK, now transfer the data into relation's rd_indexcxt. */\n\tcached = (IndexAmRoutine *) MemoryContextAlloc(relation->rd_indexcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(IndexAmRoutine));\n\tmemcpy(cached, tmp, sizeof(IndexAmRoutine));\n\trelation->rd_amroutine = cached;\n\n\tpfree(tmp);\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "tmp"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cached",
            "tmp",
            "sizeof(IndexAmRoutine)"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "relation->rd_indexcxt",
            "sizeof(IndexAmRoutine)"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetIndexAmRoutine",
          "args": [
            "relation->rd_amhandler"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nInitIndexAmRoutine(Relation relation)\n{\n\tIndexAmRoutine *cached,\n\t\t\t   *tmp;\n\n\t/*\n\t * Call the amhandler in current, short-lived memory context, just in case\n\t * it leaks anything (it probably won't, but let's be paranoid).\n\t */\n\ttmp = GetIndexAmRoutine(relation->rd_amhandler);\n\n\t/* OK, now transfer the data into relation's rd_indexcxt. */\n\tcached = (IndexAmRoutine *) MemoryContextAlloc(relation->rd_indexcxt,\n\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(IndexAmRoutine));\n\tmemcpy(cached, tmp, sizeof(IndexAmRoutine));\n\trelation->rd_amroutine = cached;\n\n\tpfree(tmp);\n}"
  },
  {
    "function_name": "RelationInitPhysicalAddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "1259-1315",
    "snippet": "static void\nRelationInitPhysicalAddr(Relation relation)\n{\n\tif (relation->rd_rel->reltablespace)\n\t\trelation->rd_node.spcNode = relation->rd_rel->reltablespace;\n\telse\n\t\trelation->rd_node.spcNode = MyDatabaseTableSpace;\n\tif (relation->rd_node.spcNode == GLOBALTABLESPACE_OID)\n\t\trelation->rd_node.dbNode = InvalidOid;\n\telse\n\t\trelation->rd_node.dbNode = MyDatabaseId;\n\n\tif (relation->rd_rel->relfilenode)\n\t{\n\t\t/*\n\t\t * Even if we are using a decoding snapshot that doesn't represent the\n\t\t * current state of the catalog we need to make sure the filenode\n\t\t * points to the current file since the older file will be gone (or\n\t\t * truncated). The new file will still contain older rows so lookups\n\t\t * in them will work correctly. This wouldn't work correctly if\n\t\t * rewrites were allowed to change the schema in an incompatible way,\n\t\t * but those are prevented both on catalog tables and on user tables\n\t\t * declared as additional catalog tables.\n\t\t */\n\t\tif (HistoricSnapshotActive()\n\t\t\t&& RelationIsAccessibleInLogicalDecoding(relation)\n\t\t\t&& IsTransactionState())\n\t\t{\n\t\t\tHeapTuple\tphys_tuple;\n\t\t\tForm_pg_class physrel;\n\n\t\t\tphys_tuple = ScanPgRelation(RelationGetRelid(relation),\n\t\t\t\t\t\t\t\t\t\tRelationGetRelid(relation) != ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t\ttrue);\n\t\t\tif (!HeapTupleIsValid(phys_tuple))\n\t\t\t\telog(ERROR, \"could not find pg_class entry for %u\",\n\t\t\t\t\t RelationGetRelid(relation));\n\t\t\tphysrel = (Form_pg_class) GETSTRUCT(phys_tuple);\n\n\t\t\trelation->rd_rel->reltablespace = physrel->reltablespace;\n\t\t\trelation->rd_rel->relfilenode = physrel->relfilenode;\n\t\t\theap_freetuple(phys_tuple);\n\t\t}\n\n\t\trelation->rd_node.relNode = relation->rd_rel->relfilenode;\n\t}\n\telse\n\t{\n\t\t/* Consult the relation mapper */\n\t\trelation->rd_node.relNode =\n\t\t\tRelationMapOidToFilenode(relation->rd_id,\n\t\t\t\t\t\t\t\t\t relation->rd_rel->relisshared);\n\t\tif (!OidIsValid(relation->rd_node.relNode))\n\t\t\telog(ERROR, \"could not find relation mapping for relation \\\"%s\\\", OID %u\",\n\t\t\t\t RelationGetRelationName(relation), relation->rd_id);\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"could not find relation mapping for relation \\\"%s\\\", OID %u\"",
            "RelationGetRelationName(relation)",
            "relation->rd_id"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "relation"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "relation->rd_node.relNode"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationMapOidToFilenode",
          "args": [
            "relation->rd_id",
            "relation->rd_rel->relisshared"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "RelationMapOidToFilenode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relmapper.c",
          "lines": "145-184",
          "snippet": "Oid\nRelationMapOidToFilenode(Oid relationId, bool shared)\n{\n\tconst RelMapFile *map;\n\tint32\t\ti;\n\n\t/* If there are active updates, believe those over the main maps */\n\tif (shared)\n\t{\n\t\tmap = &active_shared_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t\tmap = &shared_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t}\n\telse\n\t{\n\t\tmap = &active_local_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t\tmap = &local_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t}\n\n\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/relmapper.h\"",
            "#include \"utils/inval.h\"",
            "#include \"storage/lwlock.h\"",
            "#include \"storage/fd.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xloginsert.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RelMapFile shared_map;",
            "static RelMapFile local_map;",
            "static RelMapFile active_shared_updates;",
            "static RelMapFile active_local_updates;",
            "static void load_relmap_file(bool shared);",
            "static void perform_relmap_update(bool shared, const RelMapFile *updates);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relmapper.h\"\n#include \"utils/inval.h\"\n#include \"storage/lwlock.h\"\n#include \"storage/fd.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xloginsert.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic RelMapFile shared_map;\nstatic RelMapFile local_map;\nstatic RelMapFile active_shared_updates;\nstatic RelMapFile active_local_updates;\nstatic void load_relmap_file(bool shared);\nstatic void perform_relmap_update(bool shared, const RelMapFile *updates);\n\nOid\nRelationMapOidToFilenode(Oid relationId, bool shared)\n{\n\tconst RelMapFile *map;\n\tint32\t\ti;\n\n\t/* If there are active updates, believe those over the main maps */\n\tif (shared)\n\t{\n\t\tmap = &active_shared_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t\tmap = &shared_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t}\n\telse\n\t{\n\t\tmap = &active_local_updates;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t\tmap = &local_map;\n\t\tfor (i = 0; i < map->num_mappings; i++)\n\t\t{\n\t\t\tif (relationId == map->mappings[i].mapoid)\n\t\t\t\treturn map->mappings[i].mapfilenode;\n\t\t}\n\t}\n\n\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_freetuple",
          "args": [
            "phys_tuple"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "phys_tuple"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "phys_tuple"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanPgRelation",
          "args": [
            "RelationGetRelid(relation)",
            "RelationGetRelid(relation) != ClassOidIndexId",
            "true"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "ScanPgRelation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "308-370",
          "snippet": "static HeapTuple\nScanPgRelation(Oid targetRelId, bool indexOK, bool force_non_historic)\n{\n\tHeapTuple\tpg_class_tuple;\n\tRelation\tpg_class_desc;\n\tSysScanDesc pg_class_scan;\n\tScanKeyData key[1];\n\tSnapshot\tsnapshot;\n\n\t/*\n\t * If something goes wrong during backend startup, we might find ourselves\n\t * trying to read pg_class before we've selected a database.  That ain't\n\t * gonna work, so bail out with a useful error message.  If this happens,\n\t * it probably means a relcache entry that needs to be nailed isn't.\n\t */\n\tif (!OidIsValid(MyDatabaseId))\n\t\telog(FATAL, \"cannot read pg_class without having selected a database\");\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(targetRelId));\n\n\t/*\n\t * Open pg_class and fetch a tuple.  Force heap scan if we haven't yet\n\t * built the critical relcache entries (this includes initdb and startup\n\t * without a pg_internal.init file).  The caller can also force a heap\n\t * scan by setting indexOK == false.\n\t */\n\tpg_class_desc = heap_open(RelationRelationId, AccessShareLock);\n\n\t/*\n\t * The caller might need a tuple that's newer than the one the historic\n\t * snapshot; currently the only case requiring to do so is looking up the\n\t * relfilenode of non mapped system relations during decoding.\n\t */\n\tif (force_non_historic)\n\t\tsnapshot = GetNonHistoricCatalogSnapshot(RelationRelationId);\n\telse\n\t\tsnapshot = GetCatalogSnapshot(RelationRelationId);\n\n\tpg_class_scan = systable_beginscan(pg_class_desc, ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t   indexOK && criticalRelcachesBuilt,\n\t\t\t\t\t\t\t\t\t   snapshot,\n\t\t\t\t\t\t\t\t\t   1, key);\n\n\tpg_class_tuple = systable_getnext(pg_class_scan);\n\n\t/*\n\t * Must copy tuple before releasing buffer.\n\t */\n\tif (HeapTupleIsValid(pg_class_tuple))\n\t\tpg_class_tuple = heap_copytuple(pg_class_tuple);\n\n\t/* all done */\n\tsystable_endscan(pg_class_scan);\n\theap_close(pg_class_desc, AccessShareLock);\n\n\treturn pg_class_tuple;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool\t\tcriticalRelcachesBuilt = false;",
            "static HeapTuple ScanPgRelation(Oid targetRelId, bool indexOK, bool force_non_historic);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nbool\t\tcriticalRelcachesBuilt = false;\nstatic HeapTuple ScanPgRelation(Oid targetRelId, bool indexOK, bool force_non_historic);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\n\nstatic HeapTuple\nScanPgRelation(Oid targetRelId, bool indexOK, bool force_non_historic)\n{\n\tHeapTuple\tpg_class_tuple;\n\tRelation\tpg_class_desc;\n\tSysScanDesc pg_class_scan;\n\tScanKeyData key[1];\n\tSnapshot\tsnapshot;\n\n\t/*\n\t * If something goes wrong during backend startup, we might find ourselves\n\t * trying to read pg_class before we've selected a database.  That ain't\n\t * gonna work, so bail out with a useful error message.  If this happens,\n\t * it probably means a relcache entry that needs to be nailed isn't.\n\t */\n\tif (!OidIsValid(MyDatabaseId))\n\t\telog(FATAL, \"cannot read pg_class without having selected a database\");\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(targetRelId));\n\n\t/*\n\t * Open pg_class and fetch a tuple.  Force heap scan if we haven't yet\n\t * built the critical relcache entries (this includes initdb and startup\n\t * without a pg_internal.init file).  The caller can also force a heap\n\t * scan by setting indexOK == false.\n\t */\n\tpg_class_desc = heap_open(RelationRelationId, AccessShareLock);\n\n\t/*\n\t * The caller might need a tuple that's newer than the one the historic\n\t * snapshot; currently the only case requiring to do so is looking up the\n\t * relfilenode of non mapped system relations during decoding.\n\t */\n\tif (force_non_historic)\n\t\tsnapshot = GetNonHistoricCatalogSnapshot(RelationRelationId);\n\telse\n\t\tsnapshot = GetCatalogSnapshot(RelationRelationId);\n\n\tpg_class_scan = systable_beginscan(pg_class_desc, ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t   indexOK && criticalRelcachesBuilt,\n\t\t\t\t\t\t\t\t\t   snapshot,\n\t\t\t\t\t\t\t\t\t   1, key);\n\n\tpg_class_tuple = systable_getnext(pg_class_scan);\n\n\t/*\n\t * Must copy tuple before releasing buffer.\n\t */\n\tif (HeapTupleIsValid(pg_class_tuple))\n\t\tpg_class_tuple = heap_copytuple(pg_class_tuple);\n\n\t/* all done */\n\tsystable_endscan(pg_class_scan);\n\theap_close(pg_class_desc, AccessShareLock);\n\n\treturn pg_class_tuple;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsTransactionState",
          "args": [],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationIsAccessibleInLogicalDecoding",
          "args": [
            "relation"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HistoricSnapshotActive",
          "args": [],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "HistoricSnapshotActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "2023-2027",
          "snippet": "bool\nHistoricSnapshotActive(void)\n{\n\treturn HistoricSnapshot != NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot HistoricSnapshot = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot HistoricSnapshot = NULL;\n\nbool\nHistoricSnapshotActive(void)\n{\n\treturn HistoricSnapshot != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationInitPhysicalAddr(Relation relation)\n{\n\tif (relation->rd_rel->reltablespace)\n\t\trelation->rd_node.spcNode = relation->rd_rel->reltablespace;\n\telse\n\t\trelation->rd_node.spcNode = MyDatabaseTableSpace;\n\tif (relation->rd_node.spcNode == GLOBALTABLESPACE_OID)\n\t\trelation->rd_node.dbNode = InvalidOid;\n\telse\n\t\trelation->rd_node.dbNode = MyDatabaseId;\n\n\tif (relation->rd_rel->relfilenode)\n\t{\n\t\t/*\n\t\t * Even if we are using a decoding snapshot that doesn't represent the\n\t\t * current state of the catalog we need to make sure the filenode\n\t\t * points to the current file since the older file will be gone (or\n\t\t * truncated). The new file will still contain older rows so lookups\n\t\t * in them will work correctly. This wouldn't work correctly if\n\t\t * rewrites were allowed to change the schema in an incompatible way,\n\t\t * but those are prevented both on catalog tables and on user tables\n\t\t * declared as additional catalog tables.\n\t\t */\n\t\tif (HistoricSnapshotActive()\n\t\t\t&& RelationIsAccessibleInLogicalDecoding(relation)\n\t\t\t&& IsTransactionState())\n\t\t{\n\t\t\tHeapTuple\tphys_tuple;\n\t\t\tForm_pg_class physrel;\n\n\t\t\tphys_tuple = ScanPgRelation(RelationGetRelid(relation),\n\t\t\t\t\t\t\t\t\t\tRelationGetRelid(relation) != ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t\ttrue);\n\t\t\tif (!HeapTupleIsValid(phys_tuple))\n\t\t\t\telog(ERROR, \"could not find pg_class entry for %u\",\n\t\t\t\t\t RelationGetRelid(relation));\n\t\t\tphysrel = (Form_pg_class) GETSTRUCT(phys_tuple);\n\n\t\t\trelation->rd_rel->reltablespace = physrel->reltablespace;\n\t\t\trelation->rd_rel->relfilenode = physrel->relfilenode;\n\t\t\theap_freetuple(phys_tuple);\n\t\t}\n\n\t\trelation->rd_node.relNode = relation->rd_rel->relfilenode;\n\t}\n\telse\n\t{\n\t\t/* Consult the relation mapper */\n\t\trelation->rd_node.relNode =\n\t\t\tRelationMapOidToFilenode(relation->rd_id,\n\t\t\t\t\t\t\t\t\t relation->rd_rel->relisshared);\n\t\tif (!OidIsValid(relation->rd_node.relNode))\n\t\t\telog(ERROR, \"could not find relation mapping for relation \\\"%s\\\", OID %u\",\n\t\t\t\t RelationGetRelationName(relation), relation->rd_id);\n\t}\n}"
  },
  {
    "function_name": "RelationBuildDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "1070-1250",
    "snippet": "static Relation\nRelationBuildDesc(Oid targetRelId, bool insertIt)\n{\n\tRelation\trelation;\n\tOid\t\t\trelid;\n\tHeapTuple\tpg_class_tuple;\n\tForm_pg_class relp;\n\n\t/*\n\t * find the tuple in pg_class corresponding to the given relation id\n\t */\n\tpg_class_tuple = ScanPgRelation(targetRelId, true, false);\n\n\t/*\n\t * if no such tuple exists, return NULL\n\t */\n\tif (!HeapTupleIsValid(pg_class_tuple))\n\t\treturn NULL;\n\n\t/*\n\t * get information from the pg_class_tuple\n\t */\n\trelid = HeapTupleGetOid(pg_class_tuple);\n\trelp = (Form_pg_class) GETSTRUCT(pg_class_tuple);\n\tAssert(relid == targetRelId);\n\n\t/*\n\t * allocate storage for the relation descriptor, and copy pg_class_tuple\n\t * to relation->rd_rel.\n\t */\n\trelation = AllocateRelationDesc(relp);\n\n\t/*\n\t * initialize the relation's relation id (relation->rd_id)\n\t */\n\tRelationGetRelid(relation) = relid;\n\n\t/*\n\t * normal relations are not nailed into the cache; nor can a pre-existing\n\t * relation be new.  It could be temp though.  (Actually, it could be new\n\t * too, but it's okay to forget that fact if forced to flush the entry.)\n\t */\n\trelation->rd_refcnt = 0;\n\trelation->rd_isnailed = false;\n\trelation->rd_createSubid = InvalidSubTransactionId;\n\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\tswitch (relation->rd_rel->relpersistence)\n\t{\n\t\tcase RELPERSISTENCE_UNLOGGED:\n\t\tcase RELPERSISTENCE_PERMANENT:\n\t\t\trelation->rd_backend = InvalidBackendId;\n\t\t\trelation->rd_islocaltemp = false;\n\t\t\tbreak;\n\t\tcase RELPERSISTENCE_TEMP:\n\t\t\tif (isTempOrTempToastNamespace(relation->rd_rel->relnamespace))\n\t\t\t{\n\t\t\t\trelation->rd_backend = BackendIdForTempRelations();\n\t\t\t\trelation->rd_islocaltemp = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If it's a temp table, but not one of ours, we have to use\n\t\t\t\t * the slow, grotty method to figure out the owning backend.\n\t\t\t\t *\n\t\t\t\t * Note: it's possible that rd_backend gets set to MyBackendId\n\t\t\t\t * here, in case we are looking at a pg_class entry left over\n\t\t\t\t * from a crashed backend that coincidentally had the same\n\t\t\t\t * BackendId we're using.  We should *not* consider such a\n\t\t\t\t * table to be \"ours\"; this is why we need the separate\n\t\t\t\t * rd_islocaltemp flag.  The pg_class entry will get flushed\n\t\t\t\t * if/when we clean out the corresponding temp table namespace\n\t\t\t\t * in preparation for using it.\n\t\t\t\t */\n\t\t\t\trelation->rd_backend =\n\t\t\t\t\tGetTempNamespaceBackendId(relation->rd_rel->relnamespace);\n\t\t\t\tAssert(relation->rd_backend != InvalidBackendId);\n\t\t\t\trelation->rd_islocaltemp = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid relpersistence: %c\",\n\t\t\t\t relation->rd_rel->relpersistence);\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * initialize the tuple descriptor (relation->rd_att).\n\t */\n\tRelationBuildTupleDesc(relation);\n\n\t/*\n\t * Fetch rules and triggers that affect this relation\n\t */\n\tif (relation->rd_rel->relhasrules)\n\t\tRelationBuildRuleLock(relation);\n\telse\n\t{\n\t\trelation->rd_rules = NULL;\n\t\trelation->rd_rulescxt = NULL;\n\t}\n\n\tif (relation->rd_rel->relhastriggers)\n\t\tRelationBuildTriggers(relation);\n\telse\n\t\trelation->trigdesc = NULL;\n\n\tif (relation->rd_rel->relrowsecurity)\n\t\tRelationBuildRowSecurity(relation);\n\telse\n\t\trelation->rd_rsdesc = NULL;\n\n\t/* foreign key data is not loaded till asked for */\n\trelation->rd_fkeylist = NIL;\n\trelation->rd_fkeyvalid = false;\n\n\t/* if a partitioned table, initialize key and partition descriptor info */\n\tif (relation->rd_rel->relkind == RELKIND_PARTITIONED_TABLE)\n\t{\n\t\tRelationBuildPartitionKey(relation);\n\t\tRelationBuildPartitionDesc(relation);\n\t}\n\telse\n\t{\n\t\trelation->rd_partkey = NULL;\n\t\trelation->rd_partkeycxt = NULL;\n\t\trelation->rd_partdesc = NULL;\n\t\trelation->rd_pdcxt = NULL;\n\t}\n\t/* ... but partcheck is not loaded till asked for */\n\trelation->rd_partcheck = NIL;\n\trelation->rd_partcheckvalid = false;\n\trelation->rd_partcheckcxt = NULL;\n\n\t/*\n\t * if it's an index, initialize index-related information\n\t */\n\tif (OidIsValid(relation->rd_rel->relam))\n\t\tRelationInitIndexAccessInfo(relation);\n\n\t/* extract reloptions if any */\n\tRelationParseRelOptions(relation, pg_class_tuple);\n\n\t/*\n\t * initialize the relation lock manager information\n\t */\n\tRelationInitLockInfo(relation); /* see lmgr.c */\n\n\t/*\n\t * initialize physical addressing information for the relation\n\t */\n\tRelationInitPhysicalAddr(relation);\n\n\t/* make sure relation is marked as having no open file yet */\n\trelation->rd_smgr = NULL;\n\n\t/*\n\t * now we can free the memory allocated for pg_class_tuple\n\t */\n\theap_freetuple(pg_class_tuple);\n\n\t/*\n\t * Insert newly created relation into relcache hash table, if requested.\n\t *\n\t * There is one scenario in which we might find a hashtable entry already\n\t * present, even though our caller failed to find it: if the relation is a\n\t * system catalog or index that's used during relcache load, we might have\n\t * recursively created the same relcache entry during the preceding steps.\n\t * So allow RelationCacheInsert to delete any already-present relcache\n\t * entry for the same OID.  The already-present entry should have refcount\n\t * zero (else somebody forgot to close it); in the event that it doesn't,\n\t * we'll elog a WARNING and leak the already-present entry.\n\t */\n\tif (insertIt)\n\t\tRelationCacheInsert(relation, true);\n\n\t/* It's fully valid */\n\trelation->rd_isvalid = true;\n\n\treturn relation;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static Relation AllocateRelationDesc(Form_pg_class relp);",
      "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static Relation RelationBuildDesc(Oid targetRelId, bool insertIt);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RelationCacheInsert",
          "args": [
            "relation",
            "true"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_freetuple",
          "args": [
            "pg_class_tuple"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationInitPhysicalAddr",
          "args": [
            "relation"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "RelationInitPhysicalAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1259-1315",
          "snippet": "static void\nRelationInitPhysicalAddr(Relation relation)\n{\n\tif (relation->rd_rel->reltablespace)\n\t\trelation->rd_node.spcNode = relation->rd_rel->reltablespace;\n\telse\n\t\trelation->rd_node.spcNode = MyDatabaseTableSpace;\n\tif (relation->rd_node.spcNode == GLOBALTABLESPACE_OID)\n\t\trelation->rd_node.dbNode = InvalidOid;\n\telse\n\t\trelation->rd_node.dbNode = MyDatabaseId;\n\n\tif (relation->rd_rel->relfilenode)\n\t{\n\t\t/*\n\t\t * Even if we are using a decoding snapshot that doesn't represent the\n\t\t * current state of the catalog we need to make sure the filenode\n\t\t * points to the current file since the older file will be gone (or\n\t\t * truncated). The new file will still contain older rows so lookups\n\t\t * in them will work correctly. This wouldn't work correctly if\n\t\t * rewrites were allowed to change the schema in an incompatible way,\n\t\t * but those are prevented both on catalog tables and on user tables\n\t\t * declared as additional catalog tables.\n\t\t */\n\t\tif (HistoricSnapshotActive()\n\t\t\t&& RelationIsAccessibleInLogicalDecoding(relation)\n\t\t\t&& IsTransactionState())\n\t\t{\n\t\t\tHeapTuple\tphys_tuple;\n\t\t\tForm_pg_class physrel;\n\n\t\t\tphys_tuple = ScanPgRelation(RelationGetRelid(relation),\n\t\t\t\t\t\t\t\t\t\tRelationGetRelid(relation) != ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t\ttrue);\n\t\t\tif (!HeapTupleIsValid(phys_tuple))\n\t\t\t\telog(ERROR, \"could not find pg_class entry for %u\",\n\t\t\t\t\t RelationGetRelid(relation));\n\t\t\tphysrel = (Form_pg_class) GETSTRUCT(phys_tuple);\n\n\t\t\trelation->rd_rel->reltablespace = physrel->reltablespace;\n\t\t\trelation->rd_rel->relfilenode = physrel->relfilenode;\n\t\t\theap_freetuple(phys_tuple);\n\t\t}\n\n\t\trelation->rd_node.relNode = relation->rd_rel->relfilenode;\n\t}\n\telse\n\t{\n\t\t/* Consult the relation mapper */\n\t\trelation->rd_node.relNode =\n\t\t\tRelationMapOidToFilenode(relation->rd_id,\n\t\t\t\t\t\t\t\t\t relation->rd_rel->relisshared);\n\t\tif (!OidIsValid(relation->rd_node.relNode))\n\t\t\telog(ERROR, \"could not find relation mapping for relation \\\"%s\\\", OID %u\",\n\t\t\t\t RelationGetRelationName(relation), relation->rd_id);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationInitPhysicalAddr(Relation relation)\n{\n\tif (relation->rd_rel->reltablespace)\n\t\trelation->rd_node.spcNode = relation->rd_rel->reltablespace;\n\telse\n\t\trelation->rd_node.spcNode = MyDatabaseTableSpace;\n\tif (relation->rd_node.spcNode == GLOBALTABLESPACE_OID)\n\t\trelation->rd_node.dbNode = InvalidOid;\n\telse\n\t\trelation->rd_node.dbNode = MyDatabaseId;\n\n\tif (relation->rd_rel->relfilenode)\n\t{\n\t\t/*\n\t\t * Even if we are using a decoding snapshot that doesn't represent the\n\t\t * current state of the catalog we need to make sure the filenode\n\t\t * points to the current file since the older file will be gone (or\n\t\t * truncated). The new file will still contain older rows so lookups\n\t\t * in them will work correctly. This wouldn't work correctly if\n\t\t * rewrites were allowed to change the schema in an incompatible way,\n\t\t * but those are prevented both on catalog tables and on user tables\n\t\t * declared as additional catalog tables.\n\t\t */\n\t\tif (HistoricSnapshotActive()\n\t\t\t&& RelationIsAccessibleInLogicalDecoding(relation)\n\t\t\t&& IsTransactionState())\n\t\t{\n\t\t\tHeapTuple\tphys_tuple;\n\t\t\tForm_pg_class physrel;\n\n\t\t\tphys_tuple = ScanPgRelation(RelationGetRelid(relation),\n\t\t\t\t\t\t\t\t\t\tRelationGetRelid(relation) != ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t\ttrue);\n\t\t\tif (!HeapTupleIsValid(phys_tuple))\n\t\t\t\telog(ERROR, \"could not find pg_class entry for %u\",\n\t\t\t\t\t RelationGetRelid(relation));\n\t\t\tphysrel = (Form_pg_class) GETSTRUCT(phys_tuple);\n\n\t\t\trelation->rd_rel->reltablespace = physrel->reltablespace;\n\t\t\trelation->rd_rel->relfilenode = physrel->relfilenode;\n\t\t\theap_freetuple(phys_tuple);\n\t\t}\n\n\t\trelation->rd_node.relNode = relation->rd_rel->relfilenode;\n\t}\n\telse\n\t{\n\t\t/* Consult the relation mapper */\n\t\trelation->rd_node.relNode =\n\t\t\tRelationMapOidToFilenode(relation->rd_id,\n\t\t\t\t\t\t\t\t\t relation->rd_rel->relisshared);\n\t\tif (!OidIsValid(relation->rd_node.relNode))\n\t\t\telog(ERROR, \"could not find relation mapping for relation \\\"%s\\\", OID %u\",\n\t\t\t\t RelationGetRelationName(relation), relation->rd_id);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationInitLockInfo",
          "args": [
            "relation"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationParseRelOptions",
          "args": [
            "relation",
            "pg_class_tuple"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "RelationParseRelOptions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "434-483",
          "snippet": "static void\nRelationParseRelOptions(Relation relation, HeapTuple tuple)\n{\n\tbytea\t   *options;\n\tamoptions_function amoptsfn;\n\n\trelation->rd_options = NULL;\n\n\t/*\n\t * Look up any AM-specific parse function; fall out if relkind should not\n\t * have options.\n\t */\n\tswitch (relation->rd_rel->relkind)\n\t{\n\t\tcase RELKIND_RELATION:\n\t\tcase RELKIND_TOASTVALUE:\n\t\tcase RELKIND_VIEW:\n\t\tcase RELKIND_MATVIEW:\n\t\tcase RELKIND_PARTITIONED_TABLE:\n\t\t\tamoptsfn = NULL;\n\t\t\tbreak;\n\t\tcase RELKIND_INDEX:\n\t\tcase RELKIND_PARTITIONED_INDEX:\n\t\t\tamoptsfn = relation->rd_amroutine->amoptions;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Fetch reloptions from tuple; have to use a hardwired descriptor because\n\t * we might not have any other for pg_class yet (consider executing this\n\t * code for pg_class itself)\n\t */\n\toptions = extractRelOptions(tuple, GetPgClassDescriptor(), amoptsfn);\n\n\t/*\n\t * Copy parsed data into CacheMemoryContext.  To guard against the\n\t * possibility of leaks in the reloptions code, we want to do the actual\n\t * parsing in the caller's memory context and copy the results into\n\t * CacheMemoryContext after the fact.\n\t */\n\tif (options)\n\t{\n\t\trelation->rd_options = MemoryContextAlloc(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t  VARSIZE(options));\n\t\tmemcpy(relation->rd_options, options, VARSIZE(options));\n\t\tpfree(options);\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static TupleDesc GetPgClassDescriptor(void);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic TupleDesc GetPgClassDescriptor(void);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationParseRelOptions(Relation relation, HeapTuple tuple)\n{\n\tbytea\t   *options;\n\tamoptions_function amoptsfn;\n\n\trelation->rd_options = NULL;\n\n\t/*\n\t * Look up any AM-specific parse function; fall out if relkind should not\n\t * have options.\n\t */\n\tswitch (relation->rd_rel->relkind)\n\t{\n\t\tcase RELKIND_RELATION:\n\t\tcase RELKIND_TOASTVALUE:\n\t\tcase RELKIND_VIEW:\n\t\tcase RELKIND_MATVIEW:\n\t\tcase RELKIND_PARTITIONED_TABLE:\n\t\t\tamoptsfn = NULL;\n\t\t\tbreak;\n\t\tcase RELKIND_INDEX:\n\t\tcase RELKIND_PARTITIONED_INDEX:\n\t\t\tamoptsfn = relation->rd_amroutine->amoptions;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Fetch reloptions from tuple; have to use a hardwired descriptor because\n\t * we might not have any other for pg_class yet (consider executing this\n\t * code for pg_class itself)\n\t */\n\toptions = extractRelOptions(tuple, GetPgClassDescriptor(), amoptsfn);\n\n\t/*\n\t * Copy parsed data into CacheMemoryContext.  To guard against the\n\t * possibility of leaks in the reloptions code, we want to do the actual\n\t * parsing in the caller's memory context and copy the results into\n\t * CacheMemoryContext after the fact.\n\t */\n\tif (options)\n\t{\n\t\trelation->rd_options = MemoryContextAlloc(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t  VARSIZE(options));\n\t\tmemcpy(relation->rd_options, options, VARSIZE(options));\n\t\tpfree(options);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationInitIndexAccessInfo",
          "args": [
            "relation"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "RelationInitIndexAccessInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "1346-1499",
          "snippet": "void\nRelationInitIndexAccessInfo(Relation relation)\n{\n\tHeapTuple\ttuple;\n\tForm_pg_am\taform;\n\tDatum\t\tindcollDatum;\n\tDatum\t\tindclassDatum;\n\tDatum\t\tindoptionDatum;\n\tbool\t\tisnull;\n\toidvector  *indcoll;\n\toidvector  *indclass;\n\tint2vector *indoption;\n\tMemoryContext indexcxt;\n\tMemoryContext oldcontext;\n\tint\t\t\tindnatts;\n\tint\t\t\tindnkeyatts;\n\tuint16\t\tamsupport;\n\n\t/*\n\t * Make a copy of the pg_index entry for the index.  Since pg_index\n\t * contains variable-length and possibly-null fields, we have to do this\n\t * honestly rather than just treating it as a Form_pg_index struct.\n\t */\n\ttuple = SearchSysCache1(INDEXRELID,\n\t\t\t\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"cache lookup failed for index %u\",\n\t\t\t RelationGetRelid(relation));\n\toldcontext = MemoryContextSwitchTo(CacheMemoryContext);\n\trelation->rd_indextuple = heap_copytuple(tuple);\n\trelation->rd_index = (Form_pg_index) GETSTRUCT(relation->rd_indextuple);\n\tMemoryContextSwitchTo(oldcontext);\n\tReleaseSysCache(tuple);\n\n\t/*\n\t * Look up the index's access method, save the OID of its handler function\n\t */\n\ttuple = SearchSysCache1(AMOID, ObjectIdGetDatum(relation->rd_rel->relam));\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"cache lookup failed for access method %u\",\n\t\t\t relation->rd_rel->relam);\n\taform = (Form_pg_am) GETSTRUCT(tuple);\n\trelation->rd_amhandler = aform->amhandler;\n\tReleaseSysCache(tuple);\n\n\tindnatts = RelationGetNumberOfAttributes(relation);\n\tif (indnatts != IndexRelationGetNumberOfAttributes(relation))\n\t\telog(ERROR, \"relnatts disagrees with indnatts for index %u\",\n\t\t\t RelationGetRelid(relation));\n\tindnkeyatts = IndexRelationGetNumberOfKeyAttributes(relation);\n\n\t/*\n\t * Make the private context to hold index access info.  The reason we need\n\t * a context, and not just a couple of pallocs, is so that we won't leak\n\t * any subsidiary info attached to fmgr lookup records.\n\t */\n\tindexcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t \"index info\",\n\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\trelation->rd_indexcxt = indexcxt;\n\tMemoryContextCopyAndSetIdentifier(indexcxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(relation));\n\n\t/*\n\t * Now we can fetch the index AM's API struct\n\t */\n\tInitIndexAmRoutine(relation);\n\n\t/*\n\t * Allocate arrays to hold data. Opclasses are not used for included\n\t * columns, so allocate them for indnkeyatts only.\n\t */\n\trelation->rd_opfamily = (Oid *)\n\t\tMemoryContextAllocZero(indexcxt, indnkeyatts * sizeof(Oid));\n\trelation->rd_opcintype = (Oid *)\n\t\tMemoryContextAllocZero(indexcxt, indnkeyatts * sizeof(Oid));\n\n\tamsupport = relation->rd_amroutine->amsupport;\n\tif (amsupport > 0)\n\t{\n\t\tint\t\t\tnsupport = indnatts * amsupport;\n\n\t\trelation->rd_support = (RegProcedure *)\n\t\t\tMemoryContextAllocZero(indexcxt, nsupport * sizeof(RegProcedure));\n\t\trelation->rd_supportinfo = (FmgrInfo *)\n\t\t\tMemoryContextAllocZero(indexcxt, nsupport * sizeof(FmgrInfo));\n\t}\n\telse\n\t{\n\t\trelation->rd_support = NULL;\n\t\trelation->rd_supportinfo = NULL;\n\t}\n\n\trelation->rd_indcollation = (Oid *)\n\t\tMemoryContextAllocZero(indexcxt, indnkeyatts * sizeof(Oid));\n\n\trelation->rd_indoption = (int16 *)\n\t\tMemoryContextAllocZero(indexcxt, indnkeyatts * sizeof(int16));\n\n\t/*\n\t * indcollation cannot be referenced directly through the C struct,\n\t * because it comes after the variable-width indkey field.  Must extract\n\t * the datum the hard way...\n\t */\n\tindcollDatum = fastgetattr(relation->rd_indextuple,\n\t\t\t\t\t\t\t   Anum_pg_index_indcollation,\n\t\t\t\t\t\t\t   GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t   &isnull);\n\tAssert(!isnull);\n\tindcoll = (oidvector *) DatumGetPointer(indcollDatum);\n\tmemcpy(relation->rd_indcollation, indcoll->values, indnkeyatts * sizeof(Oid));\n\n\t/*\n\t * indclass cannot be referenced directly through the C struct, because it\n\t * comes after the variable-width indkey field.  Must extract the datum\n\t * the hard way...\n\t */\n\tindclassDatum = fastgetattr(relation->rd_indextuple,\n\t\t\t\t\t\t\t\tAnum_pg_index_indclass,\n\t\t\t\t\t\t\t\tGetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t&isnull);\n\tAssert(!isnull);\n\tindclass = (oidvector *) DatumGetPointer(indclassDatum);\n\n\t/*\n\t * Fill the support procedure OID array, as well as the info about\n\t * opfamilies and opclass input types.  (aminfo and supportinfo are left\n\t * as zeroes, and are filled on-the-fly when used)\n\t */\n\tIndexSupportInitialize(indclass, relation->rd_support,\n\t\t\t\t\t\t   relation->rd_opfamily, relation->rd_opcintype,\n\t\t\t\t\t\t   amsupport, indnkeyatts);\n\n\t/*\n\t * Similarly extract indoption and copy it to the cache entry\n\t */\n\tindoptionDatum = fastgetattr(relation->rd_indextuple,\n\t\t\t\t\t\t\t\t Anum_pg_index_indoption,\n\t\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t &isnull);\n\tAssert(!isnull);\n\tindoption = (int2vector *) DatumGetPointer(indoptionDatum);\n\tmemcpy(relation->rd_indoption, indoption->values, indnkeyatts * sizeof(int16));\n\n\t/*\n\t * expressions, predicate, exclusion caches will be filled later\n\t */\n\trelation->rd_indexprs = NIL;\n\trelation->rd_indpred = NIL;\n\trelation->rd_exclops = NULL;\n\trelation->rd_exclprocs = NULL;\n\trelation->rd_exclstrats = NULL;\n\trelation->rd_amcache = NULL;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static TupleDesc GetPgIndexDescriptor(void);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static List *insert_ordered_oid(List *list, Oid datum);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic TupleDesc GetPgIndexDescriptor(void);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic List *insert_ordered_oid(List *list, Oid datum);\nstatic void InitIndexAmRoutine(Relation relation);\n\nvoid\nRelationInitIndexAccessInfo(Relation relation)\n{\n\tHeapTuple\ttuple;\n\tForm_pg_am\taform;\n\tDatum\t\tindcollDatum;\n\tDatum\t\tindclassDatum;\n\tDatum\t\tindoptionDatum;\n\tbool\t\tisnull;\n\toidvector  *indcoll;\n\toidvector  *indclass;\n\tint2vector *indoption;\n\tMemoryContext indexcxt;\n\tMemoryContext oldcontext;\n\tint\t\t\tindnatts;\n\tint\t\t\tindnkeyatts;\n\tuint16\t\tamsupport;\n\n\t/*\n\t * Make a copy of the pg_index entry for the index.  Since pg_index\n\t * contains variable-length and possibly-null fields, we have to do this\n\t * honestly rather than just treating it as a Form_pg_index struct.\n\t */\n\ttuple = SearchSysCache1(INDEXRELID,\n\t\t\t\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"cache lookup failed for index %u\",\n\t\t\t RelationGetRelid(relation));\n\toldcontext = MemoryContextSwitchTo(CacheMemoryContext);\n\trelation->rd_indextuple = heap_copytuple(tuple);\n\trelation->rd_index = (Form_pg_index) GETSTRUCT(relation->rd_indextuple);\n\tMemoryContextSwitchTo(oldcontext);\n\tReleaseSysCache(tuple);\n\n\t/*\n\t * Look up the index's access method, save the OID of its handler function\n\t */\n\ttuple = SearchSysCache1(AMOID, ObjectIdGetDatum(relation->rd_rel->relam));\n\tif (!HeapTupleIsValid(tuple))\n\t\telog(ERROR, \"cache lookup failed for access method %u\",\n\t\t\t relation->rd_rel->relam);\n\taform = (Form_pg_am) GETSTRUCT(tuple);\n\trelation->rd_amhandler = aform->amhandler;\n\tReleaseSysCache(tuple);\n\n\tindnatts = RelationGetNumberOfAttributes(relation);\n\tif (indnatts != IndexRelationGetNumberOfAttributes(relation))\n\t\telog(ERROR, \"relnatts disagrees with indnatts for index %u\",\n\t\t\t RelationGetRelid(relation));\n\tindnkeyatts = IndexRelationGetNumberOfKeyAttributes(relation);\n\n\t/*\n\t * Make the private context to hold index access info.  The reason we need\n\t * a context, and not just a couple of pallocs, is so that we won't leak\n\t * any subsidiary info attached to fmgr lookup records.\n\t */\n\tindexcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t \"index info\",\n\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\trelation->rd_indexcxt = indexcxt;\n\tMemoryContextCopyAndSetIdentifier(indexcxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(relation));\n\n\t/*\n\t * Now we can fetch the index AM's API struct\n\t */\n\tInitIndexAmRoutine(relation);\n\n\t/*\n\t * Allocate arrays to hold data. Opclasses are not used for included\n\t * columns, so allocate them for indnkeyatts only.\n\t */\n\trelation->rd_opfamily = (Oid *)\n\t\tMemoryContextAllocZero(indexcxt, indnkeyatts * sizeof(Oid));\n\trelation->rd_opcintype = (Oid *)\n\t\tMemoryContextAllocZero(indexcxt, indnkeyatts * sizeof(Oid));\n\n\tamsupport = relation->rd_amroutine->amsupport;\n\tif (amsupport > 0)\n\t{\n\t\tint\t\t\tnsupport = indnatts * amsupport;\n\n\t\trelation->rd_support = (RegProcedure *)\n\t\t\tMemoryContextAllocZero(indexcxt, nsupport * sizeof(RegProcedure));\n\t\trelation->rd_supportinfo = (FmgrInfo *)\n\t\t\tMemoryContextAllocZero(indexcxt, nsupport * sizeof(FmgrInfo));\n\t}\n\telse\n\t{\n\t\trelation->rd_support = NULL;\n\t\trelation->rd_supportinfo = NULL;\n\t}\n\n\trelation->rd_indcollation = (Oid *)\n\t\tMemoryContextAllocZero(indexcxt, indnkeyatts * sizeof(Oid));\n\n\trelation->rd_indoption = (int16 *)\n\t\tMemoryContextAllocZero(indexcxt, indnkeyatts * sizeof(int16));\n\n\t/*\n\t * indcollation cannot be referenced directly through the C struct,\n\t * because it comes after the variable-width indkey field.  Must extract\n\t * the datum the hard way...\n\t */\n\tindcollDatum = fastgetattr(relation->rd_indextuple,\n\t\t\t\t\t\t\t   Anum_pg_index_indcollation,\n\t\t\t\t\t\t\t   GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t   &isnull);\n\tAssert(!isnull);\n\tindcoll = (oidvector *) DatumGetPointer(indcollDatum);\n\tmemcpy(relation->rd_indcollation, indcoll->values, indnkeyatts * sizeof(Oid));\n\n\t/*\n\t * indclass cannot be referenced directly through the C struct, because it\n\t * comes after the variable-width indkey field.  Must extract the datum\n\t * the hard way...\n\t */\n\tindclassDatum = fastgetattr(relation->rd_indextuple,\n\t\t\t\t\t\t\t\tAnum_pg_index_indclass,\n\t\t\t\t\t\t\t\tGetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t&isnull);\n\tAssert(!isnull);\n\tindclass = (oidvector *) DatumGetPointer(indclassDatum);\n\n\t/*\n\t * Fill the support procedure OID array, as well as the info about\n\t * opfamilies and opclass input types.  (aminfo and supportinfo are left\n\t * as zeroes, and are filled on-the-fly when used)\n\t */\n\tIndexSupportInitialize(indclass, relation->rd_support,\n\t\t\t\t\t\t   relation->rd_opfamily, relation->rd_opcintype,\n\t\t\t\t\t\t   amsupport, indnkeyatts);\n\n\t/*\n\t * Similarly extract indoption and copy it to the cache entry\n\t */\n\tindoptionDatum = fastgetattr(relation->rd_indextuple,\n\t\t\t\t\t\t\t\t Anum_pg_index_indoption,\n\t\t\t\t\t\t\t\t GetPgIndexDescriptor(),\n\t\t\t\t\t\t\t\t &isnull);\n\tAssert(!isnull);\n\tindoption = (int2vector *) DatumGetPointer(indoptionDatum);\n\tmemcpy(relation->rd_indoption, indoption->values, indnkeyatts * sizeof(int16));\n\n\t/*\n\t * expressions, predicate, exclusion caches will be filled later\n\t */\n\trelation->rd_indexprs = NIL;\n\trelation->rd_indpred = NIL;\n\trelation->rd_exclops = NULL;\n\trelation->rd_exclprocs = NULL;\n\trelation->rd_exclstrats = NULL;\n\trelation->rd_amcache = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "relation->rd_rel->relam"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationBuildPartitionDesc",
          "args": [
            "relation"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "RelationBuildPartitionDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/partcache.c",
          "lines": "266-798",
          "snippet": "void\nRelationBuildPartitionDesc(Relation rel)\n{\n\tList\t   *inhoids,\n\t\t\t   *partoids;\n\tOid\t\t   *oids = NULL;\n\tList\t   *boundspecs = NIL;\n\tListCell   *cell;\n\tint\t\t\ti,\n\t\t\t\tnparts;\n\tPartitionKey key = RelationGetPartitionKey(rel);\n\tPartitionDesc result;\n\tMemoryContext oldcxt;\n\n\tint\t\t\tndatums = 0;\n\tint\t\t\tdefault_index = -1;\n\n\t/* Hash partitioning specific */\n\tPartitionHashBound **hbounds = NULL;\n\n\t/* List partitioning specific */\n\tPartitionListValue **all_values = NULL;\n\tint\t\t\tnull_index = -1;\n\n\t/* Range partitioning specific */\n\tPartitionRangeBound **rbounds = NULL;\n\n\t/* Get partition oids from pg_inherits */\n\tinhoids = find_inheritance_children(RelationGetRelid(rel), NoLock);\n\n\t/* Collect bound spec nodes in a list */\n\ti = 0;\n\tpartoids = NIL;\n\tforeach(cell, inhoids)\n\t{\n\t\tOid\t\t\tinhrelid = lfirst_oid(cell);\n\t\tHeapTuple\ttuple;\n\t\tDatum\t\tdatum;\n\t\tbool\t\tisnull;\n\t\tNode\t   *boundspec;\n\n\t\ttuple = SearchSysCache1(RELOID, inhrelid);\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", inhrelid);\n\n\t\tdatum = SysCacheGetAttr(RELOID, tuple,\n\t\t\t\t\t\t\t\tAnum_pg_class_relpartbound,\n\t\t\t\t\t\t\t\t&isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null relpartbound for relation %u\", inhrelid);\n\t\tboundspec = (Node *) stringToNode(TextDatumGetCString(datum));\n\n\t\t/*\n\t\t * Sanity check: If the PartitionBoundSpec says this is the default\n\t\t * partition, its OID should correspond to whatever's stored in\n\t\t * pg_partitioned_table.partdefid; if not, the catalog is corrupt.\n\t\t */\n\t\tif (castNode(PartitionBoundSpec, boundspec)->is_default)\n\t\t{\n\t\t\tOid\t\t\tpartdefid;\n\n\t\t\tpartdefid = get_default_partition_oid(RelationGetRelid(rel));\n\t\t\tif (partdefid != inhrelid)\n\t\t\t\telog(ERROR, \"expected partdefid %u, but got %u\",\n\t\t\t\t\t inhrelid, partdefid);\n\t\t}\n\n\t\tboundspecs = lappend(boundspecs, boundspec);\n\t\tpartoids = lappend_oid(partoids, inhrelid);\n\t\tReleaseSysCache(tuple);\n\t}\n\n\tnparts = list_length(partoids);\n\n\tif (nparts > 0)\n\t{\n\t\toids = (Oid *) palloc(nparts * sizeof(Oid));\n\t\ti = 0;\n\t\tforeach(cell, partoids)\n\t\t\toids[i++] = lfirst_oid(cell);\n\n\t\t/* Convert from node to the internal representation */\n\t\tif (key->strategy == PARTITION_STRATEGY_HASH)\n\t\t{\n\t\t\tndatums = nparts;\n\t\t\thbounds = (PartitionHashBound **)\n\t\t\t\tpalloc(nparts * sizeof(PartitionHashBound *));\n\n\t\t\ti = 0;\n\t\t\tforeach(cell, boundspecs)\n\t\t\t{\n\t\t\t\tPartitionBoundSpec *spec = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlfirst(cell));\n\n\t\t\t\tif (spec->strategy != PARTITION_STRATEGY_HASH)\n\t\t\t\t\telog(ERROR, \"invalid strategy in partition bound spec\");\n\n\t\t\t\thbounds[i] = (PartitionHashBound *)\n\t\t\t\t\tpalloc(sizeof(PartitionHashBound));\n\n\t\t\t\thbounds[i]->modulus = spec->modulus;\n\t\t\t\thbounds[i]->remainder = spec->remainder;\n\t\t\t\thbounds[i]->index = i;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\t/* Sort all the bounds in ascending order */\n\t\t\tqsort(hbounds, nparts, sizeof(PartitionHashBound *),\n\t\t\t\t  qsort_partition_hbound_cmp);\n\t\t}\n\t\telse if (key->strategy == PARTITION_STRATEGY_LIST)\n\t\t{\n\t\t\tList\t   *non_null_values = NIL;\n\n\t\t\t/*\n\t\t\t * Create a unified list of non-null values across all partitions.\n\t\t\t */\n\t\t\ti = 0;\n\t\t\tnull_index = -1;\n\t\t\tforeach(cell, boundspecs)\n\t\t\t{\n\t\t\t\tPartitionBoundSpec *spec = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlfirst(cell));\n\t\t\t\tListCell   *c;\n\n\t\t\t\tif (spec->strategy != PARTITION_STRATEGY_LIST)\n\t\t\t\t\telog(ERROR, \"invalid strategy in partition bound spec\");\n\n\t\t\t\t/*\n\t\t\t\t * Note the index of the partition bound spec for the default\n\t\t\t\t * partition. There's no datum to add to the list of non-null\n\t\t\t\t * datums for this partition.\n\t\t\t\t */\n\t\t\t\tif (spec->is_default)\n\t\t\t\t{\n\t\t\t\t\tdefault_index = i;\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tforeach(c, spec->listdatums)\n\t\t\t\t{\n\t\t\t\t\tConst\t   *val = castNode(Const, lfirst(c));\n\t\t\t\t\tPartitionListValue *list_value = NULL;\n\n\t\t\t\t\tif (!val->constisnull)\n\t\t\t\t\t{\n\t\t\t\t\t\tlist_value = (PartitionListValue *)\n\t\t\t\t\t\t\tpalloc0(sizeof(PartitionListValue));\n\t\t\t\t\t\tlist_value->index = i;\n\t\t\t\t\t\tlist_value->value = val->constvalue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Never put a null into the values array, flag\n\t\t\t\t\t\t * instead for the code further down below where we\n\t\t\t\t\t\t * construct the actual relcache struct.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (null_index != -1)\n\t\t\t\t\t\t\telog(ERROR, \"found null more than once\");\n\t\t\t\t\t\tnull_index = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (list_value)\n\t\t\t\t\t\tnon_null_values = lappend(non_null_values,\n\t\t\t\t\t\t\t\t\t\t\t\t  list_value);\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tndatums = list_length(non_null_values);\n\n\t\t\t/*\n\t\t\t * Collect all list values in one array. Alongside the value, we\n\t\t\t * also save the index of partition the value comes from.\n\t\t\t */\n\t\t\tall_values = (PartitionListValue **) palloc(ndatums *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(PartitionListValue *));\n\t\t\ti = 0;\n\t\t\tforeach(cell, non_null_values)\n\t\t\t{\n\t\t\t\tPartitionListValue *src = lfirst(cell);\n\n\t\t\t\tall_values[i] = (PartitionListValue *)\n\t\t\t\t\tpalloc(sizeof(PartitionListValue));\n\t\t\t\tall_values[i]->value = src->value;\n\t\t\t\tall_values[i]->index = src->index;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tqsort_arg(all_values, ndatums, sizeof(PartitionListValue *),\n\t\t\t\t\t  qsort_partition_list_value_cmp, (void *) key);\n\t\t}\n\t\telse if (key->strategy == PARTITION_STRATEGY_RANGE)\n\t\t{\n\t\t\tint\t\t\tk;\n\t\t\tPartitionRangeBound **all_bounds,\n\t\t\t\t\t   *prev;\n\n\t\t\tall_bounds = (PartitionRangeBound **) palloc0(2 * nparts *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(PartitionRangeBound *));\n\n\t\t\t/*\n\t\t\t * Create a unified list of range bounds across all the\n\t\t\t * partitions.\n\t\t\t */\n\t\t\ti = ndatums = 0;\n\t\t\tforeach(cell, boundspecs)\n\t\t\t{\n\t\t\t\tPartitionBoundSpec *spec = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlfirst(cell));\n\t\t\t\tPartitionRangeBound *lower,\n\t\t\t\t\t\t   *upper;\n\n\t\t\t\tif (spec->strategy != PARTITION_STRATEGY_RANGE)\n\t\t\t\t\telog(ERROR, \"invalid strategy in partition bound spec\");\n\n\t\t\t\t/*\n\t\t\t\t * Note the index of the partition bound spec for the default\n\t\t\t\t * partition. There's no datum to add to the allbounds array\n\t\t\t\t * for this partition.\n\t\t\t\t */\n\t\t\t\tif (spec->is_default)\n\t\t\t\t{\n\t\t\t\t\tdefault_index = i++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlower = make_one_partition_rbound(key, i, spec->lowerdatums,\n\t\t\t\t\t\t\t\t\t\t\t\t  true);\n\t\t\t\tupper = make_one_partition_rbound(key, i, spec->upperdatums,\n\t\t\t\t\t\t\t\t\t\t\t\t  false);\n\t\t\t\tall_bounds[ndatums++] = lower;\n\t\t\t\tall_bounds[ndatums++] = upper;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tAssert(ndatums == nparts * 2 ||\n\t\t\t\t   (default_index != -1 && ndatums == (nparts - 1) * 2));\n\n\t\t\t/* Sort all the bounds in ascending order */\n\t\t\tqsort_arg(all_bounds, ndatums,\n\t\t\t\t\t  sizeof(PartitionRangeBound *),\n\t\t\t\t\t  qsort_partition_rbound_cmp,\n\t\t\t\t\t  (void *) key);\n\n\t\t\t/* Save distinct bounds from all_bounds into rbounds. */\n\t\t\trbounds = (PartitionRangeBound **)\n\t\t\t\tpalloc(ndatums * sizeof(PartitionRangeBound *));\n\t\t\tk = 0;\n\t\t\tprev = NULL;\n\t\t\tfor (i = 0; i < ndatums; i++)\n\t\t\t{\n\t\t\t\tPartitionRangeBound *cur = all_bounds[i];\n\t\t\t\tbool\t\tis_distinct = false;\n\t\t\t\tint\t\t\tj;\n\n\t\t\t\t/* Is the current bound distinct from the previous one? */\n\t\t\t\tfor (j = 0; j < key->partnatts; j++)\n\t\t\t\t{\n\t\t\t\t\tDatum\t\tcmpval;\n\n\t\t\t\t\tif (prev == NULL || cur->kind[j] != prev->kind[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tis_distinct = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If the bounds are both MINVALUE or MAXVALUE, stop now\n\t\t\t\t\t * and treat them as equal, since any values after this\n\t\t\t\t\t * point must be ignored.\n\t\t\t\t\t */\n\t\t\t\t\tif (cur->kind[j] != PARTITION_RANGE_DATUM_VALUE)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcmpval = FunctionCall2Coll(&key->partsupfunc[j],\n\t\t\t\t\t\t\t\t\t\t\t   key->partcollation[j],\n\t\t\t\t\t\t\t\t\t\t\t   cur->datums[j],\n\t\t\t\t\t\t\t\t\t\t\t   prev->datums[j]);\n\t\t\t\t\tif (DatumGetInt32(cmpval) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tis_distinct = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Only if the bound is distinct save it into a temporary\n\t\t\t\t * array i.e. rbounds which is later copied into boundinfo\n\t\t\t\t * datums array.\n\t\t\t\t */\n\t\t\t\tif (is_distinct)\n\t\t\t\t\trbounds[k++] = all_bounds[i];\n\n\t\t\t\tprev = cur;\n\t\t\t}\n\n\t\t\t/* Update ndatums to hold the count of distinct datums. */\n\t\t\tndatums = k;\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"unexpected partition strategy: %d\",\n\t\t\t\t (int) key->strategy);\n\t}\n\n\t/* Assert we aren't about to leak any old data structure */\n\tAssert(rel->rd_pdcxt == NULL);\n\tAssert(rel->rd_partdesc == NULL);\n\n\t/*\n\t * Now build the actual relcache partition descriptor.  Note that the\n\t * order of operations here is fairly critical.  If we fail partway\n\t * through this code, we won't have leaked memory because the rd_pdcxt is\n\t * attached to the relcache entry immediately, so it'll be freed whenever\n\t * the entry is rebuilt or destroyed.  However, we don't assign to\n\t * rd_partdesc until the cached data structure is fully complete and\n\t * valid, so that no other code might try to use it.\n\t */\n\trel->rd_pdcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t  \"partition descriptor\",\n\t\t\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\tMemoryContextCopyAndSetIdentifier(rel->rd_pdcxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(rel));\n\n\toldcxt = MemoryContextSwitchTo(rel->rd_pdcxt);\n\n\tresult = (PartitionDescData *) palloc0(sizeof(PartitionDescData));\n\tresult->nparts = nparts;\n\tif (nparts > 0)\n\t{\n\t\tPartitionBoundInfo boundinfo;\n\t\tint\t\t   *mapping;\n\t\tint\t\t\tnext_index = 0;\n\n\t\tresult->oids = (Oid *) palloc0(nparts * sizeof(Oid));\n\n\t\tboundinfo = (PartitionBoundInfoData *)\n\t\t\tpalloc0(sizeof(PartitionBoundInfoData));\n\t\tboundinfo->strategy = key->strategy;\n\t\tboundinfo->default_index = -1;\n\t\tboundinfo->ndatums = ndatums;\n\t\tboundinfo->null_index = -1;\n\t\tboundinfo->datums = (Datum **) palloc0(ndatums * sizeof(Datum *));\n\n\t\t/* Initialize mapping array with invalid values */\n\t\tmapping = (int *) palloc(sizeof(int) * nparts);\n\t\tfor (i = 0; i < nparts; i++)\n\t\t\tmapping[i] = -1;\n\n\t\tswitch (key->strategy)\n\t\t{\n\t\t\tcase PARTITION_STRATEGY_HASH:\n\t\t\t\t{\n\t\t\t\t\t/* Moduli are stored in ascending order */\n\t\t\t\t\tint\t\t\tgreatest_modulus = hbounds[ndatums - 1]->modulus;\n\n\t\t\t\t\tboundinfo->indexes = (int *) palloc(greatest_modulus *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int));\n\n\t\t\t\t\tfor (i = 0; i < greatest_modulus; i++)\n\t\t\t\t\t\tboundinfo->indexes[i] = -1;\n\n\t\t\t\t\tfor (i = 0; i < nparts; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\tmodulus = hbounds[i]->modulus;\n\t\t\t\t\t\tint\t\t\tremainder = hbounds[i]->remainder;\n\n\t\t\t\t\t\tboundinfo->datums[i] = (Datum *) palloc(2 *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(Datum));\n\t\t\t\t\t\tboundinfo->datums[i][0] = Int32GetDatum(modulus);\n\t\t\t\t\t\tboundinfo->datums[i][1] = Int32GetDatum(remainder);\n\n\t\t\t\t\t\twhile (remainder < greatest_modulus)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* overlap? */\n\t\t\t\t\t\t\tAssert(boundinfo->indexes[remainder] == -1);\n\t\t\t\t\t\t\tboundinfo->indexes[remainder] = i;\n\t\t\t\t\t\t\tremainder += modulus;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmapping[hbounds[i]->index] = i;\n\t\t\t\t\t\tpfree(hbounds[i]);\n\t\t\t\t\t}\n\t\t\t\t\tpfree(hbounds);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase PARTITION_STRATEGY_LIST:\n\t\t\t\t{\n\t\t\t\t\tboundinfo->indexes = (int *) palloc(ndatums * sizeof(int));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Copy values.  Indexes of individual values are mapped\n\t\t\t\t\t * to canonical values so that they match for any two list\n\t\t\t\t\t * partitioned tables with same number of partitions and\n\t\t\t\t\t * same lists per partition.  One way to canonicalize is\n\t\t\t\t\t * to assign the index in all_values[] of the smallest\n\t\t\t\t\t * value of each partition, as the index of all of the\n\t\t\t\t\t * partition's values.\n\t\t\t\t\t */\n\t\t\t\t\tfor (i = 0; i < ndatums; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tboundinfo->datums[i] = (Datum *) palloc(sizeof(Datum));\n\t\t\t\t\t\tboundinfo->datums[i][0] = datumCopy(all_values[i]->value,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey->parttypbyval[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey->parttyplen[0]);\n\n\t\t\t\t\t\t/* If the old index has no mapping, assign one */\n\t\t\t\t\t\tif (mapping[all_values[i]->index] == -1)\n\t\t\t\t\t\t\tmapping[all_values[i]->index] = next_index++;\n\n\t\t\t\t\t\tboundinfo->indexes[i] = mapping[all_values[i]->index];\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If null-accepting partition has no mapped index yet,\n\t\t\t\t\t * assign one.  This could happen if such partition\n\t\t\t\t\t * accepts only null and hence not covered in the above\n\t\t\t\t\t * loop which only handled non-null values.\n\t\t\t\t\t */\n\t\t\t\t\tif (null_index != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert(null_index >= 0);\n\t\t\t\t\t\tif (mapping[null_index] == -1)\n\t\t\t\t\t\t\tmapping[null_index] = next_index++;\n\t\t\t\t\t\tboundinfo->null_index = mapping[null_index];\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Assign mapped index for the default partition. */\n\t\t\t\t\tif (default_index != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The default partition accepts any value not\n\t\t\t\t\t\t * specified in the lists of other partitions, hence\n\t\t\t\t\t\t * it should not get mapped index while assigning\n\t\t\t\t\t\t * those for non-null datums.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tAssert(default_index >= 0 &&\n\t\t\t\t\t\t\t   mapping[default_index] == -1);\n\t\t\t\t\t\tmapping[default_index] = next_index++;\n\t\t\t\t\t\tboundinfo->default_index = mapping[default_index];\n\t\t\t\t\t}\n\n\t\t\t\t\t/* All partition must now have a valid mapping */\n\t\t\t\t\tAssert(next_index == nparts);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase PARTITION_STRATEGY_RANGE:\n\t\t\t\t{\n\t\t\t\t\tboundinfo->kind = (PartitionRangeDatumKind **)\n\t\t\t\t\t\tpalloc(ndatums *\n\t\t\t\t\t\t\t   sizeof(PartitionRangeDatumKind *));\n\t\t\t\t\tboundinfo->indexes = (int *) palloc((ndatums + 1) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int));\n\n\t\t\t\t\tfor (i = 0; i < ndatums; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\tj;\n\n\t\t\t\t\t\tboundinfo->datums[i] = (Datum *) palloc(key->partnatts *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(Datum));\n\t\t\t\t\t\tboundinfo->kind[i] = (PartitionRangeDatumKind *)\n\t\t\t\t\t\t\tpalloc(key->partnatts *\n\t\t\t\t\t\t\t\t   sizeof(PartitionRangeDatumKind));\n\t\t\t\t\t\tfor (j = 0; j < key->partnatts; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (rbounds[i]->kind[j] == PARTITION_RANGE_DATUM_VALUE)\n\t\t\t\t\t\t\t\tboundinfo->datums[i][j] =\n\t\t\t\t\t\t\t\t\tdatumCopy(rbounds[i]->datums[j],\n\t\t\t\t\t\t\t\t\t\t\t  key->parttypbyval[j],\n\t\t\t\t\t\t\t\t\t\t\t  key->parttyplen[j]);\n\t\t\t\t\t\t\tboundinfo->kind[i][j] = rbounds[i]->kind[j];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * There is no mapping for invalid indexes.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Any lower bounds in the rbounds array have invalid\n\t\t\t\t\t\t * indexes assigned, because the values between the\n\t\t\t\t\t\t * previous bound (if there is one) and this (lower)\n\t\t\t\t\t\t * bound are not part of the range of any existing\n\t\t\t\t\t\t * partition.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (rbounds[i]->lower)\n\t\t\t\t\t\t\tboundinfo->indexes[i] = -1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint\t\t\torig_index = rbounds[i]->index;\n\n\t\t\t\t\t\t\t/* If the old index has no mapping, assign one */\n\t\t\t\t\t\t\tif (mapping[orig_index] == -1)\n\t\t\t\t\t\t\t\tmapping[orig_index] = next_index++;\n\n\t\t\t\t\t\t\tboundinfo->indexes[i] = mapping[orig_index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Assign mapped index for the default partition. */\n\t\t\t\t\tif (default_index != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert(default_index >= 0 && mapping[default_index] == -1);\n\t\t\t\t\t\tmapping[default_index] = next_index++;\n\t\t\t\t\t\tboundinfo->default_index = mapping[default_index];\n\t\t\t\t\t}\n\t\t\t\t\tboundinfo->indexes[i] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected partition strategy: %d\",\n\t\t\t\t\t (int) key->strategy);\n\t\t}\n\n\t\tresult->boundinfo = boundinfo;\n\n\t\t/*\n\t\t * Now assign OIDs from the original array into mapped indexes of the\n\t\t * result array.  Order of OIDs in the former is defined by the\n\t\t * catalog scan that retrieved them, whereas that in the latter is\n\t\t * defined by canonicalized representation of the partition bounds.\n\t\t */\n\t\tfor (i = 0; i < nparts; i++)\n\t\t\tresult->oids[mapping[i]] = oids[i];\n\t\tpfree(mapping);\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n\trel->rd_partdesc = result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_inherits.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static List *generate_partition_qual(Relation rel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/planner.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_inherits.h\"\n#include \"catalog/partition.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic List *generate_partition_qual(Relation rel);\n\nvoid\nRelationBuildPartitionDesc(Relation rel)\n{\n\tList\t   *inhoids,\n\t\t\t   *partoids;\n\tOid\t\t   *oids = NULL;\n\tList\t   *boundspecs = NIL;\n\tListCell   *cell;\n\tint\t\t\ti,\n\t\t\t\tnparts;\n\tPartitionKey key = RelationGetPartitionKey(rel);\n\tPartitionDesc result;\n\tMemoryContext oldcxt;\n\n\tint\t\t\tndatums = 0;\n\tint\t\t\tdefault_index = -1;\n\n\t/* Hash partitioning specific */\n\tPartitionHashBound **hbounds = NULL;\n\n\t/* List partitioning specific */\n\tPartitionListValue **all_values = NULL;\n\tint\t\t\tnull_index = -1;\n\n\t/* Range partitioning specific */\n\tPartitionRangeBound **rbounds = NULL;\n\n\t/* Get partition oids from pg_inherits */\n\tinhoids = find_inheritance_children(RelationGetRelid(rel), NoLock);\n\n\t/* Collect bound spec nodes in a list */\n\ti = 0;\n\tpartoids = NIL;\n\tforeach(cell, inhoids)\n\t{\n\t\tOid\t\t\tinhrelid = lfirst_oid(cell);\n\t\tHeapTuple\ttuple;\n\t\tDatum\t\tdatum;\n\t\tbool\t\tisnull;\n\t\tNode\t   *boundspec;\n\n\t\ttuple = SearchSysCache1(RELOID, inhrelid);\n\t\tif (!HeapTupleIsValid(tuple))\n\t\t\telog(ERROR, \"cache lookup failed for relation %u\", inhrelid);\n\n\t\tdatum = SysCacheGetAttr(RELOID, tuple,\n\t\t\t\t\t\t\t\tAnum_pg_class_relpartbound,\n\t\t\t\t\t\t\t\t&isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null relpartbound for relation %u\", inhrelid);\n\t\tboundspec = (Node *) stringToNode(TextDatumGetCString(datum));\n\n\t\t/*\n\t\t * Sanity check: If the PartitionBoundSpec says this is the default\n\t\t * partition, its OID should correspond to whatever's stored in\n\t\t * pg_partitioned_table.partdefid; if not, the catalog is corrupt.\n\t\t */\n\t\tif (castNode(PartitionBoundSpec, boundspec)->is_default)\n\t\t{\n\t\t\tOid\t\t\tpartdefid;\n\n\t\t\tpartdefid = get_default_partition_oid(RelationGetRelid(rel));\n\t\t\tif (partdefid != inhrelid)\n\t\t\t\telog(ERROR, \"expected partdefid %u, but got %u\",\n\t\t\t\t\t inhrelid, partdefid);\n\t\t}\n\n\t\tboundspecs = lappend(boundspecs, boundspec);\n\t\tpartoids = lappend_oid(partoids, inhrelid);\n\t\tReleaseSysCache(tuple);\n\t}\n\n\tnparts = list_length(partoids);\n\n\tif (nparts > 0)\n\t{\n\t\toids = (Oid *) palloc(nparts * sizeof(Oid));\n\t\ti = 0;\n\t\tforeach(cell, partoids)\n\t\t\toids[i++] = lfirst_oid(cell);\n\n\t\t/* Convert from node to the internal representation */\n\t\tif (key->strategy == PARTITION_STRATEGY_HASH)\n\t\t{\n\t\t\tndatums = nparts;\n\t\t\thbounds = (PartitionHashBound **)\n\t\t\t\tpalloc(nparts * sizeof(PartitionHashBound *));\n\n\t\t\ti = 0;\n\t\t\tforeach(cell, boundspecs)\n\t\t\t{\n\t\t\t\tPartitionBoundSpec *spec = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlfirst(cell));\n\n\t\t\t\tif (spec->strategy != PARTITION_STRATEGY_HASH)\n\t\t\t\t\telog(ERROR, \"invalid strategy in partition bound spec\");\n\n\t\t\t\thbounds[i] = (PartitionHashBound *)\n\t\t\t\t\tpalloc(sizeof(PartitionHashBound));\n\n\t\t\t\thbounds[i]->modulus = spec->modulus;\n\t\t\t\thbounds[i]->remainder = spec->remainder;\n\t\t\t\thbounds[i]->index = i;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\t/* Sort all the bounds in ascending order */\n\t\t\tqsort(hbounds, nparts, sizeof(PartitionHashBound *),\n\t\t\t\t  qsort_partition_hbound_cmp);\n\t\t}\n\t\telse if (key->strategy == PARTITION_STRATEGY_LIST)\n\t\t{\n\t\t\tList\t   *non_null_values = NIL;\n\n\t\t\t/*\n\t\t\t * Create a unified list of non-null values across all partitions.\n\t\t\t */\n\t\t\ti = 0;\n\t\t\tnull_index = -1;\n\t\t\tforeach(cell, boundspecs)\n\t\t\t{\n\t\t\t\tPartitionBoundSpec *spec = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlfirst(cell));\n\t\t\t\tListCell   *c;\n\n\t\t\t\tif (spec->strategy != PARTITION_STRATEGY_LIST)\n\t\t\t\t\telog(ERROR, \"invalid strategy in partition bound spec\");\n\n\t\t\t\t/*\n\t\t\t\t * Note the index of the partition bound spec for the default\n\t\t\t\t * partition. There's no datum to add to the list of non-null\n\t\t\t\t * datums for this partition.\n\t\t\t\t */\n\t\t\t\tif (spec->is_default)\n\t\t\t\t{\n\t\t\t\t\tdefault_index = i;\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tforeach(c, spec->listdatums)\n\t\t\t\t{\n\t\t\t\t\tConst\t   *val = castNode(Const, lfirst(c));\n\t\t\t\t\tPartitionListValue *list_value = NULL;\n\n\t\t\t\t\tif (!val->constisnull)\n\t\t\t\t\t{\n\t\t\t\t\t\tlist_value = (PartitionListValue *)\n\t\t\t\t\t\t\tpalloc0(sizeof(PartitionListValue));\n\t\t\t\t\t\tlist_value->index = i;\n\t\t\t\t\t\tlist_value->value = val->constvalue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Never put a null into the values array, flag\n\t\t\t\t\t\t * instead for the code further down below where we\n\t\t\t\t\t\t * construct the actual relcache struct.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (null_index != -1)\n\t\t\t\t\t\t\telog(ERROR, \"found null more than once\");\n\t\t\t\t\t\tnull_index = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (list_value)\n\t\t\t\t\t\tnon_null_values = lappend(non_null_values,\n\t\t\t\t\t\t\t\t\t\t\t\t  list_value);\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tndatums = list_length(non_null_values);\n\n\t\t\t/*\n\t\t\t * Collect all list values in one array. Alongside the value, we\n\t\t\t * also save the index of partition the value comes from.\n\t\t\t */\n\t\t\tall_values = (PartitionListValue **) palloc(ndatums *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(PartitionListValue *));\n\t\t\ti = 0;\n\t\t\tforeach(cell, non_null_values)\n\t\t\t{\n\t\t\t\tPartitionListValue *src = lfirst(cell);\n\n\t\t\t\tall_values[i] = (PartitionListValue *)\n\t\t\t\t\tpalloc(sizeof(PartitionListValue));\n\t\t\t\tall_values[i]->value = src->value;\n\t\t\t\tall_values[i]->index = src->index;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tqsort_arg(all_values, ndatums, sizeof(PartitionListValue *),\n\t\t\t\t\t  qsort_partition_list_value_cmp, (void *) key);\n\t\t}\n\t\telse if (key->strategy == PARTITION_STRATEGY_RANGE)\n\t\t{\n\t\t\tint\t\t\tk;\n\t\t\tPartitionRangeBound **all_bounds,\n\t\t\t\t\t   *prev;\n\n\t\t\tall_bounds = (PartitionRangeBound **) palloc0(2 * nparts *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(PartitionRangeBound *));\n\n\t\t\t/*\n\t\t\t * Create a unified list of range bounds across all the\n\t\t\t * partitions.\n\t\t\t */\n\t\t\ti = ndatums = 0;\n\t\t\tforeach(cell, boundspecs)\n\t\t\t{\n\t\t\t\tPartitionBoundSpec *spec = castNode(PartitionBoundSpec,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlfirst(cell));\n\t\t\t\tPartitionRangeBound *lower,\n\t\t\t\t\t\t   *upper;\n\n\t\t\t\tif (spec->strategy != PARTITION_STRATEGY_RANGE)\n\t\t\t\t\telog(ERROR, \"invalid strategy in partition bound spec\");\n\n\t\t\t\t/*\n\t\t\t\t * Note the index of the partition bound spec for the default\n\t\t\t\t * partition. There's no datum to add to the allbounds array\n\t\t\t\t * for this partition.\n\t\t\t\t */\n\t\t\t\tif (spec->is_default)\n\t\t\t\t{\n\t\t\t\t\tdefault_index = i++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlower = make_one_partition_rbound(key, i, spec->lowerdatums,\n\t\t\t\t\t\t\t\t\t\t\t\t  true);\n\t\t\t\tupper = make_one_partition_rbound(key, i, spec->upperdatums,\n\t\t\t\t\t\t\t\t\t\t\t\t  false);\n\t\t\t\tall_bounds[ndatums++] = lower;\n\t\t\t\tall_bounds[ndatums++] = upper;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tAssert(ndatums == nparts * 2 ||\n\t\t\t\t   (default_index != -1 && ndatums == (nparts - 1) * 2));\n\n\t\t\t/* Sort all the bounds in ascending order */\n\t\t\tqsort_arg(all_bounds, ndatums,\n\t\t\t\t\t  sizeof(PartitionRangeBound *),\n\t\t\t\t\t  qsort_partition_rbound_cmp,\n\t\t\t\t\t  (void *) key);\n\n\t\t\t/* Save distinct bounds from all_bounds into rbounds. */\n\t\t\trbounds = (PartitionRangeBound **)\n\t\t\t\tpalloc(ndatums * sizeof(PartitionRangeBound *));\n\t\t\tk = 0;\n\t\t\tprev = NULL;\n\t\t\tfor (i = 0; i < ndatums; i++)\n\t\t\t{\n\t\t\t\tPartitionRangeBound *cur = all_bounds[i];\n\t\t\t\tbool\t\tis_distinct = false;\n\t\t\t\tint\t\t\tj;\n\n\t\t\t\t/* Is the current bound distinct from the previous one? */\n\t\t\t\tfor (j = 0; j < key->partnatts; j++)\n\t\t\t\t{\n\t\t\t\t\tDatum\t\tcmpval;\n\n\t\t\t\t\tif (prev == NULL || cur->kind[j] != prev->kind[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tis_distinct = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If the bounds are both MINVALUE or MAXVALUE, stop now\n\t\t\t\t\t * and treat them as equal, since any values after this\n\t\t\t\t\t * point must be ignored.\n\t\t\t\t\t */\n\t\t\t\t\tif (cur->kind[j] != PARTITION_RANGE_DATUM_VALUE)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcmpval = FunctionCall2Coll(&key->partsupfunc[j],\n\t\t\t\t\t\t\t\t\t\t\t   key->partcollation[j],\n\t\t\t\t\t\t\t\t\t\t\t   cur->datums[j],\n\t\t\t\t\t\t\t\t\t\t\t   prev->datums[j]);\n\t\t\t\t\tif (DatumGetInt32(cmpval) != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tis_distinct = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Only if the bound is distinct save it into a temporary\n\t\t\t\t * array i.e. rbounds which is later copied into boundinfo\n\t\t\t\t * datums array.\n\t\t\t\t */\n\t\t\t\tif (is_distinct)\n\t\t\t\t\trbounds[k++] = all_bounds[i];\n\n\t\t\t\tprev = cur;\n\t\t\t}\n\n\t\t\t/* Update ndatums to hold the count of distinct datums. */\n\t\t\tndatums = k;\n\t\t}\n\t\telse\n\t\t\telog(ERROR, \"unexpected partition strategy: %d\",\n\t\t\t\t (int) key->strategy);\n\t}\n\n\t/* Assert we aren't about to leak any old data structure */\n\tAssert(rel->rd_pdcxt == NULL);\n\tAssert(rel->rd_partdesc == NULL);\n\n\t/*\n\t * Now build the actual relcache partition descriptor.  Note that the\n\t * order of operations here is fairly critical.  If we fail partway\n\t * through this code, we won't have leaked memory because the rd_pdcxt is\n\t * attached to the relcache entry immediately, so it'll be freed whenever\n\t * the entry is rebuilt or destroyed.  However, we don't assign to\n\t * rd_partdesc until the cached data structure is fully complete and\n\t * valid, so that no other code might try to use it.\n\t */\n\trel->rd_pdcxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t  \"partition descriptor\",\n\t\t\t\t\t\t\t\t\t\t  ALLOCSET_SMALL_SIZES);\n\tMemoryContextCopyAndSetIdentifier(rel->rd_pdcxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(rel));\n\n\toldcxt = MemoryContextSwitchTo(rel->rd_pdcxt);\n\n\tresult = (PartitionDescData *) palloc0(sizeof(PartitionDescData));\n\tresult->nparts = nparts;\n\tif (nparts > 0)\n\t{\n\t\tPartitionBoundInfo boundinfo;\n\t\tint\t\t   *mapping;\n\t\tint\t\t\tnext_index = 0;\n\n\t\tresult->oids = (Oid *) palloc0(nparts * sizeof(Oid));\n\n\t\tboundinfo = (PartitionBoundInfoData *)\n\t\t\tpalloc0(sizeof(PartitionBoundInfoData));\n\t\tboundinfo->strategy = key->strategy;\n\t\tboundinfo->default_index = -1;\n\t\tboundinfo->ndatums = ndatums;\n\t\tboundinfo->null_index = -1;\n\t\tboundinfo->datums = (Datum **) palloc0(ndatums * sizeof(Datum *));\n\n\t\t/* Initialize mapping array with invalid values */\n\t\tmapping = (int *) palloc(sizeof(int) * nparts);\n\t\tfor (i = 0; i < nparts; i++)\n\t\t\tmapping[i] = -1;\n\n\t\tswitch (key->strategy)\n\t\t{\n\t\t\tcase PARTITION_STRATEGY_HASH:\n\t\t\t\t{\n\t\t\t\t\t/* Moduli are stored in ascending order */\n\t\t\t\t\tint\t\t\tgreatest_modulus = hbounds[ndatums - 1]->modulus;\n\n\t\t\t\t\tboundinfo->indexes = (int *) palloc(greatest_modulus *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int));\n\n\t\t\t\t\tfor (i = 0; i < greatest_modulus; i++)\n\t\t\t\t\t\tboundinfo->indexes[i] = -1;\n\n\t\t\t\t\tfor (i = 0; i < nparts; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\tmodulus = hbounds[i]->modulus;\n\t\t\t\t\t\tint\t\t\tremainder = hbounds[i]->remainder;\n\n\t\t\t\t\t\tboundinfo->datums[i] = (Datum *) palloc(2 *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(Datum));\n\t\t\t\t\t\tboundinfo->datums[i][0] = Int32GetDatum(modulus);\n\t\t\t\t\t\tboundinfo->datums[i][1] = Int32GetDatum(remainder);\n\n\t\t\t\t\t\twhile (remainder < greatest_modulus)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* overlap? */\n\t\t\t\t\t\t\tAssert(boundinfo->indexes[remainder] == -1);\n\t\t\t\t\t\t\tboundinfo->indexes[remainder] = i;\n\t\t\t\t\t\t\tremainder += modulus;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmapping[hbounds[i]->index] = i;\n\t\t\t\t\t\tpfree(hbounds[i]);\n\t\t\t\t\t}\n\t\t\t\t\tpfree(hbounds);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase PARTITION_STRATEGY_LIST:\n\t\t\t\t{\n\t\t\t\t\tboundinfo->indexes = (int *) palloc(ndatums * sizeof(int));\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Copy values.  Indexes of individual values are mapped\n\t\t\t\t\t * to canonical values so that they match for any two list\n\t\t\t\t\t * partitioned tables with same number of partitions and\n\t\t\t\t\t * same lists per partition.  One way to canonicalize is\n\t\t\t\t\t * to assign the index in all_values[] of the smallest\n\t\t\t\t\t * value of each partition, as the index of all of the\n\t\t\t\t\t * partition's values.\n\t\t\t\t\t */\n\t\t\t\t\tfor (i = 0; i < ndatums; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tboundinfo->datums[i] = (Datum *) palloc(sizeof(Datum));\n\t\t\t\t\t\tboundinfo->datums[i][0] = datumCopy(all_values[i]->value,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey->parttypbyval[0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tkey->parttyplen[0]);\n\n\t\t\t\t\t\t/* If the old index has no mapping, assign one */\n\t\t\t\t\t\tif (mapping[all_values[i]->index] == -1)\n\t\t\t\t\t\t\tmapping[all_values[i]->index] = next_index++;\n\n\t\t\t\t\t\tboundinfo->indexes[i] = mapping[all_values[i]->index];\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If null-accepting partition has no mapped index yet,\n\t\t\t\t\t * assign one.  This could happen if such partition\n\t\t\t\t\t * accepts only null and hence not covered in the above\n\t\t\t\t\t * loop which only handled non-null values.\n\t\t\t\t\t */\n\t\t\t\t\tif (null_index != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert(null_index >= 0);\n\t\t\t\t\t\tif (mapping[null_index] == -1)\n\t\t\t\t\t\t\tmapping[null_index] = next_index++;\n\t\t\t\t\t\tboundinfo->null_index = mapping[null_index];\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Assign mapped index for the default partition. */\n\t\t\t\t\tif (default_index != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The default partition accepts any value not\n\t\t\t\t\t\t * specified in the lists of other partitions, hence\n\t\t\t\t\t\t * it should not get mapped index while assigning\n\t\t\t\t\t\t * those for non-null datums.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tAssert(default_index >= 0 &&\n\t\t\t\t\t\t\t   mapping[default_index] == -1);\n\t\t\t\t\t\tmapping[default_index] = next_index++;\n\t\t\t\t\t\tboundinfo->default_index = mapping[default_index];\n\t\t\t\t\t}\n\n\t\t\t\t\t/* All partition must now have a valid mapping */\n\t\t\t\t\tAssert(next_index == nparts);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase PARTITION_STRATEGY_RANGE:\n\t\t\t\t{\n\t\t\t\t\tboundinfo->kind = (PartitionRangeDatumKind **)\n\t\t\t\t\t\tpalloc(ndatums *\n\t\t\t\t\t\t\t   sizeof(PartitionRangeDatumKind *));\n\t\t\t\t\tboundinfo->indexes = (int *) palloc((ndatums + 1) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(int));\n\n\t\t\t\t\tfor (i = 0; i < ndatums; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint\t\t\tj;\n\n\t\t\t\t\t\tboundinfo->datums[i] = (Datum *) palloc(key->partnatts *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(Datum));\n\t\t\t\t\t\tboundinfo->kind[i] = (PartitionRangeDatumKind *)\n\t\t\t\t\t\t\tpalloc(key->partnatts *\n\t\t\t\t\t\t\t\t   sizeof(PartitionRangeDatumKind));\n\t\t\t\t\t\tfor (j = 0; j < key->partnatts; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (rbounds[i]->kind[j] == PARTITION_RANGE_DATUM_VALUE)\n\t\t\t\t\t\t\t\tboundinfo->datums[i][j] =\n\t\t\t\t\t\t\t\t\tdatumCopy(rbounds[i]->datums[j],\n\t\t\t\t\t\t\t\t\t\t\t  key->parttypbyval[j],\n\t\t\t\t\t\t\t\t\t\t\t  key->parttyplen[j]);\n\t\t\t\t\t\t\tboundinfo->kind[i][j] = rbounds[i]->kind[j];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * There is no mapping for invalid indexes.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Any lower bounds in the rbounds array have invalid\n\t\t\t\t\t\t * indexes assigned, because the values between the\n\t\t\t\t\t\t * previous bound (if there is one) and this (lower)\n\t\t\t\t\t\t * bound are not part of the range of any existing\n\t\t\t\t\t\t * partition.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (rbounds[i]->lower)\n\t\t\t\t\t\t\tboundinfo->indexes[i] = -1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint\t\t\torig_index = rbounds[i]->index;\n\n\t\t\t\t\t\t\t/* If the old index has no mapping, assign one */\n\t\t\t\t\t\t\tif (mapping[orig_index] == -1)\n\t\t\t\t\t\t\t\tmapping[orig_index] = next_index++;\n\n\t\t\t\t\t\t\tboundinfo->indexes[i] = mapping[orig_index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Assign mapped index for the default partition. */\n\t\t\t\t\tif (default_index != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert(default_index >= 0 && mapping[default_index] == -1);\n\t\t\t\t\t\tmapping[default_index] = next_index++;\n\t\t\t\t\t\tboundinfo->default_index = mapping[default_index];\n\t\t\t\t\t}\n\t\t\t\t\tboundinfo->indexes[i] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected partition strategy: %d\",\n\t\t\t\t\t (int) key->strategy);\n\t\t}\n\n\t\tresult->boundinfo = boundinfo;\n\n\t\t/*\n\t\t * Now assign OIDs from the original array into mapped indexes of the\n\t\t * result array.  Order of OIDs in the former is defined by the\n\t\t * catalog scan that retrieved them, whereas that in the latter is\n\t\t * defined by canonicalized representation of the partition bounds.\n\t\t */\n\t\tfor (i = 0; i < nparts; i++)\n\t\t\tresult->oids[mapping[i]] = oids[i];\n\t\tpfree(mapping);\n\t}\n\n\tMemoryContextSwitchTo(oldcxt);\n\trel->rd_partdesc = result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationBuildPartitionKey",
          "args": [
            "relation"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "RelationBuildPartitionKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/partcache.c",
          "lines": "63-254",
          "snippet": "void\nRelationBuildPartitionKey(Relation relation)\n{\n\tForm_pg_partitioned_table form;\n\tHeapTuple\ttuple;\n\tbool\t\tisnull;\n\tint\t\t\ti;\n\tPartitionKey key;\n\tAttrNumber *attrs;\n\toidvector  *opclass;\n\toidvector  *collation;\n\tListCell   *partexprs_item;\n\tDatum\t\tdatum;\n\tMemoryContext partkeycxt,\n\t\t\t\toldcxt;\n\tint16\t\tprocnum;\n\n\ttuple = SearchSysCache1(PARTRELID,\n\t\t\t\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\t/*\n\t * The following happens when we have created our pg_class entry but not\n\t * the pg_partitioned_table entry yet.\n\t */\n\tif (!HeapTupleIsValid(tuple))\n\t\treturn;\n\n\tpartkeycxt = AllocSetContextCreate(CurTransactionContext,\n\t\t\t\t\t\t\t\t\t   \"partition key\",\n\t\t\t\t\t\t\t\t\t   ALLOCSET_SMALL_SIZES);\n\tMemoryContextCopyAndSetIdentifier(partkeycxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(relation));\n\n\tkey = (PartitionKey) MemoryContextAllocZero(partkeycxt,\n\t\t\t\t\t\t\t\t\t\t\t\tsizeof(PartitionKeyData));\n\n\t/* Fixed-length attributes */\n\tform = (Form_pg_partitioned_table) GETSTRUCT(tuple);\n\tkey->strategy = form->partstrat;\n\tkey->partnatts = form->partnatts;\n\n\t/*\n\t * We can rely on the first variable-length attribute being mapped to the\n\t * relevant field of the catalog's C struct, because all previous\n\t * attributes are non-nullable and fixed-length.\n\t */\n\tattrs = form->partattrs.values;\n\n\t/* But use the hard way to retrieve further variable-length attributes */\n\t/* Operator class */\n\tdatum = SysCacheGetAttr(PARTRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_partitioned_table_partclass, &isnull);\n\tAssert(!isnull);\n\topclass = (oidvector *) DatumGetPointer(datum);\n\n\t/* Collation */\n\tdatum = SysCacheGetAttr(PARTRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_partitioned_table_partcollation, &isnull);\n\tAssert(!isnull);\n\tcollation = (oidvector *) DatumGetPointer(datum);\n\n\t/* Expressions */\n\tdatum = SysCacheGetAttr(PARTRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_partitioned_table_partexprs, &isnull);\n\tif (!isnull)\n\t{\n\t\tchar\t   *exprString;\n\t\tNode\t   *expr;\n\n\t\texprString = TextDatumGetCString(datum);\n\t\texpr = stringToNode(exprString);\n\t\tpfree(exprString);\n\n\t\t/*\n\t\t * Run the expressions through const-simplification since the planner\n\t\t * will be comparing them to similarly-processed qual clause operands,\n\t\t * and may fail to detect valid matches without this step; fix\n\t\t * opfuncids while at it.  We don't need to bother with\n\t\t * canonicalize_qual() though, because partition expressions should be\n\t\t * in canonical form already (ie, no need for OR-merging or constant\n\t\t * elimination).\n\t\t */\n\t\texpr = eval_const_expressions(NULL, expr);\n\t\tfix_opfuncids(expr);\n\n\t\toldcxt = MemoryContextSwitchTo(partkeycxt);\n\t\tkey->partexprs = (List *) copyObject(expr);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/* Allocate assorted arrays in the partkeycxt, which we'll fill below */\n\toldcxt = MemoryContextSwitchTo(partkeycxt);\n\tkey->partattrs = (AttrNumber *) palloc0(key->partnatts * sizeof(AttrNumber));\n\tkey->partopfamily = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->partopcintype = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->partsupfunc = (FmgrInfo *) palloc0(key->partnatts * sizeof(FmgrInfo));\n\n\tkey->partcollation = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->parttypid = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->parttypmod = (int32 *) palloc0(key->partnatts * sizeof(int32));\n\tkey->parttyplen = (int16 *) palloc0(key->partnatts * sizeof(int16));\n\tkey->parttypbyval = (bool *) palloc0(key->partnatts * sizeof(bool));\n\tkey->parttypalign = (char *) palloc0(key->partnatts * sizeof(char));\n\tkey->parttypcoll = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* determine support function number to search for */\n\tprocnum = (key->strategy == PARTITION_STRATEGY_HASH) ?\n\t\tHASHEXTENDED_PROC : BTORDER_PROC;\n\n\t/* Copy partattrs and fill other per-attribute info */\n\tmemcpy(key->partattrs, attrs, key->partnatts * sizeof(int16));\n\tpartexprs_item = list_head(key->partexprs);\n\tfor (i = 0; i < key->partnatts; i++)\n\t{\n\t\tAttrNumber\tattno = key->partattrs[i];\n\t\tHeapTuple\topclasstup;\n\t\tForm_pg_opclass opclassform;\n\t\tOid\t\t\tfuncid;\n\n\t\t/* Collect opfamily information */\n\t\topclasstup = SearchSysCache1(CLAOID,\n\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(opclass->values[i]));\n\t\tif (!HeapTupleIsValid(opclasstup))\n\t\t\telog(ERROR, \"cache lookup failed for opclass %u\", opclass->values[i]);\n\n\t\topclassform = (Form_pg_opclass) GETSTRUCT(opclasstup);\n\t\tkey->partopfamily[i] = opclassform->opcfamily;\n\t\tkey->partopcintype[i] = opclassform->opcintype;\n\n\t\t/* Get a support function for the specified opfamily and datatypes */\n\t\tfuncid = get_opfamily_proc(opclassform->opcfamily,\n\t\t\t\t\t\t\t\t   opclassform->opcintype,\n\t\t\t\t\t\t\t\t   opclassform->opcintype,\n\t\t\t\t\t\t\t\t   procnum);\n\t\tif (!OidIsValid(funcid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t\t errmsg(\"operator class \\\"%s\\\" of access method %s is missing support function %d for type %s\",\n\t\t\t\t\t\t\tNameStr(opclassform->opcname),\n\t\t\t\t\t\t\t(key->strategy == PARTITION_STRATEGY_HASH) ?\n\t\t\t\t\t\t\t\"hash\" : \"btree\",\n\t\t\t\t\t\t\tprocnum,\n\t\t\t\t\t\t\tformat_type_be(opclassform->opcintype))));\n\n\t\tfmgr_info_cxt(funcid, &key->partsupfunc[i], partkeycxt);\n\n\t\t/* Collation */\n\t\tkey->partcollation[i] = collation->values[i];\n\n\t\t/* Collect type information */\n\t\tif (attno != 0)\n\t\t{\n\t\t\tForm_pg_attribute att = TupleDescAttr(relation->rd_att, attno - 1);\n\n\t\t\tkey->parttypid[i] = att->atttypid;\n\t\t\tkey->parttypmod[i] = att->atttypmod;\n\t\t\tkey->parttypcoll[i] = att->attcollation;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (partexprs_item == NULL)\n\t\t\t\telog(ERROR, \"wrong number of partition key expressions\");\n\n\t\t\tkey->parttypid[i] = exprType(lfirst(partexprs_item));\n\t\t\tkey->parttypmod[i] = exprTypmod(lfirst(partexprs_item));\n\t\t\tkey->parttypcoll[i] = exprCollation(lfirst(partexprs_item));\n\n\t\t\tpartexprs_item = lnext(partexprs_item);\n\t\t}\n\t\tget_typlenbyvalalign(key->parttypid[i],\n\t\t\t\t\t\t\t &key->parttyplen[i],\n\t\t\t\t\t\t\t &key->parttypbyval[i],\n\t\t\t\t\t\t\t &key->parttypalign[i]);\n\n\t\tReleaseSysCache(opclasstup);\n\t}\n\n\tReleaseSysCache(tuple);\n\n\t/* Assert that we're not leaking any old data during assignments below */\n\tAssert(relation->rd_partkeycxt == NULL);\n\tAssert(relation->rd_partkey == NULL);\n\n\t/*\n\t * Success --- reparent our context and make the relcache point to the\n\t * newly constructed key\n\t */\n\tMemoryContextSetParent(partkeycxt, CacheMemoryContext);\n\trelation->rd_partkeycxt = partkeycxt;\n\trelation->rd_partkey = key;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/planner.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_inherits.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/planner.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_inherits.h\"\n#include \"catalog/partition.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nRelationBuildPartitionKey(Relation relation)\n{\n\tForm_pg_partitioned_table form;\n\tHeapTuple\ttuple;\n\tbool\t\tisnull;\n\tint\t\t\ti;\n\tPartitionKey key;\n\tAttrNumber *attrs;\n\toidvector  *opclass;\n\toidvector  *collation;\n\tListCell   *partexprs_item;\n\tDatum\t\tdatum;\n\tMemoryContext partkeycxt,\n\t\t\t\toldcxt;\n\tint16\t\tprocnum;\n\n\ttuple = SearchSysCache1(PARTRELID,\n\t\t\t\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\t/*\n\t * The following happens when we have created our pg_class entry but not\n\t * the pg_partitioned_table entry yet.\n\t */\n\tif (!HeapTupleIsValid(tuple))\n\t\treturn;\n\n\tpartkeycxt = AllocSetContextCreate(CurTransactionContext,\n\t\t\t\t\t\t\t\t\t   \"partition key\",\n\t\t\t\t\t\t\t\t\t   ALLOCSET_SMALL_SIZES);\n\tMemoryContextCopyAndSetIdentifier(partkeycxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(relation));\n\n\tkey = (PartitionKey) MemoryContextAllocZero(partkeycxt,\n\t\t\t\t\t\t\t\t\t\t\t\tsizeof(PartitionKeyData));\n\n\t/* Fixed-length attributes */\n\tform = (Form_pg_partitioned_table) GETSTRUCT(tuple);\n\tkey->strategy = form->partstrat;\n\tkey->partnatts = form->partnatts;\n\n\t/*\n\t * We can rely on the first variable-length attribute being mapped to the\n\t * relevant field of the catalog's C struct, because all previous\n\t * attributes are non-nullable and fixed-length.\n\t */\n\tattrs = form->partattrs.values;\n\n\t/* But use the hard way to retrieve further variable-length attributes */\n\t/* Operator class */\n\tdatum = SysCacheGetAttr(PARTRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_partitioned_table_partclass, &isnull);\n\tAssert(!isnull);\n\topclass = (oidvector *) DatumGetPointer(datum);\n\n\t/* Collation */\n\tdatum = SysCacheGetAttr(PARTRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_partitioned_table_partcollation, &isnull);\n\tAssert(!isnull);\n\tcollation = (oidvector *) DatumGetPointer(datum);\n\n\t/* Expressions */\n\tdatum = SysCacheGetAttr(PARTRELID, tuple,\n\t\t\t\t\t\t\tAnum_pg_partitioned_table_partexprs, &isnull);\n\tif (!isnull)\n\t{\n\t\tchar\t   *exprString;\n\t\tNode\t   *expr;\n\n\t\texprString = TextDatumGetCString(datum);\n\t\texpr = stringToNode(exprString);\n\t\tpfree(exprString);\n\n\t\t/*\n\t\t * Run the expressions through const-simplification since the planner\n\t\t * will be comparing them to similarly-processed qual clause operands,\n\t\t * and may fail to detect valid matches without this step; fix\n\t\t * opfuncids while at it.  We don't need to bother with\n\t\t * canonicalize_qual() though, because partition expressions should be\n\t\t * in canonical form already (ie, no need for OR-merging or constant\n\t\t * elimination).\n\t\t */\n\t\texpr = eval_const_expressions(NULL, expr);\n\t\tfix_opfuncids(expr);\n\n\t\toldcxt = MemoryContextSwitchTo(partkeycxt);\n\t\tkey->partexprs = (List *) copyObject(expr);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t}\n\n\t/* Allocate assorted arrays in the partkeycxt, which we'll fill below */\n\toldcxt = MemoryContextSwitchTo(partkeycxt);\n\tkey->partattrs = (AttrNumber *) palloc0(key->partnatts * sizeof(AttrNumber));\n\tkey->partopfamily = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->partopcintype = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->partsupfunc = (FmgrInfo *) palloc0(key->partnatts * sizeof(FmgrInfo));\n\n\tkey->partcollation = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->parttypid = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tkey->parttypmod = (int32 *) palloc0(key->partnatts * sizeof(int32));\n\tkey->parttyplen = (int16 *) palloc0(key->partnatts * sizeof(int16));\n\tkey->parttypbyval = (bool *) palloc0(key->partnatts * sizeof(bool));\n\tkey->parttypalign = (char *) palloc0(key->partnatts * sizeof(char));\n\tkey->parttypcoll = (Oid *) palloc0(key->partnatts * sizeof(Oid));\n\tMemoryContextSwitchTo(oldcxt);\n\n\t/* determine support function number to search for */\n\tprocnum = (key->strategy == PARTITION_STRATEGY_HASH) ?\n\t\tHASHEXTENDED_PROC : BTORDER_PROC;\n\n\t/* Copy partattrs and fill other per-attribute info */\n\tmemcpy(key->partattrs, attrs, key->partnatts * sizeof(int16));\n\tpartexprs_item = list_head(key->partexprs);\n\tfor (i = 0; i < key->partnatts; i++)\n\t{\n\t\tAttrNumber\tattno = key->partattrs[i];\n\t\tHeapTuple\topclasstup;\n\t\tForm_pg_opclass opclassform;\n\t\tOid\t\t\tfuncid;\n\n\t\t/* Collect opfamily information */\n\t\topclasstup = SearchSysCache1(CLAOID,\n\t\t\t\t\t\t\t\t\t ObjectIdGetDatum(opclass->values[i]));\n\t\tif (!HeapTupleIsValid(opclasstup))\n\t\t\telog(ERROR, \"cache lookup failed for opclass %u\", opclass->values[i]);\n\n\t\topclassform = (Form_pg_opclass) GETSTRUCT(opclasstup);\n\t\tkey->partopfamily[i] = opclassform->opcfamily;\n\t\tkey->partopcintype[i] = opclassform->opcintype;\n\n\t\t/* Get a support function for the specified opfamily and datatypes */\n\t\tfuncid = get_opfamily_proc(opclassform->opcfamily,\n\t\t\t\t\t\t\t\t   opclassform->opcintype,\n\t\t\t\t\t\t\t\t   opclassform->opcintype,\n\t\t\t\t\t\t\t\t   procnum);\n\t\tif (!OidIsValid(funcid))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_OBJECT_DEFINITION),\n\t\t\t\t\t errmsg(\"operator class \\\"%s\\\" of access method %s is missing support function %d for type %s\",\n\t\t\t\t\t\t\tNameStr(opclassform->opcname),\n\t\t\t\t\t\t\t(key->strategy == PARTITION_STRATEGY_HASH) ?\n\t\t\t\t\t\t\t\"hash\" : \"btree\",\n\t\t\t\t\t\t\tprocnum,\n\t\t\t\t\t\t\tformat_type_be(opclassform->opcintype))));\n\n\t\tfmgr_info_cxt(funcid, &key->partsupfunc[i], partkeycxt);\n\n\t\t/* Collation */\n\t\tkey->partcollation[i] = collation->values[i];\n\n\t\t/* Collect type information */\n\t\tif (attno != 0)\n\t\t{\n\t\t\tForm_pg_attribute att = TupleDescAttr(relation->rd_att, attno - 1);\n\n\t\t\tkey->parttypid[i] = att->atttypid;\n\t\t\tkey->parttypmod[i] = att->atttypmod;\n\t\t\tkey->parttypcoll[i] = att->attcollation;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (partexprs_item == NULL)\n\t\t\t\telog(ERROR, \"wrong number of partition key expressions\");\n\n\t\t\tkey->parttypid[i] = exprType(lfirst(partexprs_item));\n\t\t\tkey->parttypmod[i] = exprTypmod(lfirst(partexprs_item));\n\t\t\tkey->parttypcoll[i] = exprCollation(lfirst(partexprs_item));\n\n\t\t\tpartexprs_item = lnext(partexprs_item);\n\t\t}\n\t\tget_typlenbyvalalign(key->parttypid[i],\n\t\t\t\t\t\t\t &key->parttyplen[i],\n\t\t\t\t\t\t\t &key->parttypbyval[i],\n\t\t\t\t\t\t\t &key->parttypalign[i]);\n\n\t\tReleaseSysCache(opclasstup);\n\t}\n\n\tReleaseSysCache(tuple);\n\n\t/* Assert that we're not leaking any old data during assignments below */\n\tAssert(relation->rd_partkeycxt == NULL);\n\tAssert(relation->rd_partkey == NULL);\n\n\t/*\n\t * Success --- reparent our context and make the relcache point to the\n\t * newly constructed key\n\t */\n\tMemoryContextSetParent(partkeycxt, CacheMemoryContext);\n\trelation->rd_partkeycxt = partkeycxt;\n\trelation->rd_partkey = key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationBuildRowSecurity",
          "args": [
            "relation"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationBuildTriggers",
          "args": [
            "relation"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationBuildRuleLock",
          "args": [
            "relation"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "RelationBuildRuleLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "723-875",
          "snippet": "static void\nRelationBuildRuleLock(Relation relation)\n{\n\tMemoryContext rulescxt;\n\tMemoryContext oldcxt;\n\tHeapTuple\trewrite_tuple;\n\tRelation\trewrite_desc;\n\tTupleDesc\trewrite_tupdesc;\n\tSysScanDesc rewrite_scan;\n\tScanKeyData key;\n\tRuleLock   *rulelock;\n\tint\t\t\tnumlocks;\n\tRewriteRule **rules;\n\tint\t\t\tmaxlocks;\n\n\t/*\n\t * Make the private context.  Assume it'll not contain much data.\n\t */\n\trulescxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t \"relation rules\",\n\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\trelation->rd_rulescxt = rulescxt;\n\tMemoryContextCopyAndSetIdentifier(rulescxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(relation));\n\n\t/*\n\t * allocate an array to hold the rewrite rules (the array is extended if\n\t * necessary)\n\t */\n\tmaxlocks = 4;\n\trules = (RewriteRule **)\n\t\tMemoryContextAlloc(rulescxt, sizeof(RewriteRule *) * maxlocks);\n\tnumlocks = 0;\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key,\n\t\t\t\tAnum_pg_rewrite_ev_class,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\t/*\n\t * open pg_rewrite and begin a scan\n\t *\n\t * Note: since we scan the rules using RewriteRelRulenameIndexId, we will\n\t * be reading the rules in name order, except possibly during\n\t * emergency-recovery operations (ie, IgnoreSystemIndexes). This in turn\n\t * ensures that rules will be fired in name order.\n\t */\n\trewrite_desc = heap_open(RewriteRelationId, AccessShareLock);\n\trewrite_tupdesc = RelationGetDescr(rewrite_desc);\n\trewrite_scan = systable_beginscan(rewrite_desc,\n\t\t\t\t\t\t\t\t\t  RewriteRelRulenameIndexId,\n\t\t\t\t\t\t\t\t\t  true, NULL,\n\t\t\t\t\t\t\t\t\t  1, &key);\n\n\twhile (HeapTupleIsValid(rewrite_tuple = systable_getnext(rewrite_scan)))\n\t{\n\t\tForm_pg_rewrite rewrite_form = (Form_pg_rewrite) GETSTRUCT(rewrite_tuple);\n\t\tbool\t\tisnull;\n\t\tDatum\t\trule_datum;\n\t\tchar\t   *rule_str;\n\t\tRewriteRule *rule;\n\n\t\trule = (RewriteRule *) MemoryContextAlloc(rulescxt,\n\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(RewriteRule));\n\n\t\trule->ruleId = HeapTupleGetOid(rewrite_tuple);\n\n\t\trule->event = rewrite_form->ev_type - '0';\n\t\trule->enabled = rewrite_form->ev_enabled;\n\t\trule->isInstead = rewrite_form->is_instead;\n\n\t\t/*\n\t\t * Must use heap_getattr to fetch ev_action and ev_qual.  Also, the\n\t\t * rule strings are often large enough to be toasted.  To avoid\n\t\t * leaking memory in the caller's context, do the detoasting here so\n\t\t * we can free the detoasted version.\n\t\t */\n\t\trule_datum = heap_getattr(rewrite_tuple,\n\t\t\t\t\t\t\t\t  Anum_pg_rewrite_ev_action,\n\t\t\t\t\t\t\t\t  rewrite_tupdesc,\n\t\t\t\t\t\t\t\t  &isnull);\n\t\tAssert(!isnull);\n\t\trule_str = TextDatumGetCString(rule_datum);\n\t\toldcxt = MemoryContextSwitchTo(rulescxt);\n\t\trule->actions = (List *) stringToNode(rule_str);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t\tpfree(rule_str);\n\n\t\trule_datum = heap_getattr(rewrite_tuple,\n\t\t\t\t\t\t\t\t  Anum_pg_rewrite_ev_qual,\n\t\t\t\t\t\t\t\t  rewrite_tupdesc,\n\t\t\t\t\t\t\t\t  &isnull);\n\t\tAssert(!isnull);\n\t\trule_str = TextDatumGetCString(rule_datum);\n\t\toldcxt = MemoryContextSwitchTo(rulescxt);\n\t\trule->qual = (Node *) stringToNode(rule_str);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t\tpfree(rule_str);\n\n\t\t/*\n\t\t * We want the rule's table references to be checked as though by the\n\t\t * table owner, not the user referencing the rule.  Therefore, scan\n\t\t * through the rule's actions and set the checkAsUser field on all\n\t\t * rtable entries.  We have to look at the qual as well, in case it\n\t\t * contains sublinks.\n\t\t *\n\t\t * The reason for doing this when the rule is loaded, rather than when\n\t\t * it is stored, is that otherwise ALTER TABLE OWNER would have to\n\t\t * grovel through stored rules to update checkAsUser fields. Scanning\n\t\t * the rule tree during load is relatively cheap (compared to\n\t\t * constructing it in the first place), so we do it here.\n\t\t */\n\t\tsetRuleCheckAsUser((Node *) rule->actions, relation->rd_rel->relowner);\n\t\tsetRuleCheckAsUser(rule->qual, relation->rd_rel->relowner);\n\n\t\tif (numlocks >= maxlocks)\n\t\t{\n\t\t\tmaxlocks *= 2;\n\t\t\trules = (RewriteRule **)\n\t\t\t\trepalloc(rules, sizeof(RewriteRule *) * maxlocks);\n\t\t}\n\t\trules[numlocks++] = rule;\n\t}\n\n\t/*\n\t * end the scan and close the attribute relation\n\t */\n\tsystable_endscan(rewrite_scan);\n\theap_close(rewrite_desc, AccessShareLock);\n\n\t/*\n\t * there might not be any rules (if relhasrules is out-of-date)\n\t */\n\tif (numlocks == 0)\n\t{\n\t\trelation->rd_rules = NULL;\n\t\trelation->rd_rulescxt = NULL;\n\t\tMemoryContextDelete(rulescxt);\n\t\treturn;\n\t}\n\n\t/*\n\t * form a RuleLock and insert into relation\n\t */\n\trulelock = (RuleLock *) MemoryContextAlloc(rulescxt, sizeof(RuleLock));\n\trulelock->numLocks = numlocks;\n\trulelock->rules = rules;\n\n\trelation->rd_rules = rulelock;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationBuildRuleLock(Relation relation)\n{\n\tMemoryContext rulescxt;\n\tMemoryContext oldcxt;\n\tHeapTuple\trewrite_tuple;\n\tRelation\trewrite_desc;\n\tTupleDesc\trewrite_tupdesc;\n\tSysScanDesc rewrite_scan;\n\tScanKeyData key;\n\tRuleLock   *rulelock;\n\tint\t\t\tnumlocks;\n\tRewriteRule **rules;\n\tint\t\t\tmaxlocks;\n\n\t/*\n\t * Make the private context.  Assume it'll not contain much data.\n\t */\n\trulescxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t \"relation rules\",\n\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\trelation->rd_rulescxt = rulescxt;\n\tMemoryContextCopyAndSetIdentifier(rulescxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(relation));\n\n\t/*\n\t * allocate an array to hold the rewrite rules (the array is extended if\n\t * necessary)\n\t */\n\tmaxlocks = 4;\n\trules = (RewriteRule **)\n\t\tMemoryContextAlloc(rulescxt, sizeof(RewriteRule *) * maxlocks);\n\tnumlocks = 0;\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key,\n\t\t\t\tAnum_pg_rewrite_ev_class,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\t/*\n\t * open pg_rewrite and begin a scan\n\t *\n\t * Note: since we scan the rules using RewriteRelRulenameIndexId, we will\n\t * be reading the rules in name order, except possibly during\n\t * emergency-recovery operations (ie, IgnoreSystemIndexes). This in turn\n\t * ensures that rules will be fired in name order.\n\t */\n\trewrite_desc = heap_open(RewriteRelationId, AccessShareLock);\n\trewrite_tupdesc = RelationGetDescr(rewrite_desc);\n\trewrite_scan = systable_beginscan(rewrite_desc,\n\t\t\t\t\t\t\t\t\t  RewriteRelRulenameIndexId,\n\t\t\t\t\t\t\t\t\t  true, NULL,\n\t\t\t\t\t\t\t\t\t  1, &key);\n\n\twhile (HeapTupleIsValid(rewrite_tuple = systable_getnext(rewrite_scan)))\n\t{\n\t\tForm_pg_rewrite rewrite_form = (Form_pg_rewrite) GETSTRUCT(rewrite_tuple);\n\t\tbool\t\tisnull;\n\t\tDatum\t\trule_datum;\n\t\tchar\t   *rule_str;\n\t\tRewriteRule *rule;\n\n\t\trule = (RewriteRule *) MemoryContextAlloc(rulescxt,\n\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(RewriteRule));\n\n\t\trule->ruleId = HeapTupleGetOid(rewrite_tuple);\n\n\t\trule->event = rewrite_form->ev_type - '0';\n\t\trule->enabled = rewrite_form->ev_enabled;\n\t\trule->isInstead = rewrite_form->is_instead;\n\n\t\t/*\n\t\t * Must use heap_getattr to fetch ev_action and ev_qual.  Also, the\n\t\t * rule strings are often large enough to be toasted.  To avoid\n\t\t * leaking memory in the caller's context, do the detoasting here so\n\t\t * we can free the detoasted version.\n\t\t */\n\t\trule_datum = heap_getattr(rewrite_tuple,\n\t\t\t\t\t\t\t\t  Anum_pg_rewrite_ev_action,\n\t\t\t\t\t\t\t\t  rewrite_tupdesc,\n\t\t\t\t\t\t\t\t  &isnull);\n\t\tAssert(!isnull);\n\t\trule_str = TextDatumGetCString(rule_datum);\n\t\toldcxt = MemoryContextSwitchTo(rulescxt);\n\t\trule->actions = (List *) stringToNode(rule_str);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t\tpfree(rule_str);\n\n\t\trule_datum = heap_getattr(rewrite_tuple,\n\t\t\t\t\t\t\t\t  Anum_pg_rewrite_ev_qual,\n\t\t\t\t\t\t\t\t  rewrite_tupdesc,\n\t\t\t\t\t\t\t\t  &isnull);\n\t\tAssert(!isnull);\n\t\trule_str = TextDatumGetCString(rule_datum);\n\t\toldcxt = MemoryContextSwitchTo(rulescxt);\n\t\trule->qual = (Node *) stringToNode(rule_str);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t\tpfree(rule_str);\n\n\t\t/*\n\t\t * We want the rule's table references to be checked as though by the\n\t\t * table owner, not the user referencing the rule.  Therefore, scan\n\t\t * through the rule's actions and set the checkAsUser field on all\n\t\t * rtable entries.  We have to look at the qual as well, in case it\n\t\t * contains sublinks.\n\t\t *\n\t\t * The reason for doing this when the rule is loaded, rather than when\n\t\t * it is stored, is that otherwise ALTER TABLE OWNER would have to\n\t\t * grovel through stored rules to update checkAsUser fields. Scanning\n\t\t * the rule tree during load is relatively cheap (compared to\n\t\t * constructing it in the first place), so we do it here.\n\t\t */\n\t\tsetRuleCheckAsUser((Node *) rule->actions, relation->rd_rel->relowner);\n\t\tsetRuleCheckAsUser(rule->qual, relation->rd_rel->relowner);\n\n\t\tif (numlocks >= maxlocks)\n\t\t{\n\t\t\tmaxlocks *= 2;\n\t\t\trules = (RewriteRule **)\n\t\t\t\trepalloc(rules, sizeof(RewriteRule *) * maxlocks);\n\t\t}\n\t\trules[numlocks++] = rule;\n\t}\n\n\t/*\n\t * end the scan and close the attribute relation\n\t */\n\tsystable_endscan(rewrite_scan);\n\theap_close(rewrite_desc, AccessShareLock);\n\n\t/*\n\t * there might not be any rules (if relhasrules is out-of-date)\n\t */\n\tif (numlocks == 0)\n\t{\n\t\trelation->rd_rules = NULL;\n\t\trelation->rd_rulescxt = NULL;\n\t\tMemoryContextDelete(rulescxt);\n\t\treturn;\n\t}\n\n\t/*\n\t * form a RuleLock and insert into relation\n\t */\n\trulelock = (RuleLock *) MemoryContextAlloc(rulescxt, sizeof(RuleLock));\n\trulelock->numLocks = numlocks;\n\trulelock->rules = rules;\n\n\trelation->rd_rules = rulelock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationBuildTupleDesc",
          "args": [
            "relation"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "RelationBuildTupleDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "491-706",
          "snippet": "static void\nRelationBuildTupleDesc(Relation relation)\n{\n\tHeapTuple\tpg_attribute_tuple;\n\tRelation\tpg_attribute_desc;\n\tSysScanDesc pg_attribute_scan;\n\tScanKeyData skey[2];\n\tint\t\t\tneed;\n\tTupleConstr *constr;\n\tAttrDefault *attrdef = NULL;\n\tAttrMissing *attrmiss = NULL;\n\tint\t\t\tndef = 0;\n\n\t/* copy some fields from pg_class row to rd_att */\n\trelation->rd_att->tdtypeid = relation->rd_rel->reltype;\n\trelation->rd_att->tdtypmod = -1;\t/* unnecessary, but... */\n\trelation->rd_att->tdhasoid = relation->rd_rel->relhasoids;\n\n\tconstr = (TupleConstr *) MemoryContextAlloc(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\tsizeof(TupleConstr));\n\tconstr->has_not_null = false;\n\n\t/*\n\t * Form a scan key that selects only user attributes (attnum > 0).\n\t * (Eliminating system attribute rows at the index level is lots faster\n\t * than fetching them.)\n\t */\n\tScanKeyInit(&skey[0],\n\t\t\t\tAnum_pg_attribute_attrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\tScanKeyInit(&skey[1],\n\t\t\t\tAnum_pg_attribute_attnum,\n\t\t\t\tBTGreaterStrategyNumber, F_INT2GT,\n\t\t\t\tInt16GetDatum(0));\n\n\t/*\n\t * Open pg_attribute and begin a scan.  Force heap scan if we haven't yet\n\t * built the critical relcache entries (this includes initdb and startup\n\t * without a pg_internal.init file).\n\t */\n\tpg_attribute_desc = heap_open(AttributeRelationId, AccessShareLock);\n\tpg_attribute_scan = systable_beginscan(pg_attribute_desc,\n\t\t\t\t\t\t\t\t\t\t   AttributeRelidNumIndexId,\n\t\t\t\t\t\t\t\t\t\t   criticalRelcachesBuilt,\n\t\t\t\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t\t\t\t   2, skey);\n\n\t/*\n\t * add attribute data to relation->rd_att\n\t */\n\tneed = RelationGetNumberOfAttributes(relation);\n\n\twhile (HeapTupleIsValid(pg_attribute_tuple = systable_getnext(pg_attribute_scan)))\n\t{\n\t\tForm_pg_attribute attp;\n\t\tint\t\t\tattnum;\n\n\t\tattp = (Form_pg_attribute) GETSTRUCT(pg_attribute_tuple);\n\n\t\tattnum = attp->attnum;\n\t\tif (attnum <= 0 || attnum > RelationGetNumberOfAttributes(relation))\n\t\t\telog(ERROR, \"invalid attribute number %d for %s\",\n\t\t\t\t attp->attnum, RelationGetRelationName(relation));\n\n\n\t\tmemcpy(TupleDescAttr(relation->rd_att, attnum - 1),\n\t\t\t   attp,\n\t\t\t   ATTRIBUTE_FIXED_PART_SIZE);\n\n\t\t/* Update constraint/default info */\n\t\tif (attp->attnotnull)\n\t\t\tconstr->has_not_null = true;\n\n\t\t/* If the column has a default, fill it into the attrdef array */\n\t\tif (attp->atthasdef)\n\t\t{\n\t\t\tif (attrdef == NULL)\n\t\t\t\tattrdef = (AttrDefault *)\n\t\t\t\t\tMemoryContextAllocZero(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t   RelationGetNumberOfAttributes(relation) *\n\t\t\t\t\t\t\t\t\t\t   sizeof(AttrDefault));\n\t\t\tattrdef[ndef].adnum = attnum;\n\t\t\tattrdef[ndef].adbin = NULL;\n\n\t\t\tndef++;\n\t\t}\n\n\t\t/* Likewise for a missing value */\n\t\tif (attp->atthasmissing)\n\t\t{\n\t\t\tDatum\t\tmissingval;\n\t\t\tbool\t\tmissingNull;\n\n\t\t\t/* Do we have a missing value? */\n\t\t\tmissingval = heap_getattr(pg_attribute_tuple,\n\t\t\t\t\t\t\t\t\t  Anum_pg_attribute_attmissingval,\n\t\t\t\t\t\t\t\t\t  pg_attribute_desc->rd_att,\n\t\t\t\t\t\t\t\t\t  &missingNull);\n\t\t\tif (!missingNull)\n\t\t\t{\n\t\t\t\t/* Yes, fetch from the array */\n\t\t\t\tMemoryContext oldcxt;\n\t\t\t\tbool\t\tis_null;\n\t\t\t\tint\t\t\tone = 1;\n\t\t\t\tDatum\t\tmissval;\n\n\t\t\t\tif (attrmiss == NULL)\n\t\t\t\t\tattrmiss = (AttrMissing *)\n\t\t\t\t\t\tMemoryContextAllocZero(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   relation->rd_rel->relnatts *\n\t\t\t\t\t\t\t\t\t\t\t   sizeof(AttrMissing));\n\n\t\t\t\tmissval = array_get_element(missingval,\n\t\t\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t\t\t&one,\n\t\t\t\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t\t\t\tattp->attlen,\n\t\t\t\t\t\t\t\t\t\t\tattp->attbyval,\n\t\t\t\t\t\t\t\t\t\t\tattp->attalign,\n\t\t\t\t\t\t\t\t\t\t\t&is_null);\n\t\t\t\tAssert(!is_null);\n\t\t\t\tif (attp->attbyval)\n\t\t\t\t{\n\t\t\t\t\t/* for copy by val just copy the datum direct */\n\t\t\t\t\tattrmiss[attnum - 1].am_value = missval;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* otherwise copy in the correct context */\n\t\t\t\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\t\t\t\t\tattrmiss[attnum - 1].am_value = datumCopy(missval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  attp->attbyval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  attp->attlen);\n\t\t\t\t\tMemoryContextSwitchTo(oldcxt);\n\t\t\t\t}\n\t\t\t\tattrmiss[attnum - 1].am_present = true;\n\t\t\t}\n\t\t}\n\t\tneed--;\n\t\tif (need == 0)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * end the scan and close the attribute relation\n\t */\n\tsystable_endscan(pg_attribute_scan);\n\theap_close(pg_attribute_desc, AccessShareLock);\n\n\tif (need != 0)\n\t\telog(ERROR, \"catalog is missing %d attribute(s) for relid %u\",\n\t\t\t need, RelationGetRelid(relation));\n\n\t/*\n\t * The attcacheoff values we read from pg_attribute should all be -1\n\t * (\"unknown\").  Verify this if assert checking is on.  They will be\n\t * computed when and if needed during tuple access.\n\t */\n#ifdef USE_ASSERT_CHECKING\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < RelationGetNumberOfAttributes(relation); i++)\n\t\t\tAssert(TupleDescAttr(relation->rd_att, i)->attcacheoff == -1);\n\t}\n#endif\n\n\t/*\n\t * However, we can easily set the attcacheoff value for the first\n\t * attribute: it must be zero.  This eliminates the need for special cases\n\t * for attnum=1 that used to exist in fastgetattr() and index_getattr().\n\t */\n\tif (RelationGetNumberOfAttributes(relation) > 0)\n\t\tTupleDescAttr(relation->rd_att, 0)->attcacheoff = 0;\n\n\t/*\n\t * Set up constraint/default info\n\t */\n\tif (constr->has_not_null || ndef > 0 ||\n\t\tattrmiss || relation->rd_rel->relchecks)\n\t{\n\t\trelation->rd_att->constr = constr;\n\n\t\tif (ndef > 0)\t\t\t/* DEFAULTs */\n\t\t{\n\t\t\tif (ndef < RelationGetNumberOfAttributes(relation))\n\t\t\t\tconstr->defval = (AttrDefault *)\n\t\t\t\t\trepalloc(attrdef, ndef * sizeof(AttrDefault));\n\t\t\telse\n\t\t\t\tconstr->defval = attrdef;\n\t\t\tconstr->num_defval = ndef;\n\t\t\tAttrDefaultFetch(relation);\n\t\t}\n\t\telse\n\t\t\tconstr->num_defval = 0;\n\n\t\tconstr->missing = attrmiss;\n\n\t\tif (relation->rd_rel->relchecks > 0)\t/* CHECKs */\n\t\t{\n\t\t\tconstr->num_check = relation->rd_rel->relchecks;\n\t\t\tconstr->check = (ConstrCheck *)\n\t\t\t\tMemoryContextAllocZero(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t   constr->num_check * sizeof(ConstrCheck));\n\t\t\tCheckConstraintFetch(relation);\n\t\t}\n\t\telse\n\t\t\tconstr->num_check = 0;\n\t}\n\telse\n\t{\n\t\tpfree(constr);\n\t\trelation->rd_att->constr = NULL;\n\t}\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool\t\tcriticalRelcachesBuilt = false;",
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static List *insert_ordered_oid(List *list, Oid datum);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nbool\t\tcriticalRelcachesBuilt = false;\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic List *insert_ordered_oid(List *list, Oid datum);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationBuildTupleDesc(Relation relation)\n{\n\tHeapTuple\tpg_attribute_tuple;\n\tRelation\tpg_attribute_desc;\n\tSysScanDesc pg_attribute_scan;\n\tScanKeyData skey[2];\n\tint\t\t\tneed;\n\tTupleConstr *constr;\n\tAttrDefault *attrdef = NULL;\n\tAttrMissing *attrmiss = NULL;\n\tint\t\t\tndef = 0;\n\n\t/* copy some fields from pg_class row to rd_att */\n\trelation->rd_att->tdtypeid = relation->rd_rel->reltype;\n\trelation->rd_att->tdtypmod = -1;\t/* unnecessary, but... */\n\trelation->rd_att->tdhasoid = relation->rd_rel->relhasoids;\n\n\tconstr = (TupleConstr *) MemoryContextAlloc(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\tsizeof(TupleConstr));\n\tconstr->has_not_null = false;\n\n\t/*\n\t * Form a scan key that selects only user attributes (attnum > 0).\n\t * (Eliminating system attribute rows at the index level is lots faster\n\t * than fetching them.)\n\t */\n\tScanKeyInit(&skey[0],\n\t\t\t\tAnum_pg_attribute_attrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\tScanKeyInit(&skey[1],\n\t\t\t\tAnum_pg_attribute_attnum,\n\t\t\t\tBTGreaterStrategyNumber, F_INT2GT,\n\t\t\t\tInt16GetDatum(0));\n\n\t/*\n\t * Open pg_attribute and begin a scan.  Force heap scan if we haven't yet\n\t * built the critical relcache entries (this includes initdb and startup\n\t * without a pg_internal.init file).\n\t */\n\tpg_attribute_desc = heap_open(AttributeRelationId, AccessShareLock);\n\tpg_attribute_scan = systable_beginscan(pg_attribute_desc,\n\t\t\t\t\t\t\t\t\t\t   AttributeRelidNumIndexId,\n\t\t\t\t\t\t\t\t\t\t   criticalRelcachesBuilt,\n\t\t\t\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t\t\t\t   2, skey);\n\n\t/*\n\t * add attribute data to relation->rd_att\n\t */\n\tneed = RelationGetNumberOfAttributes(relation);\n\n\twhile (HeapTupleIsValid(pg_attribute_tuple = systable_getnext(pg_attribute_scan)))\n\t{\n\t\tForm_pg_attribute attp;\n\t\tint\t\t\tattnum;\n\n\t\tattp = (Form_pg_attribute) GETSTRUCT(pg_attribute_tuple);\n\n\t\tattnum = attp->attnum;\n\t\tif (attnum <= 0 || attnum > RelationGetNumberOfAttributes(relation))\n\t\t\telog(ERROR, \"invalid attribute number %d for %s\",\n\t\t\t\t attp->attnum, RelationGetRelationName(relation));\n\n\n\t\tmemcpy(TupleDescAttr(relation->rd_att, attnum - 1),\n\t\t\t   attp,\n\t\t\t   ATTRIBUTE_FIXED_PART_SIZE);\n\n\t\t/* Update constraint/default info */\n\t\tif (attp->attnotnull)\n\t\t\tconstr->has_not_null = true;\n\n\t\t/* If the column has a default, fill it into the attrdef array */\n\t\tif (attp->atthasdef)\n\t\t{\n\t\t\tif (attrdef == NULL)\n\t\t\t\tattrdef = (AttrDefault *)\n\t\t\t\t\tMemoryContextAllocZero(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t   RelationGetNumberOfAttributes(relation) *\n\t\t\t\t\t\t\t\t\t\t   sizeof(AttrDefault));\n\t\t\tattrdef[ndef].adnum = attnum;\n\t\t\tattrdef[ndef].adbin = NULL;\n\n\t\t\tndef++;\n\t\t}\n\n\t\t/* Likewise for a missing value */\n\t\tif (attp->atthasmissing)\n\t\t{\n\t\t\tDatum\t\tmissingval;\n\t\t\tbool\t\tmissingNull;\n\n\t\t\t/* Do we have a missing value? */\n\t\t\tmissingval = heap_getattr(pg_attribute_tuple,\n\t\t\t\t\t\t\t\t\t  Anum_pg_attribute_attmissingval,\n\t\t\t\t\t\t\t\t\t  pg_attribute_desc->rd_att,\n\t\t\t\t\t\t\t\t\t  &missingNull);\n\t\t\tif (!missingNull)\n\t\t\t{\n\t\t\t\t/* Yes, fetch from the array */\n\t\t\t\tMemoryContext oldcxt;\n\t\t\t\tbool\t\tis_null;\n\t\t\t\tint\t\t\tone = 1;\n\t\t\t\tDatum\t\tmissval;\n\n\t\t\t\tif (attrmiss == NULL)\n\t\t\t\t\tattrmiss = (AttrMissing *)\n\t\t\t\t\t\tMemoryContextAllocZero(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   relation->rd_rel->relnatts *\n\t\t\t\t\t\t\t\t\t\t\t   sizeof(AttrMissing));\n\n\t\t\t\tmissval = array_get_element(missingval,\n\t\t\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t\t\t&one,\n\t\t\t\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t\t\t\tattp->attlen,\n\t\t\t\t\t\t\t\t\t\t\tattp->attbyval,\n\t\t\t\t\t\t\t\t\t\t\tattp->attalign,\n\t\t\t\t\t\t\t\t\t\t\t&is_null);\n\t\t\t\tAssert(!is_null);\n\t\t\t\tif (attp->attbyval)\n\t\t\t\t{\n\t\t\t\t\t/* for copy by val just copy the datum direct */\n\t\t\t\t\tattrmiss[attnum - 1].am_value = missval;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* otherwise copy in the correct context */\n\t\t\t\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\t\t\t\t\tattrmiss[attnum - 1].am_value = datumCopy(missval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  attp->attbyval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  attp->attlen);\n\t\t\t\t\tMemoryContextSwitchTo(oldcxt);\n\t\t\t\t}\n\t\t\t\tattrmiss[attnum - 1].am_present = true;\n\t\t\t}\n\t\t}\n\t\tneed--;\n\t\tif (need == 0)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * end the scan and close the attribute relation\n\t */\n\tsystable_endscan(pg_attribute_scan);\n\theap_close(pg_attribute_desc, AccessShareLock);\n\n\tif (need != 0)\n\t\telog(ERROR, \"catalog is missing %d attribute(s) for relid %u\",\n\t\t\t need, RelationGetRelid(relation));\n\n\t/*\n\t * The attcacheoff values we read from pg_attribute should all be -1\n\t * (\"unknown\").  Verify this if assert checking is on.  They will be\n\t * computed when and if needed during tuple access.\n\t */\n#ifdef USE_ASSERT_CHECKING\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < RelationGetNumberOfAttributes(relation); i++)\n\t\t\tAssert(TupleDescAttr(relation->rd_att, i)->attcacheoff == -1);\n\t}\n#endif\n\n\t/*\n\t * However, we can easily set the attcacheoff value for the first\n\t * attribute: it must be zero.  This eliminates the need for special cases\n\t * for attnum=1 that used to exist in fastgetattr() and index_getattr().\n\t */\n\tif (RelationGetNumberOfAttributes(relation) > 0)\n\t\tTupleDescAttr(relation->rd_att, 0)->attcacheoff = 0;\n\n\t/*\n\t * Set up constraint/default info\n\t */\n\tif (constr->has_not_null || ndef > 0 ||\n\t\tattrmiss || relation->rd_rel->relchecks)\n\t{\n\t\trelation->rd_att->constr = constr;\n\n\t\tif (ndef > 0)\t\t\t/* DEFAULTs */\n\t\t{\n\t\t\tif (ndef < RelationGetNumberOfAttributes(relation))\n\t\t\t\tconstr->defval = (AttrDefault *)\n\t\t\t\t\trepalloc(attrdef, ndef * sizeof(AttrDefault));\n\t\t\telse\n\t\t\t\tconstr->defval = attrdef;\n\t\t\tconstr->num_defval = ndef;\n\t\t\tAttrDefaultFetch(relation);\n\t\t}\n\t\telse\n\t\t\tconstr->num_defval = 0;\n\n\t\tconstr->missing = attrmiss;\n\n\t\tif (relation->rd_rel->relchecks > 0)\t/* CHECKs */\n\t\t{\n\t\t\tconstr->num_check = relation->rd_rel->relchecks;\n\t\t\tconstr->check = (ConstrCheck *)\n\t\t\t\tMemoryContextAllocZero(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t   constr->num_check * sizeof(ConstrCheck));\n\t\t\tCheckConstraintFetch(relation);\n\t\t}\n\t\telse\n\t\t\tconstr->num_check = 0;\n\t}\n\telse\n\t{\n\t\tpfree(constr);\n\t\trelation->rd_att->constr = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid relpersistence: %c\"",
            "relation->rd_rel->relpersistence"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relation->rd_backend != InvalidBackendId"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTempNamespaceBackendId",
          "args": [
            "relation->rd_rel->relnamespace"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BackendIdForTempRelations",
          "args": [],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isTempOrTempToastNamespace",
          "args": [
            "relation->rd_rel->relnamespace"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocateRelationDesc",
          "args": [
            "relp"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "AllocateRelationDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "378-424",
          "snippet": "static Relation\nAllocateRelationDesc(Form_pg_class relp)\n{\n\tRelation\trelation;\n\tMemoryContext oldcxt;\n\tForm_pg_class relationForm;\n\n\t/* Relcache entries must live in CacheMemoryContext */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * allocate and zero space for new relation descriptor\n\t */\n\trelation = (Relation) palloc0(sizeof(RelationData));\n\n\t/* make sure relation is marked as having no open file yet */\n\trelation->rd_smgr = NULL;\n\n\t/*\n\t * Copy the relation tuple form\n\t *\n\t * We only allocate space for the fixed fields, ie, CLASS_TUPLE_SIZE. The\n\t * variable-length fields (relacl, reloptions) are NOT stored in the\n\t * relcache --- there'd be little point in it, since we don't copy the\n\t * tuple's nulls bitmap and hence wouldn't know if the values are valid.\n\t * Bottom line is that relacl *cannot* be retrieved from the relcache. Get\n\t * it from the syscache if you need it.  The same goes for the original\n\t * form of reloptions (however, we do store the parsed form of reloptions\n\t * in rd_options).\n\t */\n\trelationForm = (Form_pg_class) palloc(CLASS_TUPLE_SIZE);\n\n\tmemcpy(relationForm, relp, CLASS_TUPLE_SIZE);\n\n\t/* initialize relation tuple form */\n\trelation->rd_rel = relationForm;\n\n\t/* and allocate attribute tuple form storage */\n\trelation->rd_att = CreateTemplateTupleDesc(relationForm->relnatts,\n\t\t\t\t\t\t\t\t\t\t\t   relationForm->relhasoids);\n\t/* which we mark as a reference-counted tupdesc */\n\trelation->rd_att->tdrefcount = 1;\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn relation;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static Relation AllocateRelationDesc(Form_pg_class relp);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic Relation AllocateRelationDesc(Form_pg_class relp);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic Relation\nAllocateRelationDesc(Form_pg_class relp)\n{\n\tRelation\trelation;\n\tMemoryContext oldcxt;\n\tForm_pg_class relationForm;\n\n\t/* Relcache entries must live in CacheMemoryContext */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * allocate and zero space for new relation descriptor\n\t */\n\trelation = (Relation) palloc0(sizeof(RelationData));\n\n\t/* make sure relation is marked as having no open file yet */\n\trelation->rd_smgr = NULL;\n\n\t/*\n\t * Copy the relation tuple form\n\t *\n\t * We only allocate space for the fixed fields, ie, CLASS_TUPLE_SIZE. The\n\t * variable-length fields (relacl, reloptions) are NOT stored in the\n\t * relcache --- there'd be little point in it, since we don't copy the\n\t * tuple's nulls bitmap and hence wouldn't know if the values are valid.\n\t * Bottom line is that relacl *cannot* be retrieved from the relcache. Get\n\t * it from the syscache if you need it.  The same goes for the original\n\t * form of reloptions (however, we do store the parsed form of reloptions\n\t * in rd_options).\n\t */\n\trelationForm = (Form_pg_class) palloc(CLASS_TUPLE_SIZE);\n\n\tmemcpy(relationForm, relp, CLASS_TUPLE_SIZE);\n\n\t/* initialize relation tuple form */\n\trelation->rd_rel = relationForm;\n\n\t/* and allocate attribute tuple form storage */\n\trelation->rd_att = CreateTemplateTupleDesc(relationForm->relnatts,\n\t\t\t\t\t\t\t\t\t\t\t   relationForm->relhasoids);\n\t/* which we mark as a reference-counted tupdesc */\n\trelation->rd_att->tdrefcount = 1;\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn relation;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relid == targetRelId"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "pg_class_tuple"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "pg_class_tuple"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "pg_class_tuple"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanPgRelation",
          "args": [
            "targetRelId",
            "true",
            "false"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "ScanPgRelation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "308-370",
          "snippet": "static HeapTuple\nScanPgRelation(Oid targetRelId, bool indexOK, bool force_non_historic)\n{\n\tHeapTuple\tpg_class_tuple;\n\tRelation\tpg_class_desc;\n\tSysScanDesc pg_class_scan;\n\tScanKeyData key[1];\n\tSnapshot\tsnapshot;\n\n\t/*\n\t * If something goes wrong during backend startup, we might find ourselves\n\t * trying to read pg_class before we've selected a database.  That ain't\n\t * gonna work, so bail out with a useful error message.  If this happens,\n\t * it probably means a relcache entry that needs to be nailed isn't.\n\t */\n\tif (!OidIsValid(MyDatabaseId))\n\t\telog(FATAL, \"cannot read pg_class without having selected a database\");\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(targetRelId));\n\n\t/*\n\t * Open pg_class and fetch a tuple.  Force heap scan if we haven't yet\n\t * built the critical relcache entries (this includes initdb and startup\n\t * without a pg_internal.init file).  The caller can also force a heap\n\t * scan by setting indexOK == false.\n\t */\n\tpg_class_desc = heap_open(RelationRelationId, AccessShareLock);\n\n\t/*\n\t * The caller might need a tuple that's newer than the one the historic\n\t * snapshot; currently the only case requiring to do so is looking up the\n\t * relfilenode of non mapped system relations during decoding.\n\t */\n\tif (force_non_historic)\n\t\tsnapshot = GetNonHistoricCatalogSnapshot(RelationRelationId);\n\telse\n\t\tsnapshot = GetCatalogSnapshot(RelationRelationId);\n\n\tpg_class_scan = systable_beginscan(pg_class_desc, ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t   indexOK && criticalRelcachesBuilt,\n\t\t\t\t\t\t\t\t\t   snapshot,\n\t\t\t\t\t\t\t\t\t   1, key);\n\n\tpg_class_tuple = systable_getnext(pg_class_scan);\n\n\t/*\n\t * Must copy tuple before releasing buffer.\n\t */\n\tif (HeapTupleIsValid(pg_class_tuple))\n\t\tpg_class_tuple = heap_copytuple(pg_class_tuple);\n\n\t/* all done */\n\tsystable_endscan(pg_class_scan);\n\theap_close(pg_class_desc, AccessShareLock);\n\n\treturn pg_class_tuple;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool\t\tcriticalRelcachesBuilt = false;",
            "static HeapTuple ScanPgRelation(Oid targetRelId, bool indexOK, bool force_non_historic);",
            "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nbool\t\tcriticalRelcachesBuilt = false;\nstatic HeapTuple ScanPgRelation(Oid targetRelId, bool indexOK, bool force_non_historic);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\n\nstatic HeapTuple\nScanPgRelation(Oid targetRelId, bool indexOK, bool force_non_historic)\n{\n\tHeapTuple\tpg_class_tuple;\n\tRelation\tpg_class_desc;\n\tSysScanDesc pg_class_scan;\n\tScanKeyData key[1];\n\tSnapshot\tsnapshot;\n\n\t/*\n\t * If something goes wrong during backend startup, we might find ourselves\n\t * trying to read pg_class before we've selected a database.  That ain't\n\t * gonna work, so bail out with a useful error message.  If this happens,\n\t * it probably means a relcache entry that needs to be nailed isn't.\n\t */\n\tif (!OidIsValid(MyDatabaseId))\n\t\telog(FATAL, \"cannot read pg_class without having selected a database\");\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(targetRelId));\n\n\t/*\n\t * Open pg_class and fetch a tuple.  Force heap scan if we haven't yet\n\t * built the critical relcache entries (this includes initdb and startup\n\t * without a pg_internal.init file).  The caller can also force a heap\n\t * scan by setting indexOK == false.\n\t */\n\tpg_class_desc = heap_open(RelationRelationId, AccessShareLock);\n\n\t/*\n\t * The caller might need a tuple that's newer than the one the historic\n\t * snapshot; currently the only case requiring to do so is looking up the\n\t * relfilenode of non mapped system relations during decoding.\n\t */\n\tif (force_non_historic)\n\t\tsnapshot = GetNonHistoricCatalogSnapshot(RelationRelationId);\n\telse\n\t\tsnapshot = GetCatalogSnapshot(RelationRelationId);\n\n\tpg_class_scan = systable_beginscan(pg_class_desc, ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t   indexOK && criticalRelcachesBuilt,\n\t\t\t\t\t\t\t\t\t   snapshot,\n\t\t\t\t\t\t\t\t\t   1, key);\n\n\tpg_class_tuple = systable_getnext(pg_class_scan);\n\n\t/*\n\t * Must copy tuple before releasing buffer.\n\t */\n\tif (HeapTupleIsValid(pg_class_tuple))\n\t\tpg_class_tuple = heap_copytuple(pg_class_tuple);\n\n\t/* all done */\n\tsystable_endscan(pg_class_scan);\n\theap_close(pg_class_desc, AccessShareLock);\n\n\treturn pg_class_tuple;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic Relation AllocateRelationDesc(Form_pg_class relp);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic Relation RelationBuildDesc(Oid targetRelId, bool insertIt);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic Relation\nRelationBuildDesc(Oid targetRelId, bool insertIt)\n{\n\tRelation\trelation;\n\tOid\t\t\trelid;\n\tHeapTuple\tpg_class_tuple;\n\tForm_pg_class relp;\n\n\t/*\n\t * find the tuple in pg_class corresponding to the given relation id\n\t */\n\tpg_class_tuple = ScanPgRelation(targetRelId, true, false);\n\n\t/*\n\t * if no such tuple exists, return NULL\n\t */\n\tif (!HeapTupleIsValid(pg_class_tuple))\n\t\treturn NULL;\n\n\t/*\n\t * get information from the pg_class_tuple\n\t */\n\trelid = HeapTupleGetOid(pg_class_tuple);\n\trelp = (Form_pg_class) GETSTRUCT(pg_class_tuple);\n\tAssert(relid == targetRelId);\n\n\t/*\n\t * allocate storage for the relation descriptor, and copy pg_class_tuple\n\t * to relation->rd_rel.\n\t */\n\trelation = AllocateRelationDesc(relp);\n\n\t/*\n\t * initialize the relation's relation id (relation->rd_id)\n\t */\n\tRelationGetRelid(relation) = relid;\n\n\t/*\n\t * normal relations are not nailed into the cache; nor can a pre-existing\n\t * relation be new.  It could be temp though.  (Actually, it could be new\n\t * too, but it's okay to forget that fact if forced to flush the entry.)\n\t */\n\trelation->rd_refcnt = 0;\n\trelation->rd_isnailed = false;\n\trelation->rd_createSubid = InvalidSubTransactionId;\n\trelation->rd_newRelfilenodeSubid = InvalidSubTransactionId;\n\tswitch (relation->rd_rel->relpersistence)\n\t{\n\t\tcase RELPERSISTENCE_UNLOGGED:\n\t\tcase RELPERSISTENCE_PERMANENT:\n\t\t\trelation->rd_backend = InvalidBackendId;\n\t\t\trelation->rd_islocaltemp = false;\n\t\t\tbreak;\n\t\tcase RELPERSISTENCE_TEMP:\n\t\t\tif (isTempOrTempToastNamespace(relation->rd_rel->relnamespace))\n\t\t\t{\n\t\t\t\trelation->rd_backend = BackendIdForTempRelations();\n\t\t\t\trelation->rd_islocaltemp = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * If it's a temp table, but not one of ours, we have to use\n\t\t\t\t * the slow, grotty method to figure out the owning backend.\n\t\t\t\t *\n\t\t\t\t * Note: it's possible that rd_backend gets set to MyBackendId\n\t\t\t\t * here, in case we are looking at a pg_class entry left over\n\t\t\t\t * from a crashed backend that coincidentally had the same\n\t\t\t\t * BackendId we're using.  We should *not* consider such a\n\t\t\t\t * table to be \"ours\"; this is why we need the separate\n\t\t\t\t * rd_islocaltemp flag.  The pg_class entry will get flushed\n\t\t\t\t * if/when we clean out the corresponding temp table namespace\n\t\t\t\t * in preparation for using it.\n\t\t\t\t */\n\t\t\t\trelation->rd_backend =\n\t\t\t\t\tGetTempNamespaceBackendId(relation->rd_rel->relnamespace);\n\t\t\t\tAssert(relation->rd_backend != InvalidBackendId);\n\t\t\t\trelation->rd_islocaltemp = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid relpersistence: %c\",\n\t\t\t\t relation->rd_rel->relpersistence);\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * initialize the tuple descriptor (relation->rd_att).\n\t */\n\tRelationBuildTupleDesc(relation);\n\n\t/*\n\t * Fetch rules and triggers that affect this relation\n\t */\n\tif (relation->rd_rel->relhasrules)\n\t\tRelationBuildRuleLock(relation);\n\telse\n\t{\n\t\trelation->rd_rules = NULL;\n\t\trelation->rd_rulescxt = NULL;\n\t}\n\n\tif (relation->rd_rel->relhastriggers)\n\t\tRelationBuildTriggers(relation);\n\telse\n\t\trelation->trigdesc = NULL;\n\n\tif (relation->rd_rel->relrowsecurity)\n\t\tRelationBuildRowSecurity(relation);\n\telse\n\t\trelation->rd_rsdesc = NULL;\n\n\t/* foreign key data is not loaded till asked for */\n\trelation->rd_fkeylist = NIL;\n\trelation->rd_fkeyvalid = false;\n\n\t/* if a partitioned table, initialize key and partition descriptor info */\n\tif (relation->rd_rel->relkind == RELKIND_PARTITIONED_TABLE)\n\t{\n\t\tRelationBuildPartitionKey(relation);\n\t\tRelationBuildPartitionDesc(relation);\n\t}\n\telse\n\t{\n\t\trelation->rd_partkey = NULL;\n\t\trelation->rd_partkeycxt = NULL;\n\t\trelation->rd_partdesc = NULL;\n\t\trelation->rd_pdcxt = NULL;\n\t}\n\t/* ... but partcheck is not loaded till asked for */\n\trelation->rd_partcheck = NIL;\n\trelation->rd_partcheckvalid = false;\n\trelation->rd_partcheckcxt = NULL;\n\n\t/*\n\t * if it's an index, initialize index-related information\n\t */\n\tif (OidIsValid(relation->rd_rel->relam))\n\t\tRelationInitIndexAccessInfo(relation);\n\n\t/* extract reloptions if any */\n\tRelationParseRelOptions(relation, pg_class_tuple);\n\n\t/*\n\t * initialize the relation lock manager information\n\t */\n\tRelationInitLockInfo(relation); /* see lmgr.c */\n\n\t/*\n\t * initialize physical addressing information for the relation\n\t */\n\tRelationInitPhysicalAddr(relation);\n\n\t/* make sure relation is marked as having no open file yet */\n\trelation->rd_smgr = NULL;\n\n\t/*\n\t * now we can free the memory allocated for pg_class_tuple\n\t */\n\theap_freetuple(pg_class_tuple);\n\n\t/*\n\t * Insert newly created relation into relcache hash table, if requested.\n\t *\n\t * There is one scenario in which we might find a hashtable entry already\n\t * present, even though our caller failed to find it: if the relation is a\n\t * system catalog or index that's used during relcache load, we might have\n\t * recursively created the same relcache entry during the preceding steps.\n\t * So allow RelationCacheInsert to delete any already-present relcache\n\t * entry for the same OID.  The already-present entry should have refcount\n\t * zero (else somebody forgot to close it); in the event that it doesn't,\n\t * we'll elog a WARNING and leak the already-present entry.\n\t */\n\tif (insertIt)\n\t\tRelationCacheInsert(relation, true);\n\n\t/* It's fully valid */\n\trelation->rd_isvalid = true;\n\n\treturn relation;\n}"
  },
  {
    "function_name": "equalPartitionDescs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "1008-1056",
    "snippet": "static bool\nequalPartitionDescs(PartitionKey key, PartitionDesc partdesc1,\n\t\t\t\t\tPartitionDesc partdesc2)\n{\n\tint\t\t\ti;\n\n\tif (partdesc1 != NULL)\n\t{\n\t\tif (partdesc2 == NULL)\n\t\t\treturn false;\n\t\tif (partdesc1->nparts != partdesc2->nparts)\n\t\t\treturn false;\n\n\t\tAssert(key != NULL || partdesc1->nparts == 0);\n\n\t\t/*\n\t\t * Same oids? If the partitioning structure did not change, that is,\n\t\t * no partitions were added or removed to the relation, the oids array\n\t\t * should still match element-by-element.\n\t\t */\n\t\tfor (i = 0; i < partdesc1->nparts; i++)\n\t\t{\n\t\t\tif (partdesc1->oids[i] != partdesc2->oids[i])\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t * Now compare partition bound collections.  The logic to iterate over\n\t\t * the collections is private to partition.c.\n\t\t */\n\t\tif (partdesc1->boundinfo != NULL)\n\t\t{\n\t\t\tif (partdesc2->boundinfo == NULL)\n\t\t\t\treturn false;\n\n\t\t\tif (!partition_bounds_equal(key->partnatts, key->parttyplen,\n\t\t\t\t\t\t\t\t\t\tkey->parttypbyval,\n\t\t\t\t\t\t\t\t\t\tpartdesc1->boundinfo,\n\t\t\t\t\t\t\t\t\t\tpartdesc2->boundinfo))\n\t\t\t\treturn false;\n\t\t}\n\t\telse if (partdesc2->boundinfo != NULL)\n\t\t\treturn false;\n\t}\n\telse if (partdesc2 != NULL)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);",
      "static bool equalPartitionDescs(PartitionKey key, PartitionDesc partdesc1,\n\t\t\t\t\tPartitionDesc partdesc2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "partition_bounds_equal",
          "args": [
            "key->partnatts",
            "key->parttyplen",
            "key->parttypbyval",
            "partdesc1->boundinfo",
            "partdesc2->boundinfo"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "key != NULL || partdesc1->nparts == 0"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\nstatic bool equalPartitionDescs(PartitionKey key, PartitionDesc partdesc1,\n\t\t\t\t\tPartitionDesc partdesc2);\n\nstatic bool\nequalPartitionDescs(PartitionKey key, PartitionDesc partdesc1,\n\t\t\t\t\tPartitionDesc partdesc2)\n{\n\tint\t\t\ti;\n\n\tif (partdesc1 != NULL)\n\t{\n\t\tif (partdesc2 == NULL)\n\t\t\treturn false;\n\t\tif (partdesc1->nparts != partdesc2->nparts)\n\t\t\treturn false;\n\n\t\tAssert(key != NULL || partdesc1->nparts == 0);\n\n\t\t/*\n\t\t * Same oids? If the partitioning structure did not change, that is,\n\t\t * no partitions were added or removed to the relation, the oids array\n\t\t * should still match element-by-element.\n\t\t */\n\t\tfor (i = 0; i < partdesc1->nparts; i++)\n\t\t{\n\t\t\tif (partdesc1->oids[i] != partdesc2->oids[i])\n\t\t\t\treturn false;\n\t\t}\n\n\t\t/*\n\t\t * Now compare partition bound collections.  The logic to iterate over\n\t\t * the collections is private to partition.c.\n\t\t */\n\t\tif (partdesc1->boundinfo != NULL)\n\t\t{\n\t\t\tif (partdesc2->boundinfo == NULL)\n\t\t\t\treturn false;\n\n\t\t\tif (!partition_bounds_equal(key->partnatts, key->parttyplen,\n\t\t\t\t\t\t\t\t\t\tkey->parttypbyval,\n\t\t\t\t\t\t\t\t\t\tpartdesc1->boundinfo,\n\t\t\t\t\t\t\t\t\t\tpartdesc2->boundinfo))\n\t\t\t\treturn false;\n\t\t}\n\t\telse if (partdesc2->boundinfo != NULL)\n\t\t\treturn false;\n\t}\n\telse if (partdesc2 != NULL)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "equalRSDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "975-1002",
    "snippet": "static bool\nequalRSDesc(RowSecurityDesc *rsdesc1, RowSecurityDesc *rsdesc2)\n{\n\tListCell   *lc,\n\t\t\t   *rc;\n\n\tif (rsdesc1 == NULL && rsdesc2 == NULL)\n\t\treturn true;\n\n\tif ((rsdesc1 != NULL && rsdesc2 == NULL) ||\n\t\t(rsdesc1 == NULL && rsdesc2 != NULL))\n\t\treturn false;\n\n\tif (list_length(rsdesc1->policies) != list_length(rsdesc2->policies))\n\t\treturn false;\n\n\t/* RelationBuildRowSecurity should build policies in order */\n\tforboth(lc, rsdesc1->policies, rc, rsdesc2->policies)\n\t{\n\t\tRowSecurityPolicy *l = (RowSecurityPolicy *) lfirst(lc);\n\t\tRowSecurityPolicy *r = (RowSecurityPolicy *) lfirst(rc);\n\n\t\tif (!equalPolicy(l, r))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "equalPolicy",
          "args": [
            "l",
            "r"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "equalPolicy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "929-968",
          "snippet": "static bool\nequalPolicy(RowSecurityPolicy *policy1, RowSecurityPolicy *policy2)\n{\n\tint\t\t\ti;\n\tOid\t\t   *r1,\n\t\t\t   *r2;\n\n\tif (policy1 != NULL)\n\t{\n\t\tif (policy2 == NULL)\n\t\t\treturn false;\n\n\t\tif (policy1->polcmd != policy2->polcmd)\n\t\t\treturn false;\n\t\tif (policy1->hassublinks != policy2->hassublinks)\n\t\t\treturn false;\n\t\tif (strcmp(policy1->policy_name, policy2->policy_name) != 0)\n\t\t\treturn false;\n\t\tif (ARR_DIMS(policy1->roles)[0] != ARR_DIMS(policy2->roles)[0])\n\t\t\treturn false;\n\n\t\tr1 = (Oid *) ARR_DATA_PTR(policy1->roles);\n\t\tr2 = (Oid *) ARR_DATA_PTR(policy2->roles);\n\n\t\tfor (i = 0; i < ARR_DIMS(policy1->roles)[0]; i++)\n\t\t{\n\t\t\tif (r1[i] != r2[i])\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (!equal(policy1->qual, policy2->qual))\n\t\t\treturn false;\n\t\tif (!equal(policy1->with_check_qual, policy2->with_check_qual))\n\t\t\treturn false;\n\t}\n\telse if (policy2 != NULL)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic bool\nequalPolicy(RowSecurityPolicy *policy1, RowSecurityPolicy *policy2)\n{\n\tint\t\t\ti;\n\tOid\t\t   *r1,\n\t\t\t   *r2;\n\n\tif (policy1 != NULL)\n\t{\n\t\tif (policy2 == NULL)\n\t\t\treturn false;\n\n\t\tif (policy1->polcmd != policy2->polcmd)\n\t\t\treturn false;\n\t\tif (policy1->hassublinks != policy2->hassublinks)\n\t\t\treturn false;\n\t\tif (strcmp(policy1->policy_name, policy2->policy_name) != 0)\n\t\t\treturn false;\n\t\tif (ARR_DIMS(policy1->roles)[0] != ARR_DIMS(policy2->roles)[0])\n\t\t\treturn false;\n\n\t\tr1 = (Oid *) ARR_DATA_PTR(policy1->roles);\n\t\tr2 = (Oid *) ARR_DATA_PTR(policy2->roles);\n\n\t\tfor (i = 0; i < ARR_DIMS(policy1->roles)[0]; i++)\n\t\t{\n\t\t\tif (r1[i] != r2[i])\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (!equal(policy1->qual, policy2->qual))\n\t\t\treturn false;\n\t\tif (!equal(policy1->with_check_qual, policy2->with_check_qual))\n\t\t\treturn false;\n\t}\n\telse if (policy2 != NULL)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "rc"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "lc"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "forboth",
          "args": [
            "lc",
            "rsdesc1->policies",
            "rc",
            "rsdesc2->policies"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "rsdesc2->policies"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "rsdesc1->policies"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic bool\nequalRSDesc(RowSecurityDesc *rsdesc1, RowSecurityDesc *rsdesc2)\n{\n\tListCell   *lc,\n\t\t\t   *rc;\n\n\tif (rsdesc1 == NULL && rsdesc2 == NULL)\n\t\treturn true;\n\n\tif ((rsdesc1 != NULL && rsdesc2 == NULL) ||\n\t\t(rsdesc1 == NULL && rsdesc2 != NULL))\n\t\treturn false;\n\n\tif (list_length(rsdesc1->policies) != list_length(rsdesc2->policies))\n\t\treturn false;\n\n\t/* RelationBuildRowSecurity should build policies in order */\n\tforboth(lc, rsdesc1->policies, rc, rsdesc2->policies)\n\t{\n\t\tRowSecurityPolicy *l = (RowSecurityPolicy *) lfirst(lc);\n\t\tRowSecurityPolicy *r = (RowSecurityPolicy *) lfirst(rc);\n\n\t\tif (!equalPolicy(l, r))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "equalPolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "929-968",
    "snippet": "static bool\nequalPolicy(RowSecurityPolicy *policy1, RowSecurityPolicy *policy2)\n{\n\tint\t\t\ti;\n\tOid\t\t   *r1,\n\t\t\t   *r2;\n\n\tif (policy1 != NULL)\n\t{\n\t\tif (policy2 == NULL)\n\t\t\treturn false;\n\n\t\tif (policy1->polcmd != policy2->polcmd)\n\t\t\treturn false;\n\t\tif (policy1->hassublinks != policy2->hassublinks)\n\t\t\treturn false;\n\t\tif (strcmp(policy1->policy_name, policy2->policy_name) != 0)\n\t\t\treturn false;\n\t\tif (ARR_DIMS(policy1->roles)[0] != ARR_DIMS(policy2->roles)[0])\n\t\t\treturn false;\n\n\t\tr1 = (Oid *) ARR_DATA_PTR(policy1->roles);\n\t\tr2 = (Oid *) ARR_DATA_PTR(policy2->roles);\n\n\t\tfor (i = 0; i < ARR_DIMS(policy1->roles)[0]; i++)\n\t\t{\n\t\t\tif (r1[i] != r2[i])\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (!equal(policy1->qual, policy2->qual))\n\t\t\treturn false;\n\t\tif (!equal(policy1->with_check_qual, policy2->with_check_qual))\n\t\t\treturn false;\n\t}\n\telse if (policy2 != NULL)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "equal",
          "args": [
            "policy1->with_check_qual",
            "policy2->with_check_qual"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "equalRSDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "975-1002",
          "snippet": "static bool\nequalRSDesc(RowSecurityDesc *rsdesc1, RowSecurityDesc *rsdesc2)\n{\n\tListCell   *lc,\n\t\t\t   *rc;\n\n\tif (rsdesc1 == NULL && rsdesc2 == NULL)\n\t\treturn true;\n\n\tif ((rsdesc1 != NULL && rsdesc2 == NULL) ||\n\t\t(rsdesc1 == NULL && rsdesc2 != NULL))\n\t\treturn false;\n\n\tif (list_length(rsdesc1->policies) != list_length(rsdesc2->policies))\n\t\treturn false;\n\n\t/* RelationBuildRowSecurity should build policies in order */\n\tforboth(lc, rsdesc1->policies, rc, rsdesc2->policies)\n\t{\n\t\tRowSecurityPolicy *l = (RowSecurityPolicy *) lfirst(lc);\n\t\tRowSecurityPolicy *r = (RowSecurityPolicy *) lfirst(rc);\n\n\t\tif (!equalPolicy(l, r))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic bool\nequalRSDesc(RowSecurityDesc *rsdesc1, RowSecurityDesc *rsdesc2)\n{\n\tListCell   *lc,\n\t\t\t   *rc;\n\n\tif (rsdesc1 == NULL && rsdesc2 == NULL)\n\t\treturn true;\n\n\tif ((rsdesc1 != NULL && rsdesc2 == NULL) ||\n\t\t(rsdesc1 == NULL && rsdesc2 != NULL))\n\t\treturn false;\n\n\tif (list_length(rsdesc1->policies) != list_length(rsdesc2->policies))\n\t\treturn false;\n\n\t/* RelationBuildRowSecurity should build policies in order */\n\tforboth(lc, rsdesc1->policies, rc, rsdesc2->policies)\n\t{\n\t\tRowSecurityPolicy *l = (RowSecurityPolicy *) lfirst(lc);\n\t\tRowSecurityPolicy *r = (RowSecurityPolicy *) lfirst(rc);\n\n\t\tif (!equalPolicy(l, r))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "policy1->roles"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "policy2->roles"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DATA_PTR",
          "args": [
            "policy1->roles"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "policy2->roles"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARR_DIMS",
          "args": [
            "policy1->roles"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "policy1->policy_name",
            "policy2->policy_name"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic bool\nequalPolicy(RowSecurityPolicy *policy1, RowSecurityPolicy *policy2)\n{\n\tint\t\t\ti;\n\tOid\t\t   *r1,\n\t\t\t   *r2;\n\n\tif (policy1 != NULL)\n\t{\n\t\tif (policy2 == NULL)\n\t\t\treturn false;\n\n\t\tif (policy1->polcmd != policy2->polcmd)\n\t\t\treturn false;\n\t\tif (policy1->hassublinks != policy2->hassublinks)\n\t\t\treturn false;\n\t\tif (strcmp(policy1->policy_name, policy2->policy_name) != 0)\n\t\t\treturn false;\n\t\tif (ARR_DIMS(policy1->roles)[0] != ARR_DIMS(policy2->roles)[0])\n\t\t\treturn false;\n\n\t\tr1 = (Oid *) ARR_DATA_PTR(policy1->roles);\n\t\tr2 = (Oid *) ARR_DATA_PTR(policy2->roles);\n\n\t\tfor (i = 0; i < ARR_DIMS(policy1->roles)[0]; i++)\n\t\t{\n\t\t\tif (r1[i] != r2[i])\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (!equal(policy1->qual, policy2->qual))\n\t\t\treturn false;\n\t\tif (!equal(policy1->with_check_qual, policy2->with_check_qual))\n\t\t\treturn false;\n\t}\n\telse if (policy2 != NULL)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "equalRuleLocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "884-922",
    "snippet": "static bool\nequalRuleLocks(RuleLock *rlock1, RuleLock *rlock2)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * As of 7.3 we assume the rule ordering is repeatable, because\n\t * RelationBuildRuleLock should read 'em in a consistent order.  So just\n\t * compare corresponding slots.\n\t */\n\tif (rlock1 != NULL)\n\t{\n\t\tif (rlock2 == NULL)\n\t\t\treturn false;\n\t\tif (rlock1->numLocks != rlock2->numLocks)\n\t\t\treturn false;\n\t\tfor (i = 0; i < rlock1->numLocks; i++)\n\t\t{\n\t\t\tRewriteRule *rule1 = rlock1->rules[i];\n\t\t\tRewriteRule *rule2 = rlock2->rules[i];\n\n\t\t\tif (rule1->ruleId != rule2->ruleId)\n\t\t\t\treturn false;\n\t\t\tif (rule1->event != rule2->event)\n\t\t\t\treturn false;\n\t\t\tif (rule1->enabled != rule2->enabled)\n\t\t\t\treturn false;\n\t\t\tif (rule1->isInstead != rule2->isInstead)\n\t\t\t\treturn false;\n\t\t\tif (!equal(rule1->qual, rule2->qual))\n\t\t\t\treturn false;\n\t\t\tif (!equal(rule1->actions, rule2->actions))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\telse if (rlock2 != NULL)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "equal",
          "args": [
            "rule1->actions",
            "rule2->actions"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "equalRSDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "975-1002",
          "snippet": "static bool\nequalRSDesc(RowSecurityDesc *rsdesc1, RowSecurityDesc *rsdesc2)\n{\n\tListCell   *lc,\n\t\t\t   *rc;\n\n\tif (rsdesc1 == NULL && rsdesc2 == NULL)\n\t\treturn true;\n\n\tif ((rsdesc1 != NULL && rsdesc2 == NULL) ||\n\t\t(rsdesc1 == NULL && rsdesc2 != NULL))\n\t\treturn false;\n\n\tif (list_length(rsdesc1->policies) != list_length(rsdesc2->policies))\n\t\treturn false;\n\n\t/* RelationBuildRowSecurity should build policies in order */\n\tforboth(lc, rsdesc1->policies, rc, rsdesc2->policies)\n\t{\n\t\tRowSecurityPolicy *l = (RowSecurityPolicy *) lfirst(lc);\n\t\tRowSecurityPolicy *r = (RowSecurityPolicy *) lfirst(rc);\n\n\t\tif (!equalPolicy(l, r))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic bool\nequalRSDesc(RowSecurityDesc *rsdesc1, RowSecurityDesc *rsdesc2)\n{\n\tListCell   *lc,\n\t\t\t   *rc;\n\n\tif (rsdesc1 == NULL && rsdesc2 == NULL)\n\t\treturn true;\n\n\tif ((rsdesc1 != NULL && rsdesc2 == NULL) ||\n\t\t(rsdesc1 == NULL && rsdesc2 != NULL))\n\t\treturn false;\n\n\tif (list_length(rsdesc1->policies) != list_length(rsdesc2->policies))\n\t\treturn false;\n\n\t/* RelationBuildRowSecurity should build policies in order */\n\tforboth(lc, rsdesc1->policies, rc, rsdesc2->policies)\n\t{\n\t\tRowSecurityPolicy *l = (RowSecurityPolicy *) lfirst(lc);\n\t\tRowSecurityPolicy *r = (RowSecurityPolicy *) lfirst(rc);\n\n\t\tif (!equalPolicy(l, r))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic bool\nequalRuleLocks(RuleLock *rlock1, RuleLock *rlock2)\n{\n\tint\t\t\ti;\n\n\t/*\n\t * As of 7.3 we assume the rule ordering is repeatable, because\n\t * RelationBuildRuleLock should read 'em in a consistent order.  So just\n\t * compare corresponding slots.\n\t */\n\tif (rlock1 != NULL)\n\t{\n\t\tif (rlock2 == NULL)\n\t\t\treturn false;\n\t\tif (rlock1->numLocks != rlock2->numLocks)\n\t\t\treturn false;\n\t\tfor (i = 0; i < rlock1->numLocks; i++)\n\t\t{\n\t\t\tRewriteRule *rule1 = rlock1->rules[i];\n\t\t\tRewriteRule *rule2 = rlock2->rules[i];\n\n\t\t\tif (rule1->ruleId != rule2->ruleId)\n\t\t\t\treturn false;\n\t\t\tif (rule1->event != rule2->event)\n\t\t\t\treturn false;\n\t\t\tif (rule1->enabled != rule2->enabled)\n\t\t\t\treturn false;\n\t\t\tif (rule1->isInstead != rule2->isInstead)\n\t\t\t\treturn false;\n\t\t\tif (!equal(rule1->qual, rule2->qual))\n\t\t\t\treturn false;\n\t\t\tif (!equal(rule1->actions, rule2->actions))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\telse if (rlock2 != NULL)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "RelationBuildRuleLock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "723-875",
    "snippet": "static void\nRelationBuildRuleLock(Relation relation)\n{\n\tMemoryContext rulescxt;\n\tMemoryContext oldcxt;\n\tHeapTuple\trewrite_tuple;\n\tRelation\trewrite_desc;\n\tTupleDesc\trewrite_tupdesc;\n\tSysScanDesc rewrite_scan;\n\tScanKeyData key;\n\tRuleLock   *rulelock;\n\tint\t\t\tnumlocks;\n\tRewriteRule **rules;\n\tint\t\t\tmaxlocks;\n\n\t/*\n\t * Make the private context.  Assume it'll not contain much data.\n\t */\n\trulescxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t \"relation rules\",\n\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\trelation->rd_rulescxt = rulescxt;\n\tMemoryContextCopyAndSetIdentifier(rulescxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(relation));\n\n\t/*\n\t * allocate an array to hold the rewrite rules (the array is extended if\n\t * necessary)\n\t */\n\tmaxlocks = 4;\n\trules = (RewriteRule **)\n\t\tMemoryContextAlloc(rulescxt, sizeof(RewriteRule *) * maxlocks);\n\tnumlocks = 0;\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key,\n\t\t\t\tAnum_pg_rewrite_ev_class,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\t/*\n\t * open pg_rewrite and begin a scan\n\t *\n\t * Note: since we scan the rules using RewriteRelRulenameIndexId, we will\n\t * be reading the rules in name order, except possibly during\n\t * emergency-recovery operations (ie, IgnoreSystemIndexes). This in turn\n\t * ensures that rules will be fired in name order.\n\t */\n\trewrite_desc = heap_open(RewriteRelationId, AccessShareLock);\n\trewrite_tupdesc = RelationGetDescr(rewrite_desc);\n\trewrite_scan = systable_beginscan(rewrite_desc,\n\t\t\t\t\t\t\t\t\t  RewriteRelRulenameIndexId,\n\t\t\t\t\t\t\t\t\t  true, NULL,\n\t\t\t\t\t\t\t\t\t  1, &key);\n\n\twhile (HeapTupleIsValid(rewrite_tuple = systable_getnext(rewrite_scan)))\n\t{\n\t\tForm_pg_rewrite rewrite_form = (Form_pg_rewrite) GETSTRUCT(rewrite_tuple);\n\t\tbool\t\tisnull;\n\t\tDatum\t\trule_datum;\n\t\tchar\t   *rule_str;\n\t\tRewriteRule *rule;\n\n\t\trule = (RewriteRule *) MemoryContextAlloc(rulescxt,\n\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(RewriteRule));\n\n\t\trule->ruleId = HeapTupleGetOid(rewrite_tuple);\n\n\t\trule->event = rewrite_form->ev_type - '0';\n\t\trule->enabled = rewrite_form->ev_enabled;\n\t\trule->isInstead = rewrite_form->is_instead;\n\n\t\t/*\n\t\t * Must use heap_getattr to fetch ev_action and ev_qual.  Also, the\n\t\t * rule strings are often large enough to be toasted.  To avoid\n\t\t * leaking memory in the caller's context, do the detoasting here so\n\t\t * we can free the detoasted version.\n\t\t */\n\t\trule_datum = heap_getattr(rewrite_tuple,\n\t\t\t\t\t\t\t\t  Anum_pg_rewrite_ev_action,\n\t\t\t\t\t\t\t\t  rewrite_tupdesc,\n\t\t\t\t\t\t\t\t  &isnull);\n\t\tAssert(!isnull);\n\t\trule_str = TextDatumGetCString(rule_datum);\n\t\toldcxt = MemoryContextSwitchTo(rulescxt);\n\t\trule->actions = (List *) stringToNode(rule_str);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t\tpfree(rule_str);\n\n\t\trule_datum = heap_getattr(rewrite_tuple,\n\t\t\t\t\t\t\t\t  Anum_pg_rewrite_ev_qual,\n\t\t\t\t\t\t\t\t  rewrite_tupdesc,\n\t\t\t\t\t\t\t\t  &isnull);\n\t\tAssert(!isnull);\n\t\trule_str = TextDatumGetCString(rule_datum);\n\t\toldcxt = MemoryContextSwitchTo(rulescxt);\n\t\trule->qual = (Node *) stringToNode(rule_str);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t\tpfree(rule_str);\n\n\t\t/*\n\t\t * We want the rule's table references to be checked as though by the\n\t\t * table owner, not the user referencing the rule.  Therefore, scan\n\t\t * through the rule's actions and set the checkAsUser field on all\n\t\t * rtable entries.  We have to look at the qual as well, in case it\n\t\t * contains sublinks.\n\t\t *\n\t\t * The reason for doing this when the rule is loaded, rather than when\n\t\t * it is stored, is that otherwise ALTER TABLE OWNER would have to\n\t\t * grovel through stored rules to update checkAsUser fields. Scanning\n\t\t * the rule tree during load is relatively cheap (compared to\n\t\t * constructing it in the first place), so we do it here.\n\t\t */\n\t\tsetRuleCheckAsUser((Node *) rule->actions, relation->rd_rel->relowner);\n\t\tsetRuleCheckAsUser(rule->qual, relation->rd_rel->relowner);\n\n\t\tif (numlocks >= maxlocks)\n\t\t{\n\t\t\tmaxlocks *= 2;\n\t\t\trules = (RewriteRule **)\n\t\t\t\trepalloc(rules, sizeof(RewriteRule *) * maxlocks);\n\t\t}\n\t\trules[numlocks++] = rule;\n\t}\n\n\t/*\n\t * end the scan and close the attribute relation\n\t */\n\tsystable_endscan(rewrite_scan);\n\theap_close(rewrite_desc, AccessShareLock);\n\n\t/*\n\t * there might not be any rules (if relhasrules is out-of-date)\n\t */\n\tif (numlocks == 0)\n\t{\n\t\trelation->rd_rules = NULL;\n\t\trelation->rd_rulescxt = NULL;\n\t\tMemoryContextDelete(rulescxt);\n\t\treturn;\n\t}\n\n\t/*\n\t * form a RuleLock and insert into relation\n\t */\n\trulelock = (RuleLock *) MemoryContextAlloc(rulescxt, sizeof(RuleLock));\n\trulelock->numLocks = numlocks;\n\trulelock->rules = rules;\n\n\trelation->rd_rules = rulelock;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "rulescxt",
            "sizeof(RuleLock)"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextDelete",
          "args": [
            "rulescxt"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextDeleteChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "255-266",
          "snippet": "void\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextDeleteChildren(MemoryContext context)\n{\n\tAssertArg(MemoryContextIsValid(context));\n\n\t/*\n\t * MemoryContextDelete will delink the child from me, so just iterate as\n\t * long as there is a child.\n\t */\n\twhile (context->firstchild != NULL)\n\t\tMemoryContextDelete(context->firstchild);\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "rewrite_desc",
            "AccessShareLock"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan",
          "args": [
            "rewrite_scan"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "rules",
            "sizeof(RewriteRule *) * maxlocks"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "repalloc_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1113-1141",
          "snippet": "void *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setRuleCheckAsUser",
          "args": [
            "rule->qual",
            "relation->rd_rel->relowner"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setRuleCheckAsUser",
          "args": [
            "(Node *) rule->actions",
            "relation->rd_rel->relowner"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "rule_str"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringToNode",
          "args": [
            "rule_str"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "rulescxt"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "rule_datum"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isnull"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "rewrite_tuple",
            "Anum_pg_rewrite_ev_qual",
            "rewrite_tupdesc",
            "&isnull"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringToNode",
          "args": [
            "rule_str"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "rulescxt"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TextDatumGetCString",
          "args": [
            "rule_datum"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!isnull"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "rewrite_tuple",
            "Anum_pg_rewrite_ev_action",
            "rewrite_tupdesc",
            "&isnull"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetOid",
          "args": [
            "rewrite_tuple"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "rewrite_tuple"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "rewrite_tuple = systable_getnext(rewrite_scan)"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext",
          "args": [
            "rewrite_scan"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_beginscan",
          "args": [
            "rewrite_desc",
            "RewriteRelRulenameIndexId",
            "true",
            "NULL",
            "1",
            "&key"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetDescr",
          "args": [
            "rewrite_desc"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "RewriteRelationId",
            "AccessShareLock"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyInit",
          "args": [
            "&key",
            "Anum_pg_rewrite_ev_class",
            "BTEqualStrategyNumber",
            "F_OIDEQ",
            "ObjectIdGetDatum(RelationGetRelid(relation))"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "RelationGetRelid(relation)"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextCopyAndSetIdentifier",
          "args": [
            "rulescxt",
            "RelationGetRelationName(relation)"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "relation"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocSetContextCreate",
          "args": [
            "CacheMemoryContext",
            "\"relation rules\"",
            "ALLOCSET_SMALL_SIZES"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationBuildRuleLock(Relation relation)\n{\n\tMemoryContext rulescxt;\n\tMemoryContext oldcxt;\n\tHeapTuple\trewrite_tuple;\n\tRelation\trewrite_desc;\n\tTupleDesc\trewrite_tupdesc;\n\tSysScanDesc rewrite_scan;\n\tScanKeyData key;\n\tRuleLock   *rulelock;\n\tint\t\t\tnumlocks;\n\tRewriteRule **rules;\n\tint\t\t\tmaxlocks;\n\n\t/*\n\t * Make the private context.  Assume it'll not contain much data.\n\t */\n\trulescxt = AllocSetContextCreate(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t \"relation rules\",\n\t\t\t\t\t\t\t\t\t ALLOCSET_SMALL_SIZES);\n\trelation->rd_rulescxt = rulescxt;\n\tMemoryContextCopyAndSetIdentifier(rulescxt,\n\t\t\t\t\t\t\t\t\t  RelationGetRelationName(relation));\n\n\t/*\n\t * allocate an array to hold the rewrite rules (the array is extended if\n\t * necessary)\n\t */\n\tmaxlocks = 4;\n\trules = (RewriteRule **)\n\t\tMemoryContextAlloc(rulescxt, sizeof(RewriteRule *) * maxlocks);\n\tnumlocks = 0;\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key,\n\t\t\t\tAnum_pg_rewrite_ev_class,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\t/*\n\t * open pg_rewrite and begin a scan\n\t *\n\t * Note: since we scan the rules using RewriteRelRulenameIndexId, we will\n\t * be reading the rules in name order, except possibly during\n\t * emergency-recovery operations (ie, IgnoreSystemIndexes). This in turn\n\t * ensures that rules will be fired in name order.\n\t */\n\trewrite_desc = heap_open(RewriteRelationId, AccessShareLock);\n\trewrite_tupdesc = RelationGetDescr(rewrite_desc);\n\trewrite_scan = systable_beginscan(rewrite_desc,\n\t\t\t\t\t\t\t\t\t  RewriteRelRulenameIndexId,\n\t\t\t\t\t\t\t\t\t  true, NULL,\n\t\t\t\t\t\t\t\t\t  1, &key);\n\n\twhile (HeapTupleIsValid(rewrite_tuple = systable_getnext(rewrite_scan)))\n\t{\n\t\tForm_pg_rewrite rewrite_form = (Form_pg_rewrite) GETSTRUCT(rewrite_tuple);\n\t\tbool\t\tisnull;\n\t\tDatum\t\trule_datum;\n\t\tchar\t   *rule_str;\n\t\tRewriteRule *rule;\n\n\t\trule = (RewriteRule *) MemoryContextAlloc(rulescxt,\n\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(RewriteRule));\n\n\t\trule->ruleId = HeapTupleGetOid(rewrite_tuple);\n\n\t\trule->event = rewrite_form->ev_type - '0';\n\t\trule->enabled = rewrite_form->ev_enabled;\n\t\trule->isInstead = rewrite_form->is_instead;\n\n\t\t/*\n\t\t * Must use heap_getattr to fetch ev_action and ev_qual.  Also, the\n\t\t * rule strings are often large enough to be toasted.  To avoid\n\t\t * leaking memory in the caller's context, do the detoasting here so\n\t\t * we can free the detoasted version.\n\t\t */\n\t\trule_datum = heap_getattr(rewrite_tuple,\n\t\t\t\t\t\t\t\t  Anum_pg_rewrite_ev_action,\n\t\t\t\t\t\t\t\t  rewrite_tupdesc,\n\t\t\t\t\t\t\t\t  &isnull);\n\t\tAssert(!isnull);\n\t\trule_str = TextDatumGetCString(rule_datum);\n\t\toldcxt = MemoryContextSwitchTo(rulescxt);\n\t\trule->actions = (List *) stringToNode(rule_str);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t\tpfree(rule_str);\n\n\t\trule_datum = heap_getattr(rewrite_tuple,\n\t\t\t\t\t\t\t\t  Anum_pg_rewrite_ev_qual,\n\t\t\t\t\t\t\t\t  rewrite_tupdesc,\n\t\t\t\t\t\t\t\t  &isnull);\n\t\tAssert(!isnull);\n\t\trule_str = TextDatumGetCString(rule_datum);\n\t\toldcxt = MemoryContextSwitchTo(rulescxt);\n\t\trule->qual = (Node *) stringToNode(rule_str);\n\t\tMemoryContextSwitchTo(oldcxt);\n\t\tpfree(rule_str);\n\n\t\t/*\n\t\t * We want the rule's table references to be checked as though by the\n\t\t * table owner, not the user referencing the rule.  Therefore, scan\n\t\t * through the rule's actions and set the checkAsUser field on all\n\t\t * rtable entries.  We have to look at the qual as well, in case it\n\t\t * contains sublinks.\n\t\t *\n\t\t * The reason for doing this when the rule is loaded, rather than when\n\t\t * it is stored, is that otherwise ALTER TABLE OWNER would have to\n\t\t * grovel through stored rules to update checkAsUser fields. Scanning\n\t\t * the rule tree during load is relatively cheap (compared to\n\t\t * constructing it in the first place), so we do it here.\n\t\t */\n\t\tsetRuleCheckAsUser((Node *) rule->actions, relation->rd_rel->relowner);\n\t\tsetRuleCheckAsUser(rule->qual, relation->rd_rel->relowner);\n\n\t\tif (numlocks >= maxlocks)\n\t\t{\n\t\t\tmaxlocks *= 2;\n\t\t\trules = (RewriteRule **)\n\t\t\t\trepalloc(rules, sizeof(RewriteRule *) * maxlocks);\n\t\t}\n\t\trules[numlocks++] = rule;\n\t}\n\n\t/*\n\t * end the scan and close the attribute relation\n\t */\n\tsystable_endscan(rewrite_scan);\n\theap_close(rewrite_desc, AccessShareLock);\n\n\t/*\n\t * there might not be any rules (if relhasrules is out-of-date)\n\t */\n\tif (numlocks == 0)\n\t{\n\t\trelation->rd_rules = NULL;\n\t\trelation->rd_rulescxt = NULL;\n\t\tMemoryContextDelete(rulescxt);\n\t\treturn;\n\t}\n\n\t/*\n\t * form a RuleLock and insert into relation\n\t */\n\trulelock = (RuleLock *) MemoryContextAlloc(rulescxt, sizeof(RuleLock));\n\trulelock->numLocks = numlocks;\n\trulelock->rules = rules;\n\n\trelation->rd_rules = rulelock;\n}"
  },
  {
    "function_name": "RelationBuildTupleDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "491-706",
    "snippet": "static void\nRelationBuildTupleDesc(Relation relation)\n{\n\tHeapTuple\tpg_attribute_tuple;\n\tRelation\tpg_attribute_desc;\n\tSysScanDesc pg_attribute_scan;\n\tScanKeyData skey[2];\n\tint\t\t\tneed;\n\tTupleConstr *constr;\n\tAttrDefault *attrdef = NULL;\n\tAttrMissing *attrmiss = NULL;\n\tint\t\t\tndef = 0;\n\n\t/* copy some fields from pg_class row to rd_att */\n\trelation->rd_att->tdtypeid = relation->rd_rel->reltype;\n\trelation->rd_att->tdtypmod = -1;\t/* unnecessary, but... */\n\trelation->rd_att->tdhasoid = relation->rd_rel->relhasoids;\n\n\tconstr = (TupleConstr *) MemoryContextAlloc(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\tsizeof(TupleConstr));\n\tconstr->has_not_null = false;\n\n\t/*\n\t * Form a scan key that selects only user attributes (attnum > 0).\n\t * (Eliminating system attribute rows at the index level is lots faster\n\t * than fetching them.)\n\t */\n\tScanKeyInit(&skey[0],\n\t\t\t\tAnum_pg_attribute_attrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\tScanKeyInit(&skey[1],\n\t\t\t\tAnum_pg_attribute_attnum,\n\t\t\t\tBTGreaterStrategyNumber, F_INT2GT,\n\t\t\t\tInt16GetDatum(0));\n\n\t/*\n\t * Open pg_attribute and begin a scan.  Force heap scan if we haven't yet\n\t * built the critical relcache entries (this includes initdb and startup\n\t * without a pg_internal.init file).\n\t */\n\tpg_attribute_desc = heap_open(AttributeRelationId, AccessShareLock);\n\tpg_attribute_scan = systable_beginscan(pg_attribute_desc,\n\t\t\t\t\t\t\t\t\t\t   AttributeRelidNumIndexId,\n\t\t\t\t\t\t\t\t\t\t   criticalRelcachesBuilt,\n\t\t\t\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t\t\t\t   2, skey);\n\n\t/*\n\t * add attribute data to relation->rd_att\n\t */\n\tneed = RelationGetNumberOfAttributes(relation);\n\n\twhile (HeapTupleIsValid(pg_attribute_tuple = systable_getnext(pg_attribute_scan)))\n\t{\n\t\tForm_pg_attribute attp;\n\t\tint\t\t\tattnum;\n\n\t\tattp = (Form_pg_attribute) GETSTRUCT(pg_attribute_tuple);\n\n\t\tattnum = attp->attnum;\n\t\tif (attnum <= 0 || attnum > RelationGetNumberOfAttributes(relation))\n\t\t\telog(ERROR, \"invalid attribute number %d for %s\",\n\t\t\t\t attp->attnum, RelationGetRelationName(relation));\n\n\n\t\tmemcpy(TupleDescAttr(relation->rd_att, attnum - 1),\n\t\t\t   attp,\n\t\t\t   ATTRIBUTE_FIXED_PART_SIZE);\n\n\t\t/* Update constraint/default info */\n\t\tif (attp->attnotnull)\n\t\t\tconstr->has_not_null = true;\n\n\t\t/* If the column has a default, fill it into the attrdef array */\n\t\tif (attp->atthasdef)\n\t\t{\n\t\t\tif (attrdef == NULL)\n\t\t\t\tattrdef = (AttrDefault *)\n\t\t\t\t\tMemoryContextAllocZero(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t   RelationGetNumberOfAttributes(relation) *\n\t\t\t\t\t\t\t\t\t\t   sizeof(AttrDefault));\n\t\t\tattrdef[ndef].adnum = attnum;\n\t\t\tattrdef[ndef].adbin = NULL;\n\n\t\t\tndef++;\n\t\t}\n\n\t\t/* Likewise for a missing value */\n\t\tif (attp->atthasmissing)\n\t\t{\n\t\t\tDatum\t\tmissingval;\n\t\t\tbool\t\tmissingNull;\n\n\t\t\t/* Do we have a missing value? */\n\t\t\tmissingval = heap_getattr(pg_attribute_tuple,\n\t\t\t\t\t\t\t\t\t  Anum_pg_attribute_attmissingval,\n\t\t\t\t\t\t\t\t\t  pg_attribute_desc->rd_att,\n\t\t\t\t\t\t\t\t\t  &missingNull);\n\t\t\tif (!missingNull)\n\t\t\t{\n\t\t\t\t/* Yes, fetch from the array */\n\t\t\t\tMemoryContext oldcxt;\n\t\t\t\tbool\t\tis_null;\n\t\t\t\tint\t\t\tone = 1;\n\t\t\t\tDatum\t\tmissval;\n\n\t\t\t\tif (attrmiss == NULL)\n\t\t\t\t\tattrmiss = (AttrMissing *)\n\t\t\t\t\t\tMemoryContextAllocZero(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   relation->rd_rel->relnatts *\n\t\t\t\t\t\t\t\t\t\t\t   sizeof(AttrMissing));\n\n\t\t\t\tmissval = array_get_element(missingval,\n\t\t\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t\t\t&one,\n\t\t\t\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t\t\t\tattp->attlen,\n\t\t\t\t\t\t\t\t\t\t\tattp->attbyval,\n\t\t\t\t\t\t\t\t\t\t\tattp->attalign,\n\t\t\t\t\t\t\t\t\t\t\t&is_null);\n\t\t\t\tAssert(!is_null);\n\t\t\t\tif (attp->attbyval)\n\t\t\t\t{\n\t\t\t\t\t/* for copy by val just copy the datum direct */\n\t\t\t\t\tattrmiss[attnum - 1].am_value = missval;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* otherwise copy in the correct context */\n\t\t\t\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\t\t\t\t\tattrmiss[attnum - 1].am_value = datumCopy(missval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  attp->attbyval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  attp->attlen);\n\t\t\t\t\tMemoryContextSwitchTo(oldcxt);\n\t\t\t\t}\n\t\t\t\tattrmiss[attnum - 1].am_present = true;\n\t\t\t}\n\t\t}\n\t\tneed--;\n\t\tif (need == 0)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * end the scan and close the attribute relation\n\t */\n\tsystable_endscan(pg_attribute_scan);\n\theap_close(pg_attribute_desc, AccessShareLock);\n\n\tif (need != 0)\n\t\telog(ERROR, \"catalog is missing %d attribute(s) for relid %u\",\n\t\t\t need, RelationGetRelid(relation));\n\n\t/*\n\t * The attcacheoff values we read from pg_attribute should all be -1\n\t * (\"unknown\").  Verify this if assert checking is on.  They will be\n\t * computed when and if needed during tuple access.\n\t */\n#ifdef USE_ASSERT_CHECKING\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < RelationGetNumberOfAttributes(relation); i++)\n\t\t\tAssert(TupleDescAttr(relation->rd_att, i)->attcacheoff == -1);\n\t}\n#endif\n\n\t/*\n\t * However, we can easily set the attcacheoff value for the first\n\t * attribute: it must be zero.  This eliminates the need for special cases\n\t * for attnum=1 that used to exist in fastgetattr() and index_getattr().\n\t */\n\tif (RelationGetNumberOfAttributes(relation) > 0)\n\t\tTupleDescAttr(relation->rd_att, 0)->attcacheoff = 0;\n\n\t/*\n\t * Set up constraint/default info\n\t */\n\tif (constr->has_not_null || ndef > 0 ||\n\t\tattrmiss || relation->rd_rel->relchecks)\n\t{\n\t\trelation->rd_att->constr = constr;\n\n\t\tif (ndef > 0)\t\t\t/* DEFAULTs */\n\t\t{\n\t\t\tif (ndef < RelationGetNumberOfAttributes(relation))\n\t\t\t\tconstr->defval = (AttrDefault *)\n\t\t\t\t\trepalloc(attrdef, ndef * sizeof(AttrDefault));\n\t\t\telse\n\t\t\t\tconstr->defval = attrdef;\n\t\t\tconstr->num_defval = ndef;\n\t\t\tAttrDefaultFetch(relation);\n\t\t}\n\t\telse\n\t\t\tconstr->num_defval = 0;\n\n\t\tconstr->missing = attrmiss;\n\n\t\tif (relation->rd_rel->relchecks > 0)\t/* CHECKs */\n\t\t{\n\t\t\tconstr->num_check = relation->rd_rel->relchecks;\n\t\t\tconstr->check = (ConstrCheck *)\n\t\t\t\tMemoryContextAllocZero(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t   constr->num_check * sizeof(ConstrCheck));\n\t\t\tCheckConstraintFetch(relation);\n\t\t}\n\t\telse\n\t\t\tconstr->num_check = 0;\n\t}\n\telse\n\t{\n\t\tpfree(constr);\n\t\trelation->rd_att->constr = NULL;\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool\t\tcriticalRelcachesBuilt = false;",
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static List *insert_ordered_oid(List *list, Oid datum);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "constr"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CheckConstraintFetch",
          "args": [
            "relation"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "CheckConstraintFetch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "4034-4100",
          "snippet": "static void\nCheckConstraintFetch(Relation relation)\n{\n\tConstrCheck *check = relation->rd_att->constr->check;\n\tint\t\t\tncheck = relation->rd_att->constr->num_check;\n\tRelation\tconrel;\n\tSysScanDesc conscan;\n\tScanKeyData skey[1];\n\tHeapTuple\thtup;\n\tint\t\t\tfound = 0;\n\n\tScanKeyInit(&skey[0],\n\t\t\t\tAnum_pg_constraint_conrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tconrel = heap_open(ConstraintRelationId, AccessShareLock);\n\tconscan = systable_beginscan(conrel, ConstraintRelidTypidNameIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(conscan)))\n\t{\n\t\tForm_pg_constraint conform = (Form_pg_constraint) GETSTRUCT(htup);\n\t\tDatum\t\tval;\n\t\tbool\t\tisnull;\n\t\tchar\t   *s;\n\n\t\t/* We want check constraints only */\n\t\tif (conform->contype != CONSTRAINT_CHECK)\n\t\t\tcontinue;\n\n\t\tif (found >= ncheck)\n\t\t\telog(ERROR, \"unexpected constraint record found for rel %s\",\n\t\t\t\t RelationGetRelationName(relation));\n\n\t\tcheck[found].ccvalid = conform->convalidated;\n\t\tcheck[found].ccnoinherit = conform->connoinherit;\n\t\tcheck[found].ccname = MemoryContextStrdup(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t  NameStr(conform->conname));\n\n\t\t/* Grab and test conbin is actually set */\n\t\tval = fastgetattr(htup,\n\t\t\t\t\t\t  Anum_pg_constraint_conbin,\n\t\t\t\t\t\t  conrel->rd_att, &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null conbin for rel %s\",\n\t\t\t\t RelationGetRelationName(relation));\n\n\t\t/* detoast and convert to cstring in caller's context */\n\t\ts = TextDatumGetCString(val);\n\t\tcheck[found].ccbin = MemoryContextStrdup(CacheMemoryContext, s);\n\t\tpfree(s);\n\n\t\tfound++;\n\t}\n\n\tsystable_endscan(conscan);\n\theap_close(conrel, AccessShareLock);\n\n\tif (found != ncheck)\n\t\telog(ERROR, \"%d constraint record(s) missing for rel %s\",\n\t\t\t ncheck - found, RelationGetRelationName(relation));\n\n\t/* Sort the records so that CHECKs are applied in a deterministic order */\n\tif (ncheck > 1)\n\t\tqsort(check, ncheck, sizeof(ConstrCheck), CheckConstraintCmp);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nCheckConstraintFetch(Relation relation)\n{\n\tConstrCheck *check = relation->rd_att->constr->check;\n\tint\t\t\tncheck = relation->rd_att->constr->num_check;\n\tRelation\tconrel;\n\tSysScanDesc conscan;\n\tScanKeyData skey[1];\n\tHeapTuple\thtup;\n\tint\t\t\tfound = 0;\n\n\tScanKeyInit(&skey[0],\n\t\t\t\tAnum_pg_constraint_conrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tconrel = heap_open(ConstraintRelationId, AccessShareLock);\n\tconscan = systable_beginscan(conrel, ConstraintRelidTypidNameIndexId, true,\n\t\t\t\t\t\t\t\t NULL, 1, skey);\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(conscan)))\n\t{\n\t\tForm_pg_constraint conform = (Form_pg_constraint) GETSTRUCT(htup);\n\t\tDatum\t\tval;\n\t\tbool\t\tisnull;\n\t\tchar\t   *s;\n\n\t\t/* We want check constraints only */\n\t\tif (conform->contype != CONSTRAINT_CHECK)\n\t\t\tcontinue;\n\n\t\tif (found >= ncheck)\n\t\t\telog(ERROR, \"unexpected constraint record found for rel %s\",\n\t\t\t\t RelationGetRelationName(relation));\n\n\t\tcheck[found].ccvalid = conform->convalidated;\n\t\tcheck[found].ccnoinherit = conform->connoinherit;\n\t\tcheck[found].ccname = MemoryContextStrdup(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t  NameStr(conform->conname));\n\n\t\t/* Grab and test conbin is actually set */\n\t\tval = fastgetattr(htup,\n\t\t\t\t\t\t  Anum_pg_constraint_conbin,\n\t\t\t\t\t\t  conrel->rd_att, &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"null conbin for rel %s\",\n\t\t\t\t RelationGetRelationName(relation));\n\n\t\t/* detoast and convert to cstring in caller's context */\n\t\ts = TextDatumGetCString(val);\n\t\tcheck[found].ccbin = MemoryContextStrdup(CacheMemoryContext, s);\n\t\tpfree(s);\n\n\t\tfound++;\n\t}\n\n\tsystable_endscan(conscan);\n\theap_close(conrel, AccessShareLock);\n\n\tif (found != ncheck)\n\t\telog(ERROR, \"%d constraint record(s) missing for rel %s\",\n\t\t\t ncheck - found, RelationGetRelationName(relation));\n\n\t/* Sort the records so that CHECKs are applied in a deterministic order */\n\tif (ncheck > 1)\n\t\tqsort(check, ncheck, sizeof(ConstrCheck), CheckConstraintCmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "CacheMemoryContext",
            "constr->num_check * sizeof(ConstrCheck)"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AttrDefaultFetch",
          "args": [
            "relation"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "AttrDefaultFetch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "3964-4029",
          "snippet": "static void\nAttrDefaultFetch(Relation relation)\n{\n\tAttrDefault *attrdef = relation->rd_att->constr->defval;\n\tint\t\t\tndef = relation->rd_att->constr->num_defval;\n\tRelation\tadrel;\n\tSysScanDesc adscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tint\t\t\tfound;\n\tint\t\t\ti;\n\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_attrdef_adrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tadrel = heap_open(AttrDefaultRelationId, AccessShareLock);\n\tadscan = systable_beginscan(adrel, AttrDefaultIndexId, true,\n\t\t\t\t\t\t\t\tNULL, 1, &skey);\n\tfound = 0;\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(adscan)))\n\t{\n\t\tForm_pg_attrdef adform = (Form_pg_attrdef) GETSTRUCT(htup);\n\t\tForm_pg_attribute attr = TupleDescAttr(relation->rd_att, adform->adnum - 1);\n\n\t\tfor (i = 0; i < ndef; i++)\n\t\t{\n\t\t\tif (adform->adnum != attrdef[i].adnum)\n\t\t\t\tcontinue;\n\t\t\tif (attrdef[i].adbin != NULL)\n\t\t\t\telog(WARNING, \"multiple attrdef records found for attr %s of rel %s\",\n\t\t\t\t\t NameStr(attr->attname),\n\t\t\t\t\t RelationGetRelationName(relation));\n\t\t\telse\n\t\t\t\tfound++;\n\n\t\t\tval = fastgetattr(htup,\n\t\t\t\t\t\t\t  Anum_pg_attrdef_adbin,\n\t\t\t\t\t\t\t  adrel->rd_att, &isnull);\n\t\t\tif (isnull)\n\t\t\t\telog(WARNING, \"null adbin for attr %s of rel %s\",\n\t\t\t\t\t NameStr(attr->attname),\n\t\t\t\t\t RelationGetRelationName(relation));\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* detoast and convert to cstring in caller's context */\n\t\t\t\tchar\t   *s = TextDatumGetCString(val);\n\n\t\t\t\tattrdef[i].adbin = MemoryContextStrdup(CacheMemoryContext, s);\n\t\t\t\tpfree(s);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i >= ndef)\n\t\t\telog(WARNING, \"unexpected attrdef record found for attr %d of rel %s\",\n\t\t\t\t adform->adnum, RelationGetRelationName(relation));\n\t}\n\n\tsystable_endscan(adscan);\n\theap_close(adrel, AccessShareLock);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void RelationReloadIndexInfo(Relation relation);",
            "static void RelationReloadNailed(Relation relation);",
            "static void RelationFlushRelation(Relation relation);",
            "static void RelationBuildTupleDesc(Relation relation);",
            "static void RelationInitPhysicalAddr(Relation relation);",
            "static void AttrDefaultFetch(Relation relation);",
            "static void CheckConstraintFetch(Relation relation);",
            "static void InitIndexAmRoutine(Relation relation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nAttrDefaultFetch(Relation relation)\n{\n\tAttrDefault *attrdef = relation->rd_att->constr->defval;\n\tint\t\t\tndef = relation->rd_att->constr->num_defval;\n\tRelation\tadrel;\n\tSysScanDesc adscan;\n\tScanKeyData skey;\n\tHeapTuple\thtup;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tint\t\t\tfound;\n\tint\t\t\ti;\n\n\tScanKeyInit(&skey,\n\t\t\t\tAnum_pg_attrdef_adrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\n\tadrel = heap_open(AttrDefaultRelationId, AccessShareLock);\n\tadscan = systable_beginscan(adrel, AttrDefaultIndexId, true,\n\t\t\t\t\t\t\t\tNULL, 1, &skey);\n\tfound = 0;\n\n\twhile (HeapTupleIsValid(htup = systable_getnext(adscan)))\n\t{\n\t\tForm_pg_attrdef adform = (Form_pg_attrdef) GETSTRUCT(htup);\n\t\tForm_pg_attribute attr = TupleDescAttr(relation->rd_att, adform->adnum - 1);\n\n\t\tfor (i = 0; i < ndef; i++)\n\t\t{\n\t\t\tif (adform->adnum != attrdef[i].adnum)\n\t\t\t\tcontinue;\n\t\t\tif (attrdef[i].adbin != NULL)\n\t\t\t\telog(WARNING, \"multiple attrdef records found for attr %s of rel %s\",\n\t\t\t\t\t NameStr(attr->attname),\n\t\t\t\t\t RelationGetRelationName(relation));\n\t\t\telse\n\t\t\t\tfound++;\n\n\t\t\tval = fastgetattr(htup,\n\t\t\t\t\t\t\t  Anum_pg_attrdef_adbin,\n\t\t\t\t\t\t\t  adrel->rd_att, &isnull);\n\t\t\tif (isnull)\n\t\t\t\telog(WARNING, \"null adbin for attr %s of rel %s\",\n\t\t\t\t\t NameStr(attr->attname),\n\t\t\t\t\t RelationGetRelationName(relation));\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* detoast and convert to cstring in caller's context */\n\t\t\t\tchar\t   *s = TextDatumGetCString(val);\n\n\t\t\t\tattrdef[i].adbin = MemoryContextStrdup(CacheMemoryContext, s);\n\t\t\t\tpfree(s);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i >= ndef)\n\t\t\telog(WARNING, \"unexpected attrdef record found for attr %d of rel %s\",\n\t\t\t\t adform->adnum, RelationGetRelationName(relation));\n\t}\n\n\tsystable_endscan(adscan);\n\theap_close(adrel, AccessShareLock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "attrdef",
            "ndef * sizeof(AttrDefault)"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "repalloc_huge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1113-1141",
          "snippet": "void *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nrepalloc_huge(void *pointer, Size size)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\tvoid\t   *ret;\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tAssertNotInCriticalSection(context);\n\n\t/* isReset must be false already */\n\tAssert(!context->isReset);\n\n\tret = context->methods->realloc(context, pointer, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_CHANGE(context, pointer, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetNumberOfAttributes",
          "args": [
            "relation"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "relation->rd_att",
            "0"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetNumberOfAttributes",
          "args": [
            "relation"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "TupleDescAttr(relation->rd_att, i)->attcacheoff == -1"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "relation->rd_att",
            "i"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetNumberOfAttributes",
          "args": [
            "relation"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"catalog is missing %d attribute(s) for relid %u\"",
            "need",
            "RelationGetRelid(relation)"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "pg_attribute_desc",
            "AccessShareLock"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan",
          "args": [
            "pg_attribute_scan"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datumCopy",
          "args": [
            "missval",
            "attp->attbyval",
            "attp->attlen"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "datumCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datum.c",
          "lines": "127-176",
          "snippet": "Datum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"utils/expandeddatum.h\"",
            "#include \"utils/datum.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/expandeddatum.h\"\n#include \"utils/datum.h\"\n#include \"postgres.h\"\n\nDatum\ndatumCopy(Datum value, bool typByVal, int typLen)\n{\n\tDatum\t\tres;\n\n\tif (typByVal)\n\t\tres = value;\n\telse if (typLen == -1)\n\t{\n\t\t/* It is a varlena datatype */\n\t\tstruct varlena *vl = (struct varlena *) DatumGetPointer(value);\n\n\t\tif (VARATT_IS_EXTERNAL_EXPANDED(vl))\n\t\t{\n\t\t\t/* Flatten into the caller's memory context */\n\t\t\tExpandedObjectHeader *eoh = DatumGetEOHP(value);\n\t\t\tSize\t\tresultsize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\tresultsize = EOH_get_flat_size(eoh);\n\t\t\tresultptr = (char *) palloc(resultsize);\n\t\t\tEOH_flatten_into(eoh, (void *) resultptr, resultsize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Otherwise, just copy the varlena datum verbatim */\n\t\t\tSize\t\trealSize;\n\t\t\tchar\t   *resultptr;\n\n\t\t\trealSize = (Size) VARSIZE_ANY(vl);\n\t\t\tresultptr = (char *) palloc(realSize);\n\t\t\tmemcpy(resultptr, vl, realSize);\n\t\t\tres = PointerGetDatum(resultptr);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Pass by reference, but not varlena, so not toasted */\n\t\tSize\t\trealSize;\n\t\tchar\t   *resultptr;\n\n\t\trealSize = datumGetSize(value, typByVal, typLen);\n\n\t\tresultptr = (char *) palloc(realSize);\n\t\tmemcpy(resultptr, DatumGetPointer(value), realSize);\n\t\tres = PointerGetDatum(resultptr);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!is_null"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_get_element",
          "args": [
            "missingval",
            "1",
            "&one",
            "-1",
            "attp->attlen",
            "attp->attbyval",
            "attp->attalign",
            "&is_null"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "array_get_element_expanded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "1919-1996",
          "snippet": "static Datum\narray_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull)\n{\n\tExpandedArrayHeader *eah;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t   *dim,\n\t\t\t   *lb,\n\t\t\t\toffset;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\n\teah = (ExpandedArrayHeader *) DatumGetEOHP(arraydatum);\n\tAssert(eah->ea_magic == EA_MAGIC);\n\n\t/* sanity-check caller's info against object */\n\tAssert(arraytyplen == -1);\n\tAssert(elmlen == eah->typlen);\n\tAssert(elmbyval == eah->typbyval);\n\tAssert(elmalign == eah->typalign);\n\n\tndim = eah->ndims;\n\tdim = eah->dims;\n\tlb = eah->lbound;\n\n\t/*\n\t * Return NULL for invalid subscript\n\t */\n\tif (ndim != nSubscripts || ndim <= 0 || ndim > MAXDIM)\n\t{\n\t\t*isNull = true;\n\t\treturn (Datum) 0;\n\t}\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tif (indx[i] < lb[i] || indx[i] >= (dim[i] + lb[i]))\n\t\t{\n\t\t\t*isNull = true;\n\t\t\treturn (Datum) 0;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the element number\n\t */\n\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\n\t/*\n\t * Deconstruct array if we didn't already.  Note that we apply this even\n\t * if the input is nominally read-only: it should be safe enough.\n\t */\n\tdeconstruct_expanded_array(eah);\n\n\tdvalues = eah->dvalues;\n\tdnulls = eah->dnulls;\n\n\t/*\n\t * Check for NULL array element\n\t */\n\tif (dnulls && dnulls[offset])\n\t{\n\t\t*isNull = true;\n\t\treturn (Datum) 0;\n\t}\n\n\t/*\n\t * OK, get the element.  It's OK to return a pass-by-ref value as a\n\t * pointer into the expanded array, for the same reason that regular\n\t * array_get_element can return a pointer into flat arrays: the value is\n\t * assumed not to change for as long as the Datum reference can exist.\n\t */\n\t*isNull = false;\n\treturn dvalues[offset];\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);",
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);",
            "static bool array_get_isnull(const bits8 *nullbitmap, int offset);",
            "static void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);",
            "static char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);",
            "static int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);",
            "static int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);",
            "static void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);",
            "static void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull);\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\nstatic bool array_get_isnull(const bits8 *nullbitmap, int offset);\nstatic void array_set_isnull(bits8 *nullbitmap, int offset, bool isNull);\nstatic char *array_seek(char *ptr, int offset, bits8 *nullbitmap, int nitems,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_nelems_size(char *ptr, int offset, bits8 *nullbitmap,\n\t\t\t\t  int nitems, int typlen, bool typbyval, char typalign);\nstatic int array_copy(char *destptr, int nitems,\n\t\t   char *srcptr, int offset, bits8 *nullbitmap,\n\t\t   int typlen, bool typbyval, char typalign);\nstatic int array_slice_size(char *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t int ndim, int *dim, int *lb,\n\t\t\t\t int *st, int *endp,\n\t\t\t\t int typlen, bool typbyval, char typalign);\nstatic void array_extract_slice(ArrayType *newarray,\n\t\t\t\t\tint ndim, int *dim, int *lb,\n\t\t\t\t\tchar *arraydataptr, bits8 *arraynullsptr,\n\t\t\t\t\tint *st, int *endp,\n\t\t\t\t\tint typlen, bool typbyval, char typalign);\nstatic void array_insert_slice(ArrayType *destArray, ArrayType *origArray,\n\t\t\t\t   ArrayType *srcArray,\n\t\t\t\t   int ndim, int *dim, int *lb,\n\t\t\t\t   int *st, int *endp,\n\t\t\t\t   int typlen, bool typbyval, char typalign);\n\nstatic Datum\narray_get_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t\t\t   bool *isNull)\n{\n\tExpandedArrayHeader *eah;\n\tint\t\t\ti,\n\t\t\t\tndim,\n\t\t\t   *dim,\n\t\t\t   *lb,\n\t\t\t\toffset;\n\tDatum\t   *dvalues;\n\tbool\t   *dnulls;\n\n\teah = (ExpandedArrayHeader *) DatumGetEOHP(arraydatum);\n\tAssert(eah->ea_magic == EA_MAGIC);\n\n\t/* sanity-check caller's info against object */\n\tAssert(arraytyplen == -1);\n\tAssert(elmlen == eah->typlen);\n\tAssert(elmbyval == eah->typbyval);\n\tAssert(elmalign == eah->typalign);\n\n\tndim = eah->ndims;\n\tdim = eah->dims;\n\tlb = eah->lbound;\n\n\t/*\n\t * Return NULL for invalid subscript\n\t */\n\tif (ndim != nSubscripts || ndim <= 0 || ndim > MAXDIM)\n\t{\n\t\t*isNull = true;\n\t\treturn (Datum) 0;\n\t}\n\tfor (i = 0; i < ndim; i++)\n\t{\n\t\tif (indx[i] < lb[i] || indx[i] >= (dim[i] + lb[i]))\n\t\t{\n\t\t\t*isNull = true;\n\t\t\treturn (Datum) 0;\n\t\t}\n\t}\n\n\t/*\n\t * Calculate the element number\n\t */\n\toffset = ArrayGetOffset(nSubscripts, dim, lb, indx);\n\n\t/*\n\t * Deconstruct array if we didn't already.  Note that we apply this even\n\t * if the input is nominally read-only: it should be safe enough.\n\t */\n\tdeconstruct_expanded_array(eah);\n\n\tdvalues = eah->dvalues;\n\tdnulls = eah->dnulls;\n\n\t/*\n\t * Check for NULL array element\n\t */\n\tif (dnulls && dnulls[offset])\n\t{\n\t\t*isNull = true;\n\t\treturn (Datum) 0;\n\t}\n\n\t/*\n\t * OK, get the element.  It's OK to return a pass-by-ref value as a\n\t * pointer into the expanded array, for the same reason that regular\n\t * array_get_element can return a pointer into flat arrays: the value is\n\t * assumed not to change for as long as the Datum reference can exist.\n\t */\n\t*isNull = false;\n\treturn dvalues[offset];\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_getattr",
          "args": [
            "pg_attribute_tuple",
            "Anum_pg_attribute_attmissingval",
            "pg_attribute_desc->rd_att",
            "&missingNull"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetNumberOfAttributes",
          "args": [
            "relation"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "TupleDescAttr(relation->rd_att, attnum - 1)",
            "attp",
            "ATTRIBUTE_FIXED_PART_SIZE"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "relation->rd_att",
            "attnum - 1"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelationName",
          "args": [
            "relation"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetNumberOfAttributes",
          "args": [
            "relation"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "pg_attribute_tuple"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "pg_attribute_tuple = systable_getnext(pg_attribute_scan)"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext",
          "args": [
            "pg_attribute_scan"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetNumberOfAttributes",
          "args": [
            "relation"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_beginscan",
          "args": [
            "pg_attribute_desc",
            "AttributeRelidNumIndexId",
            "criticalRelcachesBuilt",
            "NULL",
            "2",
            "skey"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "AttributeRelationId",
            "AccessShareLock"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyInit",
          "args": [
            "&skey[1]",
            "Anum_pg_attribute_attnum",
            "BTGreaterStrategyNumber",
            "F_INT2GT",
            "Int16GetDatum(0)"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int16GetDatum",
          "args": [
            "0"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyInit",
          "args": [
            "&skey[0]",
            "Anum_pg_attribute_attrelid",
            "BTEqualStrategyNumber",
            "F_OIDEQ",
            "ObjectIdGetDatum(RelationGetRelid(relation))"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "RelationGetRelid(relation)"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelationGetRelid",
          "args": [
            "relation"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "CacheMemoryContext",
            "sizeof(TupleConstr)"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nbool\t\tcriticalRelcachesBuilt = false;\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic List *insert_ordered_oid(List *list, Oid datum);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationBuildTupleDesc(Relation relation)\n{\n\tHeapTuple\tpg_attribute_tuple;\n\tRelation\tpg_attribute_desc;\n\tSysScanDesc pg_attribute_scan;\n\tScanKeyData skey[2];\n\tint\t\t\tneed;\n\tTupleConstr *constr;\n\tAttrDefault *attrdef = NULL;\n\tAttrMissing *attrmiss = NULL;\n\tint\t\t\tndef = 0;\n\n\t/* copy some fields from pg_class row to rd_att */\n\trelation->rd_att->tdtypeid = relation->rd_rel->reltype;\n\trelation->rd_att->tdtypmod = -1;\t/* unnecessary, but... */\n\trelation->rd_att->tdhasoid = relation->rd_rel->relhasoids;\n\n\tconstr = (TupleConstr *) MemoryContextAlloc(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\tsizeof(TupleConstr));\n\tconstr->has_not_null = false;\n\n\t/*\n\t * Form a scan key that selects only user attributes (attnum > 0).\n\t * (Eliminating system attribute rows at the index level is lots faster\n\t * than fetching them.)\n\t */\n\tScanKeyInit(&skey[0],\n\t\t\t\tAnum_pg_attribute_attrelid,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(RelationGetRelid(relation)));\n\tScanKeyInit(&skey[1],\n\t\t\t\tAnum_pg_attribute_attnum,\n\t\t\t\tBTGreaterStrategyNumber, F_INT2GT,\n\t\t\t\tInt16GetDatum(0));\n\n\t/*\n\t * Open pg_attribute and begin a scan.  Force heap scan if we haven't yet\n\t * built the critical relcache entries (this includes initdb and startup\n\t * without a pg_internal.init file).\n\t */\n\tpg_attribute_desc = heap_open(AttributeRelationId, AccessShareLock);\n\tpg_attribute_scan = systable_beginscan(pg_attribute_desc,\n\t\t\t\t\t\t\t\t\t\t   AttributeRelidNumIndexId,\n\t\t\t\t\t\t\t\t\t\t   criticalRelcachesBuilt,\n\t\t\t\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t\t\t\t   2, skey);\n\n\t/*\n\t * add attribute data to relation->rd_att\n\t */\n\tneed = RelationGetNumberOfAttributes(relation);\n\n\twhile (HeapTupleIsValid(pg_attribute_tuple = systable_getnext(pg_attribute_scan)))\n\t{\n\t\tForm_pg_attribute attp;\n\t\tint\t\t\tattnum;\n\n\t\tattp = (Form_pg_attribute) GETSTRUCT(pg_attribute_tuple);\n\n\t\tattnum = attp->attnum;\n\t\tif (attnum <= 0 || attnum > RelationGetNumberOfAttributes(relation))\n\t\t\telog(ERROR, \"invalid attribute number %d for %s\",\n\t\t\t\t attp->attnum, RelationGetRelationName(relation));\n\n\n\t\tmemcpy(TupleDescAttr(relation->rd_att, attnum - 1),\n\t\t\t   attp,\n\t\t\t   ATTRIBUTE_FIXED_PART_SIZE);\n\n\t\t/* Update constraint/default info */\n\t\tif (attp->attnotnull)\n\t\t\tconstr->has_not_null = true;\n\n\t\t/* If the column has a default, fill it into the attrdef array */\n\t\tif (attp->atthasdef)\n\t\t{\n\t\t\tif (attrdef == NULL)\n\t\t\t\tattrdef = (AttrDefault *)\n\t\t\t\t\tMemoryContextAllocZero(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t   RelationGetNumberOfAttributes(relation) *\n\t\t\t\t\t\t\t\t\t\t   sizeof(AttrDefault));\n\t\t\tattrdef[ndef].adnum = attnum;\n\t\t\tattrdef[ndef].adbin = NULL;\n\n\t\t\tndef++;\n\t\t}\n\n\t\t/* Likewise for a missing value */\n\t\tif (attp->atthasmissing)\n\t\t{\n\t\t\tDatum\t\tmissingval;\n\t\t\tbool\t\tmissingNull;\n\n\t\t\t/* Do we have a missing value? */\n\t\t\tmissingval = heap_getattr(pg_attribute_tuple,\n\t\t\t\t\t\t\t\t\t  Anum_pg_attribute_attmissingval,\n\t\t\t\t\t\t\t\t\t  pg_attribute_desc->rd_att,\n\t\t\t\t\t\t\t\t\t  &missingNull);\n\t\t\tif (!missingNull)\n\t\t\t{\n\t\t\t\t/* Yes, fetch from the array */\n\t\t\t\tMemoryContext oldcxt;\n\t\t\t\tbool\t\tis_null;\n\t\t\t\tint\t\t\tone = 1;\n\t\t\t\tDatum\t\tmissval;\n\n\t\t\t\tif (attrmiss == NULL)\n\t\t\t\t\tattrmiss = (AttrMissing *)\n\t\t\t\t\t\tMemoryContextAllocZero(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t   relation->rd_rel->relnatts *\n\t\t\t\t\t\t\t\t\t\t\t   sizeof(AttrMissing));\n\n\t\t\t\tmissval = array_get_element(missingval,\n\t\t\t\t\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\t\t\t\t\t&one,\n\t\t\t\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t\t\t\tattp->attlen,\n\t\t\t\t\t\t\t\t\t\t\tattp->attbyval,\n\t\t\t\t\t\t\t\t\t\t\tattp->attalign,\n\t\t\t\t\t\t\t\t\t\t\t&is_null);\n\t\t\t\tAssert(!is_null);\n\t\t\t\tif (attp->attbyval)\n\t\t\t\t{\n\t\t\t\t\t/* for copy by val just copy the datum direct */\n\t\t\t\t\tattrmiss[attnum - 1].am_value = missval;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/* otherwise copy in the correct context */\n\t\t\t\t\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\t\t\t\t\tattrmiss[attnum - 1].am_value = datumCopy(missval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  attp->attbyval,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  attp->attlen);\n\t\t\t\t\tMemoryContextSwitchTo(oldcxt);\n\t\t\t\t}\n\t\t\t\tattrmiss[attnum - 1].am_present = true;\n\t\t\t}\n\t\t}\n\t\tneed--;\n\t\tif (need == 0)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * end the scan and close the attribute relation\n\t */\n\tsystable_endscan(pg_attribute_scan);\n\theap_close(pg_attribute_desc, AccessShareLock);\n\n\tif (need != 0)\n\t\telog(ERROR, \"catalog is missing %d attribute(s) for relid %u\",\n\t\t\t need, RelationGetRelid(relation));\n\n\t/*\n\t * The attcacheoff values we read from pg_attribute should all be -1\n\t * (\"unknown\").  Verify this if assert checking is on.  They will be\n\t * computed when and if needed during tuple access.\n\t */\n#ifdef USE_ASSERT_CHECKING\n\t{\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < RelationGetNumberOfAttributes(relation); i++)\n\t\t\tAssert(TupleDescAttr(relation->rd_att, i)->attcacheoff == -1);\n\t}\n#endif\n\n\t/*\n\t * However, we can easily set the attcacheoff value for the first\n\t * attribute: it must be zero.  This eliminates the need for special cases\n\t * for attnum=1 that used to exist in fastgetattr() and index_getattr().\n\t */\n\tif (RelationGetNumberOfAttributes(relation) > 0)\n\t\tTupleDescAttr(relation->rd_att, 0)->attcacheoff = 0;\n\n\t/*\n\t * Set up constraint/default info\n\t */\n\tif (constr->has_not_null || ndef > 0 ||\n\t\tattrmiss || relation->rd_rel->relchecks)\n\t{\n\t\trelation->rd_att->constr = constr;\n\n\t\tif (ndef > 0)\t\t\t/* DEFAULTs */\n\t\t{\n\t\t\tif (ndef < RelationGetNumberOfAttributes(relation))\n\t\t\t\tconstr->defval = (AttrDefault *)\n\t\t\t\t\trepalloc(attrdef, ndef * sizeof(AttrDefault));\n\t\t\telse\n\t\t\t\tconstr->defval = attrdef;\n\t\t\tconstr->num_defval = ndef;\n\t\t\tAttrDefaultFetch(relation);\n\t\t}\n\t\telse\n\t\t\tconstr->num_defval = 0;\n\n\t\tconstr->missing = attrmiss;\n\n\t\tif (relation->rd_rel->relchecks > 0)\t/* CHECKs */\n\t\t{\n\t\t\tconstr->num_check = relation->rd_rel->relchecks;\n\t\t\tconstr->check = (ConstrCheck *)\n\t\t\t\tMemoryContextAllocZero(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t   constr->num_check * sizeof(ConstrCheck));\n\t\t\tCheckConstraintFetch(relation);\n\t\t}\n\t\telse\n\t\t\tconstr->num_check = 0;\n\t}\n\telse\n\t{\n\t\tpfree(constr);\n\t\trelation->rd_att->constr = NULL;\n\t}\n}"
  },
  {
    "function_name": "RelationParseRelOptions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "434-483",
    "snippet": "static void\nRelationParseRelOptions(Relation relation, HeapTuple tuple)\n{\n\tbytea\t   *options;\n\tamoptions_function amoptsfn;\n\n\trelation->rd_options = NULL;\n\n\t/*\n\t * Look up any AM-specific parse function; fall out if relkind should not\n\t * have options.\n\t */\n\tswitch (relation->rd_rel->relkind)\n\t{\n\t\tcase RELKIND_RELATION:\n\t\tcase RELKIND_TOASTVALUE:\n\t\tcase RELKIND_VIEW:\n\t\tcase RELKIND_MATVIEW:\n\t\tcase RELKIND_PARTITIONED_TABLE:\n\t\t\tamoptsfn = NULL;\n\t\t\tbreak;\n\t\tcase RELKIND_INDEX:\n\t\tcase RELKIND_PARTITIONED_INDEX:\n\t\t\tamoptsfn = relation->rd_amroutine->amoptions;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Fetch reloptions from tuple; have to use a hardwired descriptor because\n\t * we might not have any other for pg_class yet (consider executing this\n\t * code for pg_class itself)\n\t */\n\toptions = extractRelOptions(tuple, GetPgClassDescriptor(), amoptsfn);\n\n\t/*\n\t * Copy parsed data into CacheMemoryContext.  To guard against the\n\t * possibility of leaks in the reloptions code, we want to do the actual\n\t * parsing in the caller's memory context and copy the results into\n\t * CacheMemoryContext after the fact.\n\t */\n\tif (options)\n\t{\n\t\trelation->rd_options = MemoryContextAlloc(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t  VARSIZE(options));\n\t\tmemcpy(relation->rd_options, options, VARSIZE(options));\n\t\tpfree(options);\n\t}\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static TupleDesc GetPgClassDescriptor(void);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "options"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "relation->rd_options",
            "options",
            "VARSIZE(options)"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "options"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "CacheMemoryContext",
            "VARSIZE(options)"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "options"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extractRelOptions",
          "args": [
            "tuple",
            "GetPgClassDescriptor()",
            "amoptsfn"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetPgClassDescriptor",
          "args": [],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "GetPgClassDescriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
          "lines": "3933-3945",
          "snippet": "static TupleDesc\nGetPgClassDescriptor(void)\n{\n\tstatic TupleDesc pgclassdesc = NULL;\n\n\t/* Already done? */\n\tif (pgclassdesc == NULL)\n\t\tpgclassdesc = BuildHardcodedDescriptor(Natts_pg_class,\n\t\t\t\t\t\t\t\t\t\t\t   Desc_pg_class,\n\t\t\t\t\t\t\t\t\t\t\t   true);\n\n\treturn pgclassdesc;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"storage/smgr.h\"",
            "#include \"storage/lmgr.h\"",
            "#include \"rewrite/rowsecurity.h\"",
            "#include \"rewrite/rewriteDefine.h\"",
            "#include \"pgstat.h\"",
            "#include \"partitioning/partbounds.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/prep.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/policy.h\"",
            "#include \"catalog/storage.h\"",
            "#include \"catalog/schemapg.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_attrdef.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/partition.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/tupdesc_details.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/reloptions.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/multixact.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/file.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const FormData_pg_attribute Desc_pg_class[Natts_pg_class] = {Schema_pg_class};",
            "static TupleDesc GetPgClassDescriptor(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic const FormData_pg_attribute Desc_pg_class[Natts_pg_class] = {Schema_pg_class};\nstatic TupleDesc GetPgClassDescriptor(void);\n\nstatic TupleDesc\nGetPgClassDescriptor(void)\n{\n\tstatic TupleDesc pgclassdesc = NULL;\n\n\t/* Already done? */\n\tif (pgclassdesc == NULL)\n\t\tpgclassdesc = BuildHardcodedDescriptor(Natts_pg_class,\n\t\t\t\t\t\t\t\t\t\t\t   Desc_pg_class,\n\t\t\t\t\t\t\t\t\t\t\t   true);\n\n\treturn pgclassdesc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic TupleDesc GetPgClassDescriptor(void);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic void\nRelationParseRelOptions(Relation relation, HeapTuple tuple)\n{\n\tbytea\t   *options;\n\tamoptions_function amoptsfn;\n\n\trelation->rd_options = NULL;\n\n\t/*\n\t * Look up any AM-specific parse function; fall out if relkind should not\n\t * have options.\n\t */\n\tswitch (relation->rd_rel->relkind)\n\t{\n\t\tcase RELKIND_RELATION:\n\t\tcase RELKIND_TOASTVALUE:\n\t\tcase RELKIND_VIEW:\n\t\tcase RELKIND_MATVIEW:\n\t\tcase RELKIND_PARTITIONED_TABLE:\n\t\t\tamoptsfn = NULL;\n\t\t\tbreak;\n\t\tcase RELKIND_INDEX:\n\t\tcase RELKIND_PARTITIONED_INDEX:\n\t\t\tamoptsfn = relation->rd_amroutine->amoptions;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Fetch reloptions from tuple; have to use a hardwired descriptor because\n\t * we might not have any other for pg_class yet (consider executing this\n\t * code for pg_class itself)\n\t */\n\toptions = extractRelOptions(tuple, GetPgClassDescriptor(), amoptsfn);\n\n\t/*\n\t * Copy parsed data into CacheMemoryContext.  To guard against the\n\t * possibility of leaks in the reloptions code, we want to do the actual\n\t * parsing in the caller's memory context and copy the results into\n\t * CacheMemoryContext after the fact.\n\t */\n\tif (options)\n\t{\n\t\trelation->rd_options = MemoryContextAlloc(CacheMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t  VARSIZE(options));\n\t\tmemcpy(relation->rd_options, options, VARSIZE(options));\n\t\tpfree(options);\n\t}\n}"
  },
  {
    "function_name": "AllocateRelationDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "378-424",
    "snippet": "static Relation\nAllocateRelationDesc(Form_pg_class relp)\n{\n\tRelation\trelation;\n\tMemoryContext oldcxt;\n\tForm_pg_class relationForm;\n\n\t/* Relcache entries must live in CacheMemoryContext */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * allocate and zero space for new relation descriptor\n\t */\n\trelation = (Relation) palloc0(sizeof(RelationData));\n\n\t/* make sure relation is marked as having no open file yet */\n\trelation->rd_smgr = NULL;\n\n\t/*\n\t * Copy the relation tuple form\n\t *\n\t * We only allocate space for the fixed fields, ie, CLASS_TUPLE_SIZE. The\n\t * variable-length fields (relacl, reloptions) are NOT stored in the\n\t * relcache --- there'd be little point in it, since we don't copy the\n\t * tuple's nulls bitmap and hence wouldn't know if the values are valid.\n\t * Bottom line is that relacl *cannot* be retrieved from the relcache. Get\n\t * it from the syscache if you need it.  The same goes for the original\n\t * form of reloptions (however, we do store the parsed form of reloptions\n\t * in rd_options).\n\t */\n\trelationForm = (Form_pg_class) palloc(CLASS_TUPLE_SIZE);\n\n\tmemcpy(relationForm, relp, CLASS_TUPLE_SIZE);\n\n\t/* initialize relation tuple form */\n\trelation->rd_rel = relationForm;\n\n\t/* and allocate attribute tuple form storage */\n\trelation->rd_att = CreateTemplateTupleDesc(relationForm->relnatts,\n\t\t\t\t\t\t\t\t\t\t\t   relationForm->relhasoids);\n\t/* which we mark as a reference-counted tupdesc */\n\trelation->rd_att->tdrefcount = 1;\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn relation;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void RelationReloadIndexInfo(Relation relation);",
      "static void RelationReloadNailed(Relation relation);",
      "static void RelationFlushRelation(Relation relation);",
      "static Relation AllocateRelationDesc(Form_pg_class relp);",
      "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);",
      "static void RelationBuildTupleDesc(Relation relation);",
      "static void RelationInitPhysicalAddr(Relation relation);",
      "static void AttrDefaultFetch(Relation relation);",
      "static void CheckConstraintFetch(Relation relation);",
      "static void InitIndexAmRoutine(Relation relation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcxt"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTemplateTupleDesc",
          "args": [
            "relationForm->relnatts",
            "relationForm->relhasoids"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "relationForm",
            "relp",
            "CLASS_TUPLE_SIZE"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "CLASS_TUPLE_SIZE"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "CacheMemoryContext"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nstatic void RelationReloadIndexInfo(Relation relation);\nstatic void RelationReloadNailed(Relation relation);\nstatic void RelationFlushRelation(Relation relation);\nstatic Relation AllocateRelationDesc(Form_pg_class relp);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\nstatic void RelationBuildTupleDesc(Relation relation);\nstatic void RelationInitPhysicalAddr(Relation relation);\nstatic void AttrDefaultFetch(Relation relation);\nstatic void CheckConstraintFetch(Relation relation);\nstatic void InitIndexAmRoutine(Relation relation);\n\nstatic Relation\nAllocateRelationDesc(Form_pg_class relp)\n{\n\tRelation\trelation;\n\tMemoryContext oldcxt;\n\tForm_pg_class relationForm;\n\n\t/* Relcache entries must live in CacheMemoryContext */\n\toldcxt = MemoryContextSwitchTo(CacheMemoryContext);\n\n\t/*\n\t * allocate and zero space for new relation descriptor\n\t */\n\trelation = (Relation) palloc0(sizeof(RelationData));\n\n\t/* make sure relation is marked as having no open file yet */\n\trelation->rd_smgr = NULL;\n\n\t/*\n\t * Copy the relation tuple form\n\t *\n\t * We only allocate space for the fixed fields, ie, CLASS_TUPLE_SIZE. The\n\t * variable-length fields (relacl, reloptions) are NOT stored in the\n\t * relcache --- there'd be little point in it, since we don't copy the\n\t * tuple's nulls bitmap and hence wouldn't know if the values are valid.\n\t * Bottom line is that relacl *cannot* be retrieved from the relcache. Get\n\t * it from the syscache if you need it.  The same goes for the original\n\t * form of reloptions (however, we do store the parsed form of reloptions\n\t * in rd_options).\n\t */\n\trelationForm = (Form_pg_class) palloc(CLASS_TUPLE_SIZE);\n\n\tmemcpy(relationForm, relp, CLASS_TUPLE_SIZE);\n\n\t/* initialize relation tuple form */\n\trelation->rd_rel = relationForm;\n\n\t/* and allocate attribute tuple form storage */\n\trelation->rd_att = CreateTemplateTupleDesc(relationForm->relnatts,\n\t\t\t\t\t\t\t\t\t\t\t   relationForm->relhasoids);\n\t/* which we mark as a reference-counted tupdesc */\n\trelation->rd_att->tdrefcount = 1;\n\n\tMemoryContextSwitchTo(oldcxt);\n\n\treturn relation;\n}"
  },
  {
    "function_name": "ScanPgRelation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/relcache.c",
    "lines": "308-370",
    "snippet": "static HeapTuple\nScanPgRelation(Oid targetRelId, bool indexOK, bool force_non_historic)\n{\n\tHeapTuple\tpg_class_tuple;\n\tRelation\tpg_class_desc;\n\tSysScanDesc pg_class_scan;\n\tScanKeyData key[1];\n\tSnapshot\tsnapshot;\n\n\t/*\n\t * If something goes wrong during backend startup, we might find ourselves\n\t * trying to read pg_class before we've selected a database.  That ain't\n\t * gonna work, so bail out with a useful error message.  If this happens,\n\t * it probably means a relcache entry that needs to be nailed isn't.\n\t */\n\tif (!OidIsValid(MyDatabaseId))\n\t\telog(FATAL, \"cannot read pg_class without having selected a database\");\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(targetRelId));\n\n\t/*\n\t * Open pg_class and fetch a tuple.  Force heap scan if we haven't yet\n\t * built the critical relcache entries (this includes initdb and startup\n\t * without a pg_internal.init file).  The caller can also force a heap\n\t * scan by setting indexOK == false.\n\t */\n\tpg_class_desc = heap_open(RelationRelationId, AccessShareLock);\n\n\t/*\n\t * The caller might need a tuple that's newer than the one the historic\n\t * snapshot; currently the only case requiring to do so is looking up the\n\t * relfilenode of non mapped system relations during decoding.\n\t */\n\tif (force_non_historic)\n\t\tsnapshot = GetNonHistoricCatalogSnapshot(RelationRelationId);\n\telse\n\t\tsnapshot = GetCatalogSnapshot(RelationRelationId);\n\n\tpg_class_scan = systable_beginscan(pg_class_desc, ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t   indexOK && criticalRelcachesBuilt,\n\t\t\t\t\t\t\t\t\t   snapshot,\n\t\t\t\t\t\t\t\t\t   1, key);\n\n\tpg_class_tuple = systable_getnext(pg_class_scan);\n\n\t/*\n\t * Must copy tuple before releasing buffer.\n\t */\n\tif (HeapTupleIsValid(pg_class_tuple))\n\t\tpg_class_tuple = heap_copytuple(pg_class_tuple);\n\n\t/* all done */\n\tsystable_endscan(pg_class_scan);\n\theap_close(pg_class_desc, AccessShareLock);\n\n\treturn pg_class_tuple;\n}",
    "includes": [
      "#include \"utils/tqual.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/snapmgr.h\"",
      "#include \"utils/resowner_private.h\"",
      "#include \"utils/relmapper.h\"",
      "#include \"utils/partcache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/inval.h\"",
      "#include \"utils/fmgroids.h\"",
      "#include \"utils/datum.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"utils/array.h\"",
      "#include \"storage/smgr.h\"",
      "#include \"storage/lmgr.h\"",
      "#include \"rewrite/rowsecurity.h\"",
      "#include \"rewrite/rewriteDefine.h\"",
      "#include \"pgstat.h\"",
      "#include \"partitioning/partbounds.h\"",
      "#include \"optimizer/var.h\"",
      "#include \"optimizer/prep.h\"",
      "#include \"optimizer/cost.h\"",
      "#include \"optimizer/clauses.h\"",
      "#include \"nodes/nodeFuncs.h\"",
      "#include \"miscadmin.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"commands/policy.h\"",
      "#include \"catalog/storage.h\"",
      "#include \"catalog/schemapg.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_trigger.h\"",
      "#include \"catalog/pg_tablespace.h\"",
      "#include \"catalog/pg_subscription.h\"",
      "#include \"catalog/pg_statistic_ext.h\"",
      "#include \"catalog/pg_shseclabel.h\"",
      "#include \"catalog/pg_rewrite.h\"",
      "#include \"catalog/pg_publication.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_partitioned_table.h\"",
      "#include \"catalog/pg_opclass.h\"",
      "#include \"catalog/pg_namespace.h\"",
      "#include \"catalog/pg_database.h\"",
      "#include \"catalog/pg_constraint.h\"",
      "#include \"catalog/pg_auth_members.h\"",
      "#include \"catalog/pg_authid.h\"",
      "#include \"catalog/pg_attrdef.h\"",
      "#include \"catalog/pg_amproc.h\"",
      "#include \"catalog/pg_am.h\"",
      "#include \"catalog/partition.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"catalog/indexing.h\"",
      "#include \"catalog/catalog.h\"",
      "#include \"access/xlog.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/tupdesc_details.h\"",
      "#include \"access/sysattr.h\"",
      "#include \"access/reloptions.h\"",
      "#include \"access/nbtree.h\"",
      "#include \"access/multixact.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"access/hash.h\"",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/file.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool\t\tcriticalRelcachesBuilt = false;",
      "static HeapTuple ScanPgRelation(Oid targetRelId, bool indexOK, bool force_non_historic);",
      "static void RelationParseRelOptions(Relation relation, HeapTuple tuple);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "heap_close",
          "args": [
            "pg_class_desc",
            "AccessShareLock"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_endscan",
          "args": [
            "pg_class_scan"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_copytuple",
          "args": [
            "pg_class_tuple"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "pg_class_tuple"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_getnext",
          "args": [
            "pg_class_scan"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "systable_beginscan",
          "args": [
            "pg_class_desc",
            "ClassOidIndexId",
            "indexOK && criticalRelcachesBuilt",
            "snapshot",
            "1",
            "key"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCatalogSnapshot",
          "args": [
            "RelationRelationId"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "GetCatalogSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "439-453",
          "snippet": "Snapshot\nGetCatalogSnapshot(Oid relid)\n{\n\t/*\n\t * Return historic snapshot while we're doing logical decoding, so we can\n\t * see the appropriate state of the catalog.\n\t *\n\t * This is the primary reason for needing to reset the system caches after\n\t * finishing decoding.\n\t */\n\tif (HistoricSnapshotActive())\n\t\treturn HistoricSnapshot;\n\n\treturn GetNonHistoricCatalogSnapshot(relid);\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Snapshot HistoricSnapshot = NULL;",
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nstatic Snapshot HistoricSnapshot = NULL;\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nSnapshot\nGetCatalogSnapshot(Oid relid)\n{\n\t/*\n\t * Return historic snapshot while we're doing logical decoding, so we can\n\t * see the appropriate state of the catalog.\n\t *\n\t * This is the primary reason for needing to reset the system caches after\n\t * finishing decoding.\n\t */\n\tif (HistoricSnapshotActive())\n\t\treturn HistoricSnapshot;\n\n\treturn GetNonHistoricCatalogSnapshot(relid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetNonHistoricCatalogSnapshot",
          "args": [
            "RelationRelationId"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "GetNonHistoricCatalogSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/time/snapmgr.c",
          "lines": "461-497",
          "snippet": "Snapshot\nGetNonHistoricCatalogSnapshot(Oid relid)\n{\n\t/*\n\t * If the caller is trying to scan a relation that has no syscache, no\n\t * catcache invalidations will be sent when it is updated.  For a few key\n\t * relations, snapshot invalidations are sent instead.  If we're trying to\n\t * scan a relation for which neither catcache nor snapshot invalidations\n\t * are sent, we must refresh the snapshot every time.\n\t */\n\tif (CatalogSnapshot &&\n\t\t!RelationInvalidatesSnapshotsOnly(relid) &&\n\t\t!RelationHasSysCache(relid))\n\t\tInvalidateCatalogSnapshot();\n\n\tif (CatalogSnapshot == NULL)\n\t{\n\t\t/* Get new snapshot. */\n\t\tCatalogSnapshot = GetSnapshotData(&CatalogSnapshotData);\n\n\t\t/*\n\t\t * Make sure the catalog snapshot will be accounted for in decisions\n\t\t * about advancing PGXACT->xmin.  We could apply RegisterSnapshot, but\n\t\t * that would result in making a physical copy, which is overkill; and\n\t\t * it would also create a dependency on some resource owner, which we\n\t\t * do not want for reasons explained at the head of this file. Instead\n\t\t * just shove the CatalogSnapshot into the pairing heap manually. This\n\t\t * has to be reversed in InvalidateCatalogSnapshot, of course.\n\t\t *\n\t\t * NB: it had better be impossible for this to throw error, since the\n\t\t * CatalogSnapshot pointer is already valid.\n\t\t */\n\t\tpairingheap_add(&RegisteredSnapshots, &CatalogSnapshot->ph_node);\n\t}\n\n\treturn CatalogSnapshot;\n}",
          "includes": [
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/resowner_private.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/spin.h\"",
            "#include \"storage/sinvaladt.h\"",
            "#include \"storage/sinval.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/pairingheap.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/xlog.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "SnapshotData CatalogSnapshotData = {HeapTupleSatisfiesMVCC};",
            "static Snapshot CatalogSnapshot = NULL;",
            "static pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};",
            "static Snapshot CopySnapshot(Snapshot snapshot);",
            "static void FreeSnapshot(Snapshot snapshot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"storage/spin.h\"\n#include \"storage/sinvaladt.h\"\n#include \"storage/sinval.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/predicate.h\"\n#include \"miscadmin.h\"\n#include \"lib/pairingheap.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nSnapshotData CatalogSnapshotData = {HeapTupleSatisfiesMVCC};\nstatic Snapshot CatalogSnapshot = NULL;\nstatic pairingheap RegisteredSnapshots = {&xmin_cmp, NULL, NULL};\nstatic Snapshot CopySnapshot(Snapshot snapshot);\nstatic void FreeSnapshot(Snapshot snapshot);\n\nSnapshot\nGetNonHistoricCatalogSnapshot(Oid relid)\n{\n\t/*\n\t * If the caller is trying to scan a relation that has no syscache, no\n\t * catcache invalidations will be sent when it is updated.  For a few key\n\t * relations, snapshot invalidations are sent instead.  If we're trying to\n\t * scan a relation for which neither catcache nor snapshot invalidations\n\t * are sent, we must refresh the snapshot every time.\n\t */\n\tif (CatalogSnapshot &&\n\t\t!RelationInvalidatesSnapshotsOnly(relid) &&\n\t\t!RelationHasSysCache(relid))\n\t\tInvalidateCatalogSnapshot();\n\n\tif (CatalogSnapshot == NULL)\n\t{\n\t\t/* Get new snapshot. */\n\t\tCatalogSnapshot = GetSnapshotData(&CatalogSnapshotData);\n\n\t\t/*\n\t\t * Make sure the catalog snapshot will be accounted for in decisions\n\t\t * about advancing PGXACT->xmin.  We could apply RegisterSnapshot, but\n\t\t * that would result in making a physical copy, which is overkill; and\n\t\t * it would also create a dependency on some resource owner, which we\n\t\t * do not want for reasons explained at the head of this file. Instead\n\t\t * just shove the CatalogSnapshot into the pairing heap manually. This\n\t\t * has to be reversed in InvalidateCatalogSnapshot, of course.\n\t\t *\n\t\t * NB: it had better be impossible for this to throw error, since the\n\t\t * CatalogSnapshot pointer is already valid.\n\t\t */\n\t\tpairingheap_add(&RegisteredSnapshots, &CatalogSnapshot->ph_node);\n\t}\n\n\treturn CatalogSnapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "heap_open",
          "args": [
            "RelationRelationId",
            "AccessShareLock"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ScanKeyInit",
          "args": [
            "&key[0]",
            "ObjectIdAttributeNumber",
            "BTEqualStrategyNumber",
            "F_OIDEQ",
            "ObjectIdGetDatum(targetRelId)"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "targetRelId"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"cannot read pg_class without having selected a database\""
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "MyDatabaseId"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/resowner_private.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/partcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"storage/smgr.h\"\n#include \"storage/lmgr.h\"\n#include \"rewrite/rowsecurity.h\"\n#include \"rewrite/rewriteDefine.h\"\n#include \"pgstat.h\"\n#include \"partitioning/partbounds.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/prep.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"commands/trigger.h\"\n#include \"commands/policy.h\"\n#include \"catalog/storage.h\"\n#include \"catalog/schemapg.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_attrdef.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/partition.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/catalog.h\"\n#include \"access/xlog.h\"\n#include \"access/xact.h\"\n#include \"access/tupdesc_details.h\"\n#include \"access/sysattr.h\"\n#include \"access/reloptions.h\"\n#include \"access/nbtree.h\"\n#include \"access/multixact.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include \"postgres.h\"\n\nbool\t\tcriticalRelcachesBuilt = false;\nstatic HeapTuple ScanPgRelation(Oid targetRelId, bool indexOK, bool force_non_historic);\nstatic void RelationParseRelOptions(Relation relation, HeapTuple tuple);\n\nstatic HeapTuple\nScanPgRelation(Oid targetRelId, bool indexOK, bool force_non_historic)\n{\n\tHeapTuple\tpg_class_tuple;\n\tRelation\tpg_class_desc;\n\tSysScanDesc pg_class_scan;\n\tScanKeyData key[1];\n\tSnapshot\tsnapshot;\n\n\t/*\n\t * If something goes wrong during backend startup, we might find ourselves\n\t * trying to read pg_class before we've selected a database.  That ain't\n\t * gonna work, so bail out with a useful error message.  If this happens,\n\t * it probably means a relcache entry that needs to be nailed isn't.\n\t */\n\tif (!OidIsValid(MyDatabaseId))\n\t\telog(FATAL, \"cannot read pg_class without having selected a database\");\n\n\t/*\n\t * form a scan key\n\t */\n\tScanKeyInit(&key[0],\n\t\t\t\tObjectIdAttributeNumber,\n\t\t\t\tBTEqualStrategyNumber, F_OIDEQ,\n\t\t\t\tObjectIdGetDatum(targetRelId));\n\n\t/*\n\t * Open pg_class and fetch a tuple.  Force heap scan if we haven't yet\n\t * built the critical relcache entries (this includes initdb and startup\n\t * without a pg_internal.init file).  The caller can also force a heap\n\t * scan by setting indexOK == false.\n\t */\n\tpg_class_desc = heap_open(RelationRelationId, AccessShareLock);\n\n\t/*\n\t * The caller might need a tuple that's newer than the one the historic\n\t * snapshot; currently the only case requiring to do so is looking up the\n\t * relfilenode of non mapped system relations during decoding.\n\t */\n\tif (force_non_historic)\n\t\tsnapshot = GetNonHistoricCatalogSnapshot(RelationRelationId);\n\telse\n\t\tsnapshot = GetCatalogSnapshot(RelationRelationId);\n\n\tpg_class_scan = systable_beginscan(pg_class_desc, ClassOidIndexId,\n\t\t\t\t\t\t\t\t\t   indexOK && criticalRelcachesBuilt,\n\t\t\t\t\t\t\t\t\t   snapshot,\n\t\t\t\t\t\t\t\t\t   1, key);\n\n\tpg_class_tuple = systable_getnext(pg_class_scan);\n\n\t/*\n\t * Must copy tuple before releasing buffer.\n\t */\n\tif (HeapTupleIsValid(pg_class_tuple))\n\t\tpg_class_tuple = heap_copytuple(pg_class_tuple);\n\n\t/* all done */\n\tsystable_endscan(pg_class_scan);\n\theap_close(pg_class_desc, AccessShareLock);\n\n\treturn pg_class_tuple;\n}"
  }
]