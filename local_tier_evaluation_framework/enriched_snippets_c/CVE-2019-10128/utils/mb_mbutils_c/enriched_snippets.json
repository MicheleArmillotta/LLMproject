[
  {
    "function_name": "pgwin32_message_to_UTF16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "1046-1103",
    "snippet": "WCHAR *\npgwin32_message_to_UTF16(const char *str, int len, int *utf16len)\n{\n\tWCHAR\t   *utf16;\n\tint\t\t\tdstlen;\n\tUINT\t\tcodepage;\n\n\tcodepage = pg_enc2name_tbl[GetMessageEncoding()].codepage;\n\n\t/*\n\t * Use MultiByteToWideChar directly if there is a corresponding codepage,\n\t * or double conversion through UTF8 if not.  Double conversion is needed,\n\t * for example, in an ENCODING=LATIN8, LC_CTYPE=C database.\n\t */\n\tif (codepage != 0)\n\t{\n\t\tutf16 = (WCHAR *) palloc(sizeof(WCHAR) * (len + 1));\n\t\tdstlen = MultiByteToWideChar(codepage, 0, str, len, utf16, len);\n\t\tutf16[dstlen] = (WCHAR) 0;\n\t}\n\telse\n\t{\n\t\tchar\t   *utf8;\n\n\t\t/*\n\t\t * XXX pg_do_encoding_conversion() requires a transaction.  In the\n\t\t * absence of one, hope for the input to be valid UTF8.\n\t\t */\n\t\tif (IsTransactionState())\n\t\t{\n\t\t\tutf8 = (char *) pg_do_encoding_conversion((unsigned char *) str,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  GetMessageEncoding(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PG_UTF8);\n\t\t\tif (utf8 != str)\n\t\t\t\tlen = strlen(utf8);\n\t\t}\n\t\telse\n\t\t\tutf8 = (char *) str;\n\n\t\tutf16 = (WCHAR *) palloc(sizeof(WCHAR) * (len + 1));\n\t\tdstlen = MultiByteToWideChar(CP_UTF8, 0, utf8, len, utf16, len);\n\t\tutf16[dstlen] = (WCHAR) 0;\n\n\t\tif (utf8 != str)\n\t\t\tpfree(utf8);\n\t}\n\n\tif (dstlen == 0 && len > 0)\n\t{\n\t\tpfree(utf16);\n\t\treturn NULL;\t\t\t/* error */\n\t}\n\n\tif (utf16len)\n\t\t*utf16len = dstlen;\n\treturn utf16;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "utf16"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MultiByteToWideChar",
          "args": [
            "CP_UTF8",
            "0",
            "utf8",
            "len",
            "utf16",
            "len"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(WCHAR) * (len + 1)"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "utf8"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "773-788",
          "snippet": "int\npg_mbstrlen(const char *mbstr)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn strlen(mbstr);\n\n\twhile (*mbstr)\n\t{\n\t\tmbstr += pg_mblen(mbstr);\n\t\tlen++;\n\t}\n\treturn len;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nint\npg_mbstrlen(const char *mbstr)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn strlen(mbstr);\n\n\twhile (*mbstr)\n\t{\n\t\tmbstr += pg_mblen(mbstr);\n\t\tlen++;\n\t}\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_do_encoding_conversion",
          "args": [
            "(unsigned char *) str",
            "len",
            "GetMessageEncoding()",
            "PG_UTF8"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "pg_do_encoding_conversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "325-378",
          "snippet": "unsigned char *\npg_do_encoding_conversion(unsigned char *src, int len,\n\t\t\t\t\t\t  int src_encoding, int dest_encoding)\n{\n\tunsigned char *result;\n\tOid\t\t\tproc;\n\n\tif (len <= 0)\n\t\treturn src;\t\t\t\t/* empty string is always valid */\n\n\tif (src_encoding == dest_encoding)\n\t\treturn src;\t\t\t\t/* no conversion required, assume valid */\n\n\tif (dest_encoding == PG_SQL_ASCII)\n\t\treturn src;\t\t\t\t/* any string is valid in SQL_ASCII */\n\n\tif (src_encoding == PG_SQL_ASCII)\n\t{\n\t\t/* No conversion is possible, but we must validate the result */\n\t\t(void) pg_verify_mbstr(dest_encoding, (const char *) src, len, false);\n\t\treturn src;\n\t}\n\n\tif (!IsTransactionState())\t/* shouldn't happen */\n\t\telog(ERROR, \"cannot perform encoding conversion outside a transaction\");\n\n\tproc = FindDefaultConversionProc(src_encoding, dest_encoding);\n\tif (!OidIsValid(proc))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"default conversion function for encoding \\\"%s\\\" to \\\"%s\\\" does not exist\",\n\t\t\t\t\t\tpg_encoding_to_char(src_encoding),\n\t\t\t\t\t\tpg_encoding_to_char(dest_encoding))));\n\n\t/*\n\t * Allocate space for conversion result, being wary of integer overflow\n\t */\n\tif ((Size) len >= (MaxAllocSize / (Size) MAX_CONVERSION_GROWTH))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"String of %d bytes is too long for encoding conversion.\",\n\t\t\t\t\t\t   len)));\n\n\tresult = palloc(len * MAX_CONVERSION_GROWTH + 1);\n\n\tOidFunctionCall5(proc,\n\t\t\t\t\t Int32GetDatum(src_encoding),\n\t\t\t\t\t Int32GetDatum(dest_encoding),\n\t\t\t\t\t CStringGetDatum(src),\n\t\t\t\t\t CStringGetDatum(result),\n\t\t\t\t\t Int32GetDatum(len));\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nunsigned char *\npg_do_encoding_conversion(unsigned char *src, int len,\n\t\t\t\t\t\t  int src_encoding, int dest_encoding)\n{\n\tunsigned char *result;\n\tOid\t\t\tproc;\n\n\tif (len <= 0)\n\t\treturn src;\t\t\t\t/* empty string is always valid */\n\n\tif (src_encoding == dest_encoding)\n\t\treturn src;\t\t\t\t/* no conversion required, assume valid */\n\n\tif (dest_encoding == PG_SQL_ASCII)\n\t\treturn src;\t\t\t\t/* any string is valid in SQL_ASCII */\n\n\tif (src_encoding == PG_SQL_ASCII)\n\t{\n\t\t/* No conversion is possible, but we must validate the result */\n\t\t(void) pg_verify_mbstr(dest_encoding, (const char *) src, len, false);\n\t\treturn src;\n\t}\n\n\tif (!IsTransactionState())\t/* shouldn't happen */\n\t\telog(ERROR, \"cannot perform encoding conversion outside a transaction\");\n\n\tproc = FindDefaultConversionProc(src_encoding, dest_encoding);\n\tif (!OidIsValid(proc))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"default conversion function for encoding \\\"%s\\\" to \\\"%s\\\" does not exist\",\n\t\t\t\t\t\tpg_encoding_to_char(src_encoding),\n\t\t\t\t\t\tpg_encoding_to_char(dest_encoding))));\n\n\t/*\n\t * Allocate space for conversion result, being wary of integer overflow\n\t */\n\tif ((Size) len >= (MaxAllocSize / (Size) MAX_CONVERSION_GROWTH))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"String of %d bytes is too long for encoding conversion.\",\n\t\t\t\t\t\t   len)));\n\n\tresult = palloc(len * MAX_CONVERSION_GROWTH + 1);\n\n\tOidFunctionCall5(proc,\n\t\t\t\t\t Int32GetDatum(src_encoding),\n\t\t\t\t\t Int32GetDatum(dest_encoding),\n\t\t\t\t\t CStringGetDatum(src),\n\t\t\t\t\t CStringGetDatum(result),\n\t\t\t\t\t Int32GetDatum(len));\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetMessageEncoding",
          "args": [],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "GetMessageEncoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1033-1037",
          "snippet": "int\nGetMessageEncoding(void)\n{\n\treturn MessageEncoding->encoding;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *MessageEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *MessageEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\nGetMessageEncoding(void)\n{\n\treturn MessageEncoding->encoding;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsTransactionState",
          "args": [],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MultiByteToWideChar",
          "args": [
            "codepage",
            "0",
            "str",
            "len",
            "utf16",
            "len"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nWCHAR *\npgwin32_message_to_UTF16(const char *str, int len, int *utf16len)\n{\n\tWCHAR\t   *utf16;\n\tint\t\t\tdstlen;\n\tUINT\t\tcodepage;\n\n\tcodepage = pg_enc2name_tbl[GetMessageEncoding()].codepage;\n\n\t/*\n\t * Use MultiByteToWideChar directly if there is a corresponding codepage,\n\t * or double conversion through UTF8 if not.  Double conversion is needed,\n\t * for example, in an ENCODING=LATIN8, LC_CTYPE=C database.\n\t */\n\tif (codepage != 0)\n\t{\n\t\tutf16 = (WCHAR *) palloc(sizeof(WCHAR) * (len + 1));\n\t\tdstlen = MultiByteToWideChar(codepage, 0, str, len, utf16, len);\n\t\tutf16[dstlen] = (WCHAR) 0;\n\t}\n\telse\n\t{\n\t\tchar\t   *utf8;\n\n\t\t/*\n\t\t * XXX pg_do_encoding_conversion() requires a transaction.  In the\n\t\t * absence of one, hope for the input to be valid UTF8.\n\t\t */\n\t\tif (IsTransactionState())\n\t\t{\n\t\t\tutf8 = (char *) pg_do_encoding_conversion((unsigned char *) str,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  GetMessageEncoding(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PG_UTF8);\n\t\t\tif (utf8 != str)\n\t\t\t\tlen = strlen(utf8);\n\t\t}\n\t\telse\n\t\t\tutf8 = (char *) str;\n\n\t\tutf16 = (WCHAR *) palloc(sizeof(WCHAR) * (len + 1));\n\t\tdstlen = MultiByteToWideChar(CP_UTF8, 0, utf8, len, utf16, len);\n\t\tutf16[dstlen] = (WCHAR) 0;\n\n\t\tif (utf8 != str)\n\t\t\tpfree(utf8);\n\t}\n\n\tif (dstlen == 0 && len > 0)\n\t{\n\t\tpfree(utf16);\n\t\treturn NULL;\t\t\t/* error */\n\t}\n\n\tif (utf16len)\n\t\t*utf16len = dstlen;\n\treturn utf16;\n}"
  },
  {
    "function_name": "GetMessageEncoding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "1033-1037",
    "snippet": "int\nGetMessageEncoding(void)\n{\n\treturn MessageEncoding->encoding;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *MessageEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *MessageEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\nGetMessageEncoding(void)\n{\n\treturn MessageEncoding->encoding;\n}"
  },
  {
    "function_name": "pg_client_encoding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "1021-1025",
    "snippet": "Datum\npg_client_encoding(PG_FUNCTION_ARGS)\n{\n\treturn DirectFunctionCall1(namein, CStringGetDatum(ClientEncoding->name));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "namein",
            "CStringGetDatum(ClientEncoding->name)"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "ClientEncoding->name"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nDatum\npg_client_encoding(PG_FUNCTION_ARGS)\n{\n\treturn DirectFunctionCall1(namein, CStringGetDatum(ClientEncoding->name));\n}"
  },
  {
    "function_name": "getdatabaseencoding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "1015-1019",
    "snippet": "Datum\ngetdatabaseencoding(PG_FUNCTION_ARGS)\n{\n\treturn DirectFunctionCall1(namein, CStringGetDatum(DatabaseEncoding->name));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "namein",
            "CStringGetDatum(DatabaseEncoding->name)"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "DatabaseEncoding->name"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nDatum\ngetdatabaseencoding(PG_FUNCTION_ARGS)\n{\n\treturn DirectFunctionCall1(namein, CStringGetDatum(DatabaseEncoding->name));\n}"
  },
  {
    "function_name": "GetDatabaseEncodingName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "1009-1013",
    "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
  },
  {
    "function_name": "GetDatabaseEncoding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "1003-1007",
    "snippet": "int\nGetDatabaseEncoding(void)\n{\n\treturn DatabaseEncoding->encoding;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\nGetDatabaseEncoding(void)\n{\n\treturn DatabaseEncoding->encoding;\n}"
  },
  {
    "function_name": "pg_bind_textdomain_codeset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "968-995",
    "snippet": "int\npg_bind_textdomain_codeset(const char *domainname)\n{\n\tbool\t\telog_ok = (CurrentMemoryContext != NULL);\n\tint\t\t\tencoding = GetDatabaseEncoding();\n\tint\t\t\tnew_msgenc;\n\n#ifndef WIN32\n\tconst char *ctype = setlocale(LC_CTYPE, NULL);\n\n\tif (pg_strcasecmp(ctype, \"C\") == 0 || pg_strcasecmp(ctype, \"POSIX\") == 0)\n#endif\n\t\tif (encoding != PG_SQL_ASCII &&\n\t\t\traw_pg_bind_textdomain_codeset(domainname, encoding))\n\t\t\treturn encoding;\n\n\tnew_msgenc = pg_get_encoding_from_locale(NULL, elog_ok);\n\tif (new_msgenc < 0)\n\t\tnew_msgenc = PG_SQL_ASCII;\n\n#ifdef WIN32\n\tif (!raw_pg_bind_textdomain_codeset(domainname, new_msgenc))\n\t\t/* On failure, the old message encoding remains valid. */\n\t\treturn GetMessageEncoding();\n#endif\n\n\treturn new_msgenc;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetMessageEncoding",
          "args": [],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "GetMessageEncoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1033-1037",
          "snippet": "int\nGetMessageEncoding(void)\n{\n\treturn MessageEncoding->encoding;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *MessageEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *MessageEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\nGetMessageEncoding(void)\n{\n\treturn MessageEncoding->encoding;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_pg_bind_textdomain_codeset",
          "args": [
            "domainname",
            "new_msgenc"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "raw_pg_bind_textdomain_codeset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "923-947",
          "snippet": "static bool\nraw_pg_bind_textdomain_codeset(const char *domainname, int encoding)\n{\n\tbool\t\telog_ok = (CurrentMemoryContext != NULL);\n\tint\t\t\ti;\n\n\tfor (i = 0; pg_enc2gettext_tbl[i].name != NULL; i++)\n\t{\n\t\tif (pg_enc2gettext_tbl[i].encoding == encoding)\n\t\t{\n\t\t\tif (bind_textdomain_codeset(domainname,\n\t\t\t\t\t\t\t\t\t\tpg_enc2gettext_tbl[i].name) != NULL)\n\t\t\t\treturn true;\n\n\t\t\tif (elog_ok)\n\t\t\t\telog(LOG, \"bind_textdomain_codeset failed\");\n\t\t\telse\n\t\t\t\twrite_stderr(\"bind_textdomain_codeset failed\");\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic bool\nraw_pg_bind_textdomain_codeset(const char *domainname, int encoding)\n{\n\tbool\t\telog_ok = (CurrentMemoryContext != NULL);\n\tint\t\t\ti;\n\n\tfor (i = 0; pg_enc2gettext_tbl[i].name != NULL; i++)\n\t{\n\t\tif (pg_enc2gettext_tbl[i].encoding == encoding)\n\t\t{\n\t\t\tif (bind_textdomain_codeset(domainname,\n\t\t\t\t\t\t\t\t\t\tpg_enc2gettext_tbl[i].name) != NULL)\n\t\t\t\treturn true;\n\n\t\t\tif (elog_ok)\n\t\t\t\telog(LOG, \"bind_textdomain_codeset failed\");\n\t\t\telse\n\t\t\t\twrite_stderr(\"bind_textdomain_codeset failed\");\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_get_encoding_from_locale",
          "args": [
            "NULL",
            "elog_ok"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strcasecmp",
          "args": [
            "ctype",
            "\"POSIX\""
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strcasecmp",
          "args": [
            "ctype",
            "\"C\""
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setlocale",
          "args": [
            "LC_CTYPE",
            "NULL"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "pg_perm_setlocale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/pg_locale.c",
          "lines": "151-251",
          "snippet": "char *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}",
          "includes": [
            "#include <shlwapi.h>",
            "#include <unicode/ucnv.h>",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_control.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/htup_details.h\"",
            "#include <time.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define LC_ENV_BUFSIZE (NAMEDATALEN + 20)"
          ],
          "globals_used": [
            "static char lc_collate_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_ctype_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_monetary_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_numeric_envbuf[LC_ENV_BUFSIZE];",
            "static char lc_time_envbuf[LC_ENV_BUFSIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <shlwapi.h>\n#include <unicode/ucnv.h>\n#include \"utils/syscache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_control.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/htup_details.h\"\n#include <time.h>\n#include \"postgres.h\"\n\n#define LC_ENV_BUFSIZE (NAMEDATALEN + 20)\n\nstatic char lc_collate_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_ctype_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_monetary_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_numeric_envbuf[LC_ENV_BUFSIZE];\nstatic char lc_time_envbuf[LC_ENV_BUFSIZE];\n\nchar *\npg_perm_setlocale(int category, const char *locale)\n{\n\tchar\t   *result;\n\tconst char *envvar;\n\tchar\t   *envbuf;\n\n#ifndef WIN32\n\tresult = setlocale(category, locale);\n#else\n\n\t/*\n\t * On Windows, setlocale(LC_MESSAGES) does not work, so just assume that\n\t * the given value is good and set it in the environment variables. We\n\t * must ignore attempts to set to \"\", which means \"keep using the old\n\t * environment value\".\n\t */\n#ifdef LC_MESSAGES\n\tif (category == LC_MESSAGES)\n\t{\n\t\tresult = (char *) locale;\n\t\tif (locale == NULL || locale[0] == '\\0')\n\t\t\treturn result;\n\t}\n\telse\n#endif\n\t\tresult = setlocale(category, locale);\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\tif (result == NULL)\n\t\treturn result;\t\t\t/* fall out immediately on failure */\n\n\t/*\n\t * Use the right encoding in translated messages.  Under ENABLE_NLS, let\n\t * pg_bind_textdomain_codeset() figure it out.  Under !ENABLE_NLS, message\n\t * format strings are ASCII, but database-encoding strings may enter the\n\t * message via %s.  This makes the overall message encoding equal to the\n\t * database encoding.\n\t */\n\tif (category == LC_CTYPE)\n\t{\n\t\tstatic char save_lc_ctype[LC_ENV_BUFSIZE];\n\n\t\t/* copy setlocale() return value before callee invokes it again */\n\t\tstrlcpy(save_lc_ctype, result, sizeof(save_lc_ctype));\n\t\tresult = save_lc_ctype;\n\n#ifdef ENABLE_NLS\n\t\tSetMessageEncoding(pg_bind_textdomain_codeset(textdomain(NULL)));\n#else\n\t\tSetMessageEncoding(GetDatabaseEncoding());\n#endif\n\t}\n\n\tswitch (category)\n\t{\n\t\tcase LC_COLLATE:\n\t\t\tenvvar = \"LC_COLLATE\";\n\t\t\tenvbuf = lc_collate_envbuf;\n\t\t\tbreak;\n\t\tcase LC_CTYPE:\n\t\t\tenvvar = \"LC_CTYPE\";\n\t\t\tenvbuf = lc_ctype_envbuf;\n\t\t\tbreak;\n#ifdef LC_MESSAGES\n\t\tcase LC_MESSAGES:\n\t\t\tenvvar = \"LC_MESSAGES\";\n\t\t\tenvbuf = lc_messages_envbuf;\n#ifdef WIN32\n\t\t\tresult = IsoLocaleName(locale);\n\t\t\tif (result == NULL)\n\t\t\t\tresult = (char *) locale;\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\t\t\tbreak;\n#endif\t\t\t\t\t\t\t/* LC_MESSAGES */\n\t\tcase LC_MONETARY:\n\t\t\tenvvar = \"LC_MONETARY\";\n\t\t\tenvbuf = lc_monetary_envbuf;\n\t\t\tbreak;\n\t\tcase LC_NUMERIC:\n\t\t\tenvvar = \"LC_NUMERIC\";\n\t\t\tenvbuf = lc_numeric_envbuf;\n\t\t\tbreak;\n\t\tcase LC_TIME:\n\t\t\tenvvar = \"LC_TIME\";\n\t\t\tenvbuf = lc_time_envbuf;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(FATAL, \"unrecognized LC category: %d\", category);\n\t\t\tenvvar = NULL;\t\t/* keep compiler quiet */\n\t\t\tenvbuf = NULL;\n\t\t\treturn NULL;\n\t}\n\n\tsnprintf(envbuf, LC_ENV_BUFSIZE - 1, \"%s=%s\", envvar, result);\n\n\tif (putenv(envbuf))\n\t\treturn NULL;\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nint\npg_bind_textdomain_codeset(const char *domainname)\n{\n\tbool\t\telog_ok = (CurrentMemoryContext != NULL);\n\tint\t\t\tencoding = GetDatabaseEncoding();\n\tint\t\t\tnew_msgenc;\n\n#ifndef WIN32\n\tconst char *ctype = setlocale(LC_CTYPE, NULL);\n\n\tif (pg_strcasecmp(ctype, \"C\") == 0 || pg_strcasecmp(ctype, \"POSIX\") == 0)\n#endif\n\t\tif (encoding != PG_SQL_ASCII &&\n\t\t\traw_pg_bind_textdomain_codeset(domainname, encoding))\n\t\t\treturn encoding;\n\n\tnew_msgenc = pg_get_encoding_from_locale(NULL, elog_ok);\n\tif (new_msgenc < 0)\n\t\tnew_msgenc = PG_SQL_ASCII;\n\n#ifdef WIN32\n\tif (!raw_pg_bind_textdomain_codeset(domainname, new_msgenc))\n\t\t/* On failure, the old message encoding remains valid. */\n\t\treturn GetMessageEncoding();\n#endif\n\n\treturn new_msgenc;\n}"
  },
  {
    "function_name": "raw_pg_bind_textdomain_codeset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "923-947",
    "snippet": "static bool\nraw_pg_bind_textdomain_codeset(const char *domainname, int encoding)\n{\n\tbool\t\telog_ok = (CurrentMemoryContext != NULL);\n\tint\t\t\ti;\n\n\tfor (i = 0; pg_enc2gettext_tbl[i].name != NULL; i++)\n\t{\n\t\tif (pg_enc2gettext_tbl[i].encoding == encoding)\n\t\t{\n\t\t\tif (bind_textdomain_codeset(domainname,\n\t\t\t\t\t\t\t\t\t\tpg_enc2gettext_tbl[i].name) != NULL)\n\t\t\t\treturn true;\n\n\t\t\tif (elog_ok)\n\t\t\t\telog(LOG, \"bind_textdomain_codeset failed\");\n\t\t\telse\n\t\t\t\twrite_stderr(\"bind_textdomain_codeset failed\");\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_stderr",
          "args": [
            "\"bind_textdomain_codeset failed\""
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "write_stderr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3668-3703",
          "snippet": "void\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nvoid\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "LOG",
            "\"bind_textdomain_codeset failed\""
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bind_textdomain_codeset",
          "args": [
            "domainname",
            "pg_enc2gettext_tbl[i].name"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "raw_pg_bind_textdomain_codeset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "923-947",
          "snippet": "static bool\nraw_pg_bind_textdomain_codeset(const char *domainname, int encoding)\n{\n\tbool\t\telog_ok = (CurrentMemoryContext != NULL);\n\tint\t\t\ti;\n\n\tfor (i = 0; pg_enc2gettext_tbl[i].name != NULL; i++)\n\t{\n\t\tif (pg_enc2gettext_tbl[i].encoding == encoding)\n\t\t{\n\t\t\tif (bind_textdomain_codeset(domainname,\n\t\t\t\t\t\t\t\t\t\tpg_enc2gettext_tbl[i].name) != NULL)\n\t\t\t\treturn true;\n\n\t\t\tif (elog_ok)\n\t\t\t\telog(LOG, \"bind_textdomain_codeset failed\");\n\t\t\telse\n\t\t\t\twrite_stderr(\"bind_textdomain_codeset failed\");\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic bool\nraw_pg_bind_textdomain_codeset(const char *domainname, int encoding)\n{\n\tbool\t\telog_ok = (CurrentMemoryContext != NULL);\n\tint\t\t\ti;\n\n\tfor (i = 0; pg_enc2gettext_tbl[i].name != NULL; i++)\n\t{\n\t\tif (pg_enc2gettext_tbl[i].encoding == encoding)\n\t\t{\n\t\t\tif (bind_textdomain_codeset(domainname,\n\t\t\t\t\t\t\t\t\t\tpg_enc2gettext_tbl[i].name) != NULL)\n\t\t\t\treturn true;\n\n\t\t\tif (elog_ok)\n\t\t\t\telog(LOG, \"bind_textdomain_codeset failed\");\n\t\t\telse\n\t\t\t\twrite_stderr(\"bind_textdomain_codeset failed\");\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "SetMessageEncoding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "907-915",
    "snippet": "void\nSetMessageEncoding(int encoding)\n{\n\t/* Some calls happen before we can elog()! */\n\tAssert(PG_VALID_ENCODING(encoding));\n\n\tMessageEncoding = &pg_enc2name_tbl[encoding];\n\tAssert(MessageEncoding->encoding == encoding);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *MessageEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "MessageEncoding->encoding == encoding"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "PG_VALID_ENCODING(encoding)"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_VALID_ENCODING",
          "args": [
            "encoding"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *MessageEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nvoid\nSetMessageEncoding(int encoding)\n{\n\t/* Some calls happen before we can elog()! */\n\tAssert(PG_VALID_ENCODING(encoding));\n\n\tMessageEncoding = &pg_enc2name_tbl[encoding];\n\tAssert(MessageEncoding->encoding == encoding);\n}"
  },
  {
    "function_name": "SetDatabaseEncoding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "897-905",
    "snippet": "void\nSetDatabaseEncoding(int encoding)\n{\n\tif (!PG_VALID_BE_ENCODING(encoding))\n\t\telog(ERROR, \"invalid database encoding: %d\", encoding);\n\n\tDatabaseEncoding = &pg_enc2name_tbl[encoding];\n\tAssert(DatabaseEncoding->encoding == encoding);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "DatabaseEncoding->encoding == encoding"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid database encoding: %d\"",
            "encoding"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_VALID_BE_ENCODING",
          "args": [
            "encoding"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nvoid\nSetDatabaseEncoding(int encoding)\n{\n\tif (!PG_VALID_BE_ENCODING(encoding))\n\t\telog(ERROR, \"invalid database encoding: %d\", encoding);\n\n\tDatabaseEncoding = &pg_enc2name_tbl[encoding];\n\tAssert(DatabaseEncoding->encoding == encoding);\n}"
  },
  {
    "function_name": "cliplen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "886-895",
    "snippet": "static int\ncliplen(const char *str, int len, int limit)\n{\n\tint\t\t\tl = 0;\n\n\tlen = Min(len, limit);\n\twhile (l < len && str[l])\n\t\tl++;\n\treturn l;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tcliplen(const char *str, int len, int limit);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "len",
            "limit"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nstatic int\ncliplen(const char *str, int len, int limit)\n{\n\tint\t\t\tl = 0;\n\n\tlen = Min(len, limit);\n\twhile (l < len && str[l])\n\t\tl++;\n\treturn l;\n}"
  },
  {
    "function_name": "pg_mbcharcliplen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "861-883",
    "snippet": "int\npg_mbcharcliplen(const char *mbstr, int len, int limit)\n{\n\tint\t\t\tclen = 0;\n\tint\t\t\tnch = 0;\n\tint\t\t\tl;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn cliplen(mbstr, len, limit);\n\n\twhile (len > 0 && *mbstr)\n\t{\n\t\tl = pg_mblen(mbstr);\n\t\tnch++;\n\t\tif (nch > limit)\n\t\t\tbreak;\n\t\tclen += l;\n\t\tlen -= l;\n\t\tmbstr += l;\n\t}\n\treturn clen;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tcliplen(const char *str, int len, int limit);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "mbstr"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cliplen",
          "args": [
            "mbstr",
            "len",
            "limit"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "cliplen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "886-895",
          "snippet": "static int\ncliplen(const char *str, int len, int limit)\n{\n\tint\t\t\tl = 0;\n\n\tlen = Min(len, limit);\n\twhile (l < len && str[l])\n\t\tl++;\n\treturn l;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nstatic int\ncliplen(const char *str, int len, int limit)\n{\n\tint\t\t\tl = 0;\n\n\tlen = Min(len, limit);\n\twhile (l < len && str[l])\n\t\tl++;\n\treturn l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbcharcliplen(const char *mbstr, int len, int limit)\n{\n\tint\t\t\tclen = 0;\n\tint\t\t\tnch = 0;\n\tint\t\t\tl;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn cliplen(mbstr, len, limit);\n\n\twhile (len > 0 && *mbstr)\n\t{\n\t\tl = pg_mblen(mbstr);\n\t\tnch++;\n\t\tif (nch > limit)\n\t\t\tbreak;\n\t\tclen += l;\n\t\tlen -= l;\n\t\tmbstr += l;\n\t}\n\treturn clen;\n}"
  },
  {
    "function_name": "pg_encoding_mbcliplen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "829-855",
    "snippet": "int\npg_encoding_mbcliplen(int encoding, const char *mbstr,\n\t\t\t\t\t  int len, int limit)\n{\n\tmblen_converter mblen_fn;\n\tint\t\t\tclen = 0;\n\tint\t\t\tl;\n\n\t/* optimization for single byte encoding */\n\tif (pg_encoding_max_length(encoding) == 1)\n\t\treturn cliplen(mbstr, len, limit);\n\n\tmblen_fn = pg_wchar_table[encoding].mblen;\n\n\twhile (len > 0 && *mbstr)\n\t{\n\t\tl = (*mblen_fn) ((const unsigned char *) mbstr);\n\t\tif ((clen + l) > limit)\n\t\t\tbreak;\n\t\tclen += l;\n\t\tif (clen == limit)\n\t\t\tbreak;\n\t\tlen -= l;\n\t\tmbstr += l;\n\t}\n\treturn clen;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tcliplen(const char *str, int len, int limit);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "(const unsigned char *) mbstr"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cliplen",
          "args": [
            "mbstr",
            "len",
            "limit"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "cliplen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "886-895",
          "snippet": "static int\ncliplen(const char *str, int len, int limit)\n{\n\tint\t\t\tl = 0;\n\n\tlen = Min(len, limit);\n\twhile (l < len && str[l])\n\t\tl++;\n\treturn l;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nstatic int\ncliplen(const char *str, int len, int limit)\n{\n\tint\t\t\tl = 0;\n\n\tlen = Min(len, limit);\n\twhile (l < len && str[l])\n\t\tl++;\n\treturn l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_encoding_max_length",
          "args": [
            "encoding"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "pg_encoding_max_length_sql",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "528-537",
          "snippet": "Datum\npg_encoding_max_length_sql(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tencoding = PG_GETARG_INT32(0);\n\n\tif (PG_VALID_ENCODING(encoding))\n\t\tPG_RETURN_INT32(pg_wchar_table[encoding].maxmblen);\n\telse\n\t\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nDatum\npg_encoding_max_length_sql(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tencoding = PG_GETARG_INT32(0);\n\n\tif (PG_VALID_ENCODING(encoding))\n\t\tPG_RETURN_INT32(pg_wchar_table[encoding].maxmblen);\n\telse\n\t\tPG_RETURN_NULL();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_encoding_mbcliplen(int encoding, const char *mbstr,\n\t\t\t\t\t  int len, int limit)\n{\n\tmblen_converter mblen_fn;\n\tint\t\t\tclen = 0;\n\tint\t\t\tl;\n\n\t/* optimization for single byte encoding */\n\tif (pg_encoding_max_length(encoding) == 1)\n\t\treturn cliplen(mbstr, len, limit);\n\n\tmblen_fn = pg_wchar_table[encoding].mblen;\n\n\twhile (len > 0 && *mbstr)\n\t{\n\t\tl = (*mblen_fn) ((const unsigned char *) mbstr);\n\t\tif ((clen + l) > limit)\n\t\t\tbreak;\n\t\tclen += l;\n\t\tif (clen == limit)\n\t\t\tbreak;\n\t\tlen -= l;\n\t\tmbstr += l;\n\t}\n\treturn clen;\n}"
  },
  {
    "function_name": "pg_mbcliplen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "819-824",
    "snippet": "int\npg_mbcliplen(const char *mbstr, int len, int limit)\n{\n\treturn pg_encoding_mbcliplen(DatabaseEncoding->encoding, mbstr,\n\t\t\t\t\t\t\t\t len, limit);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
      "static int\tcliplen(const char *str, int len, int limit);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_encoding_mbcliplen",
          "args": [
            "DatabaseEncoding->encoding",
            "mbstr",
            "len",
            "limit"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "pg_encoding_mbcliplen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "829-855",
          "snippet": "int\npg_encoding_mbcliplen(int encoding, const char *mbstr,\n\t\t\t\t\t  int len, int limit)\n{\n\tmblen_converter mblen_fn;\n\tint\t\t\tclen = 0;\n\tint\t\t\tl;\n\n\t/* optimization for single byte encoding */\n\tif (pg_encoding_max_length(encoding) == 1)\n\t\treturn cliplen(mbstr, len, limit);\n\n\tmblen_fn = pg_wchar_table[encoding].mblen;\n\n\twhile (len > 0 && *mbstr)\n\t{\n\t\tl = (*mblen_fn) ((const unsigned char *) mbstr);\n\t\tif ((clen + l) > limit)\n\t\t\tbreak;\n\t\tclen += l;\n\t\tif (clen == limit)\n\t\t\tbreak;\n\t\tlen -= l;\n\t\tmbstr += l;\n\t}\n\treturn clen;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_encoding_mbcliplen(int encoding, const char *mbstr,\n\t\t\t\t\t  int len, int limit)\n{\n\tmblen_converter mblen_fn;\n\tint\t\t\tclen = 0;\n\tint\t\t\tl;\n\n\t/* optimization for single byte encoding */\n\tif (pg_encoding_max_length(encoding) == 1)\n\t\treturn cliplen(mbstr, len, limit);\n\n\tmblen_fn = pg_wchar_table[encoding].mblen;\n\n\twhile (len > 0 && *mbstr)\n\t{\n\t\tl = (*mblen_fn) ((const unsigned char *) mbstr);\n\t\tif ((clen + l) > limit)\n\t\t\tbreak;\n\t\tclen += l;\n\t\tif (clen == limit)\n\t\t\tbreak;\n\t\tlen -= l;\n\t\tmbstr += l;\n\t}\n\treturn clen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbcliplen(const char *mbstr, int len, int limit)\n{\n\treturn pg_encoding_mbcliplen(DatabaseEncoding->encoding, mbstr,\n\t\t\t\t\t\t\t\t len, limit);\n}"
  },
  {
    "function_name": "pg_mbstrlen_with_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "793-811",
    "snippet": "int\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tcliplen(const char *str, int len, int limit);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "mbstr"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}"
  },
  {
    "function_name": "pg_mbstrlen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "773-788",
    "snippet": "int\npg_mbstrlen(const char *mbstr)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn strlen(mbstr);\n\n\twhile (*mbstr)\n\t{\n\t\tmbstr += pg_mblen(mbstr);\n\t\tlen++;\n\t}\n\treturn len;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "mbstr"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mbstr"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "773-788",
          "snippet": "int\npg_mbstrlen(const char *mbstr)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn strlen(mbstr);\n\n\twhile (*mbstr)\n\t{\n\t\tmbstr += pg_mblen(mbstr);\n\t\tlen++;\n\t}\n\treturn len;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nint\npg_mbstrlen(const char *mbstr)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn strlen(mbstr);\n\n\twhile (*mbstr)\n\t{\n\t\tmbstr += pg_mblen(mbstr);\n\t\tlen++;\n\t}\n\treturn len;\n}"
  },
  {
    "function_name": "pg_dsplen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "766-770",
    "snippet": "int\npg_dsplen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].dsplen((const unsigned char *) mbstr);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_wchar_table[DatabaseEncoding->encoding].dsplen",
          "args": [
            "(const unsigned char *) mbstr"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_dsplen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].dsplen((const unsigned char *) mbstr);\n}"
  },
  {
    "function_name": "pg_mblen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "759-763",
    "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_wchar_table[DatabaseEncoding->encoding].mblen",
          "args": [
            "(const unsigned char *) mbstr"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
  },
  {
    "function_name": "pg_encoding_wchar2mb_with_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "751-756",
    "snippet": "int\npg_encoding_wchar2mb_with_len(int encoding,\n\t\t\t\t\t\t\t  const pg_wchar *from, char *to, int len)\n{\n\treturn pg_wchar_table[encoding].wchar2mb_with_len(from, (unsigned char *) to, len);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_wchar_table[encoding].wchar2mb_with_len",
          "args": [
            "from",
            "(unsigned char *) to",
            "len"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nint\npg_encoding_wchar2mb_with_len(int encoding,\n\t\t\t\t\t\t\t  const pg_wchar *from, char *to, int len)\n{\n\treturn pg_wchar_table[encoding].wchar2mb_with_len(from, (unsigned char *) to, len);\n}"
  },
  {
    "function_name": "pg_wchar2mb_with_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "744-748",
    "snippet": "int\npg_wchar2mb_with_len(const pg_wchar *from, char *to, int len)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].wchar2mb_with_len(from, (unsigned char *) to, len);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_wchar_table[DatabaseEncoding->encoding].wchar2mb_with_len",
          "args": [
            "from",
            "(unsigned char *) to",
            "len"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_wchar2mb_with_len(const pg_wchar *from, char *to, int len)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].wchar2mb_with_len(from, (unsigned char *) to, len);\n}"
  },
  {
    "function_name": "pg_wchar2mb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "737-741",
    "snippet": "int\npg_wchar2mb(const pg_wchar *from, char *to)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].wchar2mb_with_len(from, (unsigned char *) to, pg_wchar_strlen(from));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_wchar_table[DatabaseEncoding->encoding].wchar2mb_with_len",
          "args": [
            "from",
            "(unsigned char *) to",
            "pg_wchar_strlen(from)"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_wchar_strlen",
          "args": [
            "from"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "pg_wchar_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wstrncmp.c",
          "lines": "69-77",
          "snippet": "size_t\npg_wchar_strlen(const pg_wchar *str)\n{\n\tconst pg_wchar *s;\n\n\tfor (s = str; *s; ++s)\n\t\t;\n\treturn (s - str);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nsize_t\npg_wchar_strlen(const pg_wchar *str)\n{\n\tconst pg_wchar *s;\n\n\tfor (s = str; *s; ++s)\n\t\t;\n\treturn (s - str);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_wchar2mb(const pg_wchar *from, char *to)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].wchar2mb_with_len(from, (unsigned char *) to, pg_wchar_strlen(from));\n}"
  },
  {
    "function_name": "pg_encoding_mb2wchar_with_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "729-734",
    "snippet": "int\npg_encoding_mb2wchar_with_len(int encoding,\n\t\t\t\t\t\t\t  const char *from, pg_wchar *to, int len)\n{\n\treturn pg_wchar_table[encoding].mb2wchar_with_len((const unsigned char *) from, to, len);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_wchar_table[encoding].mb2wchar_with_len",
          "args": [
            "(const unsigned char *) from",
            "to",
            "len"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nint\npg_encoding_mb2wchar_with_len(int encoding,\n\t\t\t\t\t\t\t  const char *from, pg_wchar *to, int len)\n{\n\treturn pg_wchar_table[encoding].mb2wchar_with_len((const unsigned char *) from, to, len);\n}"
  },
  {
    "function_name": "pg_mb2wchar_with_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "722-726",
    "snippet": "int\npg_mb2wchar_with_len(const char *from, pg_wchar *to, int len)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mb2wchar_with_len((const unsigned char *) from, to, len);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_wchar_table[DatabaseEncoding->encoding].mb2wchar_with_len",
          "args": [
            "(const unsigned char *) from",
            "to",
            "len"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mb2wchar_with_len(const char *from, pg_wchar *to, int len)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mb2wchar_with_len((const unsigned char *) from, to, len);\n}"
  },
  {
    "function_name": "pg_mb2wchar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "715-719",
    "snippet": "int\npg_mb2wchar(const char *from, pg_wchar *to)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mb2wchar_with_len((const unsigned char *) from, to, strlen(from));\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_wchar_table[DatabaseEncoding->encoding].mb2wchar_with_len",
          "args": [
            "(const unsigned char *) from",
            "to",
            "strlen(from)"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "from"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "773-788",
          "snippet": "int\npg_mbstrlen(const char *mbstr)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn strlen(mbstr);\n\n\twhile (*mbstr)\n\t{\n\t\tmbstr += pg_mblen(mbstr);\n\t\tlen++;\n\t}\n\treturn len;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nint\npg_mbstrlen(const char *mbstr)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn strlen(mbstr);\n\n\twhile (*mbstr)\n\t{\n\t\tmbstr += pg_mblen(mbstr);\n\t\tlen++;\n\t}\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mb2wchar(const char *from, pg_wchar *to)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mb2wchar_with_len((const unsigned char *) from, to, strlen(from));\n}"
  },
  {
    "function_name": "perform_default_encoding_conversion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "667-711",
    "snippet": "static char *\nperform_default_encoding_conversion(const char *src, int len,\n\t\t\t\t\t\t\t\t\tbool is_client_to_server)\n{\n\tchar\t   *result;\n\tint\t\t\tsrc_encoding,\n\t\t\t\tdest_encoding;\n\tFmgrInfo   *flinfo;\n\n\tif (is_client_to_server)\n\t{\n\t\tsrc_encoding = ClientEncoding->encoding;\n\t\tdest_encoding = DatabaseEncoding->encoding;\n\t\tflinfo = ToServerConvProc;\n\t}\n\telse\n\t{\n\t\tsrc_encoding = DatabaseEncoding->encoding;\n\t\tdest_encoding = ClientEncoding->encoding;\n\t\tflinfo = ToClientConvProc;\n\t}\n\n\tif (flinfo == NULL)\n\t\treturn (char *) src;\n\n\t/*\n\t * Allocate space for conversion result, being wary of integer overflow\n\t */\n\tif ((Size) len >= (MaxAllocSize / (Size) MAX_CONVERSION_GROWTH))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"String of %d bytes is too long for encoding conversion.\",\n\t\t\t\t\t\t   len)));\n\n\tresult = palloc(len * MAX_CONVERSION_GROWTH + 1);\n\n\tFunctionCall5(flinfo,\n\t\t\t\t  Int32GetDatum(src_encoding),\n\t\t\t\t  Int32GetDatum(dest_encoding),\n\t\t\t\t  CStringGetDatum(src),\n\t\t\t\t  CStringGetDatum(result),\n\t\t\t\t  Int32GetDatum(len));\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static FmgrInfo *ToServerConvProc = NULL;",
      "static FmgrInfo *ToClientConvProc = NULL;",
      "static const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
      "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
      "static char *perform_default_encoding_conversion(const char *src,\n\t\t\t\t\t\t\t\t\tint len, bool is_client_to_server);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FunctionCall5",
          "args": [
            "flinfo",
            "Int32GetDatum(src_encoding)",
            "Int32GetDatum(dest_encoding)",
            "CStringGetDatum(src)",
            "CStringGetDatum(result)",
            "Int32GetDatum(len)"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "len"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "result"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "src"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "dest_encoding"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "src_encoding"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len * MAX_CONVERSION_GROWTH + 1"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"String of %d bytes is too long for encoding conversion.\",\n\t\t\t\t\t\t   len))"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"String of %d bytes is too long for encoding conversion.\"",
            "len"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"out of memory\""
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic FmgrInfo *ToServerConvProc = NULL;\nstatic FmgrInfo *ToClientConvProc = NULL;\nstatic const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic char *perform_default_encoding_conversion(const char *src,\n\t\t\t\t\t\t\t\t\tint len, bool is_client_to_server);\n\nstatic char *\nperform_default_encoding_conversion(const char *src, int len,\n\t\t\t\t\t\t\t\t\tbool is_client_to_server)\n{\n\tchar\t   *result;\n\tint\t\t\tsrc_encoding,\n\t\t\t\tdest_encoding;\n\tFmgrInfo   *flinfo;\n\n\tif (is_client_to_server)\n\t{\n\t\tsrc_encoding = ClientEncoding->encoding;\n\t\tdest_encoding = DatabaseEncoding->encoding;\n\t\tflinfo = ToServerConvProc;\n\t}\n\telse\n\t{\n\t\tsrc_encoding = DatabaseEncoding->encoding;\n\t\tdest_encoding = ClientEncoding->encoding;\n\t\tflinfo = ToClientConvProc;\n\t}\n\n\tif (flinfo == NULL)\n\t\treturn (char *) src;\n\n\t/*\n\t * Allocate space for conversion result, being wary of integer overflow\n\t */\n\tif ((Size) len >= (MaxAllocSize / (Size) MAX_CONVERSION_GROWTH))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"String of %d bytes is too long for encoding conversion.\",\n\t\t\t\t\t\t   len)));\n\n\tresult = palloc(len * MAX_CONVERSION_GROWTH + 1);\n\n\tFunctionCall5(flinfo,\n\t\t\t\t  Int32GetDatum(src_encoding),\n\t\t\t\t  Int32GetDatum(dest_encoding),\n\t\t\t\t  CStringGetDatum(src),\n\t\t\t\t  CStringGetDatum(result),\n\t\t\t\t  Int32GetDatum(len));\n\treturn result;\n}"
  },
  {
    "function_name": "pg_server_to_any",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "633-659",
    "snippet": "char *\npg_server_to_any(const char *s, int len, int encoding)\n{\n\tif (len <= 0)\n\t\treturn (char *) s;\t\t/* empty string is always valid */\n\n\tif (encoding == DatabaseEncoding->encoding ||\n\t\tencoding == PG_SQL_ASCII)\n\t\treturn (char *) s;\t\t/* assume data is valid */\n\n\tif (DatabaseEncoding->encoding == PG_SQL_ASCII)\n\t{\n\t\t/* No conversion is possible, but we must validate the result */\n\t\t(void) pg_verify_mbstr(encoding, s, len, false);\n\t\treturn (char *) s;\n\t}\n\n\t/* Fast path if we can use cached conversion function */\n\tif (encoding == ClientEncoding->encoding)\n\t\treturn perform_default_encoding_conversion(s, len, false);\n\n\t/* General case ... will not work outside transactions */\n\treturn (char *) pg_do_encoding_conversion((unsigned char *) s,\n\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t  DatabaseEncoding->encoding,\n\t\t\t\t\t\t\t\t\t\t\t  encoding);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
      "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_do_encoding_conversion",
          "args": [
            "(unsigned char *) s",
            "len",
            "DatabaseEncoding->encoding",
            "encoding"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "pg_do_encoding_conversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "325-378",
          "snippet": "unsigned char *\npg_do_encoding_conversion(unsigned char *src, int len,\n\t\t\t\t\t\t  int src_encoding, int dest_encoding)\n{\n\tunsigned char *result;\n\tOid\t\t\tproc;\n\n\tif (len <= 0)\n\t\treturn src;\t\t\t\t/* empty string is always valid */\n\n\tif (src_encoding == dest_encoding)\n\t\treturn src;\t\t\t\t/* no conversion required, assume valid */\n\n\tif (dest_encoding == PG_SQL_ASCII)\n\t\treturn src;\t\t\t\t/* any string is valid in SQL_ASCII */\n\n\tif (src_encoding == PG_SQL_ASCII)\n\t{\n\t\t/* No conversion is possible, but we must validate the result */\n\t\t(void) pg_verify_mbstr(dest_encoding, (const char *) src, len, false);\n\t\treturn src;\n\t}\n\n\tif (!IsTransactionState())\t/* shouldn't happen */\n\t\telog(ERROR, \"cannot perform encoding conversion outside a transaction\");\n\n\tproc = FindDefaultConversionProc(src_encoding, dest_encoding);\n\tif (!OidIsValid(proc))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"default conversion function for encoding \\\"%s\\\" to \\\"%s\\\" does not exist\",\n\t\t\t\t\t\tpg_encoding_to_char(src_encoding),\n\t\t\t\t\t\tpg_encoding_to_char(dest_encoding))));\n\n\t/*\n\t * Allocate space for conversion result, being wary of integer overflow\n\t */\n\tif ((Size) len >= (MaxAllocSize / (Size) MAX_CONVERSION_GROWTH))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"String of %d bytes is too long for encoding conversion.\",\n\t\t\t\t\t\t   len)));\n\n\tresult = palloc(len * MAX_CONVERSION_GROWTH + 1);\n\n\tOidFunctionCall5(proc,\n\t\t\t\t\t Int32GetDatum(src_encoding),\n\t\t\t\t\t Int32GetDatum(dest_encoding),\n\t\t\t\t\t CStringGetDatum(src),\n\t\t\t\t\t CStringGetDatum(result),\n\t\t\t\t\t Int32GetDatum(len));\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nunsigned char *\npg_do_encoding_conversion(unsigned char *src, int len,\n\t\t\t\t\t\t  int src_encoding, int dest_encoding)\n{\n\tunsigned char *result;\n\tOid\t\t\tproc;\n\n\tif (len <= 0)\n\t\treturn src;\t\t\t\t/* empty string is always valid */\n\n\tif (src_encoding == dest_encoding)\n\t\treturn src;\t\t\t\t/* no conversion required, assume valid */\n\n\tif (dest_encoding == PG_SQL_ASCII)\n\t\treturn src;\t\t\t\t/* any string is valid in SQL_ASCII */\n\n\tif (src_encoding == PG_SQL_ASCII)\n\t{\n\t\t/* No conversion is possible, but we must validate the result */\n\t\t(void) pg_verify_mbstr(dest_encoding, (const char *) src, len, false);\n\t\treturn src;\n\t}\n\n\tif (!IsTransactionState())\t/* shouldn't happen */\n\t\telog(ERROR, \"cannot perform encoding conversion outside a transaction\");\n\n\tproc = FindDefaultConversionProc(src_encoding, dest_encoding);\n\tif (!OidIsValid(proc))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"default conversion function for encoding \\\"%s\\\" to \\\"%s\\\" does not exist\",\n\t\t\t\t\t\tpg_encoding_to_char(src_encoding),\n\t\t\t\t\t\tpg_encoding_to_char(dest_encoding))));\n\n\t/*\n\t * Allocate space for conversion result, being wary of integer overflow\n\t */\n\tif ((Size) len >= (MaxAllocSize / (Size) MAX_CONVERSION_GROWTH))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"String of %d bytes is too long for encoding conversion.\",\n\t\t\t\t\t\t   len)));\n\n\tresult = palloc(len * MAX_CONVERSION_GROWTH + 1);\n\n\tOidFunctionCall5(proc,\n\t\t\t\t\t Int32GetDatum(src_encoding),\n\t\t\t\t\t Int32GetDatum(dest_encoding),\n\t\t\t\t\t CStringGetDatum(src),\n\t\t\t\t\t CStringGetDatum(result),\n\t\t\t\t\t Int32GetDatum(len));\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perform_default_encoding_conversion",
          "args": [
            "s",
            "len",
            "false"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "perform_default_encoding_conversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "667-711",
          "snippet": "static char *\nperform_default_encoding_conversion(const char *src, int len,\n\t\t\t\t\t\t\t\t\tbool is_client_to_server)\n{\n\tchar\t   *result;\n\tint\t\t\tsrc_encoding,\n\t\t\t\tdest_encoding;\n\tFmgrInfo   *flinfo;\n\n\tif (is_client_to_server)\n\t{\n\t\tsrc_encoding = ClientEncoding->encoding;\n\t\tdest_encoding = DatabaseEncoding->encoding;\n\t\tflinfo = ToServerConvProc;\n\t}\n\telse\n\t{\n\t\tsrc_encoding = DatabaseEncoding->encoding;\n\t\tdest_encoding = ClientEncoding->encoding;\n\t\tflinfo = ToClientConvProc;\n\t}\n\n\tif (flinfo == NULL)\n\t\treturn (char *) src;\n\n\t/*\n\t * Allocate space for conversion result, being wary of integer overflow\n\t */\n\tif ((Size) len >= (MaxAllocSize / (Size) MAX_CONVERSION_GROWTH))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"String of %d bytes is too long for encoding conversion.\",\n\t\t\t\t\t\t   len)));\n\n\tresult = palloc(len * MAX_CONVERSION_GROWTH + 1);\n\n\tFunctionCall5(flinfo,\n\t\t\t\t  Int32GetDatum(src_encoding),\n\t\t\t\t  Int32GetDatum(dest_encoding),\n\t\t\t\t  CStringGetDatum(src),\n\t\t\t\t  CStringGetDatum(result),\n\t\t\t\t  Int32GetDatum(len));\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static FmgrInfo *ToServerConvProc = NULL;",
            "static FmgrInfo *ToClientConvProc = NULL;",
            "static const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
            "static char *perform_default_encoding_conversion(const char *src,\n\t\t\t\t\t\t\t\t\tint len, bool is_client_to_server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic FmgrInfo *ToServerConvProc = NULL;\nstatic FmgrInfo *ToClientConvProc = NULL;\nstatic const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic char *perform_default_encoding_conversion(const char *src,\n\t\t\t\t\t\t\t\t\tint len, bool is_client_to_server);\n\nstatic char *\nperform_default_encoding_conversion(const char *src, int len,\n\t\t\t\t\t\t\t\t\tbool is_client_to_server)\n{\n\tchar\t   *result;\n\tint\t\t\tsrc_encoding,\n\t\t\t\tdest_encoding;\n\tFmgrInfo   *flinfo;\n\n\tif (is_client_to_server)\n\t{\n\t\tsrc_encoding = ClientEncoding->encoding;\n\t\tdest_encoding = DatabaseEncoding->encoding;\n\t\tflinfo = ToServerConvProc;\n\t}\n\telse\n\t{\n\t\tsrc_encoding = DatabaseEncoding->encoding;\n\t\tdest_encoding = ClientEncoding->encoding;\n\t\tflinfo = ToClientConvProc;\n\t}\n\n\tif (flinfo == NULL)\n\t\treturn (char *) src;\n\n\t/*\n\t * Allocate space for conversion result, being wary of integer overflow\n\t */\n\tif ((Size) len >= (MaxAllocSize / (Size) MAX_CONVERSION_GROWTH))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"String of %d bytes is too long for encoding conversion.\",\n\t\t\t\t\t\t   len)));\n\n\tresult = palloc(len * MAX_CONVERSION_GROWTH + 1);\n\n\tFunctionCall5(flinfo,\n\t\t\t\t  Int32GetDatum(src_encoding),\n\t\t\t\t  Int32GetDatum(dest_encoding),\n\t\t\t\t  CStringGetDatum(src),\n\t\t\t\t  CStringGetDatum(result),\n\t\t\t\t  Int32GetDatum(len));\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_verify_mbstr",
          "args": [
            "encoding",
            "s",
            "len",
            "false"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "pg_verify_mbstr_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1893-1953",
          "snippet": "int\npg_verify_mbstr_len(int encoding, const char *mbstr, int len, bool noError)\n{\n\tmbverifier\tmbverify;\n\tint\t\t\tmb_len;\n\n\tAssert(PG_VALID_ENCODING(encoding));\n\n\t/*\n\t * In single-byte encodings, we need only reject nulls (\\0).\n\t */\n\tif (pg_encoding_max_length(encoding) <= 1)\n\t{\n\t\tconst char *nullpos = memchr(mbstr, 0, len);\n\n\t\tif (nullpos == NULL)\n\t\t\treturn len;\n\t\tif (noError)\n\t\t\treturn -1;\n\t\treport_invalid_encoding(encoding, nullpos, 1);\n\t}\n\n\t/* fetch function pointer just once */\n\tmbverify = pg_wchar_table[encoding].mbverify;\n\n\tmb_len = 0;\n\n\twhile (len > 0)\n\t{\n\t\tint\t\t\tl;\n\n\t\t/* fast path for ASCII-subset characters */\n\t\tif (!IS_HIGHBIT_SET(*mbstr))\n\t\t{\n\t\t\tif (*mbstr != '\\0')\n\t\t\t{\n\t\t\t\tmb_len++;\n\t\t\t\tmbstr++;\n\t\t\t\tlen--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (noError)\n\t\t\t\treturn -1;\n\t\t\treport_invalid_encoding(encoding, mbstr, len);\n\t\t}\n\n\t\tl = (*mbverify) ((const unsigned char *) mbstr, len);\n\n\t\tif (l < 0)\n\t\t{\n\t\t\tif (noError)\n\t\t\t\treturn -1;\n\t\t\treport_invalid_encoding(encoding, mbstr, len);\n\t\t}\n\n\t\tmbstr += l;\n\t\tlen -= l;\n\t\tmb_len++;\n\t}\n\treturn mb_len;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_verify_mbstr_len(int encoding, const char *mbstr, int len, bool noError)\n{\n\tmbverifier\tmbverify;\n\tint\t\t\tmb_len;\n\n\tAssert(PG_VALID_ENCODING(encoding));\n\n\t/*\n\t * In single-byte encodings, we need only reject nulls (\\0).\n\t */\n\tif (pg_encoding_max_length(encoding) <= 1)\n\t{\n\t\tconst char *nullpos = memchr(mbstr, 0, len);\n\n\t\tif (nullpos == NULL)\n\t\t\treturn len;\n\t\tif (noError)\n\t\t\treturn -1;\n\t\treport_invalid_encoding(encoding, nullpos, 1);\n\t}\n\n\t/* fetch function pointer just once */\n\tmbverify = pg_wchar_table[encoding].mbverify;\n\n\tmb_len = 0;\n\n\twhile (len > 0)\n\t{\n\t\tint\t\t\tl;\n\n\t\t/* fast path for ASCII-subset characters */\n\t\tif (!IS_HIGHBIT_SET(*mbstr))\n\t\t{\n\t\t\tif (*mbstr != '\\0')\n\t\t\t{\n\t\t\t\tmb_len++;\n\t\t\t\tmbstr++;\n\t\t\t\tlen--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (noError)\n\t\t\t\treturn -1;\n\t\t\treport_invalid_encoding(encoding, mbstr, len);\n\t\t}\n\n\t\tl = (*mbverify) ((const unsigned char *) mbstr, len);\n\n\t\tif (l < 0)\n\t\t{\n\t\t\tif (noError)\n\t\t\t\treturn -1;\n\t\t\treport_invalid_encoding(encoding, mbstr, len);\n\t\t}\n\n\t\tmbstr += l;\n\t\tlen -= l;\n\t\tmb_len++;\n\t}\n\treturn mb_len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nchar *\npg_server_to_any(const char *s, int len, int encoding)\n{\n\tif (len <= 0)\n\t\treturn (char *) s;\t\t/* empty string is always valid */\n\n\tif (encoding == DatabaseEncoding->encoding ||\n\t\tencoding == PG_SQL_ASCII)\n\t\treturn (char *) s;\t\t/* assume data is valid */\n\n\tif (DatabaseEncoding->encoding == PG_SQL_ASCII)\n\t{\n\t\t/* No conversion is possible, but we must validate the result */\n\t\t(void) pg_verify_mbstr(encoding, s, len, false);\n\t\treturn (char *) s;\n\t}\n\n\t/* Fast path if we can use cached conversion function */\n\tif (encoding == ClientEncoding->encoding)\n\t\treturn perform_default_encoding_conversion(s, len, false);\n\n\t/* General case ... will not work outside transactions */\n\treturn (char *) pg_do_encoding_conversion((unsigned char *) s,\n\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t  DatabaseEncoding->encoding,\n\t\t\t\t\t\t\t\t\t\t\t  encoding);\n}"
  },
  {
    "function_name": "pg_server_to_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "622-626",
    "snippet": "char *\npg_server_to_client(const char *s, int len)\n{\n\treturn pg_server_to_any(s, len, ClientEncoding->encoding);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_server_to_any",
          "args": [
            "s",
            "len",
            "ClientEncoding->encoding"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "pg_server_to_any",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "633-659",
          "snippet": "char *\npg_server_to_any(const char *s, int len, int encoding)\n{\n\tif (len <= 0)\n\t\treturn (char *) s;\t\t/* empty string is always valid */\n\n\tif (encoding == DatabaseEncoding->encoding ||\n\t\tencoding == PG_SQL_ASCII)\n\t\treturn (char *) s;\t\t/* assume data is valid */\n\n\tif (DatabaseEncoding->encoding == PG_SQL_ASCII)\n\t{\n\t\t/* No conversion is possible, but we must validate the result */\n\t\t(void) pg_verify_mbstr(encoding, s, len, false);\n\t\treturn (char *) s;\n\t}\n\n\t/* Fast path if we can use cached conversion function */\n\tif (encoding == ClientEncoding->encoding)\n\t\treturn perform_default_encoding_conversion(s, len, false);\n\n\t/* General case ... will not work outside transactions */\n\treturn (char *) pg_do_encoding_conversion((unsigned char *) s,\n\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t  DatabaseEncoding->encoding,\n\t\t\t\t\t\t\t\t\t\t\t  encoding);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nchar *\npg_server_to_any(const char *s, int len, int encoding)\n{\n\tif (len <= 0)\n\t\treturn (char *) s;\t\t/* empty string is always valid */\n\n\tif (encoding == DatabaseEncoding->encoding ||\n\t\tencoding == PG_SQL_ASCII)\n\t\treturn (char *) s;\t\t/* assume data is valid */\n\n\tif (DatabaseEncoding->encoding == PG_SQL_ASCII)\n\t{\n\t\t/* No conversion is possible, but we must validate the result */\n\t\t(void) pg_verify_mbstr(encoding, s, len, false);\n\t\treturn (char *) s;\n\t}\n\n\t/* Fast path if we can use cached conversion function */\n\tif (encoding == ClientEncoding->encoding)\n\t\treturn perform_default_encoding_conversion(s, len, false);\n\n\t/* General case ... will not work outside transactions */\n\treturn (char *) pg_do_encoding_conversion((unsigned char *) s,\n\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t  DatabaseEncoding->encoding,\n\t\t\t\t\t\t\t\t\t\t\t  encoding);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nchar *\npg_server_to_client(const char *s, int len)\n{\n\treturn pg_server_to_any(s, len, ClientEncoding->encoding);\n}"
  },
  {
    "function_name": "pg_any_to_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "560-615",
    "snippet": "char *\npg_any_to_server(const char *s, int len, int encoding)\n{\n\tif (len <= 0)\n\t\treturn (char *) s;\t\t/* empty string is always valid */\n\n\tif (encoding == DatabaseEncoding->encoding ||\n\t\tencoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is needed, but we must still validate the data.\n\t\t */\n\t\t(void) pg_verify_mbstr(DatabaseEncoding->encoding, s, len, false);\n\t\treturn (char *) s;\n\t}\n\n\tif (DatabaseEncoding->encoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is possible, but we must still validate the data,\n\t\t * because the client-side code might have done string escaping using\n\t\t * the selected client_encoding.  If the client encoding is ASCII-safe\n\t\t * then we just do a straight validation under that encoding.  For an\n\t\t * ASCII-unsafe encoding we have a problem: we dare not pass such data\n\t\t * to the parser but we have no way to convert it.  We compromise by\n\t\t * rejecting the data if it contains any non-ASCII characters.\n\t\t */\n\t\tif (PG_VALID_BE_ENCODING(encoding))\n\t\t\t(void) pg_verify_mbstr(encoding, s, len, false);\n\t\telse\n\t\t{\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\tif (s[i] == '\\0' || IS_HIGHBIT_SET(s[i]))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t\t\t\t errmsg(\"invalid byte value for encoding \\\"%s\\\": 0x%02x\",\n\t\t\t\t\t\t\t\t\tpg_enc2name_tbl[PG_SQL_ASCII].name,\n\t\t\t\t\t\t\t\t\t(unsigned char) s[i])));\n\t\t\t}\n\t\t}\n\t\treturn (char *) s;\n\t}\n\n\t/* Fast path if we can use cached conversion function */\n\tif (encoding == ClientEncoding->encoding)\n\t\treturn perform_default_encoding_conversion(s, len, true);\n\n\t/* General case ... will not work outside transactions */\n\treturn (char *) pg_do_encoding_conversion((unsigned char *) s,\n\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t  encoding,\n\t\t\t\t\t\t\t\t\t\t\t  DatabaseEncoding->encoding);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
      "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_do_encoding_conversion",
          "args": [
            "(unsigned char *) s",
            "len",
            "encoding",
            "DatabaseEncoding->encoding"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "pg_do_encoding_conversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "325-378",
          "snippet": "unsigned char *\npg_do_encoding_conversion(unsigned char *src, int len,\n\t\t\t\t\t\t  int src_encoding, int dest_encoding)\n{\n\tunsigned char *result;\n\tOid\t\t\tproc;\n\n\tif (len <= 0)\n\t\treturn src;\t\t\t\t/* empty string is always valid */\n\n\tif (src_encoding == dest_encoding)\n\t\treturn src;\t\t\t\t/* no conversion required, assume valid */\n\n\tif (dest_encoding == PG_SQL_ASCII)\n\t\treturn src;\t\t\t\t/* any string is valid in SQL_ASCII */\n\n\tif (src_encoding == PG_SQL_ASCII)\n\t{\n\t\t/* No conversion is possible, but we must validate the result */\n\t\t(void) pg_verify_mbstr(dest_encoding, (const char *) src, len, false);\n\t\treturn src;\n\t}\n\n\tif (!IsTransactionState())\t/* shouldn't happen */\n\t\telog(ERROR, \"cannot perform encoding conversion outside a transaction\");\n\n\tproc = FindDefaultConversionProc(src_encoding, dest_encoding);\n\tif (!OidIsValid(proc))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"default conversion function for encoding \\\"%s\\\" to \\\"%s\\\" does not exist\",\n\t\t\t\t\t\tpg_encoding_to_char(src_encoding),\n\t\t\t\t\t\tpg_encoding_to_char(dest_encoding))));\n\n\t/*\n\t * Allocate space for conversion result, being wary of integer overflow\n\t */\n\tif ((Size) len >= (MaxAllocSize / (Size) MAX_CONVERSION_GROWTH))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"String of %d bytes is too long for encoding conversion.\",\n\t\t\t\t\t\t   len)));\n\n\tresult = palloc(len * MAX_CONVERSION_GROWTH + 1);\n\n\tOidFunctionCall5(proc,\n\t\t\t\t\t Int32GetDatum(src_encoding),\n\t\t\t\t\t Int32GetDatum(dest_encoding),\n\t\t\t\t\t CStringGetDatum(src),\n\t\t\t\t\t CStringGetDatum(result),\n\t\t\t\t\t Int32GetDatum(len));\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nunsigned char *\npg_do_encoding_conversion(unsigned char *src, int len,\n\t\t\t\t\t\t  int src_encoding, int dest_encoding)\n{\n\tunsigned char *result;\n\tOid\t\t\tproc;\n\n\tif (len <= 0)\n\t\treturn src;\t\t\t\t/* empty string is always valid */\n\n\tif (src_encoding == dest_encoding)\n\t\treturn src;\t\t\t\t/* no conversion required, assume valid */\n\n\tif (dest_encoding == PG_SQL_ASCII)\n\t\treturn src;\t\t\t\t/* any string is valid in SQL_ASCII */\n\n\tif (src_encoding == PG_SQL_ASCII)\n\t{\n\t\t/* No conversion is possible, but we must validate the result */\n\t\t(void) pg_verify_mbstr(dest_encoding, (const char *) src, len, false);\n\t\treturn src;\n\t}\n\n\tif (!IsTransactionState())\t/* shouldn't happen */\n\t\telog(ERROR, \"cannot perform encoding conversion outside a transaction\");\n\n\tproc = FindDefaultConversionProc(src_encoding, dest_encoding);\n\tif (!OidIsValid(proc))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"default conversion function for encoding \\\"%s\\\" to \\\"%s\\\" does not exist\",\n\t\t\t\t\t\tpg_encoding_to_char(src_encoding),\n\t\t\t\t\t\tpg_encoding_to_char(dest_encoding))));\n\n\t/*\n\t * Allocate space for conversion result, being wary of integer overflow\n\t */\n\tif ((Size) len >= (MaxAllocSize / (Size) MAX_CONVERSION_GROWTH))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"String of %d bytes is too long for encoding conversion.\",\n\t\t\t\t\t\t   len)));\n\n\tresult = palloc(len * MAX_CONVERSION_GROWTH + 1);\n\n\tOidFunctionCall5(proc,\n\t\t\t\t\t Int32GetDatum(src_encoding),\n\t\t\t\t\t Int32GetDatum(dest_encoding),\n\t\t\t\t\t CStringGetDatum(src),\n\t\t\t\t\t CStringGetDatum(result),\n\t\t\t\t\t Int32GetDatum(len));\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perform_default_encoding_conversion",
          "args": [
            "s",
            "len",
            "true"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "perform_default_encoding_conversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "667-711",
          "snippet": "static char *\nperform_default_encoding_conversion(const char *src, int len,\n\t\t\t\t\t\t\t\t\tbool is_client_to_server)\n{\n\tchar\t   *result;\n\tint\t\t\tsrc_encoding,\n\t\t\t\tdest_encoding;\n\tFmgrInfo   *flinfo;\n\n\tif (is_client_to_server)\n\t{\n\t\tsrc_encoding = ClientEncoding->encoding;\n\t\tdest_encoding = DatabaseEncoding->encoding;\n\t\tflinfo = ToServerConvProc;\n\t}\n\telse\n\t{\n\t\tsrc_encoding = DatabaseEncoding->encoding;\n\t\tdest_encoding = ClientEncoding->encoding;\n\t\tflinfo = ToClientConvProc;\n\t}\n\n\tif (flinfo == NULL)\n\t\treturn (char *) src;\n\n\t/*\n\t * Allocate space for conversion result, being wary of integer overflow\n\t */\n\tif ((Size) len >= (MaxAllocSize / (Size) MAX_CONVERSION_GROWTH))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"String of %d bytes is too long for encoding conversion.\",\n\t\t\t\t\t\t   len)));\n\n\tresult = palloc(len * MAX_CONVERSION_GROWTH + 1);\n\n\tFunctionCall5(flinfo,\n\t\t\t\t  Int32GetDatum(src_encoding),\n\t\t\t\t  Int32GetDatum(dest_encoding),\n\t\t\t\t  CStringGetDatum(src),\n\t\t\t\t  CStringGetDatum(result),\n\t\t\t\t  Int32GetDatum(len));\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static FmgrInfo *ToServerConvProc = NULL;",
            "static FmgrInfo *ToClientConvProc = NULL;",
            "static const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
            "static char *perform_default_encoding_conversion(const char *src,\n\t\t\t\t\t\t\t\t\tint len, bool is_client_to_server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic FmgrInfo *ToServerConvProc = NULL;\nstatic FmgrInfo *ToClientConvProc = NULL;\nstatic const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic char *perform_default_encoding_conversion(const char *src,\n\t\t\t\t\t\t\t\t\tint len, bool is_client_to_server);\n\nstatic char *\nperform_default_encoding_conversion(const char *src, int len,\n\t\t\t\t\t\t\t\t\tbool is_client_to_server)\n{\n\tchar\t   *result;\n\tint\t\t\tsrc_encoding,\n\t\t\t\tdest_encoding;\n\tFmgrInfo   *flinfo;\n\n\tif (is_client_to_server)\n\t{\n\t\tsrc_encoding = ClientEncoding->encoding;\n\t\tdest_encoding = DatabaseEncoding->encoding;\n\t\tflinfo = ToServerConvProc;\n\t}\n\telse\n\t{\n\t\tsrc_encoding = DatabaseEncoding->encoding;\n\t\tdest_encoding = ClientEncoding->encoding;\n\t\tflinfo = ToClientConvProc;\n\t}\n\n\tif (flinfo == NULL)\n\t\treturn (char *) src;\n\n\t/*\n\t * Allocate space for conversion result, being wary of integer overflow\n\t */\n\tif ((Size) len >= (MaxAllocSize / (Size) MAX_CONVERSION_GROWTH))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"String of %d bytes is too long for encoding conversion.\",\n\t\t\t\t\t\t   len)));\n\n\tresult = palloc(len * MAX_CONVERSION_GROWTH + 1);\n\n\tFunctionCall5(flinfo,\n\t\t\t\t  Int32GetDatum(src_encoding),\n\t\t\t\t  Int32GetDatum(dest_encoding),\n\t\t\t\t  CStringGetDatum(src),\n\t\t\t\t  CStringGetDatum(result),\n\t\t\t\t  Int32GetDatum(len));\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t\t\t\t errmsg(\"invalid byte value for encoding \\\"%s\\\": 0x%02x\",\n\t\t\t\t\t\t\t\t\tpg_enc2name_tbl[PG_SQL_ASCII].name,\n\t\t\t\t\t\t\t\t\t(unsigned char) s[i]))"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid byte value for encoding \\\"%s\\\": 0x%02x\"",
            "pg_enc2name_tbl[PG_SQL_ASCII].name",
            "(unsigned char) s[i]"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_CHARACTER_NOT_IN_REPERTOIRE"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_HIGHBIT_SET",
          "args": [
            "s[i]"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_verify_mbstr",
          "args": [
            "encoding",
            "s",
            "len",
            "false"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "pg_verify_mbstr_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1893-1953",
          "snippet": "int\npg_verify_mbstr_len(int encoding, const char *mbstr, int len, bool noError)\n{\n\tmbverifier\tmbverify;\n\tint\t\t\tmb_len;\n\n\tAssert(PG_VALID_ENCODING(encoding));\n\n\t/*\n\t * In single-byte encodings, we need only reject nulls (\\0).\n\t */\n\tif (pg_encoding_max_length(encoding) <= 1)\n\t{\n\t\tconst char *nullpos = memchr(mbstr, 0, len);\n\n\t\tif (nullpos == NULL)\n\t\t\treturn len;\n\t\tif (noError)\n\t\t\treturn -1;\n\t\treport_invalid_encoding(encoding, nullpos, 1);\n\t}\n\n\t/* fetch function pointer just once */\n\tmbverify = pg_wchar_table[encoding].mbverify;\n\n\tmb_len = 0;\n\n\twhile (len > 0)\n\t{\n\t\tint\t\t\tl;\n\n\t\t/* fast path for ASCII-subset characters */\n\t\tif (!IS_HIGHBIT_SET(*mbstr))\n\t\t{\n\t\t\tif (*mbstr != '\\0')\n\t\t\t{\n\t\t\t\tmb_len++;\n\t\t\t\tmbstr++;\n\t\t\t\tlen--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (noError)\n\t\t\t\treturn -1;\n\t\t\treport_invalid_encoding(encoding, mbstr, len);\n\t\t}\n\n\t\tl = (*mbverify) ((const unsigned char *) mbstr, len);\n\n\t\tif (l < 0)\n\t\t{\n\t\t\tif (noError)\n\t\t\t\treturn -1;\n\t\t\treport_invalid_encoding(encoding, mbstr, len);\n\t\t}\n\n\t\tmbstr += l;\n\t\tlen -= l;\n\t\tmb_len++;\n\t}\n\treturn mb_len;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_verify_mbstr_len(int encoding, const char *mbstr, int len, bool noError)\n{\n\tmbverifier\tmbverify;\n\tint\t\t\tmb_len;\n\n\tAssert(PG_VALID_ENCODING(encoding));\n\n\t/*\n\t * In single-byte encodings, we need only reject nulls (\\0).\n\t */\n\tif (pg_encoding_max_length(encoding) <= 1)\n\t{\n\t\tconst char *nullpos = memchr(mbstr, 0, len);\n\n\t\tif (nullpos == NULL)\n\t\t\treturn len;\n\t\tif (noError)\n\t\t\treturn -1;\n\t\treport_invalid_encoding(encoding, nullpos, 1);\n\t}\n\n\t/* fetch function pointer just once */\n\tmbverify = pg_wchar_table[encoding].mbverify;\n\n\tmb_len = 0;\n\n\twhile (len > 0)\n\t{\n\t\tint\t\t\tl;\n\n\t\t/* fast path for ASCII-subset characters */\n\t\tif (!IS_HIGHBIT_SET(*mbstr))\n\t\t{\n\t\t\tif (*mbstr != '\\0')\n\t\t\t{\n\t\t\t\tmb_len++;\n\t\t\t\tmbstr++;\n\t\t\t\tlen--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (noError)\n\t\t\t\treturn -1;\n\t\t\treport_invalid_encoding(encoding, mbstr, len);\n\t\t}\n\n\t\tl = (*mbverify) ((const unsigned char *) mbstr, len);\n\n\t\tif (l < 0)\n\t\t{\n\t\t\tif (noError)\n\t\t\t\treturn -1;\n\t\t\treport_invalid_encoding(encoding, mbstr, len);\n\t\t}\n\n\t\tmbstr += l;\n\t\tlen -= l;\n\t\tmb_len++;\n\t}\n\treturn mb_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_VALID_BE_ENCODING",
          "args": [
            "encoding"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nchar *\npg_any_to_server(const char *s, int len, int encoding)\n{\n\tif (len <= 0)\n\t\treturn (char *) s;\t\t/* empty string is always valid */\n\n\tif (encoding == DatabaseEncoding->encoding ||\n\t\tencoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is needed, but we must still validate the data.\n\t\t */\n\t\t(void) pg_verify_mbstr(DatabaseEncoding->encoding, s, len, false);\n\t\treturn (char *) s;\n\t}\n\n\tif (DatabaseEncoding->encoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is possible, but we must still validate the data,\n\t\t * because the client-side code might have done string escaping using\n\t\t * the selected client_encoding.  If the client encoding is ASCII-safe\n\t\t * then we just do a straight validation under that encoding.  For an\n\t\t * ASCII-unsafe encoding we have a problem: we dare not pass such data\n\t\t * to the parser but we have no way to convert it.  We compromise by\n\t\t * rejecting the data if it contains any non-ASCII characters.\n\t\t */\n\t\tif (PG_VALID_BE_ENCODING(encoding))\n\t\t\t(void) pg_verify_mbstr(encoding, s, len, false);\n\t\telse\n\t\t{\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\tif (s[i] == '\\0' || IS_HIGHBIT_SET(s[i]))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t\t\t\t errmsg(\"invalid byte value for encoding \\\"%s\\\": 0x%02x\",\n\t\t\t\t\t\t\t\t\tpg_enc2name_tbl[PG_SQL_ASCII].name,\n\t\t\t\t\t\t\t\t\t(unsigned char) s[i])));\n\t\t\t}\n\t\t}\n\t\treturn (char *) s;\n\t}\n\n\t/* Fast path if we can use cached conversion function */\n\tif (encoding == ClientEncoding->encoding)\n\t\treturn perform_default_encoding_conversion(s, len, true);\n\n\t/* General case ... will not work outside transactions */\n\treturn (char *) pg_do_encoding_conversion((unsigned char *) s,\n\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t  encoding,\n\t\t\t\t\t\t\t\t\t\t\t  DatabaseEncoding->encoding);\n}"
  },
  {
    "function_name": "pg_client_to_server",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "544-548",
    "snippet": "char *\npg_client_to_server(const char *s, int len)\n{\n\treturn pg_any_to_server(s, len, ClientEncoding->encoding);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_any_to_server",
          "args": [
            "s",
            "len",
            "ClientEncoding->encoding"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "pg_any_to_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "560-615",
          "snippet": "char *\npg_any_to_server(const char *s, int len, int encoding)\n{\n\tif (len <= 0)\n\t\treturn (char *) s;\t\t/* empty string is always valid */\n\n\tif (encoding == DatabaseEncoding->encoding ||\n\t\tencoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is needed, but we must still validate the data.\n\t\t */\n\t\t(void) pg_verify_mbstr(DatabaseEncoding->encoding, s, len, false);\n\t\treturn (char *) s;\n\t}\n\n\tif (DatabaseEncoding->encoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is possible, but we must still validate the data,\n\t\t * because the client-side code might have done string escaping using\n\t\t * the selected client_encoding.  If the client encoding is ASCII-safe\n\t\t * then we just do a straight validation under that encoding.  For an\n\t\t * ASCII-unsafe encoding we have a problem: we dare not pass such data\n\t\t * to the parser but we have no way to convert it.  We compromise by\n\t\t * rejecting the data if it contains any non-ASCII characters.\n\t\t */\n\t\tif (PG_VALID_BE_ENCODING(encoding))\n\t\t\t(void) pg_verify_mbstr(encoding, s, len, false);\n\t\telse\n\t\t{\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\tif (s[i] == '\\0' || IS_HIGHBIT_SET(s[i]))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t\t\t\t errmsg(\"invalid byte value for encoding \\\"%s\\\": 0x%02x\",\n\t\t\t\t\t\t\t\t\tpg_enc2name_tbl[PG_SQL_ASCII].name,\n\t\t\t\t\t\t\t\t\t(unsigned char) s[i])));\n\t\t\t}\n\t\t}\n\t\treturn (char *) s;\n\t}\n\n\t/* Fast path if we can use cached conversion function */\n\tif (encoding == ClientEncoding->encoding)\n\t\treturn perform_default_encoding_conversion(s, len, true);\n\n\t/* General case ... will not work outside transactions */\n\treturn (char *) pg_do_encoding_conversion((unsigned char *) s,\n\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t  encoding,\n\t\t\t\t\t\t\t\t\t\t\t  DatabaseEncoding->encoding);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nchar *\npg_any_to_server(const char *s, int len, int encoding)\n{\n\tif (len <= 0)\n\t\treturn (char *) s;\t\t/* empty string is always valid */\n\n\tif (encoding == DatabaseEncoding->encoding ||\n\t\tencoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is needed, but we must still validate the data.\n\t\t */\n\t\t(void) pg_verify_mbstr(DatabaseEncoding->encoding, s, len, false);\n\t\treturn (char *) s;\n\t}\n\n\tif (DatabaseEncoding->encoding == PG_SQL_ASCII)\n\t{\n\t\t/*\n\t\t * No conversion is possible, but we must still validate the data,\n\t\t * because the client-side code might have done string escaping using\n\t\t * the selected client_encoding.  If the client encoding is ASCII-safe\n\t\t * then we just do a straight validation under that encoding.  For an\n\t\t * ASCII-unsafe encoding we have a problem: we dare not pass such data\n\t\t * to the parser but we have no way to convert it.  We compromise by\n\t\t * rejecting the data if it contains any non-ASCII characters.\n\t\t */\n\t\tif (PG_VALID_BE_ENCODING(encoding))\n\t\t\t(void) pg_verify_mbstr(encoding, s, len, false);\n\t\telse\n\t\t{\n\t\t\tint\t\t\ti;\n\n\t\t\tfor (i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\tif (s[i] == '\\0' || IS_HIGHBIT_SET(s[i]))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),\n\t\t\t\t\t\t\t errmsg(\"invalid byte value for encoding \\\"%s\\\": 0x%02x\",\n\t\t\t\t\t\t\t\t\tpg_enc2name_tbl[PG_SQL_ASCII].name,\n\t\t\t\t\t\t\t\t\t(unsigned char) s[i])));\n\t\t\t}\n\t\t}\n\t\treturn (char *) s;\n\t}\n\n\t/* Fast path if we can use cached conversion function */\n\tif (encoding == ClientEncoding->encoding)\n\t\treturn perform_default_encoding_conversion(s, len, true);\n\n\t/* General case ... will not work outside transactions */\n\treturn (char *) pg_do_encoding_conversion((unsigned char *) s,\n\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t  encoding,\n\t\t\t\t\t\t\t\t\t\t\t  DatabaseEncoding->encoding);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nchar *\npg_client_to_server(const char *s, int len)\n{\n\treturn pg_any_to_server(s, len, ClientEncoding->encoding);\n}"
  },
  {
    "function_name": "pg_encoding_max_length_sql",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "528-537",
    "snippet": "Datum\npg_encoding_max_length_sql(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tencoding = PG_GETARG_INT32(0);\n\n\tif (PG_VALID_ENCODING(encoding))\n\t\tPG_RETURN_INT32(pg_wchar_table[encoding].maxmblen);\n\telse\n\t\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "pg_wchar_table[encoding].maxmblen"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_VALID_ENCODING",
          "args": [
            "encoding"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "0"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nDatum\npg_encoding_max_length_sql(PG_FUNCTION_ARGS)\n{\n\tint\t\t\tencoding = PG_GETARG_INT32(0);\n\n\tif (PG_VALID_ENCODING(encoding))\n\t\tPG_RETURN_INT32(pg_wchar_table[encoding].maxmblen);\n\telse\n\t\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "length_in_encoding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "499-521",
    "snippet": "Datum\nlength_in_encoding(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *string = PG_GETARG_BYTEA_PP(0);\n\tchar\t   *src_encoding_name = NameStr(*PG_GETARG_NAME(1));\n\tint\t\t\tsrc_encoding = pg_char_to_encoding(src_encoding_name);\n\tconst char *src_str;\n\tint\t\t\tlen;\n\tint\t\t\tretval;\n\n\tif (src_encoding < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid encoding name \\\"%s\\\"\",\n\t\t\t\t\t\tsrc_encoding_name)));\n\n\tlen = VARSIZE_ANY_EXHDR(string);\n\tsrc_str = VARDATA_ANY(string);\n\n\tretval = pg_verify_mbstr_len(src_encoding, src_str, len, false);\n\n\tPG_RETURN_INT32(retval);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "retval"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_verify_mbstr_len",
          "args": [
            "src_encoding",
            "src_str",
            "len",
            "false"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "pg_verify_mbstr_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1893-1953",
          "snippet": "int\npg_verify_mbstr_len(int encoding, const char *mbstr, int len, bool noError)\n{\n\tmbverifier\tmbverify;\n\tint\t\t\tmb_len;\n\n\tAssert(PG_VALID_ENCODING(encoding));\n\n\t/*\n\t * In single-byte encodings, we need only reject nulls (\\0).\n\t */\n\tif (pg_encoding_max_length(encoding) <= 1)\n\t{\n\t\tconst char *nullpos = memchr(mbstr, 0, len);\n\n\t\tif (nullpos == NULL)\n\t\t\treturn len;\n\t\tif (noError)\n\t\t\treturn -1;\n\t\treport_invalid_encoding(encoding, nullpos, 1);\n\t}\n\n\t/* fetch function pointer just once */\n\tmbverify = pg_wchar_table[encoding].mbverify;\n\n\tmb_len = 0;\n\n\twhile (len > 0)\n\t{\n\t\tint\t\t\tl;\n\n\t\t/* fast path for ASCII-subset characters */\n\t\tif (!IS_HIGHBIT_SET(*mbstr))\n\t\t{\n\t\t\tif (*mbstr != '\\0')\n\t\t\t{\n\t\t\t\tmb_len++;\n\t\t\t\tmbstr++;\n\t\t\t\tlen--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (noError)\n\t\t\t\treturn -1;\n\t\t\treport_invalid_encoding(encoding, mbstr, len);\n\t\t}\n\n\t\tl = (*mbverify) ((const unsigned char *) mbstr, len);\n\n\t\tif (l < 0)\n\t\t{\n\t\t\tif (noError)\n\t\t\t\treturn -1;\n\t\t\treport_invalid_encoding(encoding, mbstr, len);\n\t\t}\n\n\t\tmbstr += l;\n\t\tlen -= l;\n\t\tmb_len++;\n\t}\n\treturn mb_len;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_verify_mbstr_len(int encoding, const char *mbstr, int len, bool noError)\n{\n\tmbverifier\tmbverify;\n\tint\t\t\tmb_len;\n\n\tAssert(PG_VALID_ENCODING(encoding));\n\n\t/*\n\t * In single-byte encodings, we need only reject nulls (\\0).\n\t */\n\tif (pg_encoding_max_length(encoding) <= 1)\n\t{\n\t\tconst char *nullpos = memchr(mbstr, 0, len);\n\n\t\tif (nullpos == NULL)\n\t\t\treturn len;\n\t\tif (noError)\n\t\t\treturn -1;\n\t\treport_invalid_encoding(encoding, nullpos, 1);\n\t}\n\n\t/* fetch function pointer just once */\n\tmbverify = pg_wchar_table[encoding].mbverify;\n\n\tmb_len = 0;\n\n\twhile (len > 0)\n\t{\n\t\tint\t\t\tl;\n\n\t\t/* fast path for ASCII-subset characters */\n\t\tif (!IS_HIGHBIT_SET(*mbstr))\n\t\t{\n\t\t\tif (*mbstr != '\\0')\n\t\t\t{\n\t\t\t\tmb_len++;\n\t\t\t\tmbstr++;\n\t\t\t\tlen--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (noError)\n\t\t\t\treturn -1;\n\t\t\treport_invalid_encoding(encoding, mbstr, len);\n\t\t}\n\n\t\tl = (*mbverify) ((const unsigned char *) mbstr, len);\n\n\t\tif (l < 0)\n\t\t{\n\t\t\tif (noError)\n\t\t\t\treturn -1;\n\t\t\treport_invalid_encoding(encoding, mbstr, len);\n\t\t}\n\n\t\tmbstr += l;\n\t\tlen -= l;\n\t\tmb_len++;\n\t}\n\treturn mb_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "string"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "string"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid encoding name \\\"%s\\\"\",\n\t\t\t\t\t\tsrc_encoding_name))"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid encoding name \\\"%s\\\"\"",
            "src_encoding_name"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_char_to_encoding",
          "args": [
            "src_encoding_name"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "pg_char_to_encoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/encnames.c",
          "lines": "550-594",
          "snippet": "int\npg_char_to_encoding(const char *name)\n{\n\tunsigned int nel = lengthof(pg_encname_tbl);\n\tconst pg_encname *base = pg_encname_tbl,\n\t\t\t   *last = base + nel - 1,\n\t\t\t   *position;\n\tint\t\t\tresult;\n\tchar\t\tbuff[NAMEDATALEN],\n\t\t\t   *key;\n\n\tif (name == NULL || *name == '\\0')\n\t\treturn -1;\n\n\tif (strlen(name) >= NAMEDATALEN)\n\t{\n#ifdef FRONTEND\n\t\tfprintf(stderr, \"encoding name too long\\n\");\n\t\treturn -1;\n#else\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NAME_TOO_LONG),\n\t\t\t\t errmsg(\"encoding name too long\")));\n#endif\n\t}\n\tkey = clean_encoding_name(name, buff);\n\n\twhile (last >= base)\n\t{\n\t\tposition = base + ((last - base) >> 1);\n\t\tresult = key[0] - position->name[0];\n\n\t\tif (result == 0)\n\t\t{\n\t\t\tresult = strcmp(key, position->name);\n\t\t\tif (result == 0)\n\t\t\t\treturn position->encoding;\n\t\t}\n\t\tif (result < 0)\n\t\t\tlast = position - 1;\n\t\telse\n\t\t\tbase = position + 1;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"utils/builtins.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_encname pg_encname_tbl[] =\n{\n\t{\n\t\t\"abc\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"alt\", PG_WIN866\n\t},\t\t\t\t\t\t\t/* IBM866 */\n\t{\n\t\t\"big5\", PG_BIG5\n\t},\t\t\t\t\t\t\t/* Big5; Chinese for Taiwan multibyte set */\n\t{\n\t\t\"euccn\", PG_EUC_CN\n\t},\t\t\t\t\t\t\t/* EUC-CN; Extended Unix Code for simplified\n\t\t\t\t\t\t\t\t * Chinese */\n\t{\n\t\t\"eucjis2004\", PG_EUC_JIS_2004\n\t},\t\t\t\t\t\t\t/* EUC-JIS-2004; Extended UNIX Code fixed\n\t\t\t\t\t\t\t\t * Width for Japanese, standard JIS X 0213 */\n\t{\n\t\t\"eucjp\", PG_EUC_JP\n\t},\t\t\t\t\t\t\t/* EUC-JP; Extended UNIX Code fixed Width for\n\t\t\t\t\t\t\t\t * Japanese, standard OSF */\n\t{\n\t\t\"euckr\", PG_EUC_KR\n\t},\t\t\t\t\t\t\t/* EUC-KR; Extended Unix Code for Korean , KS\n\t\t\t\t\t\t\t\t * X 1001 standard */\n\t{\n\t\t\"euctw\", PG_EUC_TW\n\t},\t\t\t\t\t\t\t/* EUC-TW; Extended Unix Code for\n\t\t\t\t\t\t\t\t *\n\t\t\t\t\t\t\t\t * traditional Chinese */\n\t{\n\t\t\"gb18030\", PG_GB18030\n\t},\t\t\t\t\t\t\t/* GB18030;GB18030 */\n\t{\n\t\t\"gbk\", PG_GBK\n\t},\t\t\t\t\t\t\t/* GBK; Chinese Windows CodePage 936\n\t\t\t\t\t\t\t\t * simplified Chinese */\n\t{\n\t\t\"iso88591\", PG_LATIN1\n\t},\t\t\t\t\t\t\t/* ISO-8859-1; RFC1345,KXS2 */\n\t{\n\t\t\"iso885910\", PG_LATIN6\n\t},\t\t\t\t\t\t\t/* ISO-8859-10; RFC1345,KXS2 */\n\t{\n\t\t\"iso885913\", PG_LATIN7\n\t},\t\t\t\t\t\t\t/* ISO-8859-13; RFC1345,KXS2 */\n\t{\n\t\t\"iso885914\", PG_LATIN8\n\t},\t\t\t\t\t\t\t/* ISO-8859-14; RFC1345,KXS2 */\n\t{\n\t\t\"iso885915\", PG_LATIN9\n\t},\t\t\t\t\t\t\t/* ISO-8859-15; RFC1345,KXS2 */\n\t{\n\t\t\"iso885916\", PG_LATIN10\n\t},\t\t\t\t\t\t\t/* ISO-8859-16; RFC1345,KXS2 */\n\t{\n\t\t\"iso88592\", PG_LATIN2\n\t},\t\t\t\t\t\t\t/* ISO-8859-2; RFC1345,KXS2 */\n\t{\n\t\t\"iso88593\", PG_LATIN3\n\t},\t\t\t\t\t\t\t/* ISO-8859-3; RFC1345,KXS2 */\n\t{\n\t\t\"iso88594\", PG_LATIN4\n\t},\t\t\t\t\t\t\t/* ISO-8859-4; RFC1345,KXS2 */\n\t{\n\t\t\"iso88595\", PG_ISO_8859_5\n\t},\t\t\t\t\t\t\t/* ISO-8859-5; RFC1345,KXS2 */\n\t{\n\t\t\"iso88596\", PG_ISO_8859_6\n\t},\t\t\t\t\t\t\t/* ISO-8859-6; RFC1345,KXS2 */\n\t{\n\t\t\"iso88597\", PG_ISO_8859_7\n\t},\t\t\t\t\t\t\t/* ISO-8859-7; RFC1345,KXS2 */\n\t{\n\t\t\"iso88598\", PG_ISO_8859_8\n\t},\t\t\t\t\t\t\t/* ISO-8859-8; RFC1345,KXS2 */\n\t{\n\t\t\"iso88599\", PG_LATIN5\n\t},\t\t\t\t\t\t\t/* ISO-8859-9; RFC1345,KXS2 */\n\t{\n\t\t\"johab\", PG_JOHAB\n\t},\t\t\t\t\t\t\t/* JOHAB; Extended Unix Code for simplified\n\t\t\t\t\t\t\t\t * Chinese */\n\t{\n\t\t\"koi8\", PG_KOI8R\n\t},\t\t\t\t\t\t\t/* _dirty_ alias for KOI8-R (backward\n\t\t\t\t\t\t\t\t * compatibility) */\n\t{\n\t\t\"koi8r\", PG_KOI8R\n\t},\t\t\t\t\t\t\t/* KOI8-R; RFC1489 */\n\t{\n\t\t\"koi8u\", PG_KOI8U\n\t},\t\t\t\t\t\t\t/* KOI8-U; RFC2319 */\n\t{\n\t\t\"latin1\", PG_LATIN1\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-1 */\n\t{\n\t\t\"latin10\", PG_LATIN10\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-16 */\n\t{\n\t\t\"latin2\", PG_LATIN2\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-2 */\n\t{\n\t\t\"latin3\", PG_LATIN3\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-3 */\n\t{\n\t\t\"latin4\", PG_LATIN4\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-4 */\n\t{\n\t\t\"latin5\", PG_LATIN5\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-9 */\n\t{\n\t\t\"latin6\", PG_LATIN6\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-10 */\n\t{\n\t\t\"latin7\", PG_LATIN7\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-13 */\n\t{\n\t\t\"latin8\", PG_LATIN8\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-14 */\n\t{\n\t\t\"latin9\", PG_LATIN9\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-15 */\n\t{\n\t\t\"mskanji\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"muleinternal\", PG_MULE_INTERNAL\n\t},\n\t{\n\t\t\"shiftjis\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* Shift_JIS; JIS X 0202-1991 */\n\n\t{\n\t\t\"shiftjis2004\", PG_SHIFT_JIS_2004\n\t},\t\t\t\t\t\t\t/* SHIFT-JIS-2004; Shift JIS for Japanese,\n\t\t\t\t\t\t\t\t * standard JIS X 0213 */\n\t{\n\t\t\"sjis\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"sqlascii\", PG_SQL_ASCII\n\t},\n\t{\n\t\t\"tcvn\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"tcvn5712\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"uhc\", PG_UHC\n\t},\t\t\t\t\t\t\t/* UHC; Korean Windows CodePage 949 */\n\t{\n\t\t\"unicode\", PG_UTF8\n\t},\t\t\t\t\t\t\t/* alias for UTF8 */\n\t{\n\t\t\"utf8\", PG_UTF8\n\t},\t\t\t\t\t\t\t/* alias for UTF8 */\n\t{\n\t\t\"vscii\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"win\", PG_WIN1251\n\t},\t\t\t\t\t\t\t/* _dirty_ alias for windows-1251 (backward\n\t\t\t\t\t\t\t\t * compatibility) */\n\t{\n\t\t\"win1250\", PG_WIN1250\n\t},\t\t\t\t\t\t\t/* alias for Windows-1250 */\n\t{\n\t\t\"win1251\", PG_WIN1251\n\t},\t\t\t\t\t\t\t/* alias for Windows-1251 */\n\t{\n\t\t\"win1252\", PG_WIN1252\n\t},\t\t\t\t\t\t\t/* alias for Windows-1252 */\n\t{\n\t\t\"win1253\", PG_WIN1253\n\t},\t\t\t\t\t\t\t/* alias for Windows-1253 */\n\t{\n\t\t\"win1254\", PG_WIN1254\n\t},\t\t\t\t\t\t\t/* alias for Windows-1254 */\n\t{\n\t\t\"win1255\", PG_WIN1255\n\t},\t\t\t\t\t\t\t/* alias for Windows-1255 */\n\t{\n\t\t\"win1256\", PG_WIN1256\n\t},\t\t\t\t\t\t\t/* alias for Windows-1256 */\n\t{\n\t\t\"win1257\", PG_WIN1257\n\t},\t\t\t\t\t\t\t/* alias for Windows-1257 */\n\t{\n\t\t\"win1258\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for Windows-1258 */\n\t{\n\t\t\"win866\", PG_WIN866\n\t},\t\t\t\t\t\t\t/* IBM866 */\n\t{\n\t\t\"win874\", PG_WIN874\n\t},\t\t\t\t\t\t\t/* alias for Windows-874 */\n\t{\n\t\t\"win932\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"win936\", PG_GBK\n\t},\t\t\t\t\t\t\t/* alias for GBK */\n\t{\n\t\t\"win949\", PG_UHC\n\t},\t\t\t\t\t\t\t/* alias for UHC */\n\t{\n\t\t\"win950\", PG_BIG5\n\t},\t\t\t\t\t\t\t/* alias for BIG5 */\n\t{\n\t\t\"windows1250\", PG_WIN1250\n\t},\t\t\t\t\t\t\t/* Windows-1251; Microsoft */\n\t{\n\t\t\"windows1251\", PG_WIN1251\n\t},\t\t\t\t\t\t\t/* Windows-1251; Microsoft */\n\t{\n\t\t\"windows1252\", PG_WIN1252\n\t},\t\t\t\t\t\t\t/* Windows-1252; Microsoft */\n\t{\n\t\t\"windows1253\", PG_WIN1253\n\t},\t\t\t\t\t\t\t/* Windows-1253; Microsoft */\n\t{\n\t\t\"windows1254\", PG_WIN1254\n\t},\t\t\t\t\t\t\t/* Windows-1254; Microsoft */\n\t{\n\t\t\"windows1255\", PG_WIN1255\n\t},\t\t\t\t\t\t\t/* Windows-1255; Microsoft */\n\t{\n\t\t\"windows1256\", PG_WIN1256\n\t},\t\t\t\t\t\t\t/* Windows-1256; Microsoft */\n\t{\n\t\t\"windows1257\", PG_WIN1257\n\t},\t\t\t\t\t\t\t/* Windows-1257; Microsoft */\n\t{\n\t\t\"windows1258\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* Windows-1258; Microsoft */\n\t{\n\t\t\"windows866\", PG_WIN866\n\t},\t\t\t\t\t\t\t/* IBM866 */\n\t{\n\t\t\"windows874\", PG_WIN874\n\t},\t\t\t\t\t\t\t/* Windows-874; Microsoft */\n\t{\n\t\t\"windows932\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"windows936\", PG_GBK\n\t},\t\t\t\t\t\t\t/* alias for GBK */\n\t{\n\t\t\"windows949\", PG_UHC\n\t},\t\t\t\t\t\t\t/* alias for UHC */\n\t{\n\t\t\"windows950\", PG_BIG5\n\t}\t\t\t\t\t\t\t/* alias for BIG5 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include <unistd.h>\n#include <ctype.h>\n#include \"utils/builtins.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nstatic const pg_encname pg_encname_tbl[] =\n{\n\t{\n\t\t\"abc\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"alt\", PG_WIN866\n\t},\t\t\t\t\t\t\t/* IBM866 */\n\t{\n\t\t\"big5\", PG_BIG5\n\t},\t\t\t\t\t\t\t/* Big5; Chinese for Taiwan multibyte set */\n\t{\n\t\t\"euccn\", PG_EUC_CN\n\t},\t\t\t\t\t\t\t/* EUC-CN; Extended Unix Code for simplified\n\t\t\t\t\t\t\t\t * Chinese */\n\t{\n\t\t\"eucjis2004\", PG_EUC_JIS_2004\n\t},\t\t\t\t\t\t\t/* EUC-JIS-2004; Extended UNIX Code fixed\n\t\t\t\t\t\t\t\t * Width for Japanese, standard JIS X 0213 */\n\t{\n\t\t\"eucjp\", PG_EUC_JP\n\t},\t\t\t\t\t\t\t/* EUC-JP; Extended UNIX Code fixed Width for\n\t\t\t\t\t\t\t\t * Japanese, standard OSF */\n\t{\n\t\t\"euckr\", PG_EUC_KR\n\t},\t\t\t\t\t\t\t/* EUC-KR; Extended Unix Code for Korean , KS\n\t\t\t\t\t\t\t\t * X 1001 standard */\n\t{\n\t\t\"euctw\", PG_EUC_TW\n\t},\t\t\t\t\t\t\t/* EUC-TW; Extended Unix Code for\n\t\t\t\t\t\t\t\t *\n\t\t\t\t\t\t\t\t * traditional Chinese */\n\t{\n\t\t\"gb18030\", PG_GB18030\n\t},\t\t\t\t\t\t\t/* GB18030;GB18030 */\n\t{\n\t\t\"gbk\", PG_GBK\n\t},\t\t\t\t\t\t\t/* GBK; Chinese Windows CodePage 936\n\t\t\t\t\t\t\t\t * simplified Chinese */\n\t{\n\t\t\"iso88591\", PG_LATIN1\n\t},\t\t\t\t\t\t\t/* ISO-8859-1; RFC1345,KXS2 */\n\t{\n\t\t\"iso885910\", PG_LATIN6\n\t},\t\t\t\t\t\t\t/* ISO-8859-10; RFC1345,KXS2 */\n\t{\n\t\t\"iso885913\", PG_LATIN7\n\t},\t\t\t\t\t\t\t/* ISO-8859-13; RFC1345,KXS2 */\n\t{\n\t\t\"iso885914\", PG_LATIN8\n\t},\t\t\t\t\t\t\t/* ISO-8859-14; RFC1345,KXS2 */\n\t{\n\t\t\"iso885915\", PG_LATIN9\n\t},\t\t\t\t\t\t\t/* ISO-8859-15; RFC1345,KXS2 */\n\t{\n\t\t\"iso885916\", PG_LATIN10\n\t},\t\t\t\t\t\t\t/* ISO-8859-16; RFC1345,KXS2 */\n\t{\n\t\t\"iso88592\", PG_LATIN2\n\t},\t\t\t\t\t\t\t/* ISO-8859-2; RFC1345,KXS2 */\n\t{\n\t\t\"iso88593\", PG_LATIN3\n\t},\t\t\t\t\t\t\t/* ISO-8859-3; RFC1345,KXS2 */\n\t{\n\t\t\"iso88594\", PG_LATIN4\n\t},\t\t\t\t\t\t\t/* ISO-8859-4; RFC1345,KXS2 */\n\t{\n\t\t\"iso88595\", PG_ISO_8859_5\n\t},\t\t\t\t\t\t\t/* ISO-8859-5; RFC1345,KXS2 */\n\t{\n\t\t\"iso88596\", PG_ISO_8859_6\n\t},\t\t\t\t\t\t\t/* ISO-8859-6; RFC1345,KXS2 */\n\t{\n\t\t\"iso88597\", PG_ISO_8859_7\n\t},\t\t\t\t\t\t\t/* ISO-8859-7; RFC1345,KXS2 */\n\t{\n\t\t\"iso88598\", PG_ISO_8859_8\n\t},\t\t\t\t\t\t\t/* ISO-8859-8; RFC1345,KXS2 */\n\t{\n\t\t\"iso88599\", PG_LATIN5\n\t},\t\t\t\t\t\t\t/* ISO-8859-9; RFC1345,KXS2 */\n\t{\n\t\t\"johab\", PG_JOHAB\n\t},\t\t\t\t\t\t\t/* JOHAB; Extended Unix Code for simplified\n\t\t\t\t\t\t\t\t * Chinese */\n\t{\n\t\t\"koi8\", PG_KOI8R\n\t},\t\t\t\t\t\t\t/* _dirty_ alias for KOI8-R (backward\n\t\t\t\t\t\t\t\t * compatibility) */\n\t{\n\t\t\"koi8r\", PG_KOI8R\n\t},\t\t\t\t\t\t\t/* KOI8-R; RFC1489 */\n\t{\n\t\t\"koi8u\", PG_KOI8U\n\t},\t\t\t\t\t\t\t/* KOI8-U; RFC2319 */\n\t{\n\t\t\"latin1\", PG_LATIN1\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-1 */\n\t{\n\t\t\"latin10\", PG_LATIN10\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-16 */\n\t{\n\t\t\"latin2\", PG_LATIN2\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-2 */\n\t{\n\t\t\"latin3\", PG_LATIN3\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-3 */\n\t{\n\t\t\"latin4\", PG_LATIN4\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-4 */\n\t{\n\t\t\"latin5\", PG_LATIN5\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-9 */\n\t{\n\t\t\"latin6\", PG_LATIN6\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-10 */\n\t{\n\t\t\"latin7\", PG_LATIN7\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-13 */\n\t{\n\t\t\"latin8\", PG_LATIN8\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-14 */\n\t{\n\t\t\"latin9\", PG_LATIN9\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-15 */\n\t{\n\t\t\"mskanji\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"muleinternal\", PG_MULE_INTERNAL\n\t},\n\t{\n\t\t\"shiftjis\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* Shift_JIS; JIS X 0202-1991 */\n\n\t{\n\t\t\"shiftjis2004\", PG_SHIFT_JIS_2004\n\t},\t\t\t\t\t\t\t/* SHIFT-JIS-2004; Shift JIS for Japanese,\n\t\t\t\t\t\t\t\t * standard JIS X 0213 */\n\t{\n\t\t\"sjis\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"sqlascii\", PG_SQL_ASCII\n\t},\n\t{\n\t\t\"tcvn\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"tcvn5712\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"uhc\", PG_UHC\n\t},\t\t\t\t\t\t\t/* UHC; Korean Windows CodePage 949 */\n\t{\n\t\t\"unicode\", PG_UTF8\n\t},\t\t\t\t\t\t\t/* alias for UTF8 */\n\t{\n\t\t\"utf8\", PG_UTF8\n\t},\t\t\t\t\t\t\t/* alias for UTF8 */\n\t{\n\t\t\"vscii\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"win\", PG_WIN1251\n\t},\t\t\t\t\t\t\t/* _dirty_ alias for windows-1251 (backward\n\t\t\t\t\t\t\t\t * compatibility) */\n\t{\n\t\t\"win1250\", PG_WIN1250\n\t},\t\t\t\t\t\t\t/* alias for Windows-1250 */\n\t{\n\t\t\"win1251\", PG_WIN1251\n\t},\t\t\t\t\t\t\t/* alias for Windows-1251 */\n\t{\n\t\t\"win1252\", PG_WIN1252\n\t},\t\t\t\t\t\t\t/* alias for Windows-1252 */\n\t{\n\t\t\"win1253\", PG_WIN1253\n\t},\t\t\t\t\t\t\t/* alias for Windows-1253 */\n\t{\n\t\t\"win1254\", PG_WIN1254\n\t},\t\t\t\t\t\t\t/* alias for Windows-1254 */\n\t{\n\t\t\"win1255\", PG_WIN1255\n\t},\t\t\t\t\t\t\t/* alias for Windows-1255 */\n\t{\n\t\t\"win1256\", PG_WIN1256\n\t},\t\t\t\t\t\t\t/* alias for Windows-1256 */\n\t{\n\t\t\"win1257\", PG_WIN1257\n\t},\t\t\t\t\t\t\t/* alias for Windows-1257 */\n\t{\n\t\t\"win1258\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for Windows-1258 */\n\t{\n\t\t\"win866\", PG_WIN866\n\t},\t\t\t\t\t\t\t/* IBM866 */\n\t{\n\t\t\"win874\", PG_WIN874\n\t},\t\t\t\t\t\t\t/* alias for Windows-874 */\n\t{\n\t\t\"win932\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"win936\", PG_GBK\n\t},\t\t\t\t\t\t\t/* alias for GBK */\n\t{\n\t\t\"win949\", PG_UHC\n\t},\t\t\t\t\t\t\t/* alias for UHC */\n\t{\n\t\t\"win950\", PG_BIG5\n\t},\t\t\t\t\t\t\t/* alias for BIG5 */\n\t{\n\t\t\"windows1250\", PG_WIN1250\n\t},\t\t\t\t\t\t\t/* Windows-1251; Microsoft */\n\t{\n\t\t\"windows1251\", PG_WIN1251\n\t},\t\t\t\t\t\t\t/* Windows-1251; Microsoft */\n\t{\n\t\t\"windows1252\", PG_WIN1252\n\t},\t\t\t\t\t\t\t/* Windows-1252; Microsoft */\n\t{\n\t\t\"windows1253\", PG_WIN1253\n\t},\t\t\t\t\t\t\t/* Windows-1253; Microsoft */\n\t{\n\t\t\"windows1254\", PG_WIN1254\n\t},\t\t\t\t\t\t\t/* Windows-1254; Microsoft */\n\t{\n\t\t\"windows1255\", PG_WIN1255\n\t},\t\t\t\t\t\t\t/* Windows-1255; Microsoft */\n\t{\n\t\t\"windows1256\", PG_WIN1256\n\t},\t\t\t\t\t\t\t/* Windows-1256; Microsoft */\n\t{\n\t\t\"windows1257\", PG_WIN1257\n\t},\t\t\t\t\t\t\t/* Windows-1257; Microsoft */\n\t{\n\t\t\"windows1258\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* Windows-1258; Microsoft */\n\t{\n\t\t\"windows866\", PG_WIN866\n\t},\t\t\t\t\t\t\t/* IBM866 */\n\t{\n\t\t\"windows874\", PG_WIN874\n\t},\t\t\t\t\t\t\t/* Windows-874; Microsoft */\n\t{\n\t\t\"windows932\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"windows936\", PG_GBK\n\t},\t\t\t\t\t\t\t/* alias for GBK */\n\t{\n\t\t\"windows949\", PG_UHC\n\t},\t\t\t\t\t\t\t/* alias for UHC */\n\t{\n\t\t\"windows950\", PG_BIG5\n\t}\t\t\t\t\t\t\t/* alias for BIG5 */\n};\n\nint\npg_char_to_encoding(const char *name)\n{\n\tunsigned int nel = lengthof(pg_encname_tbl);\n\tconst pg_encname *base = pg_encname_tbl,\n\t\t\t   *last = base + nel - 1,\n\t\t\t   *position;\n\tint\t\t\tresult;\n\tchar\t\tbuff[NAMEDATALEN],\n\t\t\t   *key;\n\n\tif (name == NULL || *name == '\\0')\n\t\treturn -1;\n\n\tif (strlen(name) >= NAMEDATALEN)\n\t{\n#ifdef FRONTEND\n\t\tfprintf(stderr, \"encoding name too long\\n\");\n\t\treturn -1;\n#else\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NAME_TOO_LONG),\n\t\t\t\t errmsg(\"encoding name too long\")));\n#endif\n\t}\n\tkey = clean_encoding_name(name, buff);\n\n\twhile (last >= base)\n\t{\n\t\tposition = base + ((last - base) >> 1);\n\t\tresult = key[0] - position->name[0];\n\n\t\tif (result == 0)\n\t\t{\n\t\t\tresult = strcmp(key, position->name);\n\t\t\tif (result == 0)\n\t\t\t\treturn position->encoding;\n\t\t}\n\t\tif (result < 0)\n\t\t\tlast = position - 1;\n\t\telse\n\t\t\tbase = position + 1;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*PG_GETARG_NAME(1)"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_NAME",
          "args": [
            "1"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "0"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nDatum\nlength_in_encoding(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *string = PG_GETARG_BYTEA_PP(0);\n\tchar\t   *src_encoding_name = NameStr(*PG_GETARG_NAME(1));\n\tint\t\t\tsrc_encoding = pg_char_to_encoding(src_encoding_name);\n\tconst char *src_str;\n\tint\t\t\tlen;\n\tint\t\t\tretval;\n\n\tif (src_encoding < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid encoding name \\\"%s\\\"\",\n\t\t\t\t\t\tsrc_encoding_name)));\n\n\tlen = VARSIZE_ANY_EXHDR(string);\n\tsrc_str = VARDATA_ANY(string);\n\n\tretval = pg_verify_mbstr_len(src_encoding, src_str, len, false);\n\n\tPG_RETURN_INT32(retval);\n}"
  },
  {
    "function_name": "pg_convert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "437-490",
    "snippet": "Datum\npg_convert(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *string = PG_GETARG_BYTEA_PP(0);\n\tchar\t   *src_encoding_name = NameStr(*PG_GETARG_NAME(1));\n\tint\t\t\tsrc_encoding = pg_char_to_encoding(src_encoding_name);\n\tchar\t   *dest_encoding_name = NameStr(*PG_GETARG_NAME(2));\n\tint\t\t\tdest_encoding = pg_char_to_encoding(dest_encoding_name);\n\tconst char *src_str;\n\tchar\t   *dest_str;\n\tbytea\t   *retval;\n\tint\t\t\tlen;\n\n\tif (src_encoding < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid source encoding name \\\"%s\\\"\",\n\t\t\t\t\t\tsrc_encoding_name)));\n\tif (dest_encoding < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid destination encoding name \\\"%s\\\"\",\n\t\t\t\t\t\tdest_encoding_name)));\n\n\t/* make sure that source string is valid */\n\tlen = VARSIZE_ANY_EXHDR(string);\n\tsrc_str = VARDATA_ANY(string);\n\tpg_verify_mbstr_len(src_encoding, src_str, len, false);\n\n\t/* perform conversion */\n\tdest_str = (char *) pg_do_encoding_conversion((unsigned char *) src_str,\n\t\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t\t  src_encoding,\n\t\t\t\t\t\t\t\t\t\t\t\t  dest_encoding);\n\n\t/* update len if conversion actually happened */\n\tif (dest_str != src_str)\n\t\tlen = strlen(dest_str);\n\n\t/*\n\t * build bytea data type structure.\n\t */\n\tretval = (bytea *) palloc(len + VARHDRSZ);\n\tSET_VARSIZE(retval, len + VARHDRSZ);\n\tmemcpy(VARDATA(retval), dest_str, len);\n\n\tif (dest_str != src_str)\n\t\tpfree(dest_str);\n\n\t/* free memory if allocated by the toaster */\n\tPG_FREE_IF_COPY(string, 0);\n\n\tPG_RETURN_BYTEA_P(retval);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "retval"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "string",
            "0"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "dest_str"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "VARDATA(retval)",
            "dest_str",
            "len"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "retval"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "retval",
            "len + VARHDRSZ"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len + VARHDRSZ"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dest_str"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "773-788",
          "snippet": "int\npg_mbstrlen(const char *mbstr)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn strlen(mbstr);\n\n\twhile (*mbstr)\n\t{\n\t\tmbstr += pg_mblen(mbstr);\n\t\tlen++;\n\t}\n\treturn len;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nint\npg_mbstrlen(const char *mbstr)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn strlen(mbstr);\n\n\twhile (*mbstr)\n\t{\n\t\tmbstr += pg_mblen(mbstr);\n\t\tlen++;\n\t}\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_do_encoding_conversion",
          "args": [
            "(unsigned char *) src_str",
            "len",
            "src_encoding",
            "dest_encoding"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "pg_do_encoding_conversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "325-378",
          "snippet": "unsigned char *\npg_do_encoding_conversion(unsigned char *src, int len,\n\t\t\t\t\t\t  int src_encoding, int dest_encoding)\n{\n\tunsigned char *result;\n\tOid\t\t\tproc;\n\n\tif (len <= 0)\n\t\treturn src;\t\t\t\t/* empty string is always valid */\n\n\tif (src_encoding == dest_encoding)\n\t\treturn src;\t\t\t\t/* no conversion required, assume valid */\n\n\tif (dest_encoding == PG_SQL_ASCII)\n\t\treturn src;\t\t\t\t/* any string is valid in SQL_ASCII */\n\n\tif (src_encoding == PG_SQL_ASCII)\n\t{\n\t\t/* No conversion is possible, but we must validate the result */\n\t\t(void) pg_verify_mbstr(dest_encoding, (const char *) src, len, false);\n\t\treturn src;\n\t}\n\n\tif (!IsTransactionState())\t/* shouldn't happen */\n\t\telog(ERROR, \"cannot perform encoding conversion outside a transaction\");\n\n\tproc = FindDefaultConversionProc(src_encoding, dest_encoding);\n\tif (!OidIsValid(proc))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"default conversion function for encoding \\\"%s\\\" to \\\"%s\\\" does not exist\",\n\t\t\t\t\t\tpg_encoding_to_char(src_encoding),\n\t\t\t\t\t\tpg_encoding_to_char(dest_encoding))));\n\n\t/*\n\t * Allocate space for conversion result, being wary of integer overflow\n\t */\n\tif ((Size) len >= (MaxAllocSize / (Size) MAX_CONVERSION_GROWTH))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"String of %d bytes is too long for encoding conversion.\",\n\t\t\t\t\t\t   len)));\n\n\tresult = palloc(len * MAX_CONVERSION_GROWTH + 1);\n\n\tOidFunctionCall5(proc,\n\t\t\t\t\t Int32GetDatum(src_encoding),\n\t\t\t\t\t Int32GetDatum(dest_encoding),\n\t\t\t\t\t CStringGetDatum(src),\n\t\t\t\t\t CStringGetDatum(result),\n\t\t\t\t\t Int32GetDatum(len));\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nunsigned char *\npg_do_encoding_conversion(unsigned char *src, int len,\n\t\t\t\t\t\t  int src_encoding, int dest_encoding)\n{\n\tunsigned char *result;\n\tOid\t\t\tproc;\n\n\tif (len <= 0)\n\t\treturn src;\t\t\t\t/* empty string is always valid */\n\n\tif (src_encoding == dest_encoding)\n\t\treturn src;\t\t\t\t/* no conversion required, assume valid */\n\n\tif (dest_encoding == PG_SQL_ASCII)\n\t\treturn src;\t\t\t\t/* any string is valid in SQL_ASCII */\n\n\tif (src_encoding == PG_SQL_ASCII)\n\t{\n\t\t/* No conversion is possible, but we must validate the result */\n\t\t(void) pg_verify_mbstr(dest_encoding, (const char *) src, len, false);\n\t\treturn src;\n\t}\n\n\tif (!IsTransactionState())\t/* shouldn't happen */\n\t\telog(ERROR, \"cannot perform encoding conversion outside a transaction\");\n\n\tproc = FindDefaultConversionProc(src_encoding, dest_encoding);\n\tif (!OidIsValid(proc))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"default conversion function for encoding \\\"%s\\\" to \\\"%s\\\" does not exist\",\n\t\t\t\t\t\tpg_encoding_to_char(src_encoding),\n\t\t\t\t\t\tpg_encoding_to_char(dest_encoding))));\n\n\t/*\n\t * Allocate space for conversion result, being wary of integer overflow\n\t */\n\tif ((Size) len >= (MaxAllocSize / (Size) MAX_CONVERSION_GROWTH))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"String of %d bytes is too long for encoding conversion.\",\n\t\t\t\t\t\t   len)));\n\n\tresult = palloc(len * MAX_CONVERSION_GROWTH + 1);\n\n\tOidFunctionCall5(proc,\n\t\t\t\t\t Int32GetDatum(src_encoding),\n\t\t\t\t\t Int32GetDatum(dest_encoding),\n\t\t\t\t\t CStringGetDatum(src),\n\t\t\t\t\t CStringGetDatum(result),\n\t\t\t\t\t Int32GetDatum(len));\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_verify_mbstr_len",
          "args": [
            "src_encoding",
            "src_str",
            "len",
            "false"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "pg_verify_mbstr_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1893-1953",
          "snippet": "int\npg_verify_mbstr_len(int encoding, const char *mbstr, int len, bool noError)\n{\n\tmbverifier\tmbverify;\n\tint\t\t\tmb_len;\n\n\tAssert(PG_VALID_ENCODING(encoding));\n\n\t/*\n\t * In single-byte encodings, we need only reject nulls (\\0).\n\t */\n\tif (pg_encoding_max_length(encoding) <= 1)\n\t{\n\t\tconst char *nullpos = memchr(mbstr, 0, len);\n\n\t\tif (nullpos == NULL)\n\t\t\treturn len;\n\t\tif (noError)\n\t\t\treturn -1;\n\t\treport_invalid_encoding(encoding, nullpos, 1);\n\t}\n\n\t/* fetch function pointer just once */\n\tmbverify = pg_wchar_table[encoding].mbverify;\n\n\tmb_len = 0;\n\n\twhile (len > 0)\n\t{\n\t\tint\t\t\tl;\n\n\t\t/* fast path for ASCII-subset characters */\n\t\tif (!IS_HIGHBIT_SET(*mbstr))\n\t\t{\n\t\t\tif (*mbstr != '\\0')\n\t\t\t{\n\t\t\t\tmb_len++;\n\t\t\t\tmbstr++;\n\t\t\t\tlen--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (noError)\n\t\t\t\treturn -1;\n\t\t\treport_invalid_encoding(encoding, mbstr, len);\n\t\t}\n\n\t\tl = (*mbverify) ((const unsigned char *) mbstr, len);\n\n\t\tif (l < 0)\n\t\t{\n\t\t\tif (noError)\n\t\t\t\treturn -1;\n\t\t\treport_invalid_encoding(encoding, mbstr, len);\n\t\t}\n\n\t\tmbstr += l;\n\t\tlen -= l;\n\t\tmb_len++;\n\t}\n\treturn mb_len;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_verify_mbstr_len(int encoding, const char *mbstr, int len, bool noError)\n{\n\tmbverifier\tmbverify;\n\tint\t\t\tmb_len;\n\n\tAssert(PG_VALID_ENCODING(encoding));\n\n\t/*\n\t * In single-byte encodings, we need only reject nulls (\\0).\n\t */\n\tif (pg_encoding_max_length(encoding) <= 1)\n\t{\n\t\tconst char *nullpos = memchr(mbstr, 0, len);\n\n\t\tif (nullpos == NULL)\n\t\t\treturn len;\n\t\tif (noError)\n\t\t\treturn -1;\n\t\treport_invalid_encoding(encoding, nullpos, 1);\n\t}\n\n\t/* fetch function pointer just once */\n\tmbverify = pg_wchar_table[encoding].mbverify;\n\n\tmb_len = 0;\n\n\twhile (len > 0)\n\t{\n\t\tint\t\t\tl;\n\n\t\t/* fast path for ASCII-subset characters */\n\t\tif (!IS_HIGHBIT_SET(*mbstr))\n\t\t{\n\t\t\tif (*mbstr != '\\0')\n\t\t\t{\n\t\t\t\tmb_len++;\n\t\t\t\tmbstr++;\n\t\t\t\tlen--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (noError)\n\t\t\t\treturn -1;\n\t\t\treport_invalid_encoding(encoding, mbstr, len);\n\t\t}\n\n\t\tl = (*mbverify) ((const unsigned char *) mbstr, len);\n\n\t\tif (l < 0)\n\t\t{\n\t\t\tif (noError)\n\t\t\t\treturn -1;\n\t\t\treport_invalid_encoding(encoding, mbstr, len);\n\t\t}\n\n\t\tmbstr += l;\n\t\tlen -= l;\n\t\tmb_len++;\n\t}\n\treturn mb_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "string"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "string"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid destination encoding name \\\"%s\\\"\",\n\t\t\t\t\t\tdest_encoding_name))"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid destination encoding name \\\"%s\\\"\"",
            "dest_encoding_name"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid source encoding name \\\"%s\\\"\",\n\t\t\t\t\t\tsrc_encoding_name))"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_char_to_encoding",
          "args": [
            "dest_encoding_name"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "pg_char_to_encoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/encnames.c",
          "lines": "550-594",
          "snippet": "int\npg_char_to_encoding(const char *name)\n{\n\tunsigned int nel = lengthof(pg_encname_tbl);\n\tconst pg_encname *base = pg_encname_tbl,\n\t\t\t   *last = base + nel - 1,\n\t\t\t   *position;\n\tint\t\t\tresult;\n\tchar\t\tbuff[NAMEDATALEN],\n\t\t\t   *key;\n\n\tif (name == NULL || *name == '\\0')\n\t\treturn -1;\n\n\tif (strlen(name) >= NAMEDATALEN)\n\t{\n#ifdef FRONTEND\n\t\tfprintf(stderr, \"encoding name too long\\n\");\n\t\treturn -1;\n#else\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NAME_TOO_LONG),\n\t\t\t\t errmsg(\"encoding name too long\")));\n#endif\n\t}\n\tkey = clean_encoding_name(name, buff);\n\n\twhile (last >= base)\n\t{\n\t\tposition = base + ((last - base) >> 1);\n\t\tresult = key[0] - position->name[0];\n\n\t\tif (result == 0)\n\t\t{\n\t\t\tresult = strcmp(key, position->name);\n\t\t\tif (result == 0)\n\t\t\t\treturn position->encoding;\n\t\t}\n\t\tif (result < 0)\n\t\t\tlast = position - 1;\n\t\telse\n\t\t\tbase = position + 1;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"utils/builtins.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_encname pg_encname_tbl[] =\n{\n\t{\n\t\t\"abc\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"alt\", PG_WIN866\n\t},\t\t\t\t\t\t\t/* IBM866 */\n\t{\n\t\t\"big5\", PG_BIG5\n\t},\t\t\t\t\t\t\t/* Big5; Chinese for Taiwan multibyte set */\n\t{\n\t\t\"euccn\", PG_EUC_CN\n\t},\t\t\t\t\t\t\t/* EUC-CN; Extended Unix Code for simplified\n\t\t\t\t\t\t\t\t * Chinese */\n\t{\n\t\t\"eucjis2004\", PG_EUC_JIS_2004\n\t},\t\t\t\t\t\t\t/* EUC-JIS-2004; Extended UNIX Code fixed\n\t\t\t\t\t\t\t\t * Width for Japanese, standard JIS X 0213 */\n\t{\n\t\t\"eucjp\", PG_EUC_JP\n\t},\t\t\t\t\t\t\t/* EUC-JP; Extended UNIX Code fixed Width for\n\t\t\t\t\t\t\t\t * Japanese, standard OSF */\n\t{\n\t\t\"euckr\", PG_EUC_KR\n\t},\t\t\t\t\t\t\t/* EUC-KR; Extended Unix Code for Korean , KS\n\t\t\t\t\t\t\t\t * X 1001 standard */\n\t{\n\t\t\"euctw\", PG_EUC_TW\n\t},\t\t\t\t\t\t\t/* EUC-TW; Extended Unix Code for\n\t\t\t\t\t\t\t\t *\n\t\t\t\t\t\t\t\t * traditional Chinese */\n\t{\n\t\t\"gb18030\", PG_GB18030\n\t},\t\t\t\t\t\t\t/* GB18030;GB18030 */\n\t{\n\t\t\"gbk\", PG_GBK\n\t},\t\t\t\t\t\t\t/* GBK; Chinese Windows CodePage 936\n\t\t\t\t\t\t\t\t * simplified Chinese */\n\t{\n\t\t\"iso88591\", PG_LATIN1\n\t},\t\t\t\t\t\t\t/* ISO-8859-1; RFC1345,KXS2 */\n\t{\n\t\t\"iso885910\", PG_LATIN6\n\t},\t\t\t\t\t\t\t/* ISO-8859-10; RFC1345,KXS2 */\n\t{\n\t\t\"iso885913\", PG_LATIN7\n\t},\t\t\t\t\t\t\t/* ISO-8859-13; RFC1345,KXS2 */\n\t{\n\t\t\"iso885914\", PG_LATIN8\n\t},\t\t\t\t\t\t\t/* ISO-8859-14; RFC1345,KXS2 */\n\t{\n\t\t\"iso885915\", PG_LATIN9\n\t},\t\t\t\t\t\t\t/* ISO-8859-15; RFC1345,KXS2 */\n\t{\n\t\t\"iso885916\", PG_LATIN10\n\t},\t\t\t\t\t\t\t/* ISO-8859-16; RFC1345,KXS2 */\n\t{\n\t\t\"iso88592\", PG_LATIN2\n\t},\t\t\t\t\t\t\t/* ISO-8859-2; RFC1345,KXS2 */\n\t{\n\t\t\"iso88593\", PG_LATIN3\n\t},\t\t\t\t\t\t\t/* ISO-8859-3; RFC1345,KXS2 */\n\t{\n\t\t\"iso88594\", PG_LATIN4\n\t},\t\t\t\t\t\t\t/* ISO-8859-4; RFC1345,KXS2 */\n\t{\n\t\t\"iso88595\", PG_ISO_8859_5\n\t},\t\t\t\t\t\t\t/* ISO-8859-5; RFC1345,KXS2 */\n\t{\n\t\t\"iso88596\", PG_ISO_8859_6\n\t},\t\t\t\t\t\t\t/* ISO-8859-6; RFC1345,KXS2 */\n\t{\n\t\t\"iso88597\", PG_ISO_8859_7\n\t},\t\t\t\t\t\t\t/* ISO-8859-7; RFC1345,KXS2 */\n\t{\n\t\t\"iso88598\", PG_ISO_8859_8\n\t},\t\t\t\t\t\t\t/* ISO-8859-8; RFC1345,KXS2 */\n\t{\n\t\t\"iso88599\", PG_LATIN5\n\t},\t\t\t\t\t\t\t/* ISO-8859-9; RFC1345,KXS2 */\n\t{\n\t\t\"johab\", PG_JOHAB\n\t},\t\t\t\t\t\t\t/* JOHAB; Extended Unix Code for simplified\n\t\t\t\t\t\t\t\t * Chinese */\n\t{\n\t\t\"koi8\", PG_KOI8R\n\t},\t\t\t\t\t\t\t/* _dirty_ alias for KOI8-R (backward\n\t\t\t\t\t\t\t\t * compatibility) */\n\t{\n\t\t\"koi8r\", PG_KOI8R\n\t},\t\t\t\t\t\t\t/* KOI8-R; RFC1489 */\n\t{\n\t\t\"koi8u\", PG_KOI8U\n\t},\t\t\t\t\t\t\t/* KOI8-U; RFC2319 */\n\t{\n\t\t\"latin1\", PG_LATIN1\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-1 */\n\t{\n\t\t\"latin10\", PG_LATIN10\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-16 */\n\t{\n\t\t\"latin2\", PG_LATIN2\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-2 */\n\t{\n\t\t\"latin3\", PG_LATIN3\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-3 */\n\t{\n\t\t\"latin4\", PG_LATIN4\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-4 */\n\t{\n\t\t\"latin5\", PG_LATIN5\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-9 */\n\t{\n\t\t\"latin6\", PG_LATIN6\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-10 */\n\t{\n\t\t\"latin7\", PG_LATIN7\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-13 */\n\t{\n\t\t\"latin8\", PG_LATIN8\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-14 */\n\t{\n\t\t\"latin9\", PG_LATIN9\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-15 */\n\t{\n\t\t\"mskanji\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"muleinternal\", PG_MULE_INTERNAL\n\t},\n\t{\n\t\t\"shiftjis\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* Shift_JIS; JIS X 0202-1991 */\n\n\t{\n\t\t\"shiftjis2004\", PG_SHIFT_JIS_2004\n\t},\t\t\t\t\t\t\t/* SHIFT-JIS-2004; Shift JIS for Japanese,\n\t\t\t\t\t\t\t\t * standard JIS X 0213 */\n\t{\n\t\t\"sjis\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"sqlascii\", PG_SQL_ASCII\n\t},\n\t{\n\t\t\"tcvn\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"tcvn5712\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"uhc\", PG_UHC\n\t},\t\t\t\t\t\t\t/* UHC; Korean Windows CodePage 949 */\n\t{\n\t\t\"unicode\", PG_UTF8\n\t},\t\t\t\t\t\t\t/* alias for UTF8 */\n\t{\n\t\t\"utf8\", PG_UTF8\n\t},\t\t\t\t\t\t\t/* alias for UTF8 */\n\t{\n\t\t\"vscii\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"win\", PG_WIN1251\n\t},\t\t\t\t\t\t\t/* _dirty_ alias for windows-1251 (backward\n\t\t\t\t\t\t\t\t * compatibility) */\n\t{\n\t\t\"win1250\", PG_WIN1250\n\t},\t\t\t\t\t\t\t/* alias for Windows-1250 */\n\t{\n\t\t\"win1251\", PG_WIN1251\n\t},\t\t\t\t\t\t\t/* alias for Windows-1251 */\n\t{\n\t\t\"win1252\", PG_WIN1252\n\t},\t\t\t\t\t\t\t/* alias for Windows-1252 */\n\t{\n\t\t\"win1253\", PG_WIN1253\n\t},\t\t\t\t\t\t\t/* alias for Windows-1253 */\n\t{\n\t\t\"win1254\", PG_WIN1254\n\t},\t\t\t\t\t\t\t/* alias for Windows-1254 */\n\t{\n\t\t\"win1255\", PG_WIN1255\n\t},\t\t\t\t\t\t\t/* alias for Windows-1255 */\n\t{\n\t\t\"win1256\", PG_WIN1256\n\t},\t\t\t\t\t\t\t/* alias for Windows-1256 */\n\t{\n\t\t\"win1257\", PG_WIN1257\n\t},\t\t\t\t\t\t\t/* alias for Windows-1257 */\n\t{\n\t\t\"win1258\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for Windows-1258 */\n\t{\n\t\t\"win866\", PG_WIN866\n\t},\t\t\t\t\t\t\t/* IBM866 */\n\t{\n\t\t\"win874\", PG_WIN874\n\t},\t\t\t\t\t\t\t/* alias for Windows-874 */\n\t{\n\t\t\"win932\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"win936\", PG_GBK\n\t},\t\t\t\t\t\t\t/* alias for GBK */\n\t{\n\t\t\"win949\", PG_UHC\n\t},\t\t\t\t\t\t\t/* alias for UHC */\n\t{\n\t\t\"win950\", PG_BIG5\n\t},\t\t\t\t\t\t\t/* alias for BIG5 */\n\t{\n\t\t\"windows1250\", PG_WIN1250\n\t},\t\t\t\t\t\t\t/* Windows-1251; Microsoft */\n\t{\n\t\t\"windows1251\", PG_WIN1251\n\t},\t\t\t\t\t\t\t/* Windows-1251; Microsoft */\n\t{\n\t\t\"windows1252\", PG_WIN1252\n\t},\t\t\t\t\t\t\t/* Windows-1252; Microsoft */\n\t{\n\t\t\"windows1253\", PG_WIN1253\n\t},\t\t\t\t\t\t\t/* Windows-1253; Microsoft */\n\t{\n\t\t\"windows1254\", PG_WIN1254\n\t},\t\t\t\t\t\t\t/* Windows-1254; Microsoft */\n\t{\n\t\t\"windows1255\", PG_WIN1255\n\t},\t\t\t\t\t\t\t/* Windows-1255; Microsoft */\n\t{\n\t\t\"windows1256\", PG_WIN1256\n\t},\t\t\t\t\t\t\t/* Windows-1256; Microsoft */\n\t{\n\t\t\"windows1257\", PG_WIN1257\n\t},\t\t\t\t\t\t\t/* Windows-1257; Microsoft */\n\t{\n\t\t\"windows1258\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* Windows-1258; Microsoft */\n\t{\n\t\t\"windows866\", PG_WIN866\n\t},\t\t\t\t\t\t\t/* IBM866 */\n\t{\n\t\t\"windows874\", PG_WIN874\n\t},\t\t\t\t\t\t\t/* Windows-874; Microsoft */\n\t{\n\t\t\"windows932\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"windows936\", PG_GBK\n\t},\t\t\t\t\t\t\t/* alias for GBK */\n\t{\n\t\t\"windows949\", PG_UHC\n\t},\t\t\t\t\t\t\t/* alias for UHC */\n\t{\n\t\t\"windows950\", PG_BIG5\n\t}\t\t\t\t\t\t\t/* alias for BIG5 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include <unistd.h>\n#include <ctype.h>\n#include \"utils/builtins.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nstatic const pg_encname pg_encname_tbl[] =\n{\n\t{\n\t\t\"abc\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"alt\", PG_WIN866\n\t},\t\t\t\t\t\t\t/* IBM866 */\n\t{\n\t\t\"big5\", PG_BIG5\n\t},\t\t\t\t\t\t\t/* Big5; Chinese for Taiwan multibyte set */\n\t{\n\t\t\"euccn\", PG_EUC_CN\n\t},\t\t\t\t\t\t\t/* EUC-CN; Extended Unix Code for simplified\n\t\t\t\t\t\t\t\t * Chinese */\n\t{\n\t\t\"eucjis2004\", PG_EUC_JIS_2004\n\t},\t\t\t\t\t\t\t/* EUC-JIS-2004; Extended UNIX Code fixed\n\t\t\t\t\t\t\t\t * Width for Japanese, standard JIS X 0213 */\n\t{\n\t\t\"eucjp\", PG_EUC_JP\n\t},\t\t\t\t\t\t\t/* EUC-JP; Extended UNIX Code fixed Width for\n\t\t\t\t\t\t\t\t * Japanese, standard OSF */\n\t{\n\t\t\"euckr\", PG_EUC_KR\n\t},\t\t\t\t\t\t\t/* EUC-KR; Extended Unix Code for Korean , KS\n\t\t\t\t\t\t\t\t * X 1001 standard */\n\t{\n\t\t\"euctw\", PG_EUC_TW\n\t},\t\t\t\t\t\t\t/* EUC-TW; Extended Unix Code for\n\t\t\t\t\t\t\t\t *\n\t\t\t\t\t\t\t\t * traditional Chinese */\n\t{\n\t\t\"gb18030\", PG_GB18030\n\t},\t\t\t\t\t\t\t/* GB18030;GB18030 */\n\t{\n\t\t\"gbk\", PG_GBK\n\t},\t\t\t\t\t\t\t/* GBK; Chinese Windows CodePage 936\n\t\t\t\t\t\t\t\t * simplified Chinese */\n\t{\n\t\t\"iso88591\", PG_LATIN1\n\t},\t\t\t\t\t\t\t/* ISO-8859-1; RFC1345,KXS2 */\n\t{\n\t\t\"iso885910\", PG_LATIN6\n\t},\t\t\t\t\t\t\t/* ISO-8859-10; RFC1345,KXS2 */\n\t{\n\t\t\"iso885913\", PG_LATIN7\n\t},\t\t\t\t\t\t\t/* ISO-8859-13; RFC1345,KXS2 */\n\t{\n\t\t\"iso885914\", PG_LATIN8\n\t},\t\t\t\t\t\t\t/* ISO-8859-14; RFC1345,KXS2 */\n\t{\n\t\t\"iso885915\", PG_LATIN9\n\t},\t\t\t\t\t\t\t/* ISO-8859-15; RFC1345,KXS2 */\n\t{\n\t\t\"iso885916\", PG_LATIN10\n\t},\t\t\t\t\t\t\t/* ISO-8859-16; RFC1345,KXS2 */\n\t{\n\t\t\"iso88592\", PG_LATIN2\n\t},\t\t\t\t\t\t\t/* ISO-8859-2; RFC1345,KXS2 */\n\t{\n\t\t\"iso88593\", PG_LATIN3\n\t},\t\t\t\t\t\t\t/* ISO-8859-3; RFC1345,KXS2 */\n\t{\n\t\t\"iso88594\", PG_LATIN4\n\t},\t\t\t\t\t\t\t/* ISO-8859-4; RFC1345,KXS2 */\n\t{\n\t\t\"iso88595\", PG_ISO_8859_5\n\t},\t\t\t\t\t\t\t/* ISO-8859-5; RFC1345,KXS2 */\n\t{\n\t\t\"iso88596\", PG_ISO_8859_6\n\t},\t\t\t\t\t\t\t/* ISO-8859-6; RFC1345,KXS2 */\n\t{\n\t\t\"iso88597\", PG_ISO_8859_7\n\t},\t\t\t\t\t\t\t/* ISO-8859-7; RFC1345,KXS2 */\n\t{\n\t\t\"iso88598\", PG_ISO_8859_8\n\t},\t\t\t\t\t\t\t/* ISO-8859-8; RFC1345,KXS2 */\n\t{\n\t\t\"iso88599\", PG_LATIN5\n\t},\t\t\t\t\t\t\t/* ISO-8859-9; RFC1345,KXS2 */\n\t{\n\t\t\"johab\", PG_JOHAB\n\t},\t\t\t\t\t\t\t/* JOHAB; Extended Unix Code for simplified\n\t\t\t\t\t\t\t\t * Chinese */\n\t{\n\t\t\"koi8\", PG_KOI8R\n\t},\t\t\t\t\t\t\t/* _dirty_ alias for KOI8-R (backward\n\t\t\t\t\t\t\t\t * compatibility) */\n\t{\n\t\t\"koi8r\", PG_KOI8R\n\t},\t\t\t\t\t\t\t/* KOI8-R; RFC1489 */\n\t{\n\t\t\"koi8u\", PG_KOI8U\n\t},\t\t\t\t\t\t\t/* KOI8-U; RFC2319 */\n\t{\n\t\t\"latin1\", PG_LATIN1\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-1 */\n\t{\n\t\t\"latin10\", PG_LATIN10\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-16 */\n\t{\n\t\t\"latin2\", PG_LATIN2\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-2 */\n\t{\n\t\t\"latin3\", PG_LATIN3\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-3 */\n\t{\n\t\t\"latin4\", PG_LATIN4\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-4 */\n\t{\n\t\t\"latin5\", PG_LATIN5\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-9 */\n\t{\n\t\t\"latin6\", PG_LATIN6\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-10 */\n\t{\n\t\t\"latin7\", PG_LATIN7\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-13 */\n\t{\n\t\t\"latin8\", PG_LATIN8\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-14 */\n\t{\n\t\t\"latin9\", PG_LATIN9\n\t},\t\t\t\t\t\t\t/* alias for ISO-8859-15 */\n\t{\n\t\t\"mskanji\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"muleinternal\", PG_MULE_INTERNAL\n\t},\n\t{\n\t\t\"shiftjis\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* Shift_JIS; JIS X 0202-1991 */\n\n\t{\n\t\t\"shiftjis2004\", PG_SHIFT_JIS_2004\n\t},\t\t\t\t\t\t\t/* SHIFT-JIS-2004; Shift JIS for Japanese,\n\t\t\t\t\t\t\t\t * standard JIS X 0213 */\n\t{\n\t\t\"sjis\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"sqlascii\", PG_SQL_ASCII\n\t},\n\t{\n\t\t\"tcvn\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"tcvn5712\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"uhc\", PG_UHC\n\t},\t\t\t\t\t\t\t/* UHC; Korean Windows CodePage 949 */\n\t{\n\t\t\"unicode\", PG_UTF8\n\t},\t\t\t\t\t\t\t/* alias for UTF8 */\n\t{\n\t\t\"utf8\", PG_UTF8\n\t},\t\t\t\t\t\t\t/* alias for UTF8 */\n\t{\n\t\t\"vscii\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for WIN1258 */\n\t{\n\t\t\"win\", PG_WIN1251\n\t},\t\t\t\t\t\t\t/* _dirty_ alias for windows-1251 (backward\n\t\t\t\t\t\t\t\t * compatibility) */\n\t{\n\t\t\"win1250\", PG_WIN1250\n\t},\t\t\t\t\t\t\t/* alias for Windows-1250 */\n\t{\n\t\t\"win1251\", PG_WIN1251\n\t},\t\t\t\t\t\t\t/* alias for Windows-1251 */\n\t{\n\t\t\"win1252\", PG_WIN1252\n\t},\t\t\t\t\t\t\t/* alias for Windows-1252 */\n\t{\n\t\t\"win1253\", PG_WIN1253\n\t},\t\t\t\t\t\t\t/* alias for Windows-1253 */\n\t{\n\t\t\"win1254\", PG_WIN1254\n\t},\t\t\t\t\t\t\t/* alias for Windows-1254 */\n\t{\n\t\t\"win1255\", PG_WIN1255\n\t},\t\t\t\t\t\t\t/* alias for Windows-1255 */\n\t{\n\t\t\"win1256\", PG_WIN1256\n\t},\t\t\t\t\t\t\t/* alias for Windows-1256 */\n\t{\n\t\t\"win1257\", PG_WIN1257\n\t},\t\t\t\t\t\t\t/* alias for Windows-1257 */\n\t{\n\t\t\"win1258\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* alias for Windows-1258 */\n\t{\n\t\t\"win866\", PG_WIN866\n\t},\t\t\t\t\t\t\t/* IBM866 */\n\t{\n\t\t\"win874\", PG_WIN874\n\t},\t\t\t\t\t\t\t/* alias for Windows-874 */\n\t{\n\t\t\"win932\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"win936\", PG_GBK\n\t},\t\t\t\t\t\t\t/* alias for GBK */\n\t{\n\t\t\"win949\", PG_UHC\n\t},\t\t\t\t\t\t\t/* alias for UHC */\n\t{\n\t\t\"win950\", PG_BIG5\n\t},\t\t\t\t\t\t\t/* alias for BIG5 */\n\t{\n\t\t\"windows1250\", PG_WIN1250\n\t},\t\t\t\t\t\t\t/* Windows-1251; Microsoft */\n\t{\n\t\t\"windows1251\", PG_WIN1251\n\t},\t\t\t\t\t\t\t/* Windows-1251; Microsoft */\n\t{\n\t\t\"windows1252\", PG_WIN1252\n\t},\t\t\t\t\t\t\t/* Windows-1252; Microsoft */\n\t{\n\t\t\"windows1253\", PG_WIN1253\n\t},\t\t\t\t\t\t\t/* Windows-1253; Microsoft */\n\t{\n\t\t\"windows1254\", PG_WIN1254\n\t},\t\t\t\t\t\t\t/* Windows-1254; Microsoft */\n\t{\n\t\t\"windows1255\", PG_WIN1255\n\t},\t\t\t\t\t\t\t/* Windows-1255; Microsoft */\n\t{\n\t\t\"windows1256\", PG_WIN1256\n\t},\t\t\t\t\t\t\t/* Windows-1256; Microsoft */\n\t{\n\t\t\"windows1257\", PG_WIN1257\n\t},\t\t\t\t\t\t\t/* Windows-1257; Microsoft */\n\t{\n\t\t\"windows1258\", PG_WIN1258\n\t},\t\t\t\t\t\t\t/* Windows-1258; Microsoft */\n\t{\n\t\t\"windows866\", PG_WIN866\n\t},\t\t\t\t\t\t\t/* IBM866 */\n\t{\n\t\t\"windows874\", PG_WIN874\n\t},\t\t\t\t\t\t\t/* Windows-874; Microsoft */\n\t{\n\t\t\"windows932\", PG_SJIS\n\t},\t\t\t\t\t\t\t/* alias for Shift_JIS */\n\t{\n\t\t\"windows936\", PG_GBK\n\t},\t\t\t\t\t\t\t/* alias for GBK */\n\t{\n\t\t\"windows949\", PG_UHC\n\t},\t\t\t\t\t\t\t/* alias for UHC */\n\t{\n\t\t\"windows950\", PG_BIG5\n\t}\t\t\t\t\t\t\t/* alias for BIG5 */\n};\n\nint\npg_char_to_encoding(const char *name)\n{\n\tunsigned int nel = lengthof(pg_encname_tbl);\n\tconst pg_encname *base = pg_encname_tbl,\n\t\t\t   *last = base + nel - 1,\n\t\t\t   *position;\n\tint\t\t\tresult;\n\tchar\t\tbuff[NAMEDATALEN],\n\t\t\t   *key;\n\n\tif (name == NULL || *name == '\\0')\n\t\treturn -1;\n\n\tif (strlen(name) >= NAMEDATALEN)\n\t{\n#ifdef FRONTEND\n\t\tfprintf(stderr, \"encoding name too long\\n\");\n\t\treturn -1;\n#else\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_NAME_TOO_LONG),\n\t\t\t\t errmsg(\"encoding name too long\")));\n#endif\n\t}\n\tkey = clean_encoding_name(name, buff);\n\n\twhile (last >= base)\n\t{\n\t\tposition = base + ((last - base) >> 1);\n\t\tresult = key[0] - position->name[0];\n\n\t\tif (result == 0)\n\t\t{\n\t\t\tresult = strcmp(key, position->name);\n\t\t\tif (result == 0)\n\t\t\t\treturn position->encoding;\n\t\t}\n\t\tif (result < 0)\n\t\t\tlast = position - 1;\n\t\telse\n\t\t\tbase = position + 1;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*PG_GETARG_NAME(2)"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_NAME",
          "args": [
            "2"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "*PG_GETARG_NAME(1)"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_NAME",
          "args": [
            "1"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "0"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nDatum\npg_convert(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *string = PG_GETARG_BYTEA_PP(0);\n\tchar\t   *src_encoding_name = NameStr(*PG_GETARG_NAME(1));\n\tint\t\t\tsrc_encoding = pg_char_to_encoding(src_encoding_name);\n\tchar\t   *dest_encoding_name = NameStr(*PG_GETARG_NAME(2));\n\tint\t\t\tdest_encoding = pg_char_to_encoding(dest_encoding_name);\n\tconst char *src_str;\n\tchar\t   *dest_str;\n\tbytea\t   *retval;\n\tint\t\t\tlen;\n\n\tif (src_encoding < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid source encoding name \\\"%s\\\"\",\n\t\t\t\t\t\tsrc_encoding_name)));\n\tif (dest_encoding < 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"invalid destination encoding name \\\"%s\\\"\",\n\t\t\t\t\t\tdest_encoding_name)));\n\n\t/* make sure that source string is valid */\n\tlen = VARSIZE_ANY_EXHDR(string);\n\tsrc_str = VARDATA_ANY(string);\n\tpg_verify_mbstr_len(src_encoding, src_str, len, false);\n\n\t/* perform conversion */\n\tdest_str = (char *) pg_do_encoding_conversion((unsigned char *) src_str,\n\t\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t\t  src_encoding,\n\t\t\t\t\t\t\t\t\t\t\t\t  dest_encoding);\n\n\t/* update len if conversion actually happened */\n\tif (dest_str != src_str)\n\t\tlen = strlen(dest_str);\n\n\t/*\n\t * build bytea data type structure.\n\t */\n\tretval = (bytea *) palloc(len + VARHDRSZ);\n\tSET_VARSIZE(retval, len + VARHDRSZ);\n\tmemcpy(VARDATA(retval), dest_str, len);\n\n\tif (dest_str != src_str)\n\t\tpfree(dest_str);\n\n\t/* free memory if allocated by the toaster */\n\tPG_FREE_IF_COPY(string, 0);\n\n\tPG_RETURN_BYTEA_P(retval);\n}"
  },
  {
    "function_name": "pg_convert_from",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "410-430",
    "snippet": "Datum\npg_convert_from(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tstring = PG_GETARG_DATUM(0);\n\tDatum\t\tsrc_encoding_name = PG_GETARG_DATUM(1);\n\tDatum\t\tdest_encoding_name = DirectFunctionCall1(namein,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t CStringGetDatum(DatabaseEncoding->name));\n\tDatum\t\tresult;\n\n\tresult = DirectFunctionCall3(pg_convert, string,\n\t\t\t\t\t\t\t\t src_encoding_name, dest_encoding_name);\n\n\t/*\n\t * pg_convert returns a bytea, which we in turn return as text, relying on\n\t * the fact that they are both in fact varlena types, and thus\n\t * structurally identical. Although not all bytea values are valid text,\n\t * in this case it will be because we've told pg_convert to return one\n\t * that is valid as text in the current database encoding.\n\t */\n\tPG_RETURN_DATUM(result);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "result"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall3",
          "args": [
            "pg_convert",
            "string",
            "src_encoding_name",
            "dest_encoding_name"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "namein",
            "CStringGetDatum(DatabaseEncoding->name)"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "DatabaseEncoding->name"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nDatum\npg_convert_from(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tstring = PG_GETARG_DATUM(0);\n\tDatum\t\tsrc_encoding_name = PG_GETARG_DATUM(1);\n\tDatum\t\tdest_encoding_name = DirectFunctionCall1(namein,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t CStringGetDatum(DatabaseEncoding->name));\n\tDatum\t\tresult;\n\n\tresult = DirectFunctionCall3(pg_convert, string,\n\t\t\t\t\t\t\t\t src_encoding_name, dest_encoding_name);\n\n\t/*\n\t * pg_convert returns a bytea, which we in turn return as text, relying on\n\t * the fact that they are both in fact varlena types, and thus\n\t * structurally identical. Although not all bytea values are valid text,\n\t * in this case it will be because we've told pg_convert to return one\n\t * that is valid as text in the current database encoding.\n\t */\n\tPG_RETURN_DATUM(result);\n}"
  },
  {
    "function_name": "pg_convert_to",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "385-403",
    "snippet": "Datum\npg_convert_to(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tstring = PG_GETARG_DATUM(0);\n\tDatum\t\tdest_encoding_name = PG_GETARG_DATUM(1);\n\tDatum\t\tsrc_encoding_name = DirectFunctionCall1(namein,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tCStringGetDatum(DatabaseEncoding->name));\n\tDatum\t\tresult;\n\n\t/*\n\t * pg_convert expects a bytea as its first argument. We're passing it a\n\t * text argument here, relying on the fact that they are both in fact\n\t * varlena types, and thus structurally identical.\n\t */\n\tresult = DirectFunctionCall3(pg_convert, string,\n\t\t\t\t\t\t\t\t src_encoding_name, dest_encoding_name);\n\n\tPG_RETURN_DATUM(result);\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "result"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall3",
          "args": [
            "pg_convert",
            "string",
            "src_encoding_name",
            "dest_encoding_name"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "namein",
            "CStringGetDatum(DatabaseEncoding->name)"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "DatabaseEncoding->name"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nDatum\npg_convert_to(PG_FUNCTION_ARGS)\n{\n\tDatum\t\tstring = PG_GETARG_DATUM(0);\n\tDatum\t\tdest_encoding_name = PG_GETARG_DATUM(1);\n\tDatum\t\tsrc_encoding_name = DirectFunctionCall1(namein,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tCStringGetDatum(DatabaseEncoding->name));\n\tDatum\t\tresult;\n\n\t/*\n\t * pg_convert expects a bytea as its first argument. We're passing it a\n\t * text argument here, relying on the fact that they are both in fact\n\t * varlena types, and thus structurally identical.\n\t */\n\tresult = DirectFunctionCall3(pg_convert, string,\n\t\t\t\t\t\t\t\t src_encoding_name, dest_encoding_name);\n\n\tPG_RETURN_DATUM(result);\n}"
  },
  {
    "function_name": "pg_do_encoding_conversion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "325-378",
    "snippet": "unsigned char *\npg_do_encoding_conversion(unsigned char *src, int len,\n\t\t\t\t\t\t  int src_encoding, int dest_encoding)\n{\n\tunsigned char *result;\n\tOid\t\t\tproc;\n\n\tif (len <= 0)\n\t\treturn src;\t\t\t\t/* empty string is always valid */\n\n\tif (src_encoding == dest_encoding)\n\t\treturn src;\t\t\t\t/* no conversion required, assume valid */\n\n\tif (dest_encoding == PG_SQL_ASCII)\n\t\treturn src;\t\t\t\t/* any string is valid in SQL_ASCII */\n\n\tif (src_encoding == PG_SQL_ASCII)\n\t{\n\t\t/* No conversion is possible, but we must validate the result */\n\t\t(void) pg_verify_mbstr(dest_encoding, (const char *) src, len, false);\n\t\treturn src;\n\t}\n\n\tif (!IsTransactionState())\t/* shouldn't happen */\n\t\telog(ERROR, \"cannot perform encoding conversion outside a transaction\");\n\n\tproc = FindDefaultConversionProc(src_encoding, dest_encoding);\n\tif (!OidIsValid(proc))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"default conversion function for encoding \\\"%s\\\" to \\\"%s\\\" does not exist\",\n\t\t\t\t\t\tpg_encoding_to_char(src_encoding),\n\t\t\t\t\t\tpg_encoding_to_char(dest_encoding))));\n\n\t/*\n\t * Allocate space for conversion result, being wary of integer overflow\n\t */\n\tif ((Size) len >= (MaxAllocSize / (Size) MAX_CONVERSION_GROWTH))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"String of %d bytes is too long for encoding conversion.\",\n\t\t\t\t\t\t   len)));\n\n\tresult = palloc(len * MAX_CONVERSION_GROWTH + 1);\n\n\tOidFunctionCall5(proc,\n\t\t\t\t\t Int32GetDatum(src_encoding),\n\t\t\t\t\t Int32GetDatum(dest_encoding),\n\t\t\t\t\t CStringGetDatum(src),\n\t\t\t\t\t CStringGetDatum(result),\n\t\t\t\t\t Int32GetDatum(len));\n\treturn result;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OidFunctionCall5",
          "args": [
            "proc",
            "Int32GetDatum(src_encoding)",
            "Int32GetDatum(dest_encoding)",
            "CStringGetDatum(src)",
            "CStringGetDatum(result)",
            "Int32GetDatum(len)"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "len"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "result"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "src"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "dest_encoding"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int32GetDatum",
          "args": [
            "src_encoding"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "len * MAX_CONVERSION_GROWTH + 1"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"String of %d bytes is too long for encoding conversion.\",\n\t\t\t\t\t\t   len))"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errdetail",
          "args": [
            "\"String of %d bytes is too long for encoding conversion.\"",
            "len"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "errdetail_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "918-933",
          "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"out of memory\""
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"default conversion function for encoding \\\"%s\\\" to \\\"%s\\\" does not exist\",\n\t\t\t\t\t\tpg_encoding_to_char(src_encoding),\n\t\t\t\t\t\tpg_encoding_to_char(dest_encoding)))"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_encoding_to_char",
          "args": [
            "dest_encoding"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "pg_encoding_to_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/encnames.c",
          "lines": "606-617",
          "snippet": "const char *\npg_encoding_to_char(int encoding)\n{\n\tif (PG_VALID_ENCODING(encoding))\n\t{\n\t\tconst pg_enc2name *p = &pg_enc2name_tbl[encoding];\n\n\t\tAssert(encoding == p->encoding);\n\t\treturn p->name;\n\t}\n\treturn \"\";\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"utils/builtins.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_enc2name pg_enc2name_tbl[] =\n{\n\tDEF_ENC2NAME(SQL_ASCII, 0),\n\tDEF_ENC2NAME(EUC_JP, 20932),\n\tDEF_ENC2NAME(EUC_CN, 20936),\n\tDEF_ENC2NAME(EUC_KR, 51949),\n\tDEF_ENC2NAME(EUC_TW, 0),\n\tDEF_ENC2NAME(EUC_JIS_2004, 20932),\n\tDEF_ENC2NAME(UTF8, 65001),\n\tDEF_ENC2NAME(MULE_INTERNAL, 0),\n\tDEF_ENC2NAME(LATIN1, 28591),\n\tDEF_ENC2NAME(LATIN2, 28592),\n\tDEF_ENC2NAME(LATIN3, 28593),\n\tDEF_ENC2NAME(LATIN4, 28594),\n\tDEF_ENC2NAME(LATIN5, 28599),\n\tDEF_ENC2NAME(LATIN6, 0),\n\tDEF_ENC2NAME(LATIN7, 0),\n\tDEF_ENC2NAME(LATIN8, 0),\n\tDEF_ENC2NAME(LATIN9, 28605),\n\tDEF_ENC2NAME(LATIN10, 0),\n\tDEF_ENC2NAME(WIN1256, 1256),\n\tDEF_ENC2NAME(WIN1258, 1258),\n\tDEF_ENC2NAME(WIN866, 866),\n\tDEF_ENC2NAME(WIN874, 874),\n\tDEF_ENC2NAME(KOI8R, 20866),\n\tDEF_ENC2NAME(WIN1251, 1251),\n\tDEF_ENC2NAME(WIN1252, 1252),\n\tDEF_ENC2NAME(ISO_8859_5, 28595),\n\tDEF_ENC2NAME(ISO_8859_6, 28596),\n\tDEF_ENC2NAME(ISO_8859_7, 28597),\n\tDEF_ENC2NAME(ISO_8859_8, 28598),\n\tDEF_ENC2NAME(WIN1250, 1250),\n\tDEF_ENC2NAME(WIN1253, 1253),\n\tDEF_ENC2NAME(WIN1254, 1254),\n\tDEF_ENC2NAME(WIN1255, 1255),\n\tDEF_ENC2NAME(WIN1257, 1257),\n\tDEF_ENC2NAME(KOI8U, 21866),\n\tDEF_ENC2NAME(SJIS, 932),\n\tDEF_ENC2NAME(BIG5, 950),\n\tDEF_ENC2NAME(GBK, 936),\n\tDEF_ENC2NAME(UHC, 949),\n\tDEF_ENC2NAME(GB18030, 54936),\n\tDEF_ENC2NAME(JOHAB, 0),\n\tDEF_ENC2NAME(SHIFT_JIS_2004, 932)\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include <unistd.h>\n#include <ctype.h>\n#include \"utils/builtins.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_enc2name pg_enc2name_tbl[] =\n{\n\tDEF_ENC2NAME(SQL_ASCII, 0),\n\tDEF_ENC2NAME(EUC_JP, 20932),\n\tDEF_ENC2NAME(EUC_CN, 20936),\n\tDEF_ENC2NAME(EUC_KR, 51949),\n\tDEF_ENC2NAME(EUC_TW, 0),\n\tDEF_ENC2NAME(EUC_JIS_2004, 20932),\n\tDEF_ENC2NAME(UTF8, 65001),\n\tDEF_ENC2NAME(MULE_INTERNAL, 0),\n\tDEF_ENC2NAME(LATIN1, 28591),\n\tDEF_ENC2NAME(LATIN2, 28592),\n\tDEF_ENC2NAME(LATIN3, 28593),\n\tDEF_ENC2NAME(LATIN4, 28594),\n\tDEF_ENC2NAME(LATIN5, 28599),\n\tDEF_ENC2NAME(LATIN6, 0),\n\tDEF_ENC2NAME(LATIN7, 0),\n\tDEF_ENC2NAME(LATIN8, 0),\n\tDEF_ENC2NAME(LATIN9, 28605),\n\tDEF_ENC2NAME(LATIN10, 0),\n\tDEF_ENC2NAME(WIN1256, 1256),\n\tDEF_ENC2NAME(WIN1258, 1258),\n\tDEF_ENC2NAME(WIN866, 866),\n\tDEF_ENC2NAME(WIN874, 874),\n\tDEF_ENC2NAME(KOI8R, 20866),\n\tDEF_ENC2NAME(WIN1251, 1251),\n\tDEF_ENC2NAME(WIN1252, 1252),\n\tDEF_ENC2NAME(ISO_8859_5, 28595),\n\tDEF_ENC2NAME(ISO_8859_6, 28596),\n\tDEF_ENC2NAME(ISO_8859_7, 28597),\n\tDEF_ENC2NAME(ISO_8859_8, 28598),\n\tDEF_ENC2NAME(WIN1250, 1250),\n\tDEF_ENC2NAME(WIN1253, 1253),\n\tDEF_ENC2NAME(WIN1254, 1254),\n\tDEF_ENC2NAME(WIN1255, 1255),\n\tDEF_ENC2NAME(WIN1257, 1257),\n\tDEF_ENC2NAME(KOI8U, 21866),\n\tDEF_ENC2NAME(SJIS, 932),\n\tDEF_ENC2NAME(BIG5, 950),\n\tDEF_ENC2NAME(GBK, 936),\n\tDEF_ENC2NAME(UHC, 949),\n\tDEF_ENC2NAME(GB18030, 54936),\n\tDEF_ENC2NAME(JOHAB, 0),\n\tDEF_ENC2NAME(SHIFT_JIS_2004, 932)\n};\n\nconst char *\npg_encoding_to_char(int encoding)\n{\n\tif (PG_VALID_ENCODING(encoding))\n\t{\n\t\tconst pg_enc2name *p = &pg_enc2name_tbl[encoding];\n\n\t\tAssert(encoding == p->encoding);\n\t\treturn p->name;\n\t}\n\treturn \"\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "proc"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FindDefaultConversionProc",
          "args": [
            "src_encoding",
            "dest_encoding"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cannot perform encoding conversion outside a transaction\""
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsTransactionState",
          "args": [],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_verify_mbstr",
          "args": [
            "dest_encoding",
            "(const char *) src",
            "len",
            "false"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "pg_verify_mbstr_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1893-1953",
          "snippet": "int\npg_verify_mbstr_len(int encoding, const char *mbstr, int len, bool noError)\n{\n\tmbverifier\tmbverify;\n\tint\t\t\tmb_len;\n\n\tAssert(PG_VALID_ENCODING(encoding));\n\n\t/*\n\t * In single-byte encodings, we need only reject nulls (\\0).\n\t */\n\tif (pg_encoding_max_length(encoding) <= 1)\n\t{\n\t\tconst char *nullpos = memchr(mbstr, 0, len);\n\n\t\tif (nullpos == NULL)\n\t\t\treturn len;\n\t\tif (noError)\n\t\t\treturn -1;\n\t\treport_invalid_encoding(encoding, nullpos, 1);\n\t}\n\n\t/* fetch function pointer just once */\n\tmbverify = pg_wchar_table[encoding].mbverify;\n\n\tmb_len = 0;\n\n\twhile (len > 0)\n\t{\n\t\tint\t\t\tl;\n\n\t\t/* fast path for ASCII-subset characters */\n\t\tif (!IS_HIGHBIT_SET(*mbstr))\n\t\t{\n\t\t\tif (*mbstr != '\\0')\n\t\t\t{\n\t\t\t\tmb_len++;\n\t\t\t\tmbstr++;\n\t\t\t\tlen--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (noError)\n\t\t\t\treturn -1;\n\t\t\treport_invalid_encoding(encoding, mbstr, len);\n\t\t}\n\n\t\tl = (*mbverify) ((const unsigned char *) mbstr, len);\n\n\t\tif (l < 0)\n\t\t{\n\t\t\tif (noError)\n\t\t\t\treturn -1;\n\t\t\treport_invalid_encoding(encoding, mbstr, len);\n\t\t}\n\n\t\tmbstr += l;\n\t\tlen -= l;\n\t\tmb_len++;\n\t}\n\treturn mb_len;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_verify_mbstr_len(int encoding, const char *mbstr, int len, bool noError)\n{\n\tmbverifier\tmbverify;\n\tint\t\t\tmb_len;\n\n\tAssert(PG_VALID_ENCODING(encoding));\n\n\t/*\n\t * In single-byte encodings, we need only reject nulls (\\0).\n\t */\n\tif (pg_encoding_max_length(encoding) <= 1)\n\t{\n\t\tconst char *nullpos = memchr(mbstr, 0, len);\n\n\t\tif (nullpos == NULL)\n\t\t\treturn len;\n\t\tif (noError)\n\t\t\treturn -1;\n\t\treport_invalid_encoding(encoding, nullpos, 1);\n\t}\n\n\t/* fetch function pointer just once */\n\tmbverify = pg_wchar_table[encoding].mbverify;\n\n\tmb_len = 0;\n\n\twhile (len > 0)\n\t{\n\t\tint\t\t\tl;\n\n\t\t/* fast path for ASCII-subset characters */\n\t\tif (!IS_HIGHBIT_SET(*mbstr))\n\t\t{\n\t\t\tif (*mbstr != '\\0')\n\t\t\t{\n\t\t\t\tmb_len++;\n\t\t\t\tmbstr++;\n\t\t\t\tlen--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (noError)\n\t\t\t\treturn -1;\n\t\t\treport_invalid_encoding(encoding, mbstr, len);\n\t\t}\n\n\t\tl = (*mbverify) ((const unsigned char *) mbstr, len);\n\n\t\tif (l < 0)\n\t\t{\n\t\t\tif (noError)\n\t\t\t\treturn -1;\n\t\t\treport_invalid_encoding(encoding, mbstr, len);\n\t\t}\n\n\t\tmbstr += l;\n\t\tlen -= l;\n\t\tmb_len++;\n\t}\n\treturn mb_len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nunsigned char *\npg_do_encoding_conversion(unsigned char *src, int len,\n\t\t\t\t\t\t  int src_encoding, int dest_encoding)\n{\n\tunsigned char *result;\n\tOid\t\t\tproc;\n\n\tif (len <= 0)\n\t\treturn src;\t\t\t\t/* empty string is always valid */\n\n\tif (src_encoding == dest_encoding)\n\t\treturn src;\t\t\t\t/* no conversion required, assume valid */\n\n\tif (dest_encoding == PG_SQL_ASCII)\n\t\treturn src;\t\t\t\t/* any string is valid in SQL_ASCII */\n\n\tif (src_encoding == PG_SQL_ASCII)\n\t{\n\t\t/* No conversion is possible, but we must validate the result */\n\t\t(void) pg_verify_mbstr(dest_encoding, (const char *) src, len, false);\n\t\treturn src;\n\t}\n\n\tif (!IsTransactionState())\t/* shouldn't happen */\n\t\telog(ERROR, \"cannot perform encoding conversion outside a transaction\");\n\n\tproc = FindDefaultConversionProc(src_encoding, dest_encoding);\n\tif (!OidIsValid(proc))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"default conversion function for encoding \\\"%s\\\" to \\\"%s\\\" does not exist\",\n\t\t\t\t\t\tpg_encoding_to_char(src_encoding),\n\t\t\t\t\t\tpg_encoding_to_char(dest_encoding))));\n\n\t/*\n\t * Allocate space for conversion result, being wary of integer overflow\n\t */\n\tif ((Size) len >= (MaxAllocSize / (Size) MAX_CONVERSION_GROWTH))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"String of %d bytes is too long for encoding conversion.\",\n\t\t\t\t\t\t   len)));\n\n\tresult = palloc(len * MAX_CONVERSION_GROWTH + 1);\n\n\tOidFunctionCall5(proc,\n\t\t\t\t\t Int32GetDatum(src_encoding),\n\t\t\t\t\t Int32GetDatum(dest_encoding),\n\t\t\t\t\t CStringGetDatum(src),\n\t\t\t\t\t CStringGetDatum(result),\n\t\t\t\t\t Int32GetDatum(len));\n\treturn result;\n}"
  },
  {
    "function_name": "pg_get_client_encoding_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "314-318",
    "snippet": "const char *\npg_get_client_encoding_name(void)\n{\n\treturn ClientEncoding->name;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\npg_get_client_encoding_name(void)\n{\n\treturn ClientEncoding->name;\n}"
  },
  {
    "function_name": "pg_get_client_encoding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "305-309",
    "snippet": "int\npg_get_client_encoding(void)\n{\n\treturn ClientEncoding->encoding;\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_get_client_encoding(void)\n{\n\treturn ClientEncoding->encoding;\n}"
  },
  {
    "function_name": "InitializeClientEncoding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "281-300",
    "snippet": "void\nInitializeClientEncoding(void)\n{\n\tAssert(!backend_startup_complete);\n\tbackend_startup_complete = true;\n\n\tif (PrepareClientEncoding(pending_client_encoding) < 0 ||\n\t\tSetClientEncoding(pending_client_encoding) < 0)\n\t{\n\t\t/*\n\t\t * Oops, the requested conversion is not available. We couldn't fail\n\t\t * before, but we can now.\n\t\t */\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"conversion between %s and %s is not supported\",\n\t\t\t\t\t\tpg_enc2name_tbl[pending_client_encoding].name,\n\t\t\t\t\t\tGetDatabaseEncodingName())));\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool backend_startup_complete = false;",
      "static int\tpending_client_encoding = PG_SQL_ASCII;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"conversion between %s and %s is not supported\",\n\t\t\t\t\t\tpg_enc2name_tbl[pending_client_encoding].name,\n\t\t\t\t\t\tGetDatabaseEncodingName()))"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"conversion between %s and %s is not supported\"",
            "pg_enc2name_tbl[pending_client_encoding].name",
            "GetDatabaseEncodingName()"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncodingName",
          "args": [],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetClientEncoding",
          "args": [
            "pending_client_encoding"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "SetClientEncoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "200-275",
          "snippet": "int\nSetClientEncoding(int encoding)\n{\n\tint\t\t\tcurrent_server_encoding;\n\tbool\t\tfound;\n\tListCell   *lc;\n\tListCell   *prev;\n\tListCell   *next;\n\n\tif (!PG_VALID_FE_ENCODING(encoding))\n\t\treturn -1;\n\n\t/* Can't do anything during startup, per notes above */\n\tif (!backend_startup_complete)\n\t{\n\t\tpending_client_encoding = encoding;\n\t\treturn 0;\n\t}\n\n\tcurrent_server_encoding = GetDatabaseEncoding();\n\n\t/*\n\t * Check for cases that require no conversion function.\n\t */\n\tif (current_server_encoding == encoding ||\n\t\tcurrent_server_encoding == PG_SQL_ASCII ||\n\t\tencoding == PG_SQL_ASCII)\n\t{\n\t\tClientEncoding = &pg_enc2name_tbl[encoding];\n\t\tToServerConvProc = NULL;\n\t\tToClientConvProc = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Search the cache for the entry previously prepared by\n\t * PrepareClientEncoding; if there isn't one, we lose.  While at it,\n\t * release any duplicate entries so that repeated Prepare/Set cycles don't\n\t * leak memory.\n\t */\n\tfound = false;\n\tprev = NULL;\n\tfor (lc = list_head(ConvProcList); lc; lc = next)\n\t{\n\t\tConvProcInfo *convinfo = (ConvProcInfo *) lfirst(lc);\n\n\t\tnext = lnext(lc);\n\n\t\tif (convinfo->s_encoding == current_server_encoding &&\n\t\t\tconvinfo->c_encoding == encoding)\n\t\t{\n\t\t\tif (!found)\n\t\t\t{\n\t\t\t\t/* Found newest entry, so set up */\n\t\t\t\tClientEncoding = &pg_enc2name_tbl[encoding];\n\t\t\t\tToServerConvProc = &convinfo->to_server_info;\n\t\t\t\tToClientConvProc = &convinfo->to_client_info;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Duplicate entry, release it */\n\t\t\t\tConvProcList = list_delete_cell(ConvProcList, lc, prev);\n\t\t\t\tpfree(convinfo);\n\t\t\t\tcontinue;\t\t/* prev mustn't advance */\n\t\t\t}\n\t\t}\n\n\t\tprev = lc;\n\t}\n\n\tif (found)\n\t\treturn 0;\t\t\t\t/* success */\n\telse\n\t\treturn -1;\t\t\t\t/* it's not cached, so fail */\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static List *ConvProcList = NIL;",
            "static FmgrInfo *ToServerConvProc = NULL;",
            "static FmgrInfo *ToClientConvProc = NULL;",
            "static const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
            "static bool backend_startup_complete = false;",
            "static int\tpending_client_encoding = PG_SQL_ASCII;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic List *ConvProcList = NIL;\nstatic FmgrInfo *ToServerConvProc = NULL;\nstatic FmgrInfo *ToClientConvProc = NULL;\nstatic const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic bool backend_startup_complete = false;\nstatic int\tpending_client_encoding = PG_SQL_ASCII;\n\nint\nSetClientEncoding(int encoding)\n{\n\tint\t\t\tcurrent_server_encoding;\n\tbool\t\tfound;\n\tListCell   *lc;\n\tListCell   *prev;\n\tListCell   *next;\n\n\tif (!PG_VALID_FE_ENCODING(encoding))\n\t\treturn -1;\n\n\t/* Can't do anything during startup, per notes above */\n\tif (!backend_startup_complete)\n\t{\n\t\tpending_client_encoding = encoding;\n\t\treturn 0;\n\t}\n\n\tcurrent_server_encoding = GetDatabaseEncoding();\n\n\t/*\n\t * Check for cases that require no conversion function.\n\t */\n\tif (current_server_encoding == encoding ||\n\t\tcurrent_server_encoding == PG_SQL_ASCII ||\n\t\tencoding == PG_SQL_ASCII)\n\t{\n\t\tClientEncoding = &pg_enc2name_tbl[encoding];\n\t\tToServerConvProc = NULL;\n\t\tToClientConvProc = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Search the cache for the entry previously prepared by\n\t * PrepareClientEncoding; if there isn't one, we lose.  While at it,\n\t * release any duplicate entries so that repeated Prepare/Set cycles don't\n\t * leak memory.\n\t */\n\tfound = false;\n\tprev = NULL;\n\tfor (lc = list_head(ConvProcList); lc; lc = next)\n\t{\n\t\tConvProcInfo *convinfo = (ConvProcInfo *) lfirst(lc);\n\n\t\tnext = lnext(lc);\n\n\t\tif (convinfo->s_encoding == current_server_encoding &&\n\t\t\tconvinfo->c_encoding == encoding)\n\t\t{\n\t\t\tif (!found)\n\t\t\t{\n\t\t\t\t/* Found newest entry, so set up */\n\t\t\t\tClientEncoding = &pg_enc2name_tbl[encoding];\n\t\t\t\tToServerConvProc = &convinfo->to_server_info;\n\t\t\t\tToClientConvProc = &convinfo->to_client_info;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Duplicate entry, release it */\n\t\t\t\tConvProcList = list_delete_cell(ConvProcList, lc, prev);\n\t\t\t\tpfree(convinfo);\n\t\t\t\tcontinue;\t\t/* prev mustn't advance */\n\t\t\t}\n\t\t}\n\n\t\tprev = lc;\n\t}\n\n\tif (found)\n\t\treturn 0;\t\t\t\t/* success */\n\telse\n\t\treturn -1;\t\t\t\t/* it's not cached, so fail */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrepareClientEncoding",
          "args": [
            "pending_client_encoding"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "PrepareClientEncoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "102-192",
          "snippet": "int\nPrepareClientEncoding(int encoding)\n{\n\tint\t\t\tcurrent_server_encoding;\n\tListCell   *lc;\n\n\tif (!PG_VALID_FE_ENCODING(encoding))\n\t\treturn -1;\n\n\t/* Can't do anything during startup, per notes above */\n\tif (!backend_startup_complete)\n\t\treturn 0;\n\n\tcurrent_server_encoding = GetDatabaseEncoding();\n\n\t/*\n\t * Check for cases that require no conversion function.\n\t */\n\tif (current_server_encoding == encoding ||\n\t\tcurrent_server_encoding == PG_SQL_ASCII ||\n\t\tencoding == PG_SQL_ASCII)\n\t\treturn 0;\n\n\tif (IsTransactionState())\n\t{\n\t\t/*\n\t\t * If we're in a live transaction, it's safe to access the catalogs,\n\t\t * so look up the functions.  We repeat the lookup even if the info is\n\t\t * already cached, so that we can react to changes in the contents of\n\t\t * pg_conversion.\n\t\t */\n\t\tOid\t\t\tto_server_proc,\n\t\t\t\t\tto_client_proc;\n\t\tConvProcInfo *convinfo;\n\t\tMemoryContext oldcontext;\n\n\t\tto_server_proc = FindDefaultConversionProc(encoding,\n\t\t\t\t\t\t\t\t\t\t\t\t   current_server_encoding);\n\t\tif (!OidIsValid(to_server_proc))\n\t\t\treturn -1;\n\t\tto_client_proc = FindDefaultConversionProc(current_server_encoding,\n\t\t\t\t\t\t\t\t\t\t\t\t   encoding);\n\t\tif (!OidIsValid(to_client_proc))\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * Load the fmgr info into TopMemoryContext (could still fail here)\n\t\t */\n\t\tconvinfo = (ConvProcInfo *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(ConvProcInfo));\n\t\tconvinfo->s_encoding = current_server_encoding;\n\t\tconvinfo->c_encoding = encoding;\n\t\tfmgr_info_cxt(to_server_proc, &convinfo->to_server_info,\n\t\t\t\t\t  TopMemoryContext);\n\t\tfmgr_info_cxt(to_client_proc, &convinfo->to_client_info,\n\t\t\t\t\t  TopMemoryContext);\n\n\t\t/* Attach new info to head of list */\n\t\toldcontext = MemoryContextSwitchTo(TopMemoryContext);\n\t\tConvProcList = lcons(convinfo, ConvProcList);\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\t/*\n\t\t * We cannot yet remove any older entry for the same encoding pair,\n\t\t * since it could still be in use.  SetClientEncoding will clean up.\n\t\t */\n\n\t\treturn 0;\t\t\t\t/* success */\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If we're not in a live transaction, the only thing we can do is\n\t\t * restore a previous setting using the cache.  This covers all\n\t\t * transaction-rollback cases.  The only case it might not work for is\n\t\t * trying to change client_encoding on the fly by editing\n\t\t * postgresql.conf and SIGHUP'ing.  Which would probably be a stupid\n\t\t * thing to do anyway.\n\t\t */\n\t\tforeach(lc, ConvProcList)\n\t\t{\n\t\t\tConvProcInfo *oldinfo = (ConvProcInfo *) lfirst(lc);\n\n\t\t\tif (oldinfo->s_encoding == current_server_encoding &&\n\t\t\t\toldinfo->c_encoding == encoding)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\treturn -1;\t\t\t\t/* it's not cached, so fail */\n\t}\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static List *ConvProcList = NIL;",
            "static bool backend_startup_complete = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic List *ConvProcList = NIL;\nstatic bool backend_startup_complete = false;\n\nint\nPrepareClientEncoding(int encoding)\n{\n\tint\t\t\tcurrent_server_encoding;\n\tListCell   *lc;\n\n\tif (!PG_VALID_FE_ENCODING(encoding))\n\t\treturn -1;\n\n\t/* Can't do anything during startup, per notes above */\n\tif (!backend_startup_complete)\n\t\treturn 0;\n\n\tcurrent_server_encoding = GetDatabaseEncoding();\n\n\t/*\n\t * Check for cases that require no conversion function.\n\t */\n\tif (current_server_encoding == encoding ||\n\t\tcurrent_server_encoding == PG_SQL_ASCII ||\n\t\tencoding == PG_SQL_ASCII)\n\t\treturn 0;\n\n\tif (IsTransactionState())\n\t{\n\t\t/*\n\t\t * If we're in a live transaction, it's safe to access the catalogs,\n\t\t * so look up the functions.  We repeat the lookup even if the info is\n\t\t * already cached, so that we can react to changes in the contents of\n\t\t * pg_conversion.\n\t\t */\n\t\tOid\t\t\tto_server_proc,\n\t\t\t\t\tto_client_proc;\n\t\tConvProcInfo *convinfo;\n\t\tMemoryContext oldcontext;\n\n\t\tto_server_proc = FindDefaultConversionProc(encoding,\n\t\t\t\t\t\t\t\t\t\t\t\t   current_server_encoding);\n\t\tif (!OidIsValid(to_server_proc))\n\t\t\treturn -1;\n\t\tto_client_proc = FindDefaultConversionProc(current_server_encoding,\n\t\t\t\t\t\t\t\t\t\t\t\t   encoding);\n\t\tif (!OidIsValid(to_client_proc))\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * Load the fmgr info into TopMemoryContext (could still fail here)\n\t\t */\n\t\tconvinfo = (ConvProcInfo *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(ConvProcInfo));\n\t\tconvinfo->s_encoding = current_server_encoding;\n\t\tconvinfo->c_encoding = encoding;\n\t\tfmgr_info_cxt(to_server_proc, &convinfo->to_server_info,\n\t\t\t\t\t  TopMemoryContext);\n\t\tfmgr_info_cxt(to_client_proc, &convinfo->to_client_info,\n\t\t\t\t\t  TopMemoryContext);\n\n\t\t/* Attach new info to head of list */\n\t\toldcontext = MemoryContextSwitchTo(TopMemoryContext);\n\t\tConvProcList = lcons(convinfo, ConvProcList);\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\t/*\n\t\t * We cannot yet remove any older entry for the same encoding pair,\n\t\t * since it could still be in use.  SetClientEncoding will clean up.\n\t\t */\n\n\t\treturn 0;\t\t\t\t/* success */\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If we're not in a live transaction, the only thing we can do is\n\t\t * restore a previous setting using the cache.  This covers all\n\t\t * transaction-rollback cases.  The only case it might not work for is\n\t\t * trying to change client_encoding on the fly by editing\n\t\t * postgresql.conf and SIGHUP'ing.  Which would probably be a stupid\n\t\t * thing to do anyway.\n\t\t */\n\t\tforeach(lc, ConvProcList)\n\t\t{\n\t\t\tConvProcInfo *oldinfo = (ConvProcInfo *) lfirst(lc);\n\n\t\t\tif (oldinfo->s_encoding == current_server_encoding &&\n\t\t\t\toldinfo->c_encoding == encoding)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\treturn -1;\t\t\t\t/* it's not cached, so fail */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!backend_startup_complete"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic bool backend_startup_complete = false;\nstatic int\tpending_client_encoding = PG_SQL_ASCII;\n\nvoid\nInitializeClientEncoding(void)\n{\n\tAssert(!backend_startup_complete);\n\tbackend_startup_complete = true;\n\n\tif (PrepareClientEncoding(pending_client_encoding) < 0 ||\n\t\tSetClientEncoding(pending_client_encoding) < 0)\n\t{\n\t\t/*\n\t\t * Oops, the requested conversion is not available. We couldn't fail\n\t\t * before, but we can now.\n\t\t */\n\t\tereport(FATAL,\n\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t errmsg(\"conversion between %s and %s is not supported\",\n\t\t\t\t\t\tpg_enc2name_tbl[pending_client_encoding].name,\n\t\t\t\t\t\tGetDatabaseEncodingName())));\n\t}\n}"
  },
  {
    "function_name": "SetClientEncoding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "200-275",
    "snippet": "int\nSetClientEncoding(int encoding)\n{\n\tint\t\t\tcurrent_server_encoding;\n\tbool\t\tfound;\n\tListCell   *lc;\n\tListCell   *prev;\n\tListCell   *next;\n\n\tif (!PG_VALID_FE_ENCODING(encoding))\n\t\treturn -1;\n\n\t/* Can't do anything during startup, per notes above */\n\tif (!backend_startup_complete)\n\t{\n\t\tpending_client_encoding = encoding;\n\t\treturn 0;\n\t}\n\n\tcurrent_server_encoding = GetDatabaseEncoding();\n\n\t/*\n\t * Check for cases that require no conversion function.\n\t */\n\tif (current_server_encoding == encoding ||\n\t\tcurrent_server_encoding == PG_SQL_ASCII ||\n\t\tencoding == PG_SQL_ASCII)\n\t{\n\t\tClientEncoding = &pg_enc2name_tbl[encoding];\n\t\tToServerConvProc = NULL;\n\t\tToClientConvProc = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Search the cache for the entry previously prepared by\n\t * PrepareClientEncoding; if there isn't one, we lose.  While at it,\n\t * release any duplicate entries so that repeated Prepare/Set cycles don't\n\t * leak memory.\n\t */\n\tfound = false;\n\tprev = NULL;\n\tfor (lc = list_head(ConvProcList); lc; lc = next)\n\t{\n\t\tConvProcInfo *convinfo = (ConvProcInfo *) lfirst(lc);\n\n\t\tnext = lnext(lc);\n\n\t\tif (convinfo->s_encoding == current_server_encoding &&\n\t\t\tconvinfo->c_encoding == encoding)\n\t\t{\n\t\t\tif (!found)\n\t\t\t{\n\t\t\t\t/* Found newest entry, so set up */\n\t\t\t\tClientEncoding = &pg_enc2name_tbl[encoding];\n\t\t\t\tToServerConvProc = &convinfo->to_server_info;\n\t\t\t\tToClientConvProc = &convinfo->to_client_info;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Duplicate entry, release it */\n\t\t\t\tConvProcList = list_delete_cell(ConvProcList, lc, prev);\n\t\t\t\tpfree(convinfo);\n\t\t\t\tcontinue;\t\t/* prev mustn't advance */\n\t\t\t}\n\t\t}\n\n\t\tprev = lc;\n\t}\n\n\tif (found)\n\t\treturn 0;\t\t\t\t/* success */\n\telse\n\t\treturn -1;\t\t\t\t/* it's not cached, so fail */\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static List *ConvProcList = NIL;",
      "static FmgrInfo *ToServerConvProc = NULL;",
      "static FmgrInfo *ToClientConvProc = NULL;",
      "static const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
      "static bool backend_startup_complete = false;",
      "static int\tpending_client_encoding = PG_SQL_ASCII;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "convinfo"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_delete_cell",
          "args": [
            "ConvProcList",
            "lc",
            "prev"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnext",
          "args": [
            "lc"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "lc"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_head",
          "args": [
            "ConvProcList"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_VALID_FE_ENCODING",
          "args": [
            "encoding"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic List *ConvProcList = NIL;\nstatic FmgrInfo *ToServerConvProc = NULL;\nstatic FmgrInfo *ToClientConvProc = NULL;\nstatic const pg_enc2name *ClientEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic bool backend_startup_complete = false;\nstatic int\tpending_client_encoding = PG_SQL_ASCII;\n\nint\nSetClientEncoding(int encoding)\n{\n\tint\t\t\tcurrent_server_encoding;\n\tbool\t\tfound;\n\tListCell   *lc;\n\tListCell   *prev;\n\tListCell   *next;\n\n\tif (!PG_VALID_FE_ENCODING(encoding))\n\t\treturn -1;\n\n\t/* Can't do anything during startup, per notes above */\n\tif (!backend_startup_complete)\n\t{\n\t\tpending_client_encoding = encoding;\n\t\treturn 0;\n\t}\n\n\tcurrent_server_encoding = GetDatabaseEncoding();\n\n\t/*\n\t * Check for cases that require no conversion function.\n\t */\n\tif (current_server_encoding == encoding ||\n\t\tcurrent_server_encoding == PG_SQL_ASCII ||\n\t\tencoding == PG_SQL_ASCII)\n\t{\n\t\tClientEncoding = &pg_enc2name_tbl[encoding];\n\t\tToServerConvProc = NULL;\n\t\tToClientConvProc = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Search the cache for the entry previously prepared by\n\t * PrepareClientEncoding; if there isn't one, we lose.  While at it,\n\t * release any duplicate entries so that repeated Prepare/Set cycles don't\n\t * leak memory.\n\t */\n\tfound = false;\n\tprev = NULL;\n\tfor (lc = list_head(ConvProcList); lc; lc = next)\n\t{\n\t\tConvProcInfo *convinfo = (ConvProcInfo *) lfirst(lc);\n\n\t\tnext = lnext(lc);\n\n\t\tif (convinfo->s_encoding == current_server_encoding &&\n\t\t\tconvinfo->c_encoding == encoding)\n\t\t{\n\t\t\tif (!found)\n\t\t\t{\n\t\t\t\t/* Found newest entry, so set up */\n\t\t\t\tClientEncoding = &pg_enc2name_tbl[encoding];\n\t\t\t\tToServerConvProc = &convinfo->to_server_info;\n\t\t\t\tToClientConvProc = &convinfo->to_client_info;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Duplicate entry, release it */\n\t\t\t\tConvProcList = list_delete_cell(ConvProcList, lc, prev);\n\t\t\t\tpfree(convinfo);\n\t\t\t\tcontinue;\t\t/* prev mustn't advance */\n\t\t\t}\n\t\t}\n\n\t\tprev = lc;\n\t}\n\n\tif (found)\n\t\treturn 0;\t\t\t\t/* success */\n\telse\n\t\treturn -1;\t\t\t\t/* it's not cached, so fail */\n}"
  },
  {
    "function_name": "PrepareClientEncoding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
    "lines": "102-192",
    "snippet": "int\nPrepareClientEncoding(int encoding)\n{\n\tint\t\t\tcurrent_server_encoding;\n\tListCell   *lc;\n\n\tif (!PG_VALID_FE_ENCODING(encoding))\n\t\treturn -1;\n\n\t/* Can't do anything during startup, per notes above */\n\tif (!backend_startup_complete)\n\t\treturn 0;\n\n\tcurrent_server_encoding = GetDatabaseEncoding();\n\n\t/*\n\t * Check for cases that require no conversion function.\n\t */\n\tif (current_server_encoding == encoding ||\n\t\tcurrent_server_encoding == PG_SQL_ASCII ||\n\t\tencoding == PG_SQL_ASCII)\n\t\treturn 0;\n\n\tif (IsTransactionState())\n\t{\n\t\t/*\n\t\t * If we're in a live transaction, it's safe to access the catalogs,\n\t\t * so look up the functions.  We repeat the lookup even if the info is\n\t\t * already cached, so that we can react to changes in the contents of\n\t\t * pg_conversion.\n\t\t */\n\t\tOid\t\t\tto_server_proc,\n\t\t\t\t\tto_client_proc;\n\t\tConvProcInfo *convinfo;\n\t\tMemoryContext oldcontext;\n\n\t\tto_server_proc = FindDefaultConversionProc(encoding,\n\t\t\t\t\t\t\t\t\t\t\t\t   current_server_encoding);\n\t\tif (!OidIsValid(to_server_proc))\n\t\t\treturn -1;\n\t\tto_client_proc = FindDefaultConversionProc(current_server_encoding,\n\t\t\t\t\t\t\t\t\t\t\t\t   encoding);\n\t\tif (!OidIsValid(to_client_proc))\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * Load the fmgr info into TopMemoryContext (could still fail here)\n\t\t */\n\t\tconvinfo = (ConvProcInfo *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(ConvProcInfo));\n\t\tconvinfo->s_encoding = current_server_encoding;\n\t\tconvinfo->c_encoding = encoding;\n\t\tfmgr_info_cxt(to_server_proc, &convinfo->to_server_info,\n\t\t\t\t\t  TopMemoryContext);\n\t\tfmgr_info_cxt(to_client_proc, &convinfo->to_client_info,\n\t\t\t\t\t  TopMemoryContext);\n\n\t\t/* Attach new info to head of list */\n\t\toldcontext = MemoryContextSwitchTo(TopMemoryContext);\n\t\tConvProcList = lcons(convinfo, ConvProcList);\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\t/*\n\t\t * We cannot yet remove any older entry for the same encoding pair,\n\t\t * since it could still be in use.  SetClientEncoding will clean up.\n\t\t */\n\n\t\treturn 0;\t\t\t\t/* success */\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If we're not in a live transaction, the only thing we can do is\n\t\t * restore a previous setting using the cache.  This covers all\n\t\t * transaction-rollback cases.  The only case it might not work for is\n\t\t * trying to change client_encoding on the fly by editing\n\t\t * postgresql.conf and SIGHUP'ing.  Which would probably be a stupid\n\t\t * thing to do anyway.\n\t\t */\n\t\tforeach(lc, ConvProcList)\n\t\t{\n\t\t\tConvProcInfo *oldinfo = (ConvProcInfo *) lfirst(lc);\n\n\t\t\tif (oldinfo->s_encoding == current_server_encoding &&\n\t\t\t\toldinfo->c_encoding == encoding)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\treturn -1;\t\t\t\t/* it's not cached, so fail */\n\t}\n}",
    "includes": [
      "#include \"utils/syscache.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/xact.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static List *ConvProcList = NIL;",
      "static bool backend_startup_complete = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "lc"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "lc",
            "ConvProcList"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lcons",
          "args": [
            "convinfo",
            "ConvProcList"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "TopMemoryContext"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmgr_info_cxt",
          "args": [
            "to_client_proc",
            "&convinfo->to_client_info",
            "TopMemoryContext"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "fmgr_info_cxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "133-137",
          "snippet": "void\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nvoid\nfmgr_info_cxt(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)\n{\n\tfmgr_info_cxt_security(functionId, finfo, mcxt, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "TopMemoryContext",
            "sizeof(ConvProcInfo)"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "to_client_proc"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FindDefaultConversionProc",
          "args": [
            "current_server_encoding",
            "encoding"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "to_server_proc"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FindDefaultConversionProc",
          "args": [
            "encoding",
            "current_server_encoding"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsTransactionState",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_VALID_FE_ENCODING",
          "args": [
            "encoding"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic List *ConvProcList = NIL;\nstatic bool backend_startup_complete = false;\n\nint\nPrepareClientEncoding(int encoding)\n{\n\tint\t\t\tcurrent_server_encoding;\n\tListCell   *lc;\n\n\tif (!PG_VALID_FE_ENCODING(encoding))\n\t\treturn -1;\n\n\t/* Can't do anything during startup, per notes above */\n\tif (!backend_startup_complete)\n\t\treturn 0;\n\n\tcurrent_server_encoding = GetDatabaseEncoding();\n\n\t/*\n\t * Check for cases that require no conversion function.\n\t */\n\tif (current_server_encoding == encoding ||\n\t\tcurrent_server_encoding == PG_SQL_ASCII ||\n\t\tencoding == PG_SQL_ASCII)\n\t\treturn 0;\n\n\tif (IsTransactionState())\n\t{\n\t\t/*\n\t\t * If we're in a live transaction, it's safe to access the catalogs,\n\t\t * so look up the functions.  We repeat the lookup even if the info is\n\t\t * already cached, so that we can react to changes in the contents of\n\t\t * pg_conversion.\n\t\t */\n\t\tOid\t\t\tto_server_proc,\n\t\t\t\t\tto_client_proc;\n\t\tConvProcInfo *convinfo;\n\t\tMemoryContext oldcontext;\n\n\t\tto_server_proc = FindDefaultConversionProc(encoding,\n\t\t\t\t\t\t\t\t\t\t\t\t   current_server_encoding);\n\t\tif (!OidIsValid(to_server_proc))\n\t\t\treturn -1;\n\t\tto_client_proc = FindDefaultConversionProc(current_server_encoding,\n\t\t\t\t\t\t\t\t\t\t\t\t   encoding);\n\t\tif (!OidIsValid(to_client_proc))\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * Load the fmgr info into TopMemoryContext (could still fail here)\n\t\t */\n\t\tconvinfo = (ConvProcInfo *) MemoryContextAlloc(TopMemoryContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   sizeof(ConvProcInfo));\n\t\tconvinfo->s_encoding = current_server_encoding;\n\t\tconvinfo->c_encoding = encoding;\n\t\tfmgr_info_cxt(to_server_proc, &convinfo->to_server_info,\n\t\t\t\t\t  TopMemoryContext);\n\t\tfmgr_info_cxt(to_client_proc, &convinfo->to_client_info,\n\t\t\t\t\t  TopMemoryContext);\n\n\t\t/* Attach new info to head of list */\n\t\toldcontext = MemoryContextSwitchTo(TopMemoryContext);\n\t\tConvProcList = lcons(convinfo, ConvProcList);\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\t/*\n\t\t * We cannot yet remove any older entry for the same encoding pair,\n\t\t * since it could still be in use.  SetClientEncoding will clean up.\n\t\t */\n\n\t\treturn 0;\t\t\t\t/* success */\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If we're not in a live transaction, the only thing we can do is\n\t\t * restore a previous setting using the cache.  This covers all\n\t\t * transaction-rollback cases.  The only case it might not work for is\n\t\t * trying to change client_encoding on the fly by editing\n\t\t * postgresql.conf and SIGHUP'ing.  Which would probably be a stupid\n\t\t * thing to do anyway.\n\t\t */\n\t\tforeach(lc, ConvProcList)\n\t\t{\n\t\t\tConvProcInfo *oldinfo = (ConvProcInfo *) lfirst(lc);\n\n\t\t\tif (oldinfo->s_encoding == current_server_encoding &&\n\t\t\t\toldinfo->c_encoding == encoding)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\treturn -1;\t\t\t\t/* it's not cached, so fail */\n\t}\n}"
  }
]