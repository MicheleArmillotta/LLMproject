[
  {
    "function_name": "timeofday",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1559-1574",
    "snippet": "Datum\ntimeofday(PG_FUNCTION_ARGS)\n{\n\tstruct timeval tp;\n\tchar\t\ttempl[128];\n\tchar\t\tbuf[128];\n\tpg_time_t\ttt;\n\n\tgettimeofday(&tp, NULL);\n\ttt = (pg_time_t) tp.tv_sec;\n\tpg_strftime(templ, sizeof(templ), \"%a %b %d %H:%M:%S.%%06d %Y %Z\",\n\t\t\t\tpg_localtime(&tt, session_timezone));\n\tsnprintf(buf, sizeof(buf), templ, tp.tv_usec);\n\n\tPG_RETURN_TEXT_P(cstring_to_text(buf));\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "cstring_to_text(buf)"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "buf"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "templ",
            "tp.tv_usec"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strftime",
          "args": [
            "templ",
            "sizeof(templ)",
            "\"%a %b %d %H:%M:%S.%%06d %Y %Z\"",
            "pg_localtime(&tt, session_timezone)"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_localtime",
          "args": [
            "&tt",
            "session_timezone"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettimeofday",
          "args": [
            "&tp",
            "NULL"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimeofday(PG_FUNCTION_ARGS)\n{\n\tstruct timeval tp;\n\tchar\t\ttempl[128];\n\tchar\t\tbuf[128];\n\tpg_time_t\ttt;\n\n\tgettimeofday(&tp, NULL);\n\ttt = (pg_time_t) tp.tv_sec;\n\tpg_strftime(templ, sizeof(templ), \"%a %b %d %H:%M:%S.%%06d %Y %Z\",\n\t\t\t\tpg_localtime(&tt, session_timezone));\n\tsnprintf(buf, sizeof(buf), templ, tp.tv_usec);\n\n\tPG_RETURN_TEXT_P(cstring_to_text(buf));\n}"
  },
  {
    "function_name": "parsetinterval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1434-1545",
    "snippet": "static void\nparsetinterval(char *i_string,\n\t\t\t   AbsoluteTime *i_start,\n\t\t\t   AbsoluteTime *i_end)\n{\n\tchar\t   *p,\n\t\t\t   *p1;\n\tchar\t\tc;\n\n\tp = i_string;\n\t/* skip leading blanks up to '[' */\n\twhile ((c = *p) != '\\0')\n\t{\n\t\tif (IsSpace(c))\n\t\t\tp++;\n\t\telse if (c != '[')\n\t\t\tgoto bogus;\t\t\t/* syntax error */\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\tp++;\n\t/* skip leading blanks up to '\"' */\n\twhile ((c = *p) != '\\0')\n\t{\n\t\tif (IsSpace(c))\n\t\t\tp++;\n\t\telse if (c != '\"')\n\t\t\tgoto bogus;\t\t\t/* syntax error */\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\tp++;\n\tif (strncmp(INVALID_INTERVAL_STR, p, strlen(INVALID_INTERVAL_STR)) == 0)\n\t\tgoto bogus;\t\t\t\t/* undefined range, handled like a syntax err. */\n\t/* search for the end of the first date and change it to a \\0 */\n\tp1 = p;\n\twhile ((c = *p1) != '\\0')\n\t{\n\t\tif (c == '\"')\n\t\t\tbreak;\n\t\tp1++;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\t*p1 = '\\0';\n\t/* get the first date */\n\t*i_start = DatumGetAbsoluteTime(DirectFunctionCall1(abstimein,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tCStringGetDatum(p)));\n\t/* undo change to \\0 */\n\t*p1 = c;\n\tp = ++p1;\n\t/* skip blanks up to '\"', beginning of second date */\n\twhile ((c = *p) != '\\0')\n\t{\n\t\tif (IsSpace(c))\n\t\t\tp++;\n\t\telse if (c != '\"')\n\t\t\tgoto bogus;\t\t\t/* syntax error */\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\tp++;\n\t/* search for the end of the second date and change it to a \\0 */\n\tp1 = p;\n\twhile ((c = *p1) != '\\0')\n\t{\n\t\tif (c == '\"')\n\t\t\tbreak;\n\t\tp1++;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\t*p1 = '\\0';\n\t/* get the second date */\n\t*i_end = DatumGetAbsoluteTime(DirectFunctionCall1(abstimein,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(p)));\n\t/* undo change to \\0 */\n\t*p1 = c;\n\tp = ++p1;\n\t/* skip blanks up to ']' */\n\twhile ((c = *p) != '\\0')\n\t{\n\t\tif (IsSpace(c))\n\t\t\tp++;\n\t\telse if (c != ']')\n\t\t\tgoto bogus;\t\t\t/* syntax error */\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\tp++;\n\tc = *p;\n\tif (c != '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\n\t/* it seems to be a valid tinterval */\n\treturn;\n\nbogus:\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\"tinterval\", i_string)));\n\t*i_start = *i_end = INVALID_ABSTIME;\t/* keep compiler quiet */\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define INVALID_INTERVAL_STR\t\t\t\"Undefined Range\""
    ],
    "globals_used": [
      "static void parsetinterval(char *i_string,\n\t\t\t   AbsoluteTime *i_start,\n\t\t\t   AbsoluteTime *i_end);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\"tinterval\", i_string))"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid input syntax for type %s: \\\"%s\\\"\"",
            "\"tinterval\"",
            "i_string"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_DATETIME_FORMAT"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsSpace",
          "args": [
            "c"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetAbsoluteTime",
          "args": [
            "DirectFunctionCall1(abstimein,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(p))"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "abstimein",
            "CStringGetDatum(p)"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "p"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsSpace",
          "args": [
            "c"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetAbsoluteTime",
          "args": [
            "DirectFunctionCall1(abstimein,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tCStringGetDatum(p))"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "abstimein",
            "CStringGetDatum(p)"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "p"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "INVALID_INTERVAL_STR",
            "p",
            "strlen(INVALID_INTERVAL_STR)"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "pg_char_and_wchar_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wstrncmp.c",
          "lines": "54-67",
          "snippet": "int\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nint\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "INVALID_INTERVAL_STR"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsSpace",
          "args": [
            "c"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsSpace",
          "args": [
            "c"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define INVALID_INTERVAL_STR\t\t\t\"Undefined Range\"\n\nstatic void parsetinterval(char *i_string,\n\t\t\t   AbsoluteTime *i_start,\n\t\t\t   AbsoluteTime *i_end);\n\nstatic void\nparsetinterval(char *i_string,\n\t\t\t   AbsoluteTime *i_start,\n\t\t\t   AbsoluteTime *i_end)\n{\n\tchar\t   *p,\n\t\t\t   *p1;\n\tchar\t\tc;\n\n\tp = i_string;\n\t/* skip leading blanks up to '[' */\n\twhile ((c = *p) != '\\0')\n\t{\n\t\tif (IsSpace(c))\n\t\t\tp++;\n\t\telse if (c != '[')\n\t\t\tgoto bogus;\t\t\t/* syntax error */\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\tp++;\n\t/* skip leading blanks up to '\"' */\n\twhile ((c = *p) != '\\0')\n\t{\n\t\tif (IsSpace(c))\n\t\t\tp++;\n\t\telse if (c != '\"')\n\t\t\tgoto bogus;\t\t\t/* syntax error */\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\tp++;\n\tif (strncmp(INVALID_INTERVAL_STR, p, strlen(INVALID_INTERVAL_STR)) == 0)\n\t\tgoto bogus;\t\t\t\t/* undefined range, handled like a syntax err. */\n\t/* search for the end of the first date and change it to a \\0 */\n\tp1 = p;\n\twhile ((c = *p1) != '\\0')\n\t{\n\t\tif (c == '\"')\n\t\t\tbreak;\n\t\tp1++;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\t*p1 = '\\0';\n\t/* get the first date */\n\t*i_start = DatumGetAbsoluteTime(DirectFunctionCall1(abstimein,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tCStringGetDatum(p)));\n\t/* undo change to \\0 */\n\t*p1 = c;\n\tp = ++p1;\n\t/* skip blanks up to '\"', beginning of second date */\n\twhile ((c = *p) != '\\0')\n\t{\n\t\tif (IsSpace(c))\n\t\t\tp++;\n\t\telse if (c != '\"')\n\t\t\tgoto bogus;\t\t\t/* syntax error */\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\tp++;\n\t/* search for the end of the second date and change it to a \\0 */\n\tp1 = p;\n\twhile ((c = *p1) != '\\0')\n\t{\n\t\tif (c == '\"')\n\t\t\tbreak;\n\t\tp1++;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\t*p1 = '\\0';\n\t/* get the second date */\n\t*i_end = DatumGetAbsoluteTime(DirectFunctionCall1(abstimein,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(p)));\n\t/* undo change to \\0 */\n\t*p1 = c;\n\tp = ++p1;\n\t/* skip blanks up to ']' */\n\twhile ((c = *p) != '\\0')\n\t{\n\t\tif (IsSpace(c))\n\t\t\tp++;\n\t\telse if (c != ']')\n\t\t\tgoto bogus;\t\t\t/* syntax error */\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\tp++;\n\tc = *p;\n\tif (c != '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\n\t/* it seems to be a valid tinterval */\n\treturn;\n\nbogus:\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\"tinterval\", i_string)));\n\t*i_start = *i_end = INVALID_ABSTIME;\t/* keep compiler quiet */\n}"
  },
  {
    "function_name": "tintervalend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1404-1412",
    "snippet": "Datum\ntintervalend(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i = PG_GETARG_TIMEINTERVAL(0);\n\n\tif (i->status == T_INTERVAL_INVAL)\n\t\tPG_RETURN_ABSOLUTETIME(INVALID_ABSTIME);\n\tPG_RETURN_ABSOLUTETIME(i->data[1]);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ABSOLUTETIME",
          "args": [
            "i->data[1]"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_ABSOLUTETIME",
          "args": [
            "INVALID_ABSTIME"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nDatum\ntintervalend(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i = PG_GETARG_TIMEINTERVAL(0);\n\n\tif (i->status == T_INTERVAL_INVAL)\n\t\tPG_RETURN_ABSOLUTETIME(INVALID_ABSTIME);\n\tPG_RETURN_ABSOLUTETIME(i->data[1]);\n}"
  },
  {
    "function_name": "tintervalstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1391-1399",
    "snippet": "Datum\ntintervalstart(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i = PG_GETARG_TIMEINTERVAL(0);\n\n\tif (i->status == T_INTERVAL_INVAL)\n\t\tPG_RETURN_ABSOLUTETIME(INVALID_ABSTIME);\n\tPG_RETURN_ABSOLUTETIME(i->data[0]);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ABSOLUTETIME",
          "args": [
            "i->data[0]"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_ABSOLUTETIME",
          "args": [
            "INVALID_ABSTIME"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nDatum\ntintervalstart(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i = PG_GETARG_TIMEINTERVAL(0);\n\n\tif (i->status == T_INTERVAL_INVAL)\n\t\tPG_RETURN_ABSOLUTETIME(INVALID_ABSTIME);\n\tPG_RETURN_ABSOLUTETIME(i->data[0]);\n}"
  },
  {
    "function_name": "tintervalov",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1370-1386",
    "snippet": "Datum\ntintervalov(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i1 = PG_GETARG_TIMEINTERVAL(0);\n\tTimeInterval i2 = PG_GETARG_TIMEINTERVAL(1);\n\n\tif (i1->status == T_INTERVAL_INVAL || i2->status == T_INTERVAL_INVAL)\n\t\tPG_RETURN_BOOL(false);\n\tif (DatumGetBool(DirectFunctionCall2(abstimelt,\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i1->data[1]),\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i2->data[0]))) ||\n\t\tDatumGetBool(DirectFunctionCall2(abstimegt,\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i1->data[0]),\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i2->data[1]))))\n\t\tPG_RETURN_BOOL(false);\n\tPG_RETURN_BOOL(true);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(abstimegt,\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i1->data[0]),\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i2->data[1]))"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "abstimegt",
            "AbsoluteTimeGetDatum(i1->data[0])",
            "AbsoluteTimeGetDatum(i2->data[1])"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeGetDatum",
          "args": [
            "i2->data[1]"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeGetDatum",
          "args": [
            "i1->data[0]"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(abstimelt,\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i1->data[1]),\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i2->data[0]))"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "abstimelt",
            "AbsoluteTimeGetDatum(i1->data[1])",
            "AbsoluteTimeGetDatum(i2->data[0])"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeGetDatum",
          "args": [
            "i2->data[0]"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeGetDatum",
          "args": [
            "i1->data[1]"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "1"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nDatum\ntintervalov(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i1 = PG_GETARG_TIMEINTERVAL(0);\n\tTimeInterval i2 = PG_GETARG_TIMEINTERVAL(1);\n\n\tif (i1->status == T_INTERVAL_INVAL || i2->status == T_INTERVAL_INVAL)\n\t\tPG_RETURN_BOOL(false);\n\tif (DatumGetBool(DirectFunctionCall2(abstimelt,\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i1->data[1]),\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i2->data[0]))) ||\n\t\tDatumGetBool(DirectFunctionCall2(abstimegt,\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i1->data[0]),\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i2->data[1]))))\n\t\tPG_RETURN_BOOL(false);\n\tPG_RETURN_BOOL(true);\n}"
  },
  {
    "function_name": "tintervalct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1349-1365",
    "snippet": "Datum\ntintervalct(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i1 = PG_GETARG_TIMEINTERVAL(0);\n\tTimeInterval i2 = PG_GETARG_TIMEINTERVAL(1);\n\n\tif (i1->status == T_INTERVAL_INVAL || i2->status == T_INTERVAL_INVAL)\n\t\tPG_RETURN_BOOL(false);\n\tif (DatumGetBool(DirectFunctionCall2(abstimele,\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i1->data[0]),\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i2->data[0]))) &&\n\t\tDatumGetBool(DirectFunctionCall2(abstimege,\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i1->data[1]),\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i2->data[1]))))\n\t\tPG_RETURN_BOOL(true);\n\tPG_RETURN_BOOL(false);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(abstimege,\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i1->data[1]),\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i2->data[1]))"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "abstimege",
            "AbsoluteTimeGetDatum(i1->data[1])",
            "AbsoluteTimeGetDatum(i2->data[1])"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeGetDatum",
          "args": [
            "i2->data[1]"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeGetDatum",
          "args": [
            "i1->data[1]"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(abstimele,\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i1->data[0]),\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i2->data[0]))"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "abstimele",
            "AbsoluteTimeGetDatum(i1->data[0])",
            "AbsoluteTimeGetDatum(i2->data[0])"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeGetDatum",
          "args": [
            "i2->data[0]"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeGetDatum",
          "args": [
            "i1->data[0]"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "1"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nDatum\ntintervalct(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i1 = PG_GETARG_TIMEINTERVAL(0);\n\tTimeInterval i2 = PG_GETARG_TIMEINTERVAL(1);\n\n\tif (i1->status == T_INTERVAL_INVAL || i2->status == T_INTERVAL_INVAL)\n\t\tPG_RETURN_BOOL(false);\n\tif (DatumGetBool(DirectFunctionCall2(abstimele,\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i1->data[0]),\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i2->data[0]))) &&\n\t\tDatumGetBool(DirectFunctionCall2(abstimege,\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i1->data[1]),\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i2->data[1]))))\n\t\tPG_RETURN_BOOL(true);\n\tPG_RETURN_BOOL(false);\n}"
  },
  {
    "function_name": "tintervallenge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1332-1344",
    "snippet": "Datum\ntintervallenge(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i = PG_GETARG_TIMEINTERVAL(0);\n\tRelativeTime t = PG_GETARG_RELATIVETIME(1);\n\tRelativeTime rt;\n\n\tif (i->status == T_INTERVAL_INVAL || t == INVALID_RELTIME)\n\t\tPG_RETURN_BOOL(false);\n\trt = DatumGetRelativeTime(DirectFunctionCall1(tintervalrel,\n\t\t\t\t\t\t\t\t\t\t\t\t  TimeIntervalGetDatum(i)));\n\tPG_RETURN_BOOL(rt != INVALID_RELTIME && rt >= t);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "rt != INVALID_RELTIME && rt >= t"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRelativeTime",
          "args": [
            "DirectFunctionCall1(tintervalrel,\n\t\t\t\t\t\t\t\t\t\t\t\t  TimeIntervalGetDatum(i))"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "tintervalrel",
            "TimeIntervalGetDatum(i)"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimeIntervalGetDatum",
          "args": [
            "i"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "1"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nDatum\ntintervallenge(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i = PG_GETARG_TIMEINTERVAL(0);\n\tRelativeTime t = PG_GETARG_RELATIVETIME(1);\n\tRelativeTime rt;\n\n\tif (i->status == T_INTERVAL_INVAL || t == INVALID_RELTIME)\n\t\tPG_RETURN_BOOL(false);\n\trt = DatumGetRelativeTime(DirectFunctionCall1(tintervalrel,\n\t\t\t\t\t\t\t\t\t\t\t\t  TimeIntervalGetDatum(i)));\n\tPG_RETURN_BOOL(rt != INVALID_RELTIME && rt >= t);\n}"
  },
  {
    "function_name": "tintervallenle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1318-1330",
    "snippet": "Datum\ntintervallenle(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i = PG_GETARG_TIMEINTERVAL(0);\n\tRelativeTime t = PG_GETARG_RELATIVETIME(1);\n\tRelativeTime rt;\n\n\tif (i->status == T_INTERVAL_INVAL || t == INVALID_RELTIME)\n\t\tPG_RETURN_BOOL(false);\n\trt = DatumGetRelativeTime(DirectFunctionCall1(tintervalrel,\n\t\t\t\t\t\t\t\t\t\t\t\t  TimeIntervalGetDatum(i)));\n\tPG_RETURN_BOOL(rt != INVALID_RELTIME && rt <= t);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "rt != INVALID_RELTIME && rt <= t"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRelativeTime",
          "args": [
            "DirectFunctionCall1(tintervalrel,\n\t\t\t\t\t\t\t\t\t\t\t\t  TimeIntervalGetDatum(i))"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "tintervalrel",
            "TimeIntervalGetDatum(i)"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimeIntervalGetDatum",
          "args": [
            "i"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "1"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nDatum\ntintervallenle(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i = PG_GETARG_TIMEINTERVAL(0);\n\tRelativeTime t = PG_GETARG_RELATIVETIME(1);\n\tRelativeTime rt;\n\n\tif (i->status == T_INTERVAL_INVAL || t == INVALID_RELTIME)\n\t\tPG_RETURN_BOOL(false);\n\trt = DatumGetRelativeTime(DirectFunctionCall1(tintervalrel,\n\t\t\t\t\t\t\t\t\t\t\t\t  TimeIntervalGetDatum(i)));\n\tPG_RETURN_BOOL(rt != INVALID_RELTIME && rt <= t);\n}"
  },
  {
    "function_name": "tintervallengt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1304-1316",
    "snippet": "Datum\ntintervallengt(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i = PG_GETARG_TIMEINTERVAL(0);\n\tRelativeTime t = PG_GETARG_RELATIVETIME(1);\n\tRelativeTime rt;\n\n\tif (i->status == T_INTERVAL_INVAL || t == INVALID_RELTIME)\n\t\tPG_RETURN_BOOL(false);\n\trt = DatumGetRelativeTime(DirectFunctionCall1(tintervalrel,\n\t\t\t\t\t\t\t\t\t\t\t\t  TimeIntervalGetDatum(i)));\n\tPG_RETURN_BOOL(rt != INVALID_RELTIME && rt > t);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "rt != INVALID_RELTIME && rt > t"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRelativeTime",
          "args": [
            "DirectFunctionCall1(tintervalrel,\n\t\t\t\t\t\t\t\t\t\t\t\t  TimeIntervalGetDatum(i))"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "tintervalrel",
            "TimeIntervalGetDatum(i)"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimeIntervalGetDatum",
          "args": [
            "i"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "1"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nDatum\ntintervallengt(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i = PG_GETARG_TIMEINTERVAL(0);\n\tRelativeTime t = PG_GETARG_RELATIVETIME(1);\n\tRelativeTime rt;\n\n\tif (i->status == T_INTERVAL_INVAL || t == INVALID_RELTIME)\n\t\tPG_RETURN_BOOL(false);\n\trt = DatumGetRelativeTime(DirectFunctionCall1(tintervalrel,\n\t\t\t\t\t\t\t\t\t\t\t\t  TimeIntervalGetDatum(i)));\n\tPG_RETURN_BOOL(rt != INVALID_RELTIME && rt > t);\n}"
  },
  {
    "function_name": "tintervallenlt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1290-1302",
    "snippet": "Datum\ntintervallenlt(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i = PG_GETARG_TIMEINTERVAL(0);\n\tRelativeTime t = PG_GETARG_RELATIVETIME(1);\n\tRelativeTime rt;\n\n\tif (i->status == T_INTERVAL_INVAL || t == INVALID_RELTIME)\n\t\tPG_RETURN_BOOL(false);\n\trt = DatumGetRelativeTime(DirectFunctionCall1(tintervalrel,\n\t\t\t\t\t\t\t\t\t\t\t\t  TimeIntervalGetDatum(i)));\n\tPG_RETURN_BOOL(rt != INVALID_RELTIME && rt < t);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "rt != INVALID_RELTIME && rt < t"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRelativeTime",
          "args": [
            "DirectFunctionCall1(tintervalrel,\n\t\t\t\t\t\t\t\t\t\t\t\t  TimeIntervalGetDatum(i))"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "tintervalrel",
            "TimeIntervalGetDatum(i)"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimeIntervalGetDatum",
          "args": [
            "i"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "1"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nDatum\ntintervallenlt(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i = PG_GETARG_TIMEINTERVAL(0);\n\tRelativeTime t = PG_GETARG_RELATIVETIME(1);\n\tRelativeTime rt;\n\n\tif (i->status == T_INTERVAL_INVAL || t == INVALID_RELTIME)\n\t\tPG_RETURN_BOOL(false);\n\trt = DatumGetRelativeTime(DirectFunctionCall1(tintervalrel,\n\t\t\t\t\t\t\t\t\t\t\t\t  TimeIntervalGetDatum(i)));\n\tPG_RETURN_BOOL(rt != INVALID_RELTIME && rt < t);\n}"
  },
  {
    "function_name": "tintervallenne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1276-1288",
    "snippet": "Datum\ntintervallenne(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i = PG_GETARG_TIMEINTERVAL(0);\n\tRelativeTime t = PG_GETARG_RELATIVETIME(1);\n\tRelativeTime rt;\n\n\tif (i->status == T_INTERVAL_INVAL || t == INVALID_RELTIME)\n\t\tPG_RETURN_BOOL(false);\n\trt = DatumGetRelativeTime(DirectFunctionCall1(tintervalrel,\n\t\t\t\t\t\t\t\t\t\t\t\t  TimeIntervalGetDatum(i)));\n\tPG_RETURN_BOOL(rt != INVALID_RELTIME && rt != t);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "rt != INVALID_RELTIME && rt != t"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRelativeTime",
          "args": [
            "DirectFunctionCall1(tintervalrel,\n\t\t\t\t\t\t\t\t\t\t\t\t  TimeIntervalGetDatum(i))"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "tintervalrel",
            "TimeIntervalGetDatum(i)"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimeIntervalGetDatum",
          "args": [
            "i"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "1"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nDatum\ntintervallenne(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i = PG_GETARG_TIMEINTERVAL(0);\n\tRelativeTime t = PG_GETARG_RELATIVETIME(1);\n\tRelativeTime rt;\n\n\tif (i->status == T_INTERVAL_INVAL || t == INVALID_RELTIME)\n\t\tPG_RETURN_BOOL(false);\n\trt = DatumGetRelativeTime(DirectFunctionCall1(tintervalrel,\n\t\t\t\t\t\t\t\t\t\t\t\t  TimeIntervalGetDatum(i)));\n\tPG_RETURN_BOOL(rt != INVALID_RELTIME && rt != t);\n}"
  },
  {
    "function_name": "tintervalleneq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1262-1274",
    "snippet": "Datum\ntintervalleneq(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i = PG_GETARG_TIMEINTERVAL(0);\n\tRelativeTime t = PG_GETARG_RELATIVETIME(1);\n\tRelativeTime rt;\n\n\tif (i->status == T_INTERVAL_INVAL || t == INVALID_RELTIME)\n\t\tPG_RETURN_BOOL(false);\n\trt = DatumGetRelativeTime(DirectFunctionCall1(tintervalrel,\n\t\t\t\t\t\t\t\t\t\t\t\t  TimeIntervalGetDatum(i)));\n\tPG_RETURN_BOOL(rt != INVALID_RELTIME && rt == t);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "rt != INVALID_RELTIME && rt == t"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRelativeTime",
          "args": [
            "DirectFunctionCall1(tintervalrel,\n\t\t\t\t\t\t\t\t\t\t\t\t  TimeIntervalGetDatum(i))"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "tintervalrel",
            "TimeIntervalGetDatum(i)"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TimeIntervalGetDatum",
          "args": [
            "i"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "1"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nDatum\ntintervalleneq(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i = PG_GETARG_TIMEINTERVAL(0);\n\tRelativeTime t = PG_GETARG_RELATIVETIME(1);\n\tRelativeTime rt;\n\n\tif (i->status == T_INTERVAL_INVAL || t == INVALID_RELTIME)\n\t\tPG_RETURN_BOOL(false);\n\trt = DatumGetRelativeTime(DirectFunctionCall1(tintervalrel,\n\t\t\t\t\t\t\t\t\t\t\t\t  TimeIntervalGetDatum(i)));\n\tPG_RETURN_BOOL(rt != INVALID_RELTIME && rt == t);\n}"
  },
  {
    "function_name": "bttintervalcmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1238-1245",
    "snippet": "Datum\nbttintervalcmp(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i1 = PG_GETARG_TIMEINTERVAL(0);\n\tTimeInterval i2 = PG_GETARG_TIMEINTERVAL(1);\n\n\tPG_RETURN_INT32(tinterval_cmp_internal(i1, i2));\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "tinterval_cmp_internal(i1, i2)"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tinterval_cmp_internal",
          "args": [
            "i1",
            "i2"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "tinterval_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "1142-1182",
          "snippet": "static int\ntinterval_cmp_internal(TimeInterval a, TimeInterval b)\n{\n\tbool\t\ta_invalid;\n\tbool\t\tb_invalid;\n\tAbsoluteTime a_len;\n\tAbsoluteTime b_len;\n\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\ta_invalid = a->status == T_INTERVAL_INVAL ||\n\t\ta->data[0] == INVALID_ABSTIME ||\n\t\ta->data[1] == INVALID_ABSTIME;\n\tb_invalid = b->status == T_INTERVAL_INVAL ||\n\t\tb->data[0] == INVALID_ABSTIME ||\n\t\tb->data[1] == INVALID_ABSTIME;\n\n\tif (a_invalid)\n\t{\n\t\tif (b_invalid)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b_invalid)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\ta_len = a->data[1] - a->data[0];\n\tb_len = b->data[1] - b->data[0];\n\n\tif (a_len > b_len)\n\t\treturn 1;\n\telse if (a_len == b_len)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nstatic int\ntinterval_cmp_internal(TimeInterval a, TimeInterval b)\n{\n\tbool\t\ta_invalid;\n\tbool\t\tb_invalid;\n\tAbsoluteTime a_len;\n\tAbsoluteTime b_len;\n\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\ta_invalid = a->status == T_INTERVAL_INVAL ||\n\t\ta->data[0] == INVALID_ABSTIME ||\n\t\ta->data[1] == INVALID_ABSTIME;\n\tb_invalid = b->status == T_INTERVAL_INVAL ||\n\t\tb->data[0] == INVALID_ABSTIME ||\n\t\tb->data[1] == INVALID_ABSTIME;\n\n\tif (a_invalid)\n\t{\n\t\tif (b_invalid)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b_invalid)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\ta_len = a->data[1] - a->data[0];\n\tb_len = b->data[1] - b->data[0];\n\n\tif (a_len > b_len)\n\t\treturn 1;\n\telse if (a_len == b_len)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "1"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nbttintervalcmp(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i1 = PG_GETARG_TIMEINTERVAL(0);\n\tTimeInterval i2 = PG_GETARG_TIMEINTERVAL(1);\n\n\tPG_RETURN_INT32(tinterval_cmp_internal(i1, i2));\n}"
  },
  {
    "function_name": "tintervalge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1229-1236",
    "snippet": "Datum\ntintervalge(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i1 = PG_GETARG_TIMEINTERVAL(0);\n\tTimeInterval i2 = PG_GETARG_TIMEINTERVAL(1);\n\n\tPG_RETURN_BOOL(tinterval_cmp_internal(i1, i2) >= 0);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "tinterval_cmp_internal(i1, i2) >= 0"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tinterval_cmp_internal",
          "args": [
            "i1",
            "i2"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "tinterval_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "1142-1182",
          "snippet": "static int\ntinterval_cmp_internal(TimeInterval a, TimeInterval b)\n{\n\tbool\t\ta_invalid;\n\tbool\t\tb_invalid;\n\tAbsoluteTime a_len;\n\tAbsoluteTime b_len;\n\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\ta_invalid = a->status == T_INTERVAL_INVAL ||\n\t\ta->data[0] == INVALID_ABSTIME ||\n\t\ta->data[1] == INVALID_ABSTIME;\n\tb_invalid = b->status == T_INTERVAL_INVAL ||\n\t\tb->data[0] == INVALID_ABSTIME ||\n\t\tb->data[1] == INVALID_ABSTIME;\n\n\tif (a_invalid)\n\t{\n\t\tif (b_invalid)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b_invalid)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\ta_len = a->data[1] - a->data[0];\n\tb_len = b->data[1] - b->data[0];\n\n\tif (a_len > b_len)\n\t\treturn 1;\n\telse if (a_len == b_len)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nstatic int\ntinterval_cmp_internal(TimeInterval a, TimeInterval b)\n{\n\tbool\t\ta_invalid;\n\tbool\t\tb_invalid;\n\tAbsoluteTime a_len;\n\tAbsoluteTime b_len;\n\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\ta_invalid = a->status == T_INTERVAL_INVAL ||\n\t\ta->data[0] == INVALID_ABSTIME ||\n\t\ta->data[1] == INVALID_ABSTIME;\n\tb_invalid = b->status == T_INTERVAL_INVAL ||\n\t\tb->data[0] == INVALID_ABSTIME ||\n\t\tb->data[1] == INVALID_ABSTIME;\n\n\tif (a_invalid)\n\t{\n\t\tif (b_invalid)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b_invalid)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\ta_len = a->data[1] - a->data[0];\n\tb_len = b->data[1] - b->data[0];\n\n\tif (a_len > b_len)\n\t\treturn 1;\n\telse if (a_len == b_len)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "1"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntintervalge(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i1 = PG_GETARG_TIMEINTERVAL(0);\n\tTimeInterval i2 = PG_GETARG_TIMEINTERVAL(1);\n\n\tPG_RETURN_BOOL(tinterval_cmp_internal(i1, i2) >= 0);\n}"
  },
  {
    "function_name": "tintervalgt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1220-1227",
    "snippet": "Datum\ntintervalgt(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i1 = PG_GETARG_TIMEINTERVAL(0);\n\tTimeInterval i2 = PG_GETARG_TIMEINTERVAL(1);\n\n\tPG_RETURN_BOOL(tinterval_cmp_internal(i1, i2) > 0);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "tinterval_cmp_internal(i1, i2) > 0"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tinterval_cmp_internal",
          "args": [
            "i1",
            "i2"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "tinterval_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "1142-1182",
          "snippet": "static int\ntinterval_cmp_internal(TimeInterval a, TimeInterval b)\n{\n\tbool\t\ta_invalid;\n\tbool\t\tb_invalid;\n\tAbsoluteTime a_len;\n\tAbsoluteTime b_len;\n\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\ta_invalid = a->status == T_INTERVAL_INVAL ||\n\t\ta->data[0] == INVALID_ABSTIME ||\n\t\ta->data[1] == INVALID_ABSTIME;\n\tb_invalid = b->status == T_INTERVAL_INVAL ||\n\t\tb->data[0] == INVALID_ABSTIME ||\n\t\tb->data[1] == INVALID_ABSTIME;\n\n\tif (a_invalid)\n\t{\n\t\tif (b_invalid)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b_invalid)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\ta_len = a->data[1] - a->data[0];\n\tb_len = b->data[1] - b->data[0];\n\n\tif (a_len > b_len)\n\t\treturn 1;\n\telse if (a_len == b_len)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nstatic int\ntinterval_cmp_internal(TimeInterval a, TimeInterval b)\n{\n\tbool\t\ta_invalid;\n\tbool\t\tb_invalid;\n\tAbsoluteTime a_len;\n\tAbsoluteTime b_len;\n\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\ta_invalid = a->status == T_INTERVAL_INVAL ||\n\t\ta->data[0] == INVALID_ABSTIME ||\n\t\ta->data[1] == INVALID_ABSTIME;\n\tb_invalid = b->status == T_INTERVAL_INVAL ||\n\t\tb->data[0] == INVALID_ABSTIME ||\n\t\tb->data[1] == INVALID_ABSTIME;\n\n\tif (a_invalid)\n\t{\n\t\tif (b_invalid)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b_invalid)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\ta_len = a->data[1] - a->data[0];\n\tb_len = b->data[1] - b->data[0];\n\n\tif (a_len > b_len)\n\t\treturn 1;\n\telse if (a_len == b_len)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "1"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntintervalgt(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i1 = PG_GETARG_TIMEINTERVAL(0);\n\tTimeInterval i2 = PG_GETARG_TIMEINTERVAL(1);\n\n\tPG_RETURN_BOOL(tinterval_cmp_internal(i1, i2) > 0);\n}"
  },
  {
    "function_name": "tintervalle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1211-1218",
    "snippet": "Datum\ntintervalle(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i1 = PG_GETARG_TIMEINTERVAL(0);\n\tTimeInterval i2 = PG_GETARG_TIMEINTERVAL(1);\n\n\tPG_RETURN_BOOL(tinterval_cmp_internal(i1, i2) <= 0);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "tinterval_cmp_internal(i1, i2) <= 0"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tinterval_cmp_internal",
          "args": [
            "i1",
            "i2"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "tinterval_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "1142-1182",
          "snippet": "static int\ntinterval_cmp_internal(TimeInterval a, TimeInterval b)\n{\n\tbool\t\ta_invalid;\n\tbool\t\tb_invalid;\n\tAbsoluteTime a_len;\n\tAbsoluteTime b_len;\n\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\ta_invalid = a->status == T_INTERVAL_INVAL ||\n\t\ta->data[0] == INVALID_ABSTIME ||\n\t\ta->data[1] == INVALID_ABSTIME;\n\tb_invalid = b->status == T_INTERVAL_INVAL ||\n\t\tb->data[0] == INVALID_ABSTIME ||\n\t\tb->data[1] == INVALID_ABSTIME;\n\n\tif (a_invalid)\n\t{\n\t\tif (b_invalid)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b_invalid)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\ta_len = a->data[1] - a->data[0];\n\tb_len = b->data[1] - b->data[0];\n\n\tif (a_len > b_len)\n\t\treturn 1;\n\telse if (a_len == b_len)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nstatic int\ntinterval_cmp_internal(TimeInterval a, TimeInterval b)\n{\n\tbool\t\ta_invalid;\n\tbool\t\tb_invalid;\n\tAbsoluteTime a_len;\n\tAbsoluteTime b_len;\n\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\ta_invalid = a->status == T_INTERVAL_INVAL ||\n\t\ta->data[0] == INVALID_ABSTIME ||\n\t\ta->data[1] == INVALID_ABSTIME;\n\tb_invalid = b->status == T_INTERVAL_INVAL ||\n\t\tb->data[0] == INVALID_ABSTIME ||\n\t\tb->data[1] == INVALID_ABSTIME;\n\n\tif (a_invalid)\n\t{\n\t\tif (b_invalid)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b_invalid)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\ta_len = a->data[1] - a->data[0];\n\tb_len = b->data[1] - b->data[0];\n\n\tif (a_len > b_len)\n\t\treturn 1;\n\telse if (a_len == b_len)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "1"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntintervalle(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i1 = PG_GETARG_TIMEINTERVAL(0);\n\tTimeInterval i2 = PG_GETARG_TIMEINTERVAL(1);\n\n\tPG_RETURN_BOOL(tinterval_cmp_internal(i1, i2) <= 0);\n}"
  },
  {
    "function_name": "tintervallt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1202-1209",
    "snippet": "Datum\ntintervallt(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i1 = PG_GETARG_TIMEINTERVAL(0);\n\tTimeInterval i2 = PG_GETARG_TIMEINTERVAL(1);\n\n\tPG_RETURN_BOOL(tinterval_cmp_internal(i1, i2) < 0);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "tinterval_cmp_internal(i1, i2) < 0"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tinterval_cmp_internal",
          "args": [
            "i1",
            "i2"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "tinterval_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "1142-1182",
          "snippet": "static int\ntinterval_cmp_internal(TimeInterval a, TimeInterval b)\n{\n\tbool\t\ta_invalid;\n\tbool\t\tb_invalid;\n\tAbsoluteTime a_len;\n\tAbsoluteTime b_len;\n\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\ta_invalid = a->status == T_INTERVAL_INVAL ||\n\t\ta->data[0] == INVALID_ABSTIME ||\n\t\ta->data[1] == INVALID_ABSTIME;\n\tb_invalid = b->status == T_INTERVAL_INVAL ||\n\t\tb->data[0] == INVALID_ABSTIME ||\n\t\tb->data[1] == INVALID_ABSTIME;\n\n\tif (a_invalid)\n\t{\n\t\tif (b_invalid)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b_invalid)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\ta_len = a->data[1] - a->data[0];\n\tb_len = b->data[1] - b->data[0];\n\n\tif (a_len > b_len)\n\t\treturn 1;\n\telse if (a_len == b_len)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nstatic int\ntinterval_cmp_internal(TimeInterval a, TimeInterval b)\n{\n\tbool\t\ta_invalid;\n\tbool\t\tb_invalid;\n\tAbsoluteTime a_len;\n\tAbsoluteTime b_len;\n\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\ta_invalid = a->status == T_INTERVAL_INVAL ||\n\t\ta->data[0] == INVALID_ABSTIME ||\n\t\ta->data[1] == INVALID_ABSTIME;\n\tb_invalid = b->status == T_INTERVAL_INVAL ||\n\t\tb->data[0] == INVALID_ABSTIME ||\n\t\tb->data[1] == INVALID_ABSTIME;\n\n\tif (a_invalid)\n\t{\n\t\tif (b_invalid)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b_invalid)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\ta_len = a->data[1] - a->data[0];\n\tb_len = b->data[1] - b->data[0];\n\n\tif (a_len > b_len)\n\t\treturn 1;\n\telse if (a_len == b_len)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "1"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntintervallt(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i1 = PG_GETARG_TIMEINTERVAL(0);\n\tTimeInterval i2 = PG_GETARG_TIMEINTERVAL(1);\n\n\tPG_RETURN_BOOL(tinterval_cmp_internal(i1, i2) < 0);\n}"
  },
  {
    "function_name": "tintervalne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1193-1200",
    "snippet": "Datum\ntintervalne(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i1 = PG_GETARG_TIMEINTERVAL(0);\n\tTimeInterval i2 = PG_GETARG_TIMEINTERVAL(1);\n\n\tPG_RETURN_BOOL(tinterval_cmp_internal(i1, i2) != 0);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "tinterval_cmp_internal(i1, i2) != 0"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tinterval_cmp_internal",
          "args": [
            "i1",
            "i2"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "tinterval_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "1142-1182",
          "snippet": "static int\ntinterval_cmp_internal(TimeInterval a, TimeInterval b)\n{\n\tbool\t\ta_invalid;\n\tbool\t\tb_invalid;\n\tAbsoluteTime a_len;\n\tAbsoluteTime b_len;\n\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\ta_invalid = a->status == T_INTERVAL_INVAL ||\n\t\ta->data[0] == INVALID_ABSTIME ||\n\t\ta->data[1] == INVALID_ABSTIME;\n\tb_invalid = b->status == T_INTERVAL_INVAL ||\n\t\tb->data[0] == INVALID_ABSTIME ||\n\t\tb->data[1] == INVALID_ABSTIME;\n\n\tif (a_invalid)\n\t{\n\t\tif (b_invalid)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b_invalid)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\ta_len = a->data[1] - a->data[0];\n\tb_len = b->data[1] - b->data[0];\n\n\tif (a_len > b_len)\n\t\treturn 1;\n\telse if (a_len == b_len)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nstatic int\ntinterval_cmp_internal(TimeInterval a, TimeInterval b)\n{\n\tbool\t\ta_invalid;\n\tbool\t\tb_invalid;\n\tAbsoluteTime a_len;\n\tAbsoluteTime b_len;\n\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\ta_invalid = a->status == T_INTERVAL_INVAL ||\n\t\ta->data[0] == INVALID_ABSTIME ||\n\t\ta->data[1] == INVALID_ABSTIME;\n\tb_invalid = b->status == T_INTERVAL_INVAL ||\n\t\tb->data[0] == INVALID_ABSTIME ||\n\t\tb->data[1] == INVALID_ABSTIME;\n\n\tif (a_invalid)\n\t{\n\t\tif (b_invalid)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b_invalid)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\ta_len = a->data[1] - a->data[0];\n\tb_len = b->data[1] - b->data[0];\n\n\tif (a_len > b_len)\n\t\treturn 1;\n\telse if (a_len == b_len)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "1"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntintervalne(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i1 = PG_GETARG_TIMEINTERVAL(0);\n\tTimeInterval i2 = PG_GETARG_TIMEINTERVAL(1);\n\n\tPG_RETURN_BOOL(tinterval_cmp_internal(i1, i2) != 0);\n}"
  },
  {
    "function_name": "tintervaleq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1184-1191",
    "snippet": "Datum\ntintervaleq(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i1 = PG_GETARG_TIMEINTERVAL(0);\n\tTimeInterval i2 = PG_GETARG_TIMEINTERVAL(1);\n\n\tPG_RETURN_BOOL(tinterval_cmp_internal(i1, i2) == 0);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "tinterval_cmp_internal(i1, i2) == 0"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tinterval_cmp_internal",
          "args": [
            "i1",
            "i2"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "tinterval_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "1142-1182",
          "snippet": "static int\ntinterval_cmp_internal(TimeInterval a, TimeInterval b)\n{\n\tbool\t\ta_invalid;\n\tbool\t\tb_invalid;\n\tAbsoluteTime a_len;\n\tAbsoluteTime b_len;\n\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\ta_invalid = a->status == T_INTERVAL_INVAL ||\n\t\ta->data[0] == INVALID_ABSTIME ||\n\t\ta->data[1] == INVALID_ABSTIME;\n\tb_invalid = b->status == T_INTERVAL_INVAL ||\n\t\tb->data[0] == INVALID_ABSTIME ||\n\t\tb->data[1] == INVALID_ABSTIME;\n\n\tif (a_invalid)\n\t{\n\t\tif (b_invalid)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b_invalid)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\ta_len = a->data[1] - a->data[0];\n\tb_len = b->data[1] - b->data[0];\n\n\tif (a_len > b_len)\n\t\treturn 1;\n\telse if (a_len == b_len)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nstatic int\ntinterval_cmp_internal(TimeInterval a, TimeInterval b)\n{\n\tbool\t\ta_invalid;\n\tbool\t\tb_invalid;\n\tAbsoluteTime a_len;\n\tAbsoluteTime b_len;\n\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\ta_invalid = a->status == T_INTERVAL_INVAL ||\n\t\ta->data[0] == INVALID_ABSTIME ||\n\t\ta->data[1] == INVALID_ABSTIME;\n\tb_invalid = b->status == T_INTERVAL_INVAL ||\n\t\tb->data[0] == INVALID_ABSTIME ||\n\t\tb->data[1] == INVALID_ABSTIME;\n\n\tif (a_invalid)\n\t{\n\t\tif (b_invalid)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b_invalid)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\ta_len = a->data[1] - a->data[0];\n\tb_len = b->data[1] - b->data[0];\n\n\tif (a_len > b_len)\n\t\treturn 1;\n\telse if (a_len == b_len)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "1"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntintervaleq(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i1 = PG_GETARG_TIMEINTERVAL(0);\n\tTimeInterval i2 = PG_GETARG_TIMEINTERVAL(1);\n\n\tPG_RETURN_BOOL(tinterval_cmp_internal(i1, i2) == 0);\n}"
  },
  {
    "function_name": "tinterval_cmp_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1142-1182",
    "snippet": "static int\ntinterval_cmp_internal(TimeInterval a, TimeInterval b)\n{\n\tbool\t\ta_invalid;\n\tbool\t\tb_invalid;\n\tAbsoluteTime a_len;\n\tAbsoluteTime b_len;\n\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\ta_invalid = a->status == T_INTERVAL_INVAL ||\n\t\ta->data[0] == INVALID_ABSTIME ||\n\t\ta->data[1] == INVALID_ABSTIME;\n\tb_invalid = b->status == T_INTERVAL_INVAL ||\n\t\tb->data[0] == INVALID_ABSTIME ||\n\t\tb->data[1] == INVALID_ABSTIME;\n\n\tif (a_invalid)\n\t{\n\t\tif (b_invalid)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b_invalid)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\ta_len = a->data[1] - a->data[0];\n\tb_len = b->data[1] - b->data[0];\n\n\tif (a_len > b_len)\n\t\treturn 1;\n\telse if (a_len == b_len)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nstatic int\ntinterval_cmp_internal(TimeInterval a, TimeInterval b)\n{\n\tbool\t\ta_invalid;\n\tbool\t\tb_invalid;\n\tAbsoluteTime a_len;\n\tAbsoluteTime b_len;\n\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\ta_invalid = a->status == T_INTERVAL_INVAL ||\n\t\ta->data[0] == INVALID_ABSTIME ||\n\t\ta->data[1] == INVALID_ABSTIME;\n\tb_invalid = b->status == T_INTERVAL_INVAL ||\n\t\tb->data[0] == INVALID_ABSTIME ||\n\t\tb->data[1] == INVALID_ABSTIME;\n\n\tif (a_invalid)\n\t{\n\t\tif (b_invalid)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b_invalid)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\ta_len = a->data[1] - a->data[0];\n\tb_len = b->data[1] - b->data[0];\n\n\tif (a_len > b_len)\n\t\treturn 1;\n\telse if (a_len == b_len)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
  },
  {
    "function_name": "tintervalsame",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1103-1120",
    "snippet": "Datum\ntintervalsame(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i1 = PG_GETARG_TIMEINTERVAL(0);\n\tTimeInterval i2 = PG_GETARG_TIMEINTERVAL(1);\n\n\tif (i1->status == T_INTERVAL_INVAL || i2->status == T_INTERVAL_INVAL)\n\t\tPG_RETURN_BOOL(false);\n\n\tif (DatumGetBool(DirectFunctionCall2(abstimeeq,\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i1->data[0]),\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i2->data[0]))) &&\n\t\tDatumGetBool(DirectFunctionCall2(abstimeeq,\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i1->data[1]),\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i2->data[1]))))\n\t\tPG_RETURN_BOOL(true);\n\tPG_RETURN_BOOL(false);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(abstimeeq,\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i1->data[1]),\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i2->data[1]))"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "abstimeeq",
            "AbsoluteTimeGetDatum(i1->data[1])",
            "AbsoluteTimeGetDatum(i2->data[1])"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeGetDatum",
          "args": [
            "i2->data[1]"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeGetDatum",
          "args": [
            "i1->data[1]"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(abstimeeq,\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i1->data[0]),\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i2->data[0]))"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "abstimeeq",
            "AbsoluteTimeGetDatum(i1->data[0])",
            "AbsoluteTimeGetDatum(i2->data[0])"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeGetDatum",
          "args": [
            "i2->data[0]"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeGetDatum",
          "args": [
            "i1->data[0]"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "1"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nDatum\ntintervalsame(PG_FUNCTION_ARGS)\n{\n\tTimeInterval i1 = PG_GETARG_TIMEINTERVAL(0);\n\tTimeInterval i2 = PG_GETARG_TIMEINTERVAL(1);\n\n\tif (i1->status == T_INTERVAL_INVAL || i2->status == T_INTERVAL_INVAL)\n\t\tPG_RETURN_BOOL(false);\n\n\tif (DatumGetBool(DirectFunctionCall2(abstimeeq,\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i1->data[0]),\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i2->data[0]))) &&\n\t\tDatumGetBool(DirectFunctionCall2(abstimeeq,\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i1->data[1]),\n\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(i2->data[1]))))\n\t\tPG_RETURN_BOOL(true);\n\tPG_RETURN_BOOL(false);\n}"
  },
  {
    "function_name": "btreltimecmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1089-1096",
    "snippet": "Datum\nbtreltimecmp(PG_FUNCTION_ARGS)\n{\n\tRelativeTime t1 = PG_GETARG_RELATIVETIME(0);\n\tRelativeTime t2 = PG_GETARG_RELATIVETIME(1);\n\n\tPG_RETURN_INT32(reltime_cmp_internal(t1, t2));\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "reltime_cmp_internal(t1, t2)"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reltime_cmp_internal",
          "args": [
            "t1",
            "t2"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "reltime_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "1008-1033",
          "snippet": "static int\nreltime_cmp_internal(RelativeTime a, RelativeTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_RELTIME)\n\t{\n\t\tif (b == INVALID_RELTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_RELTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nreltime_cmp_internal(RelativeTime a, RelativeTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_RELTIME)\n\t{\n\t\tif (b == INVALID_RELTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_RELTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "1"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "0"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nbtreltimecmp(PG_FUNCTION_ARGS)\n{\n\tRelativeTime t1 = PG_GETARG_RELATIVETIME(0);\n\tRelativeTime t2 = PG_GETARG_RELATIVETIME(1);\n\n\tPG_RETURN_INT32(reltime_cmp_internal(t1, t2));\n}"
  },
  {
    "function_name": "reltimege",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1080-1087",
    "snippet": "Datum\nreltimege(PG_FUNCTION_ARGS)\n{\n\tRelativeTime t1 = PG_GETARG_RELATIVETIME(0);\n\tRelativeTime t2 = PG_GETARG_RELATIVETIME(1);\n\n\tPG_RETURN_BOOL(reltime_cmp_internal(t1, t2) >= 0);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "reltime_cmp_internal(t1, t2) >= 0"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reltime_cmp_internal",
          "args": [
            "t1",
            "t2"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "reltime_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "1008-1033",
          "snippet": "static int\nreltime_cmp_internal(RelativeTime a, RelativeTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_RELTIME)\n\t{\n\t\tif (b == INVALID_RELTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_RELTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nreltime_cmp_internal(RelativeTime a, RelativeTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_RELTIME)\n\t{\n\t\tif (b == INVALID_RELTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_RELTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "1"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "0"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nreltimege(PG_FUNCTION_ARGS)\n{\n\tRelativeTime t1 = PG_GETARG_RELATIVETIME(0);\n\tRelativeTime t2 = PG_GETARG_RELATIVETIME(1);\n\n\tPG_RETURN_BOOL(reltime_cmp_internal(t1, t2) >= 0);\n}"
  },
  {
    "function_name": "reltimele",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1071-1078",
    "snippet": "Datum\nreltimele(PG_FUNCTION_ARGS)\n{\n\tRelativeTime t1 = PG_GETARG_RELATIVETIME(0);\n\tRelativeTime t2 = PG_GETARG_RELATIVETIME(1);\n\n\tPG_RETURN_BOOL(reltime_cmp_internal(t1, t2) <= 0);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "reltime_cmp_internal(t1, t2) <= 0"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reltime_cmp_internal",
          "args": [
            "t1",
            "t2"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "reltime_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "1008-1033",
          "snippet": "static int\nreltime_cmp_internal(RelativeTime a, RelativeTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_RELTIME)\n\t{\n\t\tif (b == INVALID_RELTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_RELTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nreltime_cmp_internal(RelativeTime a, RelativeTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_RELTIME)\n\t{\n\t\tif (b == INVALID_RELTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_RELTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "1"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "0"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nreltimele(PG_FUNCTION_ARGS)\n{\n\tRelativeTime t1 = PG_GETARG_RELATIVETIME(0);\n\tRelativeTime t2 = PG_GETARG_RELATIVETIME(1);\n\n\tPG_RETURN_BOOL(reltime_cmp_internal(t1, t2) <= 0);\n}"
  },
  {
    "function_name": "reltimegt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1062-1069",
    "snippet": "Datum\nreltimegt(PG_FUNCTION_ARGS)\n{\n\tRelativeTime t1 = PG_GETARG_RELATIVETIME(0);\n\tRelativeTime t2 = PG_GETARG_RELATIVETIME(1);\n\n\tPG_RETURN_BOOL(reltime_cmp_internal(t1, t2) > 0);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "reltime_cmp_internal(t1, t2) > 0"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reltime_cmp_internal",
          "args": [
            "t1",
            "t2"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "reltime_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "1008-1033",
          "snippet": "static int\nreltime_cmp_internal(RelativeTime a, RelativeTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_RELTIME)\n\t{\n\t\tif (b == INVALID_RELTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_RELTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nreltime_cmp_internal(RelativeTime a, RelativeTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_RELTIME)\n\t{\n\t\tif (b == INVALID_RELTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_RELTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "1"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "0"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nreltimegt(PG_FUNCTION_ARGS)\n{\n\tRelativeTime t1 = PG_GETARG_RELATIVETIME(0);\n\tRelativeTime t2 = PG_GETARG_RELATIVETIME(1);\n\n\tPG_RETURN_BOOL(reltime_cmp_internal(t1, t2) > 0);\n}"
  },
  {
    "function_name": "reltimelt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1053-1060",
    "snippet": "Datum\nreltimelt(PG_FUNCTION_ARGS)\n{\n\tRelativeTime t1 = PG_GETARG_RELATIVETIME(0);\n\tRelativeTime t2 = PG_GETARG_RELATIVETIME(1);\n\n\tPG_RETURN_BOOL(reltime_cmp_internal(t1, t2) < 0);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "reltime_cmp_internal(t1, t2) < 0"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reltime_cmp_internal",
          "args": [
            "t1",
            "t2"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "reltime_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "1008-1033",
          "snippet": "static int\nreltime_cmp_internal(RelativeTime a, RelativeTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_RELTIME)\n\t{\n\t\tif (b == INVALID_RELTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_RELTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nreltime_cmp_internal(RelativeTime a, RelativeTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_RELTIME)\n\t{\n\t\tif (b == INVALID_RELTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_RELTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "1"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "0"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nreltimelt(PG_FUNCTION_ARGS)\n{\n\tRelativeTime t1 = PG_GETARG_RELATIVETIME(0);\n\tRelativeTime t2 = PG_GETARG_RELATIVETIME(1);\n\n\tPG_RETURN_BOOL(reltime_cmp_internal(t1, t2) < 0);\n}"
  },
  {
    "function_name": "reltimene",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1044-1051",
    "snippet": "Datum\nreltimene(PG_FUNCTION_ARGS)\n{\n\tRelativeTime t1 = PG_GETARG_RELATIVETIME(0);\n\tRelativeTime t2 = PG_GETARG_RELATIVETIME(1);\n\n\tPG_RETURN_BOOL(reltime_cmp_internal(t1, t2) != 0);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "reltime_cmp_internal(t1, t2) != 0"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reltime_cmp_internal",
          "args": [
            "t1",
            "t2"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "reltime_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "1008-1033",
          "snippet": "static int\nreltime_cmp_internal(RelativeTime a, RelativeTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_RELTIME)\n\t{\n\t\tif (b == INVALID_RELTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_RELTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nreltime_cmp_internal(RelativeTime a, RelativeTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_RELTIME)\n\t{\n\t\tif (b == INVALID_RELTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_RELTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "1"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "0"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nreltimene(PG_FUNCTION_ARGS)\n{\n\tRelativeTime t1 = PG_GETARG_RELATIVETIME(0);\n\tRelativeTime t2 = PG_GETARG_RELATIVETIME(1);\n\n\tPG_RETURN_BOOL(reltime_cmp_internal(t1, t2) != 0);\n}"
  },
  {
    "function_name": "reltimeeq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1035-1042",
    "snippet": "Datum\nreltimeeq(PG_FUNCTION_ARGS)\n{\n\tRelativeTime t1 = PG_GETARG_RELATIVETIME(0);\n\tRelativeTime t2 = PG_GETARG_RELATIVETIME(1);\n\n\tPG_RETURN_BOOL(reltime_cmp_internal(t1, t2) == 0);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "reltime_cmp_internal(t1, t2) == 0"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reltime_cmp_internal",
          "args": [
            "t1",
            "t2"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "reltime_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "1008-1033",
          "snippet": "static int\nreltime_cmp_internal(RelativeTime a, RelativeTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_RELTIME)\n\t{\n\t\tif (b == INVALID_RELTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_RELTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nreltime_cmp_internal(RelativeTime a, RelativeTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_RELTIME)\n\t{\n\t\tif (b == INVALID_RELTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_RELTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "1"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "0"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nreltimeeq(PG_FUNCTION_ARGS)\n{\n\tRelativeTime t1 = PG_GETARG_RELATIVETIME(0);\n\tRelativeTime t2 = PG_GETARG_RELATIVETIME(1);\n\n\tPG_RETURN_BOOL(reltime_cmp_internal(t1, t2) == 0);\n}"
  },
  {
    "function_name": "reltime_cmp_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "1008-1033",
    "snippet": "static int\nreltime_cmp_internal(RelativeTime a, RelativeTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_RELTIME)\n\t{\n\t\tif (b == INVALID_RELTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_RELTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nreltime_cmp_internal(RelativeTime a, RelativeTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_RELTIME)\n\t{\n\t\tif (b == INVALID_RELTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_RELTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
  },
  {
    "function_name": "timenow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "999-1003",
    "snippet": "Datum\ntimenow(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_ABSOLUTETIME(GetCurrentAbsoluteTime());\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ABSOLUTETIME",
          "args": [
            "GetCurrentAbsoluteTime()"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCurrentAbsoluteTime",
          "args": [],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "GetCurrentAbsoluteTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "88-95",
          "snippet": "AbsoluteTime\nGetCurrentAbsoluteTime(void)\n{\n\ttime_t\t\tnow;\n\n\tnow = time(NULL);\n\treturn (AbsoluteTime) now;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nAbsoluteTime\nGetCurrentAbsoluteTime(void)\n{\n\ttime_t\t\tnow;\n\n\tnow = time(NULL);\n\treturn (AbsoluteTime) now;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimenow(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_ABSOLUTETIME(GetCurrentAbsoluteTime());\n}"
  },
  {
    "function_name": "tintervalrel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "976-991",
    "snippet": "Datum\ntintervalrel(PG_FUNCTION_ARGS)\n{\n\tTimeInterval tinterval = PG_GETARG_TIMEINTERVAL(0);\n\tAbsoluteTime t1 = tinterval->data[0];\n\tAbsoluteTime t2 = tinterval->data[1];\n\n\tif (tinterval->status != T_INTERVAL_VALID)\n\t\tPG_RETURN_RELATIVETIME(INVALID_RELTIME);\n\n\tif (AbsoluteTimeIsReal(t1) &&\n\t\tAbsoluteTimeIsReal(t2))\n\t\tPG_RETURN_RELATIVETIME(t2 - t1);\n\n\tPG_RETURN_RELATIVETIME(INVALID_RELTIME);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define T_INTERVAL_VALID   1\t/* data represents a valid tinterval */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_RELATIVETIME",
          "args": [
            "INVALID_RELTIME"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_RELATIVETIME",
          "args": [
            "t2 - t1"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeIsReal",
          "args": [
            "t2"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeIsReal",
          "args": [
            "t1"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_RELATIVETIME",
          "args": [
            "INVALID_RELTIME"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_VALID   1\t/* data represents a valid tinterval */\n\nDatum\ntintervalrel(PG_FUNCTION_ARGS)\n{\n\tTimeInterval tinterval = PG_GETARG_TIMEINTERVAL(0);\n\tAbsoluteTime t1 = tinterval->data[0];\n\tAbsoluteTime t2 = tinterval->data[1];\n\n\tif (tinterval->status != T_INTERVAL_VALID)\n\t\tPG_RETURN_RELATIVETIME(INVALID_RELTIME);\n\n\tif (AbsoluteTimeIsReal(t1) &&\n\t\tAbsoluteTimeIsReal(t2))\n\t\tPG_RETURN_RELATIVETIME(t2 - t1);\n\n\tPG_RETURN_RELATIVETIME(INVALID_RELTIME);\n}"
  },
  {
    "function_name": "intinterval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "954-971",
    "snippet": "Datum\nintinterval(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t = PG_GETARG_ABSOLUTETIME(0);\n\tTimeInterval tinterval = PG_GETARG_TIMEINTERVAL(1);\n\n\tif (tinterval->status == T_INTERVAL_VALID && t != INVALID_ABSTIME)\n\t{\n\t\tif (DatumGetBool(DirectFunctionCall2(abstimege,\n\t\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(t),\n\t\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(tinterval->data[0]))) &&\n\t\t\tDatumGetBool(DirectFunctionCall2(abstimele,\n\t\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(t),\n\t\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(tinterval->data[1]))))\n\t\t\tPG_RETURN_BOOL(true);\n\t}\n\tPG_RETURN_BOOL(false);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define T_INTERVAL_VALID   1\t/* data represents a valid tinterval */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(abstimele,\n\t\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(t),\n\t\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(tinterval->data[1]))"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "abstimele",
            "AbsoluteTimeGetDatum(t)",
            "AbsoluteTimeGetDatum(tinterval->data[1])"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeGetDatum",
          "args": [
            "tinterval->data[1]"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeGetDatum",
          "args": [
            "t"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(abstimege,\n\t\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(t),\n\t\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(tinterval->data[0]))"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "abstimege",
            "AbsoluteTimeGetDatum(t)",
            "AbsoluteTimeGetDatum(tinterval->data[0])"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeGetDatum",
          "args": [
            "tinterval->data[0]"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeGetDatum",
          "args": [
            "t"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "1"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "0"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_VALID   1\t/* data represents a valid tinterval */\n\nDatum\nintinterval(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t = PG_GETARG_ABSOLUTETIME(0);\n\tTimeInterval tinterval = PG_GETARG_TIMEINTERVAL(1);\n\n\tif (tinterval->status == T_INTERVAL_VALID && t != INVALID_ABSTIME)\n\t{\n\t\tif (DatumGetBool(DirectFunctionCall2(abstimege,\n\t\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(t),\n\t\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(tinterval->data[0]))) &&\n\t\t\tDatumGetBool(DirectFunctionCall2(abstimele,\n\t\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(t),\n\t\t\t\t\t\t\t\t\t\t\t AbsoluteTimeGetDatum(tinterval->data[1]))))\n\t\t\tPG_RETURN_BOOL(true);\n\t}\n\tPG_RETURN_BOOL(false);\n}"
  },
  {
    "function_name": "timemi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "935-948",
    "snippet": "Datum\ntimemi(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t1 = PG_GETARG_ABSOLUTETIME(0);\n\tRelativeTime t2 = PG_GETARG_RELATIVETIME(1);\n\n\tif (AbsoluteTimeIsReal(t1) &&\n\t\tRelativeTimeIsValid(t2) &&\n\t\t((t2 > 0 && t1 > NOSTART_ABSTIME + t2) ||\n\t\t (t2 <= 0 && t1 < NOEND_ABSTIME + t2))) /* prevent overflow */\n\t\tPG_RETURN_ABSOLUTETIME(t1 - t2);\n\n\tPG_RETURN_ABSOLUTETIME(INVALID_ABSTIME);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ABSOLUTETIME",
          "args": [
            "INVALID_ABSTIME"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_ABSOLUTETIME",
          "args": [
            "t1 - t2"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelativeTimeIsValid",
          "args": [
            "t2"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeIsReal",
          "args": [
            "t1"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "1"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "0"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimemi(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t1 = PG_GETARG_ABSOLUTETIME(0);\n\tRelativeTime t2 = PG_GETARG_RELATIVETIME(1);\n\n\tif (AbsoluteTimeIsReal(t1) &&\n\t\tRelativeTimeIsValid(t2) &&\n\t\t((t2 > 0 && t1 > NOSTART_ABSTIME + t2) ||\n\t\t (t2 <= 0 && t1 < NOEND_ABSTIME + t2))) /* prevent overflow */\n\t\tPG_RETURN_ABSOLUTETIME(t1 - t2);\n\n\tPG_RETURN_ABSOLUTETIME(INVALID_ABSTIME);\n}"
  },
  {
    "function_name": "timepl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "916-929",
    "snippet": "Datum\ntimepl(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t1 = PG_GETARG_ABSOLUTETIME(0);\n\tRelativeTime t2 = PG_GETARG_RELATIVETIME(1);\n\n\tif (AbsoluteTimeIsReal(t1) &&\n\t\tRelativeTimeIsValid(t2) &&\n\t\t((t2 > 0 && t1 < NOEND_ABSTIME - t2) ||\n\t\t (t2 <= 0 && t1 > NOSTART_ABSTIME - t2)))\t/* prevent overflow */\n\t\tPG_RETURN_ABSOLUTETIME(t1 + t2);\n\n\tPG_RETURN_ABSOLUTETIME(INVALID_ABSTIME);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ABSOLUTETIME",
          "args": [
            "INVALID_ABSTIME"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_ABSOLUTETIME",
          "args": [
            "t1 + t2"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RelativeTimeIsValid",
          "args": [
            "t2"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeIsReal",
          "args": [
            "t1"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "1"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "0"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimepl(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t1 = PG_GETARG_ABSOLUTETIME(0);\n\tRelativeTime t2 = PG_GETARG_RELATIVETIME(1);\n\n\tif (AbsoluteTimeIsReal(t1) &&\n\t\tRelativeTimeIsValid(t2) &&\n\t\t((t2 > 0 && t1 < NOEND_ABSTIME - t2) ||\n\t\t (t2 <= 0 && t1 > NOSTART_ABSTIME - t2)))\t/* prevent overflow */\n\t\tPG_RETURN_ABSOLUTETIME(t1 + t2);\n\n\tPG_RETURN_ABSOLUTETIME(INVALID_ABSTIME);\n}"
  },
  {
    "function_name": "mktinterval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "882-904",
    "snippet": "Datum\nmktinterval(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t1 = PG_GETARG_ABSOLUTETIME(0);\n\tAbsoluteTime t2 = PG_GETARG_ABSOLUTETIME(1);\n\tAbsoluteTime tstart = ABSTIMEMIN(t1, t2);\n\tAbsoluteTime tend = ABSTIMEMAX(t1, t2);\n\tTimeInterval tinterval;\n\n\ttinterval = (TimeInterval) palloc(sizeof(TimeIntervalData));\n\n\tif (t1 == INVALID_ABSTIME || t2 == INVALID_ABSTIME)\n\t\ttinterval->status = T_INTERVAL_INVAL;\n\n\telse\n\t{\n\t\ttinterval->status = T_INTERVAL_VALID;\n\t\ttinterval->data[0] = tstart;\n\t\ttinterval->data[1] = tend;\n\t}\n\n\tPG_RETURN_TIMEINTERVAL(tinterval);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define T_INTERVAL_VALID   1\t/* data represents a valid tinterval */",
      "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMEINTERVAL",
          "args": [
            "tinterval"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(TimeIntervalData)"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ABSTIMEMAX",
          "args": [
            "t1",
            "t2"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ABSTIMEMIN",
          "args": [
            "t1",
            "t2"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "1"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "0"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_VALID   1\t/* data represents a valid tinterval */\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nDatum\nmktinterval(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t1 = PG_GETARG_ABSOLUTETIME(0);\n\tAbsoluteTime t2 = PG_GETARG_ABSOLUTETIME(1);\n\tAbsoluteTime tstart = ABSTIMEMIN(t1, t2);\n\tAbsoluteTime tend = ABSTIMEMAX(t1, t2);\n\tTimeInterval tinterval;\n\n\ttinterval = (TimeInterval) palloc(sizeof(TimeIntervalData));\n\n\tif (t1 == INVALID_ABSTIME || t2 == INVALID_ABSTIME)\n\t\ttinterval->status = T_INTERVAL_INVAL;\n\n\telse\n\t{\n\t\ttinterval->status = T_INTERVAL_VALID;\n\t\ttinterval->data[0] = tstart;\n\t\ttinterval->data[1] = tend;\n\t}\n\n\tPG_RETURN_TIMEINTERVAL(tinterval);\n}"
  },
  {
    "function_name": "reltime_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "839-876",
    "snippet": "Datum\nreltime_interval(PG_FUNCTION_ARGS)\n{\n\tRelativeTime reltime = PG_GETARG_RELATIVETIME(0);\n\tInterval   *result;\n\tint\t\t\tyear,\n\t\t\t\tmonth,\n\t\t\t\tday;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tswitch (reltime)\n\t{\n\t\tcase INVALID_RELTIME:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cannot convert reltime \\\"invalid\\\" to interval\")));\n\t\t\tresult->time = 0;\n\t\t\tresult->day = 0;\n\t\t\tresult->month = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tyear = reltime / SECS_PER_YEAR;\n\t\t\treltime -= year * SECS_PER_YEAR;\n\t\t\tmonth = reltime / (DAYS_PER_MONTH * SECS_PER_DAY);\n\t\t\treltime -= month * (DAYS_PER_MONTH * SECS_PER_DAY);\n\t\t\tday = reltime / SECS_PER_DAY;\n\t\t\treltime -= day * SECS_PER_DAY;\n\n\t\t\tresult->time = (reltime * USECS_PER_SEC);\n\t\t\tresult->month = MONTHS_PER_YEAR * year + month;\n\t\t\tresult->day = day;\n\t\t\tbreak;\n\t}\n\n\tPG_RETURN_INTERVAL_P(result);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INTERVAL_P",
          "args": [
            "result"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cannot convert reltime \\\"invalid\\\" to interval\"))"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"cannot convert reltime \\\"invalid\\\" to interval\""
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_FEATURE_NOT_SUPPORTED"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(Interval)"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "0"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nreltime_interval(PG_FUNCTION_ARGS)\n{\n\tRelativeTime reltime = PG_GETARG_RELATIVETIME(0);\n\tInterval   *result;\n\tint\t\t\tyear,\n\t\t\t\tmonth,\n\t\t\t\tday;\n\n\tresult = (Interval *) palloc(sizeof(Interval));\n\n\tswitch (reltime)\n\t{\n\t\tcase INVALID_RELTIME:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cannot convert reltime \\\"invalid\\\" to interval\")));\n\t\t\tresult->time = 0;\n\t\t\tresult->day = 0;\n\t\t\tresult->month = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tyear = reltime / SECS_PER_YEAR;\n\t\t\treltime -= year * SECS_PER_YEAR;\n\t\t\tmonth = reltime / (DAYS_PER_MONTH * SECS_PER_DAY);\n\t\t\treltime -= month * (DAYS_PER_MONTH * SECS_PER_DAY);\n\t\t\tday = reltime / SECS_PER_DAY;\n\t\t\treltime -= day * SECS_PER_DAY;\n\n\t\t\tresult->time = (reltime * USECS_PER_SEC);\n\t\t\tresult->month = MONTHS_PER_YEAR * year + month;\n\t\t\tresult->day = day;\n\t\t\tbreak;\n\t}\n\n\tPG_RETURN_INTERVAL_P(result);\n}"
  },
  {
    "function_name": "interval_reltime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "811-836",
    "snippet": "Datum\ninterval_reltime(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval = PG_GETARG_INTERVAL_P(0);\n\tRelativeTime time;\n\tint\t\t\tyear,\n\t\t\t\tmonth,\n\t\t\t\tday;\n\tTimeOffset\tspan;\n\n\tyear = interval->month / MONTHS_PER_YEAR;\n\tmonth = interval->month % MONTHS_PER_YEAR;\n\tday = interval->day;\n\n\tspan = ((INT64CONST(365250000) * year + INT64CONST(30000000) * month +\n\t\t\t INT64CONST(1000000) * day) * INT64CONST(86400)) +\n\t\tinterval->time;\n\tspan /= USECS_PER_SEC;\n\n\tif (span < INT_MIN || span > INT_MAX)\n\t\ttime = INVALID_RELTIME;\n\telse\n\t\ttime = span;\n\n\tPG_RETURN_RELATIVETIME(time);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_RELATIVETIME",
          "args": [
            "time"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "86400"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "1000000"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "30000000"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INT64CONST",
          "args": [
            "365250000"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INTERVAL_P",
          "args": [
            "0"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ninterval_reltime(PG_FUNCTION_ARGS)\n{\n\tInterval   *interval = PG_GETARG_INTERVAL_P(0);\n\tRelativeTime time;\n\tint\t\t\tyear,\n\t\t\t\tmonth,\n\t\t\t\tday;\n\tTimeOffset\tspan;\n\n\tyear = interval->month / MONTHS_PER_YEAR;\n\tmonth = interval->month % MONTHS_PER_YEAR;\n\tday = interval->day;\n\n\tspan = ((INT64CONST(365250000) * year + INT64CONST(30000000) * month +\n\t\t\t INT64CONST(1000000) * day) * INT64CONST(86400)) +\n\t\tinterval->time;\n\tspan /= USECS_PER_SEC;\n\n\tif (span < INT_MIN || span > INT_MAX)\n\t\ttime = INVALID_RELTIME;\n\telse\n\t\ttime = span;\n\n\tPG_RETURN_RELATIVETIME(time);\n}"
  },
  {
    "function_name": "tintervalsend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "793-804",
    "snippet": "Datum\ntintervalsend(PG_FUNCTION_ARGS)\n{\n\tTimeInterval tinterval = PG_GETARG_TIMEINTERVAL(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, tinterval->status);\n\tpq_sendint32(&buf, tinterval->data[0]);\n\tpq_sendint32(&buf, tinterval->data[1]);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "tinterval->data[1]"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "tinterval->data[0]"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "tinterval->status"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntintervalsend(PG_FUNCTION_ARGS)\n{\n\tTimeInterval tinterval = PG_GETARG_TIMEINTERVAL(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, tinterval->status);\n\tpq_sendint32(&buf, tinterval->data[0]);\n\tpq_sendint32(&buf, tinterval->data[1]);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "tintervalrecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "763-788",
    "snippet": "Datum\ntintervalrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tTimeInterval tinterval;\n\tint32\t\tstatus;\n\n\ttinterval = (TimeInterval) palloc(sizeof(TimeIntervalData));\n\n\ttinterval->status = pq_getmsgint(buf, sizeof(tinterval->status));\n\ttinterval->data[0] = pq_getmsgint(buf, sizeof(tinterval->data[0]));\n\ttinterval->data[1] = pq_getmsgint(buf, sizeof(tinterval->data[1]));\n\n\tif (tinterval->data[0] == INVALID_ABSTIME ||\n\t\ttinterval->data[1] == INVALID_ABSTIME)\n\t\tstatus = T_INTERVAL_INVAL;\t/* undefined  */\n\telse\n\t\tstatus = T_INTERVAL_VALID;\n\n\tif (status != tinterval->status)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid status in external \\\"tinterval\\\" value\")));\n\n\tPG_RETURN_TIMEINTERVAL(tinterval);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define T_INTERVAL_VALID   1\t/* data represents a valid tinterval */",
      "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMEINTERVAL",
          "args": [
            "tinterval"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid status in external \\\"tinterval\\\" value\"))"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid status in external \\\"tinterval\\\" value\""
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_BINARY_REPRESENTATION"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(tinterval->data[1])"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(tinterval->data[0])"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(tinterval->status)"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(TimeIntervalData)"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_VALID   1\t/* data represents a valid tinterval */\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nDatum\ntintervalrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tTimeInterval tinterval;\n\tint32\t\tstatus;\n\n\ttinterval = (TimeInterval) palloc(sizeof(TimeIntervalData));\n\n\ttinterval->status = pq_getmsgint(buf, sizeof(tinterval->status));\n\ttinterval->data[0] = pq_getmsgint(buf, sizeof(tinterval->data[0]));\n\ttinterval->data[1] = pq_getmsgint(buf, sizeof(tinterval->data[1]));\n\n\tif (tinterval->data[0] == INVALID_ABSTIME ||\n\t\ttinterval->data[1] == INVALID_ABSTIME)\n\t\tstatus = T_INTERVAL_INVAL;\t/* undefined  */\n\telse\n\t\tstatus = T_INTERVAL_VALID;\n\n\tif (status != tinterval->status)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_BINARY_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid status in external \\\"tinterval\\\" value\")));\n\n\tPG_RETURN_TIMEINTERVAL(tinterval);\n}"
  },
  {
    "function_name": "tintervalout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "733-758",
    "snippet": "Datum\ntintervalout(PG_FUNCTION_ARGS)\n{\n\tTimeInterval tinterval = PG_GETARG_TIMEINTERVAL(0);\n\tchar\t   *i_str,\n\t\t\t   *p;\n\n\ti_str = (char *) palloc(T_INTERVAL_LEN);\t/* [\"...\" \"...\"] */\n\tstrcpy(i_str, \"[\\\"\");\n\tif (tinterval->status == T_INTERVAL_INVAL)\n\t\tstrcat(i_str, INVALID_INTERVAL_STR);\n\telse\n\t{\n\t\tp = DatumGetCString(DirectFunctionCall1(abstimeout,\n\t\t\t\t\t\t\t\t\t\t\t\tAbsoluteTimeGetDatum(tinterval->data[0])));\n\t\tstrcat(i_str, p);\n\t\tpfree(p);\n\t\tstrcat(i_str, \"\\\" \\\"\");\n\t\tp = DatumGetCString(DirectFunctionCall1(abstimeout,\n\t\t\t\t\t\t\t\t\t\t\t\tAbsoluteTimeGetDatum(tinterval->data[1])));\n\t\tstrcat(i_str, p);\n\t\tpfree(p);\n\t}\n\tstrcat(i_str, \"\\\"]\");\n\tPG_RETURN_CSTRING(i_str);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define INVALID_INTERVAL_STR\t\t\t\"Undefined Range\"",
      "#define T_INTERVAL_LEN\t\t\t\t\t80",
      "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "i_str"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "i_str",
            "\"\\\"]\""
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "225-243",
          "snippet": "int\nnamestrcat(Name name, const char *str)\n{\n\tint\t\t\ti;\n\tchar\t   *p,\n\t\t\t   *q;\n\n\tif (!name || !str)\n\t\treturn -1;\n\tfor (i = 0, p = NameStr(*name); i < NAMEDATALEN && *p; ++i, ++p)\n\t\t;\n\tfor (q = str; i < NAMEDATALEN; ++i, ++p, ++q)\n\t{\n\t\t*p = *q;\n\t\tif (!*q)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcat(Name name, const char *str)\n{\n\tint\t\t\ti;\n\tchar\t   *p,\n\t\t\t   *q;\n\n\tif (!name || !str)\n\t\treturn -1;\n\tfor (i = 0, p = NameStr(*name); i < NAMEDATALEN && *p; ++i, ++p)\n\t\t;\n\tfor (q = str; i < NAMEDATALEN; ++i, ++p, ++q)\n\t{\n\t\t*p = *q;\n\t\tif (!*q)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "p"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "DirectFunctionCall1(abstimeout,\n\t\t\t\t\t\t\t\t\t\t\t\tAbsoluteTimeGetDatum(tinterval->data[1]))"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "abstimeout",
            "AbsoluteTimeGetDatum(tinterval->data[1])"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeGetDatum",
          "args": [
            "tinterval->data[1]"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetCString",
          "args": [
            "DirectFunctionCall1(abstimeout,\n\t\t\t\t\t\t\t\t\t\t\t\tAbsoluteTimeGetDatum(tinterval->data[0]))"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "abstimeout",
            "AbsoluteTimeGetDatum(tinterval->data[0])"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AbsoluteTimeGetDatum",
          "args": [
            "tinterval->data[0]"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "i_str",
            "\"[\\\"\""
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "T_INTERVAL_LEN"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMEINTERVAL",
          "args": [
            "0"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define INVALID_INTERVAL_STR\t\t\t\"Undefined Range\"\n#define T_INTERVAL_LEN\t\t\t\t\t80\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nDatum\ntintervalout(PG_FUNCTION_ARGS)\n{\n\tTimeInterval tinterval = PG_GETARG_TIMEINTERVAL(0);\n\tchar\t   *i_str,\n\t\t\t   *p;\n\n\ti_str = (char *) palloc(T_INTERVAL_LEN);\t/* [\"...\" \"...\"] */\n\tstrcpy(i_str, \"[\\\"\");\n\tif (tinterval->status == T_INTERVAL_INVAL)\n\t\tstrcat(i_str, INVALID_INTERVAL_STR);\n\telse\n\t{\n\t\tp = DatumGetCString(DirectFunctionCall1(abstimeout,\n\t\t\t\t\t\t\t\t\t\t\t\tAbsoluteTimeGetDatum(tinterval->data[0])));\n\t\tstrcat(i_str, p);\n\t\tpfree(p);\n\t\tstrcat(i_str, \"\\\" \\\"\");\n\t\tp = DatumGetCString(DirectFunctionCall1(abstimeout,\n\t\t\t\t\t\t\t\t\t\t\t\tAbsoluteTimeGetDatum(tinterval->data[1])));\n\t\tstrcat(i_str, p);\n\t\tpfree(p);\n\t}\n\tstrcat(i_str, \"\\\"]\");\n\tPG_RETURN_CSTRING(i_str);\n}"
  },
  {
    "function_name": "tintervalin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "702-727",
    "snippet": "Datum\ntintervalin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *tintervalstr = PG_GETARG_CSTRING(0);\n\tTimeInterval tinterval;\n\tAbsoluteTime i_start,\n\t\t\t\ti_end,\n\t\t\t\tt1,\n\t\t\t\tt2;\n\n\tparsetinterval(tintervalstr, &t1, &t2);\n\n\ttinterval = (TimeInterval) palloc(sizeof(TimeIntervalData));\n\n\tif (t1 == INVALID_ABSTIME || t2 == INVALID_ABSTIME)\n\t\ttinterval->status = T_INTERVAL_INVAL;\t/* undefined  */\n\telse\n\t\ttinterval->status = T_INTERVAL_VALID;\n\n\ti_start = ABSTIMEMIN(t1, t2);\n\ti_end = ABSTIMEMAX(t1, t2);\n\ttinterval->data[0] = i_start;\n\ttinterval->data[1] = i_end;\n\n\tPG_RETURN_TIMEINTERVAL(tinterval);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define T_INTERVAL_VALID   1\t/* data represents a valid tinterval */",
      "#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */"
    ],
    "globals_used": [
      "static void parsetinterval(char *i_string,\n\t\t\t   AbsoluteTime *i_start,\n\t\t\t   AbsoluteTime *i_end);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMEINTERVAL",
          "args": [
            "tinterval"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ABSTIMEMAX",
          "args": [
            "t1",
            "t2"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ABSTIMEMIN",
          "args": [
            "t1",
            "t2"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(TimeIntervalData)"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parsetinterval",
          "args": [
            "tintervalstr",
            "&t1",
            "&t2"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "parsetinterval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "1434-1545",
          "snippet": "static void\nparsetinterval(char *i_string,\n\t\t\t   AbsoluteTime *i_start,\n\t\t\t   AbsoluteTime *i_end)\n{\n\tchar\t   *p,\n\t\t\t   *p1;\n\tchar\t\tc;\n\n\tp = i_string;\n\t/* skip leading blanks up to '[' */\n\twhile ((c = *p) != '\\0')\n\t{\n\t\tif (IsSpace(c))\n\t\t\tp++;\n\t\telse if (c != '[')\n\t\t\tgoto bogus;\t\t\t/* syntax error */\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\tp++;\n\t/* skip leading blanks up to '\"' */\n\twhile ((c = *p) != '\\0')\n\t{\n\t\tif (IsSpace(c))\n\t\t\tp++;\n\t\telse if (c != '\"')\n\t\t\tgoto bogus;\t\t\t/* syntax error */\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\tp++;\n\tif (strncmp(INVALID_INTERVAL_STR, p, strlen(INVALID_INTERVAL_STR)) == 0)\n\t\tgoto bogus;\t\t\t\t/* undefined range, handled like a syntax err. */\n\t/* search for the end of the first date and change it to a \\0 */\n\tp1 = p;\n\twhile ((c = *p1) != '\\0')\n\t{\n\t\tif (c == '\"')\n\t\t\tbreak;\n\t\tp1++;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\t*p1 = '\\0';\n\t/* get the first date */\n\t*i_start = DatumGetAbsoluteTime(DirectFunctionCall1(abstimein,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tCStringGetDatum(p)));\n\t/* undo change to \\0 */\n\t*p1 = c;\n\tp = ++p1;\n\t/* skip blanks up to '\"', beginning of second date */\n\twhile ((c = *p) != '\\0')\n\t{\n\t\tif (IsSpace(c))\n\t\t\tp++;\n\t\telse if (c != '\"')\n\t\t\tgoto bogus;\t\t\t/* syntax error */\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\tp++;\n\t/* search for the end of the second date and change it to a \\0 */\n\tp1 = p;\n\twhile ((c = *p1) != '\\0')\n\t{\n\t\tif (c == '\"')\n\t\t\tbreak;\n\t\tp1++;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\t*p1 = '\\0';\n\t/* get the second date */\n\t*i_end = DatumGetAbsoluteTime(DirectFunctionCall1(abstimein,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(p)));\n\t/* undo change to \\0 */\n\t*p1 = c;\n\tp = ++p1;\n\t/* skip blanks up to ']' */\n\twhile ((c = *p) != '\\0')\n\t{\n\t\tif (IsSpace(c))\n\t\t\tp++;\n\t\telse if (c != ']')\n\t\t\tgoto bogus;\t\t\t/* syntax error */\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\tp++;\n\tc = *p;\n\tif (c != '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\n\t/* it seems to be a valid tinterval */\n\treturn;\n\nbogus:\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\"tinterval\", i_string)));\n\t*i_start = *i_end = INVALID_ABSTIME;\t/* keep compiler quiet */\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define INVALID_INTERVAL_STR\t\t\t\"Undefined Range\""
          ],
          "globals_used": [
            "static void parsetinterval(char *i_string,\n\t\t\t   AbsoluteTime *i_start,\n\t\t\t   AbsoluteTime *i_end);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define INVALID_INTERVAL_STR\t\t\t\"Undefined Range\"\n\nstatic void parsetinterval(char *i_string,\n\t\t\t   AbsoluteTime *i_start,\n\t\t\t   AbsoluteTime *i_end);\n\nstatic void\nparsetinterval(char *i_string,\n\t\t\t   AbsoluteTime *i_start,\n\t\t\t   AbsoluteTime *i_end)\n{\n\tchar\t   *p,\n\t\t\t   *p1;\n\tchar\t\tc;\n\n\tp = i_string;\n\t/* skip leading blanks up to '[' */\n\twhile ((c = *p) != '\\0')\n\t{\n\t\tif (IsSpace(c))\n\t\t\tp++;\n\t\telse if (c != '[')\n\t\t\tgoto bogus;\t\t\t/* syntax error */\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\tp++;\n\t/* skip leading blanks up to '\"' */\n\twhile ((c = *p) != '\\0')\n\t{\n\t\tif (IsSpace(c))\n\t\t\tp++;\n\t\telse if (c != '\"')\n\t\t\tgoto bogus;\t\t\t/* syntax error */\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\tp++;\n\tif (strncmp(INVALID_INTERVAL_STR, p, strlen(INVALID_INTERVAL_STR)) == 0)\n\t\tgoto bogus;\t\t\t\t/* undefined range, handled like a syntax err. */\n\t/* search for the end of the first date and change it to a \\0 */\n\tp1 = p;\n\twhile ((c = *p1) != '\\0')\n\t{\n\t\tif (c == '\"')\n\t\t\tbreak;\n\t\tp1++;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\t*p1 = '\\0';\n\t/* get the first date */\n\t*i_start = DatumGetAbsoluteTime(DirectFunctionCall1(abstimein,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tCStringGetDatum(p)));\n\t/* undo change to \\0 */\n\t*p1 = c;\n\tp = ++p1;\n\t/* skip blanks up to '\"', beginning of second date */\n\twhile ((c = *p) != '\\0')\n\t{\n\t\tif (IsSpace(c))\n\t\t\tp++;\n\t\telse if (c != '\"')\n\t\t\tgoto bogus;\t\t\t/* syntax error */\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\tp++;\n\t/* search for the end of the second date and change it to a \\0 */\n\tp1 = p;\n\twhile ((c = *p1) != '\\0')\n\t{\n\t\tif (c == '\"')\n\t\t\tbreak;\n\t\tp1++;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\t*p1 = '\\0';\n\t/* get the second date */\n\t*i_end = DatumGetAbsoluteTime(DirectFunctionCall1(abstimein,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(p)));\n\t/* undo change to \\0 */\n\t*p1 = c;\n\tp = ++p1;\n\t/* skip blanks up to ']' */\n\twhile ((c = *p) != '\\0')\n\t{\n\t\tif (IsSpace(c))\n\t\t\tp++;\n\t\telse if (c != ']')\n\t\t\tgoto bogus;\t\t\t/* syntax error */\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (c == '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\tp++;\n\tc = *p;\n\tif (c != '\\0')\n\t\tgoto bogus;\t\t\t\t/* syntax error */\n\n\t/* it seems to be a valid tinterval */\n\treturn;\n\nbogus:\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\"tinterval\", i_string)));\n\t*i_start = *i_end = INVALID_ABSTIME;\t/* keep compiler quiet */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define T_INTERVAL_VALID   1\t/* data represents a valid tinterval */\n#define T_INTERVAL_INVAL   0\t/* data represents no valid tinterval */\n\nstatic void parsetinterval(char *i_string,\n\t\t\t   AbsoluteTime *i_start,\n\t\t\t   AbsoluteTime *i_end);\n\nDatum\ntintervalin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *tintervalstr = PG_GETARG_CSTRING(0);\n\tTimeInterval tinterval;\n\tAbsoluteTime i_start,\n\t\t\t\ti_end,\n\t\t\t\tt1,\n\t\t\t\tt2;\n\n\tparsetinterval(tintervalstr, &t1, &t2);\n\n\ttinterval = (TimeInterval) palloc(sizeof(TimeIntervalData));\n\n\tif (t1 == INVALID_ABSTIME || t2 == INVALID_ABSTIME)\n\t\ttinterval->status = T_INTERVAL_INVAL;\t/* undefined  */\n\telse\n\t\ttinterval->status = T_INTERVAL_VALID;\n\n\ti_start = ABSTIMEMIN(t1, t2);\n\ti_end = ABSTIMEMAX(t1, t2);\n\ttinterval->data[0] = i_start;\n\ttinterval->data[1] = i_end;\n\n\tPG_RETURN_TIMEINTERVAL(tinterval);\n}"
  },
  {
    "function_name": "reltime2tm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "685-696",
    "snippet": "static void\nreltime2tm(RelativeTime time, struct pg_tm *tm)\n{\n\tdouble\t\tdtime = time;\n\n\tFMODULO(dtime, tm->tm_year, 31557600);\n\tFMODULO(dtime, tm->tm_mon, 2592000);\n\tFMODULO(dtime, tm->tm_mday, SECS_PER_DAY);\n\tFMODULO(dtime, tm->tm_hour, SECS_PER_HOUR);\n\tFMODULO(dtime, tm->tm_min, SECS_PER_MINUTE);\n\tFMODULO(dtime, tm->tm_sec, 1);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void reltime2tm(RelativeTime time, struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FMODULO",
          "args": [
            "dtime",
            "tm->tm_sec",
            "1"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FMODULO",
          "args": [
            "dtime",
            "tm->tm_min",
            "SECS_PER_MINUTE"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FMODULO",
          "args": [
            "dtime",
            "tm->tm_hour",
            "SECS_PER_HOUR"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FMODULO",
          "args": [
            "dtime",
            "tm->tm_mday",
            "SECS_PER_DAY"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FMODULO",
          "args": [
            "dtime",
            "tm->tm_mon",
            "2592000"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FMODULO",
          "args": [
            "dtime",
            "tm->tm_year",
            "31557600"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void reltime2tm(RelativeTime time, struct pg_tm *tm);\n\nstatic void\nreltime2tm(RelativeTime time, struct pg_tm *tm)\n{\n\tdouble\t\tdtime = time;\n\n\tFMODULO(dtime, tm->tm_year, 31557600);\n\tFMODULO(dtime, tm->tm_mon, 2592000);\n\tFMODULO(dtime, tm->tm_mday, SECS_PER_DAY);\n\tFMODULO(dtime, tm->tm_hour, SECS_PER_HOUR);\n\tFMODULO(dtime, tm->tm_min, SECS_PER_MINUTE);\n\tFMODULO(dtime, tm->tm_sec, 1);\n}"
  },
  {
    "function_name": "reltimesend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "673-682",
    "snippet": "Datum\nreltimesend(PG_FUNCTION_ARGS)\n{\n\tRelativeTime time = PG_GETARG_RELATIVETIME(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, time);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "time"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "0"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nreltimesend(PG_FUNCTION_ARGS)\n{\n\tRelativeTime time = PG_GETARG_RELATIVETIME(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, time);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "reltimerecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "662-668",
    "snippet": "Datum\nreltimerecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_RELATIVETIME((RelativeTime) pq_getmsgint(buf, sizeof(RelativeTime)));\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_RELATIVETIME",
          "args": [
            "(RelativeTime) pq_getmsgint(buf, sizeof(RelativeTime))"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(RelativeTime)"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nreltimerecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_RELATIVETIME((RelativeTime) pq_getmsgint(buf, sizeof(RelativeTime)));\n}"
  },
  {
    "function_name": "reltimeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "643-657",
    "snippet": "Datum\nreltimeout(PG_FUNCTION_ARGS)\n{\n\tRelativeTime time = PG_GETARG_RELATIVETIME(0);\n\tchar\t   *result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tchar\t\tbuf[MAXDATELEN + 1];\n\n\treltime2tm(time, tm);\n\tEncodeInterval(tm, 0, IntervalStyle, buf);\n\n\tresult = pstrdup(buf);\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void reltime2tm(RelativeTime time, struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "buf"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeInterval",
          "args": [
            "tm",
            "0",
            "IntervalStyle",
            "buf"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeInterval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "4229-4413",
          "snippet": "void\nEncodeInterval(struct pg_tm *tm, fsec_t fsec, int style, char *str)\n{\n\tchar\t   *cp = str;\n\tint\t\t\tyear = tm->tm_year;\n\tint\t\t\tmon = tm->tm_mon;\n\tint\t\t\tmday = tm->tm_mday;\n\tint\t\t\thour = tm->tm_hour;\n\tint\t\t\tmin = tm->tm_min;\n\tint\t\t\tsec = tm->tm_sec;\n\tbool\t\tis_before = false;\n\tbool\t\tis_zero = true;\n\n\t/*\n\t * The sign of year and month are guaranteed to match, since they are\n\t * stored internally as \"month\". But we'll need to check for is_before and\n\t * is_zero when determining the signs of day and hour/minute/seconds\n\t * fields.\n\t */\n\tswitch (style)\n\t{\n\t\t\t/* SQL Standard interval format */\n\t\tcase INTSTYLE_SQL_STANDARD:\n\t\t\t{\n\t\t\t\tbool\t\thas_negative = year < 0 || mon < 0 ||\n\t\t\t\tmday < 0 || hour < 0 ||\n\t\t\t\tmin < 0 || sec < 0 || fsec < 0;\n\t\t\t\tbool\t\thas_positive = year > 0 || mon > 0 ||\n\t\t\t\tmday > 0 || hour > 0 ||\n\t\t\t\tmin > 0 || sec > 0 || fsec > 0;\n\t\t\t\tbool\t\thas_year_month = year != 0 || mon != 0;\n\t\t\t\tbool\t\thas_day_time = mday != 0 || hour != 0 ||\n\t\t\t\tmin != 0 || sec != 0 || fsec != 0;\n\t\t\t\tbool\t\thas_day = mday != 0;\n\t\t\t\tbool\t\tsql_standard_value = !(has_negative && has_positive) &&\n\t\t\t\t!(has_year_month && has_day_time);\n\n\t\t\t\t/*\n\t\t\t\t * SQL Standard wants only 1 \"<sign>\" preceding the whole\n\t\t\t\t * interval ... but can't do that if mixed signs.\n\t\t\t\t */\n\t\t\t\tif (has_negative && sql_standard_value)\n\t\t\t\t{\n\t\t\t\t\t*cp++ = '-';\n\t\t\t\t\tyear = -year;\n\t\t\t\t\tmon = -mon;\n\t\t\t\t\tmday = -mday;\n\t\t\t\t\thour = -hour;\n\t\t\t\t\tmin = -min;\n\t\t\t\t\tsec = -sec;\n\t\t\t\t\tfsec = -fsec;\n\t\t\t\t}\n\n\t\t\t\tif (!has_negative && !has_positive)\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"0\");\n\t\t\t\t}\n\t\t\t\telse if (!sql_standard_value)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * For non sql-standard interval values, force outputting\n\t\t\t\t\t * the signs to avoid ambiguities with intervals with\n\t\t\t\t\t * mixed sign components.\n\t\t\t\t\t */\n\t\t\t\t\tchar\t\tyear_sign = (year < 0 || mon < 0) ? '-' : '+';\n\t\t\t\t\tchar\t\tday_sign = (mday < 0) ? '-' : '+';\n\t\t\t\t\tchar\t\tsec_sign = (hour < 0 || min < 0 ||\n\t\t\t\t\t\t\t\t\t\t\tsec < 0 || fsec < 0) ? '-' : '+';\n\n\t\t\t\t\tsprintf(cp, \"%c%d-%d %c%d %c%d:%02d:\",\n\t\t\t\t\t\t\tyear_sign, abs(year), abs(mon),\n\t\t\t\t\t\t\tday_sign, abs(mday),\n\t\t\t\t\t\t\tsec_sign, abs(hour), abs(min));\n\t\t\t\t\tcp += strlen(cp);\n\t\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t}\n\t\t\t\telse if (has_year_month)\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"%d-%d\", year, mon);\n\t\t\t\t}\n\t\t\t\telse if (has_day)\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"%d %d:%02d:\", mday, hour, min);\n\t\t\t\t\tcp += strlen(cp);\n\t\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"%d:%02d:\", hour, min);\n\t\t\t\t\tcp += strlen(cp);\n\t\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* ISO 8601 \"time-intervals by duration only\" */\n\t\tcase INTSTYLE_ISO_8601:\n\t\t\t/* special-case zero to avoid printing nothing */\n\t\t\tif (year == 0 && mon == 0 && mday == 0 &&\n\t\t\t\thour == 0 && min == 0 && sec == 0 && fsec == 0)\n\t\t\t{\n\t\t\t\tsprintf(cp, \"PT0S\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*cp++ = 'P';\n\t\t\tcp = AddISO8601IntPart(cp, year, 'Y');\n\t\t\tcp = AddISO8601IntPart(cp, mon, 'M');\n\t\t\tcp = AddISO8601IntPart(cp, mday, 'D');\n\t\t\tif (hour != 0 || min != 0 || sec != 0 || fsec != 0)\n\t\t\t\t*cp++ = 'T';\n\t\t\tcp = AddISO8601IntPart(cp, hour, 'H');\n\t\t\tcp = AddISO8601IntPart(cp, min, 'M');\n\t\t\tif (sec != 0 || fsec != 0)\n\t\t\t{\n\t\t\t\tif (sec < 0 || fsec < 0)\n\t\t\t\t\t*cp++ = '-';\n\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, false);\n\t\t\t\t*cp++ = 'S';\n\t\t\t\t*cp++ = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* Compatible with postgresql < 8.4 when DateStyle = 'iso' */\n\t\tcase INTSTYLE_POSTGRES:\n\t\t\tcp = AddPostgresIntPart(cp, year, \"year\", &is_zero, &is_before);\n\n\t\t\t/*\n\t\t\t * Ideally we should spell out \"month\" like we do for \"year\" and\n\t\t\t * \"day\".  However, for backward compatibility, we can't easily\n\t\t\t * fix this.  bjm 2011-05-24\n\t\t\t */\n\t\t\tcp = AddPostgresIntPart(cp, mon, \"mon\", &is_zero, &is_before);\n\t\t\tcp = AddPostgresIntPart(cp, mday, \"day\", &is_zero, &is_before);\n\t\t\tif (is_zero || hour != 0 || min != 0 || sec != 0 || fsec != 0)\n\t\t\t{\n\t\t\t\tbool\t\tminus = (hour < 0 || min < 0 || sec < 0 || fsec < 0);\n\n\t\t\t\tsprintf(cp, \"%s%s%02d:%02d:\",\n\t\t\t\t\t\tis_zero ? \"\" : \" \",\n\t\t\t\t\t\t(minus ? \"-\" : (is_before ? \"+\" : \"\")),\n\t\t\t\t\t\tabs(hour), abs(min));\n\t\t\t\tcp += strlen(cp);\n\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t*cp = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* Compatible with postgresql < 8.4 when DateStyle != 'iso' */\n\t\tcase INTSTYLE_POSTGRES_VERBOSE:\n\t\tdefault:\n\t\t\tstrcpy(cp, \"@\");\n\t\t\tcp++;\n\t\t\tcp = AddVerboseIntPart(cp, year, \"year\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, mon, \"mon\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, mday, \"day\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, hour, \"hour\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, min, \"min\", &is_zero, &is_before);\n\t\t\tif (sec != 0 || fsec != 0)\n\t\t\t{\n\t\t\t\t*cp++ = ' ';\n\t\t\t\tif (sec < 0 || (sec == 0 && fsec < 0))\n\t\t\t\t{\n\t\t\t\t\tif (is_zero)\n\t\t\t\t\t\tis_before = true;\n\t\t\t\t\telse if (!is_before)\n\t\t\t\t\t\t*cp++ = '-';\n\t\t\t\t}\n\t\t\t\telse if (is_before)\n\t\t\t\t\t*cp++ = '-';\n\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, false);\n\t\t\t\tsprintf(cp, \" sec%s\",\n\t\t\t\t\t\t(abs(sec) != 1 || fsec != 0) ? \"s\" : \"\");\n\t\t\t\tis_zero = false;\n\t\t\t}\n\t\t\t/* identically zero? then put in a unitless zero... */\n\t\t\tif (is_zero)\n\t\t\t\tstrcat(cp, \" 0\");\n\t\t\tif (is_before)\n\t\t\t\tstrcat(cp, \" ago\");\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nvoid\nEncodeInterval(struct pg_tm *tm, fsec_t fsec, int style, char *str)\n{\n\tchar\t   *cp = str;\n\tint\t\t\tyear = tm->tm_year;\n\tint\t\t\tmon = tm->tm_mon;\n\tint\t\t\tmday = tm->tm_mday;\n\tint\t\t\thour = tm->tm_hour;\n\tint\t\t\tmin = tm->tm_min;\n\tint\t\t\tsec = tm->tm_sec;\n\tbool\t\tis_before = false;\n\tbool\t\tis_zero = true;\n\n\t/*\n\t * The sign of year and month are guaranteed to match, since they are\n\t * stored internally as \"month\". But we'll need to check for is_before and\n\t * is_zero when determining the signs of day and hour/minute/seconds\n\t * fields.\n\t */\n\tswitch (style)\n\t{\n\t\t\t/* SQL Standard interval format */\n\t\tcase INTSTYLE_SQL_STANDARD:\n\t\t\t{\n\t\t\t\tbool\t\thas_negative = year < 0 || mon < 0 ||\n\t\t\t\tmday < 0 || hour < 0 ||\n\t\t\t\tmin < 0 || sec < 0 || fsec < 0;\n\t\t\t\tbool\t\thas_positive = year > 0 || mon > 0 ||\n\t\t\t\tmday > 0 || hour > 0 ||\n\t\t\t\tmin > 0 || sec > 0 || fsec > 0;\n\t\t\t\tbool\t\thas_year_month = year != 0 || mon != 0;\n\t\t\t\tbool\t\thas_day_time = mday != 0 || hour != 0 ||\n\t\t\t\tmin != 0 || sec != 0 || fsec != 0;\n\t\t\t\tbool\t\thas_day = mday != 0;\n\t\t\t\tbool\t\tsql_standard_value = !(has_negative && has_positive) &&\n\t\t\t\t!(has_year_month && has_day_time);\n\n\t\t\t\t/*\n\t\t\t\t * SQL Standard wants only 1 \"<sign>\" preceding the whole\n\t\t\t\t * interval ... but can't do that if mixed signs.\n\t\t\t\t */\n\t\t\t\tif (has_negative && sql_standard_value)\n\t\t\t\t{\n\t\t\t\t\t*cp++ = '-';\n\t\t\t\t\tyear = -year;\n\t\t\t\t\tmon = -mon;\n\t\t\t\t\tmday = -mday;\n\t\t\t\t\thour = -hour;\n\t\t\t\t\tmin = -min;\n\t\t\t\t\tsec = -sec;\n\t\t\t\t\tfsec = -fsec;\n\t\t\t\t}\n\n\t\t\t\tif (!has_negative && !has_positive)\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"0\");\n\t\t\t\t}\n\t\t\t\telse if (!sql_standard_value)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * For non sql-standard interval values, force outputting\n\t\t\t\t\t * the signs to avoid ambiguities with intervals with\n\t\t\t\t\t * mixed sign components.\n\t\t\t\t\t */\n\t\t\t\t\tchar\t\tyear_sign = (year < 0 || mon < 0) ? '-' : '+';\n\t\t\t\t\tchar\t\tday_sign = (mday < 0) ? '-' : '+';\n\t\t\t\t\tchar\t\tsec_sign = (hour < 0 || min < 0 ||\n\t\t\t\t\t\t\t\t\t\t\tsec < 0 || fsec < 0) ? '-' : '+';\n\n\t\t\t\t\tsprintf(cp, \"%c%d-%d %c%d %c%d:%02d:\",\n\t\t\t\t\t\t\tyear_sign, abs(year), abs(mon),\n\t\t\t\t\t\t\tday_sign, abs(mday),\n\t\t\t\t\t\t\tsec_sign, abs(hour), abs(min));\n\t\t\t\t\tcp += strlen(cp);\n\t\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t}\n\t\t\t\telse if (has_year_month)\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"%d-%d\", year, mon);\n\t\t\t\t}\n\t\t\t\telse if (has_day)\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"%d %d:%02d:\", mday, hour, min);\n\t\t\t\t\tcp += strlen(cp);\n\t\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsprintf(cp, \"%d:%02d:\", hour, min);\n\t\t\t\t\tcp += strlen(cp);\n\t\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t\t*cp = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* ISO 8601 \"time-intervals by duration only\" */\n\t\tcase INTSTYLE_ISO_8601:\n\t\t\t/* special-case zero to avoid printing nothing */\n\t\t\tif (year == 0 && mon == 0 && mday == 0 &&\n\t\t\t\thour == 0 && min == 0 && sec == 0 && fsec == 0)\n\t\t\t{\n\t\t\t\tsprintf(cp, \"PT0S\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*cp++ = 'P';\n\t\t\tcp = AddISO8601IntPart(cp, year, 'Y');\n\t\t\tcp = AddISO8601IntPart(cp, mon, 'M');\n\t\t\tcp = AddISO8601IntPart(cp, mday, 'D');\n\t\t\tif (hour != 0 || min != 0 || sec != 0 || fsec != 0)\n\t\t\t\t*cp++ = 'T';\n\t\t\tcp = AddISO8601IntPart(cp, hour, 'H');\n\t\t\tcp = AddISO8601IntPart(cp, min, 'M');\n\t\t\tif (sec != 0 || fsec != 0)\n\t\t\t{\n\t\t\t\tif (sec < 0 || fsec < 0)\n\t\t\t\t\t*cp++ = '-';\n\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, false);\n\t\t\t\t*cp++ = 'S';\n\t\t\t\t*cp++ = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* Compatible with postgresql < 8.4 when DateStyle = 'iso' */\n\t\tcase INTSTYLE_POSTGRES:\n\t\t\tcp = AddPostgresIntPart(cp, year, \"year\", &is_zero, &is_before);\n\n\t\t\t/*\n\t\t\t * Ideally we should spell out \"month\" like we do for \"year\" and\n\t\t\t * \"day\".  However, for backward compatibility, we can't easily\n\t\t\t * fix this.  bjm 2011-05-24\n\t\t\t */\n\t\t\tcp = AddPostgresIntPart(cp, mon, \"mon\", &is_zero, &is_before);\n\t\t\tcp = AddPostgresIntPart(cp, mday, \"day\", &is_zero, &is_before);\n\t\t\tif (is_zero || hour != 0 || min != 0 || sec != 0 || fsec != 0)\n\t\t\t{\n\t\t\t\tbool\t\tminus = (hour < 0 || min < 0 || sec < 0 || fsec < 0);\n\n\t\t\t\tsprintf(cp, \"%s%s%02d:%02d:\",\n\t\t\t\t\t\tis_zero ? \"\" : \" \",\n\t\t\t\t\t\t(minus ? \"-\" : (is_before ? \"+\" : \"\")),\n\t\t\t\t\t\tabs(hour), abs(min));\n\t\t\t\tcp += strlen(cp);\n\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, true);\n\t\t\t\t*cp = '\\0';\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* Compatible with postgresql < 8.4 when DateStyle != 'iso' */\n\t\tcase INTSTYLE_POSTGRES_VERBOSE:\n\t\tdefault:\n\t\t\tstrcpy(cp, \"@\");\n\t\t\tcp++;\n\t\t\tcp = AddVerboseIntPart(cp, year, \"year\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, mon, \"mon\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, mday, \"day\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, hour, \"hour\", &is_zero, &is_before);\n\t\t\tcp = AddVerboseIntPart(cp, min, \"min\", &is_zero, &is_before);\n\t\t\tif (sec != 0 || fsec != 0)\n\t\t\t{\n\t\t\t\t*cp++ = ' ';\n\t\t\t\tif (sec < 0 || (sec == 0 && fsec < 0))\n\t\t\t\t{\n\t\t\t\t\tif (is_zero)\n\t\t\t\t\t\tis_before = true;\n\t\t\t\t\telse if (!is_before)\n\t\t\t\t\t\t*cp++ = '-';\n\t\t\t\t}\n\t\t\t\telse if (is_before)\n\t\t\t\t\t*cp++ = '-';\n\t\t\t\tcp = AppendSeconds(cp, sec, fsec, MAX_INTERVAL_PRECISION, false);\n\t\t\t\tsprintf(cp, \" sec%s\",\n\t\t\t\t\t\t(abs(sec) != 1 || fsec != 0) ? \"s\" : \"\");\n\t\t\t\tis_zero = false;\n\t\t\t}\n\t\t\t/* identically zero? then put in a unitless zero... */\n\t\t\tif (is_zero)\n\t\t\t\tstrcat(cp, \" 0\");\n\t\t\tif (is_before)\n\t\t\t\tstrcat(cp, \" ago\");\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reltime2tm",
          "args": [
            "time",
            "tm"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "reltime2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "685-696",
          "snippet": "static void\nreltime2tm(RelativeTime time, struct pg_tm *tm)\n{\n\tdouble\t\tdtime = time;\n\n\tFMODULO(dtime, tm->tm_year, 31557600);\n\tFMODULO(dtime, tm->tm_mon, 2592000);\n\tFMODULO(dtime, tm->tm_mday, SECS_PER_DAY);\n\tFMODULO(dtime, tm->tm_hour, SECS_PER_HOUR);\n\tFMODULO(dtime, tm->tm_min, SECS_PER_MINUTE);\n\tFMODULO(dtime, tm->tm_sec, 1);\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void reltime2tm(RelativeTime time, struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void reltime2tm(RelativeTime time, struct pg_tm *tm);\n\nstatic void\nreltime2tm(RelativeTime time, struct pg_tm *tm)\n{\n\tdouble\t\tdtime = time;\n\n\tFMODULO(dtime, tm->tm_year, 31557600);\n\tFMODULO(dtime, tm->tm_mon, 2592000);\n\tFMODULO(dtime, tm->tm_mday, SECS_PER_DAY);\n\tFMODULO(dtime, tm->tm_hour, SECS_PER_HOUR);\n\tFMODULO(dtime, tm->tm_min, SECS_PER_MINUTE);\n\tFMODULO(dtime, tm->tm_sec, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_RELATIVETIME",
          "args": [
            "0"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void reltime2tm(RelativeTime time, struct pg_tm *tm);\n\nDatum\nreltimeout(PG_FUNCTION_ARGS)\n{\n\tRelativeTime time = PG_GETARG_RELATIVETIME(0);\n\tchar\t   *result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tchar\t\tbuf[MAXDATELEN + 1];\n\n\treltime2tm(time, tm);\n\tEncodeInterval(tm, 0, IntervalStyle, buf);\n\n\tresult = pstrdup(buf);\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "reltimein",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "590-638",
    "snippet": "Datum\nreltimein(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tRelativeTime result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\tdtype;\n\tint\t\t\tdterr;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tnf,\n\t\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tworkbuf[MAXDATELEN + 1];\n\n\tdterr = ParseDateTime(str, workbuf, sizeof(workbuf),\n\t\t\t\t\t\t  field, ftype, MAXDATEFIELDS, &nf);\n\tif (dterr == 0)\n\t\tdterr = DecodeInterval(field, ftype, nf, INTERVAL_FULL_RANGE,\n\t\t\t\t\t\t\t   &dtype, tm, &fsec);\n\n\t/* if those functions think it's a bad format, try ISO8601 style */\n\tif (dterr == DTERR_BAD_FORMAT)\n\t\tdterr = DecodeISO8601Interval(str,\n\t\t\t\t\t\t\t\t\t  &dtype, tm, &fsec);\n\n\tif (dterr != 0)\n\t{\n\t\tif (dterr == DTERR_FIELD_OVERFLOW)\n\t\t\tdterr = DTERR_INTERVAL_OVERFLOW;\n\t\tDateTimeParseError(dterr, str, \"reltime\");\n\t}\n\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DELTA:\n\t\t\tresult = ((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) * SECS_PER_MINUTE) + tm->tm_sec;\n\t\t\tresult += tm->tm_year * SECS_PER_YEAR + ((tm->tm_mon * DAYS_PER_MONTH) + tm->tm_mday) * SECS_PER_DAY;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected dtype %d while parsing reltime \\\"%s\\\"\",\n\t\t\t\t dtype, str);\n\t\t\tresult = INVALID_RELTIME;\n\t\t\tbreak;\n\t}\n\n\tPG_RETURN_RELATIVETIME(result);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void reltime2tm(RelativeTime time, struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_RELATIVETIME",
          "args": [
            "result"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected dtype %d while parsing reltime \\\"%s\\\"\"",
            "dtype",
            "str"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DateTimeParseError",
          "args": [
            "dterr",
            "str",
            "\"reltime\""
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "DateTimeParseError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3753-3792",
          "snippet": "void\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeISO8601Interval",
          "args": [
            "str",
            "&dtype",
            "tm",
            "&fsec"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeISO8601Interval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3507-3703",
          "snippet": "int\nDecodeISO8601Interval(char *str,\n\t\t\t\t\t  int *dtype, struct pg_tm *tm, fsec_t *fsec)\n{\n\tbool\t\tdatepart = true;\n\tbool\t\thavefield = false;\n\n\t*dtype = DTK_DELTA;\n\tClearPgTm(tm, fsec);\n\n\tif (strlen(str) < 2 || str[0] != 'P')\n\t\treturn DTERR_BAD_FORMAT;\n\n\tstr++;\n\twhile (*str)\n\t{\n\t\tchar\t   *fieldstart;\n\t\tint\t\t\tval;\n\t\tdouble\t\tfval;\n\t\tchar\t\tunit;\n\t\tint\t\t\tdterr;\n\n\t\tif (*str == 'T')\t\t/* T indicates the beginning of the time part */\n\t\t{\n\t\t\tdatepart = false;\n\t\t\thavefield = false;\n\t\t\tstr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfieldstart = str;\n\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\n\t\t/*\n\t\t * Note: we could step off the end of the string here.  Code below\n\t\t * *must* exit the loop if unit == '\\0'.\n\t\t */\n\t\tunit = *str++;\n\n\t\tif (datepart)\n\t\t{\n\t\t\tswitch (unit)\t\t/* before T: Y M W D */\n\t\t\t{\n\t\t\t\tcase 'Y':\n\t\t\t\t\ttm->tm_year += val;\n\t\t\t\t\ttm->tm_mon += (fval * MONTHS_PER_YEAR);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\ttm->tm_mon += val;\n\t\t\t\t\tAdjustFractDays(fval, tm, fsec, DAYS_PER_MONTH);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W':\n\t\t\t\t\ttm->tm_mday += val * 7;\n\t\t\t\t\tAdjustFractDays(fval, tm, fsec, 7);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\ttm->tm_mday += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T':\t\t/* ISO 8601 4.4.3.3 Alternative Format / Basic */\n\t\t\t\tcase '\\0':\n\t\t\t\t\tif (ISO8601IntegerWidth(fieldstart) == 8 && !havefield)\n\t\t\t\t\t{\n\t\t\t\t\t\ttm->tm_year += val / 10000;\n\t\t\t\t\t\ttm->tm_mon += (val / 100) % 100;\n\t\t\t\t\t\ttm->tm_mday += val % 100;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\t\tif (unit == '\\0')\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/* Else fall through to extended alternative format */\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase '-':\t\t/* ISO 8601 4.4.3.3 Alternative Format,\n\t\t\t\t\t\t\t\t * Extended */\n\t\t\t\t\tif (havefield)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\ttm->tm_year += val;\n\t\t\t\t\ttm->tm_mon += (fval * MONTHS_PER_YEAR);\n\t\t\t\t\tif (unit == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (unit == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_mon += val;\n\t\t\t\t\tAdjustFractDays(fval, tm, fsec, DAYS_PER_MONTH);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (*str == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (*str != '-')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tstr++;\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_mday += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (*str == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\tdefault:\n\t\t\t\t\t/* not a valid date unit suffix */\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswitch (unit)\t\t/* after T: H M S */\n\t\t\t{\n\t\t\t\tcase 'H':\n\t\t\t\t\ttm->tm_hour += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_HOUR);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\ttm->tm_min += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_MINUTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\ttm->tm_sec += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\0':\t\t/* ISO 8601 4.4.3.3 Alternative Format */\n\t\t\t\t\tif (ISO8601IntegerWidth(fieldstart) == 6 && !havefield)\n\t\t\t\t\t{\n\t\t\t\t\t\ttm->tm_hour += val / 10000;\n\t\t\t\t\t\ttm->tm_min += (val / 100) % 100;\n\t\t\t\t\t\ttm->tm_sec += val % 100;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, 1);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* Else fall through to extended alternative format */\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase ':':\t\t/* ISO 8601 4.4.3.3 Alternative Format,\n\t\t\t\t\t\t\t\t * Extended */\n\t\t\t\t\tif (havefield)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\ttm->tm_hour += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_HOUR);\n\t\t\t\t\tif (unit == '\\0')\n\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_min += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_MINUTE);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (*str != ':')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tstr++;\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_sec += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, 1);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* not a valid time unit suffix */\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t}\n\t\t}\n\n\t\thavefield = true;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDecodeISO8601Interval(char *str,\n\t\t\t\t\t  int *dtype, struct pg_tm *tm, fsec_t *fsec)\n{\n\tbool\t\tdatepart = true;\n\tbool\t\thavefield = false;\n\n\t*dtype = DTK_DELTA;\n\tClearPgTm(tm, fsec);\n\n\tif (strlen(str) < 2 || str[0] != 'P')\n\t\treturn DTERR_BAD_FORMAT;\n\n\tstr++;\n\twhile (*str)\n\t{\n\t\tchar\t   *fieldstart;\n\t\tint\t\t\tval;\n\t\tdouble\t\tfval;\n\t\tchar\t\tunit;\n\t\tint\t\t\tdterr;\n\n\t\tif (*str == 'T')\t\t/* T indicates the beginning of the time part */\n\t\t{\n\t\t\tdatepart = false;\n\t\t\thavefield = false;\n\t\t\tstr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfieldstart = str;\n\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\tif (dterr)\n\t\t\treturn dterr;\n\n\t\t/*\n\t\t * Note: we could step off the end of the string here.  Code below\n\t\t * *must* exit the loop if unit == '\\0'.\n\t\t */\n\t\tunit = *str++;\n\n\t\tif (datepart)\n\t\t{\n\t\t\tswitch (unit)\t\t/* before T: Y M W D */\n\t\t\t{\n\t\t\t\tcase 'Y':\n\t\t\t\t\ttm->tm_year += val;\n\t\t\t\t\ttm->tm_mon += (fval * MONTHS_PER_YEAR);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\ttm->tm_mon += val;\n\t\t\t\t\tAdjustFractDays(fval, tm, fsec, DAYS_PER_MONTH);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W':\n\t\t\t\t\ttm->tm_mday += val * 7;\n\t\t\t\t\tAdjustFractDays(fval, tm, fsec, 7);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\ttm->tm_mday += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T':\t\t/* ISO 8601 4.4.3.3 Alternative Format / Basic */\n\t\t\t\tcase '\\0':\n\t\t\t\t\tif (ISO8601IntegerWidth(fieldstart) == 8 && !havefield)\n\t\t\t\t\t{\n\t\t\t\t\t\ttm->tm_year += val / 10000;\n\t\t\t\t\t\ttm->tm_mon += (val / 100) % 100;\n\t\t\t\t\t\ttm->tm_mday += val % 100;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\t\tif (unit == '\\0')\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/* Else fall through to extended alternative format */\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase '-':\t\t/* ISO 8601 4.4.3.3 Alternative Format,\n\t\t\t\t\t\t\t\t * Extended */\n\t\t\t\t\tif (havefield)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\ttm->tm_year += val;\n\t\t\t\t\ttm->tm_mon += (fval * MONTHS_PER_YEAR);\n\t\t\t\t\tif (unit == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (unit == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_mon += val;\n\t\t\t\t\tAdjustFractDays(fval, tm, fsec, DAYS_PER_MONTH);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (*str == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (*str != '-')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tstr++;\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_mday += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (*str == 'T')\n\t\t\t\t\t{\n\t\t\t\t\t\tdatepart = false;\n\t\t\t\t\t\thavefield = false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\tdefault:\n\t\t\t\t\t/* not a valid date unit suffix */\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tswitch (unit)\t\t/* after T: H M S */\n\t\t\t{\n\t\t\t\tcase 'H':\n\t\t\t\t\ttm->tm_hour += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_HOUR);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\ttm->tm_min += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_MINUTE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\ttm->tm_sec += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, 1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\0':\t\t/* ISO 8601 4.4.3.3 Alternative Format */\n\t\t\t\t\tif (ISO8601IntegerWidth(fieldstart) == 6 && !havefield)\n\t\t\t\t\t{\n\t\t\t\t\t\ttm->tm_hour += val / 10000;\n\t\t\t\t\t\ttm->tm_min += (val / 100) % 100;\n\t\t\t\t\t\ttm->tm_sec += val % 100;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, 1);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\t/* Else fall through to extended alternative format */\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase ':':\t\t/* ISO 8601 4.4.3.3 Alternative Format,\n\t\t\t\t\t\t\t\t * Extended */\n\t\t\t\t\tif (havefield)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\ttm->tm_hour += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_HOUR);\n\t\t\t\t\tif (unit == '\\0')\n\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_min += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_MINUTE);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\tif (*str != ':')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tstr++;\n\n\t\t\t\t\tdterr = ParseISO8601Number(str, &str, &val, &fval);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\ttm->tm_sec += val;\n\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, 1);\n\t\t\t\t\tif (*str == '\\0')\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* not a valid time unit suffix */\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t}\n\t\t}\n\n\t\thavefield = true;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeInterval",
          "args": [
            "field",
            "ftype",
            "nf",
            "INTERVAL_FULL_RANGE",
            "&dtype",
            "tm",
            "&fsec"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeInterval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3081-3443",
          "snippet": "int\nDecodeInterval(char **field, int *ftype, int nf, int range,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec)\n{\n\tbool\t\tis_before = false;\n\tchar\t   *cp;\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\ti;\n\tint\t\t\tdterr;\n\tint\t\t\tval;\n\tdouble\t\tfval;\n\n\t*dtype = DTK_DELTA;\n\ttype = IGNORE_DTF;\n\tClearPgTm(tm, fsec);\n\n\t/* read through list backwards to pick up units before values */\n\tfor (i = nf - 1; i >= 0; i--)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_TIME:\n\t\t\t\tdterr = DecodeTime(field[i], fmask, range,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\t\t\t\ttype = DTK_DAY;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\n\t\t\t\t/*\n\t\t\t\t * Timezone means a token with a leading sign character and at\n\t\t\t\t * least one digit; there could be ':', '.', '-' embedded in\n\t\t\t\t * it as well.\n\t\t\t\t */\n\t\t\t\tAssert(*field[i] == '-' || *field[i] == '+');\n\n\t\t\t\t/*\n\t\t\t\t * Check for signed hh:mm or hh:mm:ss.  If so, process exactly\n\t\t\t\t * like DTK_TIME case above, plus handling the sign.\n\t\t\t\t */\n\t\t\t\tif (strchr(field[i] + 1, ':') != NULL &&\n\t\t\t\t\tDecodeTime(field[i] + 1, fmask, range,\n\t\t\t\t\t\t\t   &tmask, tm, fsec) == 0)\n\t\t\t\t{\n\t\t\t\t\tif (*field[i] == '-')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* flip the sign on all fields */\n\t\t\t\t\t\ttm->tm_hour = -tm->tm_hour;\n\t\t\t\t\t\ttm->tm_min = -tm->tm_min;\n\t\t\t\t\t\ttm->tm_sec = -tm->tm_sec;\n\t\t\t\t\t\t*fsec = -(*fsec);\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set the next type to be a day, if units are not\n\t\t\t\t\t * specified. This handles the case of '1 +02:03' since we\n\t\t\t\t\t * are reading right to left.\n\t\t\t\t\t */\n\t\t\t\t\ttype = DTK_DAY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Otherwise, fall through to DTK_NUMBER case, which can\n\t\t\t\t * handle signed float numbers and signed year-month values.\n\t\t\t\t */\n\n\t\t\t\t/* FALLTHROUGH */\n\n\t\t\tcase DTK_DATE:\n\t\t\tcase DTK_NUMBER:\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t{\n\t\t\t\t\t/* use typmod to decide what rightmost field is */\n\t\t\t\t\tswitch (range)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase INTERVAL_MASK(YEAR):\n\t\t\t\t\t\t\ttype = DTK_YEAR;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(MONTH):\n\t\t\t\t\t\tcase INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH):\n\t\t\t\t\t\t\ttype = DTK_MONTH;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY):\n\t\t\t\t\t\t\ttype = DTK_DAY;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(HOUR):\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR):\n\t\t\t\t\t\t\ttype = DTK_HOUR;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(MINUTE):\n\t\t\t\t\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\t\t\t\t\ttype = DTK_MINUTE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(SECOND):\n\t\t\t\t\t\tcase INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\t\t\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\t\t\t\t\ttype = DTK_SECOND;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ttype = DTK_SECOND;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\terrno = 0;\n\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\tif (*cp == '-')\n\t\t\t\t{\n\t\t\t\t\t/* SQL \"years-months\" syntax */\n\t\t\t\t\tint\t\t\tval2;\n\n\t\t\t\t\tval2 = strtoint(cp + 1, &cp, 10);\n\t\t\t\t\tif (errno == ERANGE || val2 < 0 || val2 >= MONTHS_PER_YEAR)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\tif (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\ttype = DTK_MONTH;\n\t\t\t\t\tif (*field[i] == '-')\n\t\t\t\t\t\tval2 = -val2;\n\t\t\t\t\tif (((double) val * MONTHS_PER_YEAR + val2) > INT_MAX ||\n\t\t\t\t\t\t((double) val * MONTHS_PER_YEAR + val2) < INT_MIN)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\tval = val * MONTHS_PER_YEAR + val2;\n\t\t\t\t\tfval = 0;\n\t\t\t\t}\n\t\t\t\telse if (*cp == '.')\n\t\t\t\t{\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tfval = strtod(cp, &cp);\n\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tif (*field[i] == '-')\n\t\t\t\t\t\tfval = -fval;\n\t\t\t\t}\n\t\t\t\telse if (*cp == '\\0')\n\t\t\t\t\tfval = 0;\n\t\t\t\telse\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\ttmask = 0;\t\t/* DTK_M(type); */\n\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase DTK_MICROSEC:\n\t\t\t\t\t\t*fsec += rint(val + fval);\n\t\t\t\t\t\ttmask = DTK_M(MICROSECOND);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MILLISEC:\n\t\t\t\t\t\t/* avoid overflowing the fsec field */\n\t\t\t\t\t\ttm->tm_sec += val / 1000;\n\t\t\t\t\t\tval -= (val / 1000) * 1000;\n\t\t\t\t\t\t*fsec += rint((val + fval) * 1000);\n\t\t\t\t\t\ttmask = DTK_M(MILLISECOND);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\ttm->tm_sec += val;\n\t\t\t\t\t\t*fsec += rint(fval * 1000000);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If any subseconds were specified, consider this\n\t\t\t\t\t\t * microsecond and millisecond input as well.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (fval == 0)\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\ttm->tm_min += val;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_MINUTE);\n\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\ttm->tm_hour += val;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_HOUR);\n\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\ttype = DTK_DAY; /* set for next field */\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\ttm->tm_mday += val;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_WEEK:\n\t\t\t\t\t\ttm->tm_mday += val * 7;\n\t\t\t\t\t\tAdjustFractDays(fval, tm, fsec, 7);\n\t\t\t\t\t\ttmask = DTK_M(WEEK);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MONTH:\n\t\t\t\t\t\ttm->tm_mon += val;\n\t\t\t\t\t\tAdjustFractDays(fval, tm, fsec, DAYS_PER_MONTH);\n\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\ttm->tm_year += val;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR;\n\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_DECADE:\n\t\t\t\t\t\ttm->tm_year += val * 10;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR * 10;\n\t\t\t\t\t\ttmask = DTK_M(DECADE);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_CENTURY:\n\t\t\t\t\t\ttm->tm_year += val * 100;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR * 100;\n\t\t\t\t\t\ttmask = DTK_M(CENTURY);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MILLENNIUM:\n\t\t\t\t\t\ttm->tm_year += val * 1000;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR * 1000;\n\t\t\t\t\t\ttmask = DTK_M(MILLENNIUM);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\ttype = DecodeUnits(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = 0;\t\t/* DTK_M(type); */\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AGO:\n\t\t\t\t\t\tis_before = true;\n\t\t\t\t\t\ttype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\ttmask = (DTK_DATE_M | DTK_TIME_M);\n\t\t\t\t\t\t*dtype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\n\n\t/* ensure that at least one time field has been found */\n\tif (fmask == 0)\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* ensure fractional seconds are fractional */\n\tif (*fsec != 0)\n\t{\n\t\tint\t\t\tsec;\n\n\t\tsec = *fsec / USECS_PER_SEC;\n\t\t*fsec -= sec * USECS_PER_SEC;\n\t\ttm->tm_sec += sec;\n\t}\n\n\t/*----------\n\t * The SQL standard defines the interval literal\n\t *\t '-1 1:00:00'\n\t * to mean \"negative 1 days and negative 1 hours\", while Postgres\n\t * traditionally treats this as meaning \"negative 1 days and positive\n\t * 1 hours\".  In SQL_STANDARD intervalstyle, we apply the leading sign\n\t * to all fields if there are no other explicit signs.\n\t *\n\t * We leave the signs alone if there are additional explicit signs.\n\t * This protects us against misinterpreting postgres-style dump output,\n\t * since the postgres-style output code has always put an explicit sign on\n\t * all fields following a negative field.  But note that SQL-spec output\n\t * is ambiguous and can be misinterpreted on load!\t(So it's best practice\n\t * to dump in postgres style, not SQL style.)\n\t *----------\n\t */\n\tif (IntervalStyle == INTSTYLE_SQL_STANDARD && *field[0] == '-')\n\t{\n\t\t/* Check for additional explicit signs */\n\t\tbool\t\tmore_signs = false;\n\n\t\tfor (i = 1; i < nf; i++)\n\t\t{\n\t\t\tif (*field[i] == '-' || *field[i] == '+')\n\t\t\t{\n\t\t\t\tmore_signs = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!more_signs)\n\t\t{\n\t\t\t/*\n\t\t\t * Rather than re-determining which field was field[0], just force\n\t\t\t * 'em all negative.\n\t\t\t */\n\t\t\tif (*fsec > 0)\n\t\t\t\t*fsec = -(*fsec);\n\t\t\tif (tm->tm_sec > 0)\n\t\t\t\ttm->tm_sec = -tm->tm_sec;\n\t\t\tif (tm->tm_min > 0)\n\t\t\t\ttm->tm_min = -tm->tm_min;\n\t\t\tif (tm->tm_hour > 0)\n\t\t\t\ttm->tm_hour = -tm->tm_hour;\n\t\t\tif (tm->tm_mday > 0)\n\t\t\t\ttm->tm_mday = -tm->tm_mday;\n\t\t\tif (tm->tm_mon > 0)\n\t\t\t\ttm->tm_mon = -tm->tm_mon;\n\t\t\tif (tm->tm_year > 0)\n\t\t\t\ttm->tm_year = -tm->tm_year;\n\t\t}\n\t}\n\n\t/* finally, AGO negates everything */\n\tif (is_before)\n\t{\n\t\t*fsec = -(*fsec);\n\t\ttm->tm_sec = -tm->tm_sec;\n\t\ttm->tm_min = -tm->tm_min;\n\t\ttm->tm_hour = -tm->tm_hour;\n\t\ttm->tm_mday = -tm->tm_mday;\n\t\ttm->tm_mon = -tm->tm_mon;\n\t\ttm->tm_year = -tm->tm_year;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "const char *const months[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", NULL};",
            "const char *const days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\", NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nconst char *const months[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", NULL};\nconst char *const days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\", NULL};\n\nint\nDecodeInterval(char **field, int *ftype, int nf, int range,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec)\n{\n\tbool\t\tis_before = false;\n\tchar\t   *cp;\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\ti;\n\tint\t\t\tdterr;\n\tint\t\t\tval;\n\tdouble\t\tfval;\n\n\t*dtype = DTK_DELTA;\n\ttype = IGNORE_DTF;\n\tClearPgTm(tm, fsec);\n\n\t/* read through list backwards to pick up units before values */\n\tfor (i = nf - 1; i >= 0; i--)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_TIME:\n\t\t\t\tdterr = DecodeTime(field[i], fmask, range,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\t\t\t\ttype = DTK_DAY;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\n\t\t\t\t/*\n\t\t\t\t * Timezone means a token with a leading sign character and at\n\t\t\t\t * least one digit; there could be ':', '.', '-' embedded in\n\t\t\t\t * it as well.\n\t\t\t\t */\n\t\t\t\tAssert(*field[i] == '-' || *field[i] == '+');\n\n\t\t\t\t/*\n\t\t\t\t * Check for signed hh:mm or hh:mm:ss.  If so, process exactly\n\t\t\t\t * like DTK_TIME case above, plus handling the sign.\n\t\t\t\t */\n\t\t\t\tif (strchr(field[i] + 1, ':') != NULL &&\n\t\t\t\t\tDecodeTime(field[i] + 1, fmask, range,\n\t\t\t\t\t\t\t   &tmask, tm, fsec) == 0)\n\t\t\t\t{\n\t\t\t\t\tif (*field[i] == '-')\n\t\t\t\t\t{\n\t\t\t\t\t\t/* flip the sign on all fields */\n\t\t\t\t\t\ttm->tm_hour = -tm->tm_hour;\n\t\t\t\t\t\ttm->tm_min = -tm->tm_min;\n\t\t\t\t\t\ttm->tm_sec = -tm->tm_sec;\n\t\t\t\t\t\t*fsec = -(*fsec);\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Set the next type to be a day, if units are not\n\t\t\t\t\t * specified. This handles the case of '1 +02:03' since we\n\t\t\t\t\t * are reading right to left.\n\t\t\t\t\t */\n\t\t\t\t\ttype = DTK_DAY;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Otherwise, fall through to DTK_NUMBER case, which can\n\t\t\t\t * handle signed float numbers and signed year-month values.\n\t\t\t\t */\n\n\t\t\t\t/* FALLTHROUGH */\n\n\t\t\tcase DTK_DATE:\n\t\t\tcase DTK_NUMBER:\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t{\n\t\t\t\t\t/* use typmod to decide what rightmost field is */\n\t\t\t\t\tswitch (range)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase INTERVAL_MASK(YEAR):\n\t\t\t\t\t\t\ttype = DTK_YEAR;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(MONTH):\n\t\t\t\t\t\tcase INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH):\n\t\t\t\t\t\t\ttype = DTK_MONTH;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY):\n\t\t\t\t\t\t\ttype = DTK_DAY;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(HOUR):\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR):\n\t\t\t\t\t\t\ttype = DTK_HOUR;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(MINUTE):\n\t\t\t\t\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):\n\t\t\t\t\t\t\ttype = DTK_MINUTE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase INTERVAL_MASK(SECOND):\n\t\t\t\t\t\tcase INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\t\t\t\tcase INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\t\t\t\tcase INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):\n\t\t\t\t\t\t\ttype = DTK_SECOND;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ttype = DTK_SECOND;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\terrno = 0;\n\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\tif (*cp == '-')\n\t\t\t\t{\n\t\t\t\t\t/* SQL \"years-months\" syntax */\n\t\t\t\t\tint\t\t\tval2;\n\n\t\t\t\t\tval2 = strtoint(cp + 1, &cp, 10);\n\t\t\t\t\tif (errno == ERANGE || val2 < 0 || val2 >= MONTHS_PER_YEAR)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\tif (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\ttype = DTK_MONTH;\n\t\t\t\t\tif (*field[i] == '-')\n\t\t\t\t\t\tval2 = -val2;\n\t\t\t\t\tif (((double) val * MONTHS_PER_YEAR + val2) > INT_MAX ||\n\t\t\t\t\t\t((double) val * MONTHS_PER_YEAR + val2) < INT_MIN)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\tval = val * MONTHS_PER_YEAR + val2;\n\t\t\t\t\tfval = 0;\n\t\t\t\t}\n\t\t\t\telse if (*cp == '.')\n\t\t\t\t{\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tfval = strtod(cp, &cp);\n\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tif (*field[i] == '-')\n\t\t\t\t\t\tfval = -fval;\n\t\t\t\t}\n\t\t\t\telse if (*cp == '\\0')\n\t\t\t\t\tfval = 0;\n\t\t\t\telse\n\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\ttmask = 0;\t\t/* DTK_M(type); */\n\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase DTK_MICROSEC:\n\t\t\t\t\t\t*fsec += rint(val + fval);\n\t\t\t\t\t\ttmask = DTK_M(MICROSECOND);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MILLISEC:\n\t\t\t\t\t\t/* avoid overflowing the fsec field */\n\t\t\t\t\t\ttm->tm_sec += val / 1000;\n\t\t\t\t\t\tval -= (val / 1000) * 1000;\n\t\t\t\t\t\t*fsec += rint((val + fval) * 1000);\n\t\t\t\t\t\ttmask = DTK_M(MILLISECOND);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\ttm->tm_sec += val;\n\t\t\t\t\t\t*fsec += rint(fval * 1000000);\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If any subseconds were specified, consider this\n\t\t\t\t\t\t * microsecond and millisecond input as well.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (fval == 0)\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\ttm->tm_min += val;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_MINUTE);\n\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\ttm->tm_hour += val;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_HOUR);\n\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\ttype = DTK_DAY; /* set for next field */\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\ttm->tm_mday += val;\n\t\t\t\t\t\tAdjustFractSeconds(fval, tm, fsec, SECS_PER_DAY);\n\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_WEEK:\n\t\t\t\t\t\ttm->tm_mday += val * 7;\n\t\t\t\t\t\tAdjustFractDays(fval, tm, fsec, 7);\n\t\t\t\t\t\ttmask = DTK_M(WEEK);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MONTH:\n\t\t\t\t\t\ttm->tm_mon += val;\n\t\t\t\t\t\tAdjustFractDays(fval, tm, fsec, DAYS_PER_MONTH);\n\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\ttm->tm_year += val;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR;\n\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_DECADE:\n\t\t\t\t\t\ttm->tm_year += val * 10;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR * 10;\n\t\t\t\t\t\ttmask = DTK_M(DECADE);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_CENTURY:\n\t\t\t\t\t\ttm->tm_year += val * 100;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR * 100;\n\t\t\t\t\t\ttmask = DTK_M(CENTURY);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTK_MILLENNIUM:\n\t\t\t\t\t\ttm->tm_year += val * 1000;\n\t\t\t\t\t\tif (fval != 0)\n\t\t\t\t\t\t\ttm->tm_mon += fval * MONTHS_PER_YEAR * 1000;\n\t\t\t\t\t\ttmask = DTK_M(MILLENNIUM);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\ttype = DecodeUnits(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = 0;\t\t/* DTK_M(type); */\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AGO:\n\t\t\t\t\t\tis_before = true;\n\t\t\t\t\t\ttype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\ttmask = (DTK_DATE_M | DTK_TIME_M);\n\t\t\t\t\t\t*dtype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\n\n\t/* ensure that at least one time field has been found */\n\tif (fmask == 0)\n\t\treturn DTERR_BAD_FORMAT;\n\n\t/* ensure fractional seconds are fractional */\n\tif (*fsec != 0)\n\t{\n\t\tint\t\t\tsec;\n\n\t\tsec = *fsec / USECS_PER_SEC;\n\t\t*fsec -= sec * USECS_PER_SEC;\n\t\ttm->tm_sec += sec;\n\t}\n\n\t/*----------\n\t * The SQL standard defines the interval literal\n\t *\t '-1 1:00:00'\n\t * to mean \"negative 1 days and negative 1 hours\", while Postgres\n\t * traditionally treats this as meaning \"negative 1 days and positive\n\t * 1 hours\".  In SQL_STANDARD intervalstyle, we apply the leading sign\n\t * to all fields if there are no other explicit signs.\n\t *\n\t * We leave the signs alone if there are additional explicit signs.\n\t * This protects us against misinterpreting postgres-style dump output,\n\t * since the postgres-style output code has always put an explicit sign on\n\t * all fields following a negative field.  But note that SQL-spec output\n\t * is ambiguous and can be misinterpreted on load!\t(So it's best practice\n\t * to dump in postgres style, not SQL style.)\n\t *----------\n\t */\n\tif (IntervalStyle == INTSTYLE_SQL_STANDARD && *field[0] == '-')\n\t{\n\t\t/* Check for additional explicit signs */\n\t\tbool\t\tmore_signs = false;\n\n\t\tfor (i = 1; i < nf; i++)\n\t\t{\n\t\t\tif (*field[i] == '-' || *field[i] == '+')\n\t\t\t{\n\t\t\t\tmore_signs = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!more_signs)\n\t\t{\n\t\t\t/*\n\t\t\t * Rather than re-determining which field was field[0], just force\n\t\t\t * 'em all negative.\n\t\t\t */\n\t\t\tif (*fsec > 0)\n\t\t\t\t*fsec = -(*fsec);\n\t\t\tif (tm->tm_sec > 0)\n\t\t\t\ttm->tm_sec = -tm->tm_sec;\n\t\t\tif (tm->tm_min > 0)\n\t\t\t\ttm->tm_min = -tm->tm_min;\n\t\t\tif (tm->tm_hour > 0)\n\t\t\t\ttm->tm_hour = -tm->tm_hour;\n\t\t\tif (tm->tm_mday > 0)\n\t\t\t\ttm->tm_mday = -tm->tm_mday;\n\t\t\tif (tm->tm_mon > 0)\n\t\t\t\ttm->tm_mon = -tm->tm_mon;\n\t\t\tif (tm->tm_year > 0)\n\t\t\t\ttm->tm_year = -tm->tm_year;\n\t\t}\n\t}\n\n\t/* finally, AGO negates everything */\n\tif (is_before)\n\t{\n\t\t*fsec = -(*fsec);\n\t\ttm->tm_sec = -tm->tm_sec;\n\t\ttm->tm_min = -tm->tm_min;\n\t\ttm->tm_hour = -tm->tm_hour;\n\t\ttm->tm_mday = -tm->tm_mday;\n\t\ttm->tm_mon = -tm->tm_mon;\n\t\ttm->tm_year = -tm->tm_year;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseDateTime",
          "args": [
            "str",
            "workbuf",
            "sizeof(workbuf)",
            "field",
            "ftype",
            "MAXDATEFIELDS",
            "&nf"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "ParseDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "545-739",
          "snippet": "int\nParseDateTime(const char *timestr, char *workbuf, size_t buflen,\n\t\t\t  char **field, int *ftype, int maxfields, int *numfields)\n{\n\tint\t\t\tnf = 0;\n\tconst char *cp = timestr;\n\tchar\t   *bufp = workbuf;\n\tconst char *bufend = workbuf + buflen;\n\n\t/*\n\t * Set the character pointed-to by \"bufptr\" to \"newchar\", and increment\n\t * \"bufptr\". \"end\" gives the end of the buffer -- we return an error if\n\t * there is no space left to append a character to the buffer. Note that\n\t * \"bufptr\" is evaluated twice.\n\t */\n#define APPEND_CHAR(bufptr, end, newchar)\t\t\\\n\tdo\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (((bufptr) + 1) >= (end))\t\t\t\\\n\t\t\treturn DTERR_BAD_FORMAT;\t\t\t\\\n\t\t*(bufptr)++ = newchar;\t\t\t\t\t\\\n\t} while (0)\n\n\t/* outer loop through fields */\n\twhile (*cp != '\\0')\n\t{\n\t\t/* Ignore spaces between fields */\n\t\tif (isspace((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record start of current field */\n\t\tif (nf >= maxfields)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfield[nf] = bufp;\n\n\t\t/* leading digit? then date or time */\n\t\tif (isdigit((unsigned char) *cp))\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t/* time field? */\n\t\t\tif (*cp == ':')\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TIME;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   (*cp == ':') || (*cp == '.'))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* date field? allow embedded text month */\n\t\t\telse if (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t{\n\t\t\t\t/* save delimiting character to use later */\n\t\t\t\tchar\t\tdelim = *cp;\n\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t/* second field is all digits? then no embedded text month */\n\t\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = ((delim == '.') ? DTK_NUMBER : DTK_DATE);\n\t\t\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * insist that the delimiters match to get a three-field\n\t\t\t\t\t * date.\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == delim)\n\t\t\t\t\t{\n\t\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t\twhile (isdigit((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\twhile (isalnum((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * otherwise, number only and will determine year, month, day, or\n\t\t\t * concatenated fields later...\n\t\t\t */\n\t\t\telse\n\t\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\t\t/* Leading decimal point? Then fractional seconds... */\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\n\t\t/*\n\t\t * text? then date string, month, day of week, special, or timezone\n\t\t */\n\t\telse if (isalpha((unsigned char) *cp))\n\t\t{\n\t\t\tbool\t\tis_date;\n\n\t\t\tftype[nf] = DTK_STRING;\n\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\n\t\t\t/*\n\t\t\t * Dates can have embedded '-', '/', or '.' separators.  It could\n\t\t\t * also be a timezone name containing embedded '/', '+', '-', '_',\n\t\t\t * or ':' (but '_' or ':' can't be the first punctuation). If the\n\t\t\t * next character is a digit or '+', we need to check whether what\n\t\t\t * we have so far is a recognized non-timezone keyword --- if so,\n\t\t\t * don't believe that this is the start of a timezone.\n\t\t\t */\n\t\t\tis_date = false;\n\t\t\tif (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t\tis_date = true;\n\t\t\telse if (*cp == '+' || isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\t*bufp = '\\0';\t/* null-terminate current field value */\n\t\t\t\t/* we need search only the core token table, not TZ names */\n\t\t\t\tif (datebsearch(field[nf], datetktbl, szdatetktbl) == NULL)\n\t\t\t\t\tis_date = true;\n\t\t\t}\n\t\t\tif (is_date)\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t} while (*cp == '+' || *cp == '-' ||\n\t\t\t\t\t\t *cp == '/' || *cp == '_' ||\n\t\t\t\t\t\t *cp == '.' || *cp == ':' ||\n\t\t\t\t\t\t isalnum((unsigned char) *cp));\n\t\t\t}\n\t\t}\n\t\t/* sign? then special or numeric timezone */\n\t\telse if (*cp == '+' || *cp == '-')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t/* soak up leading whitespace */\n\t\t\twhile (isspace((unsigned char) *cp))\n\t\t\t\tcp++;\n\t\t\t/* numeric timezone? */\n\t\t\t/* note that \"DTK_TZ\" could also be a signed float or yyyy-mm */\n\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TZ;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   *cp == ':' || *cp == '.' || *cp == '-')\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* special? */\n\t\t\telse if (isalpha((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_SPECIAL;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t}\n\t\t\t/* otherwise something wrong... */\n\t\t\telse\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\t\t/* ignore other punctuation but use as delimiter */\n\t\telse if (ispunct((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* otherwise, something is not right... */\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* force in a delimiter after each field */\n\t\t*bufp++ = '\\0';\n\t\tnf++;\n\t}\n\n\t*numfields = nf;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};",
            "static int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};\nstatic int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];\n\nint\nParseDateTime(const char *timestr, char *workbuf, size_t buflen,\n\t\t\t  char **field, int *ftype, int maxfields, int *numfields)\n{\n\tint\t\t\tnf = 0;\n\tconst char *cp = timestr;\n\tchar\t   *bufp = workbuf;\n\tconst char *bufend = workbuf + buflen;\n\n\t/*\n\t * Set the character pointed-to by \"bufptr\" to \"newchar\", and increment\n\t * \"bufptr\". \"end\" gives the end of the buffer -- we return an error if\n\t * there is no space left to append a character to the buffer. Note that\n\t * \"bufptr\" is evaluated twice.\n\t */\n#define APPEND_CHAR(bufptr, end, newchar)\t\t\\\n\tdo\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (((bufptr) + 1) >= (end))\t\t\t\\\n\t\t\treturn DTERR_BAD_FORMAT;\t\t\t\\\n\t\t*(bufptr)++ = newchar;\t\t\t\t\t\\\n\t} while (0)\n\n\t/* outer loop through fields */\n\twhile (*cp != '\\0')\n\t{\n\t\t/* Ignore spaces between fields */\n\t\tif (isspace((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record start of current field */\n\t\tif (nf >= maxfields)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfield[nf] = bufp;\n\n\t\t/* leading digit? then date or time */\n\t\tif (isdigit((unsigned char) *cp))\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t/* time field? */\n\t\t\tif (*cp == ':')\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TIME;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   (*cp == ':') || (*cp == '.'))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* date field? allow embedded text month */\n\t\t\telse if (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t{\n\t\t\t\t/* save delimiting character to use later */\n\t\t\t\tchar\t\tdelim = *cp;\n\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t/* second field is all digits? then no embedded text month */\n\t\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = ((delim == '.') ? DTK_NUMBER : DTK_DATE);\n\t\t\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * insist that the delimiters match to get a three-field\n\t\t\t\t\t * date.\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == delim)\n\t\t\t\t\t{\n\t\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t\twhile (isdigit((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\twhile (isalnum((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * otherwise, number only and will determine year, month, day, or\n\t\t\t * concatenated fields later...\n\t\t\t */\n\t\t\telse\n\t\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\t\t/* Leading decimal point? Then fractional seconds... */\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\n\t\t/*\n\t\t * text? then date string, month, day of week, special, or timezone\n\t\t */\n\t\telse if (isalpha((unsigned char) *cp))\n\t\t{\n\t\t\tbool\t\tis_date;\n\n\t\t\tftype[nf] = DTK_STRING;\n\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\n\t\t\t/*\n\t\t\t * Dates can have embedded '-', '/', or '.' separators.  It could\n\t\t\t * also be a timezone name containing embedded '/', '+', '-', '_',\n\t\t\t * or ':' (but '_' or ':' can't be the first punctuation). If the\n\t\t\t * next character is a digit or '+', we need to check whether what\n\t\t\t * we have so far is a recognized non-timezone keyword --- if so,\n\t\t\t * don't believe that this is the start of a timezone.\n\t\t\t */\n\t\t\tis_date = false;\n\t\t\tif (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t\tis_date = true;\n\t\t\telse if (*cp == '+' || isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\t*bufp = '\\0';\t/* null-terminate current field value */\n\t\t\t\t/* we need search only the core token table, not TZ names */\n\t\t\t\tif (datebsearch(field[nf], datetktbl, szdatetktbl) == NULL)\n\t\t\t\t\tis_date = true;\n\t\t\t}\n\t\t\tif (is_date)\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t} while (*cp == '+' || *cp == '-' ||\n\t\t\t\t\t\t *cp == '/' || *cp == '_' ||\n\t\t\t\t\t\t *cp == '.' || *cp == ':' ||\n\t\t\t\t\t\t isalnum((unsigned char) *cp));\n\t\t\t}\n\t\t}\n\t\t/* sign? then special or numeric timezone */\n\t\telse if (*cp == '+' || *cp == '-')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t/* soak up leading whitespace */\n\t\t\twhile (isspace((unsigned char) *cp))\n\t\t\t\tcp++;\n\t\t\t/* numeric timezone? */\n\t\t\t/* note that \"DTK_TZ\" could also be a signed float or yyyy-mm */\n\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TZ;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   *cp == ':' || *cp == '.' || *cp == '-')\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* special? */\n\t\t\telse if (isalpha((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_SPECIAL;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t}\n\t\t\t/* otherwise something wrong... */\n\t\t\telse\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\t\t/* ignore other punctuation but use as delimiter */\n\t\telse if (ispunct((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* otherwise, something is not right... */\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* force in a delimiter after each field */\n\t\t*bufp++ = '\\0';\n\t\tnf++;\n\t}\n\n\t*numfields = nf;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void reltime2tm(RelativeTime time, struct pg_tm *tm);\n\nDatum\nreltimein(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tRelativeTime result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tfsec_t\t\tfsec;\n\tint\t\t\tdtype;\n\tint\t\t\tdterr;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tnf,\n\t\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tworkbuf[MAXDATELEN + 1];\n\n\tdterr = ParseDateTime(str, workbuf, sizeof(workbuf),\n\t\t\t\t\t\t  field, ftype, MAXDATEFIELDS, &nf);\n\tif (dterr == 0)\n\t\tdterr = DecodeInterval(field, ftype, nf, INTERVAL_FULL_RANGE,\n\t\t\t\t\t\t\t   &dtype, tm, &fsec);\n\n\t/* if those functions think it's a bad format, try ISO8601 style */\n\tif (dterr == DTERR_BAD_FORMAT)\n\t\tdterr = DecodeISO8601Interval(str,\n\t\t\t\t\t\t\t\t\t  &dtype, tm, &fsec);\n\n\tif (dterr != 0)\n\t{\n\t\tif (dterr == DTERR_FIELD_OVERFLOW)\n\t\t\tdterr = DTERR_INTERVAL_OVERFLOW;\n\t\tDateTimeParseError(dterr, str, \"reltime\");\n\t}\n\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DELTA:\n\t\t\tresult = ((tm->tm_hour * MINS_PER_HOUR + tm->tm_min) * SECS_PER_MINUTE) + tm->tm_sec;\n\t\t\tresult += tm->tm_year * SECS_PER_YEAR + ((tm->tm_mon * DAYS_PER_MONTH) + tm->tm_mday) * SECS_PER_DAY;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected dtype %d while parsing reltime \\\"%s\\\"\",\n\t\t\t\t dtype, str);\n\t\t\tresult = INVALID_RELTIME;\n\t\t\tbreak;\n\t}\n\n\tPG_RETURN_RELATIVETIME(result);\n}"
  },
  {
    "function_name": "abstime_timestamptz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "542-580",
    "snippet": "Datum\nabstime_timestamptz(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime abstime = PG_GETARG_ABSOLUTETIME(0);\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\tchar\t\tzone[MAXDATELEN + 1],\n\t\t\t   *tzn = zone;\n\n\tswitch (abstime)\n\t{\n\t\tcase INVALID_ABSTIME:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cannot convert abstime \\\"invalid\\\" to timestamp\")));\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\n\t\tcase NOSTART_ABSTIME:\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\n\t\tcase NOEND_ABSTIME:\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tabstime2tm(abstime, &tz, tm, &tzn);\n\t\t\tif (tm2timestamp(tm, 0, &tz, &result) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\tbreak;\n\t};\n\n\tPG_RETURN_TIMESTAMP(result);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static AbsoluteTime tm2abstime(struct pg_tm *tm, int tz);",
      "static void reltime2tm(RelativeTime time, struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm2timestamp",
          "args": [
            "tm",
            "0",
            "&tz",
            "&result"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "tm2timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1853-1895",
          "snippet": "int\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "abstime2tm",
          "args": [
            "abstime",
            "&tz",
            "tm",
            "&tzn"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "abstime2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "98-146",
          "snippet": "void\nabstime2tm(AbsoluteTime _time, int *tzp, struct pg_tm *tm, char **tzn)\n{\n\tpg_time_t\ttime = (pg_time_t) _time;\n\tstruct pg_tm *tx;\n\n\tif (tzp != NULL)\n\t\ttx = pg_localtime(&time, session_timezone);\n\telse\n\t\ttx = pg_gmtime(&time);\n\n\tif (tx == NULL)\n\t\telog(ERROR, \"could not convert abstime to timestamp: %m\");\n\n\ttm->tm_year = tx->tm_year + 1900;\n\ttm->tm_mon = tx->tm_mon + 1;\n\ttm->tm_mday = tx->tm_mday;\n\ttm->tm_hour = tx->tm_hour;\n\ttm->tm_min = tx->tm_min;\n\ttm->tm_sec = tx->tm_sec;\n\ttm->tm_isdst = tx->tm_isdst;\n\n\ttm->tm_gmtoff = tx->tm_gmtoff;\n\ttm->tm_zone = tx->tm_zone;\n\n\tif (tzp != NULL)\n\t{\n\t\t*tzp = -tm->tm_gmtoff;\t/* tm_gmtoff is Sun/DEC-ism */\n\n\t\t/*\n\t\t * XXX FreeBSD man pages indicate that this should work - tgl 97/04/23\n\t\t */\n\t\tif (tzn != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy no more than MAXTZLEN bytes of timezone to tzn, in case it\n\t\t\t * contains an error message, which doesn't fit in the buffer\n\t\t\t */\n\t\t\tStrNCpy(*tzn, tm->tm_zone, MAXTZLEN + 1);\n\t\t\tif (strlen(tm->tm_zone) > MAXTZLEN)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"invalid time zone name: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttm->tm_zone)));\n\t\t}\n\t}\n\telse\n\t\ttm->tm_isdst = -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void reltime2tm(RelativeTime time, struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void reltime2tm(RelativeTime time, struct pg_tm *tm);\n\nvoid\nabstime2tm(AbsoluteTime _time, int *tzp, struct pg_tm *tm, char **tzn)\n{\n\tpg_time_t\ttime = (pg_time_t) _time;\n\tstruct pg_tm *tx;\n\n\tif (tzp != NULL)\n\t\ttx = pg_localtime(&time, session_timezone);\n\telse\n\t\ttx = pg_gmtime(&time);\n\n\tif (tx == NULL)\n\t\telog(ERROR, \"could not convert abstime to timestamp: %m\");\n\n\ttm->tm_year = tx->tm_year + 1900;\n\ttm->tm_mon = tx->tm_mon + 1;\n\ttm->tm_mday = tx->tm_mday;\n\ttm->tm_hour = tx->tm_hour;\n\ttm->tm_min = tx->tm_min;\n\ttm->tm_sec = tx->tm_sec;\n\ttm->tm_isdst = tx->tm_isdst;\n\n\ttm->tm_gmtoff = tx->tm_gmtoff;\n\ttm->tm_zone = tx->tm_zone;\n\n\tif (tzp != NULL)\n\t{\n\t\t*tzp = -tm->tm_gmtoff;\t/* tm_gmtoff is Sun/DEC-ism */\n\n\t\t/*\n\t\t * XXX FreeBSD man pages indicate that this should work - tgl 97/04/23\n\t\t */\n\t\tif (tzn != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy no more than MAXTZLEN bytes of timezone to tzn, in case it\n\t\t\t * contains an error message, which doesn't fit in the buffer\n\t\t\t */\n\t\t\tStrNCpy(*tzn, tm->tm_zone, MAXTZLEN + 1);\n\t\t\tif (strlen(tm->tm_zone) > MAXTZLEN)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"invalid time zone name: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttm->tm_zone)));\n\t\t}\n\t}\n\telse\n\t\ttm->tm_isdst = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOEND",
          "args": [
            "result"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOBEGIN",
          "args": [
            "result"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOBEGIN",
          "args": [
            "result"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cannot convert abstime \\\"invalid\\\" to timestamp\"))"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "0"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic AbsoluteTime tm2abstime(struct pg_tm *tm, int tz);\nstatic void reltime2tm(RelativeTime time, struct pg_tm *tm);\n\nDatum\nabstime_timestamptz(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime abstime = PG_GETARG_ABSOLUTETIME(0);\n\tTimestampTz result;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\tchar\t\tzone[MAXDATELEN + 1],\n\t\t\t   *tzn = zone;\n\n\tswitch (abstime)\n\t{\n\t\tcase INVALID_ABSTIME:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cannot convert abstime \\\"invalid\\\" to timestamp\")));\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\n\t\tcase NOSTART_ABSTIME:\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\n\t\tcase NOEND_ABSTIME:\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tabstime2tm(abstime, &tz, tm, &tzn);\n\t\t\tif (tm2timestamp(tm, 0, &tz, &result) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\tbreak;\n\t};\n\n\tPG_RETURN_TIMESTAMP(result);\n}"
  },
  {
    "function_name": "timestamptz_abstime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "513-537",
    "snippet": "Datum\ntimestamptz_abstime(PG_FUNCTION_ARGS)\n{\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMP(0);\n\tAbsoluteTime result;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tif (TIMESTAMP_IS_NOBEGIN(timestamp))\n\t\tresult = NOSTART_ABSTIME;\n\telse if (TIMESTAMP_IS_NOEND(timestamp))\n\t\tresult = NOEND_ABSTIME;\n\telse if (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) == 0)\n\t\tresult = tm2abstime(tm, 0);\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\tresult = INVALID_ABSTIME;\n\t}\n\n\tPG_RETURN_ABSOLUTETIME(result);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void reltime2tm(RelativeTime time, struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ABSOLUTETIME",
          "args": [
            "result"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm2abstime",
          "args": [
            "tm",
            "0"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "tm2abstime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "153-192",
          "snippet": "static AbsoluteTime\ntm2abstime(struct pg_tm *tm, int tz)\n{\n\tint\t\t\tday;\n\tAbsoluteTime sec;\n\n\t/* validate, before going out of range on some members */\n\tif (tm->tm_year < 1901 || tm->tm_year > 2038 ||\n\t\ttm->tm_mon < 1 || tm->tm_mon > MONTHS_PER_YEAR ||\n\t\ttm->tm_mday < 1 || tm->tm_mday > 31 ||\n\t\ttm->tm_hour < 0 ||\n\t\ttm->tm_hour > HOURS_PER_DAY ||\t/* test for > 24:00:00 */\n\t\t(tm->tm_hour == HOURS_PER_DAY && (tm->tm_min > 0 || tm->tm_sec > 0)) ||\n\t\ttm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE)\n\t\treturn INVALID_ABSTIME;\n\n\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - UNIX_EPOCH_JDATE;\n\n\t/* check for time out of range */\n\tif (day < MIN_DAYNUM || day > MAX_DAYNUM)\n\t\treturn INVALID_ABSTIME;\n\n\t/* convert to seconds */\n\tsec = tm->tm_sec + tz + (tm->tm_min + (day * HOURS_PER_DAY + tm->tm_hour) * MINS_PER_HOUR) * SECS_PER_MINUTE;\n\n\t/*\n\t * check for overflow.  We need a little slop here because the H/M/S plus\n\t * TZ offset could add up to more than 1 day.\n\t */\n\tif ((day >= MAX_DAYNUM - 10 && sec < 0) ||\n\t\t(day <= MIN_DAYNUM + 10 && sec > 0))\n\t\treturn INVALID_ABSTIME;\n\n\t/* check for reserved values (e.g. \"current\" on edge of usual range */\n\tif (!AbsoluteTimeIsReal(sec))\n\t\treturn INVALID_ABSTIME;\n\n\treturn sec;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_DAYNUM 24854\t\t/* January 18, 2038 */",
            "#define MIN_DAYNUM (-24856)\t\t/* December 13, 1901 */"
          ],
          "globals_used": [
            "static AbsoluteTime tm2abstime(struct pg_tm *tm, int tz);",
            "static void reltime2tm(RelativeTime time, struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define MAX_DAYNUM 24854\t\t/* January 18, 2038 */\n#define MIN_DAYNUM (-24856)\t\t/* December 13, 1901 */\n\nstatic AbsoluteTime tm2abstime(struct pg_tm *tm, int tz);\nstatic void reltime2tm(RelativeTime time, struct pg_tm *tm);\n\nstatic AbsoluteTime\ntm2abstime(struct pg_tm *tm, int tz)\n{\n\tint\t\t\tday;\n\tAbsoluteTime sec;\n\n\t/* validate, before going out of range on some members */\n\tif (tm->tm_year < 1901 || tm->tm_year > 2038 ||\n\t\ttm->tm_mon < 1 || tm->tm_mon > MONTHS_PER_YEAR ||\n\t\ttm->tm_mday < 1 || tm->tm_mday > 31 ||\n\t\ttm->tm_hour < 0 ||\n\t\ttm->tm_hour > HOURS_PER_DAY ||\t/* test for > 24:00:00 */\n\t\t(tm->tm_hour == HOURS_PER_DAY && (tm->tm_min > 0 || tm->tm_sec > 0)) ||\n\t\ttm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE)\n\t\treturn INVALID_ABSTIME;\n\n\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - UNIX_EPOCH_JDATE;\n\n\t/* check for time out of range */\n\tif (day < MIN_DAYNUM || day > MAX_DAYNUM)\n\t\treturn INVALID_ABSTIME;\n\n\t/* convert to seconds */\n\tsec = tm->tm_sec + tz + (tm->tm_min + (day * HOURS_PER_DAY + tm->tm_hour) * MINS_PER_HOUR) * SECS_PER_MINUTE;\n\n\t/*\n\t * check for overflow.  We need a little slop here because the H/M/S plus\n\t * TZ offset could add up to more than 1 day.\n\t */\n\tif ((day >= MAX_DAYNUM - 10 && sec < 0) ||\n\t\t(day <= MIN_DAYNUM + 10 && sec > 0))\n\t\treturn INVALID_ABSTIME;\n\n\t/* check for reserved values (e.g. \"current\" on edge of usual range */\n\tif (!AbsoluteTimeIsReal(sec))\n\t\treturn INVALID_ABSTIME;\n\n\treturn sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "NULL",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_IS_NOEND",
          "args": [
            "timestamp"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_IS_NOBEGIN",
          "args": [
            "timestamp"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void reltime2tm(RelativeTime time, struct pg_tm *tm);\n\nDatum\ntimestamptz_abstime(PG_FUNCTION_ARGS)\n{\n\tTimestampTz timestamp = PG_GETARG_TIMESTAMP(0);\n\tAbsoluteTime result;\n\tfsec_t\t\tfsec;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tif (TIMESTAMP_IS_NOBEGIN(timestamp))\n\t\tresult = NOSTART_ABSTIME;\n\telse if (TIMESTAMP_IS_NOEND(timestamp))\n\t\tresult = NOEND_ABSTIME;\n\telse if (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) == 0)\n\t\tresult = tm2abstime(tm, 0);\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\tresult = INVALID_ABSTIME;\n\t}\n\n\tPG_RETURN_ABSOLUTETIME(result);\n}"
  },
  {
    "function_name": "abstime_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "469-507",
    "snippet": "Datum\nabstime_timestamp(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime abstime = PG_GETARG_ABSOLUTETIME(0);\n\tTimestamp\tresult;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\tchar\t\tzone[MAXDATELEN + 1],\n\t\t\t   *tzn = zone;\n\n\tswitch (abstime)\n\t{\n\t\tcase INVALID_ABSTIME:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cannot convert abstime \\\"invalid\\\" to timestamp\")));\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\n\t\tcase NOSTART_ABSTIME:\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\n\t\tcase NOEND_ABSTIME:\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tabstime2tm(abstime, &tz, tm, &tzn);\n\t\t\tif (tm2timestamp(tm, 0, NULL, &result) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\tbreak;\n\t};\n\n\tPG_RETURN_TIMESTAMP(result);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static AbsoluteTime tm2abstime(struct pg_tm *tm, int tz);",
      "static void reltime2tm(RelativeTime time, struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TIMESTAMP",
          "args": [
            "result"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm2timestamp",
          "args": [
            "tm",
            "0",
            "NULL",
            "&result"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "tm2timestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1853-1895",
          "snippet": "int\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\n\nint\ntm2timestamp(struct pg_tm *tm, fsec_t fsec, int *tzp, Timestamp *result)\n{\n\tTimeOffset\tdate;\n\tTimeOffset\ttime;\n\n\t/* Prevent overflow in Julian-day routines */\n\tif (!IS_VALID_JULIAN(tm->tm_year, tm->tm_mon, tm->tm_mday))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\tdate = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - POSTGRES_EPOCH_JDATE;\n\ttime = time2t(tm->tm_hour, tm->tm_min, tm->tm_sec, fsec);\n\n\t*result = date * USECS_PER_DAY + time;\n\t/* check for major overflow */\n\tif ((*result - time) / USECS_PER_DAY != date)\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\t/* check for just-barely overflow (okay except time-of-day wraps) */\n\t/* caution: we want to allow 1999-12-31 24:00:00 */\n\tif ((*result < 0 && date > 0) ||\n\t\t(*result > 0 && date < -1))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\tif (tzp != NULL)\n\t\t*result = dt2local(*result, -(*tzp));\n\n\t/* final range check catches just-out-of-range timestamps */\n\tif (!IS_VALID_TIMESTAMP(*result))\n\t{\n\t\t*result = 0;\t\t\t/* keep compiler quiet */\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "abstime2tm",
          "args": [
            "abstime",
            "&tz",
            "tm",
            "&tzn"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "abstime2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "98-146",
          "snippet": "void\nabstime2tm(AbsoluteTime _time, int *tzp, struct pg_tm *tm, char **tzn)\n{\n\tpg_time_t\ttime = (pg_time_t) _time;\n\tstruct pg_tm *tx;\n\n\tif (tzp != NULL)\n\t\ttx = pg_localtime(&time, session_timezone);\n\telse\n\t\ttx = pg_gmtime(&time);\n\n\tif (tx == NULL)\n\t\telog(ERROR, \"could not convert abstime to timestamp: %m\");\n\n\ttm->tm_year = tx->tm_year + 1900;\n\ttm->tm_mon = tx->tm_mon + 1;\n\ttm->tm_mday = tx->tm_mday;\n\ttm->tm_hour = tx->tm_hour;\n\ttm->tm_min = tx->tm_min;\n\ttm->tm_sec = tx->tm_sec;\n\ttm->tm_isdst = tx->tm_isdst;\n\n\ttm->tm_gmtoff = tx->tm_gmtoff;\n\ttm->tm_zone = tx->tm_zone;\n\n\tif (tzp != NULL)\n\t{\n\t\t*tzp = -tm->tm_gmtoff;\t/* tm_gmtoff is Sun/DEC-ism */\n\n\t\t/*\n\t\t * XXX FreeBSD man pages indicate that this should work - tgl 97/04/23\n\t\t */\n\t\tif (tzn != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy no more than MAXTZLEN bytes of timezone to tzn, in case it\n\t\t\t * contains an error message, which doesn't fit in the buffer\n\t\t\t */\n\t\t\tStrNCpy(*tzn, tm->tm_zone, MAXTZLEN + 1);\n\t\t\tif (strlen(tm->tm_zone) > MAXTZLEN)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"invalid time zone name: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttm->tm_zone)));\n\t\t}\n\t}\n\telse\n\t\ttm->tm_isdst = -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void reltime2tm(RelativeTime time, struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void reltime2tm(RelativeTime time, struct pg_tm *tm);\n\nvoid\nabstime2tm(AbsoluteTime _time, int *tzp, struct pg_tm *tm, char **tzn)\n{\n\tpg_time_t\ttime = (pg_time_t) _time;\n\tstruct pg_tm *tx;\n\n\tif (tzp != NULL)\n\t\ttx = pg_localtime(&time, session_timezone);\n\telse\n\t\ttx = pg_gmtime(&time);\n\n\tif (tx == NULL)\n\t\telog(ERROR, \"could not convert abstime to timestamp: %m\");\n\n\ttm->tm_year = tx->tm_year + 1900;\n\ttm->tm_mon = tx->tm_mon + 1;\n\ttm->tm_mday = tx->tm_mday;\n\ttm->tm_hour = tx->tm_hour;\n\ttm->tm_min = tx->tm_min;\n\ttm->tm_sec = tx->tm_sec;\n\ttm->tm_isdst = tx->tm_isdst;\n\n\ttm->tm_gmtoff = tx->tm_gmtoff;\n\ttm->tm_zone = tx->tm_zone;\n\n\tif (tzp != NULL)\n\t{\n\t\t*tzp = -tm->tm_gmtoff;\t/* tm_gmtoff is Sun/DEC-ism */\n\n\t\t/*\n\t\t * XXX FreeBSD man pages indicate that this should work - tgl 97/04/23\n\t\t */\n\t\tif (tzn != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy no more than MAXTZLEN bytes of timezone to tzn, in case it\n\t\t\t * contains an error message, which doesn't fit in the buffer\n\t\t\t */\n\t\t\tStrNCpy(*tzn, tm->tm_zone, MAXTZLEN + 1);\n\t\t\tif (strlen(tm->tm_zone) > MAXTZLEN)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"invalid time zone name: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttm->tm_zone)));\n\t\t}\n\t}\n\telse\n\t\ttm->tm_isdst = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOEND",
          "args": [
            "result"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOBEGIN",
          "args": [
            "result"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_NOBEGIN",
          "args": [
            "result"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cannot convert abstime \\\"invalid\\\" to timestamp\"))"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "0"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic AbsoluteTime tm2abstime(struct pg_tm *tm, int tz);\nstatic void reltime2tm(RelativeTime time, struct pg_tm *tm);\n\nDatum\nabstime_timestamp(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime abstime = PG_GETARG_ABSOLUTETIME(0);\n\tTimestamp\tresult;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tint\t\t\ttz;\n\tchar\t\tzone[MAXDATELEN + 1],\n\t\t\t   *tzn = zone;\n\n\tswitch (abstime)\n\t{\n\t\tcase INVALID_ABSTIME:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t errmsg(\"cannot convert abstime \\\"invalid\\\" to timestamp\")));\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\n\t\tcase NOSTART_ABSTIME:\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\n\t\tcase NOEND_ABSTIME:\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tabstime2tm(abstime, &tz, tm, &tzn);\n\t\t\tif (tm2timestamp(tm, 0, NULL, &result) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\t\tbreak;\n\t};\n\n\tPG_RETURN_TIMESTAMP(result);\n}"
  },
  {
    "function_name": "timestamp_abstime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "436-464",
    "snippet": "Datum\ntimestamp_abstime(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(0);\n\tAbsoluteTime result;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tif (TIMESTAMP_IS_NOBEGIN(timestamp))\n\t\tresult = NOSTART_ABSTIME;\n\telse if (TIMESTAMP_IS_NOEND(timestamp))\n\t\tresult = NOEND_ABSTIME;\n\telse if (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) == 0)\n\t{\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\t\tresult = tm2abstime(tm, tz);\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\tresult = INVALID_ABSTIME;\n\t}\n\n\tPG_RETURN_ABSOLUTETIME(result);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static AbsoluteTime tm2abstime(struct pg_tm *tm, int tz);",
      "static void reltime2tm(RelativeTime time, struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ABSOLUTETIME",
          "args": [
            "result"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\"))"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"timestamp out of range\""
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATETIME_VALUE_OUT_OF_RANGE"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm2abstime",
          "args": [
            "tm",
            "tz"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "tm2abstime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "153-192",
          "snippet": "static AbsoluteTime\ntm2abstime(struct pg_tm *tm, int tz)\n{\n\tint\t\t\tday;\n\tAbsoluteTime sec;\n\n\t/* validate, before going out of range on some members */\n\tif (tm->tm_year < 1901 || tm->tm_year > 2038 ||\n\t\ttm->tm_mon < 1 || tm->tm_mon > MONTHS_PER_YEAR ||\n\t\ttm->tm_mday < 1 || tm->tm_mday > 31 ||\n\t\ttm->tm_hour < 0 ||\n\t\ttm->tm_hour > HOURS_PER_DAY ||\t/* test for > 24:00:00 */\n\t\t(tm->tm_hour == HOURS_PER_DAY && (tm->tm_min > 0 || tm->tm_sec > 0)) ||\n\t\ttm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE)\n\t\treturn INVALID_ABSTIME;\n\n\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - UNIX_EPOCH_JDATE;\n\n\t/* check for time out of range */\n\tif (day < MIN_DAYNUM || day > MAX_DAYNUM)\n\t\treturn INVALID_ABSTIME;\n\n\t/* convert to seconds */\n\tsec = tm->tm_sec + tz + (tm->tm_min + (day * HOURS_PER_DAY + tm->tm_hour) * MINS_PER_HOUR) * SECS_PER_MINUTE;\n\n\t/*\n\t * check for overflow.  We need a little slop here because the H/M/S plus\n\t * TZ offset could add up to more than 1 day.\n\t */\n\tif ((day >= MAX_DAYNUM - 10 && sec < 0) ||\n\t\t(day <= MIN_DAYNUM + 10 && sec > 0))\n\t\treturn INVALID_ABSTIME;\n\n\t/* check for reserved values (e.g. \"current\" on edge of usual range */\n\tif (!AbsoluteTimeIsReal(sec))\n\t\treturn INVALID_ABSTIME;\n\n\treturn sec;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_DAYNUM 24854\t\t/* January 18, 2038 */",
            "#define MIN_DAYNUM (-24856)\t\t/* December 13, 1901 */"
          ],
          "globals_used": [
            "static AbsoluteTime tm2abstime(struct pg_tm *tm, int tz);",
            "static void reltime2tm(RelativeTime time, struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define MAX_DAYNUM 24854\t\t/* January 18, 2038 */\n#define MIN_DAYNUM (-24856)\t\t/* December 13, 1901 */\n\nstatic AbsoluteTime tm2abstime(struct pg_tm *tm, int tz);\nstatic void reltime2tm(RelativeTime time, struct pg_tm *tm);\n\nstatic AbsoluteTime\ntm2abstime(struct pg_tm *tm, int tz)\n{\n\tint\t\t\tday;\n\tAbsoluteTime sec;\n\n\t/* validate, before going out of range on some members */\n\tif (tm->tm_year < 1901 || tm->tm_year > 2038 ||\n\t\ttm->tm_mon < 1 || tm->tm_mon > MONTHS_PER_YEAR ||\n\t\ttm->tm_mday < 1 || tm->tm_mday > 31 ||\n\t\ttm->tm_hour < 0 ||\n\t\ttm->tm_hour > HOURS_PER_DAY ||\t/* test for > 24:00:00 */\n\t\t(tm->tm_hour == HOURS_PER_DAY && (tm->tm_min > 0 || tm->tm_sec > 0)) ||\n\t\ttm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE)\n\t\treturn INVALID_ABSTIME;\n\n\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - UNIX_EPOCH_JDATE;\n\n\t/* check for time out of range */\n\tif (day < MIN_DAYNUM || day > MAX_DAYNUM)\n\t\treturn INVALID_ABSTIME;\n\n\t/* convert to seconds */\n\tsec = tm->tm_sec + tz + (tm->tm_min + (day * HOURS_PER_DAY + tm->tm_hour) * MINS_PER_HOUR) * SECS_PER_MINUTE;\n\n\t/*\n\t * check for overflow.  We need a little slop here because the H/M/S plus\n\t * TZ offset could add up to more than 1 day.\n\t */\n\tif ((day >= MAX_DAYNUM - 10 && sec < 0) ||\n\t\t(day <= MIN_DAYNUM + 10 && sec > 0))\n\t\treturn INVALID_ABSTIME;\n\n\t/* check for reserved values (e.g. \"current\" on edge of usual range */\n\tif (!AbsoluteTimeIsReal(sec))\n\t\treturn INVALID_ABSTIME;\n\n\treturn sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DetermineTimeZoneOffset",
          "args": [
            "tm",
            "session_timezone"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "DetermineTimeZoneOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "1454-1460",
          "snippet": "int\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDetermineTimeZoneOffset(struct pg_tm *tm, pg_tz *tzp)\n{\n\tpg_time_t\tt;\n\n\treturn DetermineTimeZoneOffsetInternal(tm, tzp, &t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timestamp2tm",
          "args": [
            "timestamp",
            "NULL",
            "tm",
            "&fsec",
            "NULL",
            "NULL"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "timestamp2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/timestamp.c",
          "lines": "1757-1843",
          "snippet": "int\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/int128.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/hash.h\"",
            "#include <sys/time.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);",
            "static Timestamp dt2local(Timestamp dt, int timezone);",
            "static TimestampTz timestamp2timestamptz(Timestamp timestamp);",
            "static Timestamp timestamptz2timestamp(TimestampTz timestamp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"parser/scansup.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"common/int128.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/hash.h\"\n#include <sys/time.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic TimeOffset time2t(const int hour, const int min, const int sec, const fsec_t fsec);\nstatic Timestamp dt2local(Timestamp dt, int timezone);\nstatic TimestampTz timestamp2timestamptz(Timestamp timestamp);\nstatic Timestamp timestamptz2timestamp(TimestampTz timestamp);\n\nint\ntimestamp2tm(Timestamp dt, int *tzp, struct pg_tm *tm, fsec_t *fsec, const char **tzn, pg_tz *attimezone)\n{\n\tTimestamp\tdate;\n\tTimestamp\ttime;\n\tpg_time_t\tutime;\n\n\t/* Use session timezone if caller asks for default */\n\tif (attimezone == NULL)\n\t\tattimezone = session_timezone;\n\n\ttime = dt;\n\tTMODULO(time, date, USECS_PER_DAY);\n\n\tif (time < INT64CONST(0))\n\t{\n\t\ttime += USECS_PER_DAY;\n\t\tdate -= 1;\n\t}\n\n\t/* add offset to go from J2000 back to standard Julian date */\n\tdate += POSTGRES_EPOCH_JDATE;\n\n\t/* Julian day routine does not work for negative Julian days */\n\tif (date < 0 || date > (Timestamp) INT_MAX)\n\t\treturn -1;\n\n\tj2date((int) date, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\tdt2time(time, &tm->tm_hour, &tm->tm_min, &tm->tm_sec, fsec);\n\n\t/* Done if no TZ conversion wanted */\n\tif (tzp == NULL)\n\t{\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the time falls within the range of pg_time_t, use pg_localtime() to\n\t * rotate to the local time zone.\n\t *\n\t * First, convert to an integral timestamp, avoiding possibly\n\t * platform-specific roundoff-in-wrong-direction errors, and adjust to\n\t * Unix epoch.  Then see if we can convert to pg_time_t without loss. This\n\t * coding avoids hardwiring any assumptions about the width of pg_time_t,\n\t * so it should behave sanely on machines without int64.\n\t */\n\tdt = (dt - *fsec) / USECS_PER_SEC +\n\t\t(POSTGRES_EPOCH_JDATE - UNIX_EPOCH_JDATE) * SECS_PER_DAY;\n\tutime = (pg_time_t) dt;\n\tif ((Timestamp) utime == dt)\n\t{\n\t\tstruct pg_tm *tx = pg_localtime(&utime, attimezone);\n\n\t\ttm->tm_year = tx->tm_year + 1900;\n\t\ttm->tm_mon = tx->tm_mon + 1;\n\t\ttm->tm_mday = tx->tm_mday;\n\t\ttm->tm_hour = tx->tm_hour;\n\t\ttm->tm_min = tx->tm_min;\n\t\ttm->tm_sec = tx->tm_sec;\n\t\ttm->tm_isdst = tx->tm_isdst;\n\t\ttm->tm_gmtoff = tx->tm_gmtoff;\n\t\ttm->tm_zone = tx->tm_zone;\n\t\t*tzp = -tm->tm_gmtoff;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = tm->tm_zone;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * When out of range of pg_time_t, treat as GMT\n\t\t */\n\t\t*tzp = 0;\n\t\t/* Mark this as *no* time zone available */\n\t\ttm->tm_isdst = -1;\n\t\ttm->tm_gmtoff = 0;\n\t\ttm->tm_zone = NULL;\n\t\tif (tzn != NULL)\n\t\t\t*tzn = NULL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_IS_NOEND",
          "args": [
            "timestamp"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMESTAMP_IS_NOBEGIN",
          "args": [
            "timestamp"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TIMESTAMP",
          "args": [
            "0"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic AbsoluteTime tm2abstime(struct pg_tm *tm, int tz);\nstatic void reltime2tm(RelativeTime time, struct pg_tm *tm);\n\nDatum\ntimestamp_abstime(PG_FUNCTION_ARGS)\n{\n\tTimestamp\ttimestamp = PG_GETARG_TIMESTAMP(0);\n\tAbsoluteTime result;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\n\tif (TIMESTAMP_IS_NOBEGIN(timestamp))\n\t\tresult = NOSTART_ABSTIME;\n\telse if (TIMESTAMP_IS_NOEND(timestamp))\n\t\tresult = NOEND_ABSTIME;\n\telse if (timestamp2tm(timestamp, NULL, tm, &fsec, NULL, NULL) == 0)\n\t{\n\t\ttz = DetermineTimeZoneOffset(tm, session_timezone);\n\t\tresult = tm2abstime(tm, tz);\n\t}\n\telse\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),\n\t\t\t\t errmsg(\"timestamp out of range\")));\n\t\tresult = INVALID_ABSTIME;\n\t}\n\n\tPG_RETURN_ABSOLUTETIME(result);\n}"
  },
  {
    "function_name": "btabstimecmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "423-430",
    "snippet": "Datum\nbtabstimecmp(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t1 = PG_GETARG_ABSOLUTETIME(0);\n\tAbsoluteTime t2 = PG_GETARG_ABSOLUTETIME(1);\n\n\tPG_RETURN_INT32(abstime_cmp_internal(t1, t2));\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "abstime_cmp_internal(t1, t2)"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abstime_cmp_internal",
          "args": [
            "t1",
            "t2"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "abstime_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "342-367",
          "snippet": "static int\nabstime_cmp_internal(AbsoluteTime a, AbsoluteTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_ABSTIME)\n\t{\n\t\tif (b == INVALID_ABSTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_ABSTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nabstime_cmp_internal(AbsoluteTime a, AbsoluteTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_ABSTIME)\n\t{\n\t\tif (b == INVALID_ABSTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_ABSTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "1"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "0"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nbtabstimecmp(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t1 = PG_GETARG_ABSOLUTETIME(0);\n\tAbsoluteTime t2 = PG_GETARG_ABSOLUTETIME(1);\n\n\tPG_RETURN_INT32(abstime_cmp_internal(t1, t2));\n}"
  },
  {
    "function_name": "abstimege",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "414-421",
    "snippet": "Datum\nabstimege(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t1 = PG_GETARG_ABSOLUTETIME(0);\n\tAbsoluteTime t2 = PG_GETARG_ABSOLUTETIME(1);\n\n\tPG_RETURN_BOOL(abstime_cmp_internal(t1, t2) >= 0);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "abstime_cmp_internal(t1, t2) >= 0"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abstime_cmp_internal",
          "args": [
            "t1",
            "t2"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "abstime_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "342-367",
          "snippet": "static int\nabstime_cmp_internal(AbsoluteTime a, AbsoluteTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_ABSTIME)\n\t{\n\t\tif (b == INVALID_ABSTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_ABSTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nabstime_cmp_internal(AbsoluteTime a, AbsoluteTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_ABSTIME)\n\t{\n\t\tif (b == INVALID_ABSTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_ABSTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "1"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "0"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nabstimege(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t1 = PG_GETARG_ABSOLUTETIME(0);\n\tAbsoluteTime t2 = PG_GETARG_ABSOLUTETIME(1);\n\n\tPG_RETURN_BOOL(abstime_cmp_internal(t1, t2) >= 0);\n}"
  },
  {
    "function_name": "abstimele",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "405-412",
    "snippet": "Datum\nabstimele(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t1 = PG_GETARG_ABSOLUTETIME(0);\n\tAbsoluteTime t2 = PG_GETARG_ABSOLUTETIME(1);\n\n\tPG_RETURN_BOOL(abstime_cmp_internal(t1, t2) <= 0);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "abstime_cmp_internal(t1, t2) <= 0"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abstime_cmp_internal",
          "args": [
            "t1",
            "t2"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "abstime_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "342-367",
          "snippet": "static int\nabstime_cmp_internal(AbsoluteTime a, AbsoluteTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_ABSTIME)\n\t{\n\t\tif (b == INVALID_ABSTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_ABSTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nabstime_cmp_internal(AbsoluteTime a, AbsoluteTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_ABSTIME)\n\t{\n\t\tif (b == INVALID_ABSTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_ABSTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "1"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "0"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nabstimele(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t1 = PG_GETARG_ABSOLUTETIME(0);\n\tAbsoluteTime t2 = PG_GETARG_ABSOLUTETIME(1);\n\n\tPG_RETURN_BOOL(abstime_cmp_internal(t1, t2) <= 0);\n}"
  },
  {
    "function_name": "abstimegt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "396-403",
    "snippet": "Datum\nabstimegt(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t1 = PG_GETARG_ABSOLUTETIME(0);\n\tAbsoluteTime t2 = PG_GETARG_ABSOLUTETIME(1);\n\n\tPG_RETURN_BOOL(abstime_cmp_internal(t1, t2) > 0);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "abstime_cmp_internal(t1, t2) > 0"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abstime_cmp_internal",
          "args": [
            "t1",
            "t2"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "abstime_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "342-367",
          "snippet": "static int\nabstime_cmp_internal(AbsoluteTime a, AbsoluteTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_ABSTIME)\n\t{\n\t\tif (b == INVALID_ABSTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_ABSTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nabstime_cmp_internal(AbsoluteTime a, AbsoluteTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_ABSTIME)\n\t{\n\t\tif (b == INVALID_ABSTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_ABSTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "1"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "0"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nabstimegt(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t1 = PG_GETARG_ABSOLUTETIME(0);\n\tAbsoluteTime t2 = PG_GETARG_ABSOLUTETIME(1);\n\n\tPG_RETURN_BOOL(abstime_cmp_internal(t1, t2) > 0);\n}"
  },
  {
    "function_name": "abstimelt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "387-394",
    "snippet": "Datum\nabstimelt(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t1 = PG_GETARG_ABSOLUTETIME(0);\n\tAbsoluteTime t2 = PG_GETARG_ABSOLUTETIME(1);\n\n\tPG_RETURN_BOOL(abstime_cmp_internal(t1, t2) < 0);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "abstime_cmp_internal(t1, t2) < 0"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abstime_cmp_internal",
          "args": [
            "t1",
            "t2"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "abstime_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "342-367",
          "snippet": "static int\nabstime_cmp_internal(AbsoluteTime a, AbsoluteTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_ABSTIME)\n\t{\n\t\tif (b == INVALID_ABSTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_ABSTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nabstime_cmp_internal(AbsoluteTime a, AbsoluteTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_ABSTIME)\n\t{\n\t\tif (b == INVALID_ABSTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_ABSTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "1"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "0"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nabstimelt(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t1 = PG_GETARG_ABSOLUTETIME(0);\n\tAbsoluteTime t2 = PG_GETARG_ABSOLUTETIME(1);\n\n\tPG_RETURN_BOOL(abstime_cmp_internal(t1, t2) < 0);\n}"
  },
  {
    "function_name": "abstimene",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "378-385",
    "snippet": "Datum\nabstimene(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t1 = PG_GETARG_ABSOLUTETIME(0);\n\tAbsoluteTime t2 = PG_GETARG_ABSOLUTETIME(1);\n\n\tPG_RETURN_BOOL(abstime_cmp_internal(t1, t2) != 0);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "abstime_cmp_internal(t1, t2) != 0"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abstime_cmp_internal",
          "args": [
            "t1",
            "t2"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "abstime_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "342-367",
          "snippet": "static int\nabstime_cmp_internal(AbsoluteTime a, AbsoluteTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_ABSTIME)\n\t{\n\t\tif (b == INVALID_ABSTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_ABSTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nabstime_cmp_internal(AbsoluteTime a, AbsoluteTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_ABSTIME)\n\t{\n\t\tif (b == INVALID_ABSTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_ABSTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "1"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "0"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nabstimene(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t1 = PG_GETARG_ABSOLUTETIME(0);\n\tAbsoluteTime t2 = PG_GETARG_ABSOLUTETIME(1);\n\n\tPG_RETURN_BOOL(abstime_cmp_internal(t1, t2) != 0);\n}"
  },
  {
    "function_name": "abstimeeq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "369-376",
    "snippet": "Datum\nabstimeeq(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t1 = PG_GETARG_ABSOLUTETIME(0);\n\tAbsoluteTime t2 = PG_GETARG_ABSOLUTETIME(1);\n\n\tPG_RETURN_BOOL(abstime_cmp_internal(t1, t2) == 0);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "abstime_cmp_internal(t1, t2) == 0"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abstime_cmp_internal",
          "args": [
            "t1",
            "t2"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "abstime_cmp_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "342-367",
          "snippet": "static int\nabstime_cmp_internal(AbsoluteTime a, AbsoluteTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_ABSTIME)\n\t{\n\t\tif (b == INVALID_ABSTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_ABSTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nabstime_cmp_internal(AbsoluteTime a, AbsoluteTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_ABSTIME)\n\t{\n\t\tif (b == INVALID_ABSTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_ABSTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "1"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "0"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nabstimeeq(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime t1 = PG_GETARG_ABSOLUTETIME(0);\n\tAbsoluteTime t2 = PG_GETARG_ABSOLUTETIME(1);\n\n\tPG_RETURN_BOOL(abstime_cmp_internal(t1, t2) == 0);\n}"
  },
  {
    "function_name": "abstime_cmp_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "342-367",
    "snippet": "static int\nabstime_cmp_internal(AbsoluteTime a, AbsoluteTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_ABSTIME)\n\t{\n\t\tif (b == INVALID_ABSTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_ABSTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\nabstime_cmp_internal(AbsoluteTime a, AbsoluteTime b)\n{\n\t/*\n\t * We consider all INVALIDs to be equal and larger than any non-INVALID.\n\t * This is somewhat arbitrary; the important thing is to have a consistent\n\t * sort order.\n\t */\n\tif (a == INVALID_ABSTIME)\n\t{\n\t\tif (b == INVALID_ABSTIME)\n\t\t\treturn 0;\t\t\t/* INVALID = INVALID */\n\t\telse\n\t\t\treturn 1;\t\t\t/* INVALID > non-INVALID */\n\t}\n\n\tif (b == INVALID_ABSTIME)\n\t\treturn -1;\t\t\t\t/* non-INVALID < INVALID */\n\n\tif (a > b)\n\t\treturn 1;\n\telse if (a == b)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}"
  },
  {
    "function_name": "abstime_finite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "328-336",
    "snippet": "Datum\nabstime_finite(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime abstime = PG_GETARG_ABSOLUTETIME(0);\n\n\tPG_RETURN_BOOL(abstime != INVALID_ABSTIME &&\n\t\t\t\t   abstime != NOSTART_ABSTIME &&\n\t\t\t\t   abstime != NOEND_ABSTIME);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "abstime != INVALID_ABSTIME &&\n\t\t\t\t   abstime != NOSTART_ABSTIME &&\n\t\t\t\t   abstime != NOEND_ABSTIME"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "0"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nabstime_finite(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime abstime = PG_GETARG_ABSOLUTETIME(0);\n\n\tPG_RETURN_BOOL(abstime != INVALID_ABSTIME &&\n\t\t\t\t   abstime != NOSTART_ABSTIME &&\n\t\t\t\t   abstime != NOEND_ABSTIME);\n}"
  },
  {
    "function_name": "abstimesend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "314-323",
    "snippet": "Datum\nabstimesend(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime time = PG_GETARG_ABSOLUTETIME(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, time);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "time"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "0"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nabstimesend(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime time = PG_GETARG_ABSOLUTETIME(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, time);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "abstimerecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "303-309",
    "snippet": "Datum\nabstimerecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_ABSOLUTETIME((AbsoluteTime) pq_getmsgint(buf, sizeof(AbsoluteTime)));\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ABSOLUTETIME",
          "args": [
            "(AbsoluteTime) pq_getmsgint(buf, sizeof(AbsoluteTime))"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(AbsoluteTime)"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nabstimerecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_ABSOLUTETIME((AbsoluteTime) pq_getmsgint(buf, sizeof(AbsoluteTime)));\n}"
  },
  {
    "function_name": "abstimeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "262-298",
    "snippet": "Datum\nabstimeout(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime time = PG_GETARG_ABSOLUTETIME(0);\n\tchar\t   *result;\n\tint\t\t\ttz;\n\tdouble\t\tfsec = 0;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tchar\t\tbuf[MAXDATELEN + 1];\n\tchar\t\tzone[MAXDATELEN + 1],\n\t\t\t   *tzn = zone;\n\n\tswitch (time)\n\t{\n\t\t\t/*\n\t\t\t * Note that timestamp no longer supports 'invalid'. Retain\n\t\t\t * 'invalid' for abstime for now, but dump it someday.\n\t\t\t */\n\t\tcase INVALID_ABSTIME:\n\t\t\tstrcpy(buf, INVALID);\n\t\t\tbreak;\n\t\tcase NOEND_ABSTIME:\n\t\t\tstrcpy(buf, LATE);\n\t\t\tbreak;\n\t\tcase NOSTART_ABSTIME:\n\t\t\tstrcpy(buf, EARLY);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabstime2tm(time, &tz, tm, &tzn);\n\t\t\tEncodeDateTime(tm, fsec, true, tz, tzn, DateStyle, buf);\n\t\t\tbreak;\n\t}\n\n\tresult = pstrdup(buf);\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static AbsoluteTime tm2abstime(struct pg_tm *tm, int tz);",
      "static void reltime2tm(RelativeTime time, struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "buf"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeDateTime",
          "args": [
            "tm",
            "fsec",
            "true",
            "tz",
            "tzn",
            "DateStyle",
            "buf"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3987-4149",
          "snippet": "void\nEncodeDateTime(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, const char *tzn, int style, char *str)\n{\n\tint\t\t\tday;\n\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\t/*\n\t * Negative tm_isdst means we have no valid time zone translation.\n\t */\n\tif (tm->tm_isdst < 0)\n\t\tprint_tz = false;\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* Compatible with ISO-8601 date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = (style == USE_ISO_DATES) ? ' ' : 'T';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\tif (print_tz)\n\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* Compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\t/*\n\t\t\t * Note: the uses of %.*s in this function would be risky if the\n\t\t\t * timezone names ever contain non-ASCII characters.  However, all\n\t\t\t * TZ abbreviations in the IANA database are plain ASCII.\n\t\t\t */\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German variant on European style */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* Backward-compatible with traditional Postgres abstime dates */\n\t\t\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\ttm->tm_wday = j2day(day);\n\t\t\tmemcpy(str, days[tm->tm_wday], 3);\n\t\t\tstr += 3;\n\t\t\t*str++ = ' ';\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = ' ';\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t\t*str++ = ' ';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We have a time zone, but no string version. Use the\n\t\t\t\t\t * numeric form, but be sure to include a leading space to\n\t\t\t\t\t * avoid formatting something which would be rejected by\n\t\t\t\t\t * the date/time parser later. - thomas 2001-10-19\n\t\t\t\t\t */\n\t\t\t\t\t*str++ = ' ';\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);",
            "const char *const months[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", NULL};",
            "const char *const days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\", NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\nconst char *const months[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", NULL};\nconst char *const days[] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\", NULL};\n\nvoid\nEncodeDateTime(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, const char *tzn, int style, char *str)\n{\n\tint\t\t\tday;\n\n\tAssert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR);\n\n\t/*\n\t * Negative tm_isdst means we have no valid time zone translation.\n\t */\n\tif (tm->tm_isdst < 0)\n\t\tprint_tz = false;\n\n\tswitch (style)\n\t{\n\t\tcase USE_ISO_DATES:\n\t\tcase USE_XSD_DATES:\n\t\t\t/* Compatible with ISO-8601 date formats */\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '-';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = (style == USE_ISO_DATES) ? ' ' : 'T';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\tif (print_tz)\n\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\tbreak;\n\n\t\tcase USE_SQL_DATES:\n\t\t\t/* Compatible with Oracle/Ingres date formats */\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t\t*str++ = '/';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = '/';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\t/*\n\t\t\t * Note: the uses of %.*s in this function would be risky if the\n\t\t\t * timezone names ever contain non-ASCII characters.  However, all\n\t\t\t * TZ abbreviations in the IANA database are plain ASCII.\n\t\t\t */\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_GERMAN_DATES:\n\t\t\t/* German variant on European style */\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mon, 2);\n\t\t\t*str++ = '.';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USE_POSTGRES_DATES:\n\t\tdefault:\n\t\t\t/* Backward-compatible with traditional Postgres abstime dates */\n\t\t\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);\n\t\t\ttm->tm_wday = j2day(day);\n\t\t\tmemcpy(str, days[tm->tm_wday], 3);\n\t\t\tstr += 3;\n\t\t\t*str++ = ' ';\n\t\t\tif (DateOrder == DATEORDER_DMY)\n\t\t\t{\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t\t*str++ = ' ';\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmemcpy(str, months[tm->tm_mon - 1], 3);\n\t\t\t\tstr += 3;\n\t\t\t\t*str++ = ' ';\n\t\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_mday, 2);\n\t\t\t}\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_hour, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = pg_ltostr_zeropad(str, tm->tm_min, 2);\n\t\t\t*str++ = ':';\n\t\t\tstr = AppendTimestampSeconds(str, tm, fsec);\n\t\t\t*str++ = ' ';\n\t\t\tstr = pg_ltostr_zeropad(str,\n\t\t\t\t\t\t\t\t\t(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1), 4);\n\n\t\t\tif (print_tz)\n\t\t\t{\n\t\t\t\tif (tzn)\n\t\t\t\t{\n\t\t\t\t\tsprintf(str, \" %.*s\", MAXTZLEN, tzn);\n\t\t\t\t\tstr += strlen(str);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * We have a time zone, but no string version. Use the\n\t\t\t\t\t * numeric form, but be sure to include a leading space to\n\t\t\t\t\t * avoid formatting something which would be rejected by\n\t\t\t\t\t * the date/time parser later. - thomas 2001-10-19\n\t\t\t\t\t */\n\t\t\t\t\t*str++ = ' ';\n\t\t\t\t\tstr = EncodeTimezone(str, tz, style);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tif (tm->tm_year <= 0)\n\t{\n\t\tmemcpy(str, \" BC\", 3);\t/* Don't copy NUL */\n\t\tstr += 3;\n\t}\n\t*str = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "abstime2tm",
          "args": [
            "time",
            "&tz",
            "tm",
            "&tzn"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "abstime2tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "98-146",
          "snippet": "void\nabstime2tm(AbsoluteTime _time, int *tzp, struct pg_tm *tm, char **tzn)\n{\n\tpg_time_t\ttime = (pg_time_t) _time;\n\tstruct pg_tm *tx;\n\n\tif (tzp != NULL)\n\t\ttx = pg_localtime(&time, session_timezone);\n\telse\n\t\ttx = pg_gmtime(&time);\n\n\tif (tx == NULL)\n\t\telog(ERROR, \"could not convert abstime to timestamp: %m\");\n\n\ttm->tm_year = tx->tm_year + 1900;\n\ttm->tm_mon = tx->tm_mon + 1;\n\ttm->tm_mday = tx->tm_mday;\n\ttm->tm_hour = tx->tm_hour;\n\ttm->tm_min = tx->tm_min;\n\ttm->tm_sec = tx->tm_sec;\n\ttm->tm_isdst = tx->tm_isdst;\n\n\ttm->tm_gmtoff = tx->tm_gmtoff;\n\ttm->tm_zone = tx->tm_zone;\n\n\tif (tzp != NULL)\n\t{\n\t\t*tzp = -tm->tm_gmtoff;\t/* tm_gmtoff is Sun/DEC-ism */\n\n\t\t/*\n\t\t * XXX FreeBSD man pages indicate that this should work - tgl 97/04/23\n\t\t */\n\t\tif (tzn != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy no more than MAXTZLEN bytes of timezone to tzn, in case it\n\t\t\t * contains an error message, which doesn't fit in the buffer\n\t\t\t */\n\t\t\tStrNCpy(*tzn, tm->tm_zone, MAXTZLEN + 1);\n\t\t\tif (strlen(tm->tm_zone) > MAXTZLEN)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"invalid time zone name: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttm->tm_zone)));\n\t\t}\n\t}\n\telse\n\t\ttm->tm_isdst = -1;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void reltime2tm(RelativeTime time, struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void reltime2tm(RelativeTime time, struct pg_tm *tm);\n\nvoid\nabstime2tm(AbsoluteTime _time, int *tzp, struct pg_tm *tm, char **tzn)\n{\n\tpg_time_t\ttime = (pg_time_t) _time;\n\tstruct pg_tm *tx;\n\n\tif (tzp != NULL)\n\t\ttx = pg_localtime(&time, session_timezone);\n\telse\n\t\ttx = pg_gmtime(&time);\n\n\tif (tx == NULL)\n\t\telog(ERROR, \"could not convert abstime to timestamp: %m\");\n\n\ttm->tm_year = tx->tm_year + 1900;\n\ttm->tm_mon = tx->tm_mon + 1;\n\ttm->tm_mday = tx->tm_mday;\n\ttm->tm_hour = tx->tm_hour;\n\ttm->tm_min = tx->tm_min;\n\ttm->tm_sec = tx->tm_sec;\n\ttm->tm_isdst = tx->tm_isdst;\n\n\ttm->tm_gmtoff = tx->tm_gmtoff;\n\ttm->tm_zone = tx->tm_zone;\n\n\tif (tzp != NULL)\n\t{\n\t\t*tzp = -tm->tm_gmtoff;\t/* tm_gmtoff is Sun/DEC-ism */\n\n\t\t/*\n\t\t * XXX FreeBSD man pages indicate that this should work - tgl 97/04/23\n\t\t */\n\t\tif (tzn != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy no more than MAXTZLEN bytes of timezone to tzn, in case it\n\t\t\t * contains an error message, which doesn't fit in the buffer\n\t\t\t */\n\t\t\tStrNCpy(*tzn, tm->tm_zone, MAXTZLEN + 1);\n\t\t\tif (strlen(tm->tm_zone) > MAXTZLEN)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"invalid time zone name: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttm->tm_zone)));\n\t\t}\n\t}\n\telse\n\t\ttm->tm_isdst = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buf",
            "EARLY"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ABSOLUTETIME",
          "args": [
            "0"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic AbsoluteTime tm2abstime(struct pg_tm *tm, int tz);\nstatic void reltime2tm(RelativeTime time, struct pg_tm *tm);\n\nDatum\nabstimeout(PG_FUNCTION_ARGS)\n{\n\tAbsoluteTime time = PG_GETARG_ABSOLUTETIME(0);\n\tchar\t   *result;\n\tint\t\t\ttz;\n\tdouble\t\tfsec = 0;\n\tstruct pg_tm tt,\n\t\t\t   *tm = &tt;\n\tchar\t\tbuf[MAXDATELEN + 1];\n\tchar\t\tzone[MAXDATELEN + 1],\n\t\t\t   *tzn = zone;\n\n\tswitch (time)\n\t{\n\t\t\t/*\n\t\t\t * Note that timestamp no longer supports 'invalid'. Retain\n\t\t\t * 'invalid' for abstime for now, but dump it someday.\n\t\t\t */\n\t\tcase INVALID_ABSTIME:\n\t\t\tstrcpy(buf, INVALID);\n\t\t\tbreak;\n\t\tcase NOEND_ABSTIME:\n\t\t\tstrcpy(buf, LATE);\n\t\t\tbreak;\n\t\tcase NOSTART_ABSTIME:\n\t\t\tstrcpy(buf, EARLY);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabstime2tm(time, &tz, tm, &tzn);\n\t\t\tEncodeDateTime(tm, fsec, true, tz, tzn, DateStyle, buf);\n\t\t\tbreak;\n\t}\n\n\tresult = pstrdup(buf);\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "abstimein",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "198-256",
    "snippet": "Datum\nabstimein(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tAbsoluteTime result;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz = 0;\n\tstruct pg_tm date,\n\t\t\t   *tm = &date;\n\tint\t\t\tdterr;\n\tchar\t   *field[MAXDATEFIELDS];\n\tchar\t\tworkbuf[MAXDATELEN + 1];\n\tint\t\t\tdtype;\n\tint\t\t\tnf,\n\t\t\t\tftype[MAXDATEFIELDS];\n\n\tdterr = ParseDateTime(str, workbuf, sizeof(workbuf),\n\t\t\t\t\t\t  field, ftype, MAXDATEFIELDS, &nf);\n\tif (dterr == 0)\n\t\tdterr = DecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, &tz);\n\tif (dterr != 0)\n\t\tDateTimeParseError(dterr, str, \"abstime\");\n\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tresult = tm2abstime(tm, tz);\n\t\t\tbreak;\n\n\t\tcase DTK_EPOCH:\n\n\t\t\t/*\n\t\t\t * Don't bother retaining this as a reserved value, but instead\n\t\t\t * just set to the actual epoch time (1970-01-01)\n\t\t\t */\n\t\t\tresult = 0;\n\t\t\tbreak;\n\n\t\tcase DTK_LATE:\n\t\t\tresult = NOEND_ABSTIME;\n\t\t\tbreak;\n\n\t\tcase DTK_EARLY:\n\t\t\tresult = NOSTART_ABSTIME;\n\t\t\tbreak;\n\n\t\tcase DTK_INVALID:\n\t\t\tresult = INVALID_ABSTIME;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected dtype %d while parsing abstime \\\"%s\\\"\",\n\t\t\t\t dtype, str);\n\t\t\tresult = INVALID_ABSTIME;\n\t\t\tbreak;\n\t};\n\n\tPG_RETURN_ABSOLUTETIME(result);\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static AbsoluteTime tm2abstime(struct pg_tm *tm, int tz);",
      "static void reltime2tm(RelativeTime time, struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_ABSOLUTETIME",
          "args": [
            "result"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected dtype %d while parsing abstime \\\"%s\\\"\"",
            "dtype",
            "str"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm2abstime",
          "args": [
            "tm",
            "tz"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "tm2abstime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "153-192",
          "snippet": "static AbsoluteTime\ntm2abstime(struct pg_tm *tm, int tz)\n{\n\tint\t\t\tday;\n\tAbsoluteTime sec;\n\n\t/* validate, before going out of range on some members */\n\tif (tm->tm_year < 1901 || tm->tm_year > 2038 ||\n\t\ttm->tm_mon < 1 || tm->tm_mon > MONTHS_PER_YEAR ||\n\t\ttm->tm_mday < 1 || tm->tm_mday > 31 ||\n\t\ttm->tm_hour < 0 ||\n\t\ttm->tm_hour > HOURS_PER_DAY ||\t/* test for > 24:00:00 */\n\t\t(tm->tm_hour == HOURS_PER_DAY && (tm->tm_min > 0 || tm->tm_sec > 0)) ||\n\t\ttm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE)\n\t\treturn INVALID_ABSTIME;\n\n\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - UNIX_EPOCH_JDATE;\n\n\t/* check for time out of range */\n\tif (day < MIN_DAYNUM || day > MAX_DAYNUM)\n\t\treturn INVALID_ABSTIME;\n\n\t/* convert to seconds */\n\tsec = tm->tm_sec + tz + (tm->tm_min + (day * HOURS_PER_DAY + tm->tm_hour) * MINS_PER_HOUR) * SECS_PER_MINUTE;\n\n\t/*\n\t * check for overflow.  We need a little slop here because the H/M/S plus\n\t * TZ offset could add up to more than 1 day.\n\t */\n\tif ((day >= MAX_DAYNUM - 10 && sec < 0) ||\n\t\t(day <= MIN_DAYNUM + 10 && sec > 0))\n\t\treturn INVALID_ABSTIME;\n\n\t/* check for reserved values (e.g. \"current\" on edge of usual range */\n\tif (!AbsoluteTimeIsReal(sec))\n\t\treturn INVALID_ABSTIME;\n\n\treturn sec;\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define MAX_DAYNUM 24854\t\t/* January 18, 2038 */",
            "#define MIN_DAYNUM (-24856)\t\t/* December 13, 1901 */"
          ],
          "globals_used": [
            "static AbsoluteTime tm2abstime(struct pg_tm *tm, int tz);",
            "static void reltime2tm(RelativeTime time, struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define MAX_DAYNUM 24854\t\t/* January 18, 2038 */\n#define MIN_DAYNUM (-24856)\t\t/* December 13, 1901 */\n\nstatic AbsoluteTime tm2abstime(struct pg_tm *tm, int tz);\nstatic void reltime2tm(RelativeTime time, struct pg_tm *tm);\n\nstatic AbsoluteTime\ntm2abstime(struct pg_tm *tm, int tz)\n{\n\tint\t\t\tday;\n\tAbsoluteTime sec;\n\n\t/* validate, before going out of range on some members */\n\tif (tm->tm_year < 1901 || tm->tm_year > 2038 ||\n\t\ttm->tm_mon < 1 || tm->tm_mon > MONTHS_PER_YEAR ||\n\t\ttm->tm_mday < 1 || tm->tm_mday > 31 ||\n\t\ttm->tm_hour < 0 ||\n\t\ttm->tm_hour > HOURS_PER_DAY ||\t/* test for > 24:00:00 */\n\t\t(tm->tm_hour == HOURS_PER_DAY && (tm->tm_min > 0 || tm->tm_sec > 0)) ||\n\t\ttm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE)\n\t\treturn INVALID_ABSTIME;\n\n\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - UNIX_EPOCH_JDATE;\n\n\t/* check for time out of range */\n\tif (day < MIN_DAYNUM || day > MAX_DAYNUM)\n\t\treturn INVALID_ABSTIME;\n\n\t/* convert to seconds */\n\tsec = tm->tm_sec + tz + (tm->tm_min + (day * HOURS_PER_DAY + tm->tm_hour) * MINS_PER_HOUR) * SECS_PER_MINUTE;\n\n\t/*\n\t * check for overflow.  We need a little slop here because the H/M/S plus\n\t * TZ offset could add up to more than 1 day.\n\t */\n\tif ((day >= MAX_DAYNUM - 10 && sec < 0) ||\n\t\t(day <= MIN_DAYNUM + 10 && sec > 0))\n\t\treturn INVALID_ABSTIME;\n\n\t/* check for reserved values (e.g. \"current\" on edge of usual range */\n\tif (!AbsoluteTimeIsReal(sec))\n\t\treturn INVALID_ABSTIME;\n\n\treturn sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DateTimeParseError",
          "args": [
            "dterr",
            "str",
            "\"abstime\""
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "DateTimeParseError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "3753-3792",
          "snippet": "void\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nDateTimeParseError(int dterr, const char *str, const char *datatype)\n{\n\tswitch (dterr)\n\t{\n\t\tcase DTERR_FIELD_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_MD_FIELD_OVERFLOW:\n\t\t\t/* <nanny>same as above, but add hint about DateStyle</nanny> */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATETIME_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"date/time field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr),\n\t\t\t\t\t errhint(\"Perhaps you need a different \\\"datestyle\\\" setting.\")));\n\t\t\tbreak;\n\t\tcase DTERR_INTERVAL_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INTERVAL_FIELD_OVERFLOW),\n\t\t\t\t\t errmsg(\"interval field value out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_TZDISP_OVERFLOW:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),\n\t\t\t\t\t errmsg(\"time zone displacement out of range: \\\"%s\\\"\",\n\t\t\t\t\t\t\tstr)));\n\t\t\tbreak;\n\t\tcase DTERR_BAD_FORMAT:\n\t\tdefault:\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_DATETIME_FORMAT),\n\t\t\t\t\t errmsg(\"invalid input syntax for type %s: \\\"%s\\\"\",\n\t\t\t\t\t\t\tdatatype, str)));\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeDateTime",
          "args": [
            "field",
            "ftype",
            "nf",
            "&dtype",
            "tm",
            "&fsec",
            "&tz"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "766-1439",
          "snippet": "int\nDecodeDateTime(char **field, int *ftype, int nf,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\tptype = 0;\t\t/* \"prefix type\" for ISO y2001m02d04 format */\n\tint\t\t\ti;\n\tint\t\t\tval;\n\tint\t\t\tdterr;\n\tint\t\t\tmer = HR24;\n\tbool\t\thaveTextMonth = false;\n\tbool\t\tisjulian = false;\n\tbool\t\tis2digits = false;\n\tbool\t\tbc = false;\n\tpg_tz\t   *namedTz = NULL;\n\tpg_tz\t   *abbrevTz = NULL;\n\tpg_tz\t   *valtz;\n\tchar\t   *abbrev = NULL;\n\tstruct pg_tm cur_tm;\n\n\t/*\n\t * We'll insist on at least all of the date fields, but initialize the\n\t * remaining fields in case they are not set later...\n\t */\n\t*dtype = DTK_DATE;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n\t/* don't know daylight savings time status apriori */\n\ttm->tm_isdst = -1;\n\tif (tzp != NULL)\n\t\t*tzp = 0;\n\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_DATE:\n\n\t\t\t\t/*\n\t\t\t\t * Integral julian day with attached time zone? All other\n\t\t\t\t * forms with JD will be separated into distinct fields, so we\n\t\t\t\t * handle just this case here.\n\t\t\t\t */\n\t\t\t\tif (ptype == DTK_JULIAN)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE || val < 0)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\n\t\t\t\t\ttmask = DTK_DATE_M | DTK_TIME_M | DTK_M(TZ);\n\t\t\t\t\tptype = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Already have a date? Then this might be a time zone name\n\t\t\t\t * with embedded punctuation (e.g. \"America/New_York\") or a\n\t\t\t\t * run-together time with trailing time zone (e.g. hhmmss-zz).\n\t\t\t\t * - thomas 2001-12-25\n\t\t\t\t *\n\t\t\t\t * We consider it a time zone if we already have month & day.\n\t\t\t\t * This is to allow the form \"mmm dd hhmmss tz year\", which\n\t\t\t\t * we've historically accepted.\n\t\t\t\t */\n\t\t\t\telse if (ptype != 0 ||\n\t\t\t\t\t\t ((fmask & (DTK_M(MONTH) | DTK_M(DAY))) ==\n\t\t\t\t\t\t  (DTK_M(MONTH) | DTK_M(DAY))))\n\t\t\t\t{\n\t\t\t\t\t/* No time zone accepted? Then quit... */\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tif (isdigit((unsigned char) *field[i]) || ptype != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar\t   *cp;\n\n\t\t\t\t\t\tif (ptype != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Sanity check; should not fail this test */\n\t\t\t\t\t\t\tif (ptype != DTK_TIME)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tptype = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Starts with a digit but we already have a time\n\t\t\t\t\t\t * field? Then we are in trouble with a date and time\n\t\t\t\t\t\t * already...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tif ((cp = strchr(field[i], '-')) == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t*cp = '\\0';\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Then read the rest of the field as a concatenated\n\t\t\t\t\t\t * time\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * modify tmask after returning from\n\t\t\t\t\t\t * DecodeNumberField()\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We should return an error code instead of\n\t\t\t\t\t\t\t * ereport'ing directly, but then there is no way\n\t\t\t\t\t\t\t * to report the bad time zone name.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\t\t\t\tfield[i])));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TIME:\n\n\t\t\t\t/*\n\t\t\t\t * This might be an ISO time following a \"t\" field.\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\t/* Sanity check; should not fail this test */\n\t\t\t\t\tif (ptype != DTK_TIME)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tptype = 0;\n\t\t\t\t}\n\t\t\t\tdterr = DecodeTime(field[i], fmask, INTERVAL_FULL_RANGE,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\n\t\t\t\t/*\n\t\t\t\t * Check upper limit on hours; other limits checked in\n\t\t\t\t * DecodeTime()\n\t\t\t\t */\n\t\t\t\t/* test for > 24:00:00 */\n\t\t\t\tif (tm->tm_hour > HOURS_PER_DAY ||\n\t\t\t\t\t(tm->tm_hour == HOURS_PER_DAY &&\n\t\t\t\t\t (tm->tm_min > 0 || tm->tm_sec > 0 || *fsec > 0)))\n\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tdterr = DecodeTimezone(field[i], &tz);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t*tzp = tz;\n\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_NUMBER:\n\n\t\t\t\t/*\n\t\t\t\t * Was this an \"ISO date\" with embedded field labels? An\n\t\t\t\t * example is \"y2001m02d04\" - thomas 2001-02-04\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only a few kinds are allowed to have an embedded\n\t\t\t\t\t * decimal\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MONTH:\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * already have a month and hour? then assume\n\t\t\t\t\t\t\t * minutes\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) != 0 &&\n\t\t\t\t\t\t\t\t(fmask & DTK_M(HOUR)) != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\t\ttm->tm_hour = val;\n\t\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\ttm->tm_sec = val;\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TZ:\n\t\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\t\tdterr = DecodeTimezone(field[i], tzp);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\t/* previous field was a label for \"julian date\" */\n\t\t\t\t\t\t\tif (val < 0)\n\t\t\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t\t\t/* fractional Julian Day? */\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdouble\t\ttime;\n\n\t\t\t\t\t\t\t\terrno = 0;\n\t\t\t\t\t\t\t\ttime = strtod(cp, &cp);\n\t\t\t\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\ttime *= USECS_PER_DAY;\n\t\t\t\t\t\t\t\tdt2time(time,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_hour, &tm->tm_min,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_sec, fsec);\n\t\t\t\t\t\t\t\ttmask |= DTK_TIME_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\t/* previous field was \"t\" for ISO time */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tif (tmask != DTK_TIME_M)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tptype = 0;\n\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tflen;\n\n\t\t\t\t\tflen = strlen(field[i]);\n\t\t\t\t\tcp = strchr(field[i], '.');\n\n\t\t\t\t\t/* Embedded decimal and no date yet? */\n\t\t\t\t\tif (cp != NULL && !(fmask & DTK_DATE_M))\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* embedded decimal and several digits before? */\n\t\t\t\t\telse if (cp != NULL && flen - strlen(cp) > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Interpret as a concatenated date or time Set the\n\t\t\t\t\t\t * type field to allow decoding other fields later.\n\t\t\t\t\t\t * Example: 20011223 or 040506\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Is this a YMD or HMS specification, or a year number?\n\t\t\t\t\t * YMD and HMS are required to be six digits or more, so\n\t\t\t\t\t * if it is 5 digits, it is a year.  If it is six or more\n\t\t\t\t\t * more digits, we assume it is YMD or HMS unless no date\n\t\t\t\t\t * and no time values have been specified.  This forces 6+\n\t\t\t\t\t * digit years to be at the end of the string, or to use\n\t\t\t\t\t * the ISO date specification.\n\t\t\t\t\t */\n\t\t\t\t\telse if (flen >= 6 && (!(fmask & DTK_DATE_M) ||\n\t\t\t\t\t\t\t\t\t\t   !(fmask & DTK_TIME_M)))\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* otherwise it is a single date/time field... */\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumber(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t haveTextMonth, fmask,\n\t\t\t\t\t\t\t\t\t\t\t &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t fsec, &is2digits);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\t/* timezone abbrevs take precedence over built-in tokens */\n\t\t\t\ttype = DecodeTimezoneAbbrev(i, field[i], &val, &valtz);\n\t\t\t\tif (type == UNKNOWN_FIELD)\n\t\t\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = DTK_M(type);\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\tswitch (val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_CURRENT:\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\")));\n\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_NOW:\n\t\t\t\t\t\t\t\ttmask = (DTK_DATE_M | DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentTimeUsec(tm, fsec, tzp);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_YESTERDAY:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\tj2date(date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) - 1,\n\t\t\t\t\t\t\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_TODAY:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\ttm->tm_year = cur_tm.tm_year;\n\t\t\t\t\t\t\t\ttm->tm_mon = cur_tm.tm_mon;\n\t\t\t\t\t\t\t\ttm->tm_mday = cur_tm.tm_mday;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_TOMORROW:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\tj2date(date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) + 1,\n\t\t\t\t\t\t\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_ZULU:\n\t\t\t\t\t\t\t\ttmask = (DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\t\t\t\tif (tzp != NULL)\n\t\t\t\t\t\t\t\t\t*tzp = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t*dtype = val;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MONTH:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * already have a (numeric) month? then see if we can\n\t\t\t\t\t\t * substitute...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) && !haveTextMonth &&\n\t\t\t\t\t\t\t!(fmask & DTK_M(DAY)) && tm->tm_mon >= 1 &&\n\t\t\t\t\t\t\ttm->tm_mon <= 31)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttm->tm_mday = tm->tm_mon;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thaveTextMonth = true;\n\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZMOD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * daylight savings time modifier (solves \"MET DST\"\n\t\t\t\t\t\t * syntax)\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(DTZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp -= val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZ:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * set mask for TZ here _or_ check for DTZ later when\n\t\t\t\t\t\t * getting default timezone\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TZ:\n\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DYNTZ:\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll determine the actual offset later */\n\t\t\t\t\t\tabbrevTz = valtz;\n\t\t\t\t\t\tabbrev = field[i];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AMPM:\n\t\t\t\t\t\tmer = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ADBC:\n\t\t\t\t\t\tbc = (val == BC);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DOW:\n\t\t\t\t\t\ttm->tm_wday = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttmask = 0;\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ISOTIME:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is a filler field \"t\" indicating that the next\n\t\t\t\t\t\t * field is time. Try to verify that this is sensible.\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask = 0;\n\n\t\t\t\t\t\t/* No preceding date? Then quit... */\n\t\t\t\t\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/***\n\t\t\t\t\t\t * We will need one of the following fields:\n\t\t\t\t\t\t *\tDTK_NUMBER should be hhmmss.fff\n\t\t\t\t\t\t *\tDTK_TIME should be hh:mm:ss.fff\n\t\t\t\t\t\t *\tDTK_DATE should be hhmmss-zz\n\t\t\t\t\t\t ***/\n\t\t\t\t\t\tif (i >= nf - 1 ||\n\t\t\t\t\t\t\t(ftype[i + 1] != DTK_NUMBER &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_TIME &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_DATE))\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNKNOWN_FIELD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Before giving up and declaring error, check to see\n\t\t\t\t\t\t * if it is an all-alpha timezone name.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\t\t\t\t\t\t\t/* end loop over fields */\n\n\t/* do final checking/adjustment of Y/M/D fields */\n\tdterr = ValidateDate(fmask, isjulian, is2digits, bc, tm);\n\tif (dterr)\n\t\treturn dterr;\n\n\t/* handle AM/PM */\n\tif (mer != HR24 && tm->tm_hour > HOURS_PER_DAY / 2)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (mer == AM && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\ttm->tm_hour = 0;\n\telse if (mer == PM && tm->tm_hour != HOURS_PER_DAY / 2)\n\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\n\t/* do additional checking for full date specs... */\n\tif (*dtype == DTK_DATE)\n\t{\n\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t{\n\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\treturn 1;\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\t/*\n\t\t * If we had a full timezone spec, compute the offset (we could not do\n\t\t * it before, because we need the date to resolve DST status).\n\t\t */\n\t\tif (namedTz != NULL)\n\t\t{\n\t\t\t/* daylight savings time modifier disallowed with full TZ */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, namedTz);\n\t\t}\n\n\t\t/*\n\t\t * Likewise, if we had a dynamic timezone abbreviation, resolve it\n\t\t * now.\n\t\t */\n\t\tif (abbrevTz != NULL)\n\t\t{\n\t\t\t/* daylight savings time modifier disallowed with dynamic TZ */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneAbbrevOffset(tm, abbrev, abbrevTz);\n\t\t}\n\n\t\t/* timezone not specified? then use session timezone */\n\t\tif (tzp != NULL && !(fmask & DTK_M(TZ)))\n\t\t{\n\t\t\t/*\n\t\t\t * daylight savings time modifier but no standard timezone? then\n\t\t\t * error\n\t\t\t */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, session_timezone);\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);",
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeNumber(int flen, char *field, bool haveTextMonth,\n\t\t\t int fmask, int *tmask,\n\t\t\t struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeNumberField(int len, char *str,\n\t\t\t\t  int fmask, int *tmask,\n\t\t\t\t  struct pg_tm *tm, fsec_t *fsec, bool *is2digits);\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nint\nDecodeDateTime(char **field, int *ftype, int nf,\n\t\t\t   int *dtype, struct pg_tm *tm, fsec_t *fsec, int *tzp)\n{\n\tint\t\t\tfmask = 0,\n\t\t\t\ttmask,\n\t\t\t\ttype;\n\tint\t\t\tptype = 0;\t\t/* \"prefix type\" for ISO y2001m02d04 format */\n\tint\t\t\ti;\n\tint\t\t\tval;\n\tint\t\t\tdterr;\n\tint\t\t\tmer = HR24;\n\tbool\t\thaveTextMonth = false;\n\tbool\t\tisjulian = false;\n\tbool\t\tis2digits = false;\n\tbool\t\tbc = false;\n\tpg_tz\t   *namedTz = NULL;\n\tpg_tz\t   *abbrevTz = NULL;\n\tpg_tz\t   *valtz;\n\tchar\t   *abbrev = NULL;\n\tstruct pg_tm cur_tm;\n\n\t/*\n\t * We'll insist on at least all of the date fields, but initialize the\n\t * remaining fields in case they are not set later...\n\t */\n\t*dtype = DTK_DATE;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\t*fsec = 0;\n\t/* don't know daylight savings time status apriori */\n\ttm->tm_isdst = -1;\n\tif (tzp != NULL)\n\t\t*tzp = 0;\n\n\tfor (i = 0; i < nf; i++)\n\t{\n\t\tswitch (ftype[i])\n\t\t{\n\t\t\tcase DTK_DATE:\n\n\t\t\t\t/*\n\t\t\t\t * Integral julian day with attached time zone? All other\n\t\t\t\t * forms with JD will be separated into distinct fields, so we\n\t\t\t\t * handle just this case here.\n\t\t\t\t */\n\t\t\t\tif (ptype == DTK_JULIAN)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE || val < 0)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\n\t\t\t\t\ttmask = DTK_DATE_M | DTK_TIME_M | DTK_M(TZ);\n\t\t\t\t\tptype = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Already have a date? Then this might be a time zone name\n\t\t\t\t * with embedded punctuation (e.g. \"America/New_York\") or a\n\t\t\t\t * run-together time with trailing time zone (e.g. hhmmss-zz).\n\t\t\t\t * - thomas 2001-12-25\n\t\t\t\t *\n\t\t\t\t * We consider it a time zone if we already have month & day.\n\t\t\t\t * This is to allow the form \"mmm dd hhmmss tz year\", which\n\t\t\t\t * we've historically accepted.\n\t\t\t\t */\n\t\t\t\telse if (ptype != 0 ||\n\t\t\t\t\t\t ((fmask & (DTK_M(MONTH) | DTK_M(DAY))) ==\n\t\t\t\t\t\t  (DTK_M(MONTH) | DTK_M(DAY))))\n\t\t\t\t{\n\t\t\t\t\t/* No time zone accepted? Then quit... */\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tif (isdigit((unsigned char) *field[i]) || ptype != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar\t   *cp;\n\n\t\t\t\t\t\tif (ptype != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/* Sanity check; should not fail this test */\n\t\t\t\t\t\t\tif (ptype != DTK_TIME)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tptype = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Starts with a digit but we already have a time\n\t\t\t\t\t\t * field? Then we are in trouble with a date and time\n\t\t\t\t\t\t * already...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tif ((cp = strchr(field[i], '-')) == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/* Get the time zone from the end of the string */\n\t\t\t\t\t\tdterr = DecodeTimezone(cp, tzp);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t*cp = '\\0';\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Then read the rest of the field as a concatenated\n\t\t\t\t\t\t * time\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t  fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * modify tmask after returning from\n\t\t\t\t\t\t * DecodeNumberField()\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * We should return an error code instead of\n\t\t\t\t\t\t\t * ereport'ing directly, but then there is no way\n\t\t\t\t\t\t\t * to report the bad time zone name.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t\t\t\t errmsg(\"time zone \\\"%s\\\" not recognized\",\n\t\t\t\t\t\t\t\t\t\t\tfield[i])));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TIME:\n\n\t\t\t\t/*\n\t\t\t\t * This might be an ISO time following a \"t\" field.\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\t/* Sanity check; should not fail this test */\n\t\t\t\t\tif (ptype != DTK_TIME)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\tptype = 0;\n\t\t\t\t}\n\t\t\t\tdterr = DecodeTime(field[i], fmask, INTERVAL_FULL_RANGE,\n\t\t\t\t\t\t\t\t   &tmask, tm, fsec);\n\t\t\t\tif (dterr)\n\t\t\t\t\treturn dterr;\n\n\t\t\t\t/*\n\t\t\t\t * Check upper limit on hours; other limits checked in\n\t\t\t\t * DecodeTime()\n\t\t\t\t */\n\t\t\t\t/* test for > 24:00:00 */\n\t\t\t\tif (tm->tm_hour > HOURS_PER_DAY ||\n\t\t\t\t\t(tm->tm_hour == HOURS_PER_DAY &&\n\t\t\t\t\t (tm->tm_min > 0 || tm->tm_sec > 0 || *fsec > 0)))\n\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_TZ:\n\t\t\t\t{\n\t\t\t\t\tint\t\t\ttz;\n\n\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tdterr = DecodeTimezone(field[i], &tz);\n\t\t\t\t\tif (dterr)\n\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t*tzp = tz;\n\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_NUMBER:\n\n\t\t\t\t/*\n\t\t\t\t * Was this an \"ISO date\" with embedded field labels? An\n\t\t\t\t * example is \"y2001m02d04\" - thomas 2001-02-04\n\t\t\t\t */\n\t\t\t\tif (ptype != 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tval;\n\n\t\t\t\t\terrno = 0;\n\t\t\t\t\tval = strtoint(field[i], &cp, 10);\n\t\t\t\t\tif (errno == ERANGE)\n\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only a few kinds are allowed to have an embedded\n\t\t\t\t\t * decimal\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (*cp != '\\0')\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\tswitch (ptype)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase DTK_YEAR:\n\t\t\t\t\t\t\ttm->tm_year = val;\n\t\t\t\t\t\t\ttmask = DTK_M(YEAR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MONTH:\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * already have a month and hour? then assume\n\t\t\t\t\t\t\t * minutes\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) != 0 &&\n\t\t\t\t\t\t\t\t(fmask & DTK_M(HOUR)) != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\t\t\ttmask = DTK_M(MONTH);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_DAY:\n\t\t\t\t\t\t\ttm->tm_mday = val;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_HOUR:\n\t\t\t\t\t\t\ttm->tm_hour = val;\n\t\t\t\t\t\t\ttmask = DTK_M(HOUR);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_MINUTE:\n\t\t\t\t\t\t\ttm->tm_min = val;\n\t\t\t\t\t\t\ttmask = DTK_M(MINUTE);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_SECOND:\n\t\t\t\t\t\t\ttm->tm_sec = val;\n\t\t\t\t\t\t\ttmask = DTK_M(SECOND);\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdterr = ParseFractionalSecond(cp, fsec);\n\t\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\t\ttmask = DTK_ALL_SECS_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TZ:\n\t\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\t\tdterr = DecodeTimezone(field[i], tzp);\n\t\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_JULIAN:\n\t\t\t\t\t\t\t/* previous field was a label for \"julian date\" */\n\t\t\t\t\t\t\tif (val < 0)\n\t\t\t\t\t\t\t\treturn DTERR_FIELD_OVERFLOW;\n\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\tj2date(val, &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\tisjulian = true;\n\n\t\t\t\t\t\t\t/* fractional Julian Day? */\n\t\t\t\t\t\t\tif (*cp == '.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdouble\t\ttime;\n\n\t\t\t\t\t\t\t\terrno = 0;\n\t\t\t\t\t\t\t\ttime = strtod(cp, &cp);\n\t\t\t\t\t\t\t\tif (*cp != '\\0' || errno != 0)\n\t\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\ttime *= USECS_PER_DAY;\n\t\t\t\t\t\t\t\tdt2time(time,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_hour, &tm->tm_min,\n\t\t\t\t\t\t\t\t\t\t&tm->tm_sec, fsec);\n\t\t\t\t\t\t\t\ttmask |= DTK_TIME_M;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase DTK_TIME:\n\t\t\t\t\t\t\t/* previous field was \"t\" for ISO time */\n\t\t\t\t\t\t\tdterr = DecodeNumberField(strlen(field[i]), field[i],\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (fmask | DTK_DATE_M),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t\t\tif (tmask != DTK_TIME_M)\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tptype = 0;\n\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tchar\t   *cp;\n\t\t\t\t\tint\t\t\tflen;\n\n\t\t\t\t\tflen = strlen(field[i]);\n\t\t\t\t\tcp = strchr(field[i], '.');\n\n\t\t\t\t\t/* Embedded decimal and no date yet? */\n\t\t\t\t\tif (cp != NULL && !(fmask & DTK_DATE_M))\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeDate(field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t   &tmask, &is2digits, tm);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* embedded decimal and several digits before? */\n\t\t\t\t\telse if (cp != NULL && flen - strlen(cp) > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Interpret as a concatenated date or time Set the\n\t\t\t\t\t\t * type field to allow decoding other fields later.\n\t\t\t\t\t\t * Example: 20011223 or 040506\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Is this a YMD or HMS specification, or a year number?\n\t\t\t\t\t * YMD and HMS are required to be six digits or more, so\n\t\t\t\t\t * if it is 5 digits, it is a year.  If it is six or more\n\t\t\t\t\t * more digits, we assume it is YMD or HMS unless no date\n\t\t\t\t\t * and no time values have been specified.  This forces 6+\n\t\t\t\t\t * digit years to be at the end of the string, or to use\n\t\t\t\t\t * the ISO date specification.\n\t\t\t\t\t */\n\t\t\t\t\telse if (flen >= 6 && (!(fmask & DTK_DATE_M) ||\n\t\t\t\t\t\t\t\t\t\t   !(fmask & DTK_TIME_M)))\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumberField(flen, field[i], fmask,\n\t\t\t\t\t\t\t\t\t\t\t\t  &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t\t  fsec, &is2digits);\n\t\t\t\t\t\tif (dterr < 0)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t\t/* otherwise it is a single date/time field... */\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdterr = DecodeNumber(flen, field[i],\n\t\t\t\t\t\t\t\t\t\t\t haveTextMonth, fmask,\n\t\t\t\t\t\t\t\t\t\t\t &tmask, tm,\n\t\t\t\t\t\t\t\t\t\t\t fsec, &is2digits);\n\t\t\t\t\t\tif (dterr)\n\t\t\t\t\t\t\treturn dterr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase DTK_STRING:\n\t\t\tcase DTK_SPECIAL:\n\t\t\t\t/* timezone abbrevs take precedence over built-in tokens */\n\t\t\t\ttype = DecodeTimezoneAbbrev(i, field[i], &val, &valtz);\n\t\t\t\tif (type == UNKNOWN_FIELD)\n\t\t\t\t\ttype = DecodeSpecial(i, field[i], &val);\n\t\t\t\tif (type == IGNORE_DTF)\n\t\t\t\t\tcontinue;\n\n\t\t\t\ttmask = DTK_M(type);\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\t\tcase RESERV:\n\t\t\t\t\t\tswitch (val)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase DTK_CURRENT:\n\t\t\t\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t\t\t\t\t\t\t\t errmsg(\"date/time value \\\"current\\\" is no longer supported\")));\n\n\t\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_NOW:\n\t\t\t\t\t\t\t\ttmask = (DTK_DATE_M | DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentTimeUsec(tm, fsec, tzp);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_YESTERDAY:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\tj2date(date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) - 1,\n\t\t\t\t\t\t\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_TODAY:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\ttm->tm_year = cur_tm.tm_year;\n\t\t\t\t\t\t\t\ttm->tm_mon = cur_tm.tm_mon;\n\t\t\t\t\t\t\t\ttm->tm_mday = cur_tm.tm_mday;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_TOMORROW:\n\t\t\t\t\t\t\t\ttmask = DTK_DATE_M;\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\tGetCurrentDateTime(&cur_tm);\n\t\t\t\t\t\t\t\tj2date(date2j(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) + 1,\n\t\t\t\t\t\t\t\t\t   &tm->tm_year, &tm->tm_mon, &tm->tm_mday);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase DTK_ZULU:\n\t\t\t\t\t\t\t\ttmask = (DTK_TIME_M | DTK_M(TZ));\n\t\t\t\t\t\t\t\t*dtype = DTK_DATE;\n\t\t\t\t\t\t\t\ttm->tm_hour = 0;\n\t\t\t\t\t\t\t\ttm->tm_min = 0;\n\t\t\t\t\t\t\t\ttm->tm_sec = 0;\n\t\t\t\t\t\t\t\tif (tzp != NULL)\n\t\t\t\t\t\t\t\t\t*tzp = 0;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t*dtype = val;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MONTH:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * already have a (numeric) month? then see if we can\n\t\t\t\t\t\t * substitute...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif ((fmask & DTK_M(MONTH)) && !haveTextMonth &&\n\t\t\t\t\t\t\t!(fmask & DTK_M(DAY)) && tm->tm_mon >= 1 &&\n\t\t\t\t\t\t\ttm->tm_mon <= 31)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttm->tm_mday = tm->tm_mon;\n\t\t\t\t\t\t\ttmask = DTK_M(DAY);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thaveTextMonth = true;\n\t\t\t\t\t\ttm->tm_mon = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZMOD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * daylight savings time modifier (solves \"MET DST\"\n\t\t\t\t\t\t * syntax)\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(DTZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp -= val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DTZ:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * set mask for TZ here _or_ check for DTZ later when\n\t\t\t\t\t\t * getting default timezone\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\ttm->tm_isdst = 1;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TZ:\n\t\t\t\t\t\ttm->tm_isdst = 0;\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t*tzp = -val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DYNTZ:\n\t\t\t\t\t\ttmask |= DTK_M(TZ);\n\t\t\t\t\t\tif (tzp == NULL)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll determine the actual offset later */\n\t\t\t\t\t\tabbrevTz = valtz;\n\t\t\t\t\t\tabbrev = field[i];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase AMPM:\n\t\t\t\t\t\tmer = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ADBC:\n\t\t\t\t\t\tbc = (val == BC);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DOW:\n\t\t\t\t\t\ttm->tm_wday = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNITS:\n\t\t\t\t\t\ttmask = 0;\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ISOTIME:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This is a filler field \"t\" indicating that the next\n\t\t\t\t\t\t * field is time. Try to verify that this is sensible.\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttmask = 0;\n\n\t\t\t\t\t\t/* No preceding date? Then quit... */\n\t\t\t\t\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\t/***\n\t\t\t\t\t\t * We will need one of the following fields:\n\t\t\t\t\t\t *\tDTK_NUMBER should be hhmmss.fff\n\t\t\t\t\t\t *\tDTK_TIME should be hh:mm:ss.fff\n\t\t\t\t\t\t *\tDTK_DATE should be hhmmss-zz\n\t\t\t\t\t\t ***/\n\t\t\t\t\t\tif (i >= nf - 1 ||\n\t\t\t\t\t\t\t(ftype[i + 1] != DTK_NUMBER &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_TIME &&\n\t\t\t\t\t\t\t ftype[i + 1] != DTK_DATE))\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t\t\t\tptype = val;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase UNKNOWN_FIELD:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Before giving up and declaring error, check to see\n\t\t\t\t\t\t * if it is an all-alpha timezone name.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tnamedTz = pg_tzset(field[i]);\n\t\t\t\t\t\tif (!namedTz)\n\t\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t\t\t/* we'll apply the zone setting below */\n\t\t\t\t\t\ttmask = DTK_M(TZ);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\tif (tmask & fmask)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfmask |= tmask;\n\t}\t\t\t\t\t\t\t/* end loop over fields */\n\n\t/* do final checking/adjustment of Y/M/D fields */\n\tdterr = ValidateDate(fmask, isjulian, is2digits, bc, tm);\n\tif (dterr)\n\t\treturn dterr;\n\n\t/* handle AM/PM */\n\tif (mer != HR24 && tm->tm_hour > HOURS_PER_DAY / 2)\n\t\treturn DTERR_FIELD_OVERFLOW;\n\tif (mer == AM && tm->tm_hour == HOURS_PER_DAY / 2)\n\t\ttm->tm_hour = 0;\n\telse if (mer == PM && tm->tm_hour != HOURS_PER_DAY / 2)\n\t\ttm->tm_hour += HOURS_PER_DAY / 2;\n\n\t/* do additional checking for full date specs... */\n\tif (*dtype == DTK_DATE)\n\t{\n\t\tif ((fmask & DTK_DATE_M) != DTK_DATE_M)\n\t\t{\n\t\t\tif ((fmask & DTK_TIME_M) == DTK_TIME_M)\n\t\t\t\treturn 1;\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\n\t\t/*\n\t\t * If we had a full timezone spec, compute the offset (we could not do\n\t\t * it before, because we need the date to resolve DST status).\n\t\t */\n\t\tif (namedTz != NULL)\n\t\t{\n\t\t\t/* daylight savings time modifier disallowed with full TZ */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, namedTz);\n\t\t}\n\n\t\t/*\n\t\t * Likewise, if we had a dynamic timezone abbreviation, resolve it\n\t\t * now.\n\t\t */\n\t\tif (abbrevTz != NULL)\n\t\t{\n\t\t\t/* daylight savings time modifier disallowed with dynamic TZ */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneAbbrevOffset(tm, abbrev, abbrevTz);\n\t\t}\n\n\t\t/* timezone not specified? then use session timezone */\n\t\tif (tzp != NULL && !(fmask & DTK_M(TZ)))\n\t\t{\n\t\t\t/*\n\t\t\t * daylight savings time modifier but no standard timezone? then\n\t\t\t * error\n\t\t\t */\n\t\t\tif (fmask & DTK_M(DTZMOD))\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t\t*tzp = DetermineTimeZoneOffset(tm, session_timezone);\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseDateTime",
          "args": [
            "str",
            "workbuf",
            "sizeof(workbuf)",
            "field",
            "ftype",
            "MAXDATEFIELDS",
            "&nf"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "ParseDateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "545-739",
          "snippet": "int\nParseDateTime(const char *timestr, char *workbuf, size_t buflen,\n\t\t\t  char **field, int *ftype, int maxfields, int *numfields)\n{\n\tint\t\t\tnf = 0;\n\tconst char *cp = timestr;\n\tchar\t   *bufp = workbuf;\n\tconst char *bufend = workbuf + buflen;\n\n\t/*\n\t * Set the character pointed-to by \"bufptr\" to \"newchar\", and increment\n\t * \"bufptr\". \"end\" gives the end of the buffer -- we return an error if\n\t * there is no space left to append a character to the buffer. Note that\n\t * \"bufptr\" is evaluated twice.\n\t */\n#define APPEND_CHAR(bufptr, end, newchar)\t\t\\\n\tdo\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (((bufptr) + 1) >= (end))\t\t\t\\\n\t\t\treturn DTERR_BAD_FORMAT;\t\t\t\\\n\t\t*(bufptr)++ = newchar;\t\t\t\t\t\\\n\t} while (0)\n\n\t/* outer loop through fields */\n\twhile (*cp != '\\0')\n\t{\n\t\t/* Ignore spaces between fields */\n\t\tif (isspace((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record start of current field */\n\t\tif (nf >= maxfields)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfield[nf] = bufp;\n\n\t\t/* leading digit? then date or time */\n\t\tif (isdigit((unsigned char) *cp))\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t/* time field? */\n\t\t\tif (*cp == ':')\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TIME;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   (*cp == ':') || (*cp == '.'))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* date field? allow embedded text month */\n\t\t\telse if (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t{\n\t\t\t\t/* save delimiting character to use later */\n\t\t\t\tchar\t\tdelim = *cp;\n\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t/* second field is all digits? then no embedded text month */\n\t\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = ((delim == '.') ? DTK_NUMBER : DTK_DATE);\n\t\t\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * insist that the delimiters match to get a three-field\n\t\t\t\t\t * date.\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == delim)\n\t\t\t\t\t{\n\t\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t\twhile (isdigit((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\twhile (isalnum((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * otherwise, number only and will determine year, month, day, or\n\t\t\t * concatenated fields later...\n\t\t\t */\n\t\t\telse\n\t\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\t\t/* Leading decimal point? Then fractional seconds... */\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\n\t\t/*\n\t\t * text? then date string, month, day of week, special, or timezone\n\t\t */\n\t\telse if (isalpha((unsigned char) *cp))\n\t\t{\n\t\t\tbool\t\tis_date;\n\n\t\t\tftype[nf] = DTK_STRING;\n\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\n\t\t\t/*\n\t\t\t * Dates can have embedded '-', '/', or '.' separators.  It could\n\t\t\t * also be a timezone name containing embedded '/', '+', '-', '_',\n\t\t\t * or ':' (but '_' or ':' can't be the first punctuation). If the\n\t\t\t * next character is a digit or '+', we need to check whether what\n\t\t\t * we have so far is a recognized non-timezone keyword --- if so,\n\t\t\t * don't believe that this is the start of a timezone.\n\t\t\t */\n\t\t\tis_date = false;\n\t\t\tif (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t\tis_date = true;\n\t\t\telse if (*cp == '+' || isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\t*bufp = '\\0';\t/* null-terminate current field value */\n\t\t\t\t/* we need search only the core token table, not TZ names */\n\t\t\t\tif (datebsearch(field[nf], datetktbl, szdatetktbl) == NULL)\n\t\t\t\t\tis_date = true;\n\t\t\t}\n\t\t\tif (is_date)\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t} while (*cp == '+' || *cp == '-' ||\n\t\t\t\t\t\t *cp == '/' || *cp == '_' ||\n\t\t\t\t\t\t *cp == '.' || *cp == ':' ||\n\t\t\t\t\t\t isalnum((unsigned char) *cp));\n\t\t\t}\n\t\t}\n\t\t/* sign? then special or numeric timezone */\n\t\telse if (*cp == '+' || *cp == '-')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t/* soak up leading whitespace */\n\t\t\twhile (isspace((unsigned char) *cp))\n\t\t\t\tcp++;\n\t\t\t/* numeric timezone? */\n\t\t\t/* note that \"DTK_TZ\" could also be a signed float or yyyy-mm */\n\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TZ;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   *cp == ':' || *cp == '.' || *cp == '-')\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* special? */\n\t\t\telse if (isalpha((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_SPECIAL;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t}\n\t\t\t/* otherwise something wrong... */\n\t\t\telse\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\t\t/* ignore other punctuation but use as delimiter */\n\t\telse if (ispunct((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* otherwise, something is not right... */\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* force in a delimiter after each field */\n\t\t*bufp++ = '\\0';\n\t\tnf++;\n\t}\n\n\t*numfields = nf;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};",
            "static int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic const datetkn datetktbl[] = {\n\t/* token, type, value */\n\t{EARLY, RESERV, DTK_EARLY}, /* \"-infinity\" reserved for \"early time\" */\n\t{DA_D, ADBC, AD},\t\t\t/* \"ad\" for years > 0 */\n\t{\"allballs\", RESERV, DTK_ZULU}, /* 00:00:00 */\n\t{\"am\", AMPM, AM},\n\t{\"apr\", MONTH, 4},\n\t{\"april\", MONTH, 4},\n\t{\"at\", IGNORE_DTF, 0},\t\t/* \"at\" (throwaway) */\n\t{\"aug\", MONTH, 8},\n\t{\"august\", MONTH, 8},\n\t{DB_C, ADBC, BC},\t\t\t/* \"bc\" for years <= 0 */\n\t{DCURRENT, RESERV, DTK_CURRENT},\t/* \"current\" is always now */\n\t{\"d\", UNITS, DTK_DAY},\t\t/* \"day of month\" for ISO input */\n\t{\"dec\", MONTH, 12},\n\t{\"december\", MONTH, 12},\n\t{\"dow\", UNITS, DTK_DOW},\t/* day of week */\n\t{\"doy\", UNITS, DTK_DOY},\t/* day of year */\n\t{\"dst\", DTZMOD, SECS_PER_HOUR},\n\t{EPOCH, RESERV, DTK_EPOCH}, /* \"epoch\" reserved for system epoch time */\n\t{\"feb\", MONTH, 2},\n\t{\"february\", MONTH, 2},\n\t{\"fri\", DOW, 5},\n\t{\"friday\", DOW, 5},\n\t{\"h\", UNITS, DTK_HOUR},\t\t/* \"hour\" */\n\t{LATE, RESERV, DTK_LATE},\t/* \"infinity\" reserved for \"late time\" */\n\t{INVALID, RESERV, DTK_INVALID}, /* \"invalid\" reserved for bad time */\n\t{\"isodow\", UNITS, DTK_ISODOW},\t/* ISO day of week, Sunday == 7 */\n\t{\"isoyear\", UNITS, DTK_ISOYEAR},\t/* year in terms of the ISO week date */\n\t{\"j\", UNITS, DTK_JULIAN},\n\t{\"jan\", MONTH, 1},\n\t{\"january\", MONTH, 1},\n\t{\"jd\", UNITS, DTK_JULIAN},\n\t{\"jul\", MONTH, 7},\n\t{\"julian\", UNITS, DTK_JULIAN},\n\t{\"july\", MONTH, 7},\n\t{\"jun\", MONTH, 6},\n\t{\"june\", MONTH, 6},\n\t{\"m\", UNITS, DTK_MONTH},\t/* \"month\" for ISO input */\n\t{\"mar\", MONTH, 3},\n\t{\"march\", MONTH, 3},\n\t{\"may\", MONTH, 5},\n\t{\"mm\", UNITS, DTK_MINUTE},\t/* \"minute\" for ISO input */\n\t{\"mon\", DOW, 1},\n\t{\"monday\", DOW, 1},\n\t{\"nov\", MONTH, 11},\n\t{\"november\", MONTH, 11},\n\t{NOW, RESERV, DTK_NOW},\t\t/* current transaction time */\n\t{\"oct\", MONTH, 10},\n\t{\"october\", MONTH, 10},\n\t{\"on\", IGNORE_DTF, 0},\t\t/* \"on\" (throwaway) */\n\t{\"pm\", AMPM, PM},\n\t{\"s\", UNITS, DTK_SECOND},\t/* \"seconds\" for ISO input */\n\t{\"sat\", DOW, 6},\n\t{\"saturday\", DOW, 6},\n\t{\"sep\", MONTH, 9},\n\t{\"sept\", MONTH, 9},\n\t{\"september\", MONTH, 9},\n\t{\"sun\", DOW, 0},\n\t{\"sunday\", DOW, 0},\n\t{\"t\", ISOTIME, DTK_TIME},\t/* Filler for ISO time fields */\n\t{\"thu\", DOW, 4},\n\t{\"thur\", DOW, 4},\n\t{\"thurs\", DOW, 4},\n\t{\"thursday\", DOW, 4},\n\t{TODAY, RESERV, DTK_TODAY}, /* midnight */\n\t{TOMORROW, RESERV, DTK_TOMORROW},\t/* tomorrow midnight */\n\t{\"tue\", DOW, 2},\n\t{\"tues\", DOW, 2},\n\t{\"tuesday\", DOW, 2},\n\t{\"undefined\", RESERV, DTK_INVALID}, /* pre-v6.1 invalid time */\n\t{\"wed\", DOW, 3},\n\t{\"wednesday\", DOW, 3},\n\t{\"weds\", DOW, 3},\n\t{\"y\", UNITS, DTK_YEAR},\t\t/* \"year\" for ISO input */\n\t{YESTERDAY, RESERV, DTK_YESTERDAY}\t/* yesterday midnight */\n};\nstatic int\tszdatetktbl = sizeof datetktbl / sizeof datetktbl[0];\n\nint\nParseDateTime(const char *timestr, char *workbuf, size_t buflen,\n\t\t\t  char **field, int *ftype, int maxfields, int *numfields)\n{\n\tint\t\t\tnf = 0;\n\tconst char *cp = timestr;\n\tchar\t   *bufp = workbuf;\n\tconst char *bufend = workbuf + buflen;\n\n\t/*\n\t * Set the character pointed-to by \"bufptr\" to \"newchar\", and increment\n\t * \"bufptr\". \"end\" gives the end of the buffer -- we return an error if\n\t * there is no space left to append a character to the buffer. Note that\n\t * \"bufptr\" is evaluated twice.\n\t */\n#define APPEND_CHAR(bufptr, end, newchar)\t\t\\\n\tdo\t\t\t\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (((bufptr) + 1) >= (end))\t\t\t\\\n\t\t\treturn DTERR_BAD_FORMAT;\t\t\t\\\n\t\t*(bufptr)++ = newchar;\t\t\t\t\t\\\n\t} while (0)\n\n\t/* outer loop through fields */\n\twhile (*cp != '\\0')\n\t{\n\t\t/* Ignore spaces between fields */\n\t\tif (isspace((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Record start of current field */\n\t\tif (nf >= maxfields)\n\t\t\treturn DTERR_BAD_FORMAT;\n\t\tfield[nf] = bufp;\n\n\t\t/* leading digit? then date or time */\n\t\tif (isdigit((unsigned char) *cp))\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t/* time field? */\n\t\t\tif (*cp == ':')\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TIME;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   (*cp == ':') || (*cp == '.'))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* date field? allow embedded text month */\n\t\t\telse if (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t{\n\t\t\t\t/* save delimiting character to use later */\n\t\t\t\tchar\t\tdelim = *cp;\n\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t/* second field is all digits? then no embedded text month */\n\t\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = ((delim == '.') ? DTK_NUMBER : DTK_DATE);\n\t\t\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\t\t\t/*\n\t\t\t\t\t * insist that the delimiters match to get a three-field\n\t\t\t\t\t * date.\n\t\t\t\t\t */\n\t\t\t\t\tif (*cp == delim)\n\t\t\t\t\t{\n\t\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t\twhile (isdigit((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\t\twhile (isalnum((unsigned char) *cp) || *cp == delim)\n\t\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * otherwise, number only and will determine year, month, day, or\n\t\t\t * concatenated fields later...\n\t\t\t */\n\t\t\telse\n\t\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\t\t/* Leading decimal point? Then fractional seconds... */\n\t\telse if (*cp == '.')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\twhile (isdigit((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\n\t\t\tftype[nf] = DTK_NUMBER;\n\t\t}\n\n\t\t/*\n\t\t * text? then date string, month, day of week, special, or timezone\n\t\t */\n\t\telse if (isalpha((unsigned char) *cp))\n\t\t{\n\t\t\tbool\t\tis_date;\n\n\t\t\tftype[nf] = DTK_STRING;\n\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\n\t\t\t/*\n\t\t\t * Dates can have embedded '-', '/', or '.' separators.  It could\n\t\t\t * also be a timezone name containing embedded '/', '+', '-', '_',\n\t\t\t * or ':' (but '_' or ':' can't be the first punctuation). If the\n\t\t\t * next character is a digit or '+', we need to check whether what\n\t\t\t * we have so far is a recognized non-timezone keyword --- if so,\n\t\t\t * don't believe that this is the start of a timezone.\n\t\t\t */\n\t\t\tis_date = false;\n\t\t\tif (*cp == '-' || *cp == '/' || *cp == '.')\n\t\t\t\tis_date = true;\n\t\t\telse if (*cp == '+' || isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\t*bufp = '\\0';\t/* null-terminate current field value */\n\t\t\t\t/* we need search only the core token table, not TZ names */\n\t\t\t\tif (datebsearch(field[nf], datetktbl, szdatetktbl) == NULL)\n\t\t\t\t\tis_date = true;\n\t\t\t}\n\t\t\tif (is_date)\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_DATE;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\t} while (*cp == '+' || *cp == '-' ||\n\t\t\t\t\t\t *cp == '/' || *cp == '_' ||\n\t\t\t\t\t\t *cp == '.' || *cp == ':' ||\n\t\t\t\t\t\t isalnum((unsigned char) *cp));\n\t\t\t}\n\t\t}\n\t\t/* sign? then special or numeric timezone */\n\t\telse if (*cp == '+' || *cp == '-')\n\t\t{\n\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t/* soak up leading whitespace */\n\t\t\twhile (isspace((unsigned char) *cp))\n\t\t\t\tcp++;\n\t\t\t/* numeric timezone? */\n\t\t\t/* note that \"DTK_TZ\" could also be a signed float or yyyy-mm */\n\t\t\tif (isdigit((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_TZ;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t\twhile (isdigit((unsigned char) *cp) ||\n\t\t\t\t\t   *cp == ':' || *cp == '.' || *cp == '-')\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, *cp++);\n\t\t\t}\n\t\t\t/* special? */\n\t\t\telse if (isalpha((unsigned char) *cp))\n\t\t\t{\n\t\t\t\tftype[nf] = DTK_SPECIAL;\n\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t\twhile (isalpha((unsigned char) *cp))\n\t\t\t\t\tAPPEND_CHAR(bufp, bufend, pg_tolower((unsigned char) *cp++));\n\t\t\t}\n\t\t\t/* otherwise something wrong... */\n\t\t\telse\n\t\t\t\treturn DTERR_BAD_FORMAT;\n\t\t}\n\t\t/* ignore other punctuation but use as delimiter */\n\t\telse if (ispunct((unsigned char) *cp))\n\t\t{\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\t/* otherwise, something is not right... */\n\t\telse\n\t\t\treturn DTERR_BAD_FORMAT;\n\n\t\t/* force in a delimiter after each field */\n\t\t*bufp++ = '\\0';\n\t\tnf++;\n\t}\n\n\t*numfields = nf;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic AbsoluteTime tm2abstime(struct pg_tm *tm, int tz);\nstatic void reltime2tm(RelativeTime time, struct pg_tm *tm);\n\nDatum\nabstimein(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tAbsoluteTime result;\n\tfsec_t\t\tfsec;\n\tint\t\t\ttz = 0;\n\tstruct pg_tm date,\n\t\t\t   *tm = &date;\n\tint\t\t\tdterr;\n\tchar\t   *field[MAXDATEFIELDS];\n\tchar\t\tworkbuf[MAXDATELEN + 1];\n\tint\t\t\tdtype;\n\tint\t\t\tnf,\n\t\t\t\tftype[MAXDATEFIELDS];\n\n\tdterr = ParseDateTime(str, workbuf, sizeof(workbuf),\n\t\t\t\t\t\t  field, ftype, MAXDATEFIELDS, &nf);\n\tif (dterr == 0)\n\t\tdterr = DecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, &tz);\n\tif (dterr != 0)\n\t\tDateTimeParseError(dterr, str, \"abstime\");\n\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tresult = tm2abstime(tm, tz);\n\t\t\tbreak;\n\n\t\tcase DTK_EPOCH:\n\n\t\t\t/*\n\t\t\t * Don't bother retaining this as a reserved value, but instead\n\t\t\t * just set to the actual epoch time (1970-01-01)\n\t\t\t */\n\t\t\tresult = 0;\n\t\t\tbreak;\n\n\t\tcase DTK_LATE:\n\t\t\tresult = NOEND_ABSTIME;\n\t\t\tbreak;\n\n\t\tcase DTK_EARLY:\n\t\t\tresult = NOSTART_ABSTIME;\n\t\t\tbreak;\n\n\t\tcase DTK_INVALID:\n\t\t\tresult = INVALID_ABSTIME;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unexpected dtype %d while parsing abstime \\\"%s\\\"\",\n\t\t\t\t dtype, str);\n\t\t\tresult = INVALID_ABSTIME;\n\t\t\tbreak;\n\t};\n\n\tPG_RETURN_ABSOLUTETIME(result);\n}"
  },
  {
    "function_name": "tm2abstime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "153-192",
    "snippet": "static AbsoluteTime\ntm2abstime(struct pg_tm *tm, int tz)\n{\n\tint\t\t\tday;\n\tAbsoluteTime sec;\n\n\t/* validate, before going out of range on some members */\n\tif (tm->tm_year < 1901 || tm->tm_year > 2038 ||\n\t\ttm->tm_mon < 1 || tm->tm_mon > MONTHS_PER_YEAR ||\n\t\ttm->tm_mday < 1 || tm->tm_mday > 31 ||\n\t\ttm->tm_hour < 0 ||\n\t\ttm->tm_hour > HOURS_PER_DAY ||\t/* test for > 24:00:00 */\n\t\t(tm->tm_hour == HOURS_PER_DAY && (tm->tm_min > 0 || tm->tm_sec > 0)) ||\n\t\ttm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE)\n\t\treturn INVALID_ABSTIME;\n\n\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - UNIX_EPOCH_JDATE;\n\n\t/* check for time out of range */\n\tif (day < MIN_DAYNUM || day > MAX_DAYNUM)\n\t\treturn INVALID_ABSTIME;\n\n\t/* convert to seconds */\n\tsec = tm->tm_sec + tz + (tm->tm_min + (day * HOURS_PER_DAY + tm->tm_hour) * MINS_PER_HOUR) * SECS_PER_MINUTE;\n\n\t/*\n\t * check for overflow.  We need a little slop here because the H/M/S plus\n\t * TZ offset could add up to more than 1 day.\n\t */\n\tif ((day >= MAX_DAYNUM - 10 && sec < 0) ||\n\t\t(day <= MIN_DAYNUM + 10 && sec > 0))\n\t\treturn INVALID_ABSTIME;\n\n\t/* check for reserved values (e.g. \"current\" on edge of usual range */\n\tif (!AbsoluteTimeIsReal(sec))\n\t\treturn INVALID_ABSTIME;\n\n\treturn sec;\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define MAX_DAYNUM 24854\t\t/* January 18, 2038 */",
      "#define MIN_DAYNUM (-24856)\t\t/* December 13, 1901 */"
    ],
    "globals_used": [
      "static AbsoluteTime tm2abstime(struct pg_tm *tm, int tz);",
      "static void reltime2tm(RelativeTime time, struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AbsoluteTimeIsReal",
          "args": [
            "sec"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date2j",
          "args": [
            "tm->tm_year",
            "tm->tm_mon",
            "tm->tm_mday"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "date2j",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "275-298",
          "snippet": "int\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\ndate2j(int y, int m, int d)\n{\n\tint\t\t\tjulian;\n\tint\t\t\tcentury;\n\n\tif (m > 2)\n\t{\n\t\tm += 1;\n\t\ty += 4800;\n\t}\n\telse\n\t{\n\t\tm += 13;\n\t\ty += 4799;\n\t}\n\n\tcentury = y / 100;\n\tjulian = y * 365 - 32167;\n\tjulian += y / 4 - century + century / 4;\n\tjulian += 7834 * m / 256 + d;\n\n\treturn julian;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\n#define MAX_DAYNUM 24854\t\t/* January 18, 2038 */\n#define MIN_DAYNUM (-24856)\t\t/* December 13, 1901 */\n\nstatic AbsoluteTime tm2abstime(struct pg_tm *tm, int tz);\nstatic void reltime2tm(RelativeTime time, struct pg_tm *tm);\n\nstatic AbsoluteTime\ntm2abstime(struct pg_tm *tm, int tz)\n{\n\tint\t\t\tday;\n\tAbsoluteTime sec;\n\n\t/* validate, before going out of range on some members */\n\tif (tm->tm_year < 1901 || tm->tm_year > 2038 ||\n\t\ttm->tm_mon < 1 || tm->tm_mon > MONTHS_PER_YEAR ||\n\t\ttm->tm_mday < 1 || tm->tm_mday > 31 ||\n\t\ttm->tm_hour < 0 ||\n\t\ttm->tm_hour > HOURS_PER_DAY ||\t/* test for > 24:00:00 */\n\t\t(tm->tm_hour == HOURS_PER_DAY && (tm->tm_min > 0 || tm->tm_sec > 0)) ||\n\t\ttm->tm_min < 0 || tm->tm_min > MINS_PER_HOUR - 1 ||\n\t\ttm->tm_sec < 0 || tm->tm_sec > SECS_PER_MINUTE)\n\t\treturn INVALID_ABSTIME;\n\n\tday = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - UNIX_EPOCH_JDATE;\n\n\t/* check for time out of range */\n\tif (day < MIN_DAYNUM || day > MAX_DAYNUM)\n\t\treturn INVALID_ABSTIME;\n\n\t/* convert to seconds */\n\tsec = tm->tm_sec + tz + (tm->tm_min + (day * HOURS_PER_DAY + tm->tm_hour) * MINS_PER_HOUR) * SECS_PER_MINUTE;\n\n\t/*\n\t * check for overflow.  We need a little slop here because the H/M/S plus\n\t * TZ offset could add up to more than 1 day.\n\t */\n\tif ((day >= MAX_DAYNUM - 10 && sec < 0) ||\n\t\t(day <= MIN_DAYNUM + 10 && sec > 0))\n\t\treturn INVALID_ABSTIME;\n\n\t/* check for reserved values (e.g. \"current\" on edge of usual range */\n\tif (!AbsoluteTimeIsReal(sec))\n\t\treturn INVALID_ABSTIME;\n\n\treturn sec;\n}"
  },
  {
    "function_name": "abstime2tm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "98-146",
    "snippet": "void\nabstime2tm(AbsoluteTime _time, int *tzp, struct pg_tm *tm, char **tzn)\n{\n\tpg_time_t\ttime = (pg_time_t) _time;\n\tstruct pg_tm *tx;\n\n\tif (tzp != NULL)\n\t\ttx = pg_localtime(&time, session_timezone);\n\telse\n\t\ttx = pg_gmtime(&time);\n\n\tif (tx == NULL)\n\t\telog(ERROR, \"could not convert abstime to timestamp: %m\");\n\n\ttm->tm_year = tx->tm_year + 1900;\n\ttm->tm_mon = tx->tm_mon + 1;\n\ttm->tm_mday = tx->tm_mday;\n\ttm->tm_hour = tx->tm_hour;\n\ttm->tm_min = tx->tm_min;\n\ttm->tm_sec = tx->tm_sec;\n\ttm->tm_isdst = tx->tm_isdst;\n\n\ttm->tm_gmtoff = tx->tm_gmtoff;\n\ttm->tm_zone = tx->tm_zone;\n\n\tif (tzp != NULL)\n\t{\n\t\t*tzp = -tm->tm_gmtoff;\t/* tm_gmtoff is Sun/DEC-ism */\n\n\t\t/*\n\t\t * XXX FreeBSD man pages indicate that this should work - tgl 97/04/23\n\t\t */\n\t\tif (tzn != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy no more than MAXTZLEN bytes of timezone to tzn, in case it\n\t\t\t * contains an error message, which doesn't fit in the buffer\n\t\t\t */\n\t\t\tStrNCpy(*tzn, tm->tm_zone, MAXTZLEN + 1);\n\t\t\tif (strlen(tm->tm_zone) > MAXTZLEN)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"invalid time zone name: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttm->tm_zone)));\n\t\t}\n\t}\n\telse\n\t\ttm->tm_isdst = -1;\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void reltime2tm(RelativeTime time, struct pg_tm *tm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "WARNING",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"invalid time zone name: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttm->tm_zone))"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid time zone name: \\\"%s\\\"\"",
            "tm->tm_zone"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tm->tm_zone"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "StrNCpy",
          "args": [
            "*tzn",
            "tm->tm_zone",
            "MAXTZLEN + 1"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"could not convert abstime to timestamp: %m\""
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_gmtime",
          "args": [
            "&time"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_localtime",
          "args": [
            "&time",
            "session_timezone"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void reltime2tm(RelativeTime time, struct pg_tm *tm);\n\nvoid\nabstime2tm(AbsoluteTime _time, int *tzp, struct pg_tm *tm, char **tzn)\n{\n\tpg_time_t\ttime = (pg_time_t) _time;\n\tstruct pg_tm *tx;\n\n\tif (tzp != NULL)\n\t\ttx = pg_localtime(&time, session_timezone);\n\telse\n\t\ttx = pg_gmtime(&time);\n\n\tif (tx == NULL)\n\t\telog(ERROR, \"could not convert abstime to timestamp: %m\");\n\n\ttm->tm_year = tx->tm_year + 1900;\n\ttm->tm_mon = tx->tm_mon + 1;\n\ttm->tm_mday = tx->tm_mday;\n\ttm->tm_hour = tx->tm_hour;\n\ttm->tm_min = tx->tm_min;\n\ttm->tm_sec = tx->tm_sec;\n\ttm->tm_isdst = tx->tm_isdst;\n\n\ttm->tm_gmtoff = tx->tm_gmtoff;\n\ttm->tm_zone = tx->tm_zone;\n\n\tif (tzp != NULL)\n\t{\n\t\t*tzp = -tm->tm_gmtoff;\t/* tm_gmtoff is Sun/DEC-ism */\n\n\t\t/*\n\t\t * XXX FreeBSD man pages indicate that this should work - tgl 97/04/23\n\t\t */\n\t\tif (tzn != NULL)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy no more than MAXTZLEN bytes of timezone to tzn, in case it\n\t\t\t * contains an error message, which doesn't fit in the buffer\n\t\t\t */\n\t\t\tStrNCpy(*tzn, tm->tm_zone, MAXTZLEN + 1);\n\t\t\tif (strlen(tm->tm_zone) > MAXTZLEN)\n\t\t\t\tereport(WARNING,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"invalid time zone name: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\ttm->tm_zone)));\n\t\t}\n\t}\n\telse\n\t\ttm->tm_isdst = -1;\n}"
  },
  {
    "function_name": "GetCurrentAbsoluteTime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
    "lines": "88-95",
    "snippet": "AbsoluteTime\nGetCurrentAbsoluteTime(void)\n{\n\ttime_t\t\tnow;\n\n\tnow = time(NULL);\n\treturn (AbsoluteTime) now;\n}",
    "includes": [
      "#include \"utils/nabstime.h\"",
      "#include \"utils/datetime.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include <sys/time.h>",
      "#include <time.h>",
      "#include <math.h>",
      "#include <limits.h>",
      "#include <float.h>",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "timeofday",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/nabstime.c",
          "lines": "1559-1574",
          "snippet": "Datum\ntimeofday(PG_FUNCTION_ARGS)\n{\n\tstruct timeval tp;\n\tchar\t\ttempl[128];\n\tchar\t\tbuf[128];\n\tpg_time_t\ttt;\n\n\tgettimeofday(&tp, NULL);\n\ttt = (pg_time_t) tp.tv_sec;\n\tpg_strftime(templ, sizeof(templ), \"%a %b %d %H:%M:%S.%%06d %Y %Z\",\n\t\t\t\tpg_localtime(&tt, session_timezone));\n\tsnprintf(buf, sizeof(buf), templ, tp.tv_usec);\n\n\tPG_RETURN_TEXT_P(cstring_to_text(buf));\n}",
          "includes": [
            "#include \"utils/nabstime.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntimeofday(PG_FUNCTION_ARGS)\n{\n\tstruct timeval tp;\n\tchar\t\ttempl[128];\n\tchar\t\tbuf[128];\n\tpg_time_t\ttt;\n\n\tgettimeofday(&tp, NULL);\n\ttt = (pg_time_t) tp.tv_sec;\n\tpg_strftime(templ, sizeof(templ), \"%a %b %d %H:%M:%S.%%06d %Y %Z\",\n\t\t\t\tpg_localtime(&tt, session_timezone));\n\tsnprintf(buf, sizeof(buf), templ, tp.tv_usec);\n\n\tPG_RETURN_TEXT_P(cstring_to_text(buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/nabstime.h\"\n#include \"utils/datetime.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <sys/time.h>\n#include <time.h>\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nAbsoluteTime\nGetCurrentAbsoluteTime(void)\n{\n\ttime_t\t\tnow;\n\n\tnow = time(NULL);\n\treturn (AbsoluteTime) now;\n}"
  }
]