[
  {
    "function_name": "FreePagePushSpanLeader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "1870-1886",
    "snippet": "static void\nFreePagePushSpanLeader(FreePageManager *fpm, Size first_page, Size npages)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tf = Min(npages, FPM_NUM_FREELISTS) - 1;\n\tFreePageSpanLeader *head = relptr_access(base, fpm->freelist[f]);\n\tFreePageSpanLeader *span;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, first_page);\n\tspan->magic = FREE_PAGE_SPAN_LEADER_MAGIC;\n\tspan->npages = npages;\n\trelptr_store(base, span->next, head);\n\trelptr_store(base, span->prev, (FreePageSpanLeader *) NULL);\n\tif (head != NULL)\n\t\trelptr_store(base, head->prev, span);\n\trelptr_store(base, fpm->freelist[f], span);\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0"
    ],
    "globals_used": [
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
      "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
      "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
      "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
      "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "fpm->freelist[f]",
            "span"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "head->prev",
            "span"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "span->prev",
            "(FreePageSpanLeader *) NULL"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "span->next",
            "head"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_page_to_pointer",
          "args": [
            "base",
            "first_page"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "fpm->freelist[f]"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "npages",
            "FPM_NUM_FREELISTS"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_segment_base",
          "args": [
            "fpm"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePagePushSpanLeader(FreePageManager *fpm, Size first_page, Size npages)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tf = Min(npages, FPM_NUM_FREELISTS) - 1;\n\tFreePageSpanLeader *head = relptr_access(base, fpm->freelist[f]);\n\tFreePageSpanLeader *span;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, first_page);\n\tspan->magic = FREE_PAGE_SPAN_LEADER_MAGIC;\n\tspan->npages = npages;\n\trelptr_store(base, span->next, head);\n\trelptr_store(base, span->prev, (FreePageSpanLeader *) NULL);\n\tif (head != NULL)\n\t\trelptr_store(base, head->prev, span);\n\trelptr_store(base, fpm->freelist[f], span);\n}"
  },
  {
    "function_name": "FreePagePopSpanLeader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "1842-1865",
    "snippet": "static void\nFreePagePopSpanLeader(FreePageManager *fpm, Size pageno)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *span;\n\tFreePageSpanLeader *next;\n\tFreePageSpanLeader *prev;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, pageno);\n\n\tnext = relptr_access(base, span->next);\n\tprev = relptr_access(base, span->prev);\n\tif (next != NULL)\n\t\trelptr_copy(next->prev, span->prev);\n\tif (prev != NULL)\n\t\trelptr_copy(prev->next, span->next);\n\telse\n\t{\n\t\tSize\t\tf = Min(span->npages, FPM_NUM_FREELISTS) - 1;\n\n\t\tAssert(fpm->freelist[f].relptr_off == pageno * FPM_PAGE_SIZE);\n\t\trelptr_copy(fpm->freelist[f], span->next);\n\t}\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
      "static void FreePageBtreeRecycle(FreePageManager *fpm, Size pageno);",
      "static void FreePagePopSpanLeader(FreePageManager *fpm, Size pageno);",
      "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "relptr_copy",
          "args": [
            "fpm->freelist[f]",
            "span->next"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "fpm->freelist[f].relptr_off == pageno * FPM_PAGE_SIZE"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "span->npages",
            "FPM_NUM_FREELISTS"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_copy",
          "args": [
            "prev->next",
            "span->next"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_copy",
          "args": [
            "next->prev",
            "span->prev"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "span->prev"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "span->next"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_page_to_pointer",
          "args": [
            "base",
            "pageno"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_segment_base",
          "args": [
            "fpm"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRecycle(FreePageManager *fpm, Size pageno);\nstatic void FreePagePopSpanLeader(FreePageManager *fpm, Size pageno);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePagePopSpanLeader(FreePageManager *fpm, Size pageno)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *span;\n\tFreePageSpanLeader *next;\n\tFreePageSpanLeader *prev;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, pageno);\n\n\tnext = relptr_access(base, span->next);\n\tprev = relptr_access(base, span->prev);\n\tif (next != NULL)\n\t\trelptr_copy(next->prev, span->prev);\n\tif (prev != NULL)\n\t\trelptr_copy(prev->next, span->next);\n\telse\n\t{\n\t\tSize\t\tf = Min(span->npages, FPM_NUM_FREELISTS) - 1;\n\n\t\tAssert(fpm->freelist[f].relptr_off == pageno * FPM_PAGE_SIZE);\n\t\trelptr_copy(fpm->freelist[f], span->next);\n\t}\n}"
  },
  {
    "function_name": "FreePageManagerPutInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "1475-1836",
    "snippet": "static Size\nFreePageManagerPutInternal(FreePageManager *fpm, Size first_page, Size npages,\n\t\t\t\t\t\t   bool soft)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtreeSearchResult result;\n\tFreePageBtreeLeafKey *prevkey = NULL;\n\tFreePageBtreeLeafKey *nextkey = NULL;\n\tFreePageBtree *np;\n\tSize\t\tnindex;\n\n\tAssert(npages > 0);\n\n\t/* We can store a single free span without initializing the btree. */\n\tif (fpm->btree_depth == 0)\n\t{\n\t\tif (fpm->singleton_npages == 0)\n\t\t{\n\t\t\t/* Don't have a span yet; store this one. */\n\t\t\tfpm->singleton_first_page = first_page;\n\t\t\tfpm->singleton_npages = npages;\n\t\t\tFreePagePushSpanLeader(fpm, first_page, npages);\n\t\t\treturn fpm->singleton_npages;\n\t\t}\n\t\telse if (fpm->singleton_first_page + fpm->singleton_npages ==\n\t\t\t\t first_page)\n\t\t{\n\t\t\t/* New span immediately follows sole existing span. */\n\t\t\tfpm->singleton_npages += npages;\n\t\t\tFreePagePopSpanLeader(fpm, fpm->singleton_first_page);\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t\t\treturn fpm->singleton_npages;\n\t\t}\n\t\telse if (first_page + npages == fpm->singleton_first_page)\n\t\t{\n\t\t\t/* New span immediately precedes sole existing span. */\n\t\t\tFreePagePopSpanLeader(fpm, fpm->singleton_first_page);\n\t\t\tfpm->singleton_first_page = first_page;\n\t\t\tfpm->singleton_npages += npages;\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t\t\treturn fpm->singleton_npages;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Not contiguous; we need to initialize the btree. */\n\t\t\tSize\t\troot_page;\n\t\t\tFreePageBtree *root;\n\n\t\t\tif (!relptr_is_null(fpm->btree_recycle))\n\t\t\t\troot = FreePageBtreeGetRecycled(fpm);\n\t\t\telse if (soft)\n\t\t\t\treturn 0;\t\t/* Should not allocate if soft. */\n\t\t\telse if (FreePageManagerGetInternal(fpm, 1, &root_page))\n\t\t\t\troot = (FreePageBtree *) fpm_page_to_pointer(base, root_page);\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* We'd better be able to get a page from the existing range. */\n\t\t\t\telog(FATAL, \"free page manager btree is corrupt\");\n\t\t\t}\n\n\t\t\t/* Create the btree and move the preexisting range into it. */\n\t\t\troot->hdr.magic = FREE_PAGE_LEAF_MAGIC;\n\t\t\troot->hdr.nused = 1;\n\t\t\trelptr_store(base, root->hdr.parent, (FreePageBtree *) NULL);\n\t\t\troot->u.leaf_key[0].first_page = fpm->singleton_first_page;\n\t\t\troot->u.leaf_key[0].npages = fpm->singleton_npages;\n\t\t\trelptr_store(base, fpm->btree_root, root);\n\t\t\tfpm->singleton_first_page = 0;\n\t\t\tfpm->singleton_npages = 0;\n\t\t\tfpm->btree_depth = 1;\n\n\t\t\t/*\n\t\t\t * Corner case: it may be that the btree root took the very last\n\t\t\t * free page.  In that case, the sole btree entry covers a zero\n\t\t\t * page run, which is invalid.  Overwrite it with the entry we're\n\t\t\t * trying to insert and get out.\n\t\t\t */\n\t\t\tif (root->u.leaf_key[0].npages == 0)\n\t\t\t{\n\t\t\t\troot->u.leaf_key[0].first_page = first_page;\n\t\t\t\troot->u.leaf_key[0].npages = npages;\n\t\t\t\tFreePagePushSpanLeader(fpm, first_page, npages);\n\t\t\t\treturn npages;\n\t\t\t}\n\n\t\t\t/* Fall through to insert the new key. */\n\t\t}\n\t}\n\n\t/* Search the btree. */\n\tFreePageBtreeSearch(fpm, first_page, &result);\n\tAssert(!result.found);\n\tif (result.index > 0)\n\t\tprevkey = &result.page->u.leaf_key[result.index - 1];\n\tif (result.index < result.page->hdr.nused)\n\t{\n\t\tnp = result.page;\n\t\tnindex = result.index;\n\t\tnextkey = &result.page->u.leaf_key[result.index];\n\t}\n\telse\n\t{\n\t\tnp = FreePageBtreeFindRightSibling(base, result.page);\n\t\tnindex = 0;\n\t\tif (np != NULL)\n\t\t\tnextkey = &np->u.leaf_key[0];\n\t}\n\n\t/* Consolidate with the previous entry if possible. */\n\tif (prevkey != NULL && prevkey->first_page + prevkey->npages >= first_page)\n\t{\n\t\tbool\t\tremove_next = false;\n\t\tSize\t\tresult;\n\n\t\tAssert(prevkey->first_page + prevkey->npages == first_page);\n\t\tprevkey->npages = (first_page - prevkey->first_page) + npages;\n\n\t\t/* Check whether we can *also* consolidate with the following entry. */\n\t\tif (nextkey != NULL &&\n\t\t\tprevkey->first_page + prevkey->npages >= nextkey->first_page)\n\t\t{\n\t\t\tAssert(prevkey->first_page + prevkey->npages ==\n\t\t\t\t   nextkey->first_page);\n\t\t\tprevkey->npages = (nextkey->first_page - prevkey->first_page)\n\t\t\t\t+ nextkey->npages;\n\t\t\tFreePagePopSpanLeader(fpm, nextkey->first_page);\n\t\t\tremove_next = true;\n\t\t}\n\n\t\t/* Put the span on the correct freelist and save size. */\n\t\tFreePagePopSpanLeader(fpm, prevkey->first_page);\n\t\tFreePagePushSpanLeader(fpm, prevkey->first_page, prevkey->npages);\n\t\tresult = prevkey->npages;\n\n\t\t/*\n\t\t * If we consolidated with both the preceding and following entries,\n\t\t * we must remove the following entry.  We do this last, because\n\t\t * removing an element from the btree may invalidate pointers we hold\n\t\t * into the current data structure.\n\t\t *\n\t\t * NB: The btree is technically in an invalid state a this point\n\t\t * because we've already updated prevkey to cover the same key space\n\t\t * as nextkey.  FreePageBtreeRemove() shouldn't notice that, though.\n\t\t */\n\t\tif (remove_next)\n\t\t\tFreePageBtreeRemove(fpm, np, nindex);\n\n\t\treturn result;\n\t}\n\n\t/* Consolidate with the next entry if possible. */\n\tif (nextkey != NULL && first_page + npages >= nextkey->first_page)\n\t{\n\t\tSize\t\tnewpages;\n\n\t\t/* Compute new size for span. */\n\t\tAssert(first_page + npages == nextkey->first_page);\n\t\tnewpages = (nextkey->first_page - first_page) + nextkey->npages;\n\n\t\t/* Put span on correct free list. */\n\t\tFreePagePopSpanLeader(fpm, nextkey->first_page);\n\t\tFreePagePushSpanLeader(fpm, first_page, newpages);\n\n\t\t/* Update key in place. */\n\t\tnextkey->first_page = first_page;\n\t\tnextkey->npages = newpages;\n\n\t\t/* If reducing first key on page, ancestors might need adjustment. */\n\t\tif (nindex == 0)\n\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, np);\n\n\t\treturn nextkey->npages;\n\t}\n\n\t/* Split leaf page and as many of its ancestors as necessary. */\n\tif (result.split_pages > 0)\n\t{\n\t\t/*\n\t\t * NB: We could consider various coping strategies here to avoid a\n\t\t * split; most obviously, if np != result.page, we could target that\n\t\t * page instead.   More complicated shuffling strategies could be\n\t\t * possible as well; basically, unless every single leaf page is 100%\n\t\t * full, we can jam this key in there if we try hard enough.  It's\n\t\t * unlikely that trying that hard is worthwhile, but it's possible we\n\t\t * might need to make more than no effort.  For now, we just do the\n\t\t * easy thing, which is nothing.\n\t\t */\n\n\t\t/* If this is a soft insert, it's time to give up. */\n\t\tif (soft)\n\t\t\treturn 0;\n\n\t\t/* Check whether we need to allocate more btree pages to split. */\n\t\tif (result.split_pages > fpm->btree_recycle_count)\n\t\t{\n\t\t\tSize\t\tpages_needed;\n\t\t\tSize\t\trecycle_page;\n\t\t\tSize\t\ti;\n\n\t\t\t/*\n\t\t\t * Allocate the required number of pages and split each one in\n\t\t\t * turn.  This should never fail, because if we've got enough\n\t\t\t * spans of free pages kicking around that we need additional\n\t\t\t * storage space just to remember them all, then we should\n\t\t\t * certainly have enough to expand the btree, which should only\n\t\t\t * ever use a tiny number of pages compared to the number under\n\t\t\t * management.  If it does, something's badly screwed up.\n\t\t\t */\n\t\t\tpages_needed = result.split_pages - fpm->btree_recycle_count;\n\t\t\tfor (i = 0; i < pages_needed; ++i)\n\t\t\t{\n\t\t\t\tif (!FreePageManagerGetInternal(fpm, 1, &recycle_page))\n\t\t\t\t\telog(FATAL, \"free page manager btree is corrupt\");\n\t\t\t\tFreePageBtreeRecycle(fpm, recycle_page);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The act of allocating pages to recycle may have invalidated the\n\t\t\t * results of our previous btree reserch, so repeat it. (We could\n\t\t\t * recheck whether any of our split-avoidance strategies that were\n\t\t\t * not viable before now are, but it hardly seems worthwhile, so\n\t\t\t * we don't bother. Consolidation can't be possible now if it\n\t\t\t * wasn't previously.)\n\t\t\t */\n\t\t\tFreePageBtreeSearch(fpm, first_page, &result);\n\n\t\t\t/*\n\t\t\t * The act of allocating pages for use in constructing our btree\n\t\t\t * should never cause any page to become more full, so the new\n\t\t\t * split depth should be no greater than the old one, and perhaps\n\t\t\t * less if we fortuitously allocated a chunk that freed up a slot\n\t\t\t * on the page we need to update.\n\t\t\t */\n\t\t\tAssert(result.split_pages <= fpm->btree_recycle_count);\n\t\t}\n\n\t\t/* If we still need to perform a split, do it. */\n\t\tif (result.split_pages > 0)\n\t\t{\n\t\t\tFreePageBtree *split_target = result.page;\n\t\t\tFreePageBtree *child = NULL;\n\t\t\tSize\t\tkey = first_page;\n\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tFreePageBtree *newsibling;\n\t\t\t\tFreePageBtree *parent;\n\n\t\t\t\t/* Identify parent page, which must receive downlink. */\n\t\t\t\tparent = relptr_access(base, split_target->hdr.parent);\n\n\t\t\t\t/* Split the page - downlink not added yet. */\n\t\t\t\tnewsibling = FreePageBtreeSplitPage(fpm, split_target);\n\n\t\t\t\t/*\n\t\t\t\t * At this point in the loop, we're always carrying a pending\n\t\t\t\t * insertion.  On the first pass, it's the actual key we're\n\t\t\t\t * trying to insert; on subsequent passes, it's the downlink\n\t\t\t\t * that needs to be added as a result of the split performed\n\t\t\t\t * during the previous loop iteration.  Since we've just split\n\t\t\t\t * the page, there's definitely room on one of the two\n\t\t\t\t * resulting pages.\n\t\t\t\t */\n\t\t\t\tif (child == NULL)\n\t\t\t\t{\n\t\t\t\t\tSize\t\tindex;\n\t\t\t\t\tFreePageBtree *insert_into;\n\n\t\t\t\t\tinsert_into = key < newsibling->u.leaf_key[0].first_page ?\n\t\t\t\t\t\tsplit_target : newsibling;\n\t\t\t\t\tindex = FreePageBtreeSearchLeaf(insert_into, key);\n\t\t\t\t\tFreePageBtreeInsertLeaf(insert_into, index, key, npages);\n\t\t\t\t\tif (index == 0 && insert_into == split_target)\n\t\t\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, split_target);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSize\t\tindex;\n\t\t\t\t\tFreePageBtree *insert_into;\n\n\t\t\t\t\tinsert_into =\n\t\t\t\t\t\tkey < newsibling->u.internal_key[0].first_page ?\n\t\t\t\t\t\tsplit_target : newsibling;\n\t\t\t\t\tindex = FreePageBtreeSearchInternal(insert_into, key);\n\t\t\t\t\tFreePageBtreeInsertInternal(base, insert_into, index,\n\t\t\t\t\t\t\t\t\t\t\t\tkey, child);\n\t\t\t\t\trelptr_store(base, child->hdr.parent, insert_into);\n\t\t\t\t\tif (index == 0 && insert_into == split_target)\n\t\t\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, split_target);\n\t\t\t\t}\n\n\t\t\t\t/* If the page we just split has no parent, split the root. */\n\t\t\t\tif (parent == NULL)\n\t\t\t\t{\n\t\t\t\t\tFreePageBtree *newroot;\n\n\t\t\t\t\tnewroot = FreePageBtreeGetRecycled(fpm);\n\t\t\t\t\tnewroot->hdr.magic = FREE_PAGE_INTERNAL_MAGIC;\n\t\t\t\t\tnewroot->hdr.nused = 2;\n\t\t\t\t\trelptr_store(base, newroot->hdr.parent,\n\t\t\t\t\t\t\t\t (FreePageBtree *) NULL);\n\t\t\t\t\tnewroot->u.internal_key[0].first_page =\n\t\t\t\t\t\tFreePageBtreeFirstKey(split_target);\n\t\t\t\t\trelptr_store(base, newroot->u.internal_key[0].child,\n\t\t\t\t\t\t\t\t split_target);\n\t\t\t\t\trelptr_store(base, split_target->hdr.parent, newroot);\n\t\t\t\t\tnewroot->u.internal_key[1].first_page =\n\t\t\t\t\t\tFreePageBtreeFirstKey(newsibling);\n\t\t\t\t\trelptr_store(base, newroot->u.internal_key[1].child,\n\t\t\t\t\t\t\t\t newsibling);\n\t\t\t\t\trelptr_store(base, newsibling->hdr.parent, newroot);\n\t\t\t\t\trelptr_store(base, fpm->btree_root, newroot);\n\t\t\t\t\tfpm->btree_depth++;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* If the parent page isn't full, insert the downlink. */\n\t\t\t\tkey = newsibling->u.internal_key[0].first_page;\n\t\t\t\tif (parent->hdr.nused < FPM_ITEMS_PER_INTERNAL_PAGE)\n\t\t\t\t{\n\t\t\t\t\tSize\t\tindex;\n\n\t\t\t\t\tindex = FreePageBtreeSearchInternal(parent, key);\n\t\t\t\t\tFreePageBtreeInsertInternal(base, parent, index,\n\t\t\t\t\t\t\t\t\t\t\t\tkey, newsibling);\n\t\t\t\t\trelptr_store(base, newsibling->hdr.parent, parent);\n\t\t\t\t\tif (index == 0)\n\t\t\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, parent);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* The parent also needs to be split, so loop around. */\n\t\t\t\tchild = newsibling;\n\t\t\t\tsplit_target = parent;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The loop above did the insert, so just need to update the free\n\t\t\t * list, and we're done.\n\t\t\t */\n\t\t\tFreePagePushSpanLeader(fpm, first_page, npages);\n\n\t\t\treturn npages;\n\t\t}\n\t}\n\n\t/* Physically add the key to the page. */\n\tAssert(result.page->hdr.nused < FPM_ITEMS_PER_LEAF_PAGE);\n\tFreePageBtreeInsertLeaf(result.page, result.index, first_page, npages);\n\n\t/* If new first key on page, ancestors might need adjustment. */\n\tif (result.index == 0)\n\t\tFreePageBtreeAdjustAncestorKeys(fpm, result.page);\n\n\t/* Put it on the free list. */\n\tFreePagePushSpanLeader(fpm, first_page, npages);\n\n\treturn npages;\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))",
      "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
      "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
      "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
    ],
    "globals_used": [
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
      "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
      "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
      "static void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);",
      "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
      "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
      "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
      "static Size FreePageManagerPutInternal(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t\t   Size npages, bool soft);",
      "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreePagePushSpanLeader",
          "args": [
            "fpm",
            "first_page",
            "npages"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "FreePagePushSpanLeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1870-1886",
          "snippet": "static void\nFreePagePushSpanLeader(FreePageManager *fpm, Size first_page, Size npages)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tf = Min(npages, FPM_NUM_FREELISTS) - 1;\n\tFreePageSpanLeader *head = relptr_access(base, fpm->freelist[f]);\n\tFreePageSpanLeader *span;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, first_page);\n\tspan->magic = FREE_PAGE_SPAN_LEADER_MAGIC;\n\tspan->npages = npages;\n\trelptr_store(base, span->next, head);\n\trelptr_store(base, span->prev, (FreePageSpanLeader *) NULL);\n\tif (head != NULL)\n\t\trelptr_store(base, head->prev, span);\n\trelptr_store(base, fpm->freelist[f], span);\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0"
          ],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePagePushSpanLeader(FreePageManager *fpm, Size first_page, Size npages)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tf = Min(npages, FPM_NUM_FREELISTS) - 1;\n\tFreePageSpanLeader *head = relptr_access(base, fpm->freelist[f]);\n\tFreePageSpanLeader *span;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, first_page);\n\tspan->magic = FREE_PAGE_SPAN_LEADER_MAGIC;\n\tspan->npages = npages;\n\trelptr_store(base, span->next, head);\n\trelptr_store(base, span->prev, (FreePageSpanLeader *) NULL);\n\tif (head != NULL)\n\t\trelptr_store(base, head->prev, span);\n\trelptr_store(base, fpm->freelist[f], span);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageBtreeAdjustAncestorKeys",
          "args": [
            "fpm",
            "result.page"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeAdjustAncestorKeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "500-573",
          "snippet": "static void\nFreePageBtreeAdjustAncestorKeys(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tfirst_page;\n\tFreePageBtree *parent;\n\tFreePageBtree *child;\n\n\t/* This might be either a leaf or an internal page. */\n\tAssert(btp->hdr.nused > 0);\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t{\n\t\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_LEAF_PAGE);\n\t\tfirst_page = btp->u.leaf_key[0].first_page;\n\t}\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\tfirst_page = btp->u.internal_key[0].first_page;\n\t}\n\tchild = btp;\n\n\t/* Loop until we find an ancestor that does not require adjustment. */\n\tfor (;;)\n\t{\n\t\tSize\t\ts;\n\n\t\tparent = relptr_access(base, child->hdr.parent);\n\t\tif (parent == NULL)\n\t\t\tbreak;\n\t\ts = FreePageBtreeSearchInternal(parent, first_page);\n\n\t\t/* Key is either at index s or index s-1; figure out which. */\n\t\tif (s >= parent->hdr.nused)\n\t\t{\n\t\t\tAssert(s == parent->hdr.nused);\n\t\t\t--s;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFreePageBtree *check;\n\n\t\t\tcheck = relptr_access(base, parent->u.internal_key[s].child);\n\t\t\tif (check != child)\n\t\t\t{\n\t\t\t\tAssert(s > 0);\n\t\t\t\t--s;\n\t\t\t}\n\t\t}\n\n#ifdef USE_ASSERT_CHECKING\n\t\t/* Debugging double-check. */\n\t\t{\n\t\t\tFreePageBtree *check;\n\n\t\t\tcheck = relptr_access(base, parent->u.internal_key[s].child);\n\t\t\tAssert(s < parent->hdr.nused);\n\t\t\tAssert(child == check);\n\t\t}\n#endif\n\n\t\t/* Update the parent key. */\n\t\tparent->u.internal_key[s].first_page = first_page;\n\n\t\t/*\n\t\t * If this is the first key in the parent, go up another level; else\n\t\t * done.\n\t\t */\n\t\tif (s > 0)\n\t\t\tbreak;\n\t\tchild = parent;\n\t}\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))",
            "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeAdjustAncestorKeys(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tfirst_page;\n\tFreePageBtree *parent;\n\tFreePageBtree *child;\n\n\t/* This might be either a leaf or an internal page. */\n\tAssert(btp->hdr.nused > 0);\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t{\n\t\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_LEAF_PAGE);\n\t\tfirst_page = btp->u.leaf_key[0].first_page;\n\t}\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\tfirst_page = btp->u.internal_key[0].first_page;\n\t}\n\tchild = btp;\n\n\t/* Loop until we find an ancestor that does not require adjustment. */\n\tfor (;;)\n\t{\n\t\tSize\t\ts;\n\n\t\tparent = relptr_access(base, child->hdr.parent);\n\t\tif (parent == NULL)\n\t\t\tbreak;\n\t\ts = FreePageBtreeSearchInternal(parent, first_page);\n\n\t\t/* Key is either at index s or index s-1; figure out which. */\n\t\tif (s >= parent->hdr.nused)\n\t\t{\n\t\t\tAssert(s == parent->hdr.nused);\n\t\t\t--s;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFreePageBtree *check;\n\n\t\t\tcheck = relptr_access(base, parent->u.internal_key[s].child);\n\t\t\tif (check != child)\n\t\t\t{\n\t\t\t\tAssert(s > 0);\n\t\t\t\t--s;\n\t\t\t}\n\t\t}\n\n#ifdef USE_ASSERT_CHECKING\n\t\t/* Debugging double-check. */\n\t\t{\n\t\t\tFreePageBtree *check;\n\n\t\t\tcheck = relptr_access(base, parent->u.internal_key[s].child);\n\t\t\tAssert(s < parent->hdr.nused);\n\t\t\tAssert(child == check);\n\t\t}\n#endif\n\n\t\t/* Update the parent key. */\n\t\tparent->u.internal_key[s].first_page = first_page;\n\n\t\t/*\n\t\t * If this is the first key in the parent, go up another level; else\n\t\t * done.\n\t\t */\n\t\tif (s > 0)\n\t\t\tbreak;\n\t\tchild = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageBtreeInsertLeaf",
          "args": [
            "result.page",
            "result.index",
            "first_page",
            "npages"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeInsertLeaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "916-928",
          "snippet": "static void\nFreePageBtreeInsertLeaf(FreePageBtree *btp, Size index, Size first_page,\n\t\t\t\t\t\tSize npages)\n{\n\tAssert(btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_LEAF_PAGE);\n\tAssert(index <= btp->hdr.nused);\n\tmemmove(&btp->u.leaf_key[index + 1], &btp->u.leaf_key[index],\n\t\t\tsizeof(FreePageBtreeLeafKey) * (btp->hdr.nused - index));\n\tbtp->u.leaf_key[index].first_page = first_page;\n\tbtp->u.leaf_key[index].npages = npages;\n\t++btp->hdr.nused;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))",
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\n\nstatic void\nFreePageBtreeInsertLeaf(FreePageBtree *btp, Size index, Size first_page,\n\t\t\t\t\t\tSize npages)\n{\n\tAssert(btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_LEAF_PAGE);\n\tAssert(index <= btp->hdr.nused);\n\tmemmove(&btp->u.leaf_key[index + 1], &btp->u.leaf_key[index],\n\t\t\tsizeof(FreePageBtreeLeafKey) * (btp->hdr.nused - index));\n\tbtp->u.leaf_key[index].first_page = first_page;\n\tbtp->u.leaf_key[index].npages = npages;\n\t++btp->hdr.nused;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "result.page->hdr.nused < FPM_ITEMS_PER_LEAF_PAGE"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "newsibling->hdr.parent",
            "parent"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeInsertInternal",
          "args": [
            "base",
            "parent",
            "index",
            "key",
            "newsibling"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeInsertInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "899-911",
          "snippet": "static void\nFreePageBtreeInsertInternal(char *base, FreePageBtree *btp, Size index,\n\t\t\t\t\t\t\tSize first_page, FreePageBtree *child)\n{\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\tAssert(index <= btp->hdr.nused);\n\tmemmove(&btp->u.internal_key[index + 1], &btp->u.internal_key[index],\n\t\t\tsizeof(FreePageBtreeInternalKey) * (btp->hdr.nused - index));\n\tbtp->u.internal_key[index].first_page = first_page;\n\trelptr_store(base, btp->u.internal_key[index].child, child);\n\t++btp->hdr.nused;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic void\nFreePageBtreeInsertInternal(char *base, FreePageBtree *btp, Size index,\n\t\t\t\t\t\t\tSize first_page, FreePageBtree *child)\n{\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\tAssert(index <= btp->hdr.nused);\n\tmemmove(&btp->u.internal_key[index + 1], &btp->u.internal_key[index],\n\t\t\tsizeof(FreePageBtreeInternalKey) * (btp->hdr.nused - index));\n\tbtp->u.internal_key[index].first_page = first_page;\n\trelptr_store(base, btp->u.internal_key[index].child, child);\n\t++btp->hdr.nused;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageBtreeSearchInternal",
          "args": [
            "parent",
            "key"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeSearchInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1139-1162",
          "snippet": "static Size\nFreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.internal_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic Size\nFreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.internal_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}"
        }
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "fpm->btree_root",
            "newroot"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "newsibling->hdr.parent",
            "newroot"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "newroot->u.internal_key[1].child",
            "newsibling"
          ],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeFirstKey",
          "args": [
            "newsibling"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeFirstKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "862-874",
          "snippet": "static Size\nFreePageBtreeFirstKey(FreePageBtree *btp)\n{\n\tAssert(btp->hdr.nused > 0);\n\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\treturn btp->u.leaf_key[0].first_page;\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\treturn btp->u.internal_key[0].first_page;\n\t}\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic Size\nFreePageBtreeFirstKey(FreePageBtree *btp)\n{\n\tAssert(btp->hdr.nused > 0);\n\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\treturn btp->u.leaf_key[0].first_page;\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\treturn btp->u.internal_key[0].first_page;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "split_target->hdr.parent",
            "newroot"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "newroot->u.internal_key[0].child",
            "split_target"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "newroot->hdr.parent",
            "(FreePageBtree *) NULL"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeGetRecycled",
          "args": [
            "fpm"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeGetRecycled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "879-894",
          "snippet": "static FreePageBtree *\nFreePageBtreeGetRecycled(FreePageManager *fpm)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *victim = relptr_access(base, fpm->btree_recycle);\n\tFreePageSpanLeader *newhead;\n\n\tAssert(victim != NULL);\n\tnewhead = relptr_access(base, victim->next);\n\tif (newhead != NULL)\n\t\trelptr_copy(newhead->prev, victim->prev);\n\trelptr_store(base, fpm->btree_recycle, newhead);\n\tAssert(fpm_pointer_is_page_aligned(base, victim));\n\tfpm->btree_recycle_count--;\n\treturn (FreePageBtree *) victim;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic FreePageBtree *\nFreePageBtreeGetRecycled(FreePageManager *fpm)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *victim = relptr_access(base, fpm->btree_recycle);\n\tFreePageSpanLeader *newhead;\n\n\tAssert(victim != NULL);\n\tnewhead = relptr_access(base, victim->next);\n\tif (newhead != NULL)\n\t\trelptr_copy(newhead->prev, victim->prev);\n\trelptr_store(base, fpm->btree_recycle, newhead);\n\tAssert(fpm_pointer_is_page_aligned(base, victim));\n\tfpm->btree_recycle_count--;\n\treturn (FreePageBtree *) victim;\n}"
        }
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "child->hdr.parent",
            "insert_into"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeSearchLeaf",
          "args": [
            "insert_into",
            "key"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeSearchLeaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1169-1192",
          "snippet": "static Size\nFreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_LEAF_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.leaf_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))",
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic Size\nFreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_LEAF_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.leaf_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageBtreeSplitPage",
          "args": [
            "fpm",
            "split_target"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeSplitPage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1200-1225",
          "snippet": "static FreePageBtree *\nFreePageBtreeSplitPage(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tFreePageBtree *newsibling;\n\n\tnewsibling = FreePageBtreeGetRecycled(fpm);\n\tnewsibling->hdr.magic = btp->hdr.magic;\n\tnewsibling->hdr.nused = btp->hdr.nused / 2;\n\trelptr_copy(newsibling->hdr.parent, btp->hdr.parent);\n\tbtp->hdr.nused -= newsibling->hdr.nused;\n\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\tmemcpy(&newsibling->u.leaf_key,\n\t\t\t   &btp->u.leaf_key[btp->hdr.nused],\n\t\t\t   sizeof(FreePageBtreeLeafKey) * newsibling->hdr.nused);\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tmemcpy(&newsibling->u.internal_key,\n\t\t\t   &btp->u.internal_key[btp->hdr.nused],\n\t\t\t   sizeof(FreePageBtreeInternalKey) * newsibling->hdr.nused);\n\t\tFreePageBtreeUpdateParentPointers(fpm_segment_base(fpm), newsibling);\n\t}\n\n\treturn newsibling;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic FreePageBtree *\nFreePageBtreeSplitPage(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tFreePageBtree *newsibling;\n\n\tnewsibling = FreePageBtreeGetRecycled(fpm);\n\tnewsibling->hdr.magic = btp->hdr.magic;\n\tnewsibling->hdr.nused = btp->hdr.nused / 2;\n\trelptr_copy(newsibling->hdr.parent, btp->hdr.parent);\n\tbtp->hdr.nused -= newsibling->hdr.nused;\n\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\tmemcpy(&newsibling->u.leaf_key,\n\t\t\t   &btp->u.leaf_key[btp->hdr.nused],\n\t\t\t   sizeof(FreePageBtreeLeafKey) * newsibling->hdr.nused);\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tmemcpy(&newsibling->u.internal_key,\n\t\t\t   &btp->u.internal_key[btp->hdr.nused],\n\t\t\t   sizeof(FreePageBtreeInternalKey) * newsibling->hdr.nused);\n\t\tFreePageBtreeUpdateParentPointers(fpm_segment_base(fpm), newsibling);\n\t}\n\n\treturn newsibling;\n}"
        }
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "split_target->hdr.parent"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "result.split_pages <= fpm->btree_recycle_count"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeSearch",
          "args": [
            "fpm",
            "first_page",
            "&result"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1063-1132",
          "snippet": "static void\nFreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtree *btp = relptr_access(base, fpm->btree_root);\n\tSize\t\tindex;\n\n\tresult->split_pages = 1;\n\n\t/* If the btree is empty, there's nothing to find. */\n\tif (btp == NULL)\n\t{\n\t\tresult->page = NULL;\n\t\tresult->found = false;\n\t\treturn;\n\t}\n\n\t/* Descend until we hit a leaf. */\n\twhile (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t{\n\t\tFreePageBtree *child;\n\t\tbool\t\tfound_exact;\n\n\t\tindex = FreePageBtreeSearchInternal(btp, first_page);\n\t\tfound_exact = index < btp->hdr.nused &&\n\t\t\tbtp->u.internal_key[index].first_page == first_page;\n\n\t\t/*\n\t\t * If we found an exact match we descend directly.  Otherwise, we\n\t\t * descend into the child to the left if possible so that we can find\n\t\t * the insertion point at that child's high end.\n\t\t */\n\t\tif (!found_exact && index > 0)\n\t\t\t--index;\n\n\t\t/* Track required split depth for leaf insert. */\n\t\tif (btp->hdr.nused >= FPM_ITEMS_PER_INTERNAL_PAGE)\n\t\t{\n\t\t\tAssert(btp->hdr.nused == FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\t\tresult->split_pages++;\n\t\t}\n\t\telse\n\t\t\tresult->split_pages = 0;\n\n\t\t/* Descend to appropriate child page. */\n\t\tAssert(index < btp->hdr.nused);\n\t\tchild = relptr_access(base, btp->u.internal_key[index].child);\n\t\tAssert(relptr_access(base, child->hdr.parent) == btp);\n\t\tbtp = child;\n\t}\n\n\t/* Track required split depth for leaf insert. */\n\tif (btp->hdr.nused >= FPM_ITEMS_PER_LEAF_PAGE)\n\t{\n\t\tAssert(btp->hdr.nused == FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\tresult->split_pages++;\n\t}\n\telse\n\t\tresult->split_pages = 0;\n\n\t/* Search leaf page. */\n\tindex = FreePageBtreeSearchLeaf(btp, first_page);\n\n\t/* Assemble results. */\n\tresult->page = btp;\n\tresult->index = index;\n\tresult->found = index < btp->hdr.nused &&\n\t\tfirst_page == btp->u.leaf_key[index].first_page;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))",
            "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtree *btp = relptr_access(base, fpm->btree_root);\n\tSize\t\tindex;\n\n\tresult->split_pages = 1;\n\n\t/* If the btree is empty, there's nothing to find. */\n\tif (btp == NULL)\n\t{\n\t\tresult->page = NULL;\n\t\tresult->found = false;\n\t\treturn;\n\t}\n\n\t/* Descend until we hit a leaf. */\n\twhile (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t{\n\t\tFreePageBtree *child;\n\t\tbool\t\tfound_exact;\n\n\t\tindex = FreePageBtreeSearchInternal(btp, first_page);\n\t\tfound_exact = index < btp->hdr.nused &&\n\t\t\tbtp->u.internal_key[index].first_page == first_page;\n\n\t\t/*\n\t\t * If we found an exact match we descend directly.  Otherwise, we\n\t\t * descend into the child to the left if possible so that we can find\n\t\t * the insertion point at that child's high end.\n\t\t */\n\t\tif (!found_exact && index > 0)\n\t\t\t--index;\n\n\t\t/* Track required split depth for leaf insert. */\n\t\tif (btp->hdr.nused >= FPM_ITEMS_PER_INTERNAL_PAGE)\n\t\t{\n\t\t\tAssert(btp->hdr.nused == FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\t\tresult->split_pages++;\n\t\t}\n\t\telse\n\t\t\tresult->split_pages = 0;\n\n\t\t/* Descend to appropriate child page. */\n\t\tAssert(index < btp->hdr.nused);\n\t\tchild = relptr_access(base, btp->u.internal_key[index].child);\n\t\tAssert(relptr_access(base, child->hdr.parent) == btp);\n\t\tbtp = child;\n\t}\n\n\t/* Track required split depth for leaf insert. */\n\tif (btp->hdr.nused >= FPM_ITEMS_PER_LEAF_PAGE)\n\t{\n\t\tAssert(btp->hdr.nused == FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\tresult->split_pages++;\n\t}\n\telse\n\t\tresult->split_pages = 0;\n\n\t/* Search leaf page. */\n\tindex = FreePageBtreeSearchLeaf(btp, first_page);\n\n\t/* Assemble results. */\n\tresult->page = btp;\n\tresult->index = index;\n\tresult->found = index < btp->hdr.nused &&\n\t\tfirst_page == btp->u.leaf_key[index].first_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageBtreeRecycle",
          "args": [
            "fpm",
            "recycle_page"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeRecycle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "933-949",
          "snippet": "static void\nFreePageBtreeRecycle(FreePageManager *fpm, Size pageno)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *head = relptr_access(base, fpm->btree_recycle);\n\tFreePageSpanLeader *span;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, pageno);\n\tspan->magic = FREE_PAGE_SPAN_LEADER_MAGIC;\n\tspan->npages = 1;\n\trelptr_store(base, span->next, head);\n\trelptr_store(base, span->prev, (FreePageSpanLeader *) NULL);\n\tif (head != NULL)\n\t\trelptr_store(base, head->prev, span);\n\trelptr_store(base, fpm->btree_recycle, span);\n\tfpm->btree_recycle_count++;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0"
          ],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePageBtreeRecycle(FreePageManager *fpm, Size pageno);",
            "static void FreePagePopSpanLeader(FreePageManager *fpm, Size pageno);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRecycle(FreePageManager *fpm, Size pageno);\nstatic void FreePagePopSpanLeader(FreePageManager *fpm, Size pageno);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeRecycle(FreePageManager *fpm, Size pageno)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *head = relptr_access(base, fpm->btree_recycle);\n\tFreePageSpanLeader *span;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, pageno);\n\tspan->magic = FREE_PAGE_SPAN_LEADER_MAGIC;\n\tspan->npages = 1;\n\trelptr_store(base, span->next, head);\n\trelptr_store(base, span->prev, (FreePageSpanLeader *) NULL);\n\tif (head != NULL)\n\t\trelptr_store(base, head->prev, span);\n\trelptr_store(base, fpm->btree_recycle, span);\n\tfpm->btree_recycle_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "FATAL",
            "\"free page manager btree is corrupt\""
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageManagerGetInternal",
          "args": [
            "fpm",
            "1",
            "&recycle_page"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageManagerGetInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1318-1464",
          "snippet": "static bool\nFreePageManagerGetInternal(FreePageManager *fpm, Size npages, Size *first_page)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *victim = NULL;\n\tFreePageSpanLeader *prev;\n\tFreePageSpanLeader *next;\n\tFreePageBtreeSearchResult result;\n\tSize\t\tvictim_page = 0;\t/* placate compiler */\n\tSize\t\tf;\n\n\t/*\n\t * Search for a free span.\n\t *\n\t * Right now, we use a simple best-fit policy here, but it's possible for\n\t * this to result in memory fragmentation if we're repeatedly asked to\n\t * allocate chunks just a little smaller than what we have available.\n\t * Hopefully, this is unlikely, because we expect most requests to be\n\t * single pages or superblock-sized chunks -- but no policy can be optimal\n\t * under all circumstances unless it has knowledge of future allocation\n\t * patterns.\n\t */\n\tfor (f = Min(npages, FPM_NUM_FREELISTS) - 1; f < FPM_NUM_FREELISTS; ++f)\n\t{\n\t\t/* Skip empty freelists. */\n\t\tif (relptr_is_null(fpm->freelist[f]))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All of the freelists except the last one contain only items of a\n\t\t * single size, so we just take the first one.  But the final free\n\t\t * list contains everything too big for any of the other lists, so we\n\t\t * need to search the list.\n\t\t */\n\t\tif (f < FPM_NUM_FREELISTS - 1)\n\t\t\tvictim = relptr_access(base, fpm->freelist[f]);\n\t\telse\n\t\t{\n\t\t\tFreePageSpanLeader *candidate;\n\n\t\t\tcandidate = relptr_access(base, fpm->freelist[f]);\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (candidate->npages >= npages && (victim == NULL ||\n\t\t\t\t\t\t\t\t\t\t\t\t\tvictim->npages > candidate->npages))\n\t\t\t\t{\n\t\t\t\t\tvictim = candidate;\n\t\t\t\t\tif (victim->npages == npages)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t\t} while (candidate != NULL);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* If we didn't find an allocatable span, return failure. */\n\tif (victim == NULL)\n\t\treturn false;\n\n\t/* Remove span from free list. */\n\tAssert(victim->magic == FREE_PAGE_SPAN_LEADER_MAGIC);\n\tprev = relptr_access(base, victim->prev);\n\tnext = relptr_access(base, victim->next);\n\tif (prev != NULL)\n\t\trelptr_copy(prev->next, victim->next);\n\telse\n\t\trelptr_copy(fpm->freelist[f], victim->next);\n\tif (next != NULL)\n\t\trelptr_copy(next->prev, victim->prev);\n\tvictim_page = fpm_pointer_to_page(base, victim);\n\n\t/* Decide whether we might be invalidating contiguous_pages. */\n\tif (f == FPM_NUM_FREELISTS - 1 &&\n\t\tvictim->npages == fpm->contiguous_pages)\n\t{\n\t\t/*\n\t\t * The victim span came from the oversized freelist, and had the same\n\t\t * size as the longest span.  There may or may not be another one of\n\t\t * the same size, so contiguous_pages must be recomputed just to be\n\t\t * safe.\n\t\t */\n\t\tfpm->contiguous_pages_dirty = true;\n\t}\n\telse if (f + 1 == fpm->contiguous_pages &&\n\t\t\t relptr_is_null(fpm->freelist[f]))\n\t{\n\t\t/*\n\t\t * The victim span came from a fixed sized freelist, and it was the\n\t\t * list for spans of the same size as the current longest span, and\n\t\t * the list is now empty after removing the victim.  So\n\t\t * contiguous_pages must be recomputed without a doubt.\n\t\t */\n\t\tfpm->contiguous_pages_dirty = true;\n\t}\n\n\t/*\n\t * If we haven't initialized the btree yet, the victim must be the single\n\t * span stored within the FreePageManager itself.  Otherwise, we need to\n\t * update the btree.\n\t */\n\tif (relptr_is_null(fpm->btree_root))\n\t{\n\t\tAssert(victim_page == fpm->singleton_first_page);\n\t\tAssert(victim->npages == fpm->singleton_npages);\n\t\tAssert(victim->npages >= npages);\n\t\tfpm->singleton_first_page += npages;\n\t\tfpm->singleton_npages -= npages;\n\t\tif (fpm->singleton_npages > 0)\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If the span we found is exactly the right size, remove it from the\n\t\t * btree completely.  Otherwise, adjust the btree entry to reflect the\n\t\t * still-unallocated portion of the span, and put that portion on the\n\t\t * appropriate free list.\n\t\t */\n\t\tFreePageBtreeSearch(fpm, victim_page, &result);\n\t\tAssert(result.found);\n\t\tif (victim->npages == npages)\n\t\t\tFreePageBtreeRemove(fpm, result.page, result.index);\n\t\telse\n\t\t{\n\t\t\tFreePageBtreeLeafKey *key;\n\n\t\t\t/* Adjust btree to reflect remaining pages. */\n\t\t\tAssert(victim->npages > npages);\n\t\t\tkey = &result.page->u.leaf_key[result.index];\n\t\t\tAssert(key->npages == victim->npages);\n\t\t\tkey->first_page += npages;\n\t\t\tkey->npages -= npages;\n\t\t\tif (result.index == 0)\n\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, result.page);\n\n\t\t\t/* Put the unallocated pages back on the appropriate free list. */\n\t\t\tFreePagePushSpanLeader(fpm, victim_page + npages,\n\t\t\t\t\t\t\t\t   victim->npages - npages);\n\t\t}\n\t}\n\n\t/* Return results to caller. */\n\t*first_page = fpm_pointer_to_page(base, victim);\n\treturn true;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0"
          ],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic bool\nFreePageManagerGetInternal(FreePageManager *fpm, Size npages, Size *first_page)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *victim = NULL;\n\tFreePageSpanLeader *prev;\n\tFreePageSpanLeader *next;\n\tFreePageBtreeSearchResult result;\n\tSize\t\tvictim_page = 0;\t/* placate compiler */\n\tSize\t\tf;\n\n\t/*\n\t * Search for a free span.\n\t *\n\t * Right now, we use a simple best-fit policy here, but it's possible for\n\t * this to result in memory fragmentation if we're repeatedly asked to\n\t * allocate chunks just a little smaller than what we have available.\n\t * Hopefully, this is unlikely, because we expect most requests to be\n\t * single pages or superblock-sized chunks -- but no policy can be optimal\n\t * under all circumstances unless it has knowledge of future allocation\n\t * patterns.\n\t */\n\tfor (f = Min(npages, FPM_NUM_FREELISTS) - 1; f < FPM_NUM_FREELISTS; ++f)\n\t{\n\t\t/* Skip empty freelists. */\n\t\tif (relptr_is_null(fpm->freelist[f]))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All of the freelists except the last one contain only items of a\n\t\t * single size, so we just take the first one.  But the final free\n\t\t * list contains everything too big for any of the other lists, so we\n\t\t * need to search the list.\n\t\t */\n\t\tif (f < FPM_NUM_FREELISTS - 1)\n\t\t\tvictim = relptr_access(base, fpm->freelist[f]);\n\t\telse\n\t\t{\n\t\t\tFreePageSpanLeader *candidate;\n\n\t\t\tcandidate = relptr_access(base, fpm->freelist[f]);\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (candidate->npages >= npages && (victim == NULL ||\n\t\t\t\t\t\t\t\t\t\t\t\t\tvictim->npages > candidate->npages))\n\t\t\t\t{\n\t\t\t\t\tvictim = candidate;\n\t\t\t\t\tif (victim->npages == npages)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t\t} while (candidate != NULL);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* If we didn't find an allocatable span, return failure. */\n\tif (victim == NULL)\n\t\treturn false;\n\n\t/* Remove span from free list. */\n\tAssert(victim->magic == FREE_PAGE_SPAN_LEADER_MAGIC);\n\tprev = relptr_access(base, victim->prev);\n\tnext = relptr_access(base, victim->next);\n\tif (prev != NULL)\n\t\trelptr_copy(prev->next, victim->next);\n\telse\n\t\trelptr_copy(fpm->freelist[f], victim->next);\n\tif (next != NULL)\n\t\trelptr_copy(next->prev, victim->prev);\n\tvictim_page = fpm_pointer_to_page(base, victim);\n\n\t/* Decide whether we might be invalidating contiguous_pages. */\n\tif (f == FPM_NUM_FREELISTS - 1 &&\n\t\tvictim->npages == fpm->contiguous_pages)\n\t{\n\t\t/*\n\t\t * The victim span came from the oversized freelist, and had the same\n\t\t * size as the longest span.  There may or may not be another one of\n\t\t * the same size, so contiguous_pages must be recomputed just to be\n\t\t * safe.\n\t\t */\n\t\tfpm->contiguous_pages_dirty = true;\n\t}\n\telse if (f + 1 == fpm->contiguous_pages &&\n\t\t\t relptr_is_null(fpm->freelist[f]))\n\t{\n\t\t/*\n\t\t * The victim span came from a fixed sized freelist, and it was the\n\t\t * list for spans of the same size as the current longest span, and\n\t\t * the list is now empty after removing the victim.  So\n\t\t * contiguous_pages must be recomputed without a doubt.\n\t\t */\n\t\tfpm->contiguous_pages_dirty = true;\n\t}\n\n\t/*\n\t * If we haven't initialized the btree yet, the victim must be the single\n\t * span stored within the FreePageManager itself.  Otherwise, we need to\n\t * update the btree.\n\t */\n\tif (relptr_is_null(fpm->btree_root))\n\t{\n\t\tAssert(victim_page == fpm->singleton_first_page);\n\t\tAssert(victim->npages == fpm->singleton_npages);\n\t\tAssert(victim->npages >= npages);\n\t\tfpm->singleton_first_page += npages;\n\t\tfpm->singleton_npages -= npages;\n\t\tif (fpm->singleton_npages > 0)\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If the span we found is exactly the right size, remove it from the\n\t\t * btree completely.  Otherwise, adjust the btree entry to reflect the\n\t\t * still-unallocated portion of the span, and put that portion on the\n\t\t * appropriate free list.\n\t\t */\n\t\tFreePageBtreeSearch(fpm, victim_page, &result);\n\t\tAssert(result.found);\n\t\tif (victim->npages == npages)\n\t\t\tFreePageBtreeRemove(fpm, result.page, result.index);\n\t\telse\n\t\t{\n\t\t\tFreePageBtreeLeafKey *key;\n\n\t\t\t/* Adjust btree to reflect remaining pages. */\n\t\t\tAssert(victim->npages > npages);\n\t\t\tkey = &result.page->u.leaf_key[result.index];\n\t\t\tAssert(key->npages == victim->npages);\n\t\t\tkey->first_page += npages;\n\t\t\tkey->npages -= npages;\n\t\t\tif (result.index == 0)\n\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, result.page);\n\n\t\t\t/* Put the unallocated pages back on the appropriate free list. */\n\t\t\tFreePagePushSpanLeader(fpm, victim_page + npages,\n\t\t\t\t\t\t\t\t   victim->npages - npages);\n\t\t}\n\t}\n\n\t/* Return results to caller. */\n\t*first_page = fpm_pointer_to_page(base, victim);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePagePopSpanLeader",
          "args": [
            "fpm",
            "nextkey->first_page"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "FreePagePopSpanLeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1842-1865",
          "snippet": "static void\nFreePagePopSpanLeader(FreePageManager *fpm, Size pageno)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *span;\n\tFreePageSpanLeader *next;\n\tFreePageSpanLeader *prev;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, pageno);\n\n\tnext = relptr_access(base, span->next);\n\tprev = relptr_access(base, span->prev);\n\tif (next != NULL)\n\t\trelptr_copy(next->prev, span->prev);\n\tif (prev != NULL)\n\t\trelptr_copy(prev->next, span->next);\n\telse\n\t{\n\t\tSize\t\tf = Min(span->npages, FPM_NUM_FREELISTS) - 1;\n\n\t\tAssert(fpm->freelist[f].relptr_off == pageno * FPM_PAGE_SIZE);\n\t\trelptr_copy(fpm->freelist[f], span->next);\n\t}\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePageBtreeRecycle(FreePageManager *fpm, Size pageno);",
            "static void FreePagePopSpanLeader(FreePageManager *fpm, Size pageno);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRecycle(FreePageManager *fpm, Size pageno);\nstatic void FreePagePopSpanLeader(FreePageManager *fpm, Size pageno);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePagePopSpanLeader(FreePageManager *fpm, Size pageno)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *span;\n\tFreePageSpanLeader *next;\n\tFreePageSpanLeader *prev;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, pageno);\n\n\tnext = relptr_access(base, span->next);\n\tprev = relptr_access(base, span->prev);\n\tif (next != NULL)\n\t\trelptr_copy(next->prev, span->prev);\n\tif (prev != NULL)\n\t\trelptr_copy(prev->next, span->next);\n\telse\n\t{\n\t\tSize\t\tf = Min(span->npages, FPM_NUM_FREELISTS) - 1;\n\n\t\tAssert(fpm->freelist[f].relptr_off == pageno * FPM_PAGE_SIZE);\n\t\trelptr_copy(fpm->freelist[f], span->next);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "first_page + npages == nextkey->first_page"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeRemove",
          "args": [
            "fpm",
            "np",
            "nindex"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "954-979",
          "snippet": "static void\nFreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp, Size index)\n{\n\tAssert(btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\tAssert(index < btp->hdr.nused);\n\n\t/* When last item is removed, extirpate entire page from btree. */\n\tif (btp->hdr.nused == 1)\n\t{\n\t\tFreePageBtreeRemovePage(fpm, btp);\n\t\treturn;\n\t}\n\n\t/* Physically remove the key from the page. */\n\t--btp->hdr.nused;\n\tif (index < btp->hdr.nused)\n\t\tmemmove(&btp->u.leaf_key[index], &btp->u.leaf_key[index + 1],\n\t\t\t\tsizeof(FreePageBtreeLeafKey) * (btp->hdr.nused - index));\n\n\t/* If we just removed the first key, adjust ancestor keys. */\n\tif (index == 0)\n\t\tFreePageBtreeAdjustAncestorKeys(fpm, btp);\n\n\t/* Consider whether to consolidate this page with a sibling. */\n\tFreePageBtreeConsolidate(fpm, btp);\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp, Size index)\n{\n\tAssert(btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\tAssert(index < btp->hdr.nused);\n\n\t/* When last item is removed, extirpate entire page from btree. */\n\tif (btp->hdr.nused == 1)\n\t{\n\t\tFreePageBtreeRemovePage(fpm, btp);\n\t\treturn;\n\t}\n\n\t/* Physically remove the key from the page. */\n\t--btp->hdr.nused;\n\tif (index < btp->hdr.nused)\n\t\tmemmove(&btp->u.leaf_key[index], &btp->u.leaf_key[index + 1],\n\t\t\t\tsizeof(FreePageBtreeLeafKey) * (btp->hdr.nused - index));\n\n\t/* If we just removed the first key, adjust ancestor keys. */\n\tif (index == 0)\n\t\tFreePageBtreeAdjustAncestorKeys(fpm, btp);\n\n\t/* Consider whether to consolidate this page with a sibling. */\n\tFreePageBtreeConsolidate(fpm, btp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "prevkey->first_page + prevkey->npages ==\n\t\t\t\t   nextkey->first_page"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "prevkey->first_page + prevkey->npages == first_page"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeFindRightSibling",
          "args": [
            "base",
            "result.page"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeFindRightSibling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "818-857",
          "snippet": "static FreePageBtree *\nFreePageBtreeFindRightSibling(char *base, FreePageBtree *btp)\n{\n\tFreePageBtree *p = btp;\n\tint\t\t\tlevels = 0;\n\n\t/* Move up until we can move right. */\n\tfor (;;)\n\t{\n\t\tSize\t\tfirst_page;\n\t\tSize\t\tindex;\n\n\t\tfirst_page = FreePageBtreeFirstKey(p);\n\t\tp = relptr_access(base, p->hdr.parent);\n\n\t\tif (p == NULL)\n\t\t\treturn NULL;\t\t/* we were passed the rightmost page */\n\n\t\tindex = FreePageBtreeSearchInternal(p, first_page);\n\t\tif (index < p->hdr.nused - 1)\n\t\t{\n\t\t\tAssert(p->u.internal_key[index].first_page == first_page);\n\t\t\tp = relptr_access(base, p->u.internal_key[index + 1].child);\n\t\t\tbreak;\n\t\t}\n\t\tAssert(index == p->hdr.nused - 1);\n\t\t++levels;\n\t}\n\n\t/* Descend left. */\n\twhile (levels > 0)\n\t{\n\t\tAssert(p->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tp = relptr_access(base, p->u.internal_key[0].child);\n\t\t--levels;\n\t}\n\tAssert(p->hdr.magic == btp->hdr.magic);\n\n\treturn p;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic FreePageBtree *\nFreePageBtreeFindRightSibling(char *base, FreePageBtree *btp)\n{\n\tFreePageBtree *p = btp;\n\tint\t\t\tlevels = 0;\n\n\t/* Move up until we can move right. */\n\tfor (;;)\n\t{\n\t\tSize\t\tfirst_page;\n\t\tSize\t\tindex;\n\n\t\tfirst_page = FreePageBtreeFirstKey(p);\n\t\tp = relptr_access(base, p->hdr.parent);\n\n\t\tif (p == NULL)\n\t\t\treturn NULL;\t\t/* we were passed the rightmost page */\n\n\t\tindex = FreePageBtreeSearchInternal(p, first_page);\n\t\tif (index < p->hdr.nused - 1)\n\t\t{\n\t\t\tAssert(p->u.internal_key[index].first_page == first_page);\n\t\t\tp = relptr_access(base, p->u.internal_key[index + 1].child);\n\t\t\tbreak;\n\t\t}\n\t\tAssert(index == p->hdr.nused - 1);\n\t\t++levels;\n\t}\n\n\t/* Descend left. */\n\twhile (levels > 0)\n\t{\n\t\tAssert(p->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tp = relptr_access(base, p->u.internal_key[0].child);\n\t\t--levels;\n\t}\n\tAssert(p->hdr.magic == btp->hdr.magic);\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!result.found"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "fpm->btree_root",
            "root"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "root->hdr.parent",
            "(FreePageBtree *) NULL"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_page_to_pointer",
          "args": [
            "base",
            "root_page"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_is_null",
          "args": [
            "fpm->btree_recycle"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "npages > 0"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_segment_base",
          "args": [
            "fpm"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic Size FreePageManagerPutInternal(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t\t   Size npages, bool soft);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic Size\nFreePageManagerPutInternal(FreePageManager *fpm, Size first_page, Size npages,\n\t\t\t\t\t\t   bool soft)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtreeSearchResult result;\n\tFreePageBtreeLeafKey *prevkey = NULL;\n\tFreePageBtreeLeafKey *nextkey = NULL;\n\tFreePageBtree *np;\n\tSize\t\tnindex;\n\n\tAssert(npages > 0);\n\n\t/* We can store a single free span without initializing the btree. */\n\tif (fpm->btree_depth == 0)\n\t{\n\t\tif (fpm->singleton_npages == 0)\n\t\t{\n\t\t\t/* Don't have a span yet; store this one. */\n\t\t\tfpm->singleton_first_page = first_page;\n\t\t\tfpm->singleton_npages = npages;\n\t\t\tFreePagePushSpanLeader(fpm, first_page, npages);\n\t\t\treturn fpm->singleton_npages;\n\t\t}\n\t\telse if (fpm->singleton_first_page + fpm->singleton_npages ==\n\t\t\t\t first_page)\n\t\t{\n\t\t\t/* New span immediately follows sole existing span. */\n\t\t\tfpm->singleton_npages += npages;\n\t\t\tFreePagePopSpanLeader(fpm, fpm->singleton_first_page);\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t\t\treturn fpm->singleton_npages;\n\t\t}\n\t\telse if (first_page + npages == fpm->singleton_first_page)\n\t\t{\n\t\t\t/* New span immediately precedes sole existing span. */\n\t\t\tFreePagePopSpanLeader(fpm, fpm->singleton_first_page);\n\t\t\tfpm->singleton_first_page = first_page;\n\t\t\tfpm->singleton_npages += npages;\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t\t\treturn fpm->singleton_npages;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Not contiguous; we need to initialize the btree. */\n\t\t\tSize\t\troot_page;\n\t\t\tFreePageBtree *root;\n\n\t\t\tif (!relptr_is_null(fpm->btree_recycle))\n\t\t\t\troot = FreePageBtreeGetRecycled(fpm);\n\t\t\telse if (soft)\n\t\t\t\treturn 0;\t\t/* Should not allocate if soft. */\n\t\t\telse if (FreePageManagerGetInternal(fpm, 1, &root_page))\n\t\t\t\troot = (FreePageBtree *) fpm_page_to_pointer(base, root_page);\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* We'd better be able to get a page from the existing range. */\n\t\t\t\telog(FATAL, \"free page manager btree is corrupt\");\n\t\t\t}\n\n\t\t\t/* Create the btree and move the preexisting range into it. */\n\t\t\troot->hdr.magic = FREE_PAGE_LEAF_MAGIC;\n\t\t\troot->hdr.nused = 1;\n\t\t\trelptr_store(base, root->hdr.parent, (FreePageBtree *) NULL);\n\t\t\troot->u.leaf_key[0].first_page = fpm->singleton_first_page;\n\t\t\troot->u.leaf_key[0].npages = fpm->singleton_npages;\n\t\t\trelptr_store(base, fpm->btree_root, root);\n\t\t\tfpm->singleton_first_page = 0;\n\t\t\tfpm->singleton_npages = 0;\n\t\t\tfpm->btree_depth = 1;\n\n\t\t\t/*\n\t\t\t * Corner case: it may be that the btree root took the very last\n\t\t\t * free page.  In that case, the sole btree entry covers a zero\n\t\t\t * page run, which is invalid.  Overwrite it with the entry we're\n\t\t\t * trying to insert and get out.\n\t\t\t */\n\t\t\tif (root->u.leaf_key[0].npages == 0)\n\t\t\t{\n\t\t\t\troot->u.leaf_key[0].first_page = first_page;\n\t\t\t\troot->u.leaf_key[0].npages = npages;\n\t\t\t\tFreePagePushSpanLeader(fpm, first_page, npages);\n\t\t\t\treturn npages;\n\t\t\t}\n\n\t\t\t/* Fall through to insert the new key. */\n\t\t}\n\t}\n\n\t/* Search the btree. */\n\tFreePageBtreeSearch(fpm, first_page, &result);\n\tAssert(!result.found);\n\tif (result.index > 0)\n\t\tprevkey = &result.page->u.leaf_key[result.index - 1];\n\tif (result.index < result.page->hdr.nused)\n\t{\n\t\tnp = result.page;\n\t\tnindex = result.index;\n\t\tnextkey = &result.page->u.leaf_key[result.index];\n\t}\n\telse\n\t{\n\t\tnp = FreePageBtreeFindRightSibling(base, result.page);\n\t\tnindex = 0;\n\t\tif (np != NULL)\n\t\t\tnextkey = &np->u.leaf_key[0];\n\t}\n\n\t/* Consolidate with the previous entry if possible. */\n\tif (prevkey != NULL && prevkey->first_page + prevkey->npages >= first_page)\n\t{\n\t\tbool\t\tremove_next = false;\n\t\tSize\t\tresult;\n\n\t\tAssert(prevkey->first_page + prevkey->npages == first_page);\n\t\tprevkey->npages = (first_page - prevkey->first_page) + npages;\n\n\t\t/* Check whether we can *also* consolidate with the following entry. */\n\t\tif (nextkey != NULL &&\n\t\t\tprevkey->first_page + prevkey->npages >= nextkey->first_page)\n\t\t{\n\t\t\tAssert(prevkey->first_page + prevkey->npages ==\n\t\t\t\t   nextkey->first_page);\n\t\t\tprevkey->npages = (nextkey->first_page - prevkey->first_page)\n\t\t\t\t+ nextkey->npages;\n\t\t\tFreePagePopSpanLeader(fpm, nextkey->first_page);\n\t\t\tremove_next = true;\n\t\t}\n\n\t\t/* Put the span on the correct freelist and save size. */\n\t\tFreePagePopSpanLeader(fpm, prevkey->first_page);\n\t\tFreePagePushSpanLeader(fpm, prevkey->first_page, prevkey->npages);\n\t\tresult = prevkey->npages;\n\n\t\t/*\n\t\t * If we consolidated with both the preceding and following entries,\n\t\t * we must remove the following entry.  We do this last, because\n\t\t * removing an element from the btree may invalidate pointers we hold\n\t\t * into the current data structure.\n\t\t *\n\t\t * NB: The btree is technically in an invalid state a this point\n\t\t * because we've already updated prevkey to cover the same key space\n\t\t * as nextkey.  FreePageBtreeRemove() shouldn't notice that, though.\n\t\t */\n\t\tif (remove_next)\n\t\t\tFreePageBtreeRemove(fpm, np, nindex);\n\n\t\treturn result;\n\t}\n\n\t/* Consolidate with the next entry if possible. */\n\tif (nextkey != NULL && first_page + npages >= nextkey->first_page)\n\t{\n\t\tSize\t\tnewpages;\n\n\t\t/* Compute new size for span. */\n\t\tAssert(first_page + npages == nextkey->first_page);\n\t\tnewpages = (nextkey->first_page - first_page) + nextkey->npages;\n\n\t\t/* Put span on correct free list. */\n\t\tFreePagePopSpanLeader(fpm, nextkey->first_page);\n\t\tFreePagePushSpanLeader(fpm, first_page, newpages);\n\n\t\t/* Update key in place. */\n\t\tnextkey->first_page = first_page;\n\t\tnextkey->npages = newpages;\n\n\t\t/* If reducing first key on page, ancestors might need adjustment. */\n\t\tif (nindex == 0)\n\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, np);\n\n\t\treturn nextkey->npages;\n\t}\n\n\t/* Split leaf page and as many of its ancestors as necessary. */\n\tif (result.split_pages > 0)\n\t{\n\t\t/*\n\t\t * NB: We could consider various coping strategies here to avoid a\n\t\t * split; most obviously, if np != result.page, we could target that\n\t\t * page instead.   More complicated shuffling strategies could be\n\t\t * possible as well; basically, unless every single leaf page is 100%\n\t\t * full, we can jam this key in there if we try hard enough.  It's\n\t\t * unlikely that trying that hard is worthwhile, but it's possible we\n\t\t * might need to make more than no effort.  For now, we just do the\n\t\t * easy thing, which is nothing.\n\t\t */\n\n\t\t/* If this is a soft insert, it's time to give up. */\n\t\tif (soft)\n\t\t\treturn 0;\n\n\t\t/* Check whether we need to allocate more btree pages to split. */\n\t\tif (result.split_pages > fpm->btree_recycle_count)\n\t\t{\n\t\t\tSize\t\tpages_needed;\n\t\t\tSize\t\trecycle_page;\n\t\t\tSize\t\ti;\n\n\t\t\t/*\n\t\t\t * Allocate the required number of pages and split each one in\n\t\t\t * turn.  This should never fail, because if we've got enough\n\t\t\t * spans of free pages kicking around that we need additional\n\t\t\t * storage space just to remember them all, then we should\n\t\t\t * certainly have enough to expand the btree, which should only\n\t\t\t * ever use a tiny number of pages compared to the number under\n\t\t\t * management.  If it does, something's badly screwed up.\n\t\t\t */\n\t\t\tpages_needed = result.split_pages - fpm->btree_recycle_count;\n\t\t\tfor (i = 0; i < pages_needed; ++i)\n\t\t\t{\n\t\t\t\tif (!FreePageManagerGetInternal(fpm, 1, &recycle_page))\n\t\t\t\t\telog(FATAL, \"free page manager btree is corrupt\");\n\t\t\t\tFreePageBtreeRecycle(fpm, recycle_page);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The act of allocating pages to recycle may have invalidated the\n\t\t\t * results of our previous btree reserch, so repeat it. (We could\n\t\t\t * recheck whether any of our split-avoidance strategies that were\n\t\t\t * not viable before now are, but it hardly seems worthwhile, so\n\t\t\t * we don't bother. Consolidation can't be possible now if it\n\t\t\t * wasn't previously.)\n\t\t\t */\n\t\t\tFreePageBtreeSearch(fpm, first_page, &result);\n\n\t\t\t/*\n\t\t\t * The act of allocating pages for use in constructing our btree\n\t\t\t * should never cause any page to become more full, so the new\n\t\t\t * split depth should be no greater than the old one, and perhaps\n\t\t\t * less if we fortuitously allocated a chunk that freed up a slot\n\t\t\t * on the page we need to update.\n\t\t\t */\n\t\t\tAssert(result.split_pages <= fpm->btree_recycle_count);\n\t\t}\n\n\t\t/* If we still need to perform a split, do it. */\n\t\tif (result.split_pages > 0)\n\t\t{\n\t\t\tFreePageBtree *split_target = result.page;\n\t\t\tFreePageBtree *child = NULL;\n\t\t\tSize\t\tkey = first_page;\n\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tFreePageBtree *newsibling;\n\t\t\t\tFreePageBtree *parent;\n\n\t\t\t\t/* Identify parent page, which must receive downlink. */\n\t\t\t\tparent = relptr_access(base, split_target->hdr.parent);\n\n\t\t\t\t/* Split the page - downlink not added yet. */\n\t\t\t\tnewsibling = FreePageBtreeSplitPage(fpm, split_target);\n\n\t\t\t\t/*\n\t\t\t\t * At this point in the loop, we're always carrying a pending\n\t\t\t\t * insertion.  On the first pass, it's the actual key we're\n\t\t\t\t * trying to insert; on subsequent passes, it's the downlink\n\t\t\t\t * that needs to be added as a result of the split performed\n\t\t\t\t * during the previous loop iteration.  Since we've just split\n\t\t\t\t * the page, there's definitely room on one of the two\n\t\t\t\t * resulting pages.\n\t\t\t\t */\n\t\t\t\tif (child == NULL)\n\t\t\t\t{\n\t\t\t\t\tSize\t\tindex;\n\t\t\t\t\tFreePageBtree *insert_into;\n\n\t\t\t\t\tinsert_into = key < newsibling->u.leaf_key[0].first_page ?\n\t\t\t\t\t\tsplit_target : newsibling;\n\t\t\t\t\tindex = FreePageBtreeSearchLeaf(insert_into, key);\n\t\t\t\t\tFreePageBtreeInsertLeaf(insert_into, index, key, npages);\n\t\t\t\t\tif (index == 0 && insert_into == split_target)\n\t\t\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, split_target);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSize\t\tindex;\n\t\t\t\t\tFreePageBtree *insert_into;\n\n\t\t\t\t\tinsert_into =\n\t\t\t\t\t\tkey < newsibling->u.internal_key[0].first_page ?\n\t\t\t\t\t\tsplit_target : newsibling;\n\t\t\t\t\tindex = FreePageBtreeSearchInternal(insert_into, key);\n\t\t\t\t\tFreePageBtreeInsertInternal(base, insert_into, index,\n\t\t\t\t\t\t\t\t\t\t\t\tkey, child);\n\t\t\t\t\trelptr_store(base, child->hdr.parent, insert_into);\n\t\t\t\t\tif (index == 0 && insert_into == split_target)\n\t\t\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, split_target);\n\t\t\t\t}\n\n\t\t\t\t/* If the page we just split has no parent, split the root. */\n\t\t\t\tif (parent == NULL)\n\t\t\t\t{\n\t\t\t\t\tFreePageBtree *newroot;\n\n\t\t\t\t\tnewroot = FreePageBtreeGetRecycled(fpm);\n\t\t\t\t\tnewroot->hdr.magic = FREE_PAGE_INTERNAL_MAGIC;\n\t\t\t\t\tnewroot->hdr.nused = 2;\n\t\t\t\t\trelptr_store(base, newroot->hdr.parent,\n\t\t\t\t\t\t\t\t (FreePageBtree *) NULL);\n\t\t\t\t\tnewroot->u.internal_key[0].first_page =\n\t\t\t\t\t\tFreePageBtreeFirstKey(split_target);\n\t\t\t\t\trelptr_store(base, newroot->u.internal_key[0].child,\n\t\t\t\t\t\t\t\t split_target);\n\t\t\t\t\trelptr_store(base, split_target->hdr.parent, newroot);\n\t\t\t\t\tnewroot->u.internal_key[1].first_page =\n\t\t\t\t\t\tFreePageBtreeFirstKey(newsibling);\n\t\t\t\t\trelptr_store(base, newroot->u.internal_key[1].child,\n\t\t\t\t\t\t\t\t newsibling);\n\t\t\t\t\trelptr_store(base, newsibling->hdr.parent, newroot);\n\t\t\t\t\trelptr_store(base, fpm->btree_root, newroot);\n\t\t\t\t\tfpm->btree_depth++;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* If the parent page isn't full, insert the downlink. */\n\t\t\t\tkey = newsibling->u.internal_key[0].first_page;\n\t\t\t\tif (parent->hdr.nused < FPM_ITEMS_PER_INTERNAL_PAGE)\n\t\t\t\t{\n\t\t\t\t\tSize\t\tindex;\n\n\t\t\t\t\tindex = FreePageBtreeSearchInternal(parent, key);\n\t\t\t\t\tFreePageBtreeInsertInternal(base, parent, index,\n\t\t\t\t\t\t\t\t\t\t\t\tkey, newsibling);\n\t\t\t\t\trelptr_store(base, newsibling->hdr.parent, parent);\n\t\t\t\t\tif (index == 0)\n\t\t\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, parent);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* The parent also needs to be split, so loop around. */\n\t\t\t\tchild = newsibling;\n\t\t\t\tsplit_target = parent;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The loop above did the insert, so just need to update the free\n\t\t\t * list, and we're done.\n\t\t\t */\n\t\t\tFreePagePushSpanLeader(fpm, first_page, npages);\n\n\t\t\treturn npages;\n\t\t}\n\t}\n\n\t/* Physically add the key to the page. */\n\tAssert(result.page->hdr.nused < FPM_ITEMS_PER_LEAF_PAGE);\n\tFreePageBtreeInsertLeaf(result.page, result.index, first_page, npages);\n\n\t/* If new first key on page, ancestors might need adjustment. */\n\tif (result.index == 0)\n\t\tFreePageBtreeAdjustAncestorKeys(fpm, result.page);\n\n\t/* Put it on the free list. */\n\tFreePagePushSpanLeader(fpm, first_page, npages);\n\n\treturn npages;\n}"
  },
  {
    "function_name": "FreePageManagerGetInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "1318-1464",
    "snippet": "static bool\nFreePageManagerGetInternal(FreePageManager *fpm, Size npages, Size *first_page)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *victim = NULL;\n\tFreePageSpanLeader *prev;\n\tFreePageSpanLeader *next;\n\tFreePageBtreeSearchResult result;\n\tSize\t\tvictim_page = 0;\t/* placate compiler */\n\tSize\t\tf;\n\n\t/*\n\t * Search for a free span.\n\t *\n\t * Right now, we use a simple best-fit policy here, but it's possible for\n\t * this to result in memory fragmentation if we're repeatedly asked to\n\t * allocate chunks just a little smaller than what we have available.\n\t * Hopefully, this is unlikely, because we expect most requests to be\n\t * single pages or superblock-sized chunks -- but no policy can be optimal\n\t * under all circumstances unless it has knowledge of future allocation\n\t * patterns.\n\t */\n\tfor (f = Min(npages, FPM_NUM_FREELISTS) - 1; f < FPM_NUM_FREELISTS; ++f)\n\t{\n\t\t/* Skip empty freelists. */\n\t\tif (relptr_is_null(fpm->freelist[f]))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All of the freelists except the last one contain only items of a\n\t\t * single size, so we just take the first one.  But the final free\n\t\t * list contains everything too big for any of the other lists, so we\n\t\t * need to search the list.\n\t\t */\n\t\tif (f < FPM_NUM_FREELISTS - 1)\n\t\t\tvictim = relptr_access(base, fpm->freelist[f]);\n\t\telse\n\t\t{\n\t\t\tFreePageSpanLeader *candidate;\n\n\t\t\tcandidate = relptr_access(base, fpm->freelist[f]);\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (candidate->npages >= npages && (victim == NULL ||\n\t\t\t\t\t\t\t\t\t\t\t\t\tvictim->npages > candidate->npages))\n\t\t\t\t{\n\t\t\t\t\tvictim = candidate;\n\t\t\t\t\tif (victim->npages == npages)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t\t} while (candidate != NULL);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* If we didn't find an allocatable span, return failure. */\n\tif (victim == NULL)\n\t\treturn false;\n\n\t/* Remove span from free list. */\n\tAssert(victim->magic == FREE_PAGE_SPAN_LEADER_MAGIC);\n\tprev = relptr_access(base, victim->prev);\n\tnext = relptr_access(base, victim->next);\n\tif (prev != NULL)\n\t\trelptr_copy(prev->next, victim->next);\n\telse\n\t\trelptr_copy(fpm->freelist[f], victim->next);\n\tif (next != NULL)\n\t\trelptr_copy(next->prev, victim->prev);\n\tvictim_page = fpm_pointer_to_page(base, victim);\n\n\t/* Decide whether we might be invalidating contiguous_pages. */\n\tif (f == FPM_NUM_FREELISTS - 1 &&\n\t\tvictim->npages == fpm->contiguous_pages)\n\t{\n\t\t/*\n\t\t * The victim span came from the oversized freelist, and had the same\n\t\t * size as the longest span.  There may or may not be another one of\n\t\t * the same size, so contiguous_pages must be recomputed just to be\n\t\t * safe.\n\t\t */\n\t\tfpm->contiguous_pages_dirty = true;\n\t}\n\telse if (f + 1 == fpm->contiguous_pages &&\n\t\t\t relptr_is_null(fpm->freelist[f]))\n\t{\n\t\t/*\n\t\t * The victim span came from a fixed sized freelist, and it was the\n\t\t * list for spans of the same size as the current longest span, and\n\t\t * the list is now empty after removing the victim.  So\n\t\t * contiguous_pages must be recomputed without a doubt.\n\t\t */\n\t\tfpm->contiguous_pages_dirty = true;\n\t}\n\n\t/*\n\t * If we haven't initialized the btree yet, the victim must be the single\n\t * span stored within the FreePageManager itself.  Otherwise, we need to\n\t * update the btree.\n\t */\n\tif (relptr_is_null(fpm->btree_root))\n\t{\n\t\tAssert(victim_page == fpm->singleton_first_page);\n\t\tAssert(victim->npages == fpm->singleton_npages);\n\t\tAssert(victim->npages >= npages);\n\t\tfpm->singleton_first_page += npages;\n\t\tfpm->singleton_npages -= npages;\n\t\tif (fpm->singleton_npages > 0)\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If the span we found is exactly the right size, remove it from the\n\t\t * btree completely.  Otherwise, adjust the btree entry to reflect the\n\t\t * still-unallocated portion of the span, and put that portion on the\n\t\t * appropriate free list.\n\t\t */\n\t\tFreePageBtreeSearch(fpm, victim_page, &result);\n\t\tAssert(result.found);\n\t\tif (victim->npages == npages)\n\t\t\tFreePageBtreeRemove(fpm, result.page, result.index);\n\t\telse\n\t\t{\n\t\t\tFreePageBtreeLeafKey *key;\n\n\t\t\t/* Adjust btree to reflect remaining pages. */\n\t\t\tAssert(victim->npages > npages);\n\t\t\tkey = &result.page->u.leaf_key[result.index];\n\t\t\tAssert(key->npages == victim->npages);\n\t\t\tkey->first_page += npages;\n\t\t\tkey->npages -= npages;\n\t\t\tif (result.index == 0)\n\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, result.page);\n\n\t\t\t/* Put the unallocated pages back on the appropriate free list. */\n\t\t\tFreePagePushSpanLeader(fpm, victim_page + npages,\n\t\t\t\t\t\t\t\t   victim->npages - npages);\n\t\t}\n\t}\n\n\t/* Return results to caller. */\n\t*first_page = fpm_pointer_to_page(base, victim);\n\treturn true;\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0"
    ],
    "globals_used": [
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
      "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
      "static void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);",
      "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
      "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
      "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
      "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fpm_pointer_to_page",
          "args": [
            "base",
            "victim"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePagePushSpanLeader",
          "args": [
            "fpm",
            "victim_page + npages",
            "victim->npages - npages"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "FreePagePushSpanLeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1870-1886",
          "snippet": "static void\nFreePagePushSpanLeader(FreePageManager *fpm, Size first_page, Size npages)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tf = Min(npages, FPM_NUM_FREELISTS) - 1;\n\tFreePageSpanLeader *head = relptr_access(base, fpm->freelist[f]);\n\tFreePageSpanLeader *span;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, first_page);\n\tspan->magic = FREE_PAGE_SPAN_LEADER_MAGIC;\n\tspan->npages = npages;\n\trelptr_store(base, span->next, head);\n\trelptr_store(base, span->prev, (FreePageSpanLeader *) NULL);\n\tif (head != NULL)\n\t\trelptr_store(base, head->prev, span);\n\trelptr_store(base, fpm->freelist[f], span);\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0"
          ],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePagePushSpanLeader(FreePageManager *fpm, Size first_page, Size npages)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tf = Min(npages, FPM_NUM_FREELISTS) - 1;\n\tFreePageSpanLeader *head = relptr_access(base, fpm->freelist[f]);\n\tFreePageSpanLeader *span;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, first_page);\n\tspan->magic = FREE_PAGE_SPAN_LEADER_MAGIC;\n\tspan->npages = npages;\n\trelptr_store(base, span->next, head);\n\trelptr_store(base, span->prev, (FreePageSpanLeader *) NULL);\n\tif (head != NULL)\n\t\trelptr_store(base, head->prev, span);\n\trelptr_store(base, fpm->freelist[f], span);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageBtreeAdjustAncestorKeys",
          "args": [
            "fpm",
            "result.page"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeAdjustAncestorKeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "500-573",
          "snippet": "static void\nFreePageBtreeAdjustAncestorKeys(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tfirst_page;\n\tFreePageBtree *parent;\n\tFreePageBtree *child;\n\n\t/* This might be either a leaf or an internal page. */\n\tAssert(btp->hdr.nused > 0);\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t{\n\t\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_LEAF_PAGE);\n\t\tfirst_page = btp->u.leaf_key[0].first_page;\n\t}\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\tfirst_page = btp->u.internal_key[0].first_page;\n\t}\n\tchild = btp;\n\n\t/* Loop until we find an ancestor that does not require adjustment. */\n\tfor (;;)\n\t{\n\t\tSize\t\ts;\n\n\t\tparent = relptr_access(base, child->hdr.parent);\n\t\tif (parent == NULL)\n\t\t\tbreak;\n\t\ts = FreePageBtreeSearchInternal(parent, first_page);\n\n\t\t/* Key is either at index s or index s-1; figure out which. */\n\t\tif (s >= parent->hdr.nused)\n\t\t{\n\t\t\tAssert(s == parent->hdr.nused);\n\t\t\t--s;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFreePageBtree *check;\n\n\t\t\tcheck = relptr_access(base, parent->u.internal_key[s].child);\n\t\t\tif (check != child)\n\t\t\t{\n\t\t\t\tAssert(s > 0);\n\t\t\t\t--s;\n\t\t\t}\n\t\t}\n\n#ifdef USE_ASSERT_CHECKING\n\t\t/* Debugging double-check. */\n\t\t{\n\t\t\tFreePageBtree *check;\n\n\t\t\tcheck = relptr_access(base, parent->u.internal_key[s].child);\n\t\t\tAssert(s < parent->hdr.nused);\n\t\t\tAssert(child == check);\n\t\t}\n#endif\n\n\t\t/* Update the parent key. */\n\t\tparent->u.internal_key[s].first_page = first_page;\n\n\t\t/*\n\t\t * If this is the first key in the parent, go up another level; else\n\t\t * done.\n\t\t */\n\t\tif (s > 0)\n\t\t\tbreak;\n\t\tchild = parent;\n\t}\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))",
            "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeAdjustAncestorKeys(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tfirst_page;\n\tFreePageBtree *parent;\n\tFreePageBtree *child;\n\n\t/* This might be either a leaf or an internal page. */\n\tAssert(btp->hdr.nused > 0);\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t{\n\t\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_LEAF_PAGE);\n\t\tfirst_page = btp->u.leaf_key[0].first_page;\n\t}\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\tfirst_page = btp->u.internal_key[0].first_page;\n\t}\n\tchild = btp;\n\n\t/* Loop until we find an ancestor that does not require adjustment. */\n\tfor (;;)\n\t{\n\t\tSize\t\ts;\n\n\t\tparent = relptr_access(base, child->hdr.parent);\n\t\tif (parent == NULL)\n\t\t\tbreak;\n\t\ts = FreePageBtreeSearchInternal(parent, first_page);\n\n\t\t/* Key is either at index s or index s-1; figure out which. */\n\t\tif (s >= parent->hdr.nused)\n\t\t{\n\t\t\tAssert(s == parent->hdr.nused);\n\t\t\t--s;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFreePageBtree *check;\n\n\t\t\tcheck = relptr_access(base, parent->u.internal_key[s].child);\n\t\t\tif (check != child)\n\t\t\t{\n\t\t\t\tAssert(s > 0);\n\t\t\t\t--s;\n\t\t\t}\n\t\t}\n\n#ifdef USE_ASSERT_CHECKING\n\t\t/* Debugging double-check. */\n\t\t{\n\t\t\tFreePageBtree *check;\n\n\t\t\tcheck = relptr_access(base, parent->u.internal_key[s].child);\n\t\t\tAssert(s < parent->hdr.nused);\n\t\t\tAssert(child == check);\n\t\t}\n#endif\n\n\t\t/* Update the parent key. */\n\t\tparent->u.internal_key[s].first_page = first_page;\n\n\t\t/*\n\t\t * If this is the first key in the parent, go up another level; else\n\t\t * done.\n\t\t */\n\t\tif (s > 0)\n\t\t\tbreak;\n\t\tchild = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "key->npages == victim->npages"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "victim->npages > npages"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeRemove",
          "args": [
            "fpm",
            "result.page",
            "result.index"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "954-979",
          "snippet": "static void\nFreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp, Size index)\n{\n\tAssert(btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\tAssert(index < btp->hdr.nused);\n\n\t/* When last item is removed, extirpate entire page from btree. */\n\tif (btp->hdr.nused == 1)\n\t{\n\t\tFreePageBtreeRemovePage(fpm, btp);\n\t\treturn;\n\t}\n\n\t/* Physically remove the key from the page. */\n\t--btp->hdr.nused;\n\tif (index < btp->hdr.nused)\n\t\tmemmove(&btp->u.leaf_key[index], &btp->u.leaf_key[index + 1],\n\t\t\t\tsizeof(FreePageBtreeLeafKey) * (btp->hdr.nused - index));\n\n\t/* If we just removed the first key, adjust ancestor keys. */\n\tif (index == 0)\n\t\tFreePageBtreeAdjustAncestorKeys(fpm, btp);\n\n\t/* Consider whether to consolidate this page with a sibling. */\n\tFreePageBtreeConsolidate(fpm, btp);\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp, Size index)\n{\n\tAssert(btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\tAssert(index < btp->hdr.nused);\n\n\t/* When last item is removed, extirpate entire page from btree. */\n\tif (btp->hdr.nused == 1)\n\t{\n\t\tFreePageBtreeRemovePage(fpm, btp);\n\t\treturn;\n\t}\n\n\t/* Physically remove the key from the page. */\n\t--btp->hdr.nused;\n\tif (index < btp->hdr.nused)\n\t\tmemmove(&btp->u.leaf_key[index], &btp->u.leaf_key[index + 1],\n\t\t\t\tsizeof(FreePageBtreeLeafKey) * (btp->hdr.nused - index));\n\n\t/* If we just removed the first key, adjust ancestor keys. */\n\tif (index == 0)\n\t\tFreePageBtreeAdjustAncestorKeys(fpm, btp);\n\n\t/* Consider whether to consolidate this page with a sibling. */\n\tFreePageBtreeConsolidate(fpm, btp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "result.found"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeSearch",
          "args": [
            "fpm",
            "victim_page",
            "&result"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1063-1132",
          "snippet": "static void\nFreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtree *btp = relptr_access(base, fpm->btree_root);\n\tSize\t\tindex;\n\n\tresult->split_pages = 1;\n\n\t/* If the btree is empty, there's nothing to find. */\n\tif (btp == NULL)\n\t{\n\t\tresult->page = NULL;\n\t\tresult->found = false;\n\t\treturn;\n\t}\n\n\t/* Descend until we hit a leaf. */\n\twhile (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t{\n\t\tFreePageBtree *child;\n\t\tbool\t\tfound_exact;\n\n\t\tindex = FreePageBtreeSearchInternal(btp, first_page);\n\t\tfound_exact = index < btp->hdr.nused &&\n\t\t\tbtp->u.internal_key[index].first_page == first_page;\n\n\t\t/*\n\t\t * If we found an exact match we descend directly.  Otherwise, we\n\t\t * descend into the child to the left if possible so that we can find\n\t\t * the insertion point at that child's high end.\n\t\t */\n\t\tif (!found_exact && index > 0)\n\t\t\t--index;\n\n\t\t/* Track required split depth for leaf insert. */\n\t\tif (btp->hdr.nused >= FPM_ITEMS_PER_INTERNAL_PAGE)\n\t\t{\n\t\t\tAssert(btp->hdr.nused == FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\t\tresult->split_pages++;\n\t\t}\n\t\telse\n\t\t\tresult->split_pages = 0;\n\n\t\t/* Descend to appropriate child page. */\n\t\tAssert(index < btp->hdr.nused);\n\t\tchild = relptr_access(base, btp->u.internal_key[index].child);\n\t\tAssert(relptr_access(base, child->hdr.parent) == btp);\n\t\tbtp = child;\n\t}\n\n\t/* Track required split depth for leaf insert. */\n\tif (btp->hdr.nused >= FPM_ITEMS_PER_LEAF_PAGE)\n\t{\n\t\tAssert(btp->hdr.nused == FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\tresult->split_pages++;\n\t}\n\telse\n\t\tresult->split_pages = 0;\n\n\t/* Search leaf page. */\n\tindex = FreePageBtreeSearchLeaf(btp, first_page);\n\n\t/* Assemble results. */\n\tresult->page = btp;\n\tresult->index = index;\n\tresult->found = index < btp->hdr.nused &&\n\t\tfirst_page == btp->u.leaf_key[index].first_page;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))",
            "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtree *btp = relptr_access(base, fpm->btree_root);\n\tSize\t\tindex;\n\n\tresult->split_pages = 1;\n\n\t/* If the btree is empty, there's nothing to find. */\n\tif (btp == NULL)\n\t{\n\t\tresult->page = NULL;\n\t\tresult->found = false;\n\t\treturn;\n\t}\n\n\t/* Descend until we hit a leaf. */\n\twhile (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t{\n\t\tFreePageBtree *child;\n\t\tbool\t\tfound_exact;\n\n\t\tindex = FreePageBtreeSearchInternal(btp, first_page);\n\t\tfound_exact = index < btp->hdr.nused &&\n\t\t\tbtp->u.internal_key[index].first_page == first_page;\n\n\t\t/*\n\t\t * If we found an exact match we descend directly.  Otherwise, we\n\t\t * descend into the child to the left if possible so that we can find\n\t\t * the insertion point at that child's high end.\n\t\t */\n\t\tif (!found_exact && index > 0)\n\t\t\t--index;\n\n\t\t/* Track required split depth for leaf insert. */\n\t\tif (btp->hdr.nused >= FPM_ITEMS_PER_INTERNAL_PAGE)\n\t\t{\n\t\t\tAssert(btp->hdr.nused == FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\t\tresult->split_pages++;\n\t\t}\n\t\telse\n\t\t\tresult->split_pages = 0;\n\n\t\t/* Descend to appropriate child page. */\n\t\tAssert(index < btp->hdr.nused);\n\t\tchild = relptr_access(base, btp->u.internal_key[index].child);\n\t\tAssert(relptr_access(base, child->hdr.parent) == btp);\n\t\tbtp = child;\n\t}\n\n\t/* Track required split depth for leaf insert. */\n\tif (btp->hdr.nused >= FPM_ITEMS_PER_LEAF_PAGE)\n\t{\n\t\tAssert(btp->hdr.nused == FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\tresult->split_pages++;\n\t}\n\telse\n\t\tresult->split_pages = 0;\n\n\t/* Search leaf page. */\n\tindex = FreePageBtreeSearchLeaf(btp, first_page);\n\n\t/* Assemble results. */\n\tresult->page = btp;\n\tresult->index = index;\n\tresult->found = index < btp->hdr.nused &&\n\t\tfirst_page == btp->u.leaf_key[index].first_page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "victim->npages >= npages"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "victim->npages == fpm->singleton_npages"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "victim_page == fpm->singleton_first_page"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_is_null",
          "args": [
            "fpm->btree_root"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_is_null",
          "args": [
            "fpm->freelist[f]"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_pointer_to_page",
          "args": [
            "base",
            "victim"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_copy",
          "args": [
            "next->prev",
            "victim->prev"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_copy",
          "args": [
            "fpm->freelist[f]",
            "victim->next"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_copy",
          "args": [
            "prev->next",
            "victim->next"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "victim->next"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "victim->prev"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "victim->magic == FREE_PAGE_SPAN_LEADER_MAGIC"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "candidate->next"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "fpm->freelist[f]"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "fpm->freelist[f]"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_is_null",
          "args": [
            "fpm->freelist[f]"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "npages",
            "FPM_NUM_FREELISTS"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_segment_base",
          "args": [
            "fpm"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic bool\nFreePageManagerGetInternal(FreePageManager *fpm, Size npages, Size *first_page)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *victim = NULL;\n\tFreePageSpanLeader *prev;\n\tFreePageSpanLeader *next;\n\tFreePageBtreeSearchResult result;\n\tSize\t\tvictim_page = 0;\t/* placate compiler */\n\tSize\t\tf;\n\n\t/*\n\t * Search for a free span.\n\t *\n\t * Right now, we use a simple best-fit policy here, but it's possible for\n\t * this to result in memory fragmentation if we're repeatedly asked to\n\t * allocate chunks just a little smaller than what we have available.\n\t * Hopefully, this is unlikely, because we expect most requests to be\n\t * single pages or superblock-sized chunks -- but no policy can be optimal\n\t * under all circumstances unless it has knowledge of future allocation\n\t * patterns.\n\t */\n\tfor (f = Min(npages, FPM_NUM_FREELISTS) - 1; f < FPM_NUM_FREELISTS; ++f)\n\t{\n\t\t/* Skip empty freelists. */\n\t\tif (relptr_is_null(fpm->freelist[f]))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All of the freelists except the last one contain only items of a\n\t\t * single size, so we just take the first one.  But the final free\n\t\t * list contains everything too big for any of the other lists, so we\n\t\t * need to search the list.\n\t\t */\n\t\tif (f < FPM_NUM_FREELISTS - 1)\n\t\t\tvictim = relptr_access(base, fpm->freelist[f]);\n\t\telse\n\t\t{\n\t\t\tFreePageSpanLeader *candidate;\n\n\t\t\tcandidate = relptr_access(base, fpm->freelist[f]);\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (candidate->npages >= npages && (victim == NULL ||\n\t\t\t\t\t\t\t\t\t\t\t\t\tvictim->npages > candidate->npages))\n\t\t\t\t{\n\t\t\t\t\tvictim = candidate;\n\t\t\t\t\tif (victim->npages == npages)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t\t} while (candidate != NULL);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* If we didn't find an allocatable span, return failure. */\n\tif (victim == NULL)\n\t\treturn false;\n\n\t/* Remove span from free list. */\n\tAssert(victim->magic == FREE_PAGE_SPAN_LEADER_MAGIC);\n\tprev = relptr_access(base, victim->prev);\n\tnext = relptr_access(base, victim->next);\n\tif (prev != NULL)\n\t\trelptr_copy(prev->next, victim->next);\n\telse\n\t\trelptr_copy(fpm->freelist[f], victim->next);\n\tif (next != NULL)\n\t\trelptr_copy(next->prev, victim->prev);\n\tvictim_page = fpm_pointer_to_page(base, victim);\n\n\t/* Decide whether we might be invalidating contiguous_pages. */\n\tif (f == FPM_NUM_FREELISTS - 1 &&\n\t\tvictim->npages == fpm->contiguous_pages)\n\t{\n\t\t/*\n\t\t * The victim span came from the oversized freelist, and had the same\n\t\t * size as the longest span.  There may or may not be another one of\n\t\t * the same size, so contiguous_pages must be recomputed just to be\n\t\t * safe.\n\t\t */\n\t\tfpm->contiguous_pages_dirty = true;\n\t}\n\telse if (f + 1 == fpm->contiguous_pages &&\n\t\t\t relptr_is_null(fpm->freelist[f]))\n\t{\n\t\t/*\n\t\t * The victim span came from a fixed sized freelist, and it was the\n\t\t * list for spans of the same size as the current longest span, and\n\t\t * the list is now empty after removing the victim.  So\n\t\t * contiguous_pages must be recomputed without a doubt.\n\t\t */\n\t\tfpm->contiguous_pages_dirty = true;\n\t}\n\n\t/*\n\t * If we haven't initialized the btree yet, the victim must be the single\n\t * span stored within the FreePageManager itself.  Otherwise, we need to\n\t * update the btree.\n\t */\n\tif (relptr_is_null(fpm->btree_root))\n\t{\n\t\tAssert(victim_page == fpm->singleton_first_page);\n\t\tAssert(victim->npages == fpm->singleton_npages);\n\t\tAssert(victim->npages >= npages);\n\t\tfpm->singleton_first_page += npages;\n\t\tfpm->singleton_npages -= npages;\n\t\tif (fpm->singleton_npages > 0)\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If the span we found is exactly the right size, remove it from the\n\t\t * btree completely.  Otherwise, adjust the btree entry to reflect the\n\t\t * still-unallocated portion of the span, and put that portion on the\n\t\t * appropriate free list.\n\t\t */\n\t\tFreePageBtreeSearch(fpm, victim_page, &result);\n\t\tAssert(result.found);\n\t\tif (victim->npages == npages)\n\t\t\tFreePageBtreeRemove(fpm, result.page, result.index);\n\t\telse\n\t\t{\n\t\t\tFreePageBtreeLeafKey *key;\n\n\t\t\t/* Adjust btree to reflect remaining pages. */\n\t\t\tAssert(victim->npages > npages);\n\t\t\tkey = &result.page->u.leaf_key[result.index];\n\t\t\tAssert(key->npages == victim->npages);\n\t\t\tkey->first_page += npages;\n\t\t\tkey->npages -= npages;\n\t\t\tif (result.index == 0)\n\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, result.page);\n\n\t\t\t/* Put the unallocated pages back on the appropriate free list. */\n\t\t\tFreePagePushSpanLeader(fpm, victim_page + npages,\n\t\t\t\t\t\t\t\t   victim->npages - npages);\n\t\t}\n\t}\n\n\t/* Return results to caller. */\n\t*first_page = fpm_pointer_to_page(base, victim);\n\treturn true;\n}"
  },
  {
    "function_name": "FreePageManagerDumpSpans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "1295-1312",
    "snippet": "static void\nFreePageManagerDumpSpans(FreePageManager *fpm, FreePageSpanLeader *span,\n\t\t\t\t\t\t Size expected_pages, StringInfo buf)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\n\twhile (span != NULL)\n\t{\n\t\tif (span->npages != expected_pages)\n\t\t\tappendStringInfo(buf, \" %zu(%zu)\", fpm_pointer_to_page(base, span),\n\t\t\t\t\t\t\t span->npages);\n\t\telse\n\t\t\tappendStringInfo(buf, \" %zu\", fpm_pointer_to_page(base, span));\n\t\tspan = relptr_access(base, span->next);\n\t}\n\n\tappendStringInfoChar(buf, '\\n');\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
      "static void FreePageManagerDumpBtree(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\t\t FreePageBtree *parent, int level, StringInfo buf);",
      "static void FreePageManagerDumpSpans(FreePageManager *fpm,\n\t\t\t\t\t\t FreePageSpanLeader *span, Size expected_pages,\n\t\t\t\t\t\t StringInfo buf);",
      "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "span->next"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\" %zu\"",
            "fpm_pointer_to_page(base, span)"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_pointer_to_page",
          "args": [
            "base",
            "span"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\" %zu(%zu)\"",
            "fpm_pointer_to_page(base, span)",
            "span->npages"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_pointer_to_page",
          "args": [
            "base",
            "span"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_segment_base",
          "args": [
            "fpm"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageManagerDumpBtree(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\t\t FreePageBtree *parent, int level, StringInfo buf);\nstatic void FreePageManagerDumpSpans(FreePageManager *fpm,\n\t\t\t\t\t\t FreePageSpanLeader *span, Size expected_pages,\n\t\t\t\t\t\t StringInfo buf);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageManagerDumpSpans(FreePageManager *fpm, FreePageSpanLeader *span,\n\t\t\t\t\t\t Size expected_pages, StringInfo buf)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\n\twhile (span != NULL)\n\t{\n\t\tif (span->npages != expected_pages)\n\t\t\tappendStringInfo(buf, \" %zu(%zu)\", fpm_pointer_to_page(base, span),\n\t\t\t\t\t\t\t span->npages);\n\t\telse\n\t\t\tappendStringInfo(buf, \" %zu\", fpm_pointer_to_page(base, span));\n\t\tspan = relptr_access(base, span->next);\n\t}\n\n\tappendStringInfoChar(buf, '\\n');\n}"
  },
  {
    "function_name": "FreePageManagerDumpBtree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "1249-1290",
    "snippet": "static void\nFreePageManagerDumpBtree(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\t\t FreePageBtree *parent, int level, StringInfo buf)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tpageno = fpm_pointer_to_page(base, btp);\n\tSize\t\tindex;\n\tFreePageBtree *check_parent;\n\n\tcheck_stack_depth();\n\tcheck_parent = relptr_access(base, btp->hdr.parent);\n\tappendStringInfo(buf, \"  %zu@%d %c\", pageno, level,\n\t\t\t\t\t btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC ? 'i' : 'l');\n\tif (parent != check_parent)\n\t\tappendStringInfo(buf, \" [actual parent %zu, expected %zu]\",\n\t\t\t\t\t\t fpm_pointer_to_page(base, check_parent),\n\t\t\t\t\t\t fpm_pointer_to_page(base, parent));\n\tappendStringInfoChar(buf, ':');\n\tfor (index = 0; index < btp->hdr.nused; ++index)\n\t{\n\t\tif (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t\t\tappendStringInfo(buf, \" %zu->%zu\",\n\t\t\t\t\t\t\t btp->u.internal_key[index].first_page,\n\t\t\t\t\t\t\t btp->u.internal_key[index].child.relptr_off / FPM_PAGE_SIZE);\n\t\telse\n\t\t\tappendStringInfo(buf, \" %zu(%zu)\",\n\t\t\t\t\t\t\t btp->u.leaf_key[index].first_page,\n\t\t\t\t\t\t\t btp->u.leaf_key[index].npages);\n\t}\n\tappendStringInfoChar(buf, '\\n');\n\n\tif (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t{\n\t\tfor (index = 0; index < btp->hdr.nused; ++index)\n\t\t{\n\t\t\tFreePageBtree *child;\n\n\t\t\tchild = relptr_access(base, btp->u.internal_key[index].child);\n\t\t\tFreePageManagerDumpBtree(fpm, child, btp, level + 1, buf);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
    ],
    "globals_used": [
      "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
      "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
      "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
      "static void FreePageBtreeRecycle(FreePageManager *fpm, Size pageno);",
      "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
      "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
      "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
      "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
      "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
      "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
      "static void FreePageManagerDumpBtree(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\t\t FreePageBtree *parent, int level, StringInfo buf);",
      "static void FreePageManagerDumpSpans(FreePageManager *fpm,\n\t\t\t\t\t\t FreePageSpanLeader *span, Size expected_pages,\n\t\t\t\t\t\t StringInfo buf);",
      "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
      "static void FreePagePopSpanLeader(FreePageManager *fpm, Size pageno);",
      "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreePageManagerDumpBtree",
          "args": [
            "fpm",
            "child",
            "btp",
            "level + 1",
            "buf"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageManagerDumpBtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1249-1290",
          "snippet": "static void\nFreePageManagerDumpBtree(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\t\t FreePageBtree *parent, int level, StringInfo buf)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tpageno = fpm_pointer_to_page(base, btp);\n\tSize\t\tindex;\n\tFreePageBtree *check_parent;\n\n\tcheck_stack_depth();\n\tcheck_parent = relptr_access(base, btp->hdr.parent);\n\tappendStringInfo(buf, \"  %zu@%d %c\", pageno, level,\n\t\t\t\t\t btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC ? 'i' : 'l');\n\tif (parent != check_parent)\n\t\tappendStringInfo(buf, \" [actual parent %zu, expected %zu]\",\n\t\t\t\t\t\t fpm_pointer_to_page(base, check_parent),\n\t\t\t\t\t\t fpm_pointer_to_page(base, parent));\n\tappendStringInfoChar(buf, ':');\n\tfor (index = 0; index < btp->hdr.nused; ++index)\n\t{\n\t\tif (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t\t\tappendStringInfo(buf, \" %zu->%zu\",\n\t\t\t\t\t\t\t btp->u.internal_key[index].first_page,\n\t\t\t\t\t\t\t btp->u.internal_key[index].child.relptr_off / FPM_PAGE_SIZE);\n\t\telse\n\t\t\tappendStringInfo(buf, \" %zu(%zu)\",\n\t\t\t\t\t\t\t btp->u.leaf_key[index].first_page,\n\t\t\t\t\t\t\t btp->u.leaf_key[index].npages);\n\t}\n\tappendStringInfoChar(buf, '\\n');\n\n\tif (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t{\n\t\tfor (index = 0; index < btp->hdr.nused; ++index)\n\t\t{\n\t\t\tFreePageBtree *child;\n\n\t\t\tchild = relptr_access(base, btp->u.internal_key[index].child);\n\t\t\tFreePageManagerDumpBtree(fpm, child, btp, level + 1, buf);\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "btp->u.internal_key[index].child"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\" %zu(%zu)\"",
            "btp->u.leaf_key[index].first_page",
            "btp->u.leaf_key[index].npages"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\" %zu->%zu\"",
            "btp->u.internal_key[index].first_page",
            "btp->u.internal_key[index].child.relptr_off / FPM_PAGE_SIZE"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "buf",
            "':'"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\" [actual parent %zu, expected %zu]\"",
            "fpm_pointer_to_page(base, check_parent)",
            "fpm_pointer_to_page(base, parent)"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_pointer_to_page",
          "args": [
            "base",
            "parent"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_pointer_to_page",
          "args": [
            "base",
            "check_parent"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"  %zu@%d %c\"",
            "pageno",
            "level",
            "btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC ? 'i' : 'l'"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "appendStringInfoRegexpSubstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "3944-4037",
          "snippet": "static void\nappendStringInfoRegexpSubstr(StringInfo str, text *replace_text,\n\t\t\t\t\t\t\t regmatch_t *pmatch,\n\t\t\t\t\t\t\t char *start_ptr, int data_pos)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\tint\t\t\teml = pg_database_encoding_max_length();\n\n\tfor (;;)\n\t{\n\t\tconst char *chunk_start = p;\n\t\tint\t\t\tso;\n\t\tint\t\t\teo;\n\n\t\t/* Find next escape char. */\n\t\tif (eml == 1)\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p++)\n\t\t\t\t /* nothing */ ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p += pg_mblen(p))\n\t\t\t\t /* nothing */ ;\n\t\t}\n\n\t\t/* Copy the text we just scanned over, if any. */\n\t\tif (p > chunk_start)\n\t\t\tappendBinaryStringInfo(str, chunk_start, p - chunk_start);\n\n\t\t/* Done if at end of string, else advance over escape char. */\n\t\tif (p >= p_end)\n\t\t\tbreak;\n\t\tp++;\n\n\t\tif (p >= p_end)\n\t\t{\n\t\t\t/* Escape at very end of input.  Treat same as unexpected char */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p >= '1' && *p <= '9')\n\t\t{\n\t\t\t/* Use the back reference of regexp. */\n\t\t\tint\t\t\tidx = *p - '0';\n\n\t\t\tso = pmatch[idx].rm_so;\n\t\t\teo = pmatch[idx].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '&')\n\t\t{\n\t\t\t/* Use the entire matched string. */\n\t\t\tso = pmatch[0].rm_so;\n\t\t\teo = pmatch[0].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '\\\\')\n\t\t{\n\t\t\t/* \\\\ means transfer one \\ to output. */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If escape char is not followed by any expected char, just treat\n\t\t\t * it as ordinary data to copy.  (XXX would it be better to throw\n\t\t\t * an error?)\n\t\t\t */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (so != -1 && eo != -1)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy the text that is back reference of regexp.  Note so and eo\n\t\t\t * are counted in characters not bytes.\n\t\t\t */\n\t\t\tchar\t   *chunk_start;\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tAssert(so >= data_pos);\n\t\t\tchunk_start = start_ptr;\n\t\t\tchunk_start += charlen_to_bytelen(chunk_start, so - data_pos);\n\t\t\tchunk_len = charlen_to_bytelen(chunk_start, eo - so);\n\t\t\tappendBinaryStringInfo(str, chunk_start, chunk_len);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\n\nstatic void\nappendStringInfoRegexpSubstr(StringInfo str, text *replace_text,\n\t\t\t\t\t\t\t regmatch_t *pmatch,\n\t\t\t\t\t\t\t char *start_ptr, int data_pos)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\tint\t\t\teml = pg_database_encoding_max_length();\n\n\tfor (;;)\n\t{\n\t\tconst char *chunk_start = p;\n\t\tint\t\t\tso;\n\t\tint\t\t\teo;\n\n\t\t/* Find next escape char. */\n\t\tif (eml == 1)\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p++)\n\t\t\t\t /* nothing */ ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p += pg_mblen(p))\n\t\t\t\t /* nothing */ ;\n\t\t}\n\n\t\t/* Copy the text we just scanned over, if any. */\n\t\tif (p > chunk_start)\n\t\t\tappendBinaryStringInfo(str, chunk_start, p - chunk_start);\n\n\t\t/* Done if at end of string, else advance over escape char. */\n\t\tif (p >= p_end)\n\t\t\tbreak;\n\t\tp++;\n\n\t\tif (p >= p_end)\n\t\t{\n\t\t\t/* Escape at very end of input.  Treat same as unexpected char */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p >= '1' && *p <= '9')\n\t\t{\n\t\t\t/* Use the back reference of regexp. */\n\t\t\tint\t\t\tidx = *p - '0';\n\n\t\t\tso = pmatch[idx].rm_so;\n\t\t\teo = pmatch[idx].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '&')\n\t\t{\n\t\t\t/* Use the entire matched string. */\n\t\t\tso = pmatch[0].rm_so;\n\t\t\teo = pmatch[0].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '\\\\')\n\t\t{\n\t\t\t/* \\\\ means transfer one \\ to output. */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If escape char is not followed by any expected char, just treat\n\t\t\t * it as ordinary data to copy.  (XXX would it be better to throw\n\t\t\t * an error?)\n\t\t\t */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (so != -1 && eo != -1)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy the text that is back reference of regexp.  Note so and eo\n\t\t\t * are counted in characters not bytes.\n\t\t\t */\n\t\t\tchar\t   *chunk_start;\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tAssert(so >= data_pos);\n\t\t\tchunk_start = start_ptr;\n\t\t\tchunk_start += charlen_to_bytelen(chunk_start, so - data_pos);\n\t\t\tchunk_len = charlen_to_bytelen(chunk_start, eo - so);\n\t\t\tappendBinaryStringInfo(str, chunk_start, chunk_len);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "btp->hdr.parent"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_pointer_to_page",
          "args": [
            "base",
            "btp"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_segment_base",
          "args": [
            "fpm"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRecycle(FreePageManager *fpm, Size pageno);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic void FreePageManagerDumpBtree(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\t\t FreePageBtree *parent, int level, StringInfo buf);\nstatic void FreePageManagerDumpSpans(FreePageManager *fpm,\n\t\t\t\t\t\t FreePageSpanLeader *span, Size expected_pages,\n\t\t\t\t\t\t StringInfo buf);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePopSpanLeader(FreePageManager *fpm, Size pageno);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageManagerDumpBtree(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\t\t FreePageBtree *parent, int level, StringInfo buf)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tpageno = fpm_pointer_to_page(base, btp);\n\tSize\t\tindex;\n\tFreePageBtree *check_parent;\n\n\tcheck_stack_depth();\n\tcheck_parent = relptr_access(base, btp->hdr.parent);\n\tappendStringInfo(buf, \"  %zu@%d %c\", pageno, level,\n\t\t\t\t\t btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC ? 'i' : 'l');\n\tif (parent != check_parent)\n\t\tappendStringInfo(buf, \" [actual parent %zu, expected %zu]\",\n\t\t\t\t\t\t fpm_pointer_to_page(base, check_parent),\n\t\t\t\t\t\t fpm_pointer_to_page(base, parent));\n\tappendStringInfoChar(buf, ':');\n\tfor (index = 0; index < btp->hdr.nused; ++index)\n\t{\n\t\tif (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t\t\tappendStringInfo(buf, \" %zu->%zu\",\n\t\t\t\t\t\t\t btp->u.internal_key[index].first_page,\n\t\t\t\t\t\t\t btp->u.internal_key[index].child.relptr_off / FPM_PAGE_SIZE);\n\t\telse\n\t\t\tappendStringInfo(buf, \" %zu(%zu)\",\n\t\t\t\t\t\t\t btp->u.leaf_key[index].first_page,\n\t\t\t\t\t\t\t btp->u.leaf_key[index].npages);\n\t}\n\tappendStringInfoChar(buf, '\\n');\n\n\tif (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t{\n\t\tfor (index = 0; index < btp->hdr.nused; ++index)\n\t\t{\n\t\t\tFreePageBtree *child;\n\n\t\t\tchild = relptr_access(base, btp->u.internal_key[index].child);\n\t\t\tFreePageManagerDumpBtree(fpm, child, btp, level + 1, buf);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "FreePageBtreeUpdateParentPointers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "1231-1244",
    "snippet": "static void\nFreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp)\n{\n\tSize\t\ti;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tfor (i = 0; i < btp->hdr.nused; ++i)\n\t{\n\t\tFreePageBtree *child;\n\n\t\tchild = relptr_access(base, btp->u.internal_key[i].child);\n\t\trelptr_store(base, child->hdr.parent, btp);\n\t}\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
    ],
    "globals_used": [
      "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
      "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
      "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
      "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
      "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "child->hdr.parent",
            "btp"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "btp->u.internal_key[i].child"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\n\nstatic void\nFreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp)\n{\n\tSize\t\ti;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tfor (i = 0; i < btp->hdr.nused; ++i)\n\t{\n\t\tFreePageBtree *child;\n\n\t\tchild = relptr_access(base, btp->u.internal_key[i].child);\n\t\trelptr_store(base, child->hdr.parent, btp);\n\t}\n}"
  },
  {
    "function_name": "FreePageBtreeSplitPage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "1200-1225",
    "snippet": "static FreePageBtree *\nFreePageBtreeSplitPage(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tFreePageBtree *newsibling;\n\n\tnewsibling = FreePageBtreeGetRecycled(fpm);\n\tnewsibling->hdr.magic = btp->hdr.magic;\n\tnewsibling->hdr.nused = btp->hdr.nused / 2;\n\trelptr_copy(newsibling->hdr.parent, btp->hdr.parent);\n\tbtp->hdr.nused -= newsibling->hdr.nused;\n\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\tmemcpy(&newsibling->u.leaf_key,\n\t\t\t   &btp->u.leaf_key[btp->hdr.nused],\n\t\t\t   sizeof(FreePageBtreeLeafKey) * newsibling->hdr.nused);\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tmemcpy(&newsibling->u.internal_key,\n\t\t\t   &btp->u.internal_key[btp->hdr.nused],\n\t\t\t   sizeof(FreePageBtreeInternalKey) * newsibling->hdr.nused);\n\t\tFreePageBtreeUpdateParentPointers(fpm_segment_base(fpm), newsibling);\n\t}\n\n\treturn newsibling;\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
      "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
    ],
    "globals_used": [
      "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
      "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
      "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreePageBtreeUpdateParentPointers",
          "args": [
            "fpm_segment_base(fpm)",
            "newsibling"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeUpdateParentPointers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1231-1244",
          "snippet": "static void\nFreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp)\n{\n\tSize\t\ti;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tfor (i = 0; i < btp->hdr.nused; ++i)\n\t{\n\t\tFreePageBtree *child;\n\n\t\tchild = relptr_access(base, btp->u.internal_key[i].child);\n\t\trelptr_store(base, child->hdr.parent, btp);\n\t}\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\n\nstatic void\nFreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp)\n{\n\tSize\t\ti;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tfor (i = 0; i < btp->hdr.nused; ++i)\n\t{\n\t\tFreePageBtree *child;\n\n\t\tchild = relptr_access(base, btp->u.internal_key[i].child);\n\t\trelptr_store(base, child->hdr.parent, btp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fpm_segment_base",
          "args": [
            "fpm"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&newsibling->u.internal_key",
            "&btp->u.internal_key[btp->hdr.nused]",
            "sizeof(FreePageBtreeInternalKey) * newsibling->hdr.nused"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&newsibling->u.leaf_key",
            "&btp->u.leaf_key[btp->hdr.nused]",
            "sizeof(FreePageBtreeLeafKey) * newsibling->hdr.nused"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_copy",
          "args": [
            "newsibling->hdr.parent",
            "btp->hdr.parent"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeGetRecycled",
          "args": [
            "fpm"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeGetRecycled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "879-894",
          "snippet": "static FreePageBtree *\nFreePageBtreeGetRecycled(FreePageManager *fpm)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *victim = relptr_access(base, fpm->btree_recycle);\n\tFreePageSpanLeader *newhead;\n\n\tAssert(victim != NULL);\n\tnewhead = relptr_access(base, victim->next);\n\tif (newhead != NULL)\n\t\trelptr_copy(newhead->prev, victim->prev);\n\trelptr_store(base, fpm->btree_recycle, newhead);\n\tAssert(fpm_pointer_is_page_aligned(base, victim));\n\tfpm->btree_recycle_count--;\n\treturn (FreePageBtree *) victim;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic FreePageBtree *\nFreePageBtreeGetRecycled(FreePageManager *fpm)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *victim = relptr_access(base, fpm->btree_recycle);\n\tFreePageSpanLeader *newhead;\n\n\tAssert(victim != NULL);\n\tnewhead = relptr_access(base, victim->next);\n\tif (newhead != NULL)\n\t\trelptr_copy(newhead->prev, victim->prev);\n\trelptr_store(base, fpm->btree_recycle, newhead);\n\tAssert(fpm_pointer_is_page_aligned(base, victim));\n\tfpm->btree_recycle_count--;\n\treturn (FreePageBtree *) victim;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic FreePageBtree *\nFreePageBtreeSplitPage(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tFreePageBtree *newsibling;\n\n\tnewsibling = FreePageBtreeGetRecycled(fpm);\n\tnewsibling->hdr.magic = btp->hdr.magic;\n\tnewsibling->hdr.nused = btp->hdr.nused / 2;\n\trelptr_copy(newsibling->hdr.parent, btp->hdr.parent);\n\tbtp->hdr.nused -= newsibling->hdr.nused;\n\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\tmemcpy(&newsibling->u.leaf_key,\n\t\t\t   &btp->u.leaf_key[btp->hdr.nused],\n\t\t\t   sizeof(FreePageBtreeLeafKey) * newsibling->hdr.nused);\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tmemcpy(&newsibling->u.internal_key,\n\t\t\t   &btp->u.internal_key[btp->hdr.nused],\n\t\t\t   sizeof(FreePageBtreeInternalKey) * newsibling->hdr.nused);\n\t\tFreePageBtreeUpdateParentPointers(fpm_segment_base(fpm), newsibling);\n\t}\n\n\treturn newsibling;\n}"
  },
  {
    "function_name": "FreePageBtreeSearchLeaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "1169-1192",
    "snippet": "static Size\nFreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_LEAF_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.leaf_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))",
      "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
    ],
    "globals_used": [
      "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
      "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
      "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
      "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
      "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
      "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
      "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
      "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "high > 0 && high <= FPM_ITEMS_PER_LEAF_PAGE"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "btp->hdr.magic == FREE_PAGE_LEAF_MAGIC"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic Size\nFreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_LEAF_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.leaf_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}"
  },
  {
    "function_name": "FreePageBtreeSearchInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "1139-1162",
    "snippet": "static Size\nFreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.internal_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
      "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
    ],
    "globals_used": [
      "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
      "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
      "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
      "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
      "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
      "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
      "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
      "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "high > 0 && high <= FPM_ITEMS_PER_INTERNAL_PAGE"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic Size\nFreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.internal_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}"
  },
  {
    "function_name": "FreePageBtreeSearch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "1063-1132",
    "snippet": "static void\nFreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtree *btp = relptr_access(base, fpm->btree_root);\n\tSize\t\tindex;\n\n\tresult->split_pages = 1;\n\n\t/* If the btree is empty, there's nothing to find. */\n\tif (btp == NULL)\n\t{\n\t\tresult->page = NULL;\n\t\tresult->found = false;\n\t\treturn;\n\t}\n\n\t/* Descend until we hit a leaf. */\n\twhile (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t{\n\t\tFreePageBtree *child;\n\t\tbool\t\tfound_exact;\n\n\t\tindex = FreePageBtreeSearchInternal(btp, first_page);\n\t\tfound_exact = index < btp->hdr.nused &&\n\t\t\tbtp->u.internal_key[index].first_page == first_page;\n\n\t\t/*\n\t\t * If we found an exact match we descend directly.  Otherwise, we\n\t\t * descend into the child to the left if possible so that we can find\n\t\t * the insertion point at that child's high end.\n\t\t */\n\t\tif (!found_exact && index > 0)\n\t\t\t--index;\n\n\t\t/* Track required split depth for leaf insert. */\n\t\tif (btp->hdr.nused >= FPM_ITEMS_PER_INTERNAL_PAGE)\n\t\t{\n\t\t\tAssert(btp->hdr.nused == FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\t\tresult->split_pages++;\n\t\t}\n\t\telse\n\t\t\tresult->split_pages = 0;\n\n\t\t/* Descend to appropriate child page. */\n\t\tAssert(index < btp->hdr.nused);\n\t\tchild = relptr_access(base, btp->u.internal_key[index].child);\n\t\tAssert(relptr_access(base, child->hdr.parent) == btp);\n\t\tbtp = child;\n\t}\n\n\t/* Track required split depth for leaf insert. */\n\tif (btp->hdr.nused >= FPM_ITEMS_PER_LEAF_PAGE)\n\t{\n\t\tAssert(btp->hdr.nused == FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\tresult->split_pages++;\n\t}\n\telse\n\t\tresult->split_pages = 0;\n\n\t/* Search leaf page. */\n\tindex = FreePageBtreeSearchLeaf(btp, first_page);\n\n\t/* Assemble results. */\n\tresult->page = btp;\n\tresult->index = index;\n\tresult->found = index < btp->hdr.nused &&\n\t\tfirst_page == btp->u.leaf_key[index].first_page;\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))",
      "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
      "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
    ],
    "globals_used": [
      "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
      "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
      "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
      "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
      "static void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);",
      "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
      "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
      "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
      "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
      "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreePageBtreeSearchLeaf",
          "args": [
            "btp",
            "first_page"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeSearchLeaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1169-1192",
          "snippet": "static Size\nFreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_LEAF_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.leaf_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))",
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic Size\nFreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_LEAF_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.leaf_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "btp->hdr.nused == FPM_ITEMS_PER_INTERNAL_PAGE"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "relptr_access(base, child->hdr.parent) == btp"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "child->hdr.parent"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "btp->u.internal_key[index].child"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "index < btp->hdr.nused"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "btp->hdr.nused == FPM_ITEMS_PER_INTERNAL_PAGE"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeSearchInternal",
          "args": [
            "btp",
            "first_page"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeSearchInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1139-1162",
          "snippet": "static Size\nFreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.internal_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic Size\nFreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.internal_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}"
        }
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "fpm->btree_root"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_segment_base",
          "args": [
            "fpm"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtree *btp = relptr_access(base, fpm->btree_root);\n\tSize\t\tindex;\n\n\tresult->split_pages = 1;\n\n\t/* If the btree is empty, there's nothing to find. */\n\tif (btp == NULL)\n\t{\n\t\tresult->page = NULL;\n\t\tresult->found = false;\n\t\treturn;\n\t}\n\n\t/* Descend until we hit a leaf. */\n\twhile (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t{\n\t\tFreePageBtree *child;\n\t\tbool\t\tfound_exact;\n\n\t\tindex = FreePageBtreeSearchInternal(btp, first_page);\n\t\tfound_exact = index < btp->hdr.nused &&\n\t\t\tbtp->u.internal_key[index].first_page == first_page;\n\n\t\t/*\n\t\t * If we found an exact match we descend directly.  Otherwise, we\n\t\t * descend into the child to the left if possible so that we can find\n\t\t * the insertion point at that child's high end.\n\t\t */\n\t\tif (!found_exact && index > 0)\n\t\t\t--index;\n\n\t\t/* Track required split depth for leaf insert. */\n\t\tif (btp->hdr.nused >= FPM_ITEMS_PER_INTERNAL_PAGE)\n\t\t{\n\t\t\tAssert(btp->hdr.nused == FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\t\tresult->split_pages++;\n\t\t}\n\t\telse\n\t\t\tresult->split_pages = 0;\n\n\t\t/* Descend to appropriate child page. */\n\t\tAssert(index < btp->hdr.nused);\n\t\tchild = relptr_access(base, btp->u.internal_key[index].child);\n\t\tAssert(relptr_access(base, child->hdr.parent) == btp);\n\t\tbtp = child;\n\t}\n\n\t/* Track required split depth for leaf insert. */\n\tif (btp->hdr.nused >= FPM_ITEMS_PER_LEAF_PAGE)\n\t{\n\t\tAssert(btp->hdr.nused == FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\tresult->split_pages++;\n\t}\n\telse\n\t\tresult->split_pages = 0;\n\n\t/* Search leaf page. */\n\tindex = FreePageBtreeSearchLeaf(btp, first_page);\n\n\t/* Assemble results. */\n\tresult->page = btp;\n\tresult->index = index;\n\tresult->found = index < btp->hdr.nused &&\n\t\tfirst_page == btp->u.leaf_key[index].first_page;\n}"
  },
  {
    "function_name": "FreePageBtreeRemovePage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "986-1051",
    "snippet": "static void\nFreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtree *parent;\n\tSize\t\tindex;\n\tSize\t\tfirst_page;\n\n\tfor (;;)\n\t{\n\t\t/* Find parent page. */\n\t\tparent = relptr_access(base, btp->hdr.parent);\n\t\tif (parent == NULL)\n\t\t{\n\t\t\t/* We are removing the root page. */\n\t\t\trelptr_store(base, fpm->btree_root, (FreePageBtree *) NULL);\n\t\t\tfpm->btree_depth = 0;\n\t\t\tAssert(fpm->singleton_first_page == 0);\n\t\t\tAssert(fpm->singleton_npages == 0);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If the parent contains only one item, we need to remove it as well.\n\t\t */\n\t\tif (parent->hdr.nused > 1)\n\t\t\tbreak;\n\t\tFreePageBtreeRecycle(fpm, fpm_pointer_to_page(base, btp));\n\t\tbtp = parent;\n\t}\n\n\t/* Find and remove the downlink. */\n\tfirst_page = FreePageBtreeFirstKey(btp);\n\tif (parent->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t{\n\t\tindex = FreePageBtreeSearchLeaf(parent, first_page);\n\t\tAssert(index < parent->hdr.nused);\n\t\tif (index < parent->hdr.nused - 1)\n\t\t\tmemmove(&parent->u.leaf_key[index],\n\t\t\t\t\t&parent->u.leaf_key[index + 1],\n\t\t\t\t\tsizeof(FreePageBtreeLeafKey)\n\t\t\t\t\t* (parent->hdr.nused - index - 1));\n\t}\n\telse\n\t{\n\t\tindex = FreePageBtreeSearchInternal(parent, first_page);\n\t\tAssert(index < parent->hdr.nused);\n\t\tif (index < parent->hdr.nused - 1)\n\t\t\tmemmove(&parent->u.internal_key[index],\n\t\t\t\t\t&parent->u.internal_key[index + 1],\n\t\t\t\t\tsizeof(FreePageBtreeInternalKey)\n\t\t\t\t\t* (parent->hdr.nused - index - 1));\n\t}\n\tparent->hdr.nused--;\n\tAssert(parent->hdr.nused > 0);\n\n\t/* Recycle the page. */\n\tFreePageBtreeRecycle(fpm, fpm_pointer_to_page(base, btp));\n\n\t/* Adjust ancestor keys if needed. */\n\tif (index == 0)\n\t\tFreePageBtreeAdjustAncestorKeys(fpm, parent);\n\n\t/* Consider whether to consolidate the parent with a sibling. */\n\tFreePageBtreeConsolidate(fpm, parent);\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
    ],
    "globals_used": [
      "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
      "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
      "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
      "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
      "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
      "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
      "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
      "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreePageBtreeConsolidate",
          "args": [
            "fpm",
            "parent"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeConsolidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "694-767",
          "snippet": "static void\nFreePageBtreeConsolidate(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtree *np;\n\tSize\t\tmax;\n\n\t/*\n\t * We only try to consolidate pages that are less than a third full. We\n\t * could be more aggressive about this, but that might risk performing\n\t * consolidation only to end up splitting again shortly thereafter.  Since\n\t * the btree should be very small compared to the space under management,\n\t * our goal isn't so much to ensure that it always occupies the absolutely\n\t * smallest possible number of pages as to reclaim pages before things get\n\t * too egregiously out of hand.\n\t */\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\tmax = FPM_ITEMS_PER_LEAF_PAGE;\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tmax = FPM_ITEMS_PER_INTERNAL_PAGE;\n\t}\n\tif (btp->hdr.nused >= max / 3)\n\t\treturn;\n\n\t/*\n\t * If we can fit our right sibling's keys onto this page, consolidate.\n\t */\n\tnp = FreePageBtreeFindRightSibling(base, btp);\n\tif (np != NULL && btp->hdr.nused + np->hdr.nused <= max)\n\t{\n\t\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t{\n\t\t\tmemcpy(&btp->u.leaf_key[btp->hdr.nused], &np->u.leaf_key[0],\n\t\t\t\t   sizeof(FreePageBtreeLeafKey) * np->hdr.nused);\n\t\t\tbtp->hdr.nused += np->hdr.nused;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(&btp->u.internal_key[btp->hdr.nused], &np->u.internal_key[0],\n\t\t\t\t   sizeof(FreePageBtreeInternalKey) * np->hdr.nused);\n\t\t\tbtp->hdr.nused += np->hdr.nused;\n\t\t\tFreePageBtreeUpdateParentPointers(base, btp);\n\t\t}\n\t\tFreePageBtreeRemovePage(fpm, np);\n\t\treturn;\n\t}\n\n\t/*\n\t * If we can fit our keys onto our left sibling's page, consolidate. In\n\t * this case, we move our keys onto the other page rather than visca\n\t * versa, to avoid having to adjust ancestor keys.\n\t */\n\tnp = FreePageBtreeFindLeftSibling(base, btp);\n\tif (np != NULL && btp->hdr.nused + np->hdr.nused <= max)\n\t{\n\t\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t{\n\t\t\tmemcpy(&np->u.leaf_key[np->hdr.nused], &btp->u.leaf_key[0],\n\t\t\t\t   sizeof(FreePageBtreeLeafKey) * btp->hdr.nused);\n\t\t\tnp->hdr.nused += btp->hdr.nused;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(&np->u.internal_key[np->hdr.nused], &btp->u.internal_key[0],\n\t\t\t\t   sizeof(FreePageBtreeInternalKey) * btp->hdr.nused);\n\t\t\tnp->hdr.nused += btp->hdr.nused;\n\t\t\tFreePageBtreeUpdateParentPointers(base, np);\n\t\t}\n\t\tFreePageBtreeRemovePage(fpm, btp);\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))",
            "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeConsolidate(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtree *np;\n\tSize\t\tmax;\n\n\t/*\n\t * We only try to consolidate pages that are less than a third full. We\n\t * could be more aggressive about this, but that might risk performing\n\t * consolidation only to end up splitting again shortly thereafter.  Since\n\t * the btree should be very small compared to the space under management,\n\t * our goal isn't so much to ensure that it always occupies the absolutely\n\t * smallest possible number of pages as to reclaim pages before things get\n\t * too egregiously out of hand.\n\t */\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\tmax = FPM_ITEMS_PER_LEAF_PAGE;\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tmax = FPM_ITEMS_PER_INTERNAL_PAGE;\n\t}\n\tif (btp->hdr.nused >= max / 3)\n\t\treturn;\n\n\t/*\n\t * If we can fit our right sibling's keys onto this page, consolidate.\n\t */\n\tnp = FreePageBtreeFindRightSibling(base, btp);\n\tif (np != NULL && btp->hdr.nused + np->hdr.nused <= max)\n\t{\n\t\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t{\n\t\t\tmemcpy(&btp->u.leaf_key[btp->hdr.nused], &np->u.leaf_key[0],\n\t\t\t\t   sizeof(FreePageBtreeLeafKey) * np->hdr.nused);\n\t\t\tbtp->hdr.nused += np->hdr.nused;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(&btp->u.internal_key[btp->hdr.nused], &np->u.internal_key[0],\n\t\t\t\t   sizeof(FreePageBtreeInternalKey) * np->hdr.nused);\n\t\t\tbtp->hdr.nused += np->hdr.nused;\n\t\t\tFreePageBtreeUpdateParentPointers(base, btp);\n\t\t}\n\t\tFreePageBtreeRemovePage(fpm, np);\n\t\treturn;\n\t}\n\n\t/*\n\t * If we can fit our keys onto our left sibling's page, consolidate. In\n\t * this case, we move our keys onto the other page rather than visca\n\t * versa, to avoid having to adjust ancestor keys.\n\t */\n\tnp = FreePageBtreeFindLeftSibling(base, btp);\n\tif (np != NULL && btp->hdr.nused + np->hdr.nused <= max)\n\t{\n\t\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t{\n\t\t\tmemcpy(&np->u.leaf_key[np->hdr.nused], &btp->u.leaf_key[0],\n\t\t\t\t   sizeof(FreePageBtreeLeafKey) * btp->hdr.nused);\n\t\t\tnp->hdr.nused += btp->hdr.nused;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(&np->u.internal_key[np->hdr.nused], &btp->u.internal_key[0],\n\t\t\t\t   sizeof(FreePageBtreeInternalKey) * btp->hdr.nused);\n\t\t\tnp->hdr.nused += btp->hdr.nused;\n\t\t\tFreePageBtreeUpdateParentPointers(base, np);\n\t\t}\n\t\tFreePageBtreeRemovePage(fpm, btp);\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageBtreeAdjustAncestorKeys",
          "args": [
            "fpm",
            "parent"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeAdjustAncestorKeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "500-573",
          "snippet": "static void\nFreePageBtreeAdjustAncestorKeys(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tfirst_page;\n\tFreePageBtree *parent;\n\tFreePageBtree *child;\n\n\t/* This might be either a leaf or an internal page. */\n\tAssert(btp->hdr.nused > 0);\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t{\n\t\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_LEAF_PAGE);\n\t\tfirst_page = btp->u.leaf_key[0].first_page;\n\t}\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\tfirst_page = btp->u.internal_key[0].first_page;\n\t}\n\tchild = btp;\n\n\t/* Loop until we find an ancestor that does not require adjustment. */\n\tfor (;;)\n\t{\n\t\tSize\t\ts;\n\n\t\tparent = relptr_access(base, child->hdr.parent);\n\t\tif (parent == NULL)\n\t\t\tbreak;\n\t\ts = FreePageBtreeSearchInternal(parent, first_page);\n\n\t\t/* Key is either at index s or index s-1; figure out which. */\n\t\tif (s >= parent->hdr.nused)\n\t\t{\n\t\t\tAssert(s == parent->hdr.nused);\n\t\t\t--s;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFreePageBtree *check;\n\n\t\t\tcheck = relptr_access(base, parent->u.internal_key[s].child);\n\t\t\tif (check != child)\n\t\t\t{\n\t\t\t\tAssert(s > 0);\n\t\t\t\t--s;\n\t\t\t}\n\t\t}\n\n#ifdef USE_ASSERT_CHECKING\n\t\t/* Debugging double-check. */\n\t\t{\n\t\t\tFreePageBtree *check;\n\n\t\t\tcheck = relptr_access(base, parent->u.internal_key[s].child);\n\t\t\tAssert(s < parent->hdr.nused);\n\t\t\tAssert(child == check);\n\t\t}\n#endif\n\n\t\t/* Update the parent key. */\n\t\tparent->u.internal_key[s].first_page = first_page;\n\n\t\t/*\n\t\t * If this is the first key in the parent, go up another level; else\n\t\t * done.\n\t\t */\n\t\tif (s > 0)\n\t\t\tbreak;\n\t\tchild = parent;\n\t}\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))",
            "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeAdjustAncestorKeys(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tfirst_page;\n\tFreePageBtree *parent;\n\tFreePageBtree *child;\n\n\t/* This might be either a leaf or an internal page. */\n\tAssert(btp->hdr.nused > 0);\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t{\n\t\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_LEAF_PAGE);\n\t\tfirst_page = btp->u.leaf_key[0].first_page;\n\t}\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\tfirst_page = btp->u.internal_key[0].first_page;\n\t}\n\tchild = btp;\n\n\t/* Loop until we find an ancestor that does not require adjustment. */\n\tfor (;;)\n\t{\n\t\tSize\t\ts;\n\n\t\tparent = relptr_access(base, child->hdr.parent);\n\t\tif (parent == NULL)\n\t\t\tbreak;\n\t\ts = FreePageBtreeSearchInternal(parent, first_page);\n\n\t\t/* Key is either at index s or index s-1; figure out which. */\n\t\tif (s >= parent->hdr.nused)\n\t\t{\n\t\t\tAssert(s == parent->hdr.nused);\n\t\t\t--s;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFreePageBtree *check;\n\n\t\t\tcheck = relptr_access(base, parent->u.internal_key[s].child);\n\t\t\tif (check != child)\n\t\t\t{\n\t\t\t\tAssert(s > 0);\n\t\t\t\t--s;\n\t\t\t}\n\t\t}\n\n#ifdef USE_ASSERT_CHECKING\n\t\t/* Debugging double-check. */\n\t\t{\n\t\t\tFreePageBtree *check;\n\n\t\t\tcheck = relptr_access(base, parent->u.internal_key[s].child);\n\t\t\tAssert(s < parent->hdr.nused);\n\t\t\tAssert(child == check);\n\t\t}\n#endif\n\n\t\t/* Update the parent key. */\n\t\tparent->u.internal_key[s].first_page = first_page;\n\n\t\t/*\n\t\t * If this is the first key in the parent, go up another level; else\n\t\t * done.\n\t\t */\n\t\tif (s > 0)\n\t\t\tbreak;\n\t\tchild = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageBtreeRecycle",
          "args": [
            "fpm",
            "fpm_pointer_to_page(base, btp)"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeRecycle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "933-949",
          "snippet": "static void\nFreePageBtreeRecycle(FreePageManager *fpm, Size pageno)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *head = relptr_access(base, fpm->btree_recycle);\n\tFreePageSpanLeader *span;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, pageno);\n\tspan->magic = FREE_PAGE_SPAN_LEADER_MAGIC;\n\tspan->npages = 1;\n\trelptr_store(base, span->next, head);\n\trelptr_store(base, span->prev, (FreePageSpanLeader *) NULL);\n\tif (head != NULL)\n\t\trelptr_store(base, head->prev, span);\n\trelptr_store(base, fpm->btree_recycle, span);\n\tfpm->btree_recycle_count++;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0"
          ],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePageBtreeRecycle(FreePageManager *fpm, Size pageno);",
            "static void FreePagePopSpanLeader(FreePageManager *fpm, Size pageno);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRecycle(FreePageManager *fpm, Size pageno);\nstatic void FreePagePopSpanLeader(FreePageManager *fpm, Size pageno);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeRecycle(FreePageManager *fpm, Size pageno)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *head = relptr_access(base, fpm->btree_recycle);\n\tFreePageSpanLeader *span;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, pageno);\n\tspan->magic = FREE_PAGE_SPAN_LEADER_MAGIC;\n\tspan->npages = 1;\n\trelptr_store(base, span->next, head);\n\trelptr_store(base, span->prev, (FreePageSpanLeader *) NULL);\n\tif (head != NULL)\n\t\trelptr_store(base, head->prev, span);\n\trelptr_store(base, fpm->btree_recycle, span);\n\tfpm->btree_recycle_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fpm_pointer_to_page",
          "args": [
            "base",
            "btp"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "parent->hdr.nused > 0"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&parent->u.internal_key[index]",
            "&parent->u.internal_key[index + 1]",
            "sizeof(FreePageBtreeInternalKey)\n\t\t\t\t\t* (parent->hdr.nused - index - 1)"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "index < parent->hdr.nused"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeSearchInternal",
          "args": [
            "parent",
            "first_page"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeSearchInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1139-1162",
          "snippet": "static Size\nFreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.internal_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic Size\nFreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.internal_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&parent->u.leaf_key[index]",
            "&parent->u.leaf_key[index + 1]",
            "sizeof(FreePageBtreeLeafKey)\n\t\t\t\t\t* (parent->hdr.nused - index - 1)"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "index < parent->hdr.nused"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeSearchLeaf",
          "args": [
            "parent",
            "first_page"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeSearchLeaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1169-1192",
          "snippet": "static Size\nFreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_LEAF_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.leaf_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))",
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic Size\nFreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_LEAF_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.leaf_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageBtreeFirstKey",
          "args": [
            "btp"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeFirstKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "862-874",
          "snippet": "static Size\nFreePageBtreeFirstKey(FreePageBtree *btp)\n{\n\tAssert(btp->hdr.nused > 0);\n\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\treturn btp->u.leaf_key[0].first_page;\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\treturn btp->u.internal_key[0].first_page;\n\t}\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic Size\nFreePageBtreeFirstKey(FreePageBtree *btp)\n{\n\tAssert(btp->hdr.nused > 0);\n\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\treturn btp->u.leaf_key[0].first_page;\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\treturn btp->u.internal_key[0].first_page;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fpm_pointer_to_page",
          "args": [
            "base",
            "btp"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "fpm->singleton_npages == 0"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "fpm->singleton_first_page == 0"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "fpm->btree_root",
            "(FreePageBtree *) NULL"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "btp->hdr.parent"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_segment_base",
          "args": [
            "fpm"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtree *parent;\n\tSize\t\tindex;\n\tSize\t\tfirst_page;\n\n\tfor (;;)\n\t{\n\t\t/* Find parent page. */\n\t\tparent = relptr_access(base, btp->hdr.parent);\n\t\tif (parent == NULL)\n\t\t{\n\t\t\t/* We are removing the root page. */\n\t\t\trelptr_store(base, fpm->btree_root, (FreePageBtree *) NULL);\n\t\t\tfpm->btree_depth = 0;\n\t\t\tAssert(fpm->singleton_first_page == 0);\n\t\t\tAssert(fpm->singleton_npages == 0);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If the parent contains only one item, we need to remove it as well.\n\t\t */\n\t\tif (parent->hdr.nused > 1)\n\t\t\tbreak;\n\t\tFreePageBtreeRecycle(fpm, fpm_pointer_to_page(base, btp));\n\t\tbtp = parent;\n\t}\n\n\t/* Find and remove the downlink. */\n\tfirst_page = FreePageBtreeFirstKey(btp);\n\tif (parent->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t{\n\t\tindex = FreePageBtreeSearchLeaf(parent, first_page);\n\t\tAssert(index < parent->hdr.nused);\n\t\tif (index < parent->hdr.nused - 1)\n\t\t\tmemmove(&parent->u.leaf_key[index],\n\t\t\t\t\t&parent->u.leaf_key[index + 1],\n\t\t\t\t\tsizeof(FreePageBtreeLeafKey)\n\t\t\t\t\t* (parent->hdr.nused - index - 1));\n\t}\n\telse\n\t{\n\t\tindex = FreePageBtreeSearchInternal(parent, first_page);\n\t\tAssert(index < parent->hdr.nused);\n\t\tif (index < parent->hdr.nused - 1)\n\t\t\tmemmove(&parent->u.internal_key[index],\n\t\t\t\t\t&parent->u.internal_key[index + 1],\n\t\t\t\t\tsizeof(FreePageBtreeInternalKey)\n\t\t\t\t\t* (parent->hdr.nused - index - 1));\n\t}\n\tparent->hdr.nused--;\n\tAssert(parent->hdr.nused > 0);\n\n\t/* Recycle the page. */\n\tFreePageBtreeRecycle(fpm, fpm_pointer_to_page(base, btp));\n\n\t/* Adjust ancestor keys if needed. */\n\tif (index == 0)\n\t\tFreePageBtreeAdjustAncestorKeys(fpm, parent);\n\n\t/* Consider whether to consolidate the parent with a sibling. */\n\tFreePageBtreeConsolidate(fpm, parent);\n}"
  },
  {
    "function_name": "FreePageBtreeRemove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "954-979",
    "snippet": "static void\nFreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp, Size index)\n{\n\tAssert(btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\tAssert(index < btp->hdr.nused);\n\n\t/* When last item is removed, extirpate entire page from btree. */\n\tif (btp->hdr.nused == 1)\n\t{\n\t\tFreePageBtreeRemovePage(fpm, btp);\n\t\treturn;\n\t}\n\n\t/* Physically remove the key from the page. */\n\t--btp->hdr.nused;\n\tif (index < btp->hdr.nused)\n\t\tmemmove(&btp->u.leaf_key[index], &btp->u.leaf_key[index + 1],\n\t\t\t\tsizeof(FreePageBtreeLeafKey) * (btp->hdr.nused - index));\n\n\t/* If we just removed the first key, adjust ancestor keys. */\n\tif (index == 0)\n\t\tFreePageBtreeAdjustAncestorKeys(fpm, btp);\n\n\t/* Consider whether to consolidate this page with a sibling. */\n\tFreePageBtreeConsolidate(fpm, btp);\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
    ],
    "globals_used": [
      "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
      "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
      "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
      "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreePageBtreeConsolidate",
          "args": [
            "fpm",
            "btp"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeConsolidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "694-767",
          "snippet": "static void\nFreePageBtreeConsolidate(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtree *np;\n\tSize\t\tmax;\n\n\t/*\n\t * We only try to consolidate pages that are less than a third full. We\n\t * could be more aggressive about this, but that might risk performing\n\t * consolidation only to end up splitting again shortly thereafter.  Since\n\t * the btree should be very small compared to the space under management,\n\t * our goal isn't so much to ensure that it always occupies the absolutely\n\t * smallest possible number of pages as to reclaim pages before things get\n\t * too egregiously out of hand.\n\t */\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\tmax = FPM_ITEMS_PER_LEAF_PAGE;\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tmax = FPM_ITEMS_PER_INTERNAL_PAGE;\n\t}\n\tif (btp->hdr.nused >= max / 3)\n\t\treturn;\n\n\t/*\n\t * If we can fit our right sibling's keys onto this page, consolidate.\n\t */\n\tnp = FreePageBtreeFindRightSibling(base, btp);\n\tif (np != NULL && btp->hdr.nused + np->hdr.nused <= max)\n\t{\n\t\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t{\n\t\t\tmemcpy(&btp->u.leaf_key[btp->hdr.nused], &np->u.leaf_key[0],\n\t\t\t\t   sizeof(FreePageBtreeLeafKey) * np->hdr.nused);\n\t\t\tbtp->hdr.nused += np->hdr.nused;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(&btp->u.internal_key[btp->hdr.nused], &np->u.internal_key[0],\n\t\t\t\t   sizeof(FreePageBtreeInternalKey) * np->hdr.nused);\n\t\t\tbtp->hdr.nused += np->hdr.nused;\n\t\t\tFreePageBtreeUpdateParentPointers(base, btp);\n\t\t}\n\t\tFreePageBtreeRemovePage(fpm, np);\n\t\treturn;\n\t}\n\n\t/*\n\t * If we can fit our keys onto our left sibling's page, consolidate. In\n\t * this case, we move our keys onto the other page rather than visca\n\t * versa, to avoid having to adjust ancestor keys.\n\t */\n\tnp = FreePageBtreeFindLeftSibling(base, btp);\n\tif (np != NULL && btp->hdr.nused + np->hdr.nused <= max)\n\t{\n\t\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t{\n\t\t\tmemcpy(&np->u.leaf_key[np->hdr.nused], &btp->u.leaf_key[0],\n\t\t\t\t   sizeof(FreePageBtreeLeafKey) * btp->hdr.nused);\n\t\t\tnp->hdr.nused += btp->hdr.nused;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(&np->u.internal_key[np->hdr.nused], &btp->u.internal_key[0],\n\t\t\t\t   sizeof(FreePageBtreeInternalKey) * btp->hdr.nused);\n\t\t\tnp->hdr.nused += btp->hdr.nused;\n\t\t\tFreePageBtreeUpdateParentPointers(base, np);\n\t\t}\n\t\tFreePageBtreeRemovePage(fpm, btp);\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))",
            "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeConsolidate(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtree *np;\n\tSize\t\tmax;\n\n\t/*\n\t * We only try to consolidate pages that are less than a third full. We\n\t * could be more aggressive about this, but that might risk performing\n\t * consolidation only to end up splitting again shortly thereafter.  Since\n\t * the btree should be very small compared to the space under management,\n\t * our goal isn't so much to ensure that it always occupies the absolutely\n\t * smallest possible number of pages as to reclaim pages before things get\n\t * too egregiously out of hand.\n\t */\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\tmax = FPM_ITEMS_PER_LEAF_PAGE;\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tmax = FPM_ITEMS_PER_INTERNAL_PAGE;\n\t}\n\tif (btp->hdr.nused >= max / 3)\n\t\treturn;\n\n\t/*\n\t * If we can fit our right sibling's keys onto this page, consolidate.\n\t */\n\tnp = FreePageBtreeFindRightSibling(base, btp);\n\tif (np != NULL && btp->hdr.nused + np->hdr.nused <= max)\n\t{\n\t\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t{\n\t\t\tmemcpy(&btp->u.leaf_key[btp->hdr.nused], &np->u.leaf_key[0],\n\t\t\t\t   sizeof(FreePageBtreeLeafKey) * np->hdr.nused);\n\t\t\tbtp->hdr.nused += np->hdr.nused;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(&btp->u.internal_key[btp->hdr.nused], &np->u.internal_key[0],\n\t\t\t\t   sizeof(FreePageBtreeInternalKey) * np->hdr.nused);\n\t\t\tbtp->hdr.nused += np->hdr.nused;\n\t\t\tFreePageBtreeUpdateParentPointers(base, btp);\n\t\t}\n\t\tFreePageBtreeRemovePage(fpm, np);\n\t\treturn;\n\t}\n\n\t/*\n\t * If we can fit our keys onto our left sibling's page, consolidate. In\n\t * this case, we move our keys onto the other page rather than visca\n\t * versa, to avoid having to adjust ancestor keys.\n\t */\n\tnp = FreePageBtreeFindLeftSibling(base, btp);\n\tif (np != NULL && btp->hdr.nused + np->hdr.nused <= max)\n\t{\n\t\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t{\n\t\t\tmemcpy(&np->u.leaf_key[np->hdr.nused], &btp->u.leaf_key[0],\n\t\t\t\t   sizeof(FreePageBtreeLeafKey) * btp->hdr.nused);\n\t\t\tnp->hdr.nused += btp->hdr.nused;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(&np->u.internal_key[np->hdr.nused], &btp->u.internal_key[0],\n\t\t\t\t   sizeof(FreePageBtreeInternalKey) * btp->hdr.nused);\n\t\t\tnp->hdr.nused += btp->hdr.nused;\n\t\t\tFreePageBtreeUpdateParentPointers(base, np);\n\t\t}\n\t\tFreePageBtreeRemovePage(fpm, btp);\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageBtreeAdjustAncestorKeys",
          "args": [
            "fpm",
            "btp"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeAdjustAncestorKeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "500-573",
          "snippet": "static void\nFreePageBtreeAdjustAncestorKeys(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tfirst_page;\n\tFreePageBtree *parent;\n\tFreePageBtree *child;\n\n\t/* This might be either a leaf or an internal page. */\n\tAssert(btp->hdr.nused > 0);\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t{\n\t\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_LEAF_PAGE);\n\t\tfirst_page = btp->u.leaf_key[0].first_page;\n\t}\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\tfirst_page = btp->u.internal_key[0].first_page;\n\t}\n\tchild = btp;\n\n\t/* Loop until we find an ancestor that does not require adjustment. */\n\tfor (;;)\n\t{\n\t\tSize\t\ts;\n\n\t\tparent = relptr_access(base, child->hdr.parent);\n\t\tif (parent == NULL)\n\t\t\tbreak;\n\t\ts = FreePageBtreeSearchInternal(parent, first_page);\n\n\t\t/* Key is either at index s or index s-1; figure out which. */\n\t\tif (s >= parent->hdr.nused)\n\t\t{\n\t\t\tAssert(s == parent->hdr.nused);\n\t\t\t--s;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFreePageBtree *check;\n\n\t\t\tcheck = relptr_access(base, parent->u.internal_key[s].child);\n\t\t\tif (check != child)\n\t\t\t{\n\t\t\t\tAssert(s > 0);\n\t\t\t\t--s;\n\t\t\t}\n\t\t}\n\n#ifdef USE_ASSERT_CHECKING\n\t\t/* Debugging double-check. */\n\t\t{\n\t\t\tFreePageBtree *check;\n\n\t\t\tcheck = relptr_access(base, parent->u.internal_key[s].child);\n\t\t\tAssert(s < parent->hdr.nused);\n\t\t\tAssert(child == check);\n\t\t}\n#endif\n\n\t\t/* Update the parent key. */\n\t\tparent->u.internal_key[s].first_page = first_page;\n\n\t\t/*\n\t\t * If this is the first key in the parent, go up another level; else\n\t\t * done.\n\t\t */\n\t\tif (s > 0)\n\t\t\tbreak;\n\t\tchild = parent;\n\t}\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))",
            "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeAdjustAncestorKeys(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tfirst_page;\n\tFreePageBtree *parent;\n\tFreePageBtree *child;\n\n\t/* This might be either a leaf or an internal page. */\n\tAssert(btp->hdr.nused > 0);\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t{\n\t\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_LEAF_PAGE);\n\t\tfirst_page = btp->u.leaf_key[0].first_page;\n\t}\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\tfirst_page = btp->u.internal_key[0].first_page;\n\t}\n\tchild = btp;\n\n\t/* Loop until we find an ancestor that does not require adjustment. */\n\tfor (;;)\n\t{\n\t\tSize\t\ts;\n\n\t\tparent = relptr_access(base, child->hdr.parent);\n\t\tif (parent == NULL)\n\t\t\tbreak;\n\t\ts = FreePageBtreeSearchInternal(parent, first_page);\n\n\t\t/* Key is either at index s or index s-1; figure out which. */\n\t\tif (s >= parent->hdr.nused)\n\t\t{\n\t\t\tAssert(s == parent->hdr.nused);\n\t\t\t--s;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFreePageBtree *check;\n\n\t\t\tcheck = relptr_access(base, parent->u.internal_key[s].child);\n\t\t\tif (check != child)\n\t\t\t{\n\t\t\t\tAssert(s > 0);\n\t\t\t\t--s;\n\t\t\t}\n\t\t}\n\n#ifdef USE_ASSERT_CHECKING\n\t\t/* Debugging double-check. */\n\t\t{\n\t\t\tFreePageBtree *check;\n\n\t\t\tcheck = relptr_access(base, parent->u.internal_key[s].child);\n\t\t\tAssert(s < parent->hdr.nused);\n\t\t\tAssert(child == check);\n\t\t}\n#endif\n\n\t\t/* Update the parent key. */\n\t\tparent->u.internal_key[s].first_page = first_page;\n\n\t\t/*\n\t\t * If this is the first key in the parent, go up another level; else\n\t\t * done.\n\t\t */\n\t\tif (s > 0)\n\t\t\tbreak;\n\t\tchild = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&btp->u.leaf_key[index]",
            "&btp->u.leaf_key[index + 1]",
            "sizeof(FreePageBtreeLeafKey) * (btp->hdr.nused - index)"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeRemovePage",
          "args": [
            "fpm",
            "btp"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeRemovePage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "986-1051",
          "snippet": "static void\nFreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtree *parent;\n\tSize\t\tindex;\n\tSize\t\tfirst_page;\n\n\tfor (;;)\n\t{\n\t\t/* Find parent page. */\n\t\tparent = relptr_access(base, btp->hdr.parent);\n\t\tif (parent == NULL)\n\t\t{\n\t\t\t/* We are removing the root page. */\n\t\t\trelptr_store(base, fpm->btree_root, (FreePageBtree *) NULL);\n\t\t\tfpm->btree_depth = 0;\n\t\t\tAssert(fpm->singleton_first_page == 0);\n\t\t\tAssert(fpm->singleton_npages == 0);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If the parent contains only one item, we need to remove it as well.\n\t\t */\n\t\tif (parent->hdr.nused > 1)\n\t\t\tbreak;\n\t\tFreePageBtreeRecycle(fpm, fpm_pointer_to_page(base, btp));\n\t\tbtp = parent;\n\t}\n\n\t/* Find and remove the downlink. */\n\tfirst_page = FreePageBtreeFirstKey(btp);\n\tif (parent->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t{\n\t\tindex = FreePageBtreeSearchLeaf(parent, first_page);\n\t\tAssert(index < parent->hdr.nused);\n\t\tif (index < parent->hdr.nused - 1)\n\t\t\tmemmove(&parent->u.leaf_key[index],\n\t\t\t\t\t&parent->u.leaf_key[index + 1],\n\t\t\t\t\tsizeof(FreePageBtreeLeafKey)\n\t\t\t\t\t* (parent->hdr.nused - index - 1));\n\t}\n\telse\n\t{\n\t\tindex = FreePageBtreeSearchInternal(parent, first_page);\n\t\tAssert(index < parent->hdr.nused);\n\t\tif (index < parent->hdr.nused - 1)\n\t\t\tmemmove(&parent->u.internal_key[index],\n\t\t\t\t\t&parent->u.internal_key[index + 1],\n\t\t\t\t\tsizeof(FreePageBtreeInternalKey)\n\t\t\t\t\t* (parent->hdr.nused - index - 1));\n\t}\n\tparent->hdr.nused--;\n\tAssert(parent->hdr.nused > 0);\n\n\t/* Recycle the page. */\n\tFreePageBtreeRecycle(fpm, fpm_pointer_to_page(base, btp));\n\n\t/* Adjust ancestor keys if needed. */\n\tif (index == 0)\n\t\tFreePageBtreeAdjustAncestorKeys(fpm, parent);\n\n\t/* Consider whether to consolidate the parent with a sibling. */\n\tFreePageBtreeConsolidate(fpm, parent);\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtree *parent;\n\tSize\t\tindex;\n\tSize\t\tfirst_page;\n\n\tfor (;;)\n\t{\n\t\t/* Find parent page. */\n\t\tparent = relptr_access(base, btp->hdr.parent);\n\t\tif (parent == NULL)\n\t\t{\n\t\t\t/* We are removing the root page. */\n\t\t\trelptr_store(base, fpm->btree_root, (FreePageBtree *) NULL);\n\t\t\tfpm->btree_depth = 0;\n\t\t\tAssert(fpm->singleton_first_page == 0);\n\t\t\tAssert(fpm->singleton_npages == 0);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If the parent contains only one item, we need to remove it as well.\n\t\t */\n\t\tif (parent->hdr.nused > 1)\n\t\t\tbreak;\n\t\tFreePageBtreeRecycle(fpm, fpm_pointer_to_page(base, btp));\n\t\tbtp = parent;\n\t}\n\n\t/* Find and remove the downlink. */\n\tfirst_page = FreePageBtreeFirstKey(btp);\n\tif (parent->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t{\n\t\tindex = FreePageBtreeSearchLeaf(parent, first_page);\n\t\tAssert(index < parent->hdr.nused);\n\t\tif (index < parent->hdr.nused - 1)\n\t\t\tmemmove(&parent->u.leaf_key[index],\n\t\t\t\t\t&parent->u.leaf_key[index + 1],\n\t\t\t\t\tsizeof(FreePageBtreeLeafKey)\n\t\t\t\t\t* (parent->hdr.nused - index - 1));\n\t}\n\telse\n\t{\n\t\tindex = FreePageBtreeSearchInternal(parent, first_page);\n\t\tAssert(index < parent->hdr.nused);\n\t\tif (index < parent->hdr.nused - 1)\n\t\t\tmemmove(&parent->u.internal_key[index],\n\t\t\t\t\t&parent->u.internal_key[index + 1],\n\t\t\t\t\tsizeof(FreePageBtreeInternalKey)\n\t\t\t\t\t* (parent->hdr.nused - index - 1));\n\t}\n\tparent->hdr.nused--;\n\tAssert(parent->hdr.nused > 0);\n\n\t/* Recycle the page. */\n\tFreePageBtreeRecycle(fpm, fpm_pointer_to_page(base, btp));\n\n\t/* Adjust ancestor keys if needed. */\n\tif (index == 0)\n\t\tFreePageBtreeAdjustAncestorKeys(fpm, parent);\n\n\t/* Consider whether to consolidate the parent with a sibling. */\n\tFreePageBtreeConsolidate(fpm, parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "index < btp->hdr.nused"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "btp->hdr.magic == FREE_PAGE_LEAF_MAGIC"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp, Size index)\n{\n\tAssert(btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\tAssert(index < btp->hdr.nused);\n\n\t/* When last item is removed, extirpate entire page from btree. */\n\tif (btp->hdr.nused == 1)\n\t{\n\t\tFreePageBtreeRemovePage(fpm, btp);\n\t\treturn;\n\t}\n\n\t/* Physically remove the key from the page. */\n\t--btp->hdr.nused;\n\tif (index < btp->hdr.nused)\n\t\tmemmove(&btp->u.leaf_key[index], &btp->u.leaf_key[index + 1],\n\t\t\t\tsizeof(FreePageBtreeLeafKey) * (btp->hdr.nused - index));\n\n\t/* If we just removed the first key, adjust ancestor keys. */\n\tif (index == 0)\n\t\tFreePageBtreeAdjustAncestorKeys(fpm, btp);\n\n\t/* Consider whether to consolidate this page with a sibling. */\n\tFreePageBtreeConsolidate(fpm, btp);\n}"
  },
  {
    "function_name": "FreePageBtreeRecycle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "933-949",
    "snippet": "static void\nFreePageBtreeRecycle(FreePageManager *fpm, Size pageno)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *head = relptr_access(base, fpm->btree_recycle);\n\tFreePageSpanLeader *span;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, pageno);\n\tspan->magic = FREE_PAGE_SPAN_LEADER_MAGIC;\n\tspan->npages = 1;\n\trelptr_store(base, span->next, head);\n\trelptr_store(base, span->prev, (FreePageSpanLeader *) NULL);\n\tif (head != NULL)\n\t\trelptr_store(base, head->prev, span);\n\trelptr_store(base, fpm->btree_recycle, span);\n\tfpm->btree_recycle_count++;\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0"
    ],
    "globals_used": [
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
      "static void FreePageBtreeRecycle(FreePageManager *fpm, Size pageno);",
      "static void FreePagePopSpanLeader(FreePageManager *fpm, Size pageno);",
      "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "fpm->btree_recycle",
            "span"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "head->prev",
            "span"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "span->prev",
            "(FreePageSpanLeader *) NULL"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "span->next",
            "head"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_page_to_pointer",
          "args": [
            "base",
            "pageno"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "fpm->btree_recycle"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_segment_base",
          "args": [
            "fpm"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRecycle(FreePageManager *fpm, Size pageno);\nstatic void FreePagePopSpanLeader(FreePageManager *fpm, Size pageno);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeRecycle(FreePageManager *fpm, Size pageno)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *head = relptr_access(base, fpm->btree_recycle);\n\tFreePageSpanLeader *span;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, pageno);\n\tspan->magic = FREE_PAGE_SPAN_LEADER_MAGIC;\n\tspan->npages = 1;\n\trelptr_store(base, span->next, head);\n\trelptr_store(base, span->prev, (FreePageSpanLeader *) NULL);\n\tif (head != NULL)\n\t\trelptr_store(base, head->prev, span);\n\trelptr_store(base, fpm->btree_recycle, span);\n\tfpm->btree_recycle_count++;\n}"
  },
  {
    "function_name": "FreePageBtreeInsertLeaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "916-928",
    "snippet": "static void\nFreePageBtreeInsertLeaf(FreePageBtree *btp, Size index, Size first_page,\n\t\t\t\t\t\tSize npages)\n{\n\tAssert(btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_LEAF_PAGE);\n\tAssert(index <= btp->hdr.nused);\n\tmemmove(&btp->u.leaf_key[index + 1], &btp->u.leaf_key[index],\n\t\t\tsizeof(FreePageBtreeLeafKey) * (btp->hdr.nused - index));\n\tbtp->u.leaf_key[index].first_page = first_page;\n\tbtp->u.leaf_key[index].npages = npages;\n\t++btp->hdr.nused;\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))",
      "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
    ],
    "globals_used": [
      "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
      "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
      "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
      "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
      "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
      "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
      "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
      "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
      "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
      "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
      "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&btp->u.leaf_key[index + 1]",
            "&btp->u.leaf_key[index]",
            "sizeof(FreePageBtreeLeafKey) * (btp->hdr.nused - index)"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "index <= btp->hdr.nused"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "btp->hdr.nused <= FPM_ITEMS_PER_LEAF_PAGE"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "btp->hdr.magic == FREE_PAGE_LEAF_MAGIC"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\n\nstatic void\nFreePageBtreeInsertLeaf(FreePageBtree *btp, Size index, Size first_page,\n\t\t\t\t\t\tSize npages)\n{\n\tAssert(btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_LEAF_PAGE);\n\tAssert(index <= btp->hdr.nused);\n\tmemmove(&btp->u.leaf_key[index + 1], &btp->u.leaf_key[index],\n\t\t\tsizeof(FreePageBtreeLeafKey) * (btp->hdr.nused - index));\n\tbtp->u.leaf_key[index].first_page = first_page;\n\tbtp->u.leaf_key[index].npages = npages;\n\t++btp->hdr.nused;\n}"
  },
  {
    "function_name": "FreePageBtreeInsertInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "899-911",
    "snippet": "static void\nFreePageBtreeInsertInternal(char *base, FreePageBtree *btp, Size index,\n\t\t\t\t\t\t\tSize first_page, FreePageBtree *child)\n{\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\tAssert(index <= btp->hdr.nused);\n\tmemmove(&btp->u.internal_key[index + 1], &btp->u.internal_key[index],\n\t\t\tsizeof(FreePageBtreeInternalKey) * (btp->hdr.nused - index));\n\tbtp->u.internal_key[index].first_page = first_page;\n\trelptr_store(base, btp->u.internal_key[index].child, child);\n\t++btp->hdr.nused;\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
      "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
    ],
    "globals_used": [
      "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
      "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
      "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
      "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
      "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
      "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
      "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
      "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
      "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
      "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "btp->u.internal_key[index].child",
            "child"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&btp->u.internal_key[index + 1]",
            "&btp->u.internal_key[index]",
            "sizeof(FreePageBtreeInternalKey) * (btp->hdr.nused - index)"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "index <= btp->hdr.nused"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "btp->hdr.nused <= FPM_ITEMS_PER_INTERNAL_PAGE"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic void\nFreePageBtreeInsertInternal(char *base, FreePageBtree *btp, Size index,\n\t\t\t\t\t\t\tSize first_page, FreePageBtree *child)\n{\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\tAssert(index <= btp->hdr.nused);\n\tmemmove(&btp->u.internal_key[index + 1], &btp->u.internal_key[index],\n\t\t\tsizeof(FreePageBtreeInternalKey) * (btp->hdr.nused - index));\n\tbtp->u.internal_key[index].first_page = first_page;\n\trelptr_store(base, btp->u.internal_key[index].child, child);\n\t++btp->hdr.nused;\n}"
  },
  {
    "function_name": "FreePageBtreeGetRecycled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "879-894",
    "snippet": "static FreePageBtree *\nFreePageBtreeGetRecycled(FreePageManager *fpm)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *victim = relptr_access(base, fpm->btree_recycle);\n\tFreePageSpanLeader *newhead;\n\n\tAssert(victim != NULL);\n\tnewhead = relptr_access(base, victim->next);\n\tif (newhead != NULL)\n\t\trelptr_copy(newhead->prev, victim->prev);\n\trelptr_store(base, fpm->btree_recycle, newhead);\n\tAssert(fpm_pointer_is_page_aligned(base, victim));\n\tfpm->btree_recycle_count--;\n\treturn (FreePageBtree *) victim;\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "fpm_pointer_is_page_aligned(base, victim)"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_pointer_is_page_aligned",
          "args": [
            "base",
            "victim"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "fpm->btree_recycle",
            "newhead"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_copy",
          "args": [
            "newhead->prev",
            "victim->prev"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "victim->next"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "victim != NULL"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "fpm->btree_recycle"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_segment_base",
          "args": [
            "fpm"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic FreePageBtree *\nFreePageBtreeGetRecycled(FreePageManager *fpm)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *victim = relptr_access(base, fpm->btree_recycle);\n\tFreePageSpanLeader *newhead;\n\n\tAssert(victim != NULL);\n\tnewhead = relptr_access(base, victim->next);\n\tif (newhead != NULL)\n\t\trelptr_copy(newhead->prev, victim->prev);\n\trelptr_store(base, fpm->btree_recycle, newhead);\n\tAssert(fpm_pointer_is_page_aligned(base, victim));\n\tfpm->btree_recycle_count--;\n\treturn (FreePageBtree *) victim;\n}"
  },
  {
    "function_name": "FreePageBtreeFirstKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "862-874",
    "snippet": "static Size\nFreePageBtreeFirstKey(FreePageBtree *btp)\n{\n\tAssert(btp->hdr.nused > 0);\n\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\treturn btp->u.leaf_key[0].first_page;\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\treturn btp->u.internal_key[0].first_page;\n\t}\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
      "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
    ],
    "globals_used": [
      "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
      "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
      "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
      "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
      "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
      "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
      "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
      "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "btp->hdr.nused > 0"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic Size\nFreePageBtreeFirstKey(FreePageBtree *btp)\n{\n\tAssert(btp->hdr.nused > 0);\n\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\treturn btp->u.leaf_key[0].first_page;\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\treturn btp->u.internal_key[0].first_page;\n\t}\n}"
  },
  {
    "function_name": "FreePageBtreeFindRightSibling",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "818-857",
    "snippet": "static FreePageBtree *\nFreePageBtreeFindRightSibling(char *base, FreePageBtree *btp)\n{\n\tFreePageBtree *p = btp;\n\tint\t\t\tlevels = 0;\n\n\t/* Move up until we can move right. */\n\tfor (;;)\n\t{\n\t\tSize\t\tfirst_page;\n\t\tSize\t\tindex;\n\n\t\tfirst_page = FreePageBtreeFirstKey(p);\n\t\tp = relptr_access(base, p->hdr.parent);\n\n\t\tif (p == NULL)\n\t\t\treturn NULL;\t\t/* we were passed the rightmost page */\n\n\t\tindex = FreePageBtreeSearchInternal(p, first_page);\n\t\tif (index < p->hdr.nused - 1)\n\t\t{\n\t\t\tAssert(p->u.internal_key[index].first_page == first_page);\n\t\t\tp = relptr_access(base, p->u.internal_key[index + 1].child);\n\t\t\tbreak;\n\t\t}\n\t\tAssert(index == p->hdr.nused - 1);\n\t\t++levels;\n\t}\n\n\t/* Descend left. */\n\twhile (levels > 0)\n\t{\n\t\tAssert(p->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tp = relptr_access(base, p->u.internal_key[0].child);\n\t\t--levels;\n\t}\n\tAssert(p->hdr.magic == btp->hdr.magic);\n\n\treturn p;\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
    ],
    "globals_used": [
      "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
      "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
      "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
      "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
      "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
      "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
      "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
      "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
      "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
      "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "p->hdr.magic == btp->hdr.magic"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "p->u.internal_key[0].child"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "p->hdr.magic == FREE_PAGE_INTERNAL_MAGIC"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "index == p->hdr.nused - 1"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "p->u.internal_key[index + 1].child"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "p->u.internal_key[index].first_page == first_page"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeSearchInternal",
          "args": [
            "p",
            "first_page"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeSearchInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1139-1162",
          "snippet": "static Size\nFreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.internal_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic Size\nFreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.internal_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}"
        }
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "p->hdr.parent"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeFirstKey",
          "args": [
            "p"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeFirstKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "862-874",
          "snippet": "static Size\nFreePageBtreeFirstKey(FreePageBtree *btp)\n{\n\tAssert(btp->hdr.nused > 0);\n\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\treturn btp->u.leaf_key[0].first_page;\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\treturn btp->u.internal_key[0].first_page;\n\t}\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic Size\nFreePageBtreeFirstKey(FreePageBtree *btp)\n{\n\tAssert(btp->hdr.nused > 0);\n\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\treturn btp->u.leaf_key[0].first_page;\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\treturn btp->u.internal_key[0].first_page;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic FreePageBtree *\nFreePageBtreeFindRightSibling(char *base, FreePageBtree *btp)\n{\n\tFreePageBtree *p = btp;\n\tint\t\t\tlevels = 0;\n\n\t/* Move up until we can move right. */\n\tfor (;;)\n\t{\n\t\tSize\t\tfirst_page;\n\t\tSize\t\tindex;\n\n\t\tfirst_page = FreePageBtreeFirstKey(p);\n\t\tp = relptr_access(base, p->hdr.parent);\n\n\t\tif (p == NULL)\n\t\t\treturn NULL;\t\t/* we were passed the rightmost page */\n\n\t\tindex = FreePageBtreeSearchInternal(p, first_page);\n\t\tif (index < p->hdr.nused - 1)\n\t\t{\n\t\t\tAssert(p->u.internal_key[index].first_page == first_page);\n\t\t\tp = relptr_access(base, p->u.internal_key[index + 1].child);\n\t\t\tbreak;\n\t\t}\n\t\tAssert(index == p->hdr.nused - 1);\n\t\t++levels;\n\t}\n\n\t/* Descend left. */\n\twhile (levels > 0)\n\t{\n\t\tAssert(p->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tp = relptr_access(base, p->u.internal_key[0].child);\n\t\t--levels;\n\t}\n\tAssert(p->hdr.magic == btp->hdr.magic);\n\n\treturn p;\n}"
  },
  {
    "function_name": "FreePageBtreeFindLeftSibling",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "773-812",
    "snippet": "static FreePageBtree *\nFreePageBtreeFindLeftSibling(char *base, FreePageBtree *btp)\n{\n\tFreePageBtree *p = btp;\n\tint\t\t\tlevels = 0;\n\n\t/* Move up until we can move left. */\n\tfor (;;)\n\t{\n\t\tSize\t\tfirst_page;\n\t\tSize\t\tindex;\n\n\t\tfirst_page = FreePageBtreeFirstKey(p);\n\t\tp = relptr_access(base, p->hdr.parent);\n\n\t\tif (p == NULL)\n\t\t\treturn NULL;\t\t/* we were passed the rightmost page */\n\n\t\tindex = FreePageBtreeSearchInternal(p, first_page);\n\t\tif (index > 0)\n\t\t{\n\t\t\tAssert(p->u.internal_key[index].first_page == first_page);\n\t\t\tp = relptr_access(base, p->u.internal_key[index - 1].child);\n\t\t\tbreak;\n\t\t}\n\t\tAssert(index == 0);\n\t\t++levels;\n\t}\n\n\t/* Descend left. */\n\twhile (levels > 0)\n\t{\n\t\tAssert(p->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tp = relptr_access(base, p->u.internal_key[p->hdr.nused - 1].child);\n\t\t--levels;\n\t}\n\tAssert(p->hdr.magic == btp->hdr.magic);\n\n\treturn p;\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
    ],
    "globals_used": [
      "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
      "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
      "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
      "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
      "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
      "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
      "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
      "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
      "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
      "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "p->hdr.magic == btp->hdr.magic"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "p->u.internal_key[p->hdr.nused - 1].child"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "p->hdr.magic == FREE_PAGE_INTERNAL_MAGIC"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "index == 0"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "p->u.internal_key[index - 1].child"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "p->u.internal_key[index].first_page == first_page"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeSearchInternal",
          "args": [
            "p",
            "first_page"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeSearchInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1139-1162",
          "snippet": "static Size\nFreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.internal_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic Size\nFreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.internal_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}"
        }
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "p->hdr.parent"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeFirstKey",
          "args": [
            "p"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeFirstKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "862-874",
          "snippet": "static Size\nFreePageBtreeFirstKey(FreePageBtree *btp)\n{\n\tAssert(btp->hdr.nused > 0);\n\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\treturn btp->u.leaf_key[0].first_page;\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\treturn btp->u.internal_key[0].first_page;\n\t}\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic Size\nFreePageBtreeFirstKey(FreePageBtree *btp)\n{\n\tAssert(btp->hdr.nused > 0);\n\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\treturn btp->u.leaf_key[0].first_page;\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\treturn btp->u.internal_key[0].first_page;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic FreePageBtree *\nFreePageBtreeFindLeftSibling(char *base, FreePageBtree *btp)\n{\n\tFreePageBtree *p = btp;\n\tint\t\t\tlevels = 0;\n\n\t/* Move up until we can move left. */\n\tfor (;;)\n\t{\n\t\tSize\t\tfirst_page;\n\t\tSize\t\tindex;\n\n\t\tfirst_page = FreePageBtreeFirstKey(p);\n\t\tp = relptr_access(base, p->hdr.parent);\n\n\t\tif (p == NULL)\n\t\t\treturn NULL;\t\t/* we were passed the rightmost page */\n\n\t\tindex = FreePageBtreeSearchInternal(p, first_page);\n\t\tif (index > 0)\n\t\t{\n\t\t\tAssert(p->u.internal_key[index].first_page == first_page);\n\t\t\tp = relptr_access(base, p->u.internal_key[index - 1].child);\n\t\t\tbreak;\n\t\t}\n\t\tAssert(index == 0);\n\t\t++levels;\n\t}\n\n\t/* Descend left. */\n\twhile (levels > 0)\n\t{\n\t\tAssert(p->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tp = relptr_access(base, p->u.internal_key[p->hdr.nused - 1].child);\n\t\t--levels;\n\t}\n\tAssert(p->hdr.magic == btp->hdr.magic);\n\n\treturn p;\n}"
  },
  {
    "function_name": "FreePageBtreeConsolidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "694-767",
    "snippet": "static void\nFreePageBtreeConsolidate(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtree *np;\n\tSize\t\tmax;\n\n\t/*\n\t * We only try to consolidate pages that are less than a third full. We\n\t * could be more aggressive about this, but that might risk performing\n\t * consolidation only to end up splitting again shortly thereafter.  Since\n\t * the btree should be very small compared to the space under management,\n\t * our goal isn't so much to ensure that it always occupies the absolutely\n\t * smallest possible number of pages as to reclaim pages before things get\n\t * too egregiously out of hand.\n\t */\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\tmax = FPM_ITEMS_PER_LEAF_PAGE;\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tmax = FPM_ITEMS_PER_INTERNAL_PAGE;\n\t}\n\tif (btp->hdr.nused >= max / 3)\n\t\treturn;\n\n\t/*\n\t * If we can fit our right sibling's keys onto this page, consolidate.\n\t */\n\tnp = FreePageBtreeFindRightSibling(base, btp);\n\tif (np != NULL && btp->hdr.nused + np->hdr.nused <= max)\n\t{\n\t\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t{\n\t\t\tmemcpy(&btp->u.leaf_key[btp->hdr.nused], &np->u.leaf_key[0],\n\t\t\t\t   sizeof(FreePageBtreeLeafKey) * np->hdr.nused);\n\t\t\tbtp->hdr.nused += np->hdr.nused;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(&btp->u.internal_key[btp->hdr.nused], &np->u.internal_key[0],\n\t\t\t\t   sizeof(FreePageBtreeInternalKey) * np->hdr.nused);\n\t\t\tbtp->hdr.nused += np->hdr.nused;\n\t\t\tFreePageBtreeUpdateParentPointers(base, btp);\n\t\t}\n\t\tFreePageBtreeRemovePage(fpm, np);\n\t\treturn;\n\t}\n\n\t/*\n\t * If we can fit our keys onto our left sibling's page, consolidate. In\n\t * this case, we move our keys onto the other page rather than visca\n\t * versa, to avoid having to adjust ancestor keys.\n\t */\n\tnp = FreePageBtreeFindLeftSibling(base, btp);\n\tif (np != NULL && btp->hdr.nused + np->hdr.nused <= max)\n\t{\n\t\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t{\n\t\t\tmemcpy(&np->u.leaf_key[np->hdr.nused], &btp->u.leaf_key[0],\n\t\t\t\t   sizeof(FreePageBtreeLeafKey) * btp->hdr.nused);\n\t\t\tnp->hdr.nused += btp->hdr.nused;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(&np->u.internal_key[np->hdr.nused], &btp->u.internal_key[0],\n\t\t\t\t   sizeof(FreePageBtreeInternalKey) * btp->hdr.nused);\n\t\t\tnp->hdr.nused += btp->hdr.nused;\n\t\t\tFreePageBtreeUpdateParentPointers(base, np);\n\t\t}\n\t\tFreePageBtreeRemovePage(fpm, btp);\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))",
      "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
      "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
      "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
    ],
    "globals_used": [
      "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
      "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
      "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreePageBtreeRemovePage",
          "args": [
            "fpm",
            "btp"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeRemovePage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "986-1051",
          "snippet": "static void\nFreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtree *parent;\n\tSize\t\tindex;\n\tSize\t\tfirst_page;\n\n\tfor (;;)\n\t{\n\t\t/* Find parent page. */\n\t\tparent = relptr_access(base, btp->hdr.parent);\n\t\tif (parent == NULL)\n\t\t{\n\t\t\t/* We are removing the root page. */\n\t\t\trelptr_store(base, fpm->btree_root, (FreePageBtree *) NULL);\n\t\t\tfpm->btree_depth = 0;\n\t\t\tAssert(fpm->singleton_first_page == 0);\n\t\t\tAssert(fpm->singleton_npages == 0);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If the parent contains only one item, we need to remove it as well.\n\t\t */\n\t\tif (parent->hdr.nused > 1)\n\t\t\tbreak;\n\t\tFreePageBtreeRecycle(fpm, fpm_pointer_to_page(base, btp));\n\t\tbtp = parent;\n\t}\n\n\t/* Find and remove the downlink. */\n\tfirst_page = FreePageBtreeFirstKey(btp);\n\tif (parent->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t{\n\t\tindex = FreePageBtreeSearchLeaf(parent, first_page);\n\t\tAssert(index < parent->hdr.nused);\n\t\tif (index < parent->hdr.nused - 1)\n\t\t\tmemmove(&parent->u.leaf_key[index],\n\t\t\t\t\t&parent->u.leaf_key[index + 1],\n\t\t\t\t\tsizeof(FreePageBtreeLeafKey)\n\t\t\t\t\t* (parent->hdr.nused - index - 1));\n\t}\n\telse\n\t{\n\t\tindex = FreePageBtreeSearchInternal(parent, first_page);\n\t\tAssert(index < parent->hdr.nused);\n\t\tif (index < parent->hdr.nused - 1)\n\t\t\tmemmove(&parent->u.internal_key[index],\n\t\t\t\t\t&parent->u.internal_key[index + 1],\n\t\t\t\t\tsizeof(FreePageBtreeInternalKey)\n\t\t\t\t\t* (parent->hdr.nused - index - 1));\n\t}\n\tparent->hdr.nused--;\n\tAssert(parent->hdr.nused > 0);\n\n\t/* Recycle the page. */\n\tFreePageBtreeRecycle(fpm, fpm_pointer_to_page(base, btp));\n\n\t/* Adjust ancestor keys if needed. */\n\tif (index == 0)\n\t\tFreePageBtreeAdjustAncestorKeys(fpm, parent);\n\n\t/* Consider whether to consolidate the parent with a sibling. */\n\tFreePageBtreeConsolidate(fpm, parent);\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtree *parent;\n\tSize\t\tindex;\n\tSize\t\tfirst_page;\n\n\tfor (;;)\n\t{\n\t\t/* Find parent page. */\n\t\tparent = relptr_access(base, btp->hdr.parent);\n\t\tif (parent == NULL)\n\t\t{\n\t\t\t/* We are removing the root page. */\n\t\t\trelptr_store(base, fpm->btree_root, (FreePageBtree *) NULL);\n\t\t\tfpm->btree_depth = 0;\n\t\t\tAssert(fpm->singleton_first_page == 0);\n\t\t\tAssert(fpm->singleton_npages == 0);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If the parent contains only one item, we need to remove it as well.\n\t\t */\n\t\tif (parent->hdr.nused > 1)\n\t\t\tbreak;\n\t\tFreePageBtreeRecycle(fpm, fpm_pointer_to_page(base, btp));\n\t\tbtp = parent;\n\t}\n\n\t/* Find and remove the downlink. */\n\tfirst_page = FreePageBtreeFirstKey(btp);\n\tif (parent->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t{\n\t\tindex = FreePageBtreeSearchLeaf(parent, first_page);\n\t\tAssert(index < parent->hdr.nused);\n\t\tif (index < parent->hdr.nused - 1)\n\t\t\tmemmove(&parent->u.leaf_key[index],\n\t\t\t\t\t&parent->u.leaf_key[index + 1],\n\t\t\t\t\tsizeof(FreePageBtreeLeafKey)\n\t\t\t\t\t* (parent->hdr.nused - index - 1));\n\t}\n\telse\n\t{\n\t\tindex = FreePageBtreeSearchInternal(parent, first_page);\n\t\tAssert(index < parent->hdr.nused);\n\t\tif (index < parent->hdr.nused - 1)\n\t\t\tmemmove(&parent->u.internal_key[index],\n\t\t\t\t\t&parent->u.internal_key[index + 1],\n\t\t\t\t\tsizeof(FreePageBtreeInternalKey)\n\t\t\t\t\t* (parent->hdr.nused - index - 1));\n\t}\n\tparent->hdr.nused--;\n\tAssert(parent->hdr.nused > 0);\n\n\t/* Recycle the page. */\n\tFreePageBtreeRecycle(fpm, fpm_pointer_to_page(base, btp));\n\n\t/* Adjust ancestor keys if needed. */\n\tif (index == 0)\n\t\tFreePageBtreeAdjustAncestorKeys(fpm, parent);\n\n\t/* Consider whether to consolidate the parent with a sibling. */\n\tFreePageBtreeConsolidate(fpm, parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageBtreeUpdateParentPointers",
          "args": [
            "base",
            "np"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeUpdateParentPointers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1231-1244",
          "snippet": "static void\nFreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp)\n{\n\tSize\t\ti;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tfor (i = 0; i < btp->hdr.nused; ++i)\n\t{\n\t\tFreePageBtree *child;\n\n\t\tchild = relptr_access(base, btp->u.internal_key[i].child);\n\t\trelptr_store(base, child->hdr.parent, btp);\n\t}\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\n\nstatic void\nFreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp)\n{\n\tSize\t\ti;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tfor (i = 0; i < btp->hdr.nused; ++i)\n\t{\n\t\tFreePageBtree *child;\n\n\t\tchild = relptr_access(base, btp->u.internal_key[i].child);\n\t\trelptr_store(base, child->hdr.parent, btp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&np->u.internal_key[np->hdr.nused]",
            "&btp->u.internal_key[0]",
            "sizeof(FreePageBtreeInternalKey) * btp->hdr.nused"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&np->u.leaf_key[np->hdr.nused]",
            "&btp->u.leaf_key[0]",
            "sizeof(FreePageBtreeLeafKey) * btp->hdr.nused"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeFindLeftSibling",
          "args": [
            "base",
            "btp"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeFindLeftSibling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "773-812",
          "snippet": "static FreePageBtree *\nFreePageBtreeFindLeftSibling(char *base, FreePageBtree *btp)\n{\n\tFreePageBtree *p = btp;\n\tint\t\t\tlevels = 0;\n\n\t/* Move up until we can move left. */\n\tfor (;;)\n\t{\n\t\tSize\t\tfirst_page;\n\t\tSize\t\tindex;\n\n\t\tfirst_page = FreePageBtreeFirstKey(p);\n\t\tp = relptr_access(base, p->hdr.parent);\n\n\t\tif (p == NULL)\n\t\t\treturn NULL;\t\t/* we were passed the rightmost page */\n\n\t\tindex = FreePageBtreeSearchInternal(p, first_page);\n\t\tif (index > 0)\n\t\t{\n\t\t\tAssert(p->u.internal_key[index].first_page == first_page);\n\t\t\tp = relptr_access(base, p->u.internal_key[index - 1].child);\n\t\t\tbreak;\n\t\t}\n\t\tAssert(index == 0);\n\t\t++levels;\n\t}\n\n\t/* Descend left. */\n\twhile (levels > 0)\n\t{\n\t\tAssert(p->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tp = relptr_access(base, p->u.internal_key[p->hdr.nused - 1].child);\n\t\t--levels;\n\t}\n\tAssert(p->hdr.magic == btp->hdr.magic);\n\n\treturn p;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic FreePageBtree *\nFreePageBtreeFindLeftSibling(char *base, FreePageBtree *btp)\n{\n\tFreePageBtree *p = btp;\n\tint\t\t\tlevels = 0;\n\n\t/* Move up until we can move left. */\n\tfor (;;)\n\t{\n\t\tSize\t\tfirst_page;\n\t\tSize\t\tindex;\n\n\t\tfirst_page = FreePageBtreeFirstKey(p);\n\t\tp = relptr_access(base, p->hdr.parent);\n\n\t\tif (p == NULL)\n\t\t\treturn NULL;\t\t/* we were passed the rightmost page */\n\n\t\tindex = FreePageBtreeSearchInternal(p, first_page);\n\t\tif (index > 0)\n\t\t{\n\t\t\tAssert(p->u.internal_key[index].first_page == first_page);\n\t\t\tp = relptr_access(base, p->u.internal_key[index - 1].child);\n\t\t\tbreak;\n\t\t}\n\t\tAssert(index == 0);\n\t\t++levels;\n\t}\n\n\t/* Descend left. */\n\twhile (levels > 0)\n\t{\n\t\tAssert(p->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tp = relptr_access(base, p->u.internal_key[p->hdr.nused - 1].child);\n\t\t--levels;\n\t}\n\tAssert(p->hdr.magic == btp->hdr.magic);\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&btp->u.internal_key[btp->hdr.nused]",
            "&np->u.internal_key[0]",
            "sizeof(FreePageBtreeInternalKey) * np->hdr.nused"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&btp->u.leaf_key[btp->hdr.nused]",
            "&np->u.leaf_key[0]",
            "sizeof(FreePageBtreeLeafKey) * np->hdr.nused"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeFindRightSibling",
          "args": [
            "base",
            "btp"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeFindRightSibling",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "818-857",
          "snippet": "static FreePageBtree *\nFreePageBtreeFindRightSibling(char *base, FreePageBtree *btp)\n{\n\tFreePageBtree *p = btp;\n\tint\t\t\tlevels = 0;\n\n\t/* Move up until we can move right. */\n\tfor (;;)\n\t{\n\t\tSize\t\tfirst_page;\n\t\tSize\t\tindex;\n\n\t\tfirst_page = FreePageBtreeFirstKey(p);\n\t\tp = relptr_access(base, p->hdr.parent);\n\n\t\tif (p == NULL)\n\t\t\treturn NULL;\t\t/* we were passed the rightmost page */\n\n\t\tindex = FreePageBtreeSearchInternal(p, first_page);\n\t\tif (index < p->hdr.nused - 1)\n\t\t{\n\t\t\tAssert(p->u.internal_key[index].first_page == first_page);\n\t\t\tp = relptr_access(base, p->u.internal_key[index + 1].child);\n\t\t\tbreak;\n\t\t}\n\t\tAssert(index == p->hdr.nused - 1);\n\t\t++levels;\n\t}\n\n\t/* Descend left. */\n\twhile (levels > 0)\n\t{\n\t\tAssert(p->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tp = relptr_access(base, p->u.internal_key[0].child);\n\t\t--levels;\n\t}\n\tAssert(p->hdr.magic == btp->hdr.magic);\n\n\treturn p;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic FreePageBtree *\nFreePageBtreeFindRightSibling(char *base, FreePageBtree *btp)\n{\n\tFreePageBtree *p = btp;\n\tint\t\t\tlevels = 0;\n\n\t/* Move up until we can move right. */\n\tfor (;;)\n\t{\n\t\tSize\t\tfirst_page;\n\t\tSize\t\tindex;\n\n\t\tfirst_page = FreePageBtreeFirstKey(p);\n\t\tp = relptr_access(base, p->hdr.parent);\n\n\t\tif (p == NULL)\n\t\t\treturn NULL;\t\t/* we were passed the rightmost page */\n\n\t\tindex = FreePageBtreeSearchInternal(p, first_page);\n\t\tif (index < p->hdr.nused - 1)\n\t\t{\n\t\t\tAssert(p->u.internal_key[index].first_page == first_page);\n\t\t\tp = relptr_access(base, p->u.internal_key[index + 1].child);\n\t\t\tbreak;\n\t\t}\n\t\tAssert(index == p->hdr.nused - 1);\n\t\t++levels;\n\t}\n\n\t/* Descend left. */\n\twhile (levels > 0)\n\t{\n\t\tAssert(p->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tp = relptr_access(base, p->u.internal_key[0].child);\n\t\t--levels;\n\t}\n\tAssert(p->hdr.magic == btp->hdr.magic);\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_segment_base",
          "args": [
            "fpm"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeConsolidate(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtree *np;\n\tSize\t\tmax;\n\n\t/*\n\t * We only try to consolidate pages that are less than a third full. We\n\t * could be more aggressive about this, but that might risk performing\n\t * consolidation only to end up splitting again shortly thereafter.  Since\n\t * the btree should be very small compared to the space under management,\n\t * our goal isn't so much to ensure that it always occupies the absolutely\n\t * smallest possible number of pages as to reclaim pages before things get\n\t * too egregiously out of hand.\n\t */\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\tmax = FPM_ITEMS_PER_LEAF_PAGE;\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tmax = FPM_ITEMS_PER_INTERNAL_PAGE;\n\t}\n\tif (btp->hdr.nused >= max / 3)\n\t\treturn;\n\n\t/*\n\t * If we can fit our right sibling's keys onto this page, consolidate.\n\t */\n\tnp = FreePageBtreeFindRightSibling(base, btp);\n\tif (np != NULL && btp->hdr.nused + np->hdr.nused <= max)\n\t{\n\t\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t{\n\t\t\tmemcpy(&btp->u.leaf_key[btp->hdr.nused], &np->u.leaf_key[0],\n\t\t\t\t   sizeof(FreePageBtreeLeafKey) * np->hdr.nused);\n\t\t\tbtp->hdr.nused += np->hdr.nused;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(&btp->u.internal_key[btp->hdr.nused], &np->u.internal_key[0],\n\t\t\t\t   sizeof(FreePageBtreeInternalKey) * np->hdr.nused);\n\t\t\tbtp->hdr.nused += np->hdr.nused;\n\t\t\tFreePageBtreeUpdateParentPointers(base, btp);\n\t\t}\n\t\tFreePageBtreeRemovePage(fpm, np);\n\t\treturn;\n\t}\n\n\t/*\n\t * If we can fit our keys onto our left sibling's page, consolidate. In\n\t * this case, we move our keys onto the other page rather than visca\n\t * versa, to avoid having to adjust ancestor keys.\n\t */\n\tnp = FreePageBtreeFindLeftSibling(base, btp);\n\tif (np != NULL && btp->hdr.nused + np->hdr.nused <= max)\n\t{\n\t\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t{\n\t\t\tmemcpy(&np->u.leaf_key[np->hdr.nused], &btp->u.leaf_key[0],\n\t\t\t\t   sizeof(FreePageBtreeLeafKey) * btp->hdr.nused);\n\t\t\tnp->hdr.nused += btp->hdr.nused;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmemcpy(&np->u.internal_key[np->hdr.nused], &btp->u.internal_key[0],\n\t\t\t\t   sizeof(FreePageBtreeInternalKey) * btp->hdr.nused);\n\t\t\tnp->hdr.nused += btp->hdr.nused;\n\t\t\tFreePageBtreeUpdateParentPointers(base, np);\n\t\t}\n\t\tFreePageBtreeRemovePage(fpm, btp);\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "FreePageBtreeCleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "579-688",
    "snippet": "static Size\nFreePageBtreeCleanup(FreePageManager *fpm)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tmax_contiguous_pages = 0;\n\n\t/* Attempt to shrink the depth of the btree. */\n\twhile (!relptr_is_null(fpm->btree_root))\n\t{\n\t\tFreePageBtree *root = relptr_access(base, fpm->btree_root);\n\n\t\t/* If the root contains only one key, reduce depth by one. */\n\t\tif (root->hdr.nused == 1)\n\t\t{\n\t\t\t/* Shrink depth of tree by one. */\n\t\t\tAssert(fpm->btree_depth > 0);\n\t\t\t--fpm->btree_depth;\n\t\t\tif (root->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t\t{\n\t\t\t\t/* If root is a leaf, convert only entry to singleton range. */\n\t\t\t\trelptr_store(base, fpm->btree_root, (FreePageBtree *) NULL);\n\t\t\t\tfpm->singleton_first_page = root->u.leaf_key[0].first_page;\n\t\t\t\tfpm->singleton_npages = root->u.leaf_key[0].npages;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFreePageBtree *newroot;\n\n\t\t\t\t/* If root is an internal page, make only child the root. */\n\t\t\t\tAssert(root->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\t\t\trelptr_copy(fpm->btree_root, root->u.internal_key[0].child);\n\t\t\t\tnewroot = relptr_access(base, fpm->btree_root);\n\t\t\t\trelptr_store(base, newroot->hdr.parent, (FreePageBtree *) NULL);\n\t\t\t}\n\t\t\tFreePageBtreeRecycle(fpm, fpm_pointer_to_page(base, root));\n\t\t}\n\t\telse if (root->hdr.nused == 2 &&\n\t\t\t\t root->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t{\n\t\t\tSize\t\tend_of_first;\n\t\t\tSize\t\tstart_of_second;\n\n\t\t\tend_of_first = root->u.leaf_key[0].first_page +\n\t\t\t\troot->u.leaf_key[0].npages;\n\t\t\tstart_of_second = root->u.leaf_key[1].first_page;\n\n\t\t\tif (end_of_first + 1 == start_of_second)\n\t\t\t{\n\t\t\t\tSize\t\troot_page = fpm_pointer_to_page(base, root);\n\n\t\t\t\tif (end_of_first == root_page)\n\t\t\t\t{\n\t\t\t\t\tFreePagePopSpanLeader(fpm, root->u.leaf_key[0].first_page);\n\t\t\t\t\tFreePagePopSpanLeader(fpm, root->u.leaf_key[1].first_page);\n\t\t\t\t\tfpm->singleton_first_page = root->u.leaf_key[0].first_page;\n\t\t\t\t\tfpm->singleton_npages = root->u.leaf_key[0].npages +\n\t\t\t\t\t\troot->u.leaf_key[1].npages + 1;\n\t\t\t\t\tfpm->btree_depth = 0;\n\t\t\t\t\trelptr_store(base, fpm->btree_root,\n\t\t\t\t\t\t\t\t (FreePageBtree *) NULL);\n\t\t\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t\t\t\t\tAssert(max_contiguous_pages == 0);\n\t\t\t\t\tmax_contiguous_pages = fpm->singleton_npages;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Whether it worked or not, it's time to stop. */\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Nothing more to do.  Stop. */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Attempt to free recycled btree pages.  We skip this if releasing the\n\t * recycled page would require a btree page split, because the page we're\n\t * trying to recycle would be consumed by the split, which would be\n\t * counterproductive.\n\t *\n\t * We also currently only ever attempt to recycle the first page on the\n\t * list; that could be made more aggressive, but it's not clear that the\n\t * complexity would be worthwhile.\n\t */\n\twhile (fpm->btree_recycle_count > 0)\n\t{\n\t\tFreePageBtree *btp;\n\t\tSize\t\tfirst_page;\n\t\tSize\t\tcontiguous_pages;\n\n\t\tbtp = FreePageBtreeGetRecycled(fpm);\n\t\tfirst_page = fpm_pointer_to_page(base, btp);\n\t\tcontiguous_pages = FreePageManagerPutInternal(fpm, first_page, 1, true);\n\t\tif (contiguous_pages == 0)\n\t\t{\n\t\t\tFreePageBtreeRecycle(fpm, first_page);\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (contiguous_pages > max_contiguous_pages)\n\t\t\t\tmax_contiguous_pages = contiguous_pages;\n\t\t}\n\t}\n\n\treturn max_contiguous_pages;\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
      "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
    ],
    "globals_used": [
      "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
      "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
      "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
      "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
      "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
      "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
      "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
      "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
      "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
      "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreePageBtreeRecycle",
          "args": [
            "fpm",
            "first_page"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeRecycle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "933-949",
          "snippet": "static void\nFreePageBtreeRecycle(FreePageManager *fpm, Size pageno)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *head = relptr_access(base, fpm->btree_recycle);\n\tFreePageSpanLeader *span;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, pageno);\n\tspan->magic = FREE_PAGE_SPAN_LEADER_MAGIC;\n\tspan->npages = 1;\n\trelptr_store(base, span->next, head);\n\trelptr_store(base, span->prev, (FreePageSpanLeader *) NULL);\n\tif (head != NULL)\n\t\trelptr_store(base, head->prev, span);\n\trelptr_store(base, fpm->btree_recycle, span);\n\tfpm->btree_recycle_count++;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0"
          ],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePageBtreeRecycle(FreePageManager *fpm, Size pageno);",
            "static void FreePagePopSpanLeader(FreePageManager *fpm, Size pageno);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRecycle(FreePageManager *fpm, Size pageno);\nstatic void FreePagePopSpanLeader(FreePageManager *fpm, Size pageno);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeRecycle(FreePageManager *fpm, Size pageno)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *head = relptr_access(base, fpm->btree_recycle);\n\tFreePageSpanLeader *span;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, pageno);\n\tspan->magic = FREE_PAGE_SPAN_LEADER_MAGIC;\n\tspan->npages = 1;\n\trelptr_store(base, span->next, head);\n\trelptr_store(base, span->prev, (FreePageSpanLeader *) NULL);\n\tif (head != NULL)\n\t\trelptr_store(base, head->prev, span);\n\trelptr_store(base, fpm->btree_recycle, span);\n\tfpm->btree_recycle_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageManagerPutInternal",
          "args": [
            "fpm",
            "first_page",
            "1",
            "true"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageManagerPutInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1475-1836",
          "snippet": "static Size\nFreePageManagerPutInternal(FreePageManager *fpm, Size first_page, Size npages,\n\t\t\t\t\t\t   bool soft)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtreeSearchResult result;\n\tFreePageBtreeLeafKey *prevkey = NULL;\n\tFreePageBtreeLeafKey *nextkey = NULL;\n\tFreePageBtree *np;\n\tSize\t\tnindex;\n\n\tAssert(npages > 0);\n\n\t/* We can store a single free span without initializing the btree. */\n\tif (fpm->btree_depth == 0)\n\t{\n\t\tif (fpm->singleton_npages == 0)\n\t\t{\n\t\t\t/* Don't have a span yet; store this one. */\n\t\t\tfpm->singleton_first_page = first_page;\n\t\t\tfpm->singleton_npages = npages;\n\t\t\tFreePagePushSpanLeader(fpm, first_page, npages);\n\t\t\treturn fpm->singleton_npages;\n\t\t}\n\t\telse if (fpm->singleton_first_page + fpm->singleton_npages ==\n\t\t\t\t first_page)\n\t\t{\n\t\t\t/* New span immediately follows sole existing span. */\n\t\t\tfpm->singleton_npages += npages;\n\t\t\tFreePagePopSpanLeader(fpm, fpm->singleton_first_page);\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t\t\treturn fpm->singleton_npages;\n\t\t}\n\t\telse if (first_page + npages == fpm->singleton_first_page)\n\t\t{\n\t\t\t/* New span immediately precedes sole existing span. */\n\t\t\tFreePagePopSpanLeader(fpm, fpm->singleton_first_page);\n\t\t\tfpm->singleton_first_page = first_page;\n\t\t\tfpm->singleton_npages += npages;\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t\t\treturn fpm->singleton_npages;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Not contiguous; we need to initialize the btree. */\n\t\t\tSize\t\troot_page;\n\t\t\tFreePageBtree *root;\n\n\t\t\tif (!relptr_is_null(fpm->btree_recycle))\n\t\t\t\troot = FreePageBtreeGetRecycled(fpm);\n\t\t\telse if (soft)\n\t\t\t\treturn 0;\t\t/* Should not allocate if soft. */\n\t\t\telse if (FreePageManagerGetInternal(fpm, 1, &root_page))\n\t\t\t\troot = (FreePageBtree *) fpm_page_to_pointer(base, root_page);\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* We'd better be able to get a page from the existing range. */\n\t\t\t\telog(FATAL, \"free page manager btree is corrupt\");\n\t\t\t}\n\n\t\t\t/* Create the btree and move the preexisting range into it. */\n\t\t\troot->hdr.magic = FREE_PAGE_LEAF_MAGIC;\n\t\t\troot->hdr.nused = 1;\n\t\t\trelptr_store(base, root->hdr.parent, (FreePageBtree *) NULL);\n\t\t\troot->u.leaf_key[0].first_page = fpm->singleton_first_page;\n\t\t\troot->u.leaf_key[0].npages = fpm->singleton_npages;\n\t\t\trelptr_store(base, fpm->btree_root, root);\n\t\t\tfpm->singleton_first_page = 0;\n\t\t\tfpm->singleton_npages = 0;\n\t\t\tfpm->btree_depth = 1;\n\n\t\t\t/*\n\t\t\t * Corner case: it may be that the btree root took the very last\n\t\t\t * free page.  In that case, the sole btree entry covers a zero\n\t\t\t * page run, which is invalid.  Overwrite it with the entry we're\n\t\t\t * trying to insert and get out.\n\t\t\t */\n\t\t\tif (root->u.leaf_key[0].npages == 0)\n\t\t\t{\n\t\t\t\troot->u.leaf_key[0].first_page = first_page;\n\t\t\t\troot->u.leaf_key[0].npages = npages;\n\t\t\t\tFreePagePushSpanLeader(fpm, first_page, npages);\n\t\t\t\treturn npages;\n\t\t\t}\n\n\t\t\t/* Fall through to insert the new key. */\n\t\t}\n\t}\n\n\t/* Search the btree. */\n\tFreePageBtreeSearch(fpm, first_page, &result);\n\tAssert(!result.found);\n\tif (result.index > 0)\n\t\tprevkey = &result.page->u.leaf_key[result.index - 1];\n\tif (result.index < result.page->hdr.nused)\n\t{\n\t\tnp = result.page;\n\t\tnindex = result.index;\n\t\tnextkey = &result.page->u.leaf_key[result.index];\n\t}\n\telse\n\t{\n\t\tnp = FreePageBtreeFindRightSibling(base, result.page);\n\t\tnindex = 0;\n\t\tif (np != NULL)\n\t\t\tnextkey = &np->u.leaf_key[0];\n\t}\n\n\t/* Consolidate with the previous entry if possible. */\n\tif (prevkey != NULL && prevkey->first_page + prevkey->npages >= first_page)\n\t{\n\t\tbool\t\tremove_next = false;\n\t\tSize\t\tresult;\n\n\t\tAssert(prevkey->first_page + prevkey->npages == first_page);\n\t\tprevkey->npages = (first_page - prevkey->first_page) + npages;\n\n\t\t/* Check whether we can *also* consolidate with the following entry. */\n\t\tif (nextkey != NULL &&\n\t\t\tprevkey->first_page + prevkey->npages >= nextkey->first_page)\n\t\t{\n\t\t\tAssert(prevkey->first_page + prevkey->npages ==\n\t\t\t\t   nextkey->first_page);\n\t\t\tprevkey->npages = (nextkey->first_page - prevkey->first_page)\n\t\t\t\t+ nextkey->npages;\n\t\t\tFreePagePopSpanLeader(fpm, nextkey->first_page);\n\t\t\tremove_next = true;\n\t\t}\n\n\t\t/* Put the span on the correct freelist and save size. */\n\t\tFreePagePopSpanLeader(fpm, prevkey->first_page);\n\t\tFreePagePushSpanLeader(fpm, prevkey->first_page, prevkey->npages);\n\t\tresult = prevkey->npages;\n\n\t\t/*\n\t\t * If we consolidated with both the preceding and following entries,\n\t\t * we must remove the following entry.  We do this last, because\n\t\t * removing an element from the btree may invalidate pointers we hold\n\t\t * into the current data structure.\n\t\t *\n\t\t * NB: The btree is technically in an invalid state a this point\n\t\t * because we've already updated prevkey to cover the same key space\n\t\t * as nextkey.  FreePageBtreeRemove() shouldn't notice that, though.\n\t\t */\n\t\tif (remove_next)\n\t\t\tFreePageBtreeRemove(fpm, np, nindex);\n\n\t\treturn result;\n\t}\n\n\t/* Consolidate with the next entry if possible. */\n\tif (nextkey != NULL && first_page + npages >= nextkey->first_page)\n\t{\n\t\tSize\t\tnewpages;\n\n\t\t/* Compute new size for span. */\n\t\tAssert(first_page + npages == nextkey->first_page);\n\t\tnewpages = (nextkey->first_page - first_page) + nextkey->npages;\n\n\t\t/* Put span on correct free list. */\n\t\tFreePagePopSpanLeader(fpm, nextkey->first_page);\n\t\tFreePagePushSpanLeader(fpm, first_page, newpages);\n\n\t\t/* Update key in place. */\n\t\tnextkey->first_page = first_page;\n\t\tnextkey->npages = newpages;\n\n\t\t/* If reducing first key on page, ancestors might need adjustment. */\n\t\tif (nindex == 0)\n\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, np);\n\n\t\treturn nextkey->npages;\n\t}\n\n\t/* Split leaf page and as many of its ancestors as necessary. */\n\tif (result.split_pages > 0)\n\t{\n\t\t/*\n\t\t * NB: We could consider various coping strategies here to avoid a\n\t\t * split; most obviously, if np != result.page, we could target that\n\t\t * page instead.   More complicated shuffling strategies could be\n\t\t * possible as well; basically, unless every single leaf page is 100%\n\t\t * full, we can jam this key in there if we try hard enough.  It's\n\t\t * unlikely that trying that hard is worthwhile, but it's possible we\n\t\t * might need to make more than no effort.  For now, we just do the\n\t\t * easy thing, which is nothing.\n\t\t */\n\n\t\t/* If this is a soft insert, it's time to give up. */\n\t\tif (soft)\n\t\t\treturn 0;\n\n\t\t/* Check whether we need to allocate more btree pages to split. */\n\t\tif (result.split_pages > fpm->btree_recycle_count)\n\t\t{\n\t\t\tSize\t\tpages_needed;\n\t\t\tSize\t\trecycle_page;\n\t\t\tSize\t\ti;\n\n\t\t\t/*\n\t\t\t * Allocate the required number of pages and split each one in\n\t\t\t * turn.  This should never fail, because if we've got enough\n\t\t\t * spans of free pages kicking around that we need additional\n\t\t\t * storage space just to remember them all, then we should\n\t\t\t * certainly have enough to expand the btree, which should only\n\t\t\t * ever use a tiny number of pages compared to the number under\n\t\t\t * management.  If it does, something's badly screwed up.\n\t\t\t */\n\t\t\tpages_needed = result.split_pages - fpm->btree_recycle_count;\n\t\t\tfor (i = 0; i < pages_needed; ++i)\n\t\t\t{\n\t\t\t\tif (!FreePageManagerGetInternal(fpm, 1, &recycle_page))\n\t\t\t\t\telog(FATAL, \"free page manager btree is corrupt\");\n\t\t\t\tFreePageBtreeRecycle(fpm, recycle_page);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The act of allocating pages to recycle may have invalidated the\n\t\t\t * results of our previous btree reserch, so repeat it. (We could\n\t\t\t * recheck whether any of our split-avoidance strategies that were\n\t\t\t * not viable before now are, but it hardly seems worthwhile, so\n\t\t\t * we don't bother. Consolidation can't be possible now if it\n\t\t\t * wasn't previously.)\n\t\t\t */\n\t\t\tFreePageBtreeSearch(fpm, first_page, &result);\n\n\t\t\t/*\n\t\t\t * The act of allocating pages for use in constructing our btree\n\t\t\t * should never cause any page to become more full, so the new\n\t\t\t * split depth should be no greater than the old one, and perhaps\n\t\t\t * less if we fortuitously allocated a chunk that freed up a slot\n\t\t\t * on the page we need to update.\n\t\t\t */\n\t\t\tAssert(result.split_pages <= fpm->btree_recycle_count);\n\t\t}\n\n\t\t/* If we still need to perform a split, do it. */\n\t\tif (result.split_pages > 0)\n\t\t{\n\t\t\tFreePageBtree *split_target = result.page;\n\t\t\tFreePageBtree *child = NULL;\n\t\t\tSize\t\tkey = first_page;\n\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tFreePageBtree *newsibling;\n\t\t\t\tFreePageBtree *parent;\n\n\t\t\t\t/* Identify parent page, which must receive downlink. */\n\t\t\t\tparent = relptr_access(base, split_target->hdr.parent);\n\n\t\t\t\t/* Split the page - downlink not added yet. */\n\t\t\t\tnewsibling = FreePageBtreeSplitPage(fpm, split_target);\n\n\t\t\t\t/*\n\t\t\t\t * At this point in the loop, we're always carrying a pending\n\t\t\t\t * insertion.  On the first pass, it's the actual key we're\n\t\t\t\t * trying to insert; on subsequent passes, it's the downlink\n\t\t\t\t * that needs to be added as a result of the split performed\n\t\t\t\t * during the previous loop iteration.  Since we've just split\n\t\t\t\t * the page, there's definitely room on one of the two\n\t\t\t\t * resulting pages.\n\t\t\t\t */\n\t\t\t\tif (child == NULL)\n\t\t\t\t{\n\t\t\t\t\tSize\t\tindex;\n\t\t\t\t\tFreePageBtree *insert_into;\n\n\t\t\t\t\tinsert_into = key < newsibling->u.leaf_key[0].first_page ?\n\t\t\t\t\t\tsplit_target : newsibling;\n\t\t\t\t\tindex = FreePageBtreeSearchLeaf(insert_into, key);\n\t\t\t\t\tFreePageBtreeInsertLeaf(insert_into, index, key, npages);\n\t\t\t\t\tif (index == 0 && insert_into == split_target)\n\t\t\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, split_target);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSize\t\tindex;\n\t\t\t\t\tFreePageBtree *insert_into;\n\n\t\t\t\t\tinsert_into =\n\t\t\t\t\t\tkey < newsibling->u.internal_key[0].first_page ?\n\t\t\t\t\t\tsplit_target : newsibling;\n\t\t\t\t\tindex = FreePageBtreeSearchInternal(insert_into, key);\n\t\t\t\t\tFreePageBtreeInsertInternal(base, insert_into, index,\n\t\t\t\t\t\t\t\t\t\t\t\tkey, child);\n\t\t\t\t\trelptr_store(base, child->hdr.parent, insert_into);\n\t\t\t\t\tif (index == 0 && insert_into == split_target)\n\t\t\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, split_target);\n\t\t\t\t}\n\n\t\t\t\t/* If the page we just split has no parent, split the root. */\n\t\t\t\tif (parent == NULL)\n\t\t\t\t{\n\t\t\t\t\tFreePageBtree *newroot;\n\n\t\t\t\t\tnewroot = FreePageBtreeGetRecycled(fpm);\n\t\t\t\t\tnewroot->hdr.magic = FREE_PAGE_INTERNAL_MAGIC;\n\t\t\t\t\tnewroot->hdr.nused = 2;\n\t\t\t\t\trelptr_store(base, newroot->hdr.parent,\n\t\t\t\t\t\t\t\t (FreePageBtree *) NULL);\n\t\t\t\t\tnewroot->u.internal_key[0].first_page =\n\t\t\t\t\t\tFreePageBtreeFirstKey(split_target);\n\t\t\t\t\trelptr_store(base, newroot->u.internal_key[0].child,\n\t\t\t\t\t\t\t\t split_target);\n\t\t\t\t\trelptr_store(base, split_target->hdr.parent, newroot);\n\t\t\t\t\tnewroot->u.internal_key[1].first_page =\n\t\t\t\t\t\tFreePageBtreeFirstKey(newsibling);\n\t\t\t\t\trelptr_store(base, newroot->u.internal_key[1].child,\n\t\t\t\t\t\t\t\t newsibling);\n\t\t\t\t\trelptr_store(base, newsibling->hdr.parent, newroot);\n\t\t\t\t\trelptr_store(base, fpm->btree_root, newroot);\n\t\t\t\t\tfpm->btree_depth++;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* If the parent page isn't full, insert the downlink. */\n\t\t\t\tkey = newsibling->u.internal_key[0].first_page;\n\t\t\t\tif (parent->hdr.nused < FPM_ITEMS_PER_INTERNAL_PAGE)\n\t\t\t\t{\n\t\t\t\t\tSize\t\tindex;\n\n\t\t\t\t\tindex = FreePageBtreeSearchInternal(parent, key);\n\t\t\t\t\tFreePageBtreeInsertInternal(base, parent, index,\n\t\t\t\t\t\t\t\t\t\t\t\tkey, newsibling);\n\t\t\t\t\trelptr_store(base, newsibling->hdr.parent, parent);\n\t\t\t\t\tif (index == 0)\n\t\t\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, parent);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* The parent also needs to be split, so loop around. */\n\t\t\t\tchild = newsibling;\n\t\t\t\tsplit_target = parent;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The loop above did the insert, so just need to update the free\n\t\t\t * list, and we're done.\n\t\t\t */\n\t\t\tFreePagePushSpanLeader(fpm, first_page, npages);\n\n\t\t\treturn npages;\n\t\t}\n\t}\n\n\t/* Physically add the key to the page. */\n\tAssert(result.page->hdr.nused < FPM_ITEMS_PER_LEAF_PAGE);\n\tFreePageBtreeInsertLeaf(result.page, result.index, first_page, npages);\n\n\t/* If new first key on page, ancestors might need adjustment. */\n\tif (result.index == 0)\n\t\tFreePageBtreeAdjustAncestorKeys(fpm, result.page);\n\n\t/* Put it on the free list. */\n\tFreePagePushSpanLeader(fpm, first_page, npages);\n\n\treturn npages;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))",
            "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static Size FreePageManagerPutInternal(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t\t   Size npages, bool soft);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic Size FreePageManagerPutInternal(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t\t   Size npages, bool soft);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic Size\nFreePageManagerPutInternal(FreePageManager *fpm, Size first_page, Size npages,\n\t\t\t\t\t\t   bool soft)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtreeSearchResult result;\n\tFreePageBtreeLeafKey *prevkey = NULL;\n\tFreePageBtreeLeafKey *nextkey = NULL;\n\tFreePageBtree *np;\n\tSize\t\tnindex;\n\n\tAssert(npages > 0);\n\n\t/* We can store a single free span without initializing the btree. */\n\tif (fpm->btree_depth == 0)\n\t{\n\t\tif (fpm->singleton_npages == 0)\n\t\t{\n\t\t\t/* Don't have a span yet; store this one. */\n\t\t\tfpm->singleton_first_page = first_page;\n\t\t\tfpm->singleton_npages = npages;\n\t\t\tFreePagePushSpanLeader(fpm, first_page, npages);\n\t\t\treturn fpm->singleton_npages;\n\t\t}\n\t\telse if (fpm->singleton_first_page + fpm->singleton_npages ==\n\t\t\t\t first_page)\n\t\t{\n\t\t\t/* New span immediately follows sole existing span. */\n\t\t\tfpm->singleton_npages += npages;\n\t\t\tFreePagePopSpanLeader(fpm, fpm->singleton_first_page);\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t\t\treturn fpm->singleton_npages;\n\t\t}\n\t\telse if (first_page + npages == fpm->singleton_first_page)\n\t\t{\n\t\t\t/* New span immediately precedes sole existing span. */\n\t\t\tFreePagePopSpanLeader(fpm, fpm->singleton_first_page);\n\t\t\tfpm->singleton_first_page = first_page;\n\t\t\tfpm->singleton_npages += npages;\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t\t\treturn fpm->singleton_npages;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Not contiguous; we need to initialize the btree. */\n\t\t\tSize\t\troot_page;\n\t\t\tFreePageBtree *root;\n\n\t\t\tif (!relptr_is_null(fpm->btree_recycle))\n\t\t\t\troot = FreePageBtreeGetRecycled(fpm);\n\t\t\telse if (soft)\n\t\t\t\treturn 0;\t\t/* Should not allocate if soft. */\n\t\t\telse if (FreePageManagerGetInternal(fpm, 1, &root_page))\n\t\t\t\troot = (FreePageBtree *) fpm_page_to_pointer(base, root_page);\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* We'd better be able to get a page from the existing range. */\n\t\t\t\telog(FATAL, \"free page manager btree is corrupt\");\n\t\t\t}\n\n\t\t\t/* Create the btree and move the preexisting range into it. */\n\t\t\troot->hdr.magic = FREE_PAGE_LEAF_MAGIC;\n\t\t\troot->hdr.nused = 1;\n\t\t\trelptr_store(base, root->hdr.parent, (FreePageBtree *) NULL);\n\t\t\troot->u.leaf_key[0].first_page = fpm->singleton_first_page;\n\t\t\troot->u.leaf_key[0].npages = fpm->singleton_npages;\n\t\t\trelptr_store(base, fpm->btree_root, root);\n\t\t\tfpm->singleton_first_page = 0;\n\t\t\tfpm->singleton_npages = 0;\n\t\t\tfpm->btree_depth = 1;\n\n\t\t\t/*\n\t\t\t * Corner case: it may be that the btree root took the very last\n\t\t\t * free page.  In that case, the sole btree entry covers a zero\n\t\t\t * page run, which is invalid.  Overwrite it with the entry we're\n\t\t\t * trying to insert and get out.\n\t\t\t */\n\t\t\tif (root->u.leaf_key[0].npages == 0)\n\t\t\t{\n\t\t\t\troot->u.leaf_key[0].first_page = first_page;\n\t\t\t\troot->u.leaf_key[0].npages = npages;\n\t\t\t\tFreePagePushSpanLeader(fpm, first_page, npages);\n\t\t\t\treturn npages;\n\t\t\t}\n\n\t\t\t/* Fall through to insert the new key. */\n\t\t}\n\t}\n\n\t/* Search the btree. */\n\tFreePageBtreeSearch(fpm, first_page, &result);\n\tAssert(!result.found);\n\tif (result.index > 0)\n\t\tprevkey = &result.page->u.leaf_key[result.index - 1];\n\tif (result.index < result.page->hdr.nused)\n\t{\n\t\tnp = result.page;\n\t\tnindex = result.index;\n\t\tnextkey = &result.page->u.leaf_key[result.index];\n\t}\n\telse\n\t{\n\t\tnp = FreePageBtreeFindRightSibling(base, result.page);\n\t\tnindex = 0;\n\t\tif (np != NULL)\n\t\t\tnextkey = &np->u.leaf_key[0];\n\t}\n\n\t/* Consolidate with the previous entry if possible. */\n\tif (prevkey != NULL && prevkey->first_page + prevkey->npages >= first_page)\n\t{\n\t\tbool\t\tremove_next = false;\n\t\tSize\t\tresult;\n\n\t\tAssert(prevkey->first_page + prevkey->npages == first_page);\n\t\tprevkey->npages = (first_page - prevkey->first_page) + npages;\n\n\t\t/* Check whether we can *also* consolidate with the following entry. */\n\t\tif (nextkey != NULL &&\n\t\t\tprevkey->first_page + prevkey->npages >= nextkey->first_page)\n\t\t{\n\t\t\tAssert(prevkey->first_page + prevkey->npages ==\n\t\t\t\t   nextkey->first_page);\n\t\t\tprevkey->npages = (nextkey->first_page - prevkey->first_page)\n\t\t\t\t+ nextkey->npages;\n\t\t\tFreePagePopSpanLeader(fpm, nextkey->first_page);\n\t\t\tremove_next = true;\n\t\t}\n\n\t\t/* Put the span on the correct freelist and save size. */\n\t\tFreePagePopSpanLeader(fpm, prevkey->first_page);\n\t\tFreePagePushSpanLeader(fpm, prevkey->first_page, prevkey->npages);\n\t\tresult = prevkey->npages;\n\n\t\t/*\n\t\t * If we consolidated with both the preceding and following entries,\n\t\t * we must remove the following entry.  We do this last, because\n\t\t * removing an element from the btree may invalidate pointers we hold\n\t\t * into the current data structure.\n\t\t *\n\t\t * NB: The btree is technically in an invalid state a this point\n\t\t * because we've already updated prevkey to cover the same key space\n\t\t * as nextkey.  FreePageBtreeRemove() shouldn't notice that, though.\n\t\t */\n\t\tif (remove_next)\n\t\t\tFreePageBtreeRemove(fpm, np, nindex);\n\n\t\treturn result;\n\t}\n\n\t/* Consolidate with the next entry if possible. */\n\tif (nextkey != NULL && first_page + npages >= nextkey->first_page)\n\t{\n\t\tSize\t\tnewpages;\n\n\t\t/* Compute new size for span. */\n\t\tAssert(first_page + npages == nextkey->first_page);\n\t\tnewpages = (nextkey->first_page - first_page) + nextkey->npages;\n\n\t\t/* Put span on correct free list. */\n\t\tFreePagePopSpanLeader(fpm, nextkey->first_page);\n\t\tFreePagePushSpanLeader(fpm, first_page, newpages);\n\n\t\t/* Update key in place. */\n\t\tnextkey->first_page = first_page;\n\t\tnextkey->npages = newpages;\n\n\t\t/* If reducing first key on page, ancestors might need adjustment. */\n\t\tif (nindex == 0)\n\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, np);\n\n\t\treturn nextkey->npages;\n\t}\n\n\t/* Split leaf page and as many of its ancestors as necessary. */\n\tif (result.split_pages > 0)\n\t{\n\t\t/*\n\t\t * NB: We could consider various coping strategies here to avoid a\n\t\t * split; most obviously, if np != result.page, we could target that\n\t\t * page instead.   More complicated shuffling strategies could be\n\t\t * possible as well; basically, unless every single leaf page is 100%\n\t\t * full, we can jam this key in there if we try hard enough.  It's\n\t\t * unlikely that trying that hard is worthwhile, but it's possible we\n\t\t * might need to make more than no effort.  For now, we just do the\n\t\t * easy thing, which is nothing.\n\t\t */\n\n\t\t/* If this is a soft insert, it's time to give up. */\n\t\tif (soft)\n\t\t\treturn 0;\n\n\t\t/* Check whether we need to allocate more btree pages to split. */\n\t\tif (result.split_pages > fpm->btree_recycle_count)\n\t\t{\n\t\t\tSize\t\tpages_needed;\n\t\t\tSize\t\trecycle_page;\n\t\t\tSize\t\ti;\n\n\t\t\t/*\n\t\t\t * Allocate the required number of pages and split each one in\n\t\t\t * turn.  This should never fail, because if we've got enough\n\t\t\t * spans of free pages kicking around that we need additional\n\t\t\t * storage space just to remember them all, then we should\n\t\t\t * certainly have enough to expand the btree, which should only\n\t\t\t * ever use a tiny number of pages compared to the number under\n\t\t\t * management.  If it does, something's badly screwed up.\n\t\t\t */\n\t\t\tpages_needed = result.split_pages - fpm->btree_recycle_count;\n\t\t\tfor (i = 0; i < pages_needed; ++i)\n\t\t\t{\n\t\t\t\tif (!FreePageManagerGetInternal(fpm, 1, &recycle_page))\n\t\t\t\t\telog(FATAL, \"free page manager btree is corrupt\");\n\t\t\t\tFreePageBtreeRecycle(fpm, recycle_page);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The act of allocating pages to recycle may have invalidated the\n\t\t\t * results of our previous btree reserch, so repeat it. (We could\n\t\t\t * recheck whether any of our split-avoidance strategies that were\n\t\t\t * not viable before now are, but it hardly seems worthwhile, so\n\t\t\t * we don't bother. Consolidation can't be possible now if it\n\t\t\t * wasn't previously.)\n\t\t\t */\n\t\t\tFreePageBtreeSearch(fpm, first_page, &result);\n\n\t\t\t/*\n\t\t\t * The act of allocating pages for use in constructing our btree\n\t\t\t * should never cause any page to become more full, so the new\n\t\t\t * split depth should be no greater than the old one, and perhaps\n\t\t\t * less if we fortuitously allocated a chunk that freed up a slot\n\t\t\t * on the page we need to update.\n\t\t\t */\n\t\t\tAssert(result.split_pages <= fpm->btree_recycle_count);\n\t\t}\n\n\t\t/* If we still need to perform a split, do it. */\n\t\tif (result.split_pages > 0)\n\t\t{\n\t\t\tFreePageBtree *split_target = result.page;\n\t\t\tFreePageBtree *child = NULL;\n\t\t\tSize\t\tkey = first_page;\n\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tFreePageBtree *newsibling;\n\t\t\t\tFreePageBtree *parent;\n\n\t\t\t\t/* Identify parent page, which must receive downlink. */\n\t\t\t\tparent = relptr_access(base, split_target->hdr.parent);\n\n\t\t\t\t/* Split the page - downlink not added yet. */\n\t\t\t\tnewsibling = FreePageBtreeSplitPage(fpm, split_target);\n\n\t\t\t\t/*\n\t\t\t\t * At this point in the loop, we're always carrying a pending\n\t\t\t\t * insertion.  On the first pass, it's the actual key we're\n\t\t\t\t * trying to insert; on subsequent passes, it's the downlink\n\t\t\t\t * that needs to be added as a result of the split performed\n\t\t\t\t * during the previous loop iteration.  Since we've just split\n\t\t\t\t * the page, there's definitely room on one of the two\n\t\t\t\t * resulting pages.\n\t\t\t\t */\n\t\t\t\tif (child == NULL)\n\t\t\t\t{\n\t\t\t\t\tSize\t\tindex;\n\t\t\t\t\tFreePageBtree *insert_into;\n\n\t\t\t\t\tinsert_into = key < newsibling->u.leaf_key[0].first_page ?\n\t\t\t\t\t\tsplit_target : newsibling;\n\t\t\t\t\tindex = FreePageBtreeSearchLeaf(insert_into, key);\n\t\t\t\t\tFreePageBtreeInsertLeaf(insert_into, index, key, npages);\n\t\t\t\t\tif (index == 0 && insert_into == split_target)\n\t\t\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, split_target);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSize\t\tindex;\n\t\t\t\t\tFreePageBtree *insert_into;\n\n\t\t\t\t\tinsert_into =\n\t\t\t\t\t\tkey < newsibling->u.internal_key[0].first_page ?\n\t\t\t\t\t\tsplit_target : newsibling;\n\t\t\t\t\tindex = FreePageBtreeSearchInternal(insert_into, key);\n\t\t\t\t\tFreePageBtreeInsertInternal(base, insert_into, index,\n\t\t\t\t\t\t\t\t\t\t\t\tkey, child);\n\t\t\t\t\trelptr_store(base, child->hdr.parent, insert_into);\n\t\t\t\t\tif (index == 0 && insert_into == split_target)\n\t\t\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, split_target);\n\t\t\t\t}\n\n\t\t\t\t/* If the page we just split has no parent, split the root. */\n\t\t\t\tif (parent == NULL)\n\t\t\t\t{\n\t\t\t\t\tFreePageBtree *newroot;\n\n\t\t\t\t\tnewroot = FreePageBtreeGetRecycled(fpm);\n\t\t\t\t\tnewroot->hdr.magic = FREE_PAGE_INTERNAL_MAGIC;\n\t\t\t\t\tnewroot->hdr.nused = 2;\n\t\t\t\t\trelptr_store(base, newroot->hdr.parent,\n\t\t\t\t\t\t\t\t (FreePageBtree *) NULL);\n\t\t\t\t\tnewroot->u.internal_key[0].first_page =\n\t\t\t\t\t\tFreePageBtreeFirstKey(split_target);\n\t\t\t\t\trelptr_store(base, newroot->u.internal_key[0].child,\n\t\t\t\t\t\t\t\t split_target);\n\t\t\t\t\trelptr_store(base, split_target->hdr.parent, newroot);\n\t\t\t\t\tnewroot->u.internal_key[1].first_page =\n\t\t\t\t\t\tFreePageBtreeFirstKey(newsibling);\n\t\t\t\t\trelptr_store(base, newroot->u.internal_key[1].child,\n\t\t\t\t\t\t\t\t newsibling);\n\t\t\t\t\trelptr_store(base, newsibling->hdr.parent, newroot);\n\t\t\t\t\trelptr_store(base, fpm->btree_root, newroot);\n\t\t\t\t\tfpm->btree_depth++;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* If the parent page isn't full, insert the downlink. */\n\t\t\t\tkey = newsibling->u.internal_key[0].first_page;\n\t\t\t\tif (parent->hdr.nused < FPM_ITEMS_PER_INTERNAL_PAGE)\n\t\t\t\t{\n\t\t\t\t\tSize\t\tindex;\n\n\t\t\t\t\tindex = FreePageBtreeSearchInternal(parent, key);\n\t\t\t\t\tFreePageBtreeInsertInternal(base, parent, index,\n\t\t\t\t\t\t\t\t\t\t\t\tkey, newsibling);\n\t\t\t\t\trelptr_store(base, newsibling->hdr.parent, parent);\n\t\t\t\t\tif (index == 0)\n\t\t\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, parent);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* The parent also needs to be split, so loop around. */\n\t\t\t\tchild = newsibling;\n\t\t\t\tsplit_target = parent;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The loop above did the insert, so just need to update the free\n\t\t\t * list, and we're done.\n\t\t\t */\n\t\t\tFreePagePushSpanLeader(fpm, first_page, npages);\n\n\t\t\treturn npages;\n\t\t}\n\t}\n\n\t/* Physically add the key to the page. */\n\tAssert(result.page->hdr.nused < FPM_ITEMS_PER_LEAF_PAGE);\n\tFreePageBtreeInsertLeaf(result.page, result.index, first_page, npages);\n\n\t/* If new first key on page, ancestors might need adjustment. */\n\tif (result.index == 0)\n\t\tFreePageBtreeAdjustAncestorKeys(fpm, result.page);\n\n\t/* Put it on the free list. */\n\tFreePagePushSpanLeader(fpm, first_page, npages);\n\n\treturn npages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fpm_pointer_to_page",
          "args": [
            "base",
            "btp"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeGetRecycled",
          "args": [
            "fpm"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeGetRecycled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "879-894",
          "snippet": "static FreePageBtree *\nFreePageBtreeGetRecycled(FreePageManager *fpm)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *victim = relptr_access(base, fpm->btree_recycle);\n\tFreePageSpanLeader *newhead;\n\n\tAssert(victim != NULL);\n\tnewhead = relptr_access(base, victim->next);\n\tif (newhead != NULL)\n\t\trelptr_copy(newhead->prev, victim->prev);\n\trelptr_store(base, fpm->btree_recycle, newhead);\n\tAssert(fpm_pointer_is_page_aligned(base, victim));\n\tfpm->btree_recycle_count--;\n\treturn (FreePageBtree *) victim;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic FreePageBtree *\nFreePageBtreeGetRecycled(FreePageManager *fpm)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *victim = relptr_access(base, fpm->btree_recycle);\n\tFreePageSpanLeader *newhead;\n\n\tAssert(victim != NULL);\n\tnewhead = relptr_access(base, victim->next);\n\tif (newhead != NULL)\n\t\trelptr_copy(newhead->prev, victim->prev);\n\trelptr_store(base, fpm->btree_recycle, newhead);\n\tAssert(fpm_pointer_is_page_aligned(base, victim));\n\tfpm->btree_recycle_count--;\n\treturn (FreePageBtree *) victim;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "max_contiguous_pages == 0"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePagePushSpanLeader",
          "args": [
            "fpm",
            "fpm->singleton_first_page",
            "fpm->singleton_npages"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "FreePagePushSpanLeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1870-1886",
          "snippet": "static void\nFreePagePushSpanLeader(FreePageManager *fpm, Size first_page, Size npages)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tf = Min(npages, FPM_NUM_FREELISTS) - 1;\n\tFreePageSpanLeader *head = relptr_access(base, fpm->freelist[f]);\n\tFreePageSpanLeader *span;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, first_page);\n\tspan->magic = FREE_PAGE_SPAN_LEADER_MAGIC;\n\tspan->npages = npages;\n\trelptr_store(base, span->next, head);\n\trelptr_store(base, span->prev, (FreePageSpanLeader *) NULL);\n\tif (head != NULL)\n\t\trelptr_store(base, head->prev, span);\n\trelptr_store(base, fpm->freelist[f], span);\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0"
          ],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePagePushSpanLeader(FreePageManager *fpm, Size first_page, Size npages)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tf = Min(npages, FPM_NUM_FREELISTS) - 1;\n\tFreePageSpanLeader *head = relptr_access(base, fpm->freelist[f]);\n\tFreePageSpanLeader *span;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, first_page);\n\tspan->magic = FREE_PAGE_SPAN_LEADER_MAGIC;\n\tspan->npages = npages;\n\trelptr_store(base, span->next, head);\n\trelptr_store(base, span->prev, (FreePageSpanLeader *) NULL);\n\tif (head != NULL)\n\t\trelptr_store(base, head->prev, span);\n\trelptr_store(base, fpm->freelist[f], span);\n}"
        }
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "fpm->btree_root",
            "(FreePageBtree *) NULL"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePagePopSpanLeader",
          "args": [
            "fpm",
            "root->u.leaf_key[1].first_page"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "FreePagePopSpanLeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1842-1865",
          "snippet": "static void\nFreePagePopSpanLeader(FreePageManager *fpm, Size pageno)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *span;\n\tFreePageSpanLeader *next;\n\tFreePageSpanLeader *prev;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, pageno);\n\n\tnext = relptr_access(base, span->next);\n\tprev = relptr_access(base, span->prev);\n\tif (next != NULL)\n\t\trelptr_copy(next->prev, span->prev);\n\tif (prev != NULL)\n\t\trelptr_copy(prev->next, span->next);\n\telse\n\t{\n\t\tSize\t\tf = Min(span->npages, FPM_NUM_FREELISTS) - 1;\n\n\t\tAssert(fpm->freelist[f].relptr_off == pageno * FPM_PAGE_SIZE);\n\t\trelptr_copy(fpm->freelist[f], span->next);\n\t}\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePageBtreeRecycle(FreePageManager *fpm, Size pageno);",
            "static void FreePagePopSpanLeader(FreePageManager *fpm, Size pageno);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRecycle(FreePageManager *fpm, Size pageno);\nstatic void FreePagePopSpanLeader(FreePageManager *fpm, Size pageno);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePagePopSpanLeader(FreePageManager *fpm, Size pageno)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *span;\n\tFreePageSpanLeader *next;\n\tFreePageSpanLeader *prev;\n\n\tspan = (FreePageSpanLeader *) fpm_page_to_pointer(base, pageno);\n\n\tnext = relptr_access(base, span->next);\n\tprev = relptr_access(base, span->prev);\n\tif (next != NULL)\n\t\trelptr_copy(next->prev, span->prev);\n\tif (prev != NULL)\n\t\trelptr_copy(prev->next, span->next);\n\telse\n\t{\n\t\tSize\t\tf = Min(span->npages, FPM_NUM_FREELISTS) - 1;\n\n\t\tAssert(fpm->freelist[f].relptr_off == pageno * FPM_PAGE_SIZE);\n\t\trelptr_copy(fpm->freelist[f], span->next);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fpm_pointer_to_page",
          "args": [
            "base",
            "root"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_pointer_to_page",
          "args": [
            "base",
            "root"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "newroot->hdr.parent",
            "(FreePageBtree *) NULL"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "fpm->btree_root"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_copy",
          "args": [
            "fpm->btree_root",
            "root->u.internal_key[0].child"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "root->hdr.magic == FREE_PAGE_INTERNAL_MAGIC"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "fpm->btree_root",
            "(FreePageBtree *) NULL"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "fpm->btree_depth > 0"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "fpm->btree_root"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_is_null",
          "args": [
            "fpm->btree_root"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_segment_base",
          "args": [
            "fpm"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic Size\nFreePageBtreeCleanup(FreePageManager *fpm)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tmax_contiguous_pages = 0;\n\n\t/* Attempt to shrink the depth of the btree. */\n\twhile (!relptr_is_null(fpm->btree_root))\n\t{\n\t\tFreePageBtree *root = relptr_access(base, fpm->btree_root);\n\n\t\t/* If the root contains only one key, reduce depth by one. */\n\t\tif (root->hdr.nused == 1)\n\t\t{\n\t\t\t/* Shrink depth of tree by one. */\n\t\t\tAssert(fpm->btree_depth > 0);\n\t\t\t--fpm->btree_depth;\n\t\t\tif (root->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t\t{\n\t\t\t\t/* If root is a leaf, convert only entry to singleton range. */\n\t\t\t\trelptr_store(base, fpm->btree_root, (FreePageBtree *) NULL);\n\t\t\t\tfpm->singleton_first_page = root->u.leaf_key[0].first_page;\n\t\t\t\tfpm->singleton_npages = root->u.leaf_key[0].npages;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFreePageBtree *newroot;\n\n\t\t\t\t/* If root is an internal page, make only child the root. */\n\t\t\t\tAssert(root->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\t\t\trelptr_copy(fpm->btree_root, root->u.internal_key[0].child);\n\t\t\t\tnewroot = relptr_access(base, fpm->btree_root);\n\t\t\t\trelptr_store(base, newroot->hdr.parent, (FreePageBtree *) NULL);\n\t\t\t}\n\t\t\tFreePageBtreeRecycle(fpm, fpm_pointer_to_page(base, root));\n\t\t}\n\t\telse if (root->hdr.nused == 2 &&\n\t\t\t\t root->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t{\n\t\t\tSize\t\tend_of_first;\n\t\t\tSize\t\tstart_of_second;\n\n\t\t\tend_of_first = root->u.leaf_key[0].first_page +\n\t\t\t\troot->u.leaf_key[0].npages;\n\t\t\tstart_of_second = root->u.leaf_key[1].first_page;\n\n\t\t\tif (end_of_first + 1 == start_of_second)\n\t\t\t{\n\t\t\t\tSize\t\troot_page = fpm_pointer_to_page(base, root);\n\n\t\t\t\tif (end_of_first == root_page)\n\t\t\t\t{\n\t\t\t\t\tFreePagePopSpanLeader(fpm, root->u.leaf_key[0].first_page);\n\t\t\t\t\tFreePagePopSpanLeader(fpm, root->u.leaf_key[1].first_page);\n\t\t\t\t\tfpm->singleton_first_page = root->u.leaf_key[0].first_page;\n\t\t\t\t\tfpm->singleton_npages = root->u.leaf_key[0].npages +\n\t\t\t\t\t\troot->u.leaf_key[1].npages + 1;\n\t\t\t\t\tfpm->btree_depth = 0;\n\t\t\t\t\trelptr_store(base, fpm->btree_root,\n\t\t\t\t\t\t\t\t (FreePageBtree *) NULL);\n\t\t\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t\t\t\t\tAssert(max_contiguous_pages == 0);\n\t\t\t\t\tmax_contiguous_pages = fpm->singleton_npages;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Whether it worked or not, it's time to stop. */\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Nothing more to do.  Stop. */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Attempt to free recycled btree pages.  We skip this if releasing the\n\t * recycled page would require a btree page split, because the page we're\n\t * trying to recycle would be consumed by the split, which would be\n\t * counterproductive.\n\t *\n\t * We also currently only ever attempt to recycle the first page on the\n\t * list; that could be made more aggressive, but it's not clear that the\n\t * complexity would be worthwhile.\n\t */\n\twhile (fpm->btree_recycle_count > 0)\n\t{\n\t\tFreePageBtree *btp;\n\t\tSize\t\tfirst_page;\n\t\tSize\t\tcontiguous_pages;\n\n\t\tbtp = FreePageBtreeGetRecycled(fpm);\n\t\tfirst_page = fpm_pointer_to_page(base, btp);\n\t\tcontiguous_pages = FreePageManagerPutInternal(fpm, first_page, 1, true);\n\t\tif (contiguous_pages == 0)\n\t\t{\n\t\t\tFreePageBtreeRecycle(fpm, first_page);\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (contiguous_pages > max_contiguous_pages)\n\t\t\t\tmax_contiguous_pages = contiguous_pages;\n\t\t}\n\t}\n\n\treturn max_contiguous_pages;\n}"
  },
  {
    "function_name": "FreePageBtreeAdjustAncestorKeys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "500-573",
    "snippet": "static void\nFreePageBtreeAdjustAncestorKeys(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tfirst_page;\n\tFreePageBtree *parent;\n\tFreePageBtree *child;\n\n\t/* This might be either a leaf or an internal page. */\n\tAssert(btp->hdr.nused > 0);\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t{\n\t\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_LEAF_PAGE);\n\t\tfirst_page = btp->u.leaf_key[0].first_page;\n\t}\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\tfirst_page = btp->u.internal_key[0].first_page;\n\t}\n\tchild = btp;\n\n\t/* Loop until we find an ancestor that does not require adjustment. */\n\tfor (;;)\n\t{\n\t\tSize\t\ts;\n\n\t\tparent = relptr_access(base, child->hdr.parent);\n\t\tif (parent == NULL)\n\t\t\tbreak;\n\t\ts = FreePageBtreeSearchInternal(parent, first_page);\n\n\t\t/* Key is either at index s or index s-1; figure out which. */\n\t\tif (s >= parent->hdr.nused)\n\t\t{\n\t\t\tAssert(s == parent->hdr.nused);\n\t\t\t--s;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFreePageBtree *check;\n\n\t\t\tcheck = relptr_access(base, parent->u.internal_key[s].child);\n\t\t\tif (check != child)\n\t\t\t{\n\t\t\t\tAssert(s > 0);\n\t\t\t\t--s;\n\t\t\t}\n\t\t}\n\n#ifdef USE_ASSERT_CHECKING\n\t\t/* Debugging double-check. */\n\t\t{\n\t\t\tFreePageBtree *check;\n\n\t\t\tcheck = relptr_access(base, parent->u.internal_key[s].child);\n\t\t\tAssert(s < parent->hdr.nused);\n\t\t\tAssert(child == check);\n\t\t}\n#endif\n\n\t\t/* Update the parent key. */\n\t\tparent->u.internal_key[s].first_page = first_page;\n\n\t\t/*\n\t\t * If this is the first key in the parent, go up another level; else\n\t\t * done.\n\t\t */\n\t\tif (s > 0)\n\t\t\tbreak;\n\t\tchild = parent;\n\t}\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))",
      "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
      "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
      "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
    ],
    "globals_used": [
      "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
      "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
      "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
      "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
      "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
      "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
      "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
      "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
      "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "child == check"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "s < parent->hdr.nused"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "parent->u.internal_key[s].child"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "s > 0"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "parent->u.internal_key[s].child"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "s == parent->hdr.nused"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageBtreeSearchInternal",
          "args": [
            "parent",
            "first_page"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeSearchInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1139-1162",
          "snippet": "static Size\nFreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.internal_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\n\nstatic Size\nFreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page)\n{\n\tSize\t\tlow = 0;\n\tSize\t\thigh = btp->hdr.nused;\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\tAssert(high > 0 && high <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\n\twhile (low < high)\n\t{\n\t\tSize\t\tmid = (low + high) / 2;\n\t\tSize\t\tval = btp->u.internal_key[mid].first_page;\n\n\t\tif (first_page == val)\n\t\t\treturn mid;\n\t\telse if (first_page < val)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\n\treturn low;\n}"
        }
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "child->hdr.parent"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "btp->hdr.nused <= FPM_ITEMS_PER_INTERNAL_PAGE"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "btp->hdr.nused <= FPM_ITEMS_PER_LEAF_PAGE"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "btp->hdr.nused > 0"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_segment_base",
          "args": [
            "fpm"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageBtreeAdjustAncestorKeys(FreePageManager *fpm, FreePageBtree *btp)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tfirst_page;\n\tFreePageBtree *parent;\n\tFreePageBtree *child;\n\n\t/* This might be either a leaf or an internal page. */\n\tAssert(btp->hdr.nused > 0);\n\tif (btp->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t{\n\t\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_LEAF_PAGE);\n\t\tfirst_page = btp->u.leaf_key[0].first_page;\n\t}\n\telse\n\t{\n\t\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\tAssert(btp->hdr.nused <= FPM_ITEMS_PER_INTERNAL_PAGE);\n\t\tfirst_page = btp->u.internal_key[0].first_page;\n\t}\n\tchild = btp;\n\n\t/* Loop until we find an ancestor that does not require adjustment. */\n\tfor (;;)\n\t{\n\t\tSize\t\ts;\n\n\t\tparent = relptr_access(base, child->hdr.parent);\n\t\tif (parent == NULL)\n\t\t\tbreak;\n\t\ts = FreePageBtreeSearchInternal(parent, first_page);\n\n\t\t/* Key is either at index s or index s-1; figure out which. */\n\t\tif (s >= parent->hdr.nused)\n\t\t{\n\t\t\tAssert(s == parent->hdr.nused);\n\t\t\t--s;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tFreePageBtree *check;\n\n\t\t\tcheck = relptr_access(base, parent->u.internal_key[s].child);\n\t\t\tif (check != child)\n\t\t\t{\n\t\t\t\tAssert(s > 0);\n\t\t\t\t--s;\n\t\t\t}\n\t\t}\n\n#ifdef USE_ASSERT_CHECKING\n\t\t/* Debugging double-check. */\n\t\t{\n\t\t\tFreePageBtree *check;\n\n\t\t\tcheck = relptr_access(base, parent->u.internal_key[s].child);\n\t\t\tAssert(s < parent->hdr.nused);\n\t\t\tAssert(child == check);\n\t\t}\n#endif\n\n\t\t/* Update the parent key. */\n\t\tparent->u.internal_key[s].first_page = first_page;\n\n\t\t/*\n\t\t * If this is the first key in the parent, go up another level; else\n\t\t * done.\n\t\t */\n\t\tif (s > 0)\n\t\t\tbreak;\n\t\tchild = parent;\n\t}\n}"
  },
  {
    "function_name": "FreePageManagerDump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "423-481",
    "snippet": "char *\nFreePageManagerDump(FreePageManager *fpm)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tStringInfoData buf;\n\tFreePageSpanLeader *recycle;\n\tbool\t\tdumped_any_freelist = false;\n\tSize\t\tf;\n\n\t/* Initialize output buffer. */\n\tinitStringInfo(&buf);\n\n\t/* Dump general stuff. */\n\tappendStringInfo(&buf, \"metadata: self %zu max contiguous pages = %zu\\n\",\n\t\t\t\t\t fpm->self.relptr_off, fpm->contiguous_pages);\n\n\t/* Dump btree. */\n\tif (fpm->btree_depth > 0)\n\t{\n\t\tFreePageBtree *root;\n\n\t\tappendStringInfo(&buf, \"btree depth %u:\\n\", fpm->btree_depth);\n\t\troot = relptr_access(base, fpm->btree_root);\n\t\tFreePageManagerDumpBtree(fpm, root, NULL, 0, &buf);\n\t}\n\telse if (fpm->singleton_npages > 0)\n\t{\n\t\tappendStringInfo(&buf, \"singleton: %zu(%zu)\\n\",\n\t\t\t\t\t\t fpm->singleton_first_page, fpm->singleton_npages);\n\t}\n\n\t/* Dump btree recycle list. */\n\trecycle = relptr_access(base, fpm->btree_recycle);\n\tif (recycle != NULL)\n\t{\n\t\tappendStringInfoString(&buf, \"btree recycle:\");\n\t\tFreePageManagerDumpSpans(fpm, recycle, 1, &buf);\n\t}\n\n\t/* Dump free lists. */\n\tfor (f = 0; f < FPM_NUM_FREELISTS; ++f)\n\t{\n\t\tFreePageSpanLeader *span;\n\n\t\tif (relptr_is_null(fpm->freelist[f]))\n\t\t\tcontinue;\n\t\tif (!dumped_any_freelist)\n\t\t{\n\t\t\tappendStringInfoString(&buf, \"freelists:\\n\");\n\t\t\tdumped_any_freelist = true;\n\t\t}\n\t\tappendStringInfo(&buf, \"  %zu:\", f + 1);\n\t\tspan = relptr_access(base, fpm->freelist[f]);\n\t\tFreePageManagerDumpSpans(fpm, span, f + 1, &buf);\n\t}\n\n\t/* And return result to caller. */\n\treturn buf.data;\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);",
      "static void FreePageManagerDumpBtree(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\t\t FreePageBtree *parent, int level, StringInfo buf);",
      "static void FreePageManagerDumpSpans(FreePageManager *fpm,\n\t\t\t\t\t\t FreePageSpanLeader *span, Size expected_pages,\n\t\t\t\t\t\t StringInfo buf);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreePageManagerDumpSpans",
          "args": [
            "fpm",
            "span",
            "f + 1",
            "&buf"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageManagerDumpSpans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1295-1312",
          "snippet": "static void\nFreePageManagerDumpSpans(FreePageManager *fpm, FreePageSpanLeader *span,\n\t\t\t\t\t\t Size expected_pages, StringInfo buf)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\n\twhile (span != NULL)\n\t{\n\t\tif (span->npages != expected_pages)\n\t\t\tappendStringInfo(buf, \" %zu(%zu)\", fpm_pointer_to_page(base, span),\n\t\t\t\t\t\t\t span->npages);\n\t\telse\n\t\t\tappendStringInfo(buf, \" %zu\", fpm_pointer_to_page(base, span));\n\t\tspan = relptr_access(base, span->next);\n\t}\n\n\tappendStringInfoChar(buf, '\\n');\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePageManagerDumpBtree(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\t\t FreePageBtree *parent, int level, StringInfo buf);",
            "static void FreePageManagerDumpSpans(FreePageManager *fpm,\n\t\t\t\t\t\t FreePageSpanLeader *span, Size expected_pages,\n\t\t\t\t\t\t StringInfo buf);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageManagerDumpBtree(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\t\t FreePageBtree *parent, int level, StringInfo buf);\nstatic void FreePageManagerDumpSpans(FreePageManager *fpm,\n\t\t\t\t\t\t FreePageSpanLeader *span, Size expected_pages,\n\t\t\t\t\t\t StringInfo buf);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageManagerDumpSpans(FreePageManager *fpm, FreePageSpanLeader *span,\n\t\t\t\t\t\t Size expected_pages, StringInfo buf)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\n\twhile (span != NULL)\n\t{\n\t\tif (span->npages != expected_pages)\n\t\t\tappendStringInfo(buf, \" %zu(%zu)\", fpm_pointer_to_page(base, span),\n\t\t\t\t\t\t\t span->npages);\n\t\telse\n\t\t\tappendStringInfo(buf, \" %zu\", fpm_pointer_to_page(base, span));\n\t\tspan = relptr_access(base, span->next);\n\t}\n\n\tappendStringInfoChar(buf, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "fpm->freelist[f]"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"  %zu:\"",
            "f + 1"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "\"freelists:\\n\""
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_is_null",
          "args": [
            "fpm->freelist[f]"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "\"btree recycle:\""
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "fpm->btree_recycle"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"singleton: %zu(%zu)\\n\"",
            "fpm->singleton_first_page",
            "fpm->singleton_npages"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageManagerDumpBtree",
          "args": [
            "fpm",
            "root",
            "NULL",
            "0",
            "&buf"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageManagerDumpBtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1249-1290",
          "snippet": "static void\nFreePageManagerDumpBtree(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\t\t FreePageBtree *parent, int level, StringInfo buf)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tpageno = fpm_pointer_to_page(base, btp);\n\tSize\t\tindex;\n\tFreePageBtree *check_parent;\n\n\tcheck_stack_depth();\n\tcheck_parent = relptr_access(base, btp->hdr.parent);\n\tappendStringInfo(buf, \"  %zu@%d %c\", pageno, level,\n\t\t\t\t\t btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC ? 'i' : 'l');\n\tif (parent != check_parent)\n\t\tappendStringInfo(buf, \" [actual parent %zu, expected %zu]\",\n\t\t\t\t\t\t fpm_pointer_to_page(base, check_parent),\n\t\t\t\t\t\t fpm_pointer_to_page(base, parent));\n\tappendStringInfoChar(buf, ':');\n\tfor (index = 0; index < btp->hdr.nused; ++index)\n\t{\n\t\tif (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t\t\tappendStringInfo(buf, \" %zu->%zu\",\n\t\t\t\t\t\t\t btp->u.internal_key[index].first_page,\n\t\t\t\t\t\t\t btp->u.internal_key[index].child.relptr_off / FPM_PAGE_SIZE);\n\t\telse\n\t\t\tappendStringInfo(buf, \" %zu(%zu)\",\n\t\t\t\t\t\t\t btp->u.leaf_key[index].first_page,\n\t\t\t\t\t\t\t btp->u.leaf_key[index].npages);\n\t}\n\tappendStringInfoChar(buf, '\\n');\n\n\tif (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t{\n\t\tfor (index = 0; index < btp->hdr.nused; ++index)\n\t\t{\n\t\t\tFreePageBtree *child;\n\n\t\t\tchild = relptr_access(base, btp->u.internal_key[index].child);\n\t\t\tFreePageManagerDumpBtree(fpm, child, btp, level + 1, buf);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePageBtreeRecycle(FreePageManager *fpm, Size pageno);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static void FreePageManagerDumpBtree(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\t\t FreePageBtree *parent, int level, StringInfo buf);",
            "static void FreePageManagerDumpSpans(FreePageManager *fpm,\n\t\t\t\t\t\t FreePageSpanLeader *span, Size expected_pages,\n\t\t\t\t\t\t StringInfo buf);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static void FreePagePopSpanLeader(FreePageManager *fpm, Size pageno);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRecycle(FreePageManager *fpm, Size pageno);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic void FreePageManagerDumpBtree(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\t\t FreePageBtree *parent, int level, StringInfo buf);\nstatic void FreePageManagerDumpSpans(FreePageManager *fpm,\n\t\t\t\t\t\t FreePageSpanLeader *span, Size expected_pages,\n\t\t\t\t\t\t StringInfo buf);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePopSpanLeader(FreePageManager *fpm, Size pageno);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageManagerDumpBtree(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\t\t FreePageBtree *parent, int level, StringInfo buf)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tpageno = fpm_pointer_to_page(base, btp);\n\tSize\t\tindex;\n\tFreePageBtree *check_parent;\n\n\tcheck_stack_depth();\n\tcheck_parent = relptr_access(base, btp->hdr.parent);\n\tappendStringInfo(buf, \"  %zu@%d %c\", pageno, level,\n\t\t\t\t\t btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC ? 'i' : 'l');\n\tif (parent != check_parent)\n\t\tappendStringInfo(buf, \" [actual parent %zu, expected %zu]\",\n\t\t\t\t\t\t fpm_pointer_to_page(base, check_parent),\n\t\t\t\t\t\t fpm_pointer_to_page(base, parent));\n\tappendStringInfoChar(buf, ':');\n\tfor (index = 0; index < btp->hdr.nused; ++index)\n\t{\n\t\tif (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t\t\tappendStringInfo(buf, \" %zu->%zu\",\n\t\t\t\t\t\t\t btp->u.internal_key[index].first_page,\n\t\t\t\t\t\t\t btp->u.internal_key[index].child.relptr_off / FPM_PAGE_SIZE);\n\t\telse\n\t\t\tappendStringInfo(buf, \" %zu(%zu)\",\n\t\t\t\t\t\t\t btp->u.leaf_key[index].first_page,\n\t\t\t\t\t\t\t btp->u.leaf_key[index].npages);\n\t}\n\tappendStringInfoChar(buf, '\\n');\n\n\tif (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t{\n\t\tfor (index = 0; index < btp->hdr.nused; ++index)\n\t\t{\n\t\t\tFreePageBtree *child;\n\n\t\t\tchild = relptr_access(base, btp->u.internal_key[index].child);\n\t\t\tFreePageManagerDumpBtree(fpm, child, btp, level + 1, buf);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "fpm->btree_root"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"btree depth %u:\\n\"",
            "fpm->btree_depth"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"metadata: self %zu max contiguous pages = %zu\\n\"",
            "fpm->self.relptr_off",
            "fpm->contiguous_pages"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_segment_base",
          "args": [
            "fpm"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);\nstatic void FreePageManagerDumpBtree(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\t\t FreePageBtree *parent, int level, StringInfo buf);\nstatic void FreePageManagerDumpSpans(FreePageManager *fpm,\n\t\t\t\t\t\t FreePageSpanLeader *span, Size expected_pages,\n\t\t\t\t\t\t StringInfo buf);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nchar *\nFreePageManagerDump(FreePageManager *fpm)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tStringInfoData buf;\n\tFreePageSpanLeader *recycle;\n\tbool\t\tdumped_any_freelist = false;\n\tSize\t\tf;\n\n\t/* Initialize output buffer. */\n\tinitStringInfo(&buf);\n\n\t/* Dump general stuff. */\n\tappendStringInfo(&buf, \"metadata: self %zu max contiguous pages = %zu\\n\",\n\t\t\t\t\t fpm->self.relptr_off, fpm->contiguous_pages);\n\n\t/* Dump btree. */\n\tif (fpm->btree_depth > 0)\n\t{\n\t\tFreePageBtree *root;\n\n\t\tappendStringInfo(&buf, \"btree depth %u:\\n\", fpm->btree_depth);\n\t\troot = relptr_access(base, fpm->btree_root);\n\t\tFreePageManagerDumpBtree(fpm, root, NULL, 0, &buf);\n\t}\n\telse if (fpm->singleton_npages > 0)\n\t{\n\t\tappendStringInfo(&buf, \"singleton: %zu(%zu)\\n\",\n\t\t\t\t\t\t fpm->singleton_first_page, fpm->singleton_npages);\n\t}\n\n\t/* Dump btree recycle list. */\n\trecycle = relptr_access(base, fpm->btree_recycle);\n\tif (recycle != NULL)\n\t{\n\t\tappendStringInfoString(&buf, \"btree recycle:\");\n\t\tFreePageManagerDumpSpans(fpm, recycle, 1, &buf);\n\t}\n\n\t/* Dump free lists. */\n\tfor (f = 0; f < FPM_NUM_FREELISTS; ++f)\n\t{\n\t\tFreePageSpanLeader *span;\n\n\t\tif (relptr_is_null(fpm->freelist[f]))\n\t\t\tcontinue;\n\t\tif (!dumped_any_freelist)\n\t\t{\n\t\t\tappendStringInfoString(&buf, \"freelists:\\n\");\n\t\t\tdumped_any_freelist = true;\n\t\t}\n\t\tappendStringInfo(&buf, \"  %zu:\", f + 1);\n\t\tspan = relptr_access(base, fpm->freelist[f]);\n\t\tFreePageManagerDumpSpans(fpm, span, f + 1, &buf);\n\t}\n\n\t/* And return result to caller. */\n\treturn buf.data;\n}"
  },
  {
    "function_name": "FreePageManagerPut",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "378-418",
    "snippet": "void\nFreePageManagerPut(FreePageManager *fpm, Size first_page, Size npages)\n{\n\tSize\t\tcontiguous_pages;\n\n\tAssert(npages > 0);\n\n\t/* Record the new pages. */\n\tcontiguous_pages =\n\t\tFreePageManagerPutInternal(fpm, first_page, npages, false);\n\n\t/*\n\t * If the new range we inserted into the page manager was contiguous with\n\t * an existing range, it may have opened up cleanup opportunities.\n\t */\n\tif (contiguous_pages > npages)\n\t{\n\t\tSize\t\tcleanup_contiguous_pages;\n\n\t\tcleanup_contiguous_pages = FreePageBtreeCleanup(fpm);\n\t\tif (cleanup_contiguous_pages > contiguous_pages)\n\t\t\tcontiguous_pages = cleanup_contiguous_pages;\n\t}\n\n\t/* See if we now have a new largest chunk. */\n\tif (fpm->contiguous_pages < contiguous_pages)\n\t\tfpm->contiguous_pages = contiguous_pages;\n\n\t/*\n\t * The earlier call to FreePageManagerPutInternal may have set\n\t * contiguous_pages_dirty if it needed to allocate internal pages, so\n\t * recompute contiguous_pages if necessary.\n\t */\n\tFreePageManagerUpdateLargest(fpm);\n\n#ifdef FPM_EXTRA_ASSERTS\n\tfpm->free_pages += npages;\n\tAssert(fpm->free_pages == sum_free_pages(fpm));\n\tAssert(fpm->contiguous_pages == FreePageManagerLargestContiguous(fpm));\n#endif\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
      "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
      "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
      "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
      "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "fpm->contiguous_pages == FreePageManagerLargestContiguous(fpm)"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageManagerLargestContiguous",
          "args": [
            "fpm"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageManagerLargestContiguous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "323-359",
          "snippet": "static Size\nFreePageManagerLargestContiguous(FreePageManager *fpm)\n{\n\tchar\t   *base;\n\tSize\t\tlargest;\n\n\tbase = fpm_segment_base(fpm);\n\tlargest = 0;\n\tif (!relptr_is_null(fpm->freelist[FPM_NUM_FREELISTS - 1]))\n\t{\n\t\tFreePageSpanLeader *candidate;\n\n\t\tcandidate = relptr_access(base, fpm->freelist[FPM_NUM_FREELISTS - 1]);\n\t\tdo\n\t\t{\n\t\t\tif (candidate->npages > largest)\n\t\t\t\tlargest = candidate->npages;\n\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t} while (candidate != NULL);\n\t}\n\telse\n\t{\n\t\tSize\t\tf = FPM_NUM_FREELISTS - 1;\n\n\t\tdo\n\t\t{\n\t\t\t--f;\n\t\t\tif (!relptr_is_null(fpm->freelist[f]))\n\t\t\t{\n\t\t\t\tlargest = f + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (f > 0);\n\t}\n\n\treturn largest;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic Size\nFreePageManagerLargestContiguous(FreePageManager *fpm)\n{\n\tchar\t   *base;\n\tSize\t\tlargest;\n\n\tbase = fpm_segment_base(fpm);\n\tlargest = 0;\n\tif (!relptr_is_null(fpm->freelist[FPM_NUM_FREELISTS - 1]))\n\t{\n\t\tFreePageSpanLeader *candidate;\n\n\t\tcandidate = relptr_access(base, fpm->freelist[FPM_NUM_FREELISTS - 1]);\n\t\tdo\n\t\t{\n\t\t\tif (candidate->npages > largest)\n\t\t\t\tlargest = candidate->npages;\n\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t} while (candidate != NULL);\n\t}\n\telse\n\t{\n\t\tSize\t\tf = FPM_NUM_FREELISTS - 1;\n\n\t\tdo\n\t\t{\n\t\t\t--f;\n\t\t\tif (!relptr_is_null(fpm->freelist[f]))\n\t\t\t{\n\t\t\t\tlargest = f + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (f > 0);\n\t}\n\n\treturn largest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "fpm->free_pages == sum_free_pages(fpm)"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sum_free_pages",
          "args": [
            "fpm"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "sum_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "273-316",
          "snippet": "static Size\nsum_free_pages(FreePageManager *fpm)\n{\n\tFreePageSpanLeader *recycle;\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tsum = 0;\n\tint\t\t\tlist;\n\n\t/* Count the spans by scanning the freelists. */\n\tfor (list = 0; list < FPM_NUM_FREELISTS; ++list)\n\t{\n\n\t\tif (!relptr_is_null(fpm->freelist[list]))\n\t\t{\n\t\t\tFreePageSpanLeader *candidate =\n\t\t\trelptr_access(base, fpm->freelist[list]);\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tsum += candidate->npages;\n\t\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t\t} while (candidate != NULL);\n\t\t}\n\t}\n\n\t/* Count btree internal pages. */\n\tif (fpm->btree_depth > 0)\n\t{\n\t\tFreePageBtree *root = relptr_access(base, fpm->btree_root);\n\n\t\tsum_free_pages_recurse(fpm, root, &sum);\n\t}\n\n\t/* Count the recycle list. */\n\tfor (recycle = relptr_access(base, fpm->btree_recycle);\n\t\t recycle != NULL;\n\t\t recycle = relptr_access(base, recycle->next))\n\t{\n\t\tAssert(recycle->npages == 1);\n\t\t++sum;\n\t}\n\n\treturn sum;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic Size\nsum_free_pages(FreePageManager *fpm)\n{\n\tFreePageSpanLeader *recycle;\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tsum = 0;\n\tint\t\t\tlist;\n\n\t/* Count the spans by scanning the freelists. */\n\tfor (list = 0; list < FPM_NUM_FREELISTS; ++list)\n\t{\n\n\t\tif (!relptr_is_null(fpm->freelist[list]))\n\t\t{\n\t\t\tFreePageSpanLeader *candidate =\n\t\t\trelptr_access(base, fpm->freelist[list]);\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tsum += candidate->npages;\n\t\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t\t} while (candidate != NULL);\n\t\t}\n\t}\n\n\t/* Count btree internal pages. */\n\tif (fpm->btree_depth > 0)\n\t{\n\t\tFreePageBtree *root = relptr_access(base, fpm->btree_root);\n\n\t\tsum_free_pages_recurse(fpm, root, &sum);\n\t}\n\n\t/* Count the recycle list. */\n\tfor (recycle = relptr_access(base, fpm->btree_recycle);\n\t\t recycle != NULL;\n\t\t recycle = relptr_access(base, recycle->next))\n\t{\n\t\tAssert(recycle->npages == 1);\n\t\t++sum;\n\t}\n\n\treturn sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageManagerUpdateLargest",
          "args": [
            "fpm"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageManagerUpdateLargest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "365-373",
          "snippet": "static void\nFreePageManagerUpdateLargest(FreePageManager *fpm)\n{\n\tif (!fpm->contiguous_pages_dirty)\n\t\treturn;\n\n\tfpm->contiguous_pages = FreePageManagerLargestContiguous(fpm);\n\tfpm->contiguous_pages_dirty = false;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageManagerUpdateLargest(FreePageManager *fpm)\n{\n\tif (!fpm->contiguous_pages_dirty)\n\t\treturn;\n\n\tfpm->contiguous_pages = FreePageManagerLargestContiguous(fpm);\n\tfpm->contiguous_pages_dirty = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageBtreeCleanup",
          "args": [
            "fpm"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeCleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "579-688",
          "snippet": "static Size\nFreePageBtreeCleanup(FreePageManager *fpm)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tmax_contiguous_pages = 0;\n\n\t/* Attempt to shrink the depth of the btree. */\n\twhile (!relptr_is_null(fpm->btree_root))\n\t{\n\t\tFreePageBtree *root = relptr_access(base, fpm->btree_root);\n\n\t\t/* If the root contains only one key, reduce depth by one. */\n\t\tif (root->hdr.nused == 1)\n\t\t{\n\t\t\t/* Shrink depth of tree by one. */\n\t\t\tAssert(fpm->btree_depth > 0);\n\t\t\t--fpm->btree_depth;\n\t\t\tif (root->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t\t{\n\t\t\t\t/* If root is a leaf, convert only entry to singleton range. */\n\t\t\t\trelptr_store(base, fpm->btree_root, (FreePageBtree *) NULL);\n\t\t\t\tfpm->singleton_first_page = root->u.leaf_key[0].first_page;\n\t\t\t\tfpm->singleton_npages = root->u.leaf_key[0].npages;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFreePageBtree *newroot;\n\n\t\t\t\t/* If root is an internal page, make only child the root. */\n\t\t\t\tAssert(root->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\t\t\trelptr_copy(fpm->btree_root, root->u.internal_key[0].child);\n\t\t\t\tnewroot = relptr_access(base, fpm->btree_root);\n\t\t\t\trelptr_store(base, newroot->hdr.parent, (FreePageBtree *) NULL);\n\t\t\t}\n\t\t\tFreePageBtreeRecycle(fpm, fpm_pointer_to_page(base, root));\n\t\t}\n\t\telse if (root->hdr.nused == 2 &&\n\t\t\t\t root->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t{\n\t\t\tSize\t\tend_of_first;\n\t\t\tSize\t\tstart_of_second;\n\n\t\t\tend_of_first = root->u.leaf_key[0].first_page +\n\t\t\t\troot->u.leaf_key[0].npages;\n\t\t\tstart_of_second = root->u.leaf_key[1].first_page;\n\n\t\t\tif (end_of_first + 1 == start_of_second)\n\t\t\t{\n\t\t\t\tSize\t\troot_page = fpm_pointer_to_page(base, root);\n\n\t\t\t\tif (end_of_first == root_page)\n\t\t\t\t{\n\t\t\t\t\tFreePagePopSpanLeader(fpm, root->u.leaf_key[0].first_page);\n\t\t\t\t\tFreePagePopSpanLeader(fpm, root->u.leaf_key[1].first_page);\n\t\t\t\t\tfpm->singleton_first_page = root->u.leaf_key[0].first_page;\n\t\t\t\t\tfpm->singleton_npages = root->u.leaf_key[0].npages +\n\t\t\t\t\t\troot->u.leaf_key[1].npages + 1;\n\t\t\t\t\tfpm->btree_depth = 0;\n\t\t\t\t\trelptr_store(base, fpm->btree_root,\n\t\t\t\t\t\t\t\t (FreePageBtree *) NULL);\n\t\t\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t\t\t\t\tAssert(max_contiguous_pages == 0);\n\t\t\t\t\tmax_contiguous_pages = fpm->singleton_npages;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Whether it worked or not, it's time to stop. */\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Nothing more to do.  Stop. */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Attempt to free recycled btree pages.  We skip this if releasing the\n\t * recycled page would require a btree page split, because the page we're\n\t * trying to recycle would be consumed by the split, which would be\n\t * counterproductive.\n\t *\n\t * We also currently only ever attempt to recycle the first page on the\n\t * list; that could be made more aggressive, but it's not clear that the\n\t * complexity would be worthwhile.\n\t */\n\twhile (fpm->btree_recycle_count > 0)\n\t{\n\t\tFreePageBtree *btp;\n\t\tSize\t\tfirst_page;\n\t\tSize\t\tcontiguous_pages;\n\n\t\tbtp = FreePageBtreeGetRecycled(fpm);\n\t\tfirst_page = fpm_pointer_to_page(base, btp);\n\t\tcontiguous_pages = FreePageManagerPutInternal(fpm, first_page, 1, true);\n\t\tif (contiguous_pages == 0)\n\t\t{\n\t\t\tFreePageBtreeRecycle(fpm, first_page);\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (contiguous_pages > max_contiguous_pages)\n\t\t\t\tmax_contiguous_pages = contiguous_pages;\n\t\t}\n\t}\n\n\treturn max_contiguous_pages;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic Size\nFreePageBtreeCleanup(FreePageManager *fpm)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tmax_contiguous_pages = 0;\n\n\t/* Attempt to shrink the depth of the btree. */\n\twhile (!relptr_is_null(fpm->btree_root))\n\t{\n\t\tFreePageBtree *root = relptr_access(base, fpm->btree_root);\n\n\t\t/* If the root contains only one key, reduce depth by one. */\n\t\tif (root->hdr.nused == 1)\n\t\t{\n\t\t\t/* Shrink depth of tree by one. */\n\t\t\tAssert(fpm->btree_depth > 0);\n\t\t\t--fpm->btree_depth;\n\t\t\tif (root->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t\t{\n\t\t\t\t/* If root is a leaf, convert only entry to singleton range. */\n\t\t\t\trelptr_store(base, fpm->btree_root, (FreePageBtree *) NULL);\n\t\t\t\tfpm->singleton_first_page = root->u.leaf_key[0].first_page;\n\t\t\t\tfpm->singleton_npages = root->u.leaf_key[0].npages;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFreePageBtree *newroot;\n\n\t\t\t\t/* If root is an internal page, make only child the root. */\n\t\t\t\tAssert(root->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\t\t\trelptr_copy(fpm->btree_root, root->u.internal_key[0].child);\n\t\t\t\tnewroot = relptr_access(base, fpm->btree_root);\n\t\t\t\trelptr_store(base, newroot->hdr.parent, (FreePageBtree *) NULL);\n\t\t\t}\n\t\t\tFreePageBtreeRecycle(fpm, fpm_pointer_to_page(base, root));\n\t\t}\n\t\telse if (root->hdr.nused == 2 &&\n\t\t\t\t root->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t{\n\t\t\tSize\t\tend_of_first;\n\t\t\tSize\t\tstart_of_second;\n\n\t\t\tend_of_first = root->u.leaf_key[0].first_page +\n\t\t\t\troot->u.leaf_key[0].npages;\n\t\t\tstart_of_second = root->u.leaf_key[1].first_page;\n\n\t\t\tif (end_of_first + 1 == start_of_second)\n\t\t\t{\n\t\t\t\tSize\t\troot_page = fpm_pointer_to_page(base, root);\n\n\t\t\t\tif (end_of_first == root_page)\n\t\t\t\t{\n\t\t\t\t\tFreePagePopSpanLeader(fpm, root->u.leaf_key[0].first_page);\n\t\t\t\t\tFreePagePopSpanLeader(fpm, root->u.leaf_key[1].first_page);\n\t\t\t\t\tfpm->singleton_first_page = root->u.leaf_key[0].first_page;\n\t\t\t\t\tfpm->singleton_npages = root->u.leaf_key[0].npages +\n\t\t\t\t\t\troot->u.leaf_key[1].npages + 1;\n\t\t\t\t\tfpm->btree_depth = 0;\n\t\t\t\t\trelptr_store(base, fpm->btree_root,\n\t\t\t\t\t\t\t\t (FreePageBtree *) NULL);\n\t\t\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t\t\t\t\tAssert(max_contiguous_pages == 0);\n\t\t\t\t\tmax_contiguous_pages = fpm->singleton_npages;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Whether it worked or not, it's time to stop. */\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Nothing more to do.  Stop. */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Attempt to free recycled btree pages.  We skip this if releasing the\n\t * recycled page would require a btree page split, because the page we're\n\t * trying to recycle would be consumed by the split, which would be\n\t * counterproductive.\n\t *\n\t * We also currently only ever attempt to recycle the first page on the\n\t * list; that could be made more aggressive, but it's not clear that the\n\t * complexity would be worthwhile.\n\t */\n\twhile (fpm->btree_recycle_count > 0)\n\t{\n\t\tFreePageBtree *btp;\n\t\tSize\t\tfirst_page;\n\t\tSize\t\tcontiguous_pages;\n\n\t\tbtp = FreePageBtreeGetRecycled(fpm);\n\t\tfirst_page = fpm_pointer_to_page(base, btp);\n\t\tcontiguous_pages = FreePageManagerPutInternal(fpm, first_page, 1, true);\n\t\tif (contiguous_pages == 0)\n\t\t{\n\t\t\tFreePageBtreeRecycle(fpm, first_page);\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (contiguous_pages > max_contiguous_pages)\n\t\t\t\tmax_contiguous_pages = contiguous_pages;\n\t\t}\n\t}\n\n\treturn max_contiguous_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageManagerPutInternal",
          "args": [
            "fpm",
            "first_page",
            "npages",
            "false"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageManagerPutInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1475-1836",
          "snippet": "static Size\nFreePageManagerPutInternal(FreePageManager *fpm, Size first_page, Size npages,\n\t\t\t\t\t\t   bool soft)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtreeSearchResult result;\n\tFreePageBtreeLeafKey *prevkey = NULL;\n\tFreePageBtreeLeafKey *nextkey = NULL;\n\tFreePageBtree *np;\n\tSize\t\tnindex;\n\n\tAssert(npages > 0);\n\n\t/* We can store a single free span without initializing the btree. */\n\tif (fpm->btree_depth == 0)\n\t{\n\t\tif (fpm->singleton_npages == 0)\n\t\t{\n\t\t\t/* Don't have a span yet; store this one. */\n\t\t\tfpm->singleton_first_page = first_page;\n\t\t\tfpm->singleton_npages = npages;\n\t\t\tFreePagePushSpanLeader(fpm, first_page, npages);\n\t\t\treturn fpm->singleton_npages;\n\t\t}\n\t\telse if (fpm->singleton_first_page + fpm->singleton_npages ==\n\t\t\t\t first_page)\n\t\t{\n\t\t\t/* New span immediately follows sole existing span. */\n\t\t\tfpm->singleton_npages += npages;\n\t\t\tFreePagePopSpanLeader(fpm, fpm->singleton_first_page);\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t\t\treturn fpm->singleton_npages;\n\t\t}\n\t\telse if (first_page + npages == fpm->singleton_first_page)\n\t\t{\n\t\t\t/* New span immediately precedes sole existing span. */\n\t\t\tFreePagePopSpanLeader(fpm, fpm->singleton_first_page);\n\t\t\tfpm->singleton_first_page = first_page;\n\t\t\tfpm->singleton_npages += npages;\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t\t\treturn fpm->singleton_npages;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Not contiguous; we need to initialize the btree. */\n\t\t\tSize\t\troot_page;\n\t\t\tFreePageBtree *root;\n\n\t\t\tif (!relptr_is_null(fpm->btree_recycle))\n\t\t\t\troot = FreePageBtreeGetRecycled(fpm);\n\t\t\telse if (soft)\n\t\t\t\treturn 0;\t\t/* Should not allocate if soft. */\n\t\t\telse if (FreePageManagerGetInternal(fpm, 1, &root_page))\n\t\t\t\troot = (FreePageBtree *) fpm_page_to_pointer(base, root_page);\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* We'd better be able to get a page from the existing range. */\n\t\t\t\telog(FATAL, \"free page manager btree is corrupt\");\n\t\t\t}\n\n\t\t\t/* Create the btree and move the preexisting range into it. */\n\t\t\troot->hdr.magic = FREE_PAGE_LEAF_MAGIC;\n\t\t\troot->hdr.nused = 1;\n\t\t\trelptr_store(base, root->hdr.parent, (FreePageBtree *) NULL);\n\t\t\troot->u.leaf_key[0].first_page = fpm->singleton_first_page;\n\t\t\troot->u.leaf_key[0].npages = fpm->singleton_npages;\n\t\t\trelptr_store(base, fpm->btree_root, root);\n\t\t\tfpm->singleton_first_page = 0;\n\t\t\tfpm->singleton_npages = 0;\n\t\t\tfpm->btree_depth = 1;\n\n\t\t\t/*\n\t\t\t * Corner case: it may be that the btree root took the very last\n\t\t\t * free page.  In that case, the sole btree entry covers a zero\n\t\t\t * page run, which is invalid.  Overwrite it with the entry we're\n\t\t\t * trying to insert and get out.\n\t\t\t */\n\t\t\tif (root->u.leaf_key[0].npages == 0)\n\t\t\t{\n\t\t\t\troot->u.leaf_key[0].first_page = first_page;\n\t\t\t\troot->u.leaf_key[0].npages = npages;\n\t\t\t\tFreePagePushSpanLeader(fpm, first_page, npages);\n\t\t\t\treturn npages;\n\t\t\t}\n\n\t\t\t/* Fall through to insert the new key. */\n\t\t}\n\t}\n\n\t/* Search the btree. */\n\tFreePageBtreeSearch(fpm, first_page, &result);\n\tAssert(!result.found);\n\tif (result.index > 0)\n\t\tprevkey = &result.page->u.leaf_key[result.index - 1];\n\tif (result.index < result.page->hdr.nused)\n\t{\n\t\tnp = result.page;\n\t\tnindex = result.index;\n\t\tnextkey = &result.page->u.leaf_key[result.index];\n\t}\n\telse\n\t{\n\t\tnp = FreePageBtreeFindRightSibling(base, result.page);\n\t\tnindex = 0;\n\t\tif (np != NULL)\n\t\t\tnextkey = &np->u.leaf_key[0];\n\t}\n\n\t/* Consolidate with the previous entry if possible. */\n\tif (prevkey != NULL && prevkey->first_page + prevkey->npages >= first_page)\n\t{\n\t\tbool\t\tremove_next = false;\n\t\tSize\t\tresult;\n\n\t\tAssert(prevkey->first_page + prevkey->npages == first_page);\n\t\tprevkey->npages = (first_page - prevkey->first_page) + npages;\n\n\t\t/* Check whether we can *also* consolidate with the following entry. */\n\t\tif (nextkey != NULL &&\n\t\t\tprevkey->first_page + prevkey->npages >= nextkey->first_page)\n\t\t{\n\t\t\tAssert(prevkey->first_page + prevkey->npages ==\n\t\t\t\t   nextkey->first_page);\n\t\t\tprevkey->npages = (nextkey->first_page - prevkey->first_page)\n\t\t\t\t+ nextkey->npages;\n\t\t\tFreePagePopSpanLeader(fpm, nextkey->first_page);\n\t\t\tremove_next = true;\n\t\t}\n\n\t\t/* Put the span on the correct freelist and save size. */\n\t\tFreePagePopSpanLeader(fpm, prevkey->first_page);\n\t\tFreePagePushSpanLeader(fpm, prevkey->first_page, prevkey->npages);\n\t\tresult = prevkey->npages;\n\n\t\t/*\n\t\t * If we consolidated with both the preceding and following entries,\n\t\t * we must remove the following entry.  We do this last, because\n\t\t * removing an element from the btree may invalidate pointers we hold\n\t\t * into the current data structure.\n\t\t *\n\t\t * NB: The btree is technically in an invalid state a this point\n\t\t * because we've already updated prevkey to cover the same key space\n\t\t * as nextkey.  FreePageBtreeRemove() shouldn't notice that, though.\n\t\t */\n\t\tif (remove_next)\n\t\t\tFreePageBtreeRemove(fpm, np, nindex);\n\n\t\treturn result;\n\t}\n\n\t/* Consolidate with the next entry if possible. */\n\tif (nextkey != NULL && first_page + npages >= nextkey->first_page)\n\t{\n\t\tSize\t\tnewpages;\n\n\t\t/* Compute new size for span. */\n\t\tAssert(first_page + npages == nextkey->first_page);\n\t\tnewpages = (nextkey->first_page - first_page) + nextkey->npages;\n\n\t\t/* Put span on correct free list. */\n\t\tFreePagePopSpanLeader(fpm, nextkey->first_page);\n\t\tFreePagePushSpanLeader(fpm, first_page, newpages);\n\n\t\t/* Update key in place. */\n\t\tnextkey->first_page = first_page;\n\t\tnextkey->npages = newpages;\n\n\t\t/* If reducing first key on page, ancestors might need adjustment. */\n\t\tif (nindex == 0)\n\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, np);\n\n\t\treturn nextkey->npages;\n\t}\n\n\t/* Split leaf page and as many of its ancestors as necessary. */\n\tif (result.split_pages > 0)\n\t{\n\t\t/*\n\t\t * NB: We could consider various coping strategies here to avoid a\n\t\t * split; most obviously, if np != result.page, we could target that\n\t\t * page instead.   More complicated shuffling strategies could be\n\t\t * possible as well; basically, unless every single leaf page is 100%\n\t\t * full, we can jam this key in there if we try hard enough.  It's\n\t\t * unlikely that trying that hard is worthwhile, but it's possible we\n\t\t * might need to make more than no effort.  For now, we just do the\n\t\t * easy thing, which is nothing.\n\t\t */\n\n\t\t/* If this is a soft insert, it's time to give up. */\n\t\tif (soft)\n\t\t\treturn 0;\n\n\t\t/* Check whether we need to allocate more btree pages to split. */\n\t\tif (result.split_pages > fpm->btree_recycle_count)\n\t\t{\n\t\t\tSize\t\tpages_needed;\n\t\t\tSize\t\trecycle_page;\n\t\t\tSize\t\ti;\n\n\t\t\t/*\n\t\t\t * Allocate the required number of pages and split each one in\n\t\t\t * turn.  This should never fail, because if we've got enough\n\t\t\t * spans of free pages kicking around that we need additional\n\t\t\t * storage space just to remember them all, then we should\n\t\t\t * certainly have enough to expand the btree, which should only\n\t\t\t * ever use a tiny number of pages compared to the number under\n\t\t\t * management.  If it does, something's badly screwed up.\n\t\t\t */\n\t\t\tpages_needed = result.split_pages - fpm->btree_recycle_count;\n\t\t\tfor (i = 0; i < pages_needed; ++i)\n\t\t\t{\n\t\t\t\tif (!FreePageManagerGetInternal(fpm, 1, &recycle_page))\n\t\t\t\t\telog(FATAL, \"free page manager btree is corrupt\");\n\t\t\t\tFreePageBtreeRecycle(fpm, recycle_page);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The act of allocating pages to recycle may have invalidated the\n\t\t\t * results of our previous btree reserch, so repeat it. (We could\n\t\t\t * recheck whether any of our split-avoidance strategies that were\n\t\t\t * not viable before now are, but it hardly seems worthwhile, so\n\t\t\t * we don't bother. Consolidation can't be possible now if it\n\t\t\t * wasn't previously.)\n\t\t\t */\n\t\t\tFreePageBtreeSearch(fpm, first_page, &result);\n\n\t\t\t/*\n\t\t\t * The act of allocating pages for use in constructing our btree\n\t\t\t * should never cause any page to become more full, so the new\n\t\t\t * split depth should be no greater than the old one, and perhaps\n\t\t\t * less if we fortuitously allocated a chunk that freed up a slot\n\t\t\t * on the page we need to update.\n\t\t\t */\n\t\t\tAssert(result.split_pages <= fpm->btree_recycle_count);\n\t\t}\n\n\t\t/* If we still need to perform a split, do it. */\n\t\tif (result.split_pages > 0)\n\t\t{\n\t\t\tFreePageBtree *split_target = result.page;\n\t\t\tFreePageBtree *child = NULL;\n\t\t\tSize\t\tkey = first_page;\n\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tFreePageBtree *newsibling;\n\t\t\t\tFreePageBtree *parent;\n\n\t\t\t\t/* Identify parent page, which must receive downlink. */\n\t\t\t\tparent = relptr_access(base, split_target->hdr.parent);\n\n\t\t\t\t/* Split the page - downlink not added yet. */\n\t\t\t\tnewsibling = FreePageBtreeSplitPage(fpm, split_target);\n\n\t\t\t\t/*\n\t\t\t\t * At this point in the loop, we're always carrying a pending\n\t\t\t\t * insertion.  On the first pass, it's the actual key we're\n\t\t\t\t * trying to insert; on subsequent passes, it's the downlink\n\t\t\t\t * that needs to be added as a result of the split performed\n\t\t\t\t * during the previous loop iteration.  Since we've just split\n\t\t\t\t * the page, there's definitely room on one of the two\n\t\t\t\t * resulting pages.\n\t\t\t\t */\n\t\t\t\tif (child == NULL)\n\t\t\t\t{\n\t\t\t\t\tSize\t\tindex;\n\t\t\t\t\tFreePageBtree *insert_into;\n\n\t\t\t\t\tinsert_into = key < newsibling->u.leaf_key[0].first_page ?\n\t\t\t\t\t\tsplit_target : newsibling;\n\t\t\t\t\tindex = FreePageBtreeSearchLeaf(insert_into, key);\n\t\t\t\t\tFreePageBtreeInsertLeaf(insert_into, index, key, npages);\n\t\t\t\t\tif (index == 0 && insert_into == split_target)\n\t\t\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, split_target);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSize\t\tindex;\n\t\t\t\t\tFreePageBtree *insert_into;\n\n\t\t\t\t\tinsert_into =\n\t\t\t\t\t\tkey < newsibling->u.internal_key[0].first_page ?\n\t\t\t\t\t\tsplit_target : newsibling;\n\t\t\t\t\tindex = FreePageBtreeSearchInternal(insert_into, key);\n\t\t\t\t\tFreePageBtreeInsertInternal(base, insert_into, index,\n\t\t\t\t\t\t\t\t\t\t\t\tkey, child);\n\t\t\t\t\trelptr_store(base, child->hdr.parent, insert_into);\n\t\t\t\t\tif (index == 0 && insert_into == split_target)\n\t\t\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, split_target);\n\t\t\t\t}\n\n\t\t\t\t/* If the page we just split has no parent, split the root. */\n\t\t\t\tif (parent == NULL)\n\t\t\t\t{\n\t\t\t\t\tFreePageBtree *newroot;\n\n\t\t\t\t\tnewroot = FreePageBtreeGetRecycled(fpm);\n\t\t\t\t\tnewroot->hdr.magic = FREE_PAGE_INTERNAL_MAGIC;\n\t\t\t\t\tnewroot->hdr.nused = 2;\n\t\t\t\t\trelptr_store(base, newroot->hdr.parent,\n\t\t\t\t\t\t\t\t (FreePageBtree *) NULL);\n\t\t\t\t\tnewroot->u.internal_key[0].first_page =\n\t\t\t\t\t\tFreePageBtreeFirstKey(split_target);\n\t\t\t\t\trelptr_store(base, newroot->u.internal_key[0].child,\n\t\t\t\t\t\t\t\t split_target);\n\t\t\t\t\trelptr_store(base, split_target->hdr.parent, newroot);\n\t\t\t\t\tnewroot->u.internal_key[1].first_page =\n\t\t\t\t\t\tFreePageBtreeFirstKey(newsibling);\n\t\t\t\t\trelptr_store(base, newroot->u.internal_key[1].child,\n\t\t\t\t\t\t\t\t newsibling);\n\t\t\t\t\trelptr_store(base, newsibling->hdr.parent, newroot);\n\t\t\t\t\trelptr_store(base, fpm->btree_root, newroot);\n\t\t\t\t\tfpm->btree_depth++;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* If the parent page isn't full, insert the downlink. */\n\t\t\t\tkey = newsibling->u.internal_key[0].first_page;\n\t\t\t\tif (parent->hdr.nused < FPM_ITEMS_PER_INTERNAL_PAGE)\n\t\t\t\t{\n\t\t\t\t\tSize\t\tindex;\n\n\t\t\t\t\tindex = FreePageBtreeSearchInternal(parent, key);\n\t\t\t\t\tFreePageBtreeInsertInternal(base, parent, index,\n\t\t\t\t\t\t\t\t\t\t\t\tkey, newsibling);\n\t\t\t\t\trelptr_store(base, newsibling->hdr.parent, parent);\n\t\t\t\t\tif (index == 0)\n\t\t\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, parent);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* The parent also needs to be split, so loop around. */\n\t\t\t\tchild = newsibling;\n\t\t\t\tsplit_target = parent;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The loop above did the insert, so just need to update the free\n\t\t\t * list, and we're done.\n\t\t\t */\n\t\t\tFreePagePushSpanLeader(fpm, first_page, npages);\n\n\t\t\treturn npages;\n\t\t}\n\t}\n\n\t/* Physically add the key to the page. */\n\tAssert(result.page->hdr.nused < FPM_ITEMS_PER_LEAF_PAGE);\n\tFreePageBtreeInsertLeaf(result.page, result.index, first_page, npages);\n\n\t/* If new first key on page, ancestors might need adjustment. */\n\tif (result.index == 0)\n\t\tFreePageBtreeAdjustAncestorKeys(fpm, result.page);\n\n\t/* Put it on the free list. */\n\tFreePagePushSpanLeader(fpm, first_page, npages);\n\n\treturn npages;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))",
            "#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))",
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static Size FreePageManagerPutInternal(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t\t   Size npages, bool soft);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FPM_ITEMS_PER_LEAF_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeLeafKey))\n#define FPM_ITEMS_PER_INTERNAL_PAGE \\\n\t((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \\\n\t\tsizeof(FreePageBtreeInternalKey))\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic Size FreePageManagerPutInternal(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t\t   Size npages, bool soft);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic Size\nFreePageManagerPutInternal(FreePageManager *fpm, Size first_page, Size npages,\n\t\t\t\t\t\t   bool soft)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageBtreeSearchResult result;\n\tFreePageBtreeLeafKey *prevkey = NULL;\n\tFreePageBtreeLeafKey *nextkey = NULL;\n\tFreePageBtree *np;\n\tSize\t\tnindex;\n\n\tAssert(npages > 0);\n\n\t/* We can store a single free span without initializing the btree. */\n\tif (fpm->btree_depth == 0)\n\t{\n\t\tif (fpm->singleton_npages == 0)\n\t\t{\n\t\t\t/* Don't have a span yet; store this one. */\n\t\t\tfpm->singleton_first_page = first_page;\n\t\t\tfpm->singleton_npages = npages;\n\t\t\tFreePagePushSpanLeader(fpm, first_page, npages);\n\t\t\treturn fpm->singleton_npages;\n\t\t}\n\t\telse if (fpm->singleton_first_page + fpm->singleton_npages ==\n\t\t\t\t first_page)\n\t\t{\n\t\t\t/* New span immediately follows sole existing span. */\n\t\t\tfpm->singleton_npages += npages;\n\t\t\tFreePagePopSpanLeader(fpm, fpm->singleton_first_page);\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t\t\treturn fpm->singleton_npages;\n\t\t}\n\t\telse if (first_page + npages == fpm->singleton_first_page)\n\t\t{\n\t\t\t/* New span immediately precedes sole existing span. */\n\t\t\tFreePagePopSpanLeader(fpm, fpm->singleton_first_page);\n\t\t\tfpm->singleton_first_page = first_page;\n\t\t\tfpm->singleton_npages += npages;\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t\t\treturn fpm->singleton_npages;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Not contiguous; we need to initialize the btree. */\n\t\t\tSize\t\troot_page;\n\t\t\tFreePageBtree *root;\n\n\t\t\tif (!relptr_is_null(fpm->btree_recycle))\n\t\t\t\troot = FreePageBtreeGetRecycled(fpm);\n\t\t\telse if (soft)\n\t\t\t\treturn 0;\t\t/* Should not allocate if soft. */\n\t\t\telse if (FreePageManagerGetInternal(fpm, 1, &root_page))\n\t\t\t\troot = (FreePageBtree *) fpm_page_to_pointer(base, root_page);\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* We'd better be able to get a page from the existing range. */\n\t\t\t\telog(FATAL, \"free page manager btree is corrupt\");\n\t\t\t}\n\n\t\t\t/* Create the btree and move the preexisting range into it. */\n\t\t\troot->hdr.magic = FREE_PAGE_LEAF_MAGIC;\n\t\t\troot->hdr.nused = 1;\n\t\t\trelptr_store(base, root->hdr.parent, (FreePageBtree *) NULL);\n\t\t\troot->u.leaf_key[0].first_page = fpm->singleton_first_page;\n\t\t\troot->u.leaf_key[0].npages = fpm->singleton_npages;\n\t\t\trelptr_store(base, fpm->btree_root, root);\n\t\t\tfpm->singleton_first_page = 0;\n\t\t\tfpm->singleton_npages = 0;\n\t\t\tfpm->btree_depth = 1;\n\n\t\t\t/*\n\t\t\t * Corner case: it may be that the btree root took the very last\n\t\t\t * free page.  In that case, the sole btree entry covers a zero\n\t\t\t * page run, which is invalid.  Overwrite it with the entry we're\n\t\t\t * trying to insert and get out.\n\t\t\t */\n\t\t\tif (root->u.leaf_key[0].npages == 0)\n\t\t\t{\n\t\t\t\troot->u.leaf_key[0].first_page = first_page;\n\t\t\t\troot->u.leaf_key[0].npages = npages;\n\t\t\t\tFreePagePushSpanLeader(fpm, first_page, npages);\n\t\t\t\treturn npages;\n\t\t\t}\n\n\t\t\t/* Fall through to insert the new key. */\n\t\t}\n\t}\n\n\t/* Search the btree. */\n\tFreePageBtreeSearch(fpm, first_page, &result);\n\tAssert(!result.found);\n\tif (result.index > 0)\n\t\tprevkey = &result.page->u.leaf_key[result.index - 1];\n\tif (result.index < result.page->hdr.nused)\n\t{\n\t\tnp = result.page;\n\t\tnindex = result.index;\n\t\tnextkey = &result.page->u.leaf_key[result.index];\n\t}\n\telse\n\t{\n\t\tnp = FreePageBtreeFindRightSibling(base, result.page);\n\t\tnindex = 0;\n\t\tif (np != NULL)\n\t\t\tnextkey = &np->u.leaf_key[0];\n\t}\n\n\t/* Consolidate with the previous entry if possible. */\n\tif (prevkey != NULL && prevkey->first_page + prevkey->npages >= first_page)\n\t{\n\t\tbool\t\tremove_next = false;\n\t\tSize\t\tresult;\n\n\t\tAssert(prevkey->first_page + prevkey->npages == first_page);\n\t\tprevkey->npages = (first_page - prevkey->first_page) + npages;\n\n\t\t/* Check whether we can *also* consolidate with the following entry. */\n\t\tif (nextkey != NULL &&\n\t\t\tprevkey->first_page + prevkey->npages >= nextkey->first_page)\n\t\t{\n\t\t\tAssert(prevkey->first_page + prevkey->npages ==\n\t\t\t\t   nextkey->first_page);\n\t\t\tprevkey->npages = (nextkey->first_page - prevkey->first_page)\n\t\t\t\t+ nextkey->npages;\n\t\t\tFreePagePopSpanLeader(fpm, nextkey->first_page);\n\t\t\tremove_next = true;\n\t\t}\n\n\t\t/* Put the span on the correct freelist and save size. */\n\t\tFreePagePopSpanLeader(fpm, prevkey->first_page);\n\t\tFreePagePushSpanLeader(fpm, prevkey->first_page, prevkey->npages);\n\t\tresult = prevkey->npages;\n\n\t\t/*\n\t\t * If we consolidated with both the preceding and following entries,\n\t\t * we must remove the following entry.  We do this last, because\n\t\t * removing an element from the btree may invalidate pointers we hold\n\t\t * into the current data structure.\n\t\t *\n\t\t * NB: The btree is technically in an invalid state a this point\n\t\t * because we've already updated prevkey to cover the same key space\n\t\t * as nextkey.  FreePageBtreeRemove() shouldn't notice that, though.\n\t\t */\n\t\tif (remove_next)\n\t\t\tFreePageBtreeRemove(fpm, np, nindex);\n\n\t\treturn result;\n\t}\n\n\t/* Consolidate with the next entry if possible. */\n\tif (nextkey != NULL && first_page + npages >= nextkey->first_page)\n\t{\n\t\tSize\t\tnewpages;\n\n\t\t/* Compute new size for span. */\n\t\tAssert(first_page + npages == nextkey->first_page);\n\t\tnewpages = (nextkey->first_page - first_page) + nextkey->npages;\n\n\t\t/* Put span on correct free list. */\n\t\tFreePagePopSpanLeader(fpm, nextkey->first_page);\n\t\tFreePagePushSpanLeader(fpm, first_page, newpages);\n\n\t\t/* Update key in place. */\n\t\tnextkey->first_page = first_page;\n\t\tnextkey->npages = newpages;\n\n\t\t/* If reducing first key on page, ancestors might need adjustment. */\n\t\tif (nindex == 0)\n\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, np);\n\n\t\treturn nextkey->npages;\n\t}\n\n\t/* Split leaf page and as many of its ancestors as necessary. */\n\tif (result.split_pages > 0)\n\t{\n\t\t/*\n\t\t * NB: We could consider various coping strategies here to avoid a\n\t\t * split; most obviously, if np != result.page, we could target that\n\t\t * page instead.   More complicated shuffling strategies could be\n\t\t * possible as well; basically, unless every single leaf page is 100%\n\t\t * full, we can jam this key in there if we try hard enough.  It's\n\t\t * unlikely that trying that hard is worthwhile, but it's possible we\n\t\t * might need to make more than no effort.  For now, we just do the\n\t\t * easy thing, which is nothing.\n\t\t */\n\n\t\t/* If this is a soft insert, it's time to give up. */\n\t\tif (soft)\n\t\t\treturn 0;\n\n\t\t/* Check whether we need to allocate more btree pages to split. */\n\t\tif (result.split_pages > fpm->btree_recycle_count)\n\t\t{\n\t\t\tSize\t\tpages_needed;\n\t\t\tSize\t\trecycle_page;\n\t\t\tSize\t\ti;\n\n\t\t\t/*\n\t\t\t * Allocate the required number of pages and split each one in\n\t\t\t * turn.  This should never fail, because if we've got enough\n\t\t\t * spans of free pages kicking around that we need additional\n\t\t\t * storage space just to remember them all, then we should\n\t\t\t * certainly have enough to expand the btree, which should only\n\t\t\t * ever use a tiny number of pages compared to the number under\n\t\t\t * management.  If it does, something's badly screwed up.\n\t\t\t */\n\t\t\tpages_needed = result.split_pages - fpm->btree_recycle_count;\n\t\t\tfor (i = 0; i < pages_needed; ++i)\n\t\t\t{\n\t\t\t\tif (!FreePageManagerGetInternal(fpm, 1, &recycle_page))\n\t\t\t\t\telog(FATAL, \"free page manager btree is corrupt\");\n\t\t\t\tFreePageBtreeRecycle(fpm, recycle_page);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The act of allocating pages to recycle may have invalidated the\n\t\t\t * results of our previous btree reserch, so repeat it. (We could\n\t\t\t * recheck whether any of our split-avoidance strategies that were\n\t\t\t * not viable before now are, but it hardly seems worthwhile, so\n\t\t\t * we don't bother. Consolidation can't be possible now if it\n\t\t\t * wasn't previously.)\n\t\t\t */\n\t\t\tFreePageBtreeSearch(fpm, first_page, &result);\n\n\t\t\t/*\n\t\t\t * The act of allocating pages for use in constructing our btree\n\t\t\t * should never cause any page to become more full, so the new\n\t\t\t * split depth should be no greater than the old one, and perhaps\n\t\t\t * less if we fortuitously allocated a chunk that freed up a slot\n\t\t\t * on the page we need to update.\n\t\t\t */\n\t\t\tAssert(result.split_pages <= fpm->btree_recycle_count);\n\t\t}\n\n\t\t/* If we still need to perform a split, do it. */\n\t\tif (result.split_pages > 0)\n\t\t{\n\t\t\tFreePageBtree *split_target = result.page;\n\t\t\tFreePageBtree *child = NULL;\n\t\t\tSize\t\tkey = first_page;\n\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tFreePageBtree *newsibling;\n\t\t\t\tFreePageBtree *parent;\n\n\t\t\t\t/* Identify parent page, which must receive downlink. */\n\t\t\t\tparent = relptr_access(base, split_target->hdr.parent);\n\n\t\t\t\t/* Split the page - downlink not added yet. */\n\t\t\t\tnewsibling = FreePageBtreeSplitPage(fpm, split_target);\n\n\t\t\t\t/*\n\t\t\t\t * At this point in the loop, we're always carrying a pending\n\t\t\t\t * insertion.  On the first pass, it's the actual key we're\n\t\t\t\t * trying to insert; on subsequent passes, it's the downlink\n\t\t\t\t * that needs to be added as a result of the split performed\n\t\t\t\t * during the previous loop iteration.  Since we've just split\n\t\t\t\t * the page, there's definitely room on one of the two\n\t\t\t\t * resulting pages.\n\t\t\t\t */\n\t\t\t\tif (child == NULL)\n\t\t\t\t{\n\t\t\t\t\tSize\t\tindex;\n\t\t\t\t\tFreePageBtree *insert_into;\n\n\t\t\t\t\tinsert_into = key < newsibling->u.leaf_key[0].first_page ?\n\t\t\t\t\t\tsplit_target : newsibling;\n\t\t\t\t\tindex = FreePageBtreeSearchLeaf(insert_into, key);\n\t\t\t\t\tFreePageBtreeInsertLeaf(insert_into, index, key, npages);\n\t\t\t\t\tif (index == 0 && insert_into == split_target)\n\t\t\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, split_target);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSize\t\tindex;\n\t\t\t\t\tFreePageBtree *insert_into;\n\n\t\t\t\t\tinsert_into =\n\t\t\t\t\t\tkey < newsibling->u.internal_key[0].first_page ?\n\t\t\t\t\t\tsplit_target : newsibling;\n\t\t\t\t\tindex = FreePageBtreeSearchInternal(insert_into, key);\n\t\t\t\t\tFreePageBtreeInsertInternal(base, insert_into, index,\n\t\t\t\t\t\t\t\t\t\t\t\tkey, child);\n\t\t\t\t\trelptr_store(base, child->hdr.parent, insert_into);\n\t\t\t\t\tif (index == 0 && insert_into == split_target)\n\t\t\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, split_target);\n\t\t\t\t}\n\n\t\t\t\t/* If the page we just split has no parent, split the root. */\n\t\t\t\tif (parent == NULL)\n\t\t\t\t{\n\t\t\t\t\tFreePageBtree *newroot;\n\n\t\t\t\t\tnewroot = FreePageBtreeGetRecycled(fpm);\n\t\t\t\t\tnewroot->hdr.magic = FREE_PAGE_INTERNAL_MAGIC;\n\t\t\t\t\tnewroot->hdr.nused = 2;\n\t\t\t\t\trelptr_store(base, newroot->hdr.parent,\n\t\t\t\t\t\t\t\t (FreePageBtree *) NULL);\n\t\t\t\t\tnewroot->u.internal_key[0].first_page =\n\t\t\t\t\t\tFreePageBtreeFirstKey(split_target);\n\t\t\t\t\trelptr_store(base, newroot->u.internal_key[0].child,\n\t\t\t\t\t\t\t\t split_target);\n\t\t\t\t\trelptr_store(base, split_target->hdr.parent, newroot);\n\t\t\t\t\tnewroot->u.internal_key[1].first_page =\n\t\t\t\t\t\tFreePageBtreeFirstKey(newsibling);\n\t\t\t\t\trelptr_store(base, newroot->u.internal_key[1].child,\n\t\t\t\t\t\t\t\t newsibling);\n\t\t\t\t\trelptr_store(base, newsibling->hdr.parent, newroot);\n\t\t\t\t\trelptr_store(base, fpm->btree_root, newroot);\n\t\t\t\t\tfpm->btree_depth++;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* If the parent page isn't full, insert the downlink. */\n\t\t\t\tkey = newsibling->u.internal_key[0].first_page;\n\t\t\t\tif (parent->hdr.nused < FPM_ITEMS_PER_INTERNAL_PAGE)\n\t\t\t\t{\n\t\t\t\t\tSize\t\tindex;\n\n\t\t\t\t\tindex = FreePageBtreeSearchInternal(parent, key);\n\t\t\t\t\tFreePageBtreeInsertInternal(base, parent, index,\n\t\t\t\t\t\t\t\t\t\t\t\tkey, newsibling);\n\t\t\t\t\trelptr_store(base, newsibling->hdr.parent, parent);\n\t\t\t\t\tif (index == 0)\n\t\t\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, parent);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* The parent also needs to be split, so loop around. */\n\t\t\t\tchild = newsibling;\n\t\t\t\tsplit_target = parent;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The loop above did the insert, so just need to update the free\n\t\t\t * list, and we're done.\n\t\t\t */\n\t\t\tFreePagePushSpanLeader(fpm, first_page, npages);\n\n\t\t\treturn npages;\n\t\t}\n\t}\n\n\t/* Physically add the key to the page. */\n\tAssert(result.page->hdr.nused < FPM_ITEMS_PER_LEAF_PAGE);\n\tFreePageBtreeInsertLeaf(result.page, result.index, first_page, npages);\n\n\t/* If new first key on page, ancestors might need adjustment. */\n\tif (result.index == 0)\n\t\tFreePageBtreeAdjustAncestorKeys(fpm, result.page);\n\n\t/* Put it on the free list. */\n\tFreePagePushSpanLeader(fpm, first_page, npages);\n\n\treturn npages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "npages > 0"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nvoid\nFreePageManagerPut(FreePageManager *fpm, Size first_page, Size npages)\n{\n\tSize\t\tcontiguous_pages;\n\n\tAssert(npages > 0);\n\n\t/* Record the new pages. */\n\tcontiguous_pages =\n\t\tFreePageManagerPutInternal(fpm, first_page, npages, false);\n\n\t/*\n\t * If the new range we inserted into the page manager was contiguous with\n\t * an existing range, it may have opened up cleanup opportunities.\n\t */\n\tif (contiguous_pages > npages)\n\t{\n\t\tSize\t\tcleanup_contiguous_pages;\n\n\t\tcleanup_contiguous_pages = FreePageBtreeCleanup(fpm);\n\t\tif (cleanup_contiguous_pages > contiguous_pages)\n\t\t\tcontiguous_pages = cleanup_contiguous_pages;\n\t}\n\n\t/* See if we now have a new largest chunk. */\n\tif (fpm->contiguous_pages < contiguous_pages)\n\t\tfpm->contiguous_pages = contiguous_pages;\n\n\t/*\n\t * The earlier call to FreePageManagerPutInternal may have set\n\t * contiguous_pages_dirty if it needed to allocate internal pages, so\n\t * recompute contiguous_pages if necessary.\n\t */\n\tFreePageManagerUpdateLargest(fpm);\n\n#ifdef FPM_EXTRA_ASSERTS\n\tfpm->free_pages += npages;\n\tAssert(fpm->free_pages == sum_free_pages(fpm));\n\tAssert(fpm->contiguous_pages == FreePageManagerLargestContiguous(fpm));\n#endif\n}"
  },
  {
    "function_name": "FreePageManagerUpdateLargest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "365-373",
    "snippet": "static void\nFreePageManagerUpdateLargest(FreePageManager *fpm)\n{\n\tif (!fpm->contiguous_pages_dirty)\n\t\treturn;\n\n\tfpm->contiguous_pages = FreePageManagerLargestContiguous(fpm);\n\tfpm->contiguous_pages_dirty = false;\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FreePageManagerLargestContiguous",
          "args": [
            "fpm"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageManagerLargestContiguous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "323-359",
          "snippet": "static Size\nFreePageManagerLargestContiguous(FreePageManager *fpm)\n{\n\tchar\t   *base;\n\tSize\t\tlargest;\n\n\tbase = fpm_segment_base(fpm);\n\tlargest = 0;\n\tif (!relptr_is_null(fpm->freelist[FPM_NUM_FREELISTS - 1]))\n\t{\n\t\tFreePageSpanLeader *candidate;\n\n\t\tcandidate = relptr_access(base, fpm->freelist[FPM_NUM_FREELISTS - 1]);\n\t\tdo\n\t\t{\n\t\t\tif (candidate->npages > largest)\n\t\t\t\tlargest = candidate->npages;\n\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t} while (candidate != NULL);\n\t}\n\telse\n\t{\n\t\tSize\t\tf = FPM_NUM_FREELISTS - 1;\n\n\t\tdo\n\t\t{\n\t\t\t--f;\n\t\t\tif (!relptr_is_null(fpm->freelist[f]))\n\t\t\t{\n\t\t\t\tlargest = f + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (f > 0);\n\t}\n\n\treturn largest;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic Size\nFreePageManagerLargestContiguous(FreePageManager *fpm)\n{\n\tchar\t   *base;\n\tSize\t\tlargest;\n\n\tbase = fpm_segment_base(fpm);\n\tlargest = 0;\n\tif (!relptr_is_null(fpm->freelist[FPM_NUM_FREELISTS - 1]))\n\t{\n\t\tFreePageSpanLeader *candidate;\n\n\t\tcandidate = relptr_access(base, fpm->freelist[FPM_NUM_FREELISTS - 1]);\n\t\tdo\n\t\t{\n\t\t\tif (candidate->npages > largest)\n\t\t\t\tlargest = candidate->npages;\n\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t} while (candidate != NULL);\n\t}\n\telse\n\t{\n\t\tSize\t\tf = FPM_NUM_FREELISTS - 1;\n\n\t\tdo\n\t\t{\n\t\t\t--f;\n\t\t\tif (!relptr_is_null(fpm->freelist[f]))\n\t\t\t{\n\t\t\t\tlargest = f + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (f > 0);\n\t}\n\n\treturn largest;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageManagerUpdateLargest(FreePageManager *fpm)\n{\n\tif (!fpm->contiguous_pages_dirty)\n\t\treturn;\n\n\tfpm->contiguous_pages = FreePageManagerLargestContiguous(fpm);\n\tfpm->contiguous_pages_dirty = false;\n}"
  },
  {
    "function_name": "FreePageManagerLargestContiguous",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "323-359",
    "snippet": "static Size\nFreePageManagerLargestContiguous(FreePageManager *fpm)\n{\n\tchar\t   *base;\n\tSize\t\tlargest;\n\n\tbase = fpm_segment_base(fpm);\n\tlargest = 0;\n\tif (!relptr_is_null(fpm->freelist[FPM_NUM_FREELISTS - 1]))\n\t{\n\t\tFreePageSpanLeader *candidate;\n\n\t\tcandidate = relptr_access(base, fpm->freelist[FPM_NUM_FREELISTS - 1]);\n\t\tdo\n\t\t{\n\t\t\tif (candidate->npages > largest)\n\t\t\t\tlargest = candidate->npages;\n\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t} while (candidate != NULL);\n\t}\n\telse\n\t{\n\t\tSize\t\tf = FPM_NUM_FREELISTS - 1;\n\n\t\tdo\n\t\t{\n\t\t\t--f;\n\t\t\tif (!relptr_is_null(fpm->freelist[f]))\n\t\t\t{\n\t\t\t\tlargest = f + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (f > 0);\n\t}\n\n\treturn largest;\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
      "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "relptr_is_null",
          "args": [
            "fpm->freelist[f]"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "candidate->next"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "fpm->freelist[FPM_NUM_FREELISTS - 1]"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_is_null",
          "args": [
            "fpm->freelist[FPM_NUM_FREELISTS - 1]"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_segment_base",
          "args": [
            "fpm"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic Size\nFreePageManagerLargestContiguous(FreePageManager *fpm)\n{\n\tchar\t   *base;\n\tSize\t\tlargest;\n\n\tbase = fpm_segment_base(fpm);\n\tlargest = 0;\n\tif (!relptr_is_null(fpm->freelist[FPM_NUM_FREELISTS - 1]))\n\t{\n\t\tFreePageSpanLeader *candidate;\n\n\t\tcandidate = relptr_access(base, fpm->freelist[FPM_NUM_FREELISTS - 1]);\n\t\tdo\n\t\t{\n\t\t\tif (candidate->npages > largest)\n\t\t\t\tlargest = candidate->npages;\n\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t} while (candidate != NULL);\n\t}\n\telse\n\t{\n\t\tSize\t\tf = FPM_NUM_FREELISTS - 1;\n\n\t\tdo\n\t\t{\n\t\t\t--f;\n\t\t\tif (!relptr_is_null(fpm->freelist[f]))\n\t\t\t{\n\t\t\t\tlargest = f + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (f > 0);\n\t}\n\n\treturn largest;\n}"
  },
  {
    "function_name": "sum_free_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "273-316",
    "snippet": "static Size\nsum_free_pages(FreePageManager *fpm)\n{\n\tFreePageSpanLeader *recycle;\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tsum = 0;\n\tint\t\t\tlist;\n\n\t/* Count the spans by scanning the freelists. */\n\tfor (list = 0; list < FPM_NUM_FREELISTS; ++list)\n\t{\n\n\t\tif (!relptr_is_null(fpm->freelist[list]))\n\t\t{\n\t\t\tFreePageSpanLeader *candidate =\n\t\t\trelptr_access(base, fpm->freelist[list]);\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tsum += candidate->npages;\n\t\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t\t} while (candidate != NULL);\n\t\t}\n\t}\n\n\t/* Count btree internal pages. */\n\tif (fpm->btree_depth > 0)\n\t{\n\t\tFreePageBtree *root = relptr_access(base, fpm->btree_root);\n\n\t\tsum_free_pages_recurse(fpm, root, &sum);\n\t}\n\n\t/* Count the recycle list. */\n\tfor (recycle = relptr_access(base, fpm->btree_recycle);\n\t\t recycle != NULL;\n\t\t recycle = relptr_access(base, recycle->next))\n\t{\n\t\tAssert(recycle->npages == 1);\n\t\t++sum;\n\t}\n\n\treturn sum;\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
      "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "recycle->npages == 1"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "recycle->next"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "fpm->btree_recycle"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sum_free_pages_recurse",
          "args": [
            "fpm",
            "root",
            "&sum"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "sum_free_pages_recurse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "251-272",
          "snippet": "static void\nsum_free_pages_recurse(FreePageManager *fpm, FreePageBtree *btp, Size *sum)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC ||\n\t\t   btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\t++*sum;\n\tif (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t{\n\t\tSize\t\tindex;\n\n\n\t\tfor (index = 0; index < btp->hdr.nused; ++index)\n\t\t{\n\t\t\tFreePageBtree *child;\n\n\t\t\tchild = relptr_access(base, btp->u.internal_key[index].child);\n\t\t\tsum_free_pages_recurse(fpm, child, sum);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nsum_free_pages_recurse(FreePageManager *fpm, FreePageBtree *btp, Size *sum)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC ||\n\t\t   btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\t++*sum;\n\tif (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t{\n\t\tSize\t\tindex;\n\n\n\t\tfor (index = 0; index < btp->hdr.nused; ++index)\n\t\t{\n\t\t\tFreePageBtree *child;\n\n\t\t\tchild = relptr_access(base, btp->u.internal_key[index].child);\n\t\t\tsum_free_pages_recurse(fpm, child, sum);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "fpm->btree_root"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "candidate->next"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "fpm->freelist[list]"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_is_null",
          "args": [
            "fpm->freelist[list]"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_segment_base",
          "args": [
            "fpm"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic Size\nsum_free_pages(FreePageManager *fpm)\n{\n\tFreePageSpanLeader *recycle;\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tsum = 0;\n\tint\t\t\tlist;\n\n\t/* Count the spans by scanning the freelists. */\n\tfor (list = 0; list < FPM_NUM_FREELISTS; ++list)\n\t{\n\n\t\tif (!relptr_is_null(fpm->freelist[list]))\n\t\t{\n\t\t\tFreePageSpanLeader *candidate =\n\t\t\trelptr_access(base, fpm->freelist[list]);\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tsum += candidate->npages;\n\t\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t\t} while (candidate != NULL);\n\t\t}\n\t}\n\n\t/* Count btree internal pages. */\n\tif (fpm->btree_depth > 0)\n\t{\n\t\tFreePageBtree *root = relptr_access(base, fpm->btree_root);\n\n\t\tsum_free_pages_recurse(fpm, root, &sum);\n\t}\n\n\t/* Count the recycle list. */\n\tfor (recycle = relptr_access(base, fpm->btree_recycle);\n\t\t recycle != NULL;\n\t\t recycle = relptr_access(base, recycle->next))\n\t{\n\t\tAssert(recycle->npages == 1);\n\t\t++sum;\n\t}\n\n\treturn sum;\n}"
  },
  {
    "function_name": "sum_free_pages_recurse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "251-272",
    "snippet": "static void\nsum_free_pages_recurse(FreePageManager *fpm, FreePageBtree *btp, Size *sum)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC ||\n\t\t   btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\t++*sum;\n\tif (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t{\n\t\tSize\t\tindex;\n\n\n\t\tfor (index = 0; index < btp->hdr.nused; ++index)\n\t\t{\n\t\t\tFreePageBtree *child;\n\n\t\t\tchild = relptr_access(base, btp->u.internal_key[index].child);\n\t\t\tsum_free_pages_recurse(fpm, child, sum);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
      "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
    ],
    "globals_used": [
      "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
      "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
      "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
      "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
      "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
      "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sum_free_pages_recurse",
          "args": [
            "fpm",
            "child",
            "sum"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "sum_free_pages_recurse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "251-272",
          "snippet": "static void\nsum_free_pages_recurse(FreePageManager *fpm, FreePageBtree *btp, Size *sum)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC ||\n\t\t   btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\t++*sum;\n\tif (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t{\n\t\tSize\t\tindex;\n\n\n\t\tfor (index = 0; index < btp->hdr.nused; ++index)\n\t\t{\n\t\t\tFreePageBtree *child;\n\n\t\t\tchild = relptr_access(base, btp->u.internal_key[index].child);\n\t\t\tsum_free_pages_recurse(fpm, child, sum);\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "relptr_access",
          "args": [
            "base",
            "btp->u.internal_key[index].child"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC ||\n\t\t   btp->hdr.magic == FREE_PAGE_LEAF_MAGIC"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fpm_segment_base",
          "args": [
            "fpm"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nsum_free_pages_recurse(FreePageManager *fpm, FreePageBtree *btp, Size *sum)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\n\tAssert(btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC ||\n\t\t   btp->hdr.magic == FREE_PAGE_LEAF_MAGIC);\n\t++*sum;\n\tif (btp->hdr.magic == FREE_PAGE_INTERNAL_MAGIC)\n\t{\n\t\tSize\t\tindex;\n\n\n\t\tfor (index = 0; index < btp->hdr.nused; ++index)\n\t\t{\n\t\t\tFreePageBtree *child;\n\n\t\t\tchild = relptr_access(base, btp->u.internal_key[index].child);\n\t\t\tsum_free_pages_recurse(fpm, child, sum);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "FreePageManagerGet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "209-248",
    "snippet": "bool\nFreePageManagerGet(FreePageManager *fpm, Size npages, Size *first_page)\n{\n\tbool\t\tresult;\n\tSize\t\tcontiguous_pages;\n\n\tresult = FreePageManagerGetInternal(fpm, npages, first_page);\n\n\t/*\n\t * It's a bit counterintuitive, but allocating pages can actually create\n\t * opportunities for cleanup that create larger ranges.  We might pull a\n\t * key out of the btree that enables the item at the head of the btree\n\t * recycle list to be inserted; and then if there are more items behind it\n\t * one of those might cause two currently-separated ranges to merge,\n\t * creating a single range of contiguous pages larger than any that\n\t * existed previously.  It might be worth trying to improve the cleanup\n\t * algorithm to avoid such corner cases, but for now we just notice the\n\t * condition and do the appropriate reporting.\n\t */\n\tcontiguous_pages = FreePageBtreeCleanup(fpm);\n\tif (fpm->contiguous_pages < contiguous_pages)\n\t\tfpm->contiguous_pages = contiguous_pages;\n\n\t/*\n\t * FreePageManagerGetInternal may have set contiguous_pages_dirty.\n\t * Recompute contigous_pages if so.\n\t */\n\tFreePageManagerUpdateLargest(fpm);\n\n#ifdef FPM_EXTRA_ASSERTS\n\tif (result)\n\t{\n\t\tAssert(fpm->free_pages >= npages);\n\t\tfpm->free_pages -= npages;\n\t}\n\tAssert(fpm->free_pages == sum_free_pages(fpm));\n\tAssert(fpm->contiguous_pages == FreePageManagerLargestContiguous(fpm));\n#endif\n\treturn result;\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
      "static void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);",
      "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
      "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
      "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
      "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "fpm->contiguous_pages == FreePageManagerLargestContiguous(fpm)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageManagerLargestContiguous",
          "args": [
            "fpm"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageManagerLargestContiguous",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "323-359",
          "snippet": "static Size\nFreePageManagerLargestContiguous(FreePageManager *fpm)\n{\n\tchar\t   *base;\n\tSize\t\tlargest;\n\n\tbase = fpm_segment_base(fpm);\n\tlargest = 0;\n\tif (!relptr_is_null(fpm->freelist[FPM_NUM_FREELISTS - 1]))\n\t{\n\t\tFreePageSpanLeader *candidate;\n\n\t\tcandidate = relptr_access(base, fpm->freelist[FPM_NUM_FREELISTS - 1]);\n\t\tdo\n\t\t{\n\t\t\tif (candidate->npages > largest)\n\t\t\t\tlargest = candidate->npages;\n\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t} while (candidate != NULL);\n\t}\n\telse\n\t{\n\t\tSize\t\tf = FPM_NUM_FREELISTS - 1;\n\n\t\tdo\n\t\t{\n\t\t\t--f;\n\t\t\tif (!relptr_is_null(fpm->freelist[f]))\n\t\t\t{\n\t\t\t\tlargest = f + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (f > 0);\n\t}\n\n\treturn largest;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic Size\nFreePageManagerLargestContiguous(FreePageManager *fpm)\n{\n\tchar\t   *base;\n\tSize\t\tlargest;\n\n\tbase = fpm_segment_base(fpm);\n\tlargest = 0;\n\tif (!relptr_is_null(fpm->freelist[FPM_NUM_FREELISTS - 1]))\n\t{\n\t\tFreePageSpanLeader *candidate;\n\n\t\tcandidate = relptr_access(base, fpm->freelist[FPM_NUM_FREELISTS - 1]);\n\t\tdo\n\t\t{\n\t\t\tif (candidate->npages > largest)\n\t\t\t\tlargest = candidate->npages;\n\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t} while (candidate != NULL);\n\t}\n\telse\n\t{\n\t\tSize\t\tf = FPM_NUM_FREELISTS - 1;\n\n\t\tdo\n\t\t{\n\t\t\t--f;\n\t\t\tif (!relptr_is_null(fpm->freelist[f]))\n\t\t\t{\n\t\t\t\tlargest = f + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (f > 0);\n\t}\n\n\treturn largest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "fpm->free_pages == sum_free_pages(fpm)"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sum_free_pages",
          "args": [
            "fpm"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "sum_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "273-316",
          "snippet": "static Size\nsum_free_pages(FreePageManager *fpm)\n{\n\tFreePageSpanLeader *recycle;\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tsum = 0;\n\tint\t\t\tlist;\n\n\t/* Count the spans by scanning the freelists. */\n\tfor (list = 0; list < FPM_NUM_FREELISTS; ++list)\n\t{\n\n\t\tif (!relptr_is_null(fpm->freelist[list]))\n\t\t{\n\t\t\tFreePageSpanLeader *candidate =\n\t\t\trelptr_access(base, fpm->freelist[list]);\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tsum += candidate->npages;\n\t\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t\t} while (candidate != NULL);\n\t\t}\n\t}\n\n\t/* Count btree internal pages. */\n\tif (fpm->btree_depth > 0)\n\t{\n\t\tFreePageBtree *root = relptr_access(base, fpm->btree_root);\n\n\t\tsum_free_pages_recurse(fpm, root, &sum);\n\t}\n\n\t/* Count the recycle list. */\n\tfor (recycle = relptr_access(base, fpm->btree_recycle);\n\t\t recycle != NULL;\n\t\t recycle = relptr_access(base, recycle->next))\n\t{\n\t\tAssert(recycle->npages == 1);\n\t\t++sum;\n\t}\n\n\treturn sum;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic Size\nsum_free_pages(FreePageManager *fpm)\n{\n\tFreePageSpanLeader *recycle;\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tsum = 0;\n\tint\t\t\tlist;\n\n\t/* Count the spans by scanning the freelists. */\n\tfor (list = 0; list < FPM_NUM_FREELISTS; ++list)\n\t{\n\n\t\tif (!relptr_is_null(fpm->freelist[list]))\n\t\t{\n\t\t\tFreePageSpanLeader *candidate =\n\t\t\trelptr_access(base, fpm->freelist[list]);\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tsum += candidate->npages;\n\t\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t\t} while (candidate != NULL);\n\t\t}\n\t}\n\n\t/* Count btree internal pages. */\n\tif (fpm->btree_depth > 0)\n\t{\n\t\tFreePageBtree *root = relptr_access(base, fpm->btree_root);\n\n\t\tsum_free_pages_recurse(fpm, root, &sum);\n\t}\n\n\t/* Count the recycle list. */\n\tfor (recycle = relptr_access(base, fpm->btree_recycle);\n\t\t recycle != NULL;\n\t\t recycle = relptr_access(base, recycle->next))\n\t{\n\t\tAssert(recycle->npages == 1);\n\t\t++sum;\n\t}\n\n\treturn sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "fpm->free_pages >= npages"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreePageManagerUpdateLargest",
          "args": [
            "fpm"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageManagerUpdateLargest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "365-373",
          "snippet": "static void\nFreePageManagerUpdateLargest(FreePageManager *fpm)\n{\n\tif (!fpm->contiguous_pages_dirty)\n\t\treturn;\n\n\tfpm->contiguous_pages = FreePageManagerLargestContiguous(fpm);\n\tfpm->contiguous_pages_dirty = false;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic void\nFreePageManagerUpdateLargest(FreePageManager *fpm)\n{\n\tif (!fpm->contiguous_pages_dirty)\n\t\treturn;\n\n\tfpm->contiguous_pages = FreePageManagerLargestContiguous(fpm);\n\tfpm->contiguous_pages_dirty = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageBtreeCleanup",
          "args": [
            "fpm"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageBtreeCleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "579-688",
          "snippet": "static Size\nFreePageBtreeCleanup(FreePageManager *fpm)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tmax_contiguous_pages = 0;\n\n\t/* Attempt to shrink the depth of the btree. */\n\twhile (!relptr_is_null(fpm->btree_root))\n\t{\n\t\tFreePageBtree *root = relptr_access(base, fpm->btree_root);\n\n\t\t/* If the root contains only one key, reduce depth by one. */\n\t\tif (root->hdr.nused == 1)\n\t\t{\n\t\t\t/* Shrink depth of tree by one. */\n\t\t\tAssert(fpm->btree_depth > 0);\n\t\t\t--fpm->btree_depth;\n\t\t\tif (root->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t\t{\n\t\t\t\t/* If root is a leaf, convert only entry to singleton range. */\n\t\t\t\trelptr_store(base, fpm->btree_root, (FreePageBtree *) NULL);\n\t\t\t\tfpm->singleton_first_page = root->u.leaf_key[0].first_page;\n\t\t\t\tfpm->singleton_npages = root->u.leaf_key[0].npages;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFreePageBtree *newroot;\n\n\t\t\t\t/* If root is an internal page, make only child the root. */\n\t\t\t\tAssert(root->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\t\t\trelptr_copy(fpm->btree_root, root->u.internal_key[0].child);\n\t\t\t\tnewroot = relptr_access(base, fpm->btree_root);\n\t\t\t\trelptr_store(base, newroot->hdr.parent, (FreePageBtree *) NULL);\n\t\t\t}\n\t\t\tFreePageBtreeRecycle(fpm, fpm_pointer_to_page(base, root));\n\t\t}\n\t\telse if (root->hdr.nused == 2 &&\n\t\t\t\t root->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t{\n\t\t\tSize\t\tend_of_first;\n\t\t\tSize\t\tstart_of_second;\n\n\t\t\tend_of_first = root->u.leaf_key[0].first_page +\n\t\t\t\troot->u.leaf_key[0].npages;\n\t\t\tstart_of_second = root->u.leaf_key[1].first_page;\n\n\t\t\tif (end_of_first + 1 == start_of_second)\n\t\t\t{\n\t\t\t\tSize\t\troot_page = fpm_pointer_to_page(base, root);\n\n\t\t\t\tif (end_of_first == root_page)\n\t\t\t\t{\n\t\t\t\t\tFreePagePopSpanLeader(fpm, root->u.leaf_key[0].first_page);\n\t\t\t\t\tFreePagePopSpanLeader(fpm, root->u.leaf_key[1].first_page);\n\t\t\t\t\tfpm->singleton_first_page = root->u.leaf_key[0].first_page;\n\t\t\t\t\tfpm->singleton_npages = root->u.leaf_key[0].npages +\n\t\t\t\t\t\troot->u.leaf_key[1].npages + 1;\n\t\t\t\t\tfpm->btree_depth = 0;\n\t\t\t\t\trelptr_store(base, fpm->btree_root,\n\t\t\t\t\t\t\t\t (FreePageBtree *) NULL);\n\t\t\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t\t\t\t\tAssert(max_contiguous_pages == 0);\n\t\t\t\t\tmax_contiguous_pages = fpm->singleton_npages;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Whether it worked or not, it's time to stop. */\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Nothing more to do.  Stop. */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Attempt to free recycled btree pages.  We skip this if releasing the\n\t * recycled page would require a btree page split, because the page we're\n\t * trying to recycle would be consumed by the split, which would be\n\t * counterproductive.\n\t *\n\t * We also currently only ever attempt to recycle the first page on the\n\t * list; that could be made more aggressive, but it's not clear that the\n\t * complexity would be worthwhile.\n\t */\n\twhile (fpm->btree_recycle_count > 0)\n\t{\n\t\tFreePageBtree *btp;\n\t\tSize\t\tfirst_page;\n\t\tSize\t\tcontiguous_pages;\n\n\t\tbtp = FreePageBtreeGetRecycled(fpm);\n\t\tfirst_page = fpm_pointer_to_page(base, btp);\n\t\tcontiguous_pages = FreePageManagerPutInternal(fpm, first_page, 1, true);\n\t\tif (contiguous_pages == 0)\n\t\t{\n\t\t\tFreePageBtreeRecycle(fpm, first_page);\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (contiguous_pages > max_contiguous_pages)\n\t\t\t\tmax_contiguous_pages = contiguous_pages;\n\t\t}\n\t}\n\n\treturn max_contiguous_pages;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9",
            "#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728"
          ],
          "globals_used": [
            "static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);",
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);",
            "static Size FreePageBtreeFirstKey(FreePageBtree *btp);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);",
            "static void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_INTERNAL_MAGIC\t\t0x19aa32c9\n#define FREE_PAGE_LEAF_MAGIC\t\t\t0x98eae728\n\nstatic void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm,\n\t\t\t\t\t\t\t\tFreePageBtree *btp);\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeFindLeftSibling(char *base,\n\t\t\t\t\t\t\t FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeFindRightSibling(char *base,\n\t\t\t\t\t\t\t  FreePageBtree *btp);\nstatic Size FreePageBtreeFirstKey(FreePageBtree *btp);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertInternal(char *base, FreePageBtree *btp,\n\t\t\t\t\t\t\tSize index, Size first_page, FreePageBtree *child);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRemovePage(FreePageManager *fpm, FreePageBtree *btp);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic FreePageBtree *FreePageBtreeSplitPage(FreePageManager *fpm,\n\t\t\t\t\t   FreePageBtree *btp);\nstatic void FreePageBtreeUpdateParentPointers(char *base, FreePageBtree *btp);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic Size\nFreePageBtreeCleanup(FreePageManager *fpm)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tSize\t\tmax_contiguous_pages = 0;\n\n\t/* Attempt to shrink the depth of the btree. */\n\twhile (!relptr_is_null(fpm->btree_root))\n\t{\n\t\tFreePageBtree *root = relptr_access(base, fpm->btree_root);\n\n\t\t/* If the root contains only one key, reduce depth by one. */\n\t\tif (root->hdr.nused == 1)\n\t\t{\n\t\t\t/* Shrink depth of tree by one. */\n\t\t\tAssert(fpm->btree_depth > 0);\n\t\t\t--fpm->btree_depth;\n\t\t\tif (root->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t\t{\n\t\t\t\t/* If root is a leaf, convert only entry to singleton range. */\n\t\t\t\trelptr_store(base, fpm->btree_root, (FreePageBtree *) NULL);\n\t\t\t\tfpm->singleton_first_page = root->u.leaf_key[0].first_page;\n\t\t\t\tfpm->singleton_npages = root->u.leaf_key[0].npages;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFreePageBtree *newroot;\n\n\t\t\t\t/* If root is an internal page, make only child the root. */\n\t\t\t\tAssert(root->hdr.magic == FREE_PAGE_INTERNAL_MAGIC);\n\t\t\t\trelptr_copy(fpm->btree_root, root->u.internal_key[0].child);\n\t\t\t\tnewroot = relptr_access(base, fpm->btree_root);\n\t\t\t\trelptr_store(base, newroot->hdr.parent, (FreePageBtree *) NULL);\n\t\t\t}\n\t\t\tFreePageBtreeRecycle(fpm, fpm_pointer_to_page(base, root));\n\t\t}\n\t\telse if (root->hdr.nused == 2 &&\n\t\t\t\t root->hdr.magic == FREE_PAGE_LEAF_MAGIC)\n\t\t{\n\t\t\tSize\t\tend_of_first;\n\t\t\tSize\t\tstart_of_second;\n\n\t\t\tend_of_first = root->u.leaf_key[0].first_page +\n\t\t\t\troot->u.leaf_key[0].npages;\n\t\t\tstart_of_second = root->u.leaf_key[1].first_page;\n\n\t\t\tif (end_of_first + 1 == start_of_second)\n\t\t\t{\n\t\t\t\tSize\t\troot_page = fpm_pointer_to_page(base, root);\n\n\t\t\t\tif (end_of_first == root_page)\n\t\t\t\t{\n\t\t\t\t\tFreePagePopSpanLeader(fpm, root->u.leaf_key[0].first_page);\n\t\t\t\t\tFreePagePopSpanLeader(fpm, root->u.leaf_key[1].first_page);\n\t\t\t\t\tfpm->singleton_first_page = root->u.leaf_key[0].first_page;\n\t\t\t\t\tfpm->singleton_npages = root->u.leaf_key[0].npages +\n\t\t\t\t\t\troot->u.leaf_key[1].npages + 1;\n\t\t\t\t\tfpm->btree_depth = 0;\n\t\t\t\t\trelptr_store(base, fpm->btree_root,\n\t\t\t\t\t\t\t\t (FreePageBtree *) NULL);\n\t\t\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t\t\t\t\tAssert(max_contiguous_pages == 0);\n\t\t\t\t\tmax_contiguous_pages = fpm->singleton_npages;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Whether it worked or not, it's time to stop. */\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Nothing more to do.  Stop. */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * Attempt to free recycled btree pages.  We skip this if releasing the\n\t * recycled page would require a btree page split, because the page we're\n\t * trying to recycle would be consumed by the split, which would be\n\t * counterproductive.\n\t *\n\t * We also currently only ever attempt to recycle the first page on the\n\t * list; that could be made more aggressive, but it's not clear that the\n\t * complexity would be worthwhile.\n\t */\n\twhile (fpm->btree_recycle_count > 0)\n\t{\n\t\tFreePageBtree *btp;\n\t\tSize\t\tfirst_page;\n\t\tSize\t\tcontiguous_pages;\n\n\t\tbtp = FreePageBtreeGetRecycled(fpm);\n\t\tfirst_page = fpm_pointer_to_page(base, btp);\n\t\tcontiguous_pages = FreePageManagerPutInternal(fpm, first_page, 1, true);\n\t\tif (contiguous_pages == 0)\n\t\t{\n\t\t\tFreePageBtreeRecycle(fpm, first_page);\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (contiguous_pages > max_contiguous_pages)\n\t\t\t\tmax_contiguous_pages = contiguous_pages;\n\t\t}\n\t}\n\n\treturn max_contiguous_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreePageManagerGetInternal",
          "args": [
            "fpm",
            "npages",
            "first_page"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "FreePageManagerGetInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
          "lines": "1318-1464",
          "snippet": "static bool\nFreePageManagerGetInternal(FreePageManager *fpm, Size npages, Size *first_page)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *victim = NULL;\n\tFreePageSpanLeader *prev;\n\tFreePageSpanLeader *next;\n\tFreePageBtreeSearchResult result;\n\tSize\t\tvictim_page = 0;\t/* placate compiler */\n\tSize\t\tf;\n\n\t/*\n\t * Search for a free span.\n\t *\n\t * Right now, we use a simple best-fit policy here, but it's possible for\n\t * this to result in memory fragmentation if we're repeatedly asked to\n\t * allocate chunks just a little smaller than what we have available.\n\t * Hopefully, this is unlikely, because we expect most requests to be\n\t * single pages or superblock-sized chunks -- but no policy can be optimal\n\t * under all circumstances unless it has knowledge of future allocation\n\t * patterns.\n\t */\n\tfor (f = Min(npages, FPM_NUM_FREELISTS) - 1; f < FPM_NUM_FREELISTS; ++f)\n\t{\n\t\t/* Skip empty freelists. */\n\t\tif (relptr_is_null(fpm->freelist[f]))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All of the freelists except the last one contain only items of a\n\t\t * single size, so we just take the first one.  But the final free\n\t\t * list contains everything too big for any of the other lists, so we\n\t\t * need to search the list.\n\t\t */\n\t\tif (f < FPM_NUM_FREELISTS - 1)\n\t\t\tvictim = relptr_access(base, fpm->freelist[f]);\n\t\telse\n\t\t{\n\t\t\tFreePageSpanLeader *candidate;\n\n\t\t\tcandidate = relptr_access(base, fpm->freelist[f]);\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (candidate->npages >= npages && (victim == NULL ||\n\t\t\t\t\t\t\t\t\t\t\t\t\tvictim->npages > candidate->npages))\n\t\t\t\t{\n\t\t\t\t\tvictim = candidate;\n\t\t\t\t\tif (victim->npages == npages)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t\t} while (candidate != NULL);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* If we didn't find an allocatable span, return failure. */\n\tif (victim == NULL)\n\t\treturn false;\n\n\t/* Remove span from free list. */\n\tAssert(victim->magic == FREE_PAGE_SPAN_LEADER_MAGIC);\n\tprev = relptr_access(base, victim->prev);\n\tnext = relptr_access(base, victim->next);\n\tif (prev != NULL)\n\t\trelptr_copy(prev->next, victim->next);\n\telse\n\t\trelptr_copy(fpm->freelist[f], victim->next);\n\tif (next != NULL)\n\t\trelptr_copy(next->prev, victim->prev);\n\tvictim_page = fpm_pointer_to_page(base, victim);\n\n\t/* Decide whether we might be invalidating contiguous_pages. */\n\tif (f == FPM_NUM_FREELISTS - 1 &&\n\t\tvictim->npages == fpm->contiguous_pages)\n\t{\n\t\t/*\n\t\t * The victim span came from the oversized freelist, and had the same\n\t\t * size as the longest span.  There may or may not be another one of\n\t\t * the same size, so contiguous_pages must be recomputed just to be\n\t\t * safe.\n\t\t */\n\t\tfpm->contiguous_pages_dirty = true;\n\t}\n\telse if (f + 1 == fpm->contiguous_pages &&\n\t\t\t relptr_is_null(fpm->freelist[f]))\n\t{\n\t\t/*\n\t\t * The victim span came from a fixed sized freelist, and it was the\n\t\t * list for spans of the same size as the current longest span, and\n\t\t * the list is now empty after removing the victim.  So\n\t\t * contiguous_pages must be recomputed without a doubt.\n\t\t */\n\t\tfpm->contiguous_pages_dirty = true;\n\t}\n\n\t/*\n\t * If we haven't initialized the btree yet, the victim must be the single\n\t * span stored within the FreePageManager itself.  Otherwise, we need to\n\t * update the btree.\n\t */\n\tif (relptr_is_null(fpm->btree_root))\n\t{\n\t\tAssert(victim_page == fpm->singleton_first_page);\n\t\tAssert(victim->npages == fpm->singleton_npages);\n\t\tAssert(victim->npages >= npages);\n\t\tfpm->singleton_first_page += npages;\n\t\tfpm->singleton_npages -= npages;\n\t\tif (fpm->singleton_npages > 0)\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If the span we found is exactly the right size, remove it from the\n\t\t * btree completely.  Otherwise, adjust the btree entry to reflect the\n\t\t * still-unallocated portion of the span, and put that portion on the\n\t\t * appropriate free list.\n\t\t */\n\t\tFreePageBtreeSearch(fpm, victim_page, &result);\n\t\tAssert(result.found);\n\t\tif (victim->npages == npages)\n\t\t\tFreePageBtreeRemove(fpm, result.page, result.index);\n\t\telse\n\t\t{\n\t\t\tFreePageBtreeLeafKey *key;\n\n\t\t\t/* Adjust btree to reflect remaining pages. */\n\t\t\tAssert(victim->npages > npages);\n\t\t\tkey = &result.page->u.leaf_key[result.index];\n\t\t\tAssert(key->npages == victim->npages);\n\t\t\tkey->first_page += npages;\n\t\t\tkey->npages -= npages;\n\t\t\tif (result.index == 0)\n\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, result.page);\n\n\t\t\t/* Put the unallocated pages back on the appropriate free list. */\n\t\t\tFreePagePushSpanLeader(fpm, victim_page + npages,\n\t\t\t\t\t\t\t\t   victim->npages - npages);\n\t\t}\n\t}\n\n\t/* Return results to caller. */\n\t*first_page = fpm_pointer_to_page(base, victim);\n\treturn true;\n}",
          "includes": [
            "#include \"utils/relptr.h\"",
            "#include \"utils/freepage.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0"
          ],
          "globals_used": [
            "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
            "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
            "static void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);",
            "static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);",
            "static void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);",
            "static Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);",
            "static Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);",
            "static bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);",
            "static void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);",
            "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
            "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\n#define FREE_PAGE_SPAN_LEADER_MAGIC\t\t0xea4020f0\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp,\n\t\t\t\t\tSize index);\nstatic void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nstatic bool\nFreePageManagerGetInternal(FreePageManager *fpm, Size npages, Size *first_page)\n{\n\tchar\t   *base = fpm_segment_base(fpm);\n\tFreePageSpanLeader *victim = NULL;\n\tFreePageSpanLeader *prev;\n\tFreePageSpanLeader *next;\n\tFreePageBtreeSearchResult result;\n\tSize\t\tvictim_page = 0;\t/* placate compiler */\n\tSize\t\tf;\n\n\t/*\n\t * Search for a free span.\n\t *\n\t * Right now, we use a simple best-fit policy here, but it's possible for\n\t * this to result in memory fragmentation if we're repeatedly asked to\n\t * allocate chunks just a little smaller than what we have available.\n\t * Hopefully, this is unlikely, because we expect most requests to be\n\t * single pages or superblock-sized chunks -- but no policy can be optimal\n\t * under all circumstances unless it has knowledge of future allocation\n\t * patterns.\n\t */\n\tfor (f = Min(npages, FPM_NUM_FREELISTS) - 1; f < FPM_NUM_FREELISTS; ++f)\n\t{\n\t\t/* Skip empty freelists. */\n\t\tif (relptr_is_null(fpm->freelist[f]))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * All of the freelists except the last one contain only items of a\n\t\t * single size, so we just take the first one.  But the final free\n\t\t * list contains everything too big for any of the other lists, so we\n\t\t * need to search the list.\n\t\t */\n\t\tif (f < FPM_NUM_FREELISTS - 1)\n\t\t\tvictim = relptr_access(base, fpm->freelist[f]);\n\t\telse\n\t\t{\n\t\t\tFreePageSpanLeader *candidate;\n\n\t\t\tcandidate = relptr_access(base, fpm->freelist[f]);\n\t\t\tdo\n\t\t\t{\n\t\t\t\tif (candidate->npages >= npages && (victim == NULL ||\n\t\t\t\t\t\t\t\t\t\t\t\t\tvictim->npages > candidate->npages))\n\t\t\t\t{\n\t\t\t\t\tvictim = candidate;\n\t\t\t\t\tif (victim->npages == npages)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcandidate = relptr_access(base, candidate->next);\n\t\t\t} while (candidate != NULL);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* If we didn't find an allocatable span, return failure. */\n\tif (victim == NULL)\n\t\treturn false;\n\n\t/* Remove span from free list. */\n\tAssert(victim->magic == FREE_PAGE_SPAN_LEADER_MAGIC);\n\tprev = relptr_access(base, victim->prev);\n\tnext = relptr_access(base, victim->next);\n\tif (prev != NULL)\n\t\trelptr_copy(prev->next, victim->next);\n\telse\n\t\trelptr_copy(fpm->freelist[f], victim->next);\n\tif (next != NULL)\n\t\trelptr_copy(next->prev, victim->prev);\n\tvictim_page = fpm_pointer_to_page(base, victim);\n\n\t/* Decide whether we might be invalidating contiguous_pages. */\n\tif (f == FPM_NUM_FREELISTS - 1 &&\n\t\tvictim->npages == fpm->contiguous_pages)\n\t{\n\t\t/*\n\t\t * The victim span came from the oversized freelist, and had the same\n\t\t * size as the longest span.  There may or may not be another one of\n\t\t * the same size, so contiguous_pages must be recomputed just to be\n\t\t * safe.\n\t\t */\n\t\tfpm->contiguous_pages_dirty = true;\n\t}\n\telse if (f + 1 == fpm->contiguous_pages &&\n\t\t\t relptr_is_null(fpm->freelist[f]))\n\t{\n\t\t/*\n\t\t * The victim span came from a fixed sized freelist, and it was the\n\t\t * list for spans of the same size as the current longest span, and\n\t\t * the list is now empty after removing the victim.  So\n\t\t * contiguous_pages must be recomputed without a doubt.\n\t\t */\n\t\tfpm->contiguous_pages_dirty = true;\n\t}\n\n\t/*\n\t * If we haven't initialized the btree yet, the victim must be the single\n\t * span stored within the FreePageManager itself.  Otherwise, we need to\n\t * update the btree.\n\t */\n\tif (relptr_is_null(fpm->btree_root))\n\t{\n\t\tAssert(victim_page == fpm->singleton_first_page);\n\t\tAssert(victim->npages == fpm->singleton_npages);\n\t\tAssert(victim->npages >= npages);\n\t\tfpm->singleton_first_page += npages;\n\t\tfpm->singleton_npages -= npages;\n\t\tif (fpm->singleton_npages > 0)\n\t\t\tFreePagePushSpanLeader(fpm, fpm->singleton_first_page,\n\t\t\t\t\t\t\t\t   fpm->singleton_npages);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If the span we found is exactly the right size, remove it from the\n\t\t * btree completely.  Otherwise, adjust the btree entry to reflect the\n\t\t * still-unallocated portion of the span, and put that portion on the\n\t\t * appropriate free list.\n\t\t */\n\t\tFreePageBtreeSearch(fpm, victim_page, &result);\n\t\tAssert(result.found);\n\t\tif (victim->npages == npages)\n\t\t\tFreePageBtreeRemove(fpm, result.page, result.index);\n\t\telse\n\t\t{\n\t\t\tFreePageBtreeLeafKey *key;\n\n\t\t\t/* Adjust btree to reflect remaining pages. */\n\t\t\tAssert(victim->npages > npages);\n\t\t\tkey = &result.page->u.leaf_key[result.index];\n\t\t\tAssert(key->npages == victim->npages);\n\t\t\tkey->first_page += npages;\n\t\t\tkey->npages -= npages;\n\t\t\tif (result.index == 0)\n\t\t\t\tFreePageBtreeAdjustAncestorKeys(fpm, result.page);\n\n\t\t\t/* Put the unallocated pages back on the appropriate free list. */\n\t\t\tFreePagePushSpanLeader(fpm, victim_page + npages,\n\t\t\t\t\t\t\t\t   victim->npages - npages);\n\t\t}\n\t}\n\n\t/* Return results to caller. */\n\t*first_page = fpm_pointer_to_page(base, victim);\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic void FreePageBtreeInsertLeaf(FreePageBtree *btp, Size index,\n\t\t\t\t\t\tSize first_page, Size npages);\nstatic void FreePageBtreeSearch(FreePageManager *fpm, Size first_page,\n\t\t\t\t\tFreePageBtreeSearchResult *result);\nstatic Size FreePageBtreeSearchInternal(FreePageBtree *btp, Size first_page);\nstatic Size FreePageBtreeSearchLeaf(FreePageBtree *btp, Size first_page);\nstatic bool FreePageManagerGetInternal(FreePageManager *fpm, Size npages,\n\t\t\t\t\t\t   Size *first_page);\nstatic void FreePagePushSpanLeader(FreePageManager *fpm, Size first_page,\n\t\t\t\t\t   Size npages);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nbool\nFreePageManagerGet(FreePageManager *fpm, Size npages, Size *first_page)\n{\n\tbool\t\tresult;\n\tSize\t\tcontiguous_pages;\n\n\tresult = FreePageManagerGetInternal(fpm, npages, first_page);\n\n\t/*\n\t * It's a bit counterintuitive, but allocating pages can actually create\n\t * opportunities for cleanup that create larger ranges.  We might pull a\n\t * key out of the btree that enables the item at the head of the btree\n\t * recycle list to be inserted; and then if there are more items behind it\n\t * one of those might cause two currently-separated ranges to merge,\n\t * creating a single range of contiguous pages larger than any that\n\t * existed previously.  It might be worth trying to improve the cleanup\n\t * algorithm to avoid such corner cases, but for now we just notice the\n\t * condition and do the appropriate reporting.\n\t */\n\tcontiguous_pages = FreePageBtreeCleanup(fpm);\n\tif (fpm->contiguous_pages < contiguous_pages)\n\t\tfpm->contiguous_pages = contiguous_pages;\n\n\t/*\n\t * FreePageManagerGetInternal may have set contiguous_pages_dirty.\n\t * Recompute contigous_pages if so.\n\t */\n\tFreePageManagerUpdateLargest(fpm);\n\n#ifdef FPM_EXTRA_ASSERTS\n\tif (result)\n\t{\n\t\tAssert(fpm->free_pages >= npages);\n\t\tfpm->free_pages -= npages;\n\t}\n\tAssert(fpm->free_pages == sum_free_pages(fpm));\n\tAssert(fpm->contiguous_pages == FreePageManagerLargestContiguous(fpm));\n#endif\n\treturn result;\n}"
  },
  {
    "function_name": "FreePageManagerInitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/freepage.c",
    "lines": "182-202",
    "snippet": "void\nFreePageManagerInitialize(FreePageManager *fpm, char *base)\n{\n\tSize\t\tf;\n\n\trelptr_store(base, fpm->self, fpm);\n\trelptr_store(base, fpm->btree_root, (FreePageBtree *) NULL);\n\trelptr_store(base, fpm->btree_recycle, (FreePageSpanLeader *) NULL);\n\tfpm->btree_depth = 0;\n\tfpm->btree_recycle_count = 0;\n\tfpm->singleton_first_page = 0;\n\tfpm->singleton_npages = 0;\n\tfpm->contiguous_pages = 0;\n\tfpm->contiguous_pages_dirty = true;\n#ifdef FPM_EXTRA_ASSERTS\n\tfpm->free_pages = 0;\n#endif\n\n\tfor (f = 0; f < FPM_NUM_FREELISTS; f++)\n\t\trelptr_store(base, fpm->freelist[f], (FreePageSpanLeader *) NULL);\n}",
    "includes": [
      "#include \"utils/relptr.h\"",
      "#include \"utils/freepage.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Size FreePageBtreeCleanup(FreePageManager *fpm);",
      "static FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);",
      "static Size FreePageManagerLargestContiguous(FreePageManager *fpm);",
      "static void FreePageManagerUpdateLargest(FreePageManager *fpm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "fpm->freelist[f]",
            "(FreePageSpanLeader *) NULL"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "fpm->btree_recycle",
            "(FreePageSpanLeader *) NULL"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "fpm->btree_root",
            "(FreePageBtree *) NULL"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relptr_store",
          "args": [
            "base",
            "fpm->self",
            "fpm"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/relptr.h\"\n#include \"utils/freepage.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"postgres.h\"\n\nstatic Size FreePageBtreeCleanup(FreePageManager *fpm);\nstatic FreePageBtree *FreePageBtreeGetRecycled(FreePageManager *fpm);\nstatic Size FreePageManagerLargestContiguous(FreePageManager *fpm);\nstatic void FreePageManagerUpdateLargest(FreePageManager *fpm);\n\nvoid\nFreePageManagerInitialize(FreePageManager *fpm, char *base)\n{\n\tSize\t\tf;\n\n\trelptr_store(base, fpm->self, fpm);\n\trelptr_store(base, fpm->btree_root, (FreePageBtree *) NULL);\n\trelptr_store(base, fpm->btree_recycle, (FreePageSpanLeader *) NULL);\n\tfpm->btree_depth = 0;\n\tfpm->btree_recycle_count = 0;\n\tfpm->singleton_first_page = 0;\n\tfpm->singleton_npages = 0;\n\tfpm->contiguous_pages = 0;\n\tfpm->contiguous_pages_dirty = true;\n#ifdef FPM_EXTRA_ASSERTS\n\tfpm->free_pages = 0;\n#endif\n\n\tfor (f = 0; f < FPM_NUM_FREELISTS; f++)\n\t\trelptr_store(base, fpm->freelist[f], (FreePageSpanLeader *) NULL);\n}"
  }
]