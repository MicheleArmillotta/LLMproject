[
  {
    "function_name": "repeat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
    "lines": "1033-1068",
    "snippet": "Datum\nrepeat(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string = PG_GETARG_TEXT_PP(0);\n\tint32\t\tcount = PG_GETARG_INT32(1);\n\ttext\t   *result;\n\tint\t\t\tslen,\n\t\t\t\ttlen;\n\tint\t\t\ti;\n\tchar\t   *cp,\n\t\t\t   *sp;\n\n\tif (count < 0)\n\t\tcount = 0;\n\n\tslen = VARSIZE_ANY_EXHDR(string);\n\n\tif (unlikely(pg_mul_s32_overflow(count, slen, &tlen)) ||\n\t\tunlikely(pg_add_s32_overflow(tlen, VARHDRSZ, &tlen)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"requested length too large\")));\n\n\tresult = (text *) palloc(tlen);\n\n\tSET_VARSIZE(result, tlen);\n\tcp = VARDATA(result);\n\tsp = VARDATA_ANY(string);\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tmemcpy(cp, sp, slen);\n\t\tcp += slen;\n\t}\n\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"common/int.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cp",
            "sp",
            "slen"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "string"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "tlen"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "tlen"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"requested length too large\"))"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"requested length too large\""
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pg_add_s32_overflow(tlen, VARHDRSZ, &tlen)"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_add_s32_overflow",
          "args": [
            "tlen",
            "VARHDRSZ",
            "&tlen"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pg_mul_s32_overflow(count, slen, &tlen)"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mul_s32_overflow",
          "args": [
            "count",
            "slen",
            "&tlen"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "string"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nDatum\nrepeat(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string = PG_GETARG_TEXT_PP(0);\n\tint32\t\tcount = PG_GETARG_INT32(1);\n\ttext\t   *result;\n\tint\t\t\tslen,\n\t\t\t\ttlen;\n\tint\t\t\ti;\n\tchar\t   *cp,\n\t\t\t   *sp;\n\n\tif (count < 0)\n\t\tcount = 0;\n\n\tslen = VARSIZE_ANY_EXHDR(string);\n\n\tif (unlikely(pg_mul_s32_overflow(count, slen, &tlen)) ||\n\t\tunlikely(pg_add_s32_overflow(tlen, VARHDRSZ, &tlen)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"requested length too large\")));\n\n\tresult = (text *) palloc(tlen);\n\n\tSET_VARSIZE(result, tlen);\n\tcp = VARDATA(result);\n\tsp = VARDATA_ANY(string);\n\tfor (i = 0; i < count; i++)\n\t{\n\t\tmemcpy(cp, sp, slen);\n\t\tcp += slen;\n\t}\n\n\tPG_RETURN_TEXT_P(result);\n}"
  },
  {
    "function_name": "chr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
    "lines": "925-1017",
    "snippet": "Datum\nchr\t\t\t(PG_FUNCTION_ARGS)\n{\n\tuint32\t\tcvalue = PG_GETARG_UINT32(0);\n\ttext\t   *result;\n\tint\t\t\tencoding = GetDatabaseEncoding();\n\n\tif (encoding == PG_UTF8 && cvalue > 127)\n\t{\n\t\t/* for Unicode we treat the argument as a code point */\n\t\tint\t\t\tbytes;\n\t\tunsigned char *wch;\n\n\t\t/*\n\t\t * We only allow valid Unicode code points; per RFC3629 that stops at\n\t\t * U+10FFFF, even though 4-byte UTF8 sequences can hold values up to\n\t\t * U+1FFFFF.\n\t\t */\n\t\tif (cvalue > 0x0010ffff)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"requested character too large for encoding: %d\",\n\t\t\t\t\t\t\tcvalue)));\n\n\t\tif (cvalue > 0xffff)\n\t\t\tbytes = 4;\n\t\telse if (cvalue > 0x07ff)\n\t\t\tbytes = 3;\n\t\telse\n\t\t\tbytes = 2;\n\n\t\tresult = (text *) palloc(VARHDRSZ + bytes);\n\t\tSET_VARSIZE(result, VARHDRSZ + bytes);\n\t\twch = (unsigned char *) VARDATA(result);\n\n\t\tif (bytes == 2)\n\t\t{\n\t\t\twch[0] = 0xC0 | ((cvalue >> 6) & 0x1F);\n\t\t\twch[1] = 0x80 | (cvalue & 0x3F);\n\t\t}\n\t\telse if (bytes == 3)\n\t\t{\n\t\t\twch[0] = 0xE0 | ((cvalue >> 12) & 0x0F);\n\t\t\twch[1] = 0x80 | ((cvalue >> 6) & 0x3F);\n\t\t\twch[2] = 0x80 | (cvalue & 0x3F);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twch[0] = 0xF0 | ((cvalue >> 18) & 0x07);\n\t\t\twch[1] = 0x80 | ((cvalue >> 12) & 0x3F);\n\t\t\twch[2] = 0x80 | ((cvalue >> 6) & 0x3F);\n\t\t\twch[3] = 0x80 | (cvalue & 0x3F);\n\t\t}\n\n\t\t/*\n\t\t * The preceding range check isn't sufficient, because UTF8 excludes\n\t\t * Unicode \"surrogate pair\" codes.  Make sure what we created is valid\n\t\t * UTF8.\n\t\t */\n\t\tif (!pg_utf8_islegal(wch, bytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"requested character not valid for encoding: %d\",\n\t\t\t\t\t\t\tcvalue)));\n\t}\n\telse\n\t{\n\t\tbool\t\tis_mb;\n\n\t\t/*\n\t\t * Error out on arguments that make no sense or that we can't validly\n\t\t * represent in the encoding.\n\t\t */\n\t\tif (cvalue == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"null character not permitted\")));\n\n\t\tis_mb = pg_encoding_max_length(encoding) > 1;\n\n\t\tif ((is_mb && (cvalue > 127)) || (!is_mb && (cvalue > 255)))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"requested character too large for encoding: %d\",\n\t\t\t\t\t\t\tcvalue)));\n\n\t\tresult = (text *) palloc(VARHDRSZ + 1);\n\t\tSET_VARSIZE(result, VARHDRSZ + 1);\n\t\t*VARDATA(result) = (char) cvalue;\n\t}\n\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"common/int.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "VARHDRSZ + 1"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "VARHDRSZ + 1"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"requested character too large for encoding: %d\",\n\t\t\t\t\t\t\tcvalue))"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"requested character too large for encoding: %d\"",
            "cvalue"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_encoding_max_length",
          "args": [
            "encoding"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "pg_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1819-1825",
          "snippet": "int\npg_encoding_max_length(int encoding)\n{\n\tAssert(PG_VALID_ENCODING(encoding));\n\n\treturn pg_wchar_table[encoding].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_encoding_max_length(int encoding)\n{\n\tAssert(PG_VALID_ENCODING(encoding));\n\n\treturn pg_wchar_table[encoding].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"null character not permitted\"))"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"requested character not valid for encoding: %d\",\n\t\t\t\t\t\t\tcvalue))"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_utf8_islegal",
          "args": [
            "wch",
            "bytes"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "pg_utf8_islegal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1457-1512",
          "snippet": "bool\npg_utf8_islegal(const unsigned char *source, int length)\n{\n\tunsigned char a;\n\n\tswitch (length)\n\t{\n\t\tdefault:\n\t\t\t/* reject lengths 5 and 6 for now */\n\t\t\treturn false;\n\t\tcase 4:\n\t\t\ta = source[3];\n\t\t\tif (a < 0x80 || a > 0xBF)\n\t\t\t\treturn false;\n\t\t\t/* FALL THRU */\n\t\tcase 3:\n\t\t\ta = source[2];\n\t\t\tif (a < 0x80 || a > 0xBF)\n\t\t\t\treturn false;\n\t\t\t/* FALL THRU */\n\t\tcase 2:\n\t\t\ta = source[1];\n\t\t\tswitch (*source)\n\t\t\t{\n\t\t\t\tcase 0xE0:\n\t\t\t\t\tif (a < 0xA0 || a > 0xBF)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xED:\n\t\t\t\t\tif (a < 0x80 || a > 0x9F)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xF0:\n\t\t\t\t\tif (a < 0x90 || a > 0xBF)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xF4:\n\t\t\t\t\tif (a < 0x80 || a > 0x8F)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (a < 0x80 || a > 0xBF)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALL THRU */\n\t\tcase 1:\n\t\t\ta = *source;\n\t\t\tif (a >= 0x80 && a < 0xC2)\n\t\t\t\treturn false;\n\t\t\tif (a > 0xF4)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nbool\npg_utf8_islegal(const unsigned char *source, int length)\n{\n\tunsigned char a;\n\n\tswitch (length)\n\t{\n\t\tdefault:\n\t\t\t/* reject lengths 5 and 6 for now */\n\t\t\treturn false;\n\t\tcase 4:\n\t\t\ta = source[3];\n\t\t\tif (a < 0x80 || a > 0xBF)\n\t\t\t\treturn false;\n\t\t\t/* FALL THRU */\n\t\tcase 3:\n\t\t\ta = source[2];\n\t\t\tif (a < 0x80 || a > 0xBF)\n\t\t\t\treturn false;\n\t\t\t/* FALL THRU */\n\t\tcase 2:\n\t\t\ta = source[1];\n\t\t\tswitch (*source)\n\t\t\t{\n\t\t\t\tcase 0xE0:\n\t\t\t\t\tif (a < 0xA0 || a > 0xBF)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xED:\n\t\t\t\t\tif (a < 0x80 || a > 0x9F)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xF0:\n\t\t\t\t\tif (a < 0x90 || a > 0xBF)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xF4:\n\t\t\t\t\tif (a < 0x80 || a > 0x8F)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (a < 0x80 || a > 0xBF)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* FALL THRU */\n\t\tcase 1:\n\t\t\ta = *source;\n\t\t\tif (a >= 0x80 && a < 0xC2)\n\t\t\t\treturn false;\n\t\t\tif (a > 0xF4)\n\t\t\t\treturn false;\n\t\t\tbreak;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "VARHDRSZ + bytes"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"requested character too large for encoding: %d\",\n\t\t\t\t\t\t\tcvalue))"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_UINT32",
          "args": [
            "0"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nDatum\nchr\t\t\t(PG_FUNCTION_ARGS)\n{\n\tuint32\t\tcvalue = PG_GETARG_UINT32(0);\n\ttext\t   *result;\n\tint\t\t\tencoding = GetDatabaseEncoding();\n\n\tif (encoding == PG_UTF8 && cvalue > 127)\n\t{\n\t\t/* for Unicode we treat the argument as a code point */\n\t\tint\t\t\tbytes;\n\t\tunsigned char *wch;\n\n\t\t/*\n\t\t * We only allow valid Unicode code points; per RFC3629 that stops at\n\t\t * U+10FFFF, even though 4-byte UTF8 sequences can hold values up to\n\t\t * U+1FFFFF.\n\t\t */\n\t\tif (cvalue > 0x0010ffff)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"requested character too large for encoding: %d\",\n\t\t\t\t\t\t\tcvalue)));\n\n\t\tif (cvalue > 0xffff)\n\t\t\tbytes = 4;\n\t\telse if (cvalue > 0x07ff)\n\t\t\tbytes = 3;\n\t\telse\n\t\t\tbytes = 2;\n\n\t\tresult = (text *) palloc(VARHDRSZ + bytes);\n\t\tSET_VARSIZE(result, VARHDRSZ + bytes);\n\t\twch = (unsigned char *) VARDATA(result);\n\n\t\tif (bytes == 2)\n\t\t{\n\t\t\twch[0] = 0xC0 | ((cvalue >> 6) & 0x1F);\n\t\t\twch[1] = 0x80 | (cvalue & 0x3F);\n\t\t}\n\t\telse if (bytes == 3)\n\t\t{\n\t\t\twch[0] = 0xE0 | ((cvalue >> 12) & 0x0F);\n\t\t\twch[1] = 0x80 | ((cvalue >> 6) & 0x3F);\n\t\t\twch[2] = 0x80 | (cvalue & 0x3F);\n\t\t}\n\t\telse\n\t\t{\n\t\t\twch[0] = 0xF0 | ((cvalue >> 18) & 0x07);\n\t\t\twch[1] = 0x80 | ((cvalue >> 12) & 0x3F);\n\t\t\twch[2] = 0x80 | ((cvalue >> 6) & 0x3F);\n\t\t\twch[3] = 0x80 | (cvalue & 0x3F);\n\t\t}\n\n\t\t/*\n\t\t * The preceding range check isn't sufficient, because UTF8 excludes\n\t\t * Unicode \"surrogate pair\" codes.  Make sure what we created is valid\n\t\t * UTF8.\n\t\t */\n\t\tif (!pg_utf8_islegal(wch, bytes))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"requested character not valid for encoding: %d\",\n\t\t\t\t\t\t\tcvalue)));\n\t}\n\telse\n\t{\n\t\tbool\t\tis_mb;\n\n\t\t/*\n\t\t * Error out on arguments that make no sense or that we can't validly\n\t\t * represent in the encoding.\n\t\t */\n\t\tif (cvalue == 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"null character not permitted\")));\n\n\t\tis_mb = pg_encoding_max_length(encoding) > 1;\n\n\t\tif ((is_mb && (cvalue > 127)) || (!is_mb && (cvalue > 255)))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"requested character too large for encoding: %d\",\n\t\t\t\t\t\t\tcvalue)));\n\n\t\tresult = (text *) palloc(VARHDRSZ + 1);\n\t\tSET_VARSIZE(result, VARHDRSZ + 1);\n\t\t*VARDATA(result) = (char) cvalue;\n\t}\n\n\tPG_RETURN_TEXT_P(result);\n}"
  },
  {
    "function_name": "ascii",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
    "lines": "844-901",
    "snippet": "Datum\nascii(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string = PG_GETARG_TEXT_PP(0);\n\tint\t\t\tencoding = GetDatabaseEncoding();\n\tunsigned char *data;\n\n\tif (VARSIZE_ANY_EXHDR(string) <= 0)\n\t\tPG_RETURN_INT32(0);\n\n\tdata = (unsigned char *) VARDATA_ANY(string);\n\n\tif (encoding == PG_UTF8 && *data > 127)\n\t{\n\t\t/* return the code point for Unicode */\n\n\t\tint\t\t\tresult = 0,\n\t\t\t\t\ttbytes = 0,\n\t\t\t\t\ti;\n\n\t\tif (*data >= 0xF0)\n\t\t{\n\t\t\tresult = *data & 0x07;\n\t\t\ttbytes = 3;\n\t\t}\n\t\telse if (*data >= 0xE0)\n\t\t{\n\t\t\tresult = *data & 0x0F;\n\t\t\ttbytes = 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tAssert(*data > 0xC0);\n\t\t\tresult = *data & 0x1f;\n\t\t\ttbytes = 1;\n\t\t}\n\n\t\tAssert(tbytes > 0);\n\n\t\tfor (i = 1; i <= tbytes; i++)\n\t\t{\n\t\t\tAssert((data[i] & 0xC0) == 0x80);\n\t\t\tresult = (result << 6) + (data[i] & 0x3f);\n\t\t}\n\n\t\tPG_RETURN_INT32(result);\n\t}\n\telse\n\t{\n\t\tif (pg_encoding_max_length(encoding) > 1 && *data > 127)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"requested character too large\")));\n\n\n\t\tPG_RETURN_INT32((int32) *data);\n\t}\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"common/int.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "(int32) *data"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"requested character too large\"))"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"requested character too large\""
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_encoding_max_length",
          "args": [
            "encoding"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "pg_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1819-1825",
          "snippet": "int\npg_encoding_max_length(int encoding)\n{\n\tAssert(PG_VALID_ENCODING(encoding));\n\n\treturn pg_wchar_table[encoding].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_encoding_max_length(int encoding)\n{\n\tAssert(PG_VALID_ENCODING(encoding));\n\n\treturn pg_wchar_table[encoding].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "result"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "(data[i] & 0xC0) == 0x80"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "tbytes > 0"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "*data > 0xC0"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "string"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "0"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "string"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDatabaseEncoding",
          "args": [],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "GetDatabaseEncodingName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1009-1013",
          "snippet": "const char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nconst char *\nGetDatabaseEncodingName(void)\n{\n\treturn DatabaseEncoding->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nDatum\nascii(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string = PG_GETARG_TEXT_PP(0);\n\tint\t\t\tencoding = GetDatabaseEncoding();\n\tunsigned char *data;\n\n\tif (VARSIZE_ANY_EXHDR(string) <= 0)\n\t\tPG_RETURN_INT32(0);\n\n\tdata = (unsigned char *) VARDATA_ANY(string);\n\n\tif (encoding == PG_UTF8 && *data > 127)\n\t{\n\t\t/* return the code point for Unicode */\n\n\t\tint\t\t\tresult = 0,\n\t\t\t\t\ttbytes = 0,\n\t\t\t\t\ti;\n\n\t\tif (*data >= 0xF0)\n\t\t{\n\t\t\tresult = *data & 0x07;\n\t\t\ttbytes = 3;\n\t\t}\n\t\telse if (*data >= 0xE0)\n\t\t{\n\t\t\tresult = *data & 0x0F;\n\t\t\ttbytes = 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tAssert(*data > 0xC0);\n\t\t\tresult = *data & 0x1f;\n\t\t\ttbytes = 1;\n\t\t}\n\n\t\tAssert(tbytes > 0);\n\n\t\tfor (i = 1; i <= tbytes; i++)\n\t\t{\n\t\t\tAssert((data[i] & 0xC0) == 0x80);\n\t\t\tresult = (result << 6) + (data[i] & 0x3f);\n\t\t}\n\n\t\tPG_RETURN_INT32(result);\n\t}\n\telse\n\t{\n\t\tif (pg_encoding_max_length(encoding) > 1 && *data > 127)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"requested character too large\")));\n\n\n\t\tPG_RETURN_INT32((int32) *data);\n\t}\n}"
  },
  {
    "function_name": "translate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
    "lines": "718-820",
    "snippet": "Datum\ntranslate(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string = PG_GETARG_TEXT_PP(0);\n\ttext\t   *from = PG_GETARG_TEXT_PP(1);\n\ttext\t   *to = PG_GETARG_TEXT_PP(2);\n\ttext\t   *result;\n\tchar\t   *from_ptr,\n\t\t\t   *to_ptr;\n\tchar\t   *source,\n\t\t\t   *target;\n\tint\t\t\tm,\n\t\t\t\tfromlen,\n\t\t\t\ttolen,\n\t\t\t\tretlen,\n\t\t\t\ti;\n\tint\t\t\tworst_len;\n\tint\t\t\tlen;\n\tint\t\t\tsource_len;\n\tint\t\t\tfrom_index;\n\n\tm = VARSIZE_ANY_EXHDR(string);\n\tif (m <= 0)\n\t\tPG_RETURN_TEXT_P(string);\n\tsource = VARDATA_ANY(string);\n\n\tfromlen = VARSIZE_ANY_EXHDR(from);\n\tfrom_ptr = VARDATA_ANY(from);\n\ttolen = VARSIZE_ANY_EXHDR(to);\n\tto_ptr = VARDATA_ANY(to);\n\n\t/*\n\t * The worst-case expansion is to substitute a max-length character for a\n\t * single-byte character at each position of the string.\n\t */\n\tworst_len = pg_database_encoding_max_length() * m;\n\n\t/* check for integer overflow */\n\tif (worst_len / pg_database_encoding_max_length() != m)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"requested length too large\")));\n\n\tresult = (text *) palloc(worst_len + VARHDRSZ);\n\ttarget = VARDATA(result);\n\tretlen = 0;\n\n\twhile (m > 0)\n\t{\n\t\tsource_len = pg_mblen(source);\n\t\tfrom_index = 0;\n\n\t\tfor (i = 0; i < fromlen; i += len)\n\t\t{\n\t\t\tlen = pg_mblen(&from_ptr[i]);\n\t\t\tif (len == source_len &&\n\t\t\t\tmemcmp(source, &from_ptr[i], len) == 0)\n\t\t\t\tbreak;\n\n\t\t\tfrom_index++;\n\t\t}\n\t\tif (i < fromlen)\n\t\t{\n\t\t\t/* substitute */\n\t\t\tchar\t   *p = to_ptr;\n\n\t\t\tfor (i = 0; i < from_index; i++)\n\t\t\t{\n\t\t\t\tp += pg_mblen(p);\n\t\t\t\tif (p >= (to_ptr + tolen))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p < (to_ptr + tolen))\n\t\t\t{\n\t\t\t\tlen = pg_mblen(p);\n\t\t\t\tmemcpy(target, p, len);\n\t\t\t\ttarget += len;\n\t\t\t\tretlen += len;\n\t\t\t}\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* no match, so copy */\n\t\t\tmemcpy(target, source, source_len);\n\t\t\ttarget += source_len;\n\t\t\tretlen += source_len;\n\t\t}\n\n\t\tsource += source_len;\n\t\tm -= source_len;\n\t}\n\n\tSET_VARSIZE(result, retlen + VARHDRSZ);\n\n\t/*\n\t * The function result is probably much bigger than needed, if we're using\n\t * a multibyte encoding, but it's not worth reallocating it; the result\n\t * probably won't live long anyway.\n\t */\n\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"common/int.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "result",
            "retlen + VARHDRSZ"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "target",
            "source",
            "source_len"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "target",
            "p",
            "len"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "p"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "source",
            "&from_ptr[i]",
            "len"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "result"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "worst_len + VARHDRSZ"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"requested length too large\"))"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"requested length too large\""
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "to"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "to"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "from"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "from"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "string"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "string"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "string"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "2"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nDatum\ntranslate(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string = PG_GETARG_TEXT_PP(0);\n\ttext\t   *from = PG_GETARG_TEXT_PP(1);\n\ttext\t   *to = PG_GETARG_TEXT_PP(2);\n\ttext\t   *result;\n\tchar\t   *from_ptr,\n\t\t\t   *to_ptr;\n\tchar\t   *source,\n\t\t\t   *target;\n\tint\t\t\tm,\n\t\t\t\tfromlen,\n\t\t\t\ttolen,\n\t\t\t\tretlen,\n\t\t\t\ti;\n\tint\t\t\tworst_len;\n\tint\t\t\tlen;\n\tint\t\t\tsource_len;\n\tint\t\t\tfrom_index;\n\n\tm = VARSIZE_ANY_EXHDR(string);\n\tif (m <= 0)\n\t\tPG_RETURN_TEXT_P(string);\n\tsource = VARDATA_ANY(string);\n\n\tfromlen = VARSIZE_ANY_EXHDR(from);\n\tfrom_ptr = VARDATA_ANY(from);\n\ttolen = VARSIZE_ANY_EXHDR(to);\n\tto_ptr = VARDATA_ANY(to);\n\n\t/*\n\t * The worst-case expansion is to substitute a max-length character for a\n\t * single-byte character at each position of the string.\n\t */\n\tworst_len = pg_database_encoding_max_length() * m;\n\n\t/* check for integer overflow */\n\tif (worst_len / pg_database_encoding_max_length() != m)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"requested length too large\")));\n\n\tresult = (text *) palloc(worst_len + VARHDRSZ);\n\ttarget = VARDATA(result);\n\tretlen = 0;\n\n\twhile (m > 0)\n\t{\n\t\tsource_len = pg_mblen(source);\n\t\tfrom_index = 0;\n\n\t\tfor (i = 0; i < fromlen; i += len)\n\t\t{\n\t\t\tlen = pg_mblen(&from_ptr[i]);\n\t\t\tif (len == source_len &&\n\t\t\t\tmemcmp(source, &from_ptr[i], len) == 0)\n\t\t\t\tbreak;\n\n\t\t\tfrom_index++;\n\t\t}\n\t\tif (i < fromlen)\n\t\t{\n\t\t\t/* substitute */\n\t\t\tchar\t   *p = to_ptr;\n\n\t\t\tfor (i = 0; i < from_index; i++)\n\t\t\t{\n\t\t\t\tp += pg_mblen(p);\n\t\t\t\tif (p >= (to_ptr + tolen))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p < (to_ptr + tolen))\n\t\t\t{\n\t\t\t\tlen = pg_mblen(p);\n\t\t\t\tmemcpy(target, p, len);\n\t\t\t\ttarget += len;\n\t\t\t\tretlen += len;\n\t\t\t}\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* no match, so copy */\n\t\t\tmemcpy(target, source, source_len);\n\t\t\ttarget += source_len;\n\t\t\tretlen += source_len;\n\t\t}\n\n\t\tsource += source_len;\n\t\tm -= source_len;\n\t}\n\n\tSET_VARSIZE(result, retlen + VARHDRSZ);\n\n\t/*\n\t * The function result is probably much bigger than needed, if we're using\n\t * a multibyte encoding, but it's not worth reallocating it; the result\n\t * probably won't live long anyway.\n\t */\n\n\tPG_RETURN_TEXT_P(result);\n}"
  },
  {
    "function_name": "rtrim1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
    "lines": "687-698",
    "snippet": "Datum\nrtrim1(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string = PG_GETARG_TEXT_PP(0);\n\ttext\t   *ret;\n\n\tret = dotrim(VARDATA_ANY(string), VARSIZE_ANY_EXHDR(string),\n\t\t\t\t \" \", 1,\n\t\t\t\t false, true);\n\n\tPG_RETURN_TEXT_P(ret);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"common/int.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "ret"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dotrim",
          "args": [
            "VARDATA_ANY(string)",
            "VARSIZE_ANY_EXHDR(string)",
            "\" \"",
            "1",
            "false",
            "true"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "dotrim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
          "lines": "371-522",
          "snippet": "static text *\ndotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim)\n{\n\tint\t\t\ti;\n\n\t/* Nothing to do if either string or set is empty */\n\tif (stringlen > 0 && setlen > 0)\n\t{\n\t\tif (pg_database_encoding_max_length() > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * In the multibyte-encoding case, build arrays of pointers to\n\t\t\t * character starts, so that we can avoid inefficient checks in\n\t\t\t * the inner loops.\n\t\t\t */\n\t\t\tconst char **stringchars;\n\t\t\tconst char **setchars;\n\t\t\tint\t\t   *stringmblen;\n\t\t\tint\t\t   *setmblen;\n\t\t\tint\t\t\tstringnchars;\n\t\t\tint\t\t\tsetnchars;\n\t\t\tint\t\t\tresultndx;\n\t\t\tint\t\t\tresultnchars;\n\t\t\tconst char *p;\n\t\t\tint\t\t\tlen;\n\t\t\tint\t\t\tmblen;\n\t\t\tconst char *str_pos;\n\t\t\tint\t\t\tstr_len;\n\n\t\t\tstringchars = (const char **) palloc(stringlen * sizeof(char *));\n\t\t\tstringmblen = (int *) palloc(stringlen * sizeof(int));\n\t\t\tstringnchars = 0;\n\t\t\tp = string;\n\t\t\tlen = stringlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tstringchars[stringnchars] = p;\n\t\t\t\tstringmblen[stringnchars] = mblen = pg_mblen(p);\n\t\t\t\tstringnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tsetchars = (const char **) palloc(setlen * sizeof(char *));\n\t\t\tsetmblen = (int *) palloc(setlen * sizeof(int));\n\t\t\tsetnchars = 0;\n\t\t\tp = set;\n\t\t\tlen = setlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tsetchars[setnchars] = p;\n\t\t\t\tsetmblen[setnchars] = mblen = pg_mblen(p);\n\t\t\t\tsetnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tresultndx = 0;\t\t/* index in stringchars[] */\n\t\t\tresultnchars = stringnchars;\n\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx];\n\t\t\t\t\tstr_len = stringmblen[resultndx];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring += str_len;\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultndx++;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx + resultnchars - 1];\n\t\t\t\t\tstr_len = stringmblen[resultndx + resultnchars - 1];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpfree(stringchars);\n\t\t\tpfree(stringmblen);\n\t\t\tpfree(setchars);\n\t\t\tpfree(setmblen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * In the single-byte-encoding case, we don't need such overhead.\n\t\t\t */\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = *string;\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring++;\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = string[stringlen - 1];\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Return selected portion of string */\n\treturn cstring_to_text_with_len(string, stringlen);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"common/int.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static text *dotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nstatic text *dotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim);\n\nstatic text *\ndotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim)\n{\n\tint\t\t\ti;\n\n\t/* Nothing to do if either string or set is empty */\n\tif (stringlen > 0 && setlen > 0)\n\t{\n\t\tif (pg_database_encoding_max_length() > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * In the multibyte-encoding case, build arrays of pointers to\n\t\t\t * character starts, so that we can avoid inefficient checks in\n\t\t\t * the inner loops.\n\t\t\t */\n\t\t\tconst char **stringchars;\n\t\t\tconst char **setchars;\n\t\t\tint\t\t   *stringmblen;\n\t\t\tint\t\t   *setmblen;\n\t\t\tint\t\t\tstringnchars;\n\t\t\tint\t\t\tsetnchars;\n\t\t\tint\t\t\tresultndx;\n\t\t\tint\t\t\tresultnchars;\n\t\t\tconst char *p;\n\t\t\tint\t\t\tlen;\n\t\t\tint\t\t\tmblen;\n\t\t\tconst char *str_pos;\n\t\t\tint\t\t\tstr_len;\n\n\t\t\tstringchars = (const char **) palloc(stringlen * sizeof(char *));\n\t\t\tstringmblen = (int *) palloc(stringlen * sizeof(int));\n\t\t\tstringnchars = 0;\n\t\t\tp = string;\n\t\t\tlen = stringlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tstringchars[stringnchars] = p;\n\t\t\t\tstringmblen[stringnchars] = mblen = pg_mblen(p);\n\t\t\t\tstringnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tsetchars = (const char **) palloc(setlen * sizeof(char *));\n\t\t\tsetmblen = (int *) palloc(setlen * sizeof(int));\n\t\t\tsetnchars = 0;\n\t\t\tp = set;\n\t\t\tlen = setlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tsetchars[setnchars] = p;\n\t\t\t\tsetmblen[setnchars] = mblen = pg_mblen(p);\n\t\t\t\tsetnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tresultndx = 0;\t\t/* index in stringchars[] */\n\t\t\tresultnchars = stringnchars;\n\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx];\n\t\t\t\t\tstr_len = stringmblen[resultndx];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring += str_len;\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultndx++;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx + resultnchars - 1];\n\t\t\t\t\tstr_len = stringmblen[resultndx + resultnchars - 1];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpfree(stringchars);\n\t\t\tpfree(stringmblen);\n\t\t\tpfree(setchars);\n\t\t\tpfree(setmblen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * In the single-byte-encoding case, we don't need such overhead.\n\t\t\t */\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = *string;\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring++;\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = string[stringlen - 1];\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Return selected portion of string */\n\treturn cstring_to_text_with_len(string, stringlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "string"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "string"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nDatum\nrtrim1(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string = PG_GETARG_TEXT_PP(0);\n\ttext\t   *ret;\n\n\tret = dotrim(VARDATA_ANY(string), VARSIZE_ANY_EXHDR(string),\n\t\t\t\t \" \", 1,\n\t\t\t\t false, true);\n\n\tPG_RETURN_TEXT_P(ret);\n}"
  },
  {
    "function_name": "rtrim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
    "lines": "667-679",
    "snippet": "Datum\nrtrim(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string = PG_GETARG_TEXT_PP(0);\n\ttext\t   *set = PG_GETARG_TEXT_PP(1);\n\ttext\t   *ret;\n\n\tret = dotrim(VARDATA_ANY(string), VARSIZE_ANY_EXHDR(string),\n\t\t\t\t VARDATA_ANY(set), VARSIZE_ANY_EXHDR(set),\n\t\t\t\t false, true);\n\n\tPG_RETURN_TEXT_P(ret);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"common/int.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "ret"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dotrim",
          "args": [
            "VARDATA_ANY(string)",
            "VARSIZE_ANY_EXHDR(string)",
            "VARDATA_ANY(set)",
            "VARSIZE_ANY_EXHDR(set)",
            "false",
            "true"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "dotrim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
          "lines": "371-522",
          "snippet": "static text *\ndotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim)\n{\n\tint\t\t\ti;\n\n\t/* Nothing to do if either string or set is empty */\n\tif (stringlen > 0 && setlen > 0)\n\t{\n\t\tif (pg_database_encoding_max_length() > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * In the multibyte-encoding case, build arrays of pointers to\n\t\t\t * character starts, so that we can avoid inefficient checks in\n\t\t\t * the inner loops.\n\t\t\t */\n\t\t\tconst char **stringchars;\n\t\t\tconst char **setchars;\n\t\t\tint\t\t   *stringmblen;\n\t\t\tint\t\t   *setmblen;\n\t\t\tint\t\t\tstringnchars;\n\t\t\tint\t\t\tsetnchars;\n\t\t\tint\t\t\tresultndx;\n\t\t\tint\t\t\tresultnchars;\n\t\t\tconst char *p;\n\t\t\tint\t\t\tlen;\n\t\t\tint\t\t\tmblen;\n\t\t\tconst char *str_pos;\n\t\t\tint\t\t\tstr_len;\n\n\t\t\tstringchars = (const char **) palloc(stringlen * sizeof(char *));\n\t\t\tstringmblen = (int *) palloc(stringlen * sizeof(int));\n\t\t\tstringnchars = 0;\n\t\t\tp = string;\n\t\t\tlen = stringlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tstringchars[stringnchars] = p;\n\t\t\t\tstringmblen[stringnchars] = mblen = pg_mblen(p);\n\t\t\t\tstringnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tsetchars = (const char **) palloc(setlen * sizeof(char *));\n\t\t\tsetmblen = (int *) palloc(setlen * sizeof(int));\n\t\t\tsetnchars = 0;\n\t\t\tp = set;\n\t\t\tlen = setlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tsetchars[setnchars] = p;\n\t\t\t\tsetmblen[setnchars] = mblen = pg_mblen(p);\n\t\t\t\tsetnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tresultndx = 0;\t\t/* index in stringchars[] */\n\t\t\tresultnchars = stringnchars;\n\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx];\n\t\t\t\t\tstr_len = stringmblen[resultndx];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring += str_len;\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultndx++;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx + resultnchars - 1];\n\t\t\t\t\tstr_len = stringmblen[resultndx + resultnchars - 1];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpfree(stringchars);\n\t\t\tpfree(stringmblen);\n\t\t\tpfree(setchars);\n\t\t\tpfree(setmblen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * In the single-byte-encoding case, we don't need such overhead.\n\t\t\t */\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = *string;\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring++;\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = string[stringlen - 1];\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Return selected portion of string */\n\treturn cstring_to_text_with_len(string, stringlen);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"common/int.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static text *dotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nstatic text *dotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim);\n\nstatic text *\ndotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim)\n{\n\tint\t\t\ti;\n\n\t/* Nothing to do if either string or set is empty */\n\tif (stringlen > 0 && setlen > 0)\n\t{\n\t\tif (pg_database_encoding_max_length() > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * In the multibyte-encoding case, build arrays of pointers to\n\t\t\t * character starts, so that we can avoid inefficient checks in\n\t\t\t * the inner loops.\n\t\t\t */\n\t\t\tconst char **stringchars;\n\t\t\tconst char **setchars;\n\t\t\tint\t\t   *stringmblen;\n\t\t\tint\t\t   *setmblen;\n\t\t\tint\t\t\tstringnchars;\n\t\t\tint\t\t\tsetnchars;\n\t\t\tint\t\t\tresultndx;\n\t\t\tint\t\t\tresultnchars;\n\t\t\tconst char *p;\n\t\t\tint\t\t\tlen;\n\t\t\tint\t\t\tmblen;\n\t\t\tconst char *str_pos;\n\t\t\tint\t\t\tstr_len;\n\n\t\t\tstringchars = (const char **) palloc(stringlen * sizeof(char *));\n\t\t\tstringmblen = (int *) palloc(stringlen * sizeof(int));\n\t\t\tstringnchars = 0;\n\t\t\tp = string;\n\t\t\tlen = stringlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tstringchars[stringnchars] = p;\n\t\t\t\tstringmblen[stringnchars] = mblen = pg_mblen(p);\n\t\t\t\tstringnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tsetchars = (const char **) palloc(setlen * sizeof(char *));\n\t\t\tsetmblen = (int *) palloc(setlen * sizeof(int));\n\t\t\tsetnchars = 0;\n\t\t\tp = set;\n\t\t\tlen = setlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tsetchars[setnchars] = p;\n\t\t\t\tsetmblen[setnchars] = mblen = pg_mblen(p);\n\t\t\t\tsetnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tresultndx = 0;\t\t/* index in stringchars[] */\n\t\t\tresultnchars = stringnchars;\n\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx];\n\t\t\t\t\tstr_len = stringmblen[resultndx];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring += str_len;\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultndx++;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx + resultnchars - 1];\n\t\t\t\t\tstr_len = stringmblen[resultndx + resultnchars - 1];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpfree(stringchars);\n\t\t\tpfree(stringmblen);\n\t\t\tpfree(setchars);\n\t\t\tpfree(setmblen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * In the single-byte-encoding case, we don't need such overhead.\n\t\t\t */\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = *string;\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring++;\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = string[stringlen - 1];\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Return selected portion of string */\n\treturn cstring_to_text_with_len(string, stringlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "set"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "set"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "string"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "string"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nDatum\nrtrim(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string = PG_GETARG_TEXT_PP(0);\n\ttext\t   *set = PG_GETARG_TEXT_PP(1);\n\ttext\t   *ret;\n\n\tret = dotrim(VARDATA_ANY(string), VARSIZE_ANY_EXHDR(string),\n\t\t\t\t VARDATA_ANY(set), VARSIZE_ANY_EXHDR(set),\n\t\t\t\t false, true);\n\n\tPG_RETURN_TEXT_P(ret);\n}"
  },
  {
    "function_name": "ltrim1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
    "lines": "639-650",
    "snippet": "Datum\nltrim1(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string = PG_GETARG_TEXT_PP(0);\n\ttext\t   *ret;\n\n\tret = dotrim(VARDATA_ANY(string), VARSIZE_ANY_EXHDR(string),\n\t\t\t\t \" \", 1,\n\t\t\t\t true, false);\n\n\tPG_RETURN_TEXT_P(ret);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"common/int.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "ret"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dotrim",
          "args": [
            "VARDATA_ANY(string)",
            "VARSIZE_ANY_EXHDR(string)",
            "\" \"",
            "1",
            "true",
            "false"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "dotrim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
          "lines": "371-522",
          "snippet": "static text *\ndotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim)\n{\n\tint\t\t\ti;\n\n\t/* Nothing to do if either string or set is empty */\n\tif (stringlen > 0 && setlen > 0)\n\t{\n\t\tif (pg_database_encoding_max_length() > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * In the multibyte-encoding case, build arrays of pointers to\n\t\t\t * character starts, so that we can avoid inefficient checks in\n\t\t\t * the inner loops.\n\t\t\t */\n\t\t\tconst char **stringchars;\n\t\t\tconst char **setchars;\n\t\t\tint\t\t   *stringmblen;\n\t\t\tint\t\t   *setmblen;\n\t\t\tint\t\t\tstringnchars;\n\t\t\tint\t\t\tsetnchars;\n\t\t\tint\t\t\tresultndx;\n\t\t\tint\t\t\tresultnchars;\n\t\t\tconst char *p;\n\t\t\tint\t\t\tlen;\n\t\t\tint\t\t\tmblen;\n\t\t\tconst char *str_pos;\n\t\t\tint\t\t\tstr_len;\n\n\t\t\tstringchars = (const char **) palloc(stringlen * sizeof(char *));\n\t\t\tstringmblen = (int *) palloc(stringlen * sizeof(int));\n\t\t\tstringnchars = 0;\n\t\t\tp = string;\n\t\t\tlen = stringlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tstringchars[stringnchars] = p;\n\t\t\t\tstringmblen[stringnchars] = mblen = pg_mblen(p);\n\t\t\t\tstringnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tsetchars = (const char **) palloc(setlen * sizeof(char *));\n\t\t\tsetmblen = (int *) palloc(setlen * sizeof(int));\n\t\t\tsetnchars = 0;\n\t\t\tp = set;\n\t\t\tlen = setlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tsetchars[setnchars] = p;\n\t\t\t\tsetmblen[setnchars] = mblen = pg_mblen(p);\n\t\t\t\tsetnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tresultndx = 0;\t\t/* index in stringchars[] */\n\t\t\tresultnchars = stringnchars;\n\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx];\n\t\t\t\t\tstr_len = stringmblen[resultndx];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring += str_len;\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultndx++;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx + resultnchars - 1];\n\t\t\t\t\tstr_len = stringmblen[resultndx + resultnchars - 1];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpfree(stringchars);\n\t\t\tpfree(stringmblen);\n\t\t\tpfree(setchars);\n\t\t\tpfree(setmblen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * In the single-byte-encoding case, we don't need such overhead.\n\t\t\t */\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = *string;\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring++;\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = string[stringlen - 1];\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Return selected portion of string */\n\treturn cstring_to_text_with_len(string, stringlen);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"common/int.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static text *dotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nstatic text *dotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim);\n\nstatic text *\ndotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim)\n{\n\tint\t\t\ti;\n\n\t/* Nothing to do if either string or set is empty */\n\tif (stringlen > 0 && setlen > 0)\n\t{\n\t\tif (pg_database_encoding_max_length() > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * In the multibyte-encoding case, build arrays of pointers to\n\t\t\t * character starts, so that we can avoid inefficient checks in\n\t\t\t * the inner loops.\n\t\t\t */\n\t\t\tconst char **stringchars;\n\t\t\tconst char **setchars;\n\t\t\tint\t\t   *stringmblen;\n\t\t\tint\t\t   *setmblen;\n\t\t\tint\t\t\tstringnchars;\n\t\t\tint\t\t\tsetnchars;\n\t\t\tint\t\t\tresultndx;\n\t\t\tint\t\t\tresultnchars;\n\t\t\tconst char *p;\n\t\t\tint\t\t\tlen;\n\t\t\tint\t\t\tmblen;\n\t\t\tconst char *str_pos;\n\t\t\tint\t\t\tstr_len;\n\n\t\t\tstringchars = (const char **) palloc(stringlen * sizeof(char *));\n\t\t\tstringmblen = (int *) palloc(stringlen * sizeof(int));\n\t\t\tstringnchars = 0;\n\t\t\tp = string;\n\t\t\tlen = stringlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tstringchars[stringnchars] = p;\n\t\t\t\tstringmblen[stringnchars] = mblen = pg_mblen(p);\n\t\t\t\tstringnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tsetchars = (const char **) palloc(setlen * sizeof(char *));\n\t\t\tsetmblen = (int *) palloc(setlen * sizeof(int));\n\t\t\tsetnchars = 0;\n\t\t\tp = set;\n\t\t\tlen = setlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tsetchars[setnchars] = p;\n\t\t\t\tsetmblen[setnchars] = mblen = pg_mblen(p);\n\t\t\t\tsetnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tresultndx = 0;\t\t/* index in stringchars[] */\n\t\t\tresultnchars = stringnchars;\n\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx];\n\t\t\t\t\tstr_len = stringmblen[resultndx];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring += str_len;\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultndx++;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx + resultnchars - 1];\n\t\t\t\t\tstr_len = stringmblen[resultndx + resultnchars - 1];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpfree(stringchars);\n\t\t\tpfree(stringmblen);\n\t\t\tpfree(setchars);\n\t\t\tpfree(setmblen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * In the single-byte-encoding case, we don't need such overhead.\n\t\t\t */\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = *string;\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring++;\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = string[stringlen - 1];\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Return selected portion of string */\n\treturn cstring_to_text_with_len(string, stringlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "string"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "string"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nDatum\nltrim1(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string = PG_GETARG_TEXT_PP(0);\n\ttext\t   *ret;\n\n\tret = dotrim(VARDATA_ANY(string), VARSIZE_ANY_EXHDR(string),\n\t\t\t\t \" \", 1,\n\t\t\t\t true, false);\n\n\tPG_RETURN_TEXT_P(ret);\n}"
  },
  {
    "function_name": "ltrim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
    "lines": "619-631",
    "snippet": "Datum\nltrim(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string = PG_GETARG_TEXT_PP(0);\n\ttext\t   *set = PG_GETARG_TEXT_PP(1);\n\ttext\t   *ret;\n\n\tret = dotrim(VARDATA_ANY(string), VARSIZE_ANY_EXHDR(string),\n\t\t\t\t VARDATA_ANY(set), VARSIZE_ANY_EXHDR(set),\n\t\t\t\t true, false);\n\n\tPG_RETURN_TEXT_P(ret);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"common/int.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "ret"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dotrim",
          "args": [
            "VARDATA_ANY(string)",
            "VARSIZE_ANY_EXHDR(string)",
            "VARDATA_ANY(set)",
            "VARSIZE_ANY_EXHDR(set)",
            "true",
            "false"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "dotrim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
          "lines": "371-522",
          "snippet": "static text *\ndotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim)\n{\n\tint\t\t\ti;\n\n\t/* Nothing to do if either string or set is empty */\n\tif (stringlen > 0 && setlen > 0)\n\t{\n\t\tif (pg_database_encoding_max_length() > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * In the multibyte-encoding case, build arrays of pointers to\n\t\t\t * character starts, so that we can avoid inefficient checks in\n\t\t\t * the inner loops.\n\t\t\t */\n\t\t\tconst char **stringchars;\n\t\t\tconst char **setchars;\n\t\t\tint\t\t   *stringmblen;\n\t\t\tint\t\t   *setmblen;\n\t\t\tint\t\t\tstringnchars;\n\t\t\tint\t\t\tsetnchars;\n\t\t\tint\t\t\tresultndx;\n\t\t\tint\t\t\tresultnchars;\n\t\t\tconst char *p;\n\t\t\tint\t\t\tlen;\n\t\t\tint\t\t\tmblen;\n\t\t\tconst char *str_pos;\n\t\t\tint\t\t\tstr_len;\n\n\t\t\tstringchars = (const char **) palloc(stringlen * sizeof(char *));\n\t\t\tstringmblen = (int *) palloc(stringlen * sizeof(int));\n\t\t\tstringnchars = 0;\n\t\t\tp = string;\n\t\t\tlen = stringlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tstringchars[stringnchars] = p;\n\t\t\t\tstringmblen[stringnchars] = mblen = pg_mblen(p);\n\t\t\t\tstringnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tsetchars = (const char **) palloc(setlen * sizeof(char *));\n\t\t\tsetmblen = (int *) palloc(setlen * sizeof(int));\n\t\t\tsetnchars = 0;\n\t\t\tp = set;\n\t\t\tlen = setlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tsetchars[setnchars] = p;\n\t\t\t\tsetmblen[setnchars] = mblen = pg_mblen(p);\n\t\t\t\tsetnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tresultndx = 0;\t\t/* index in stringchars[] */\n\t\t\tresultnchars = stringnchars;\n\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx];\n\t\t\t\t\tstr_len = stringmblen[resultndx];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring += str_len;\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultndx++;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx + resultnchars - 1];\n\t\t\t\t\tstr_len = stringmblen[resultndx + resultnchars - 1];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpfree(stringchars);\n\t\t\tpfree(stringmblen);\n\t\t\tpfree(setchars);\n\t\t\tpfree(setmblen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * In the single-byte-encoding case, we don't need such overhead.\n\t\t\t */\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = *string;\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring++;\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = string[stringlen - 1];\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Return selected portion of string */\n\treturn cstring_to_text_with_len(string, stringlen);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"common/int.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static text *dotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nstatic text *dotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim);\n\nstatic text *\ndotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim)\n{\n\tint\t\t\ti;\n\n\t/* Nothing to do if either string or set is empty */\n\tif (stringlen > 0 && setlen > 0)\n\t{\n\t\tif (pg_database_encoding_max_length() > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * In the multibyte-encoding case, build arrays of pointers to\n\t\t\t * character starts, so that we can avoid inefficient checks in\n\t\t\t * the inner loops.\n\t\t\t */\n\t\t\tconst char **stringchars;\n\t\t\tconst char **setchars;\n\t\t\tint\t\t   *stringmblen;\n\t\t\tint\t\t   *setmblen;\n\t\t\tint\t\t\tstringnchars;\n\t\t\tint\t\t\tsetnchars;\n\t\t\tint\t\t\tresultndx;\n\t\t\tint\t\t\tresultnchars;\n\t\t\tconst char *p;\n\t\t\tint\t\t\tlen;\n\t\t\tint\t\t\tmblen;\n\t\t\tconst char *str_pos;\n\t\t\tint\t\t\tstr_len;\n\n\t\t\tstringchars = (const char **) palloc(stringlen * sizeof(char *));\n\t\t\tstringmblen = (int *) palloc(stringlen * sizeof(int));\n\t\t\tstringnchars = 0;\n\t\t\tp = string;\n\t\t\tlen = stringlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tstringchars[stringnchars] = p;\n\t\t\t\tstringmblen[stringnchars] = mblen = pg_mblen(p);\n\t\t\t\tstringnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tsetchars = (const char **) palloc(setlen * sizeof(char *));\n\t\t\tsetmblen = (int *) palloc(setlen * sizeof(int));\n\t\t\tsetnchars = 0;\n\t\t\tp = set;\n\t\t\tlen = setlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tsetchars[setnchars] = p;\n\t\t\t\tsetmblen[setnchars] = mblen = pg_mblen(p);\n\t\t\t\tsetnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tresultndx = 0;\t\t/* index in stringchars[] */\n\t\t\tresultnchars = stringnchars;\n\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx];\n\t\t\t\t\tstr_len = stringmblen[resultndx];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring += str_len;\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultndx++;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx + resultnchars - 1];\n\t\t\t\t\tstr_len = stringmblen[resultndx + resultnchars - 1];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpfree(stringchars);\n\t\t\tpfree(stringmblen);\n\t\t\tpfree(setchars);\n\t\t\tpfree(setmblen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * In the single-byte-encoding case, we don't need such overhead.\n\t\t\t */\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = *string;\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring++;\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = string[stringlen - 1];\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Return selected portion of string */\n\treturn cstring_to_text_with_len(string, stringlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "set"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "set"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "string"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "string"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nDatum\nltrim(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string = PG_GETARG_TEXT_PP(0);\n\ttext\t   *set = PG_GETARG_TEXT_PP(1);\n\ttext\t   *ret;\n\n\tret = dotrim(VARDATA_ANY(string), VARSIZE_ANY_EXHDR(string),\n\t\t\t\t VARDATA_ANY(set), VARSIZE_ANY_EXHDR(set),\n\t\t\t\t true, false);\n\n\tPG_RETURN_TEXT_P(ret);\n}"
  },
  {
    "function_name": "byteatrim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
    "lines": "540-602",
    "snippet": "Datum\nbyteatrim(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *string = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *set = PG_GETARG_BYTEA_PP(1);\n\tbytea\t   *ret;\n\tchar\t   *ptr,\n\t\t\t   *end,\n\t\t\t   *ptr2,\n\t\t\t   *ptr2start,\n\t\t\t   *end2;\n\tint\t\t\tm,\n\t\t\t\tstringlen,\n\t\t\t\tsetlen;\n\n\tstringlen = VARSIZE_ANY_EXHDR(string);\n\tsetlen = VARSIZE_ANY_EXHDR(set);\n\n\tif (stringlen <= 0 || setlen <= 0)\n\t\tPG_RETURN_BYTEA_P(string);\n\n\tm = stringlen;\n\tptr = VARDATA_ANY(string);\n\tend = ptr + stringlen - 1;\n\tptr2start = VARDATA_ANY(set);\n\tend2 = ptr2start + setlen - 1;\n\n\twhile (m > 0)\n\t{\n\t\tptr2 = ptr2start;\n\t\twhile (ptr2 <= end2)\n\t\t{\n\t\t\tif (*ptr == *ptr2)\n\t\t\t\tbreak;\n\t\t\t++ptr2;\n\t\t}\n\t\tif (ptr2 > end2)\n\t\t\tbreak;\n\t\tptr++;\n\t\tm--;\n\t}\n\n\twhile (m > 0)\n\t{\n\t\tptr2 = ptr2start;\n\t\twhile (ptr2 <= end2)\n\t\t{\n\t\t\tif (*end == *ptr2)\n\t\t\t\tbreak;\n\t\t\t++ptr2;\n\t\t}\n\t\tif (ptr2 > end2)\n\t\t\tbreak;\n\t\tend--;\n\t\tm--;\n\t}\n\n\tret = (bytea *) palloc(VARHDRSZ + m);\n\tSET_VARSIZE(ret, VARHDRSZ + m);\n\tmemcpy(VARDATA(ret), ptr, m);\n\n\tPG_RETURN_BYTEA_P(ret);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"common/int.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "ret"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "VARDATA(ret)",
            "ptr",
            "m"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "ret"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "ret",
            "VARHDRSZ + m"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "VARHDRSZ + m"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "set"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "string"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "string"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "set"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "string"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "1"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_BYTEA_PP",
          "args": [
            "0"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nDatum\nbyteatrim(PG_FUNCTION_ARGS)\n{\n\tbytea\t   *string = PG_GETARG_BYTEA_PP(0);\n\tbytea\t   *set = PG_GETARG_BYTEA_PP(1);\n\tbytea\t   *ret;\n\tchar\t   *ptr,\n\t\t\t   *end,\n\t\t\t   *ptr2,\n\t\t\t   *ptr2start,\n\t\t\t   *end2;\n\tint\t\t\tm,\n\t\t\t\tstringlen,\n\t\t\t\tsetlen;\n\n\tstringlen = VARSIZE_ANY_EXHDR(string);\n\tsetlen = VARSIZE_ANY_EXHDR(set);\n\n\tif (stringlen <= 0 || setlen <= 0)\n\t\tPG_RETURN_BYTEA_P(string);\n\n\tm = stringlen;\n\tptr = VARDATA_ANY(string);\n\tend = ptr + stringlen - 1;\n\tptr2start = VARDATA_ANY(set);\n\tend2 = ptr2start + setlen - 1;\n\n\twhile (m > 0)\n\t{\n\t\tptr2 = ptr2start;\n\t\twhile (ptr2 <= end2)\n\t\t{\n\t\t\tif (*ptr == *ptr2)\n\t\t\t\tbreak;\n\t\t\t++ptr2;\n\t\t}\n\t\tif (ptr2 > end2)\n\t\t\tbreak;\n\t\tptr++;\n\t\tm--;\n\t}\n\n\twhile (m > 0)\n\t{\n\t\tptr2 = ptr2start;\n\t\twhile (ptr2 <= end2)\n\t\t{\n\t\t\tif (*end == *ptr2)\n\t\t\t\tbreak;\n\t\t\t++ptr2;\n\t\t}\n\t\tif (ptr2 > end2)\n\t\t\tbreak;\n\t\tend--;\n\t\tm--;\n\t}\n\n\tret = (bytea *) palloc(VARHDRSZ + m);\n\tSET_VARSIZE(ret, VARHDRSZ + m);\n\tmemcpy(VARDATA(ret), ptr, m);\n\n\tPG_RETURN_BYTEA_P(ret);\n}"
  },
  {
    "function_name": "dotrim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
    "lines": "371-522",
    "snippet": "static text *\ndotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim)\n{\n\tint\t\t\ti;\n\n\t/* Nothing to do if either string or set is empty */\n\tif (stringlen > 0 && setlen > 0)\n\t{\n\t\tif (pg_database_encoding_max_length() > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * In the multibyte-encoding case, build arrays of pointers to\n\t\t\t * character starts, so that we can avoid inefficient checks in\n\t\t\t * the inner loops.\n\t\t\t */\n\t\t\tconst char **stringchars;\n\t\t\tconst char **setchars;\n\t\t\tint\t\t   *stringmblen;\n\t\t\tint\t\t   *setmblen;\n\t\t\tint\t\t\tstringnchars;\n\t\t\tint\t\t\tsetnchars;\n\t\t\tint\t\t\tresultndx;\n\t\t\tint\t\t\tresultnchars;\n\t\t\tconst char *p;\n\t\t\tint\t\t\tlen;\n\t\t\tint\t\t\tmblen;\n\t\t\tconst char *str_pos;\n\t\t\tint\t\t\tstr_len;\n\n\t\t\tstringchars = (const char **) palloc(stringlen * sizeof(char *));\n\t\t\tstringmblen = (int *) palloc(stringlen * sizeof(int));\n\t\t\tstringnchars = 0;\n\t\t\tp = string;\n\t\t\tlen = stringlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tstringchars[stringnchars] = p;\n\t\t\t\tstringmblen[stringnchars] = mblen = pg_mblen(p);\n\t\t\t\tstringnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tsetchars = (const char **) palloc(setlen * sizeof(char *));\n\t\t\tsetmblen = (int *) palloc(setlen * sizeof(int));\n\t\t\tsetnchars = 0;\n\t\t\tp = set;\n\t\t\tlen = setlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tsetchars[setnchars] = p;\n\t\t\t\tsetmblen[setnchars] = mblen = pg_mblen(p);\n\t\t\t\tsetnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tresultndx = 0;\t\t/* index in stringchars[] */\n\t\t\tresultnchars = stringnchars;\n\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx];\n\t\t\t\t\tstr_len = stringmblen[resultndx];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring += str_len;\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultndx++;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx + resultnchars - 1];\n\t\t\t\t\tstr_len = stringmblen[resultndx + resultnchars - 1];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpfree(stringchars);\n\t\t\tpfree(stringmblen);\n\t\t\tpfree(setchars);\n\t\t\tpfree(setmblen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * In the single-byte-encoding case, we don't need such overhead.\n\t\t\t */\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = *string;\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring++;\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = string[stringlen - 1];\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Return selected portion of string */\n\treturn cstring_to_text_with_len(string, stringlen);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"common/int.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static text *dotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "string",
            "stringlen"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "setmblen"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "str_pos",
            "setchars[i]",
            "str_len"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "str_pos",
            "setchars[i]",
            "str_len"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "p"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "setlen * sizeof(int)"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nstatic text *dotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim);\n\nstatic text *\ndotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim)\n{\n\tint\t\t\ti;\n\n\t/* Nothing to do if either string or set is empty */\n\tif (stringlen > 0 && setlen > 0)\n\t{\n\t\tif (pg_database_encoding_max_length() > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * In the multibyte-encoding case, build arrays of pointers to\n\t\t\t * character starts, so that we can avoid inefficient checks in\n\t\t\t * the inner loops.\n\t\t\t */\n\t\t\tconst char **stringchars;\n\t\t\tconst char **setchars;\n\t\t\tint\t\t   *stringmblen;\n\t\t\tint\t\t   *setmblen;\n\t\t\tint\t\t\tstringnchars;\n\t\t\tint\t\t\tsetnchars;\n\t\t\tint\t\t\tresultndx;\n\t\t\tint\t\t\tresultnchars;\n\t\t\tconst char *p;\n\t\t\tint\t\t\tlen;\n\t\t\tint\t\t\tmblen;\n\t\t\tconst char *str_pos;\n\t\t\tint\t\t\tstr_len;\n\n\t\t\tstringchars = (const char **) palloc(stringlen * sizeof(char *));\n\t\t\tstringmblen = (int *) palloc(stringlen * sizeof(int));\n\t\t\tstringnchars = 0;\n\t\t\tp = string;\n\t\t\tlen = stringlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tstringchars[stringnchars] = p;\n\t\t\t\tstringmblen[stringnchars] = mblen = pg_mblen(p);\n\t\t\t\tstringnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tsetchars = (const char **) palloc(setlen * sizeof(char *));\n\t\t\tsetmblen = (int *) palloc(setlen * sizeof(int));\n\t\t\tsetnchars = 0;\n\t\t\tp = set;\n\t\t\tlen = setlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tsetchars[setnchars] = p;\n\t\t\t\tsetmblen[setnchars] = mblen = pg_mblen(p);\n\t\t\t\tsetnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tresultndx = 0;\t\t/* index in stringchars[] */\n\t\t\tresultnchars = stringnchars;\n\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx];\n\t\t\t\t\tstr_len = stringmblen[resultndx];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring += str_len;\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultndx++;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx + resultnchars - 1];\n\t\t\t\t\tstr_len = stringmblen[resultndx + resultnchars - 1];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpfree(stringchars);\n\t\t\tpfree(stringmblen);\n\t\t\tpfree(setchars);\n\t\t\tpfree(setmblen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * In the single-byte-encoding case, we don't need such overhead.\n\t\t\t */\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = *string;\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring++;\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = string[stringlen - 1];\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Return selected portion of string */\n\treturn cstring_to_text_with_len(string, stringlen);\n}"
  },
  {
    "function_name": "btrim1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
    "lines": "355-366",
    "snippet": "Datum\nbtrim1(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string = PG_GETARG_TEXT_PP(0);\n\ttext\t   *ret;\n\n\tret = dotrim(VARDATA_ANY(string), VARSIZE_ANY_EXHDR(string),\n\t\t\t\t \" \", 1,\n\t\t\t\t true, true);\n\n\tPG_RETURN_TEXT_P(ret);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"common/int.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "ret"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dotrim",
          "args": [
            "VARDATA_ANY(string)",
            "VARSIZE_ANY_EXHDR(string)",
            "\" \"",
            "1",
            "true",
            "true"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "dotrim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
          "lines": "371-522",
          "snippet": "static text *\ndotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim)\n{\n\tint\t\t\ti;\n\n\t/* Nothing to do if either string or set is empty */\n\tif (stringlen > 0 && setlen > 0)\n\t{\n\t\tif (pg_database_encoding_max_length() > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * In the multibyte-encoding case, build arrays of pointers to\n\t\t\t * character starts, so that we can avoid inefficient checks in\n\t\t\t * the inner loops.\n\t\t\t */\n\t\t\tconst char **stringchars;\n\t\t\tconst char **setchars;\n\t\t\tint\t\t   *stringmblen;\n\t\t\tint\t\t   *setmblen;\n\t\t\tint\t\t\tstringnchars;\n\t\t\tint\t\t\tsetnchars;\n\t\t\tint\t\t\tresultndx;\n\t\t\tint\t\t\tresultnchars;\n\t\t\tconst char *p;\n\t\t\tint\t\t\tlen;\n\t\t\tint\t\t\tmblen;\n\t\t\tconst char *str_pos;\n\t\t\tint\t\t\tstr_len;\n\n\t\t\tstringchars = (const char **) palloc(stringlen * sizeof(char *));\n\t\t\tstringmblen = (int *) palloc(stringlen * sizeof(int));\n\t\t\tstringnchars = 0;\n\t\t\tp = string;\n\t\t\tlen = stringlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tstringchars[stringnchars] = p;\n\t\t\t\tstringmblen[stringnchars] = mblen = pg_mblen(p);\n\t\t\t\tstringnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tsetchars = (const char **) palloc(setlen * sizeof(char *));\n\t\t\tsetmblen = (int *) palloc(setlen * sizeof(int));\n\t\t\tsetnchars = 0;\n\t\t\tp = set;\n\t\t\tlen = setlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tsetchars[setnchars] = p;\n\t\t\t\tsetmblen[setnchars] = mblen = pg_mblen(p);\n\t\t\t\tsetnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tresultndx = 0;\t\t/* index in stringchars[] */\n\t\t\tresultnchars = stringnchars;\n\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx];\n\t\t\t\t\tstr_len = stringmblen[resultndx];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring += str_len;\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultndx++;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx + resultnchars - 1];\n\t\t\t\t\tstr_len = stringmblen[resultndx + resultnchars - 1];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpfree(stringchars);\n\t\t\tpfree(stringmblen);\n\t\t\tpfree(setchars);\n\t\t\tpfree(setmblen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * In the single-byte-encoding case, we don't need such overhead.\n\t\t\t */\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = *string;\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring++;\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = string[stringlen - 1];\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Return selected portion of string */\n\treturn cstring_to_text_with_len(string, stringlen);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"common/int.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static text *dotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nstatic text *dotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim);\n\nstatic text *\ndotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim)\n{\n\tint\t\t\ti;\n\n\t/* Nothing to do if either string or set is empty */\n\tif (stringlen > 0 && setlen > 0)\n\t{\n\t\tif (pg_database_encoding_max_length() > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * In the multibyte-encoding case, build arrays of pointers to\n\t\t\t * character starts, so that we can avoid inefficient checks in\n\t\t\t * the inner loops.\n\t\t\t */\n\t\t\tconst char **stringchars;\n\t\t\tconst char **setchars;\n\t\t\tint\t\t   *stringmblen;\n\t\t\tint\t\t   *setmblen;\n\t\t\tint\t\t\tstringnchars;\n\t\t\tint\t\t\tsetnchars;\n\t\t\tint\t\t\tresultndx;\n\t\t\tint\t\t\tresultnchars;\n\t\t\tconst char *p;\n\t\t\tint\t\t\tlen;\n\t\t\tint\t\t\tmblen;\n\t\t\tconst char *str_pos;\n\t\t\tint\t\t\tstr_len;\n\n\t\t\tstringchars = (const char **) palloc(stringlen * sizeof(char *));\n\t\t\tstringmblen = (int *) palloc(stringlen * sizeof(int));\n\t\t\tstringnchars = 0;\n\t\t\tp = string;\n\t\t\tlen = stringlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tstringchars[stringnchars] = p;\n\t\t\t\tstringmblen[stringnchars] = mblen = pg_mblen(p);\n\t\t\t\tstringnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tsetchars = (const char **) palloc(setlen * sizeof(char *));\n\t\t\tsetmblen = (int *) palloc(setlen * sizeof(int));\n\t\t\tsetnchars = 0;\n\t\t\tp = set;\n\t\t\tlen = setlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tsetchars[setnchars] = p;\n\t\t\t\tsetmblen[setnchars] = mblen = pg_mblen(p);\n\t\t\t\tsetnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tresultndx = 0;\t\t/* index in stringchars[] */\n\t\t\tresultnchars = stringnchars;\n\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx];\n\t\t\t\t\tstr_len = stringmblen[resultndx];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring += str_len;\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultndx++;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx + resultnchars - 1];\n\t\t\t\t\tstr_len = stringmblen[resultndx + resultnchars - 1];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpfree(stringchars);\n\t\t\tpfree(stringmblen);\n\t\t\tpfree(setchars);\n\t\t\tpfree(setmblen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * In the single-byte-encoding case, we don't need such overhead.\n\t\t\t */\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = *string;\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring++;\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = string[stringlen - 1];\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Return selected portion of string */\n\treturn cstring_to_text_with_len(string, stringlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "string"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "string"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nDatum\nbtrim1(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string = PG_GETARG_TEXT_PP(0);\n\ttext\t   *ret;\n\n\tret = dotrim(VARDATA_ANY(string), VARSIZE_ANY_EXHDR(string),\n\t\t\t\t \" \", 1,\n\t\t\t\t true, true);\n\n\tPG_RETURN_TEXT_P(ret);\n}"
  },
  {
    "function_name": "btrim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
    "lines": "335-347",
    "snippet": "Datum\nbtrim(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string = PG_GETARG_TEXT_PP(0);\n\ttext\t   *set = PG_GETARG_TEXT_PP(1);\n\ttext\t   *ret;\n\n\tret = dotrim(VARDATA_ANY(string), VARSIZE_ANY_EXHDR(string),\n\t\t\t\t VARDATA_ANY(set), VARSIZE_ANY_EXHDR(set),\n\t\t\t\t true, true);\n\n\tPG_RETURN_TEXT_P(ret);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"common/int.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "ret"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dotrim",
          "args": [
            "VARDATA_ANY(string)",
            "VARSIZE_ANY_EXHDR(string)",
            "VARDATA_ANY(set)",
            "VARSIZE_ANY_EXHDR(set)",
            "true",
            "true"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "dotrim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
          "lines": "371-522",
          "snippet": "static text *\ndotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim)\n{\n\tint\t\t\ti;\n\n\t/* Nothing to do if either string or set is empty */\n\tif (stringlen > 0 && setlen > 0)\n\t{\n\t\tif (pg_database_encoding_max_length() > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * In the multibyte-encoding case, build arrays of pointers to\n\t\t\t * character starts, so that we can avoid inefficient checks in\n\t\t\t * the inner loops.\n\t\t\t */\n\t\t\tconst char **stringchars;\n\t\t\tconst char **setchars;\n\t\t\tint\t\t   *stringmblen;\n\t\t\tint\t\t   *setmblen;\n\t\t\tint\t\t\tstringnchars;\n\t\t\tint\t\t\tsetnchars;\n\t\t\tint\t\t\tresultndx;\n\t\t\tint\t\t\tresultnchars;\n\t\t\tconst char *p;\n\t\t\tint\t\t\tlen;\n\t\t\tint\t\t\tmblen;\n\t\t\tconst char *str_pos;\n\t\t\tint\t\t\tstr_len;\n\n\t\t\tstringchars = (const char **) palloc(stringlen * sizeof(char *));\n\t\t\tstringmblen = (int *) palloc(stringlen * sizeof(int));\n\t\t\tstringnchars = 0;\n\t\t\tp = string;\n\t\t\tlen = stringlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tstringchars[stringnchars] = p;\n\t\t\t\tstringmblen[stringnchars] = mblen = pg_mblen(p);\n\t\t\t\tstringnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tsetchars = (const char **) palloc(setlen * sizeof(char *));\n\t\t\tsetmblen = (int *) palloc(setlen * sizeof(int));\n\t\t\tsetnchars = 0;\n\t\t\tp = set;\n\t\t\tlen = setlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tsetchars[setnchars] = p;\n\t\t\t\tsetmblen[setnchars] = mblen = pg_mblen(p);\n\t\t\t\tsetnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tresultndx = 0;\t\t/* index in stringchars[] */\n\t\t\tresultnchars = stringnchars;\n\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx];\n\t\t\t\t\tstr_len = stringmblen[resultndx];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring += str_len;\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultndx++;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx + resultnchars - 1];\n\t\t\t\t\tstr_len = stringmblen[resultndx + resultnchars - 1];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpfree(stringchars);\n\t\t\tpfree(stringmblen);\n\t\t\tpfree(setchars);\n\t\t\tpfree(setmblen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * In the single-byte-encoding case, we don't need such overhead.\n\t\t\t */\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = *string;\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring++;\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = string[stringlen - 1];\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Return selected portion of string */\n\treturn cstring_to_text_with_len(string, stringlen);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"common/int.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static text *dotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nstatic text *dotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim);\n\nstatic text *\ndotrim(const char *string, int stringlen,\n\t   const char *set, int setlen,\n\t   bool doltrim, bool dortrim)\n{\n\tint\t\t\ti;\n\n\t/* Nothing to do if either string or set is empty */\n\tif (stringlen > 0 && setlen > 0)\n\t{\n\t\tif (pg_database_encoding_max_length() > 1)\n\t\t{\n\t\t\t/*\n\t\t\t * In the multibyte-encoding case, build arrays of pointers to\n\t\t\t * character starts, so that we can avoid inefficient checks in\n\t\t\t * the inner loops.\n\t\t\t */\n\t\t\tconst char **stringchars;\n\t\t\tconst char **setchars;\n\t\t\tint\t\t   *stringmblen;\n\t\t\tint\t\t   *setmblen;\n\t\t\tint\t\t\tstringnchars;\n\t\t\tint\t\t\tsetnchars;\n\t\t\tint\t\t\tresultndx;\n\t\t\tint\t\t\tresultnchars;\n\t\t\tconst char *p;\n\t\t\tint\t\t\tlen;\n\t\t\tint\t\t\tmblen;\n\t\t\tconst char *str_pos;\n\t\t\tint\t\t\tstr_len;\n\n\t\t\tstringchars = (const char **) palloc(stringlen * sizeof(char *));\n\t\t\tstringmblen = (int *) palloc(stringlen * sizeof(int));\n\t\t\tstringnchars = 0;\n\t\t\tp = string;\n\t\t\tlen = stringlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tstringchars[stringnchars] = p;\n\t\t\t\tstringmblen[stringnchars] = mblen = pg_mblen(p);\n\t\t\t\tstringnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tsetchars = (const char **) palloc(setlen * sizeof(char *));\n\t\t\tsetmblen = (int *) palloc(setlen * sizeof(int));\n\t\t\tsetnchars = 0;\n\t\t\tp = set;\n\t\t\tlen = setlen;\n\t\t\twhile (len > 0)\n\t\t\t{\n\t\t\t\tsetchars[setnchars] = p;\n\t\t\t\tsetmblen[setnchars] = mblen = pg_mblen(p);\n\t\t\t\tsetnchars++;\n\t\t\t\tp += mblen;\n\t\t\t\tlen -= mblen;\n\t\t\t}\n\n\t\t\tresultndx = 0;\t\t/* index in stringchars[] */\n\t\t\tresultnchars = stringnchars;\n\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx];\n\t\t\t\t\tstr_len = stringmblen[resultndx];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring += str_len;\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultndx++;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (resultnchars > 0)\n\t\t\t\t{\n\t\t\t\t\tstr_pos = stringchars[resultndx + resultnchars - 1];\n\t\t\t\t\tstr_len = stringmblen[resultndx + resultnchars - 1];\n\t\t\t\t\tfor (i = 0; i < setnchars; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_len == setmblen[i] &&\n\t\t\t\t\t\t\tmemcmp(str_pos, setchars[i], str_len) == 0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setnchars)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen -= str_len;\n\t\t\t\t\tresultnchars--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpfree(stringchars);\n\t\t\tpfree(stringmblen);\n\t\t\tpfree(setchars);\n\t\t\tpfree(setmblen);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * In the single-byte-encoding case, we don't need such overhead.\n\t\t\t */\n\t\t\tif (doltrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = *string;\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstring++;\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dortrim)\n\t\t\t{\n\t\t\t\twhile (stringlen > 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstr_ch = string[stringlen - 1];\n\n\t\t\t\t\tfor (i = 0; i < setlen; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (str_ch == set[i])\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i >= setlen)\n\t\t\t\t\t\tbreak;\t/* no match here */\n\t\t\t\t\tstringlen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Return selected portion of string */\n\treturn cstring_to_text_with_len(string, stringlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "set"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "set"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "string"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "string"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nDatum\nbtrim(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string = PG_GETARG_TEXT_PP(0);\n\ttext\t   *set = PG_GETARG_TEXT_PP(1);\n\ttext\t   *ret;\n\n\tret = dotrim(VARDATA_ANY(string), VARSIZE_ANY_EXHDR(string),\n\t\t\t\t VARDATA_ANY(set), VARSIZE_ANY_EXHDR(set),\n\t\t\t\t true, true);\n\n\tPG_RETURN_TEXT_P(ret);\n}"
  },
  {
    "function_name": "rpad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
    "lines": "239-317",
    "snippet": "Datum\nrpad(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string1 = PG_GETARG_TEXT_PP(0);\n\tint32\t\tlen = PG_GETARG_INT32(1);\n\ttext\t   *string2 = PG_GETARG_TEXT_PP(2);\n\ttext\t   *ret;\n\tchar\t   *ptr1,\n\t\t\t   *ptr2,\n\t\t\t   *ptr2start,\n\t\t\t   *ptr2end,\n\t\t\t   *ptr_ret;\n\tint\t\t\tm,\n\t\t\t\ts1len,\n\t\t\t\ts2len;\n\n\tint\t\t\tbytelen;\n\n\t/* Negative len is silently taken as zero */\n\tif (len < 0)\n\t\tlen = 0;\n\n\ts1len = VARSIZE_ANY_EXHDR(string1);\n\tif (s1len < 0)\n\t\ts1len = 0;\t\t\t\t/* shouldn't happen */\n\n\ts2len = VARSIZE_ANY_EXHDR(string2);\n\tif (s2len < 0)\n\t\ts2len = 0;\t\t\t\t/* shouldn't happen */\n\n\ts1len = pg_mbstrlen_with_len(VARDATA_ANY(string1), s1len);\n\n\tif (s1len > len)\n\t\ts1len = len;\t\t\t/* truncate string1 to len chars */\n\n\tif (s2len <= 0)\n\t\tlen = s1len;\t\t\t/* nothing to pad with, so don't pad */\n\n\tbytelen = pg_database_encoding_max_length() * len;\n\n\t/* Check for integer overflow */\n\tif (len != 0 && bytelen / pg_database_encoding_max_length() != len)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"requested length too large\")));\n\n\tret = (text *) palloc(VARHDRSZ + bytelen);\n\tm = len - s1len;\n\n\tptr1 = VARDATA_ANY(string1);\n\tptr_ret = VARDATA(ret);\n\n\twhile (s1len--)\n\t{\n\t\tint\t\t\tmlen = pg_mblen(ptr1);\n\n\t\tmemcpy(ptr_ret, ptr1, mlen);\n\t\tptr_ret += mlen;\n\t\tptr1 += mlen;\n\t}\n\n\tptr2 = ptr2start = VARDATA_ANY(string2);\n\tptr2end = ptr2 + s2len;\n\n\twhile (m--)\n\t{\n\t\tint\t\t\tmlen = pg_mblen(ptr2);\n\n\t\tmemcpy(ptr_ret, ptr2, mlen);\n\t\tptr_ret += mlen;\n\t\tptr2 += mlen;\n\t\tif (ptr2 == ptr2end)\t/* wrap around at end of s2 */\n\t\t\tptr2 = ptr2start;\n\t}\n\n\tSET_VARSIZE(ret, ptr_ret - (char *) ret);\n\n\tPG_RETURN_TEXT_P(ret);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"common/int.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "ret"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "ret",
            "ptr_ret - (char *) ret"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr_ret",
            "ptr2",
            "mlen"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "ptr2"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "string2"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr_ret",
            "ptr1",
            "mlen"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "ret"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "string1"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "VARHDRSZ + bytelen"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"requested length too large\"))"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"requested length too large\""
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mbstrlen_with_len",
          "args": [
            "VARDATA_ANY(string1)",
            "s1len"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbstrlen_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "793-811",
          "snippet": "int\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "string1"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "string2"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "string1"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "2"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nDatum\nrpad(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string1 = PG_GETARG_TEXT_PP(0);\n\tint32\t\tlen = PG_GETARG_INT32(1);\n\ttext\t   *string2 = PG_GETARG_TEXT_PP(2);\n\ttext\t   *ret;\n\tchar\t   *ptr1,\n\t\t\t   *ptr2,\n\t\t\t   *ptr2start,\n\t\t\t   *ptr2end,\n\t\t\t   *ptr_ret;\n\tint\t\t\tm,\n\t\t\t\ts1len,\n\t\t\t\ts2len;\n\n\tint\t\t\tbytelen;\n\n\t/* Negative len is silently taken as zero */\n\tif (len < 0)\n\t\tlen = 0;\n\n\ts1len = VARSIZE_ANY_EXHDR(string1);\n\tif (s1len < 0)\n\t\ts1len = 0;\t\t\t\t/* shouldn't happen */\n\n\ts2len = VARSIZE_ANY_EXHDR(string2);\n\tif (s2len < 0)\n\t\ts2len = 0;\t\t\t\t/* shouldn't happen */\n\n\ts1len = pg_mbstrlen_with_len(VARDATA_ANY(string1), s1len);\n\n\tif (s1len > len)\n\t\ts1len = len;\t\t\t/* truncate string1 to len chars */\n\n\tif (s2len <= 0)\n\t\tlen = s1len;\t\t\t/* nothing to pad with, so don't pad */\n\n\tbytelen = pg_database_encoding_max_length() * len;\n\n\t/* Check for integer overflow */\n\tif (len != 0 && bytelen / pg_database_encoding_max_length() != len)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"requested length too large\")));\n\n\tret = (text *) palloc(VARHDRSZ + bytelen);\n\tm = len - s1len;\n\n\tptr1 = VARDATA_ANY(string1);\n\tptr_ret = VARDATA(ret);\n\n\twhile (s1len--)\n\t{\n\t\tint\t\t\tmlen = pg_mblen(ptr1);\n\n\t\tmemcpy(ptr_ret, ptr1, mlen);\n\t\tptr_ret += mlen;\n\t\tptr1 += mlen;\n\t}\n\n\tptr2 = ptr2start = VARDATA_ANY(string2);\n\tptr2end = ptr2 + s2len;\n\n\twhile (m--)\n\t{\n\t\tint\t\t\tmlen = pg_mblen(ptr2);\n\n\t\tmemcpy(ptr_ret, ptr2, mlen);\n\t\tptr_ret += mlen;\n\t\tptr2 += mlen;\n\t\tif (ptr2 == ptr2end)\t/* wrap around at end of s2 */\n\t\t\tptr2 = ptr2start;\n\t}\n\n\tSET_VARSIZE(ret, ptr_ret - (char *) ret);\n\n\tPG_RETURN_TEXT_P(ret);\n}"
  },
  {
    "function_name": "lpad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
    "lines": "141-220",
    "snippet": "Datum\nlpad(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string1 = PG_GETARG_TEXT_PP(0);\n\tint32\t\tlen = PG_GETARG_INT32(1);\n\ttext\t   *string2 = PG_GETARG_TEXT_PP(2);\n\ttext\t   *ret;\n\tchar\t   *ptr1,\n\t\t\t   *ptr2,\n\t\t\t   *ptr2start,\n\t\t\t   *ptr2end,\n\t\t\t   *ptr_ret;\n\tint\t\t\tm,\n\t\t\t\ts1len,\n\t\t\t\ts2len;\n\n\tint\t\t\tbytelen;\n\n\t/* Negative len is silently taken as zero */\n\tif (len < 0)\n\t\tlen = 0;\n\n\ts1len = VARSIZE_ANY_EXHDR(string1);\n\tif (s1len < 0)\n\t\ts1len = 0;\t\t\t\t/* shouldn't happen */\n\n\ts2len = VARSIZE_ANY_EXHDR(string2);\n\tif (s2len < 0)\n\t\ts2len = 0;\t\t\t\t/* shouldn't happen */\n\n\ts1len = pg_mbstrlen_with_len(VARDATA_ANY(string1), s1len);\n\n\tif (s1len > len)\n\t\ts1len = len;\t\t\t/* truncate string1 to len chars */\n\n\tif (s2len <= 0)\n\t\tlen = s1len;\t\t\t/* nothing to pad with, so don't pad */\n\n\tbytelen = pg_database_encoding_max_length() * len;\n\n\t/* check for integer overflow */\n\tif (len != 0 && bytelen / pg_database_encoding_max_length() != len)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"requested length too large\")));\n\n\tret = (text *) palloc(VARHDRSZ + bytelen);\n\n\tm = len - s1len;\n\n\tptr2 = ptr2start = VARDATA_ANY(string2);\n\tptr2end = ptr2 + s2len;\n\tptr_ret = VARDATA(ret);\n\n\twhile (m--)\n\t{\n\t\tint\t\t\tmlen = pg_mblen(ptr2);\n\n\t\tmemcpy(ptr_ret, ptr2, mlen);\n\t\tptr_ret += mlen;\n\t\tptr2 += mlen;\n\t\tif (ptr2 == ptr2end)\t/* wrap around at end of s2 */\n\t\t\tptr2 = ptr2start;\n\t}\n\n\tptr1 = VARDATA_ANY(string1);\n\n\twhile (s1len--)\n\t{\n\t\tint\t\t\tmlen = pg_mblen(ptr1);\n\n\t\tmemcpy(ptr_ret, ptr1, mlen);\n\t\tptr_ret += mlen;\n\t\tptr1 += mlen;\n\t}\n\n\tSET_VARSIZE(ret, ptr_ret - (char *) ret);\n\n\tPG_RETURN_TEXT_P(ret);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"common/int.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "ret"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "ret",
            "ptr_ret - (char *) ret"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr_ret",
            "ptr1",
            "mlen"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "ptr1"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "string1"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr_ret",
            "ptr2",
            "mlen"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "ret"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "string2"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "VARHDRSZ + bytelen"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"requested length too large\"))"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"requested length too large\""
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mbstrlen_with_len",
          "args": [
            "VARDATA_ANY(string1)",
            "s1len"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbstrlen_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "793-811",
          "snippet": "int\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbstrlen_with_len(const char *mbstr, int limit)\n{\n\tint\t\t\tlen = 0;\n\n\t/* optimization for single byte encoding */\n\tif (pg_database_encoding_max_length() == 1)\n\t\treturn limit;\n\n\twhile (limit > 0 && *mbstr)\n\t{\n\t\tint\t\t\tl = pg_mblen(mbstr);\n\n\t\tlimit -= l;\n\t\tmbstr += l;\n\t\tlen++;\n\t}\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "string1"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "string2"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "string1"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "2"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "1"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nDatum\nlpad(PG_FUNCTION_ARGS)\n{\n\ttext\t   *string1 = PG_GETARG_TEXT_PP(0);\n\tint32\t\tlen = PG_GETARG_INT32(1);\n\ttext\t   *string2 = PG_GETARG_TEXT_PP(2);\n\ttext\t   *ret;\n\tchar\t   *ptr1,\n\t\t\t   *ptr2,\n\t\t\t   *ptr2start,\n\t\t\t   *ptr2end,\n\t\t\t   *ptr_ret;\n\tint\t\t\tm,\n\t\t\t\ts1len,\n\t\t\t\ts2len;\n\n\tint\t\t\tbytelen;\n\n\t/* Negative len is silently taken as zero */\n\tif (len < 0)\n\t\tlen = 0;\n\n\ts1len = VARSIZE_ANY_EXHDR(string1);\n\tif (s1len < 0)\n\t\ts1len = 0;\t\t\t\t/* shouldn't happen */\n\n\ts2len = VARSIZE_ANY_EXHDR(string2);\n\tif (s2len < 0)\n\t\ts2len = 0;\t\t\t\t/* shouldn't happen */\n\n\ts1len = pg_mbstrlen_with_len(VARDATA_ANY(string1), s1len);\n\n\tif (s1len > len)\n\t\ts1len = len;\t\t\t/* truncate string1 to len chars */\n\n\tif (s2len <= 0)\n\t\tlen = s1len;\t\t\t/* nothing to pad with, so don't pad */\n\n\tbytelen = pg_database_encoding_max_length() * len;\n\n\t/* check for integer overflow */\n\tif (len != 0 && bytelen / pg_database_encoding_max_length() != len)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"requested length too large\")));\n\n\tret = (text *) palloc(VARHDRSZ + bytelen);\n\n\tm = len - s1len;\n\n\tptr2 = ptr2start = VARDATA_ANY(string2);\n\tptr2end = ptr2 + s2len;\n\tptr_ret = VARDATA(ret);\n\n\twhile (m--)\n\t{\n\t\tint\t\t\tmlen = pg_mblen(ptr2);\n\n\t\tmemcpy(ptr_ret, ptr2, mlen);\n\t\tptr_ret += mlen;\n\t\tptr2 += mlen;\n\t\tif (ptr2 == ptr2end)\t/* wrap around at end of s2 */\n\t\t\tptr2 = ptr2start;\n\t}\n\n\tptr1 = VARDATA_ANY(string1);\n\n\twhile (s1len--)\n\t{\n\t\tint\t\t\tmlen = pg_mblen(ptr1);\n\n\t\tmemcpy(ptr_ret, ptr1, mlen);\n\t\tptr_ret += mlen;\n\t\tptr1 += mlen;\n\t}\n\n\tSET_VARSIZE(ret, ptr_ret - (char *) ret);\n\n\tPG_RETURN_TEXT_P(ret);\n}"
  },
  {
    "function_name": "initcap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
    "lines": "108-122",
    "snippet": "Datum\ninitcap(PG_FUNCTION_ARGS)\n{\n\ttext\t   *in_string = PG_GETARG_TEXT_PP(0);\n\tchar\t   *out_string;\n\ttext\t   *result;\n\n\tout_string = str_initcap(VARDATA_ANY(in_string),\n\t\t\t\t\t\t\t VARSIZE_ANY_EXHDR(in_string),\n\t\t\t\t\t\t\t PG_GET_COLLATION());\n\tresult = cstring_to_text(out_string);\n\tpfree(out_string);\n\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"common/int.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "out_string"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "out_string"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_initcap",
          "args": [
            "VARDATA_ANY(in_string)",
            "VARSIZE_ANY_EXHDR(in_string)",
            "PG_GET_COLLATION()"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "str_initcap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1752-1891",
          "snippet": "char *\nstr_initcap(const char *buff, size_t nbytes, Oid collid)\n{\n\tchar\t   *result;\n\tint\t\t\twasalnum = false;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\t/* C/POSIX collations use this path regardless of database encoding */\n\tif (lc_ctype_is_c(collid))\n\t{\n\t\tresult = asc_initcap(buff, nbytes);\n\t}\n\telse\n\t{\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for initcap() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n#ifdef USE_ICU\n\t\tif (mylocale && mylocale->provider == COLLPROVIDER_ICU)\n\t\t{\n\t\t\tint32_t\t\tlen_uchar,\n\t\t\t\t\t\tlen_conv;\n\t\t\tUChar\t   *buff_uchar;\n\t\t\tUChar\t   *buff_conv;\n\n\t\t\tlen_uchar = icu_to_uchar(&buff_uchar, buff, nbytes);\n\t\t\tlen_conv = icu_convert_case(u_strToTitle_default_BI, mylocale,\n\t\t\t\t\t\t\t\t\t\t&buff_conv, buff_uchar, len_uchar);\n\t\t\ticu_from_uchar(&result, buff_conv, len_conv);\n\t\t\tpfree(buff_uchar);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tif (pg_database_encoding_max_length() > 1)\n\t\t\t{\n\t\t\t\twchar_t    *workspace;\n\t\t\t\tsize_t\t\tcurr_char;\n\t\t\t\tsize_t\t\tresult_size;\n\n\t\t\t\t/* Overflow paranoia */\n\t\t\t\tif ((nbytes + 1) > (INT_MAX / sizeof(wchar_t)))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t\t\t/* Output workspace cannot have more codes than input bytes */\n\t\t\t\tworkspace = (wchar_t *) palloc((nbytes + 1) * sizeof(wchar_t));\n\n\t\t\t\tchar2wchar(workspace, nbytes + 1, buff, nbytes, mylocale);\n\n\t\t\t\tfor (curr_char = 0; workspace[curr_char] != 0; curr_char++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\tworkspace[curr_char] = towlower_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tworkspace[curr_char] = towupper_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\t\twasalnum = iswalnum_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\t}\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\tworkspace[curr_char] = towlower(workspace[curr_char]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tworkspace[curr_char] = towupper(workspace[curr_char]);\n\t\t\t\t\t\twasalnum = iswalnum(workspace[curr_char]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make result large enough; case change might change number\n\t\t\t\t * of bytes\n\t\t\t\t */\n\t\t\t\tresult_size = curr_char * pg_database_encoding_max_length() + 1;\n\t\t\t\tresult = palloc(result_size);\n\n\t\t\t\twchar2char(result, workspace, result_size, mylocale);\n\t\t\t\tpfree(workspace);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar\t   *p;\n\n\t\t\t\tresult = pnstrdup(buff, nbytes);\n\n\t\t\t\t/*\n\t\t\t\t * Note: we assume that toupper_l()/tolower_l() will not be so\n\t\t\t\t * broken as to need guard tests.  When using the default\n\t\t\t\t * collation, we apply the traditional Postgres behavior that\n\t\t\t\t * forces ASCII-style treatment of I/i, but in non-default\n\t\t\t\t * collations you get exactly what the collation says.\n\t\t\t\t */\n\t\t\t\tfor (p = result; *p; p++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\t*p = tolower_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*p = toupper_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\t\twasalnum = isalnum_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\t}\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\t*p = pg_tolower((unsigned char) *p);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*p = pg_toupper((unsigned char) *p);\n\t\t\t\t\t\twasalnum = isalnum((unsigned char) *p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
            "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);",
            "static char *int_to_roman(int number);",
            "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\nstatic char *int_to_roman(int number);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\n\nchar *\nstr_initcap(const char *buff, size_t nbytes, Oid collid)\n{\n\tchar\t   *result;\n\tint\t\t\twasalnum = false;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\t/* C/POSIX collations use this path regardless of database encoding */\n\tif (lc_ctype_is_c(collid))\n\t{\n\t\tresult = asc_initcap(buff, nbytes);\n\t}\n\telse\n\t{\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for initcap() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n#ifdef USE_ICU\n\t\tif (mylocale && mylocale->provider == COLLPROVIDER_ICU)\n\t\t{\n\t\t\tint32_t\t\tlen_uchar,\n\t\t\t\t\t\tlen_conv;\n\t\t\tUChar\t   *buff_uchar;\n\t\t\tUChar\t   *buff_conv;\n\n\t\t\tlen_uchar = icu_to_uchar(&buff_uchar, buff, nbytes);\n\t\t\tlen_conv = icu_convert_case(u_strToTitle_default_BI, mylocale,\n\t\t\t\t\t\t\t\t\t\t&buff_conv, buff_uchar, len_uchar);\n\t\t\ticu_from_uchar(&result, buff_conv, len_conv);\n\t\t\tpfree(buff_uchar);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tif (pg_database_encoding_max_length() > 1)\n\t\t\t{\n\t\t\t\twchar_t    *workspace;\n\t\t\t\tsize_t\t\tcurr_char;\n\t\t\t\tsize_t\t\tresult_size;\n\n\t\t\t\t/* Overflow paranoia */\n\t\t\t\tif ((nbytes + 1) > (INT_MAX / sizeof(wchar_t)))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t\t\t/* Output workspace cannot have more codes than input bytes */\n\t\t\t\tworkspace = (wchar_t *) palloc((nbytes + 1) * sizeof(wchar_t));\n\n\t\t\t\tchar2wchar(workspace, nbytes + 1, buff, nbytes, mylocale);\n\n\t\t\t\tfor (curr_char = 0; workspace[curr_char] != 0; curr_char++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\tworkspace[curr_char] = towlower_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tworkspace[curr_char] = towupper_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\t\twasalnum = iswalnum_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\t}\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\tworkspace[curr_char] = towlower(workspace[curr_char]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tworkspace[curr_char] = towupper(workspace[curr_char]);\n\t\t\t\t\t\twasalnum = iswalnum(workspace[curr_char]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make result large enough; case change might change number\n\t\t\t\t * of bytes\n\t\t\t\t */\n\t\t\t\tresult_size = curr_char * pg_database_encoding_max_length() + 1;\n\t\t\t\tresult = palloc(result_size);\n\n\t\t\t\twchar2char(result, workspace, result_size, mylocale);\n\t\t\t\tpfree(workspace);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar\t   *p;\n\n\t\t\t\tresult = pnstrdup(buff, nbytes);\n\n\t\t\t\t/*\n\t\t\t\t * Note: we assume that toupper_l()/tolower_l() will not be so\n\t\t\t\t * broken as to need guard tests.  When using the default\n\t\t\t\t * collation, we apply the traditional Postgres behavior that\n\t\t\t\t * forces ASCII-style treatment of I/i, but in non-default\n\t\t\t\t * collations you get exactly what the collation says.\n\t\t\t\t */\n\t\t\t\tfor (p = result; *p; p++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\t*p = tolower_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*p = toupper_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\t\twasalnum = isalnum_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\t}\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t{\n\t\t\t\t\t\tif (wasalnum)\n\t\t\t\t\t\t\t*p = pg_tolower((unsigned char) *p);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t*p = pg_toupper((unsigned char) *p);\n\t\t\t\t\t\twasalnum = isalnum((unsigned char) *p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "in_string"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "in_string"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nDatum\ninitcap(PG_FUNCTION_ARGS)\n{\n\ttext\t   *in_string = PG_GETARG_TEXT_PP(0);\n\tchar\t   *out_string;\n\ttext\t   *result;\n\n\tout_string = str_initcap(VARDATA_ANY(in_string),\n\t\t\t\t\t\t\t VARSIZE_ANY_EXHDR(in_string),\n\t\t\t\t\t\t\t PG_GET_COLLATION());\n\tresult = cstring_to_text(out_string);\n\tpfree(out_string);\n\n\tPG_RETURN_TEXT_P(result);\n}"
  },
  {
    "function_name": "upper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
    "lines": "74-88",
    "snippet": "Datum\nupper(PG_FUNCTION_ARGS)\n{\n\ttext\t   *in_string = PG_GETARG_TEXT_PP(0);\n\tchar\t   *out_string;\n\ttext\t   *result;\n\n\tout_string = str_toupper(VARDATA_ANY(in_string),\n\t\t\t\t\t\t\t VARSIZE_ANY_EXHDR(in_string),\n\t\t\t\t\t\t\t PG_GET_COLLATION());\n\tresult = cstring_to_text(out_string);\n\tpfree(out_string);\n\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"common/int.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "out_string"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "out_string"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_toupper",
          "args": [
            "VARDATA_ANY(in_string)",
            "VARSIZE_ANY_EXHDR(in_string)",
            "PG_GET_COLLATION()"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "str_toupper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1630-1744",
          "snippet": "char *\nstr_toupper(const char *buff, size_t nbytes, Oid collid)\n{\n\tchar\t   *result;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\t/* C/POSIX collations use this path regardless of database encoding */\n\tif (lc_ctype_is_c(collid))\n\t{\n\t\tresult = asc_toupper(buff, nbytes);\n\t}\n\telse\n\t{\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for upper() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n#ifdef USE_ICU\n\t\tif (mylocale && mylocale->provider == COLLPROVIDER_ICU)\n\t\t{\n\t\t\tint32_t\t\tlen_uchar,\n\t\t\t\t\t\tlen_conv;\n\t\t\tUChar\t   *buff_uchar;\n\t\t\tUChar\t   *buff_conv;\n\n\t\t\tlen_uchar = icu_to_uchar(&buff_uchar, buff, nbytes);\n\t\t\tlen_conv = icu_convert_case(u_strToUpper, mylocale,\n\t\t\t\t\t\t\t\t\t\t&buff_conv, buff_uchar, len_uchar);\n\t\t\ticu_from_uchar(&result, buff_conv, len_conv);\n\t\t\tpfree(buff_uchar);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tif (pg_database_encoding_max_length() > 1)\n\t\t\t{\n\t\t\t\twchar_t    *workspace;\n\t\t\t\tsize_t\t\tcurr_char;\n\t\t\t\tsize_t\t\tresult_size;\n\n\t\t\t\t/* Overflow paranoia */\n\t\t\t\tif ((nbytes + 1) > (INT_MAX / sizeof(wchar_t)))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t\t\t/* Output workspace cannot have more codes than input bytes */\n\t\t\t\tworkspace = (wchar_t *) palloc((nbytes + 1) * sizeof(wchar_t));\n\n\t\t\t\tchar2wchar(workspace, nbytes + 1, buff, nbytes, mylocale);\n\n\t\t\t\tfor (curr_char = 0; workspace[curr_char] != 0; curr_char++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\tworkspace[curr_char] = towupper_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\tworkspace[curr_char] = towupper(workspace[curr_char]);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make result large enough; case change might change number\n\t\t\t\t * of bytes\n\t\t\t\t */\n\t\t\t\tresult_size = curr_char * pg_database_encoding_max_length() + 1;\n\t\t\t\tresult = palloc(result_size);\n\n\t\t\t\twchar2char(result, workspace, result_size, mylocale);\n\t\t\t\tpfree(workspace);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar\t   *p;\n\n\t\t\t\tresult = pnstrdup(buff, nbytes);\n\n\t\t\t\t/*\n\t\t\t\t * Note: we assume that toupper_l() will not be so broken as\n\t\t\t\t * to need an islower_l() guard test.  When using the default\n\t\t\t\t * collation, we apply the traditional Postgres behavior that\n\t\t\t\t * forces ASCII-style treatment of I/i, but in non-default\n\t\t\t\t * collations you get exactly what the collation says.\n\t\t\t\t */\n\t\t\t\tfor (p = result; *p; p++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\t*p = toupper_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\t*p = pg_toupper((unsigned char) *p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
            "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);",
            "static char *int_to_roman(int number);",
            "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\nstatic char *int_to_roman(int number);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\n\nchar *\nstr_toupper(const char *buff, size_t nbytes, Oid collid)\n{\n\tchar\t   *result;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\t/* C/POSIX collations use this path regardless of database encoding */\n\tif (lc_ctype_is_c(collid))\n\t{\n\t\tresult = asc_toupper(buff, nbytes);\n\t}\n\telse\n\t{\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for upper() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n#ifdef USE_ICU\n\t\tif (mylocale && mylocale->provider == COLLPROVIDER_ICU)\n\t\t{\n\t\t\tint32_t\t\tlen_uchar,\n\t\t\t\t\t\tlen_conv;\n\t\t\tUChar\t   *buff_uchar;\n\t\t\tUChar\t   *buff_conv;\n\n\t\t\tlen_uchar = icu_to_uchar(&buff_uchar, buff, nbytes);\n\t\t\tlen_conv = icu_convert_case(u_strToUpper, mylocale,\n\t\t\t\t\t\t\t\t\t\t&buff_conv, buff_uchar, len_uchar);\n\t\t\ticu_from_uchar(&result, buff_conv, len_conv);\n\t\t\tpfree(buff_uchar);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tif (pg_database_encoding_max_length() > 1)\n\t\t\t{\n\t\t\t\twchar_t    *workspace;\n\t\t\t\tsize_t\t\tcurr_char;\n\t\t\t\tsize_t\t\tresult_size;\n\n\t\t\t\t/* Overflow paranoia */\n\t\t\t\tif ((nbytes + 1) > (INT_MAX / sizeof(wchar_t)))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t\t\t/* Output workspace cannot have more codes than input bytes */\n\t\t\t\tworkspace = (wchar_t *) palloc((nbytes + 1) * sizeof(wchar_t));\n\n\t\t\t\tchar2wchar(workspace, nbytes + 1, buff, nbytes, mylocale);\n\n\t\t\t\tfor (curr_char = 0; workspace[curr_char] != 0; curr_char++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\tworkspace[curr_char] = towupper_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\tworkspace[curr_char] = towupper(workspace[curr_char]);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make result large enough; case change might change number\n\t\t\t\t * of bytes\n\t\t\t\t */\n\t\t\t\tresult_size = curr_char * pg_database_encoding_max_length() + 1;\n\t\t\t\tresult = palloc(result_size);\n\n\t\t\t\twchar2char(result, workspace, result_size, mylocale);\n\t\t\t\tpfree(workspace);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar\t   *p;\n\n\t\t\t\tresult = pnstrdup(buff, nbytes);\n\n\t\t\t\t/*\n\t\t\t\t * Note: we assume that toupper_l() will not be so broken as\n\t\t\t\t * to need an islower_l() guard test.  When using the default\n\t\t\t\t * collation, we apply the traditional Postgres behavior that\n\t\t\t\t * forces ASCII-style treatment of I/i, but in non-default\n\t\t\t\t * collations you get exactly what the collation says.\n\t\t\t\t */\n\t\t\t\tfor (p = result; *p; p++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\t*p = toupper_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\t*p = pg_toupper((unsigned char) *p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "in_string"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "in_string"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nDatum\nupper(PG_FUNCTION_ARGS)\n{\n\ttext\t   *in_string = PG_GETARG_TEXT_PP(0);\n\tchar\t   *out_string;\n\ttext\t   *result;\n\n\tout_string = str_toupper(VARDATA_ANY(in_string),\n\t\t\t\t\t\t\t VARSIZE_ANY_EXHDR(in_string),\n\t\t\t\t\t\t\t PG_GET_COLLATION());\n\tresult = cstring_to_text(out_string);\n\tpfree(out_string);\n\n\tPG_RETURN_TEXT_P(result);\n}"
  },
  {
    "function_name": "lower",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oracle_compat.c",
    "lines": "43-57",
    "snippet": "Datum\nlower(PG_FUNCTION_ARGS)\n{\n\ttext\t   *in_string = PG_GETARG_TEXT_PP(0);\n\tchar\t   *out_string;\n\ttext\t   *result;\n\n\tout_string = str_tolower(VARDATA_ANY(in_string),\n\t\t\t\t\t\t\t VARSIZE_ANY_EXHDR(in_string),\n\t\t\t\t\t\t\t PG_GET_COLLATION());\n\tresult = cstring_to_text(out_string);\n\tpfree(out_string);\n\n\tPG_RETURN_TEXT_P(result);\n}",
    "includes": [
      "#include \"mb/pg_wchar.h\"",
      "#include \"utils/formatting.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"common/int.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TEXT_P",
          "args": [
            "result"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "out_string"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cstring_to_text",
          "args": [
            "out_string"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "148-152",
          "snippet": "text *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text(const char *s)\n{\n\treturn cstring_to_text_with_len(s, strlen(s));\n}"
        }
      },
      {
        "call_info": {
          "callee": "str_tolower",
          "args": [
            "VARDATA_ANY(in_string)",
            "VARSIZE_ANY_EXHDR(in_string)",
            "PG_GET_COLLATION()"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "str_tolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/formatting.c",
          "lines": "1508-1622",
          "snippet": "char *\nstr_tolower(const char *buff, size_t nbytes, Oid collid)\n{\n\tchar\t   *result;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\t/* C/POSIX collations use this path regardless of database encoding */\n\tif (lc_ctype_is_c(collid))\n\t{\n\t\tresult = asc_tolower(buff, nbytes);\n\t}\n\telse\n\t{\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for lower() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n#ifdef USE_ICU\n\t\tif (mylocale && mylocale->provider == COLLPROVIDER_ICU)\n\t\t{\n\t\t\tint32_t\t\tlen_uchar;\n\t\t\tint32_t\t\tlen_conv;\n\t\t\tUChar\t   *buff_uchar;\n\t\t\tUChar\t   *buff_conv;\n\n\t\t\tlen_uchar = icu_to_uchar(&buff_uchar, buff, nbytes);\n\t\t\tlen_conv = icu_convert_case(u_strToLower, mylocale,\n\t\t\t\t\t\t\t\t\t\t&buff_conv, buff_uchar, len_uchar);\n\t\t\ticu_from_uchar(&result, buff_conv, len_conv);\n\t\t\tpfree(buff_uchar);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tif (pg_database_encoding_max_length() > 1)\n\t\t\t{\n\t\t\t\twchar_t    *workspace;\n\t\t\t\tsize_t\t\tcurr_char;\n\t\t\t\tsize_t\t\tresult_size;\n\n\t\t\t\t/* Overflow paranoia */\n\t\t\t\tif ((nbytes + 1) > (INT_MAX / sizeof(wchar_t)))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t\t\t/* Output workspace cannot have more codes than input bytes */\n\t\t\t\tworkspace = (wchar_t *) palloc((nbytes + 1) * sizeof(wchar_t));\n\n\t\t\t\tchar2wchar(workspace, nbytes + 1, buff, nbytes, mylocale);\n\n\t\t\t\tfor (curr_char = 0; workspace[curr_char] != 0; curr_char++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\tworkspace[curr_char] = towlower_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\tworkspace[curr_char] = towlower(workspace[curr_char]);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make result large enough; case change might change number\n\t\t\t\t * of bytes\n\t\t\t\t */\n\t\t\t\tresult_size = curr_char * pg_database_encoding_max_length() + 1;\n\t\t\t\tresult = palloc(result_size);\n\n\t\t\t\twchar2char(result, workspace, result_size, mylocale);\n\t\t\t\tpfree(workspace);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar\t   *p;\n\n\t\t\t\tresult = pnstrdup(buff, nbytes);\n\n\t\t\t\t/*\n\t\t\t\t * Note: we assume that tolower_l() will not be so broken as\n\t\t\t\t * to need an isupper_l() guard test.  When using the default\n\t\t\t\t * collation, we apply the traditional Postgres behavior that\n\t\t\t\t * forces ASCII-style treatment of I/i, but in non-default\n\t\t\t\t * collations you get exactly what the collation says.\n\t\t\t\t */\n\t\t\t\tfor (p = result; *p; p++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\t*p = tolower_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\t*p = pg_tolower((unsigned char) *p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/formatting.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include <unicode/ustring.h>",
            "#include <wctype.h>",
            "#include <wchar.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <math.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);",
            "static void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);",
            "static char *int_to_roman(int number);",
            "static char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/pg_locale.h\"\n#include \"utils/numeric.h\"\n#include \"utils/int8.h\"\n#include \"utils/formatting.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/pg_collation.h\"\n#include <unicode/ustring.h>\n#include <wctype.h>\n#include <wchar.h>\n#include <limits.h>\n#include <float.h>\n#include <math.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void DCH_to_char(FormatNode *node, bool is_interval,\n\t\t\tTmToChar *in, char *out, Oid collid);\nstatic void DCH_from_char(FormatNode *node, char *in, TmFromChar *out);\nstatic char *int_to_roman(int number);\nstatic char *NUM_processor(FormatNode *node, NUMDesc *Num, char *inout,\n\t\t\t  char *number, int input_len, int to_char_out_pre_spaces,\n\t\t\t  int sign, bool is_to_char, Oid collid);\n\nchar *\nstr_tolower(const char *buff, size_t nbytes, Oid collid)\n{\n\tchar\t   *result;\n\n\tif (!buff)\n\t\treturn NULL;\n\n\t/* C/POSIX collations use this path regardless of database encoding */\n\tif (lc_ctype_is_c(collid))\n\t{\n\t\tresult = asc_tolower(buff, nbytes);\n\t}\n\telse\n\t{\n\t\tpg_locale_t mylocale = 0;\n\n\t\tif (collid != DEFAULT_COLLATION_OID)\n\t\t{\n\t\t\tif (!OidIsValid(collid))\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * This typically means that the parser could not resolve a\n\t\t\t\t * conflict of implicit collations, so report it that way.\n\t\t\t\t */\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INDETERMINATE_COLLATION),\n\t\t\t\t\t\t errmsg(\"could not determine which collation to use for lower() function\"),\n\t\t\t\t\t\t errhint(\"Use the COLLATE clause to set the collation explicitly.\")));\n\t\t\t}\n\t\t\tmylocale = pg_newlocale_from_collation(collid);\n\t\t}\n\n#ifdef USE_ICU\n\t\tif (mylocale && mylocale->provider == COLLPROVIDER_ICU)\n\t\t{\n\t\t\tint32_t\t\tlen_uchar;\n\t\t\tint32_t\t\tlen_conv;\n\t\t\tUChar\t   *buff_uchar;\n\t\t\tUChar\t   *buff_conv;\n\n\t\t\tlen_uchar = icu_to_uchar(&buff_uchar, buff, nbytes);\n\t\t\tlen_conv = icu_convert_case(u_strToLower, mylocale,\n\t\t\t\t\t\t\t\t\t\t&buff_conv, buff_uchar, len_uchar);\n\t\t\ticu_from_uchar(&result, buff_conv, len_conv);\n\t\t\tpfree(buff_uchar);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t\tif (pg_database_encoding_max_length() > 1)\n\t\t\t{\n\t\t\t\twchar_t    *workspace;\n\t\t\t\tsize_t\t\tcurr_char;\n\t\t\t\tsize_t\t\tresult_size;\n\n\t\t\t\t/* Overflow paranoia */\n\t\t\t\tif ((nbytes + 1) > (INT_MAX / sizeof(wchar_t)))\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\t\t\t/* Output workspace cannot have more codes than input bytes */\n\t\t\t\tworkspace = (wchar_t *) palloc((nbytes + 1) * sizeof(wchar_t));\n\n\t\t\t\tchar2wchar(workspace, nbytes + 1, buff, nbytes, mylocale);\n\n\t\t\t\tfor (curr_char = 0; workspace[curr_char] != 0; curr_char++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\tworkspace[curr_char] = towlower_l(workspace[curr_char], mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\tworkspace[curr_char] = towlower(workspace[curr_char]);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Make result large enough; case change might change number\n\t\t\t\t * of bytes\n\t\t\t\t */\n\t\t\t\tresult_size = curr_char * pg_database_encoding_max_length() + 1;\n\t\t\t\tresult = palloc(result_size);\n\n\t\t\t\twchar2char(result, workspace, result_size, mylocale);\n\t\t\t\tpfree(workspace);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchar\t   *p;\n\n\t\t\t\tresult = pnstrdup(buff, nbytes);\n\n\t\t\t\t/*\n\t\t\t\t * Note: we assume that tolower_l() will not be so broken as\n\t\t\t\t * to need an isupper_l() guard test.  When using the default\n\t\t\t\t * collation, we apply the traditional Postgres behavior that\n\t\t\t\t * forces ASCII-style treatment of I/i, but in non-default\n\t\t\t\t * collations you get exactly what the collation says.\n\t\t\t\t */\n\t\t\t\tfor (p = result; *p; p++)\n\t\t\t\t{\n#ifdef HAVE_LOCALE_T\n\t\t\t\t\tif (mylocale)\n\t\t\t\t\t\t*p = tolower_l((unsigned char) *p, mylocale->info.lt);\n\t\t\t\t\telse\n#endif\n\t\t\t\t\t\t*p = pg_tolower((unsigned char) *p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GET_COLLATION",
          "args": [],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "in_string"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "in_string"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/formatting.h\"\n#include \"utils/builtins.h\"\n#include \"common/int.h\"\n#include \"postgres.h\"\n\nDatum\nlower(PG_FUNCTION_ARGS)\n{\n\ttext\t   *in_string = PG_GETARG_TEXT_PP(0);\n\tchar\t   *out_string;\n\ttext\t   *result;\n\n\tout_string = str_tolower(VARDATA_ANY(in_string),\n\t\t\t\t\t\t\t VARSIZE_ANY_EXHDR(in_string),\n\t\t\t\t\t\t\t PG_GET_COLLATION());\n\tresult = cstring_to_text(out_string);\n\tpfree(out_string);\n\n\tPG_RETURN_TEXT_P(result);\n}"
  }
]