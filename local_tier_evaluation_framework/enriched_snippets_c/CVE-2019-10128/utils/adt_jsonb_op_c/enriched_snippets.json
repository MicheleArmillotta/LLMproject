[
  {
    "function_name": "jsonb_hash_extended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_op.c",
    "lines": "295-336",
    "snippet": "Datum\njsonb_hash_extended(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tuint64\t\tseed = PG_GETARG_INT64(1);\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\tuint64\t\thash = 0;\n\n\tif (JB_ROOT_COUNT(jb) == 0)\n\t\tPG_RETURN_UINT64(seed);\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t{\n\t\tswitch (r)\n\t\t{\n\t\t\t\t/* Rotation is left to JsonbHashScalarValueExtended() */\n\t\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t\thash ^= ((uint64) JB_FARRAY) << 32 | JB_FARRAY;\n\t\t\t\tbreak;\n\t\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t\thash ^= ((uint64) JB_FOBJECT) << 32 | JB_FOBJECT;\n\t\t\t\tbreak;\n\t\t\tcase WJB_KEY:\n\t\t\tcase WJB_VALUE:\n\t\t\tcase WJB_ELEM:\n\t\t\t\tJsonbHashScalarValueExtended(&v, &hash, seed);\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_ARRAY:\n\t\t\tcase WJB_END_OBJECT:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid JsonbIteratorNext rc: %d\", (int) r);\n\t\t}\n\t}\n\n\tPG_FREE_IF_COPY(jb, 0);\n\tPG_RETURN_UINT64(hash);\n}",
    "includes": [
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_UINT64",
          "args": [
            "hash"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "jb",
            "0"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid JsonbIteratorNext rc: %d\"",
            "(int) r"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbHashScalarValueExtended",
          "args": [
            "&v",
            "&hash",
            "seed"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbHashScalarValueExtended",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1256-1293",
          "snippet": "void\nJsonbHashScalarValueExtended(const JsonbValue *scalarVal, uint64 *hash,\n\t\t\t\t\t\t\t uint64 seed)\n{\n\tuint64\t\ttmp;\n\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\ttmp = seed + 0x01;\n\t\t\tbreak;\n\t\tcase jbvString:\n\t\t\ttmp = DatumGetUInt64(hash_any_extended((const unsigned char *) scalarVal->val.string.val,\n\t\t\t\t\t\t\t\t\t\t\t\t   scalarVal->val.string.len,\n\t\t\t\t\t\t\t\t\t\t\t\t   seed));\n\t\t\tbreak;\n\t\tcase jbvNumeric:\n\t\t\ttmp = DatumGetUInt64(DirectFunctionCall2(hash_numeric_extended,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NumericGetDatum(scalarVal->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t UInt64GetDatum(seed)));\n\t\t\tbreak;\n\t\tcase jbvBool:\n\t\t\tif (seed)\n\t\t\t\ttmp = DatumGetUInt64(DirectFunctionCall2(hashcharextended,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t BoolGetDatum(scalarVal->val.boolean),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t UInt64GetDatum(seed)));\n\t\t\telse\n\t\t\t\ttmp = scalarVal->val.boolean ? 0x02 : 0x04;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t\tbreak;\n\t}\n\n\t*hash = ROTATE_HIGH_AND_LOW_32BITS(*hash);\n\t*hash ^= tmp;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nvoid\nJsonbHashScalarValueExtended(const JsonbValue *scalarVal, uint64 *hash,\n\t\t\t\t\t\t\t uint64 seed)\n{\n\tuint64\t\ttmp;\n\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\ttmp = seed + 0x01;\n\t\t\tbreak;\n\t\tcase jbvString:\n\t\t\ttmp = DatumGetUInt64(hash_any_extended((const unsigned char *) scalarVal->val.string.val,\n\t\t\t\t\t\t\t\t\t\t\t\t   scalarVal->val.string.len,\n\t\t\t\t\t\t\t\t\t\t\t\t   seed));\n\t\t\tbreak;\n\t\tcase jbvNumeric:\n\t\t\ttmp = DatumGetUInt64(DirectFunctionCall2(hash_numeric_extended,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NumericGetDatum(scalarVal->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t UInt64GetDatum(seed)));\n\t\t\tbreak;\n\t\tcase jbvBool:\n\t\t\tif (seed)\n\t\t\t\ttmp = DatumGetUInt64(DirectFunctionCall2(hashcharextended,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t BoolGetDatum(scalarVal->val.boolean),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t UInt64GetDatum(seed)));\n\t\t\telse\n\t\t\t\ttmp = scalarVal->val.boolean ? 0x02 : 0x04;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t\tbreak;\n\t}\n\n\t*hash = ROTATE_HIGH_AND_LOW_32BITS(*hash);\n\t*hash ^= tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "false"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&jb->root"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_UINT64",
          "args": [
            "seed"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_COUNT",
          "args": [
            "jb"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT64",
          "args": [
            "1"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_hash_extended(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tuint64\t\tseed = PG_GETARG_INT64(1);\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\tuint64\t\thash = 0;\n\n\tif (JB_ROOT_COUNT(jb) == 0)\n\t\tPG_RETURN_UINT64(seed);\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t{\n\t\tswitch (r)\n\t\t{\n\t\t\t\t/* Rotation is left to JsonbHashScalarValueExtended() */\n\t\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t\thash ^= ((uint64) JB_FARRAY) << 32 | JB_FARRAY;\n\t\t\t\tbreak;\n\t\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t\thash ^= ((uint64) JB_FOBJECT) << 32 | JB_FOBJECT;\n\t\t\t\tbreak;\n\t\t\tcase WJB_KEY:\n\t\t\tcase WJB_VALUE:\n\t\t\tcase WJB_ELEM:\n\t\t\t\tJsonbHashScalarValueExtended(&v, &hash, seed);\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_ARRAY:\n\t\t\tcase WJB_END_OBJECT:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid JsonbIteratorNext rc: %d\", (int) r);\n\t\t}\n\t}\n\n\tPG_FREE_IF_COPY(jb, 0);\n\tPG_RETURN_UINT64(hash);\n}"
  },
  {
    "function_name": "jsonb_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_op.c",
    "lines": "253-293",
    "snippet": "Datum\njsonb_hash(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\tuint32\t\thash = 0;\n\n\tif (JB_ROOT_COUNT(jb) == 0)\n\t\tPG_RETURN_INT32(0);\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t{\n\t\tswitch (r)\n\t\t{\n\t\t\t\t/* Rotation is left to JsonbHashScalarValue() */\n\t\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t\thash ^= JB_FARRAY;\n\t\t\t\tbreak;\n\t\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t\thash ^= JB_FOBJECT;\n\t\t\t\tbreak;\n\t\t\tcase WJB_KEY:\n\t\t\tcase WJB_VALUE:\n\t\t\tcase WJB_ELEM:\n\t\t\t\tJsonbHashScalarValue(&v, &hash);\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_ARRAY:\n\t\t\tcase WJB_END_OBJECT:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid JsonbIteratorNext rc: %d\", (int) r);\n\t\t}\n\t}\n\n\tPG_FREE_IF_COPY(jb, 0);\n\tPG_RETURN_INT32(hash);\n}",
    "includes": [
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "hash"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "jb",
            "0"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"invalid JsonbIteratorNext rc: %d\"",
            "(int) r"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbHashScalarValue",
          "args": [
            "&v",
            "&hash"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbHashScalarValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "1213-1250",
          "snippet": "void\nJsonbHashScalarValue(const JsonbValue *scalarVal, uint32 *hash)\n{\n\tuint32\t\ttmp;\n\n\t/* Compute hash value for scalarVal */\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\ttmp = 0x01;\n\t\t\tbreak;\n\t\tcase jbvString:\n\t\t\ttmp = DatumGetUInt32(hash_any((const unsigned char *) scalarVal->val.string.val,\n\t\t\t\t\t\t\t\t\t\t  scalarVal->val.string.len));\n\t\t\tbreak;\n\t\tcase jbvNumeric:\n\t\t\t/* Must hash equal numerics to equal hash codes */\n\t\t\ttmp = DatumGetUInt32(DirectFunctionCall1(hash_numeric,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NumericGetDatum(scalarVal->val.numeric)));\n\t\t\tbreak;\n\t\tcase jbvBool:\n\t\t\ttmp = scalarVal->val.boolean ? 0x02 : 0x04;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t\ttmp = 0;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Combine hash values of successive keys, values and elements by rotating\n\t * the previous value left 1 bit, then XOR'ing in the new\n\t * key/value/element's hash value.\n\t */\n\t*hash = (*hash << 1) | (*hash >> 31);\n\t*hash ^= tmp;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);",
            "static JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbScalar(StringInfo buffer, JEntry *header, JsonbValue *scalarVal);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic void appendKey(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendValue(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic void appendElement(JsonbParseState *pstate, JsonbValue *scalarVal);\nstatic JsonbValue *pushJsonbValueScalar(JsonbParseState **pstate,\n\t\t\t\t\t JsonbIteratorToken seq,\n\t\t\t\t\t JsonbValue *scalarVal);\n\nvoid\nJsonbHashScalarValue(const JsonbValue *scalarVal, uint32 *hash)\n{\n\tuint32\t\ttmp;\n\n\t/* Compute hash value for scalarVal */\n\tswitch (scalarVal->type)\n\t{\n\t\tcase jbvNull:\n\t\t\ttmp = 0x01;\n\t\t\tbreak;\n\t\tcase jbvString:\n\t\t\ttmp = DatumGetUInt32(hash_any((const unsigned char *) scalarVal->val.string.val,\n\t\t\t\t\t\t\t\t\t\t  scalarVal->val.string.len));\n\t\t\tbreak;\n\t\tcase jbvNumeric:\n\t\t\t/* Must hash equal numerics to equal hash codes */\n\t\t\ttmp = DatumGetUInt32(DirectFunctionCall1(hash_numeric,\n\t\t\t\t\t\t\t\t\t\t\t\t\t NumericGetDatum(scalarVal->val.numeric)));\n\t\t\tbreak;\n\t\tcase jbvBool:\n\t\t\ttmp = scalarVal->val.boolean ? 0x02 : 0x04;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t\ttmp = 0;\t\t\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * Combine hash values of successive keys, values and elements by rotating\n\t * the previous value left 1 bit, then XOR'ing in the new\n\t * key/value/element's hash value.\n\t */\n\t*hash = (*hash << 1) | (*hash >> 31);\n\t*hash ^= tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorNext",
          "args": [
            "&it",
            "&v",
            "false"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorNext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "753-894",
          "snippet": "JsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbIteratorToken\nJsonbIteratorNext(JsonbIterator **it, JsonbValue *val, bool skipNested)\n{\n\tif (*it == NULL)\n\t\treturn WJB_DONE;\n\n\t/*\n\t * When stepping into a nested container, we jump back here to start\n\t * processing the child. We will not recurse further in one call, because\n\t * processing the child will always begin in JBI_ARRAY_START or\n\t * JBI_OBJECT_START state.\n\t */\nrecurse:\n\tswitch ((*it)->state)\n\t{\n\t\tcase JBI_ARRAY_START:\n\t\t\t/* Set v to array on first array call */\n\t\t\tval->type = jbvArray;\n\t\t\tval->val.array.nElems = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.array.elems is not actually set, because we aren't doing\n\t\t\t * a full conversion\n\t\t\t */\n\t\t\tval->val.array.rawScalar = (*it)->isScalar;\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = 0;\t/* not actually used */\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_ARRAY_ELEM;\n\t\t\treturn WJB_BEGIN_ARRAY;\n\n\t\tcase JBI_ARRAY_ELEM:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All elements within array already processed.  Report this\n\t\t\t\t * to caller, and give it back original parent iterator (which\n\t\t\t\t * independently tracks iteration progress at its level of\n\t\t\t\t * nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_ARRAY;\n\t\t\t}\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t/* Recurse into container. */\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Scalar item in array, or a container and caller didn't want\n\t\t\t\t * us to recurse into it.\n\t\t\t\t */\n\t\t\t\treturn WJB_ELEM;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_START:\n\t\t\t/* Set v to object on first object call */\n\t\t\tval->type = jbvObject;\n\t\t\tval->val.object.nPairs = (*it)->nElems;\n\n\t\t\t/*\n\t\t\t * v->val.object.pairs is not actually set, because we aren't\n\t\t\t * doing a full conversion\n\t\t\t */\n\t\t\t(*it)->curIndex = 0;\n\t\t\t(*it)->curDataOffset = 0;\n\t\t\t(*it)->curValueOffset = getJsonbOffset((*it)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t   (*it)->nElems);\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\t\t\treturn WJB_BEGIN_OBJECT;\n\n\t\tcase JBI_OBJECT_KEY:\n\t\t\tif ((*it)->curIndex >= (*it)->nElems)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * All pairs within object already processed.  Report this to\n\t\t\t\t * caller, and give it back original containing iterator\n\t\t\t\t * (which independently tracks iteration progress at its level\n\t\t\t\t * of nesting).\n\t\t\t\t */\n\t\t\t\t*it = freeAndGetParent(*it);\n\t\t\t\treturn WJB_END_OBJECT;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Return key of a key/value pair.  */\n\t\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex,\n\t\t\t\t\t\t\t   (*it)->dataProper, (*it)->curDataOffset,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tif (val->type != jbvString)\n\t\t\t\t\telog(ERROR, \"unexpected jsonb type as object key\");\n\n\t\t\t\t/* Set state for next call */\n\t\t\t\t(*it)->state = JBI_OBJECT_VALUE;\n\t\t\t\treturn WJB_KEY;\n\t\t\t}\n\n\t\tcase JBI_OBJECT_VALUE:\n\t\t\t/* Set state for next call */\n\t\t\t(*it)->state = JBI_OBJECT_KEY;\n\n\t\t\tfillJsonbValue((*it)->container, (*it)->curIndex + (*it)->nElems,\n\t\t\t\t\t\t   (*it)->dataProper, (*it)->curValueOffset,\n\t\t\t\t\t\t   val);\n\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curDataOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex]);\n\t\t\tJBE_ADVANCE_OFFSET((*it)->curValueOffset,\n\t\t\t\t\t\t\t   (*it)->children[(*it)->curIndex + (*it)->nElems]);\n\t\t\t(*it)->curIndex++;\n\n\t\t\t/*\n\t\t\t * Value may be a container, in which case we recurse with new,\n\t\t\t * child iterator (unless the caller asked not to, by passing\n\t\t\t * skipNested).\n\t\t\t */\n\t\t\tif (!IsAJsonbScalar(val) && !skipNested)\n\t\t\t{\n\t\t\t\t*it = iteratorFromContainer(val->val.binary.data, *it);\n\t\t\t\tgoto recurse;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn WJB_VALUE;\n\t}\n\n\telog(ERROR, \"invalid iterator state\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&jb->root"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "0"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_COUNT",
          "args": [
            "jb"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_hash(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tJsonbIterator *it;\n\tJsonbValue\tv;\n\tJsonbIteratorToken r;\n\tuint32\t\thash = 0;\n\n\tif (JB_ROOT_COUNT(jb) == 0)\n\t\tPG_RETURN_INT32(0);\n\n\tit = JsonbIteratorInit(&jb->root);\n\n\twhile ((r = JsonbIteratorNext(&it, &v, false)) != WJB_DONE)\n\t{\n\t\tswitch (r)\n\t\t{\n\t\t\t\t/* Rotation is left to JsonbHashScalarValue() */\n\t\t\tcase WJB_BEGIN_ARRAY:\n\t\t\t\thash ^= JB_FARRAY;\n\t\t\t\tbreak;\n\t\t\tcase WJB_BEGIN_OBJECT:\n\t\t\t\thash ^= JB_FOBJECT;\n\t\t\t\tbreak;\n\t\t\tcase WJB_KEY:\n\t\t\tcase WJB_VALUE:\n\t\t\tcase WJB_ELEM:\n\t\t\t\tJsonbHashScalarValue(&v, &hash);\n\t\t\t\tbreak;\n\t\t\tcase WJB_END_ARRAY:\n\t\t\tcase WJB_END_OBJECT:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid JsonbIteratorNext rc: %d\", (int) r);\n\t\t}\n\t}\n\n\tPG_FREE_IF_COPY(jb, 0);\n\tPG_RETURN_INT32(hash);\n}"
  },
  {
    "function_name": "jsonb_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_op.c",
    "lines": "236-248",
    "snippet": "Datum\njsonb_cmp(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jba = PG_GETARG_JSONB_P(0);\n\tJsonb\t   *jbb = PG_GETARG_JSONB_P(1);\n\tint\t\t\tres;\n\n\tres = compareJsonbContainers(&jba->root, &jbb->root);\n\n\tPG_FREE_IF_COPY(jba, 0);\n\tPG_FREE_IF_COPY(jbb, 1);\n\tPG_RETURN_INT32(res);\n}",
    "includes": [
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "res"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "jbb",
            "1"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "jba",
            "0"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compareJsonbContainers",
          "args": [
            "&jba->root",
            "&jbb->root"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "compareJsonbContainers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "177-298",
          "snippet": "int\ncompareJsonbContainers(JsonbContainer *a, JsonbContainer *b)\n{\n\tJsonbIterator *ita,\n\t\t\t   *itb;\n\tint\t\t\tres = 0;\n\n\tita = JsonbIteratorInit(a);\n\titb = JsonbIteratorInit(b);\n\n\tdo\n\t{\n\t\tJsonbValue\tva,\n\t\t\t\t\tvb;\n\t\tJsonbIteratorToken ra,\n\t\t\t\t\trb;\n\n\t\tra = JsonbIteratorNext(&ita, &va, false);\n\t\trb = JsonbIteratorNext(&itb, &vb, false);\n\n\t\tif (ra == rb)\n\t\t{\n\t\t\tif (ra == WJB_DONE)\n\t\t\t{\n\t\t\t\t/* Decisively equal */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ra == WJB_END_ARRAY || ra == WJB_END_OBJECT)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * There is no array or object to compare at this stage of\n\t\t\t\t * processing.  jbvArray/jbvObject values are compared\n\t\t\t\t * initially, at the WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT\n\t\t\t\t * tokens.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (va.type == vb.type)\n\t\t\t{\n\t\t\t\tswitch (va.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvString:\n\t\t\t\t\tcase jbvNull:\n\t\t\t\t\tcase jbvNumeric:\n\t\t\t\t\tcase jbvBool:\n\t\t\t\t\t\tres = compareJsonbScalarValue(&va, &vb);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvArray:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This could be a \"raw scalar\" pseudo array.  That's\n\t\t\t\t\t\t * a special case here though, since we still want the\n\t\t\t\t\t\t * general type-based comparisons to apply, and as far\n\t\t\t\t\t\t * as we're concerned a pseudo array is just a scalar.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (va.val.array.rawScalar != vb.val.array.rawScalar)\n\t\t\t\t\t\t\tres = (va.val.array.rawScalar) ? -1 : 1;\n\t\t\t\t\t\tif (va.val.array.nElems != vb.val.array.nElems)\n\t\t\t\t\t\t\tres = (va.val.array.nElems > vb.val.array.nElems) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tif (va.val.object.nPairs != vb.val.object.nPairs)\n\t\t\t\t\t\t\tres = (va.val.object.nPairs > vb.val.object.nPairs) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvBinary:\n\t\t\t\t\t\telog(ERROR, \"unexpected jbvBinary value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Type-defined order */\n\t\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * It's safe to assume that the types differed, and that the va\n\t\t\t * and vb values passed were set.\n\t\t\t *\n\t\t\t * If the two values were of the same container type, then there'd\n\t\t\t * have been a chance to observe the variation in the number of\n\t\t\t * elements/pairs (when processing WJB_BEGIN_OBJECT, say). They're\n\t\t\t * either two heterogeneously-typed containers, or a container and\n\t\t\t * some scalar type.\n\t\t\t *\n\t\t\t * We don't have to consider the WJB_END_ARRAY and WJB_END_OBJECT\n\t\t\t * cases here, because we would have seen the corresponding\n\t\t\t * WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT tokens first, and\n\t\t\t * concluded that they don't match.\n\t\t\t */\n\t\t\tAssert(ra != WJB_END_ARRAY && ra != WJB_END_OBJECT);\n\t\t\tAssert(rb != WJB_END_ARRAY && rb != WJB_END_OBJECT);\n\n\t\t\tAssert(va.type != vb.type);\n\t\t\tAssert(va.type != jbvBinary);\n\t\t\tAssert(vb.type != jbvBinary);\n\t\t\t/* Type-defined order */\n\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t}\n\t}\n\twhile (res == 0);\n\n\twhile (ita != NULL)\n\t{\n\t\tJsonbIterator *i = ita->parent;\n\n\t\tpfree(ita);\n\t\tita = i;\n\t}\n\twhile (itb != NULL)\n\t{\n\t\tJsonbIterator *i = itb->parent;\n\n\t\tpfree(itb);\n\t\titb = i;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static int\tlengthCompareJsonbStringValue(const void *a, const void *b);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic int\tlengthCompareJsonbStringValue(const void *a, const void *b);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nint\ncompareJsonbContainers(JsonbContainer *a, JsonbContainer *b)\n{\n\tJsonbIterator *ita,\n\t\t\t   *itb;\n\tint\t\t\tres = 0;\n\n\tita = JsonbIteratorInit(a);\n\titb = JsonbIteratorInit(b);\n\n\tdo\n\t{\n\t\tJsonbValue\tva,\n\t\t\t\t\tvb;\n\t\tJsonbIteratorToken ra,\n\t\t\t\t\trb;\n\n\t\tra = JsonbIteratorNext(&ita, &va, false);\n\t\trb = JsonbIteratorNext(&itb, &vb, false);\n\n\t\tif (ra == rb)\n\t\t{\n\t\t\tif (ra == WJB_DONE)\n\t\t\t{\n\t\t\t\t/* Decisively equal */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ra == WJB_END_ARRAY || ra == WJB_END_OBJECT)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * There is no array or object to compare at this stage of\n\t\t\t\t * processing.  jbvArray/jbvObject values are compared\n\t\t\t\t * initially, at the WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT\n\t\t\t\t * tokens.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (va.type == vb.type)\n\t\t\t{\n\t\t\t\tswitch (va.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvString:\n\t\t\t\t\tcase jbvNull:\n\t\t\t\t\tcase jbvNumeric:\n\t\t\t\t\tcase jbvBool:\n\t\t\t\t\t\tres = compareJsonbScalarValue(&va, &vb);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvArray:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This could be a \"raw scalar\" pseudo array.  That's\n\t\t\t\t\t\t * a special case here though, since we still want the\n\t\t\t\t\t\t * general type-based comparisons to apply, and as far\n\t\t\t\t\t\t * as we're concerned a pseudo array is just a scalar.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (va.val.array.rawScalar != vb.val.array.rawScalar)\n\t\t\t\t\t\t\tres = (va.val.array.rawScalar) ? -1 : 1;\n\t\t\t\t\t\tif (va.val.array.nElems != vb.val.array.nElems)\n\t\t\t\t\t\t\tres = (va.val.array.nElems > vb.val.array.nElems) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tif (va.val.object.nPairs != vb.val.object.nPairs)\n\t\t\t\t\t\t\tres = (va.val.object.nPairs > vb.val.object.nPairs) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvBinary:\n\t\t\t\t\t\telog(ERROR, \"unexpected jbvBinary value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Type-defined order */\n\t\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * It's safe to assume that the types differed, and that the va\n\t\t\t * and vb values passed were set.\n\t\t\t *\n\t\t\t * If the two values were of the same container type, then there'd\n\t\t\t * have been a chance to observe the variation in the number of\n\t\t\t * elements/pairs (when processing WJB_BEGIN_OBJECT, say). They're\n\t\t\t * either two heterogeneously-typed containers, or a container and\n\t\t\t * some scalar type.\n\t\t\t *\n\t\t\t * We don't have to consider the WJB_END_ARRAY and WJB_END_OBJECT\n\t\t\t * cases here, because we would have seen the corresponding\n\t\t\t * WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT tokens first, and\n\t\t\t * concluded that they don't match.\n\t\t\t */\n\t\t\tAssert(ra != WJB_END_ARRAY && ra != WJB_END_OBJECT);\n\t\t\tAssert(rb != WJB_END_ARRAY && rb != WJB_END_OBJECT);\n\n\t\t\tAssert(va.type != vb.type);\n\t\t\tAssert(va.type != jbvBinary);\n\t\t\tAssert(vb.type != jbvBinary);\n\t\t\t/* Type-defined order */\n\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t}\n\t}\n\twhile (res == 0);\n\n\twhile (ita != NULL)\n\t{\n\t\tJsonbIterator *i = ita->parent;\n\n\t\tpfree(ita);\n\t\tita = i;\n\t}\n\twhile (itb != NULL)\n\t{\n\t\tJsonbIterator *i = itb->parent;\n\n\t\tpfree(itb);\n\t\titb = i;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "1"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_cmp(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jba = PG_GETARG_JSONB_P(0);\n\tJsonb\t   *jbb = PG_GETARG_JSONB_P(1);\n\tint\t\t\tres;\n\n\tres = compareJsonbContainers(&jba->root, &jbb->root);\n\n\tPG_FREE_IF_COPY(jba, 0);\n\tPG_FREE_IF_COPY(jbb, 1);\n\tPG_RETURN_INT32(res);\n}"
  },
  {
    "function_name": "jsonb_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_op.c",
    "lines": "222-234",
    "snippet": "Datum\njsonb_eq(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jba = PG_GETARG_JSONB_P(0);\n\tJsonb\t   *jbb = PG_GETARG_JSONB_P(1);\n\tbool\t\tres;\n\n\tres = (compareJsonbContainers(&jba->root, &jbb->root) == 0);\n\n\tPG_FREE_IF_COPY(jba, 0);\n\tPG_FREE_IF_COPY(jbb, 1);\n\tPG_RETURN_BOOL(res);\n}",
    "includes": [
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "jbb",
            "1"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "jba",
            "0"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compareJsonbContainers",
          "args": [
            "&jba->root",
            "&jbb->root"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "compareJsonbContainers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "177-298",
          "snippet": "int\ncompareJsonbContainers(JsonbContainer *a, JsonbContainer *b)\n{\n\tJsonbIterator *ita,\n\t\t\t   *itb;\n\tint\t\t\tres = 0;\n\n\tita = JsonbIteratorInit(a);\n\titb = JsonbIteratorInit(b);\n\n\tdo\n\t{\n\t\tJsonbValue\tva,\n\t\t\t\t\tvb;\n\t\tJsonbIteratorToken ra,\n\t\t\t\t\trb;\n\n\t\tra = JsonbIteratorNext(&ita, &va, false);\n\t\trb = JsonbIteratorNext(&itb, &vb, false);\n\n\t\tif (ra == rb)\n\t\t{\n\t\t\tif (ra == WJB_DONE)\n\t\t\t{\n\t\t\t\t/* Decisively equal */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ra == WJB_END_ARRAY || ra == WJB_END_OBJECT)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * There is no array or object to compare at this stage of\n\t\t\t\t * processing.  jbvArray/jbvObject values are compared\n\t\t\t\t * initially, at the WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT\n\t\t\t\t * tokens.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (va.type == vb.type)\n\t\t\t{\n\t\t\t\tswitch (va.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvString:\n\t\t\t\t\tcase jbvNull:\n\t\t\t\t\tcase jbvNumeric:\n\t\t\t\t\tcase jbvBool:\n\t\t\t\t\t\tres = compareJsonbScalarValue(&va, &vb);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvArray:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This could be a \"raw scalar\" pseudo array.  That's\n\t\t\t\t\t\t * a special case here though, since we still want the\n\t\t\t\t\t\t * general type-based comparisons to apply, and as far\n\t\t\t\t\t\t * as we're concerned a pseudo array is just a scalar.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (va.val.array.rawScalar != vb.val.array.rawScalar)\n\t\t\t\t\t\t\tres = (va.val.array.rawScalar) ? -1 : 1;\n\t\t\t\t\t\tif (va.val.array.nElems != vb.val.array.nElems)\n\t\t\t\t\t\t\tres = (va.val.array.nElems > vb.val.array.nElems) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tif (va.val.object.nPairs != vb.val.object.nPairs)\n\t\t\t\t\t\t\tres = (va.val.object.nPairs > vb.val.object.nPairs) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvBinary:\n\t\t\t\t\t\telog(ERROR, \"unexpected jbvBinary value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Type-defined order */\n\t\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * It's safe to assume that the types differed, and that the va\n\t\t\t * and vb values passed were set.\n\t\t\t *\n\t\t\t * If the two values were of the same container type, then there'd\n\t\t\t * have been a chance to observe the variation in the number of\n\t\t\t * elements/pairs (when processing WJB_BEGIN_OBJECT, say). They're\n\t\t\t * either two heterogeneously-typed containers, or a container and\n\t\t\t * some scalar type.\n\t\t\t *\n\t\t\t * We don't have to consider the WJB_END_ARRAY and WJB_END_OBJECT\n\t\t\t * cases here, because we would have seen the corresponding\n\t\t\t * WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT tokens first, and\n\t\t\t * concluded that they don't match.\n\t\t\t */\n\t\t\tAssert(ra != WJB_END_ARRAY && ra != WJB_END_OBJECT);\n\t\t\tAssert(rb != WJB_END_ARRAY && rb != WJB_END_OBJECT);\n\n\t\t\tAssert(va.type != vb.type);\n\t\t\tAssert(va.type != jbvBinary);\n\t\t\tAssert(vb.type != jbvBinary);\n\t\t\t/* Type-defined order */\n\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t}\n\t}\n\twhile (res == 0);\n\n\twhile (ita != NULL)\n\t{\n\t\tJsonbIterator *i = ita->parent;\n\n\t\tpfree(ita);\n\t\tita = i;\n\t}\n\twhile (itb != NULL)\n\t{\n\t\tJsonbIterator *i = itb->parent;\n\n\t\tpfree(itb);\n\t\titb = i;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static int\tlengthCompareJsonbStringValue(const void *a, const void *b);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic int\tlengthCompareJsonbStringValue(const void *a, const void *b);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nint\ncompareJsonbContainers(JsonbContainer *a, JsonbContainer *b)\n{\n\tJsonbIterator *ita,\n\t\t\t   *itb;\n\tint\t\t\tres = 0;\n\n\tita = JsonbIteratorInit(a);\n\titb = JsonbIteratorInit(b);\n\n\tdo\n\t{\n\t\tJsonbValue\tva,\n\t\t\t\t\tvb;\n\t\tJsonbIteratorToken ra,\n\t\t\t\t\trb;\n\n\t\tra = JsonbIteratorNext(&ita, &va, false);\n\t\trb = JsonbIteratorNext(&itb, &vb, false);\n\n\t\tif (ra == rb)\n\t\t{\n\t\t\tif (ra == WJB_DONE)\n\t\t\t{\n\t\t\t\t/* Decisively equal */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ra == WJB_END_ARRAY || ra == WJB_END_OBJECT)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * There is no array or object to compare at this stage of\n\t\t\t\t * processing.  jbvArray/jbvObject values are compared\n\t\t\t\t * initially, at the WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT\n\t\t\t\t * tokens.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (va.type == vb.type)\n\t\t\t{\n\t\t\t\tswitch (va.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvString:\n\t\t\t\t\tcase jbvNull:\n\t\t\t\t\tcase jbvNumeric:\n\t\t\t\t\tcase jbvBool:\n\t\t\t\t\t\tres = compareJsonbScalarValue(&va, &vb);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvArray:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This could be a \"raw scalar\" pseudo array.  That's\n\t\t\t\t\t\t * a special case here though, since we still want the\n\t\t\t\t\t\t * general type-based comparisons to apply, and as far\n\t\t\t\t\t\t * as we're concerned a pseudo array is just a scalar.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (va.val.array.rawScalar != vb.val.array.rawScalar)\n\t\t\t\t\t\t\tres = (va.val.array.rawScalar) ? -1 : 1;\n\t\t\t\t\t\tif (va.val.array.nElems != vb.val.array.nElems)\n\t\t\t\t\t\t\tres = (va.val.array.nElems > vb.val.array.nElems) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tif (va.val.object.nPairs != vb.val.object.nPairs)\n\t\t\t\t\t\t\tres = (va.val.object.nPairs > vb.val.object.nPairs) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvBinary:\n\t\t\t\t\t\telog(ERROR, \"unexpected jbvBinary value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Type-defined order */\n\t\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * It's safe to assume that the types differed, and that the va\n\t\t\t * and vb values passed were set.\n\t\t\t *\n\t\t\t * If the two values were of the same container type, then there'd\n\t\t\t * have been a chance to observe the variation in the number of\n\t\t\t * elements/pairs (when processing WJB_BEGIN_OBJECT, say). They're\n\t\t\t * either two heterogeneously-typed containers, or a container and\n\t\t\t * some scalar type.\n\t\t\t *\n\t\t\t * We don't have to consider the WJB_END_ARRAY and WJB_END_OBJECT\n\t\t\t * cases here, because we would have seen the corresponding\n\t\t\t * WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT tokens first, and\n\t\t\t * concluded that they don't match.\n\t\t\t */\n\t\t\tAssert(ra != WJB_END_ARRAY && ra != WJB_END_OBJECT);\n\t\t\tAssert(rb != WJB_END_ARRAY && rb != WJB_END_OBJECT);\n\n\t\t\tAssert(va.type != vb.type);\n\t\t\tAssert(va.type != jbvBinary);\n\t\t\tAssert(vb.type != jbvBinary);\n\t\t\t/* Type-defined order */\n\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t}\n\t}\n\twhile (res == 0);\n\n\twhile (ita != NULL)\n\t{\n\t\tJsonbIterator *i = ita->parent;\n\n\t\tpfree(ita);\n\t\tita = i;\n\t}\n\twhile (itb != NULL)\n\t{\n\t\tJsonbIterator *i = itb->parent;\n\n\t\tpfree(itb);\n\t\titb = i;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "1"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_eq(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jba = PG_GETARG_JSONB_P(0);\n\tJsonb\t   *jbb = PG_GETARG_JSONB_P(1);\n\tbool\t\tres;\n\n\tres = (compareJsonbContainers(&jba->root, &jbb->root) == 0);\n\n\tPG_FREE_IF_COPY(jba, 0);\n\tPG_FREE_IF_COPY(jbb, 1);\n\tPG_RETURN_BOOL(res);\n}"
  },
  {
    "function_name": "jsonb_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_op.c",
    "lines": "208-220",
    "snippet": "Datum\njsonb_ge(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jba = PG_GETARG_JSONB_P(0);\n\tJsonb\t   *jbb = PG_GETARG_JSONB_P(1);\n\tbool\t\tres;\n\n\tres = (compareJsonbContainers(&jba->root, &jbb->root) >= 0);\n\n\tPG_FREE_IF_COPY(jba, 0);\n\tPG_FREE_IF_COPY(jbb, 1);\n\tPG_RETURN_BOOL(res);\n}",
    "includes": [
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "jbb",
            "1"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "jba",
            "0"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compareJsonbContainers",
          "args": [
            "&jba->root",
            "&jbb->root"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "compareJsonbContainers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "177-298",
          "snippet": "int\ncompareJsonbContainers(JsonbContainer *a, JsonbContainer *b)\n{\n\tJsonbIterator *ita,\n\t\t\t   *itb;\n\tint\t\t\tres = 0;\n\n\tita = JsonbIteratorInit(a);\n\titb = JsonbIteratorInit(b);\n\n\tdo\n\t{\n\t\tJsonbValue\tva,\n\t\t\t\t\tvb;\n\t\tJsonbIteratorToken ra,\n\t\t\t\t\trb;\n\n\t\tra = JsonbIteratorNext(&ita, &va, false);\n\t\trb = JsonbIteratorNext(&itb, &vb, false);\n\n\t\tif (ra == rb)\n\t\t{\n\t\t\tif (ra == WJB_DONE)\n\t\t\t{\n\t\t\t\t/* Decisively equal */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ra == WJB_END_ARRAY || ra == WJB_END_OBJECT)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * There is no array or object to compare at this stage of\n\t\t\t\t * processing.  jbvArray/jbvObject values are compared\n\t\t\t\t * initially, at the WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT\n\t\t\t\t * tokens.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (va.type == vb.type)\n\t\t\t{\n\t\t\t\tswitch (va.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvString:\n\t\t\t\t\tcase jbvNull:\n\t\t\t\t\tcase jbvNumeric:\n\t\t\t\t\tcase jbvBool:\n\t\t\t\t\t\tres = compareJsonbScalarValue(&va, &vb);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvArray:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This could be a \"raw scalar\" pseudo array.  That's\n\t\t\t\t\t\t * a special case here though, since we still want the\n\t\t\t\t\t\t * general type-based comparisons to apply, and as far\n\t\t\t\t\t\t * as we're concerned a pseudo array is just a scalar.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (va.val.array.rawScalar != vb.val.array.rawScalar)\n\t\t\t\t\t\t\tres = (va.val.array.rawScalar) ? -1 : 1;\n\t\t\t\t\t\tif (va.val.array.nElems != vb.val.array.nElems)\n\t\t\t\t\t\t\tres = (va.val.array.nElems > vb.val.array.nElems) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tif (va.val.object.nPairs != vb.val.object.nPairs)\n\t\t\t\t\t\t\tres = (va.val.object.nPairs > vb.val.object.nPairs) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvBinary:\n\t\t\t\t\t\telog(ERROR, \"unexpected jbvBinary value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Type-defined order */\n\t\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * It's safe to assume that the types differed, and that the va\n\t\t\t * and vb values passed were set.\n\t\t\t *\n\t\t\t * If the two values were of the same container type, then there'd\n\t\t\t * have been a chance to observe the variation in the number of\n\t\t\t * elements/pairs (when processing WJB_BEGIN_OBJECT, say). They're\n\t\t\t * either two heterogeneously-typed containers, or a container and\n\t\t\t * some scalar type.\n\t\t\t *\n\t\t\t * We don't have to consider the WJB_END_ARRAY and WJB_END_OBJECT\n\t\t\t * cases here, because we would have seen the corresponding\n\t\t\t * WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT tokens first, and\n\t\t\t * concluded that they don't match.\n\t\t\t */\n\t\t\tAssert(ra != WJB_END_ARRAY && ra != WJB_END_OBJECT);\n\t\t\tAssert(rb != WJB_END_ARRAY && rb != WJB_END_OBJECT);\n\n\t\t\tAssert(va.type != vb.type);\n\t\t\tAssert(va.type != jbvBinary);\n\t\t\tAssert(vb.type != jbvBinary);\n\t\t\t/* Type-defined order */\n\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t}\n\t}\n\twhile (res == 0);\n\n\twhile (ita != NULL)\n\t{\n\t\tJsonbIterator *i = ita->parent;\n\n\t\tpfree(ita);\n\t\tita = i;\n\t}\n\twhile (itb != NULL)\n\t{\n\t\tJsonbIterator *i = itb->parent;\n\n\t\tpfree(itb);\n\t\titb = i;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static int\tlengthCompareJsonbStringValue(const void *a, const void *b);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic int\tlengthCompareJsonbStringValue(const void *a, const void *b);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nint\ncompareJsonbContainers(JsonbContainer *a, JsonbContainer *b)\n{\n\tJsonbIterator *ita,\n\t\t\t   *itb;\n\tint\t\t\tres = 0;\n\n\tita = JsonbIteratorInit(a);\n\titb = JsonbIteratorInit(b);\n\n\tdo\n\t{\n\t\tJsonbValue\tva,\n\t\t\t\t\tvb;\n\t\tJsonbIteratorToken ra,\n\t\t\t\t\trb;\n\n\t\tra = JsonbIteratorNext(&ita, &va, false);\n\t\trb = JsonbIteratorNext(&itb, &vb, false);\n\n\t\tif (ra == rb)\n\t\t{\n\t\t\tif (ra == WJB_DONE)\n\t\t\t{\n\t\t\t\t/* Decisively equal */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ra == WJB_END_ARRAY || ra == WJB_END_OBJECT)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * There is no array or object to compare at this stage of\n\t\t\t\t * processing.  jbvArray/jbvObject values are compared\n\t\t\t\t * initially, at the WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT\n\t\t\t\t * tokens.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (va.type == vb.type)\n\t\t\t{\n\t\t\t\tswitch (va.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvString:\n\t\t\t\t\tcase jbvNull:\n\t\t\t\t\tcase jbvNumeric:\n\t\t\t\t\tcase jbvBool:\n\t\t\t\t\t\tres = compareJsonbScalarValue(&va, &vb);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvArray:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This could be a \"raw scalar\" pseudo array.  That's\n\t\t\t\t\t\t * a special case here though, since we still want the\n\t\t\t\t\t\t * general type-based comparisons to apply, and as far\n\t\t\t\t\t\t * as we're concerned a pseudo array is just a scalar.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (va.val.array.rawScalar != vb.val.array.rawScalar)\n\t\t\t\t\t\t\tres = (va.val.array.rawScalar) ? -1 : 1;\n\t\t\t\t\t\tif (va.val.array.nElems != vb.val.array.nElems)\n\t\t\t\t\t\t\tres = (va.val.array.nElems > vb.val.array.nElems) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tif (va.val.object.nPairs != vb.val.object.nPairs)\n\t\t\t\t\t\t\tres = (va.val.object.nPairs > vb.val.object.nPairs) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvBinary:\n\t\t\t\t\t\telog(ERROR, \"unexpected jbvBinary value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Type-defined order */\n\t\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * It's safe to assume that the types differed, and that the va\n\t\t\t * and vb values passed were set.\n\t\t\t *\n\t\t\t * If the two values were of the same container type, then there'd\n\t\t\t * have been a chance to observe the variation in the number of\n\t\t\t * elements/pairs (when processing WJB_BEGIN_OBJECT, say). They're\n\t\t\t * either two heterogeneously-typed containers, or a container and\n\t\t\t * some scalar type.\n\t\t\t *\n\t\t\t * We don't have to consider the WJB_END_ARRAY and WJB_END_OBJECT\n\t\t\t * cases here, because we would have seen the corresponding\n\t\t\t * WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT tokens first, and\n\t\t\t * concluded that they don't match.\n\t\t\t */\n\t\t\tAssert(ra != WJB_END_ARRAY && ra != WJB_END_OBJECT);\n\t\t\tAssert(rb != WJB_END_ARRAY && rb != WJB_END_OBJECT);\n\n\t\t\tAssert(va.type != vb.type);\n\t\t\tAssert(va.type != jbvBinary);\n\t\t\tAssert(vb.type != jbvBinary);\n\t\t\t/* Type-defined order */\n\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t}\n\t}\n\twhile (res == 0);\n\n\twhile (ita != NULL)\n\t{\n\t\tJsonbIterator *i = ita->parent;\n\n\t\tpfree(ita);\n\t\tita = i;\n\t}\n\twhile (itb != NULL)\n\t{\n\t\tJsonbIterator *i = itb->parent;\n\n\t\tpfree(itb);\n\t\titb = i;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "1"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_ge(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jba = PG_GETARG_JSONB_P(0);\n\tJsonb\t   *jbb = PG_GETARG_JSONB_P(1);\n\tbool\t\tres;\n\n\tres = (compareJsonbContainers(&jba->root, &jbb->root) >= 0);\n\n\tPG_FREE_IF_COPY(jba, 0);\n\tPG_FREE_IF_COPY(jbb, 1);\n\tPG_RETURN_BOOL(res);\n}"
  },
  {
    "function_name": "jsonb_le",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_op.c",
    "lines": "194-206",
    "snippet": "Datum\njsonb_le(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jba = PG_GETARG_JSONB_P(0);\n\tJsonb\t   *jbb = PG_GETARG_JSONB_P(1);\n\tbool\t\tres;\n\n\tres = (compareJsonbContainers(&jba->root, &jbb->root) <= 0);\n\n\tPG_FREE_IF_COPY(jba, 0);\n\tPG_FREE_IF_COPY(jbb, 1);\n\tPG_RETURN_BOOL(res);\n}",
    "includes": [
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "jbb",
            "1"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "jba",
            "0"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compareJsonbContainers",
          "args": [
            "&jba->root",
            "&jbb->root"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "compareJsonbContainers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "177-298",
          "snippet": "int\ncompareJsonbContainers(JsonbContainer *a, JsonbContainer *b)\n{\n\tJsonbIterator *ita,\n\t\t\t   *itb;\n\tint\t\t\tres = 0;\n\n\tita = JsonbIteratorInit(a);\n\titb = JsonbIteratorInit(b);\n\n\tdo\n\t{\n\t\tJsonbValue\tva,\n\t\t\t\t\tvb;\n\t\tJsonbIteratorToken ra,\n\t\t\t\t\trb;\n\n\t\tra = JsonbIteratorNext(&ita, &va, false);\n\t\trb = JsonbIteratorNext(&itb, &vb, false);\n\n\t\tif (ra == rb)\n\t\t{\n\t\t\tif (ra == WJB_DONE)\n\t\t\t{\n\t\t\t\t/* Decisively equal */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ra == WJB_END_ARRAY || ra == WJB_END_OBJECT)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * There is no array or object to compare at this stage of\n\t\t\t\t * processing.  jbvArray/jbvObject values are compared\n\t\t\t\t * initially, at the WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT\n\t\t\t\t * tokens.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (va.type == vb.type)\n\t\t\t{\n\t\t\t\tswitch (va.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvString:\n\t\t\t\t\tcase jbvNull:\n\t\t\t\t\tcase jbvNumeric:\n\t\t\t\t\tcase jbvBool:\n\t\t\t\t\t\tres = compareJsonbScalarValue(&va, &vb);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvArray:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This could be a \"raw scalar\" pseudo array.  That's\n\t\t\t\t\t\t * a special case here though, since we still want the\n\t\t\t\t\t\t * general type-based comparisons to apply, and as far\n\t\t\t\t\t\t * as we're concerned a pseudo array is just a scalar.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (va.val.array.rawScalar != vb.val.array.rawScalar)\n\t\t\t\t\t\t\tres = (va.val.array.rawScalar) ? -1 : 1;\n\t\t\t\t\t\tif (va.val.array.nElems != vb.val.array.nElems)\n\t\t\t\t\t\t\tres = (va.val.array.nElems > vb.val.array.nElems) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tif (va.val.object.nPairs != vb.val.object.nPairs)\n\t\t\t\t\t\t\tres = (va.val.object.nPairs > vb.val.object.nPairs) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvBinary:\n\t\t\t\t\t\telog(ERROR, \"unexpected jbvBinary value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Type-defined order */\n\t\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * It's safe to assume that the types differed, and that the va\n\t\t\t * and vb values passed were set.\n\t\t\t *\n\t\t\t * If the two values were of the same container type, then there'd\n\t\t\t * have been a chance to observe the variation in the number of\n\t\t\t * elements/pairs (when processing WJB_BEGIN_OBJECT, say). They're\n\t\t\t * either two heterogeneously-typed containers, or a container and\n\t\t\t * some scalar type.\n\t\t\t *\n\t\t\t * We don't have to consider the WJB_END_ARRAY and WJB_END_OBJECT\n\t\t\t * cases here, because we would have seen the corresponding\n\t\t\t * WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT tokens first, and\n\t\t\t * concluded that they don't match.\n\t\t\t */\n\t\t\tAssert(ra != WJB_END_ARRAY && ra != WJB_END_OBJECT);\n\t\t\tAssert(rb != WJB_END_ARRAY && rb != WJB_END_OBJECT);\n\n\t\t\tAssert(va.type != vb.type);\n\t\t\tAssert(va.type != jbvBinary);\n\t\t\tAssert(vb.type != jbvBinary);\n\t\t\t/* Type-defined order */\n\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t}\n\t}\n\twhile (res == 0);\n\n\twhile (ita != NULL)\n\t{\n\t\tJsonbIterator *i = ita->parent;\n\n\t\tpfree(ita);\n\t\tita = i;\n\t}\n\twhile (itb != NULL)\n\t{\n\t\tJsonbIterator *i = itb->parent;\n\n\t\tpfree(itb);\n\t\titb = i;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static int\tlengthCompareJsonbStringValue(const void *a, const void *b);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic int\tlengthCompareJsonbStringValue(const void *a, const void *b);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nint\ncompareJsonbContainers(JsonbContainer *a, JsonbContainer *b)\n{\n\tJsonbIterator *ita,\n\t\t\t   *itb;\n\tint\t\t\tres = 0;\n\n\tita = JsonbIteratorInit(a);\n\titb = JsonbIteratorInit(b);\n\n\tdo\n\t{\n\t\tJsonbValue\tva,\n\t\t\t\t\tvb;\n\t\tJsonbIteratorToken ra,\n\t\t\t\t\trb;\n\n\t\tra = JsonbIteratorNext(&ita, &va, false);\n\t\trb = JsonbIteratorNext(&itb, &vb, false);\n\n\t\tif (ra == rb)\n\t\t{\n\t\t\tif (ra == WJB_DONE)\n\t\t\t{\n\t\t\t\t/* Decisively equal */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ra == WJB_END_ARRAY || ra == WJB_END_OBJECT)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * There is no array or object to compare at this stage of\n\t\t\t\t * processing.  jbvArray/jbvObject values are compared\n\t\t\t\t * initially, at the WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT\n\t\t\t\t * tokens.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (va.type == vb.type)\n\t\t\t{\n\t\t\t\tswitch (va.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvString:\n\t\t\t\t\tcase jbvNull:\n\t\t\t\t\tcase jbvNumeric:\n\t\t\t\t\tcase jbvBool:\n\t\t\t\t\t\tres = compareJsonbScalarValue(&va, &vb);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvArray:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This could be a \"raw scalar\" pseudo array.  That's\n\t\t\t\t\t\t * a special case here though, since we still want the\n\t\t\t\t\t\t * general type-based comparisons to apply, and as far\n\t\t\t\t\t\t * as we're concerned a pseudo array is just a scalar.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (va.val.array.rawScalar != vb.val.array.rawScalar)\n\t\t\t\t\t\t\tres = (va.val.array.rawScalar) ? -1 : 1;\n\t\t\t\t\t\tif (va.val.array.nElems != vb.val.array.nElems)\n\t\t\t\t\t\t\tres = (va.val.array.nElems > vb.val.array.nElems) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tif (va.val.object.nPairs != vb.val.object.nPairs)\n\t\t\t\t\t\t\tres = (va.val.object.nPairs > vb.val.object.nPairs) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvBinary:\n\t\t\t\t\t\telog(ERROR, \"unexpected jbvBinary value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Type-defined order */\n\t\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * It's safe to assume that the types differed, and that the va\n\t\t\t * and vb values passed were set.\n\t\t\t *\n\t\t\t * If the two values were of the same container type, then there'd\n\t\t\t * have been a chance to observe the variation in the number of\n\t\t\t * elements/pairs (when processing WJB_BEGIN_OBJECT, say). They're\n\t\t\t * either two heterogeneously-typed containers, or a container and\n\t\t\t * some scalar type.\n\t\t\t *\n\t\t\t * We don't have to consider the WJB_END_ARRAY and WJB_END_OBJECT\n\t\t\t * cases here, because we would have seen the corresponding\n\t\t\t * WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT tokens first, and\n\t\t\t * concluded that they don't match.\n\t\t\t */\n\t\t\tAssert(ra != WJB_END_ARRAY && ra != WJB_END_OBJECT);\n\t\t\tAssert(rb != WJB_END_ARRAY && rb != WJB_END_OBJECT);\n\n\t\t\tAssert(va.type != vb.type);\n\t\t\tAssert(va.type != jbvBinary);\n\t\t\tAssert(vb.type != jbvBinary);\n\t\t\t/* Type-defined order */\n\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t}\n\t}\n\twhile (res == 0);\n\n\twhile (ita != NULL)\n\t{\n\t\tJsonbIterator *i = ita->parent;\n\n\t\tpfree(ita);\n\t\tita = i;\n\t}\n\twhile (itb != NULL)\n\t{\n\t\tJsonbIterator *i = itb->parent;\n\n\t\tpfree(itb);\n\t\titb = i;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "1"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_le(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jba = PG_GETARG_JSONB_P(0);\n\tJsonb\t   *jbb = PG_GETARG_JSONB_P(1);\n\tbool\t\tres;\n\n\tres = (compareJsonbContainers(&jba->root, &jbb->root) <= 0);\n\n\tPG_FREE_IF_COPY(jba, 0);\n\tPG_FREE_IF_COPY(jbb, 1);\n\tPG_RETURN_BOOL(res);\n}"
  },
  {
    "function_name": "jsonb_gt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_op.c",
    "lines": "180-192",
    "snippet": "Datum\njsonb_gt(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jba = PG_GETARG_JSONB_P(0);\n\tJsonb\t   *jbb = PG_GETARG_JSONB_P(1);\n\tbool\t\tres;\n\n\tres = (compareJsonbContainers(&jba->root, &jbb->root) > 0);\n\n\tPG_FREE_IF_COPY(jba, 0);\n\tPG_FREE_IF_COPY(jbb, 1);\n\tPG_RETURN_BOOL(res);\n}",
    "includes": [
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "jbb",
            "1"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "jba",
            "0"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compareJsonbContainers",
          "args": [
            "&jba->root",
            "&jbb->root"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "compareJsonbContainers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "177-298",
          "snippet": "int\ncompareJsonbContainers(JsonbContainer *a, JsonbContainer *b)\n{\n\tJsonbIterator *ita,\n\t\t\t   *itb;\n\tint\t\t\tres = 0;\n\n\tita = JsonbIteratorInit(a);\n\titb = JsonbIteratorInit(b);\n\n\tdo\n\t{\n\t\tJsonbValue\tva,\n\t\t\t\t\tvb;\n\t\tJsonbIteratorToken ra,\n\t\t\t\t\trb;\n\n\t\tra = JsonbIteratorNext(&ita, &va, false);\n\t\trb = JsonbIteratorNext(&itb, &vb, false);\n\n\t\tif (ra == rb)\n\t\t{\n\t\t\tif (ra == WJB_DONE)\n\t\t\t{\n\t\t\t\t/* Decisively equal */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ra == WJB_END_ARRAY || ra == WJB_END_OBJECT)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * There is no array or object to compare at this stage of\n\t\t\t\t * processing.  jbvArray/jbvObject values are compared\n\t\t\t\t * initially, at the WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT\n\t\t\t\t * tokens.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (va.type == vb.type)\n\t\t\t{\n\t\t\t\tswitch (va.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvString:\n\t\t\t\t\tcase jbvNull:\n\t\t\t\t\tcase jbvNumeric:\n\t\t\t\t\tcase jbvBool:\n\t\t\t\t\t\tres = compareJsonbScalarValue(&va, &vb);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvArray:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This could be a \"raw scalar\" pseudo array.  That's\n\t\t\t\t\t\t * a special case here though, since we still want the\n\t\t\t\t\t\t * general type-based comparisons to apply, and as far\n\t\t\t\t\t\t * as we're concerned a pseudo array is just a scalar.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (va.val.array.rawScalar != vb.val.array.rawScalar)\n\t\t\t\t\t\t\tres = (va.val.array.rawScalar) ? -1 : 1;\n\t\t\t\t\t\tif (va.val.array.nElems != vb.val.array.nElems)\n\t\t\t\t\t\t\tres = (va.val.array.nElems > vb.val.array.nElems) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tif (va.val.object.nPairs != vb.val.object.nPairs)\n\t\t\t\t\t\t\tres = (va.val.object.nPairs > vb.val.object.nPairs) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvBinary:\n\t\t\t\t\t\telog(ERROR, \"unexpected jbvBinary value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Type-defined order */\n\t\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * It's safe to assume that the types differed, and that the va\n\t\t\t * and vb values passed were set.\n\t\t\t *\n\t\t\t * If the two values were of the same container type, then there'd\n\t\t\t * have been a chance to observe the variation in the number of\n\t\t\t * elements/pairs (when processing WJB_BEGIN_OBJECT, say). They're\n\t\t\t * either two heterogeneously-typed containers, or a container and\n\t\t\t * some scalar type.\n\t\t\t *\n\t\t\t * We don't have to consider the WJB_END_ARRAY and WJB_END_OBJECT\n\t\t\t * cases here, because we would have seen the corresponding\n\t\t\t * WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT tokens first, and\n\t\t\t * concluded that they don't match.\n\t\t\t */\n\t\t\tAssert(ra != WJB_END_ARRAY && ra != WJB_END_OBJECT);\n\t\t\tAssert(rb != WJB_END_ARRAY && rb != WJB_END_OBJECT);\n\n\t\t\tAssert(va.type != vb.type);\n\t\t\tAssert(va.type != jbvBinary);\n\t\t\tAssert(vb.type != jbvBinary);\n\t\t\t/* Type-defined order */\n\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t}\n\t}\n\twhile (res == 0);\n\n\twhile (ita != NULL)\n\t{\n\t\tJsonbIterator *i = ita->parent;\n\n\t\tpfree(ita);\n\t\tita = i;\n\t}\n\twhile (itb != NULL)\n\t{\n\t\tJsonbIterator *i = itb->parent;\n\n\t\tpfree(itb);\n\t\titb = i;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static int\tlengthCompareJsonbStringValue(const void *a, const void *b);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic int\tlengthCompareJsonbStringValue(const void *a, const void *b);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nint\ncompareJsonbContainers(JsonbContainer *a, JsonbContainer *b)\n{\n\tJsonbIterator *ita,\n\t\t\t   *itb;\n\tint\t\t\tres = 0;\n\n\tita = JsonbIteratorInit(a);\n\titb = JsonbIteratorInit(b);\n\n\tdo\n\t{\n\t\tJsonbValue\tva,\n\t\t\t\t\tvb;\n\t\tJsonbIteratorToken ra,\n\t\t\t\t\trb;\n\n\t\tra = JsonbIteratorNext(&ita, &va, false);\n\t\trb = JsonbIteratorNext(&itb, &vb, false);\n\n\t\tif (ra == rb)\n\t\t{\n\t\t\tif (ra == WJB_DONE)\n\t\t\t{\n\t\t\t\t/* Decisively equal */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ra == WJB_END_ARRAY || ra == WJB_END_OBJECT)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * There is no array or object to compare at this stage of\n\t\t\t\t * processing.  jbvArray/jbvObject values are compared\n\t\t\t\t * initially, at the WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT\n\t\t\t\t * tokens.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (va.type == vb.type)\n\t\t\t{\n\t\t\t\tswitch (va.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvString:\n\t\t\t\t\tcase jbvNull:\n\t\t\t\t\tcase jbvNumeric:\n\t\t\t\t\tcase jbvBool:\n\t\t\t\t\t\tres = compareJsonbScalarValue(&va, &vb);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvArray:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This could be a \"raw scalar\" pseudo array.  That's\n\t\t\t\t\t\t * a special case here though, since we still want the\n\t\t\t\t\t\t * general type-based comparisons to apply, and as far\n\t\t\t\t\t\t * as we're concerned a pseudo array is just a scalar.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (va.val.array.rawScalar != vb.val.array.rawScalar)\n\t\t\t\t\t\t\tres = (va.val.array.rawScalar) ? -1 : 1;\n\t\t\t\t\t\tif (va.val.array.nElems != vb.val.array.nElems)\n\t\t\t\t\t\t\tres = (va.val.array.nElems > vb.val.array.nElems) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tif (va.val.object.nPairs != vb.val.object.nPairs)\n\t\t\t\t\t\t\tres = (va.val.object.nPairs > vb.val.object.nPairs) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvBinary:\n\t\t\t\t\t\telog(ERROR, \"unexpected jbvBinary value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Type-defined order */\n\t\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * It's safe to assume that the types differed, and that the va\n\t\t\t * and vb values passed were set.\n\t\t\t *\n\t\t\t * If the two values were of the same container type, then there'd\n\t\t\t * have been a chance to observe the variation in the number of\n\t\t\t * elements/pairs (when processing WJB_BEGIN_OBJECT, say). They're\n\t\t\t * either two heterogeneously-typed containers, or a container and\n\t\t\t * some scalar type.\n\t\t\t *\n\t\t\t * We don't have to consider the WJB_END_ARRAY and WJB_END_OBJECT\n\t\t\t * cases here, because we would have seen the corresponding\n\t\t\t * WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT tokens first, and\n\t\t\t * concluded that they don't match.\n\t\t\t */\n\t\t\tAssert(ra != WJB_END_ARRAY && ra != WJB_END_OBJECT);\n\t\t\tAssert(rb != WJB_END_ARRAY && rb != WJB_END_OBJECT);\n\n\t\t\tAssert(va.type != vb.type);\n\t\t\tAssert(va.type != jbvBinary);\n\t\t\tAssert(vb.type != jbvBinary);\n\t\t\t/* Type-defined order */\n\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t}\n\t}\n\twhile (res == 0);\n\n\twhile (ita != NULL)\n\t{\n\t\tJsonbIterator *i = ita->parent;\n\n\t\tpfree(ita);\n\t\tita = i;\n\t}\n\twhile (itb != NULL)\n\t{\n\t\tJsonbIterator *i = itb->parent;\n\n\t\tpfree(itb);\n\t\titb = i;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "1"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_gt(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jba = PG_GETARG_JSONB_P(0);\n\tJsonb\t   *jbb = PG_GETARG_JSONB_P(1);\n\tbool\t\tres;\n\n\tres = (compareJsonbContainers(&jba->root, &jbb->root) > 0);\n\n\tPG_FREE_IF_COPY(jba, 0);\n\tPG_FREE_IF_COPY(jbb, 1);\n\tPG_RETURN_BOOL(res);\n}"
  },
  {
    "function_name": "jsonb_lt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_op.c",
    "lines": "166-178",
    "snippet": "Datum\njsonb_lt(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jba = PG_GETARG_JSONB_P(0);\n\tJsonb\t   *jbb = PG_GETARG_JSONB_P(1);\n\tbool\t\tres;\n\n\tres = (compareJsonbContainers(&jba->root, &jbb->root) < 0);\n\n\tPG_FREE_IF_COPY(jba, 0);\n\tPG_FREE_IF_COPY(jbb, 1);\n\tPG_RETURN_BOOL(res);\n}",
    "includes": [
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "jbb",
            "1"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "jba",
            "0"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compareJsonbContainers",
          "args": [
            "&jba->root",
            "&jbb->root"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "compareJsonbContainers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "177-298",
          "snippet": "int\ncompareJsonbContainers(JsonbContainer *a, JsonbContainer *b)\n{\n\tJsonbIterator *ita,\n\t\t\t   *itb;\n\tint\t\t\tres = 0;\n\n\tita = JsonbIteratorInit(a);\n\titb = JsonbIteratorInit(b);\n\n\tdo\n\t{\n\t\tJsonbValue\tva,\n\t\t\t\t\tvb;\n\t\tJsonbIteratorToken ra,\n\t\t\t\t\trb;\n\n\t\tra = JsonbIteratorNext(&ita, &va, false);\n\t\trb = JsonbIteratorNext(&itb, &vb, false);\n\n\t\tif (ra == rb)\n\t\t{\n\t\t\tif (ra == WJB_DONE)\n\t\t\t{\n\t\t\t\t/* Decisively equal */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ra == WJB_END_ARRAY || ra == WJB_END_OBJECT)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * There is no array or object to compare at this stage of\n\t\t\t\t * processing.  jbvArray/jbvObject values are compared\n\t\t\t\t * initially, at the WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT\n\t\t\t\t * tokens.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (va.type == vb.type)\n\t\t\t{\n\t\t\t\tswitch (va.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvString:\n\t\t\t\t\tcase jbvNull:\n\t\t\t\t\tcase jbvNumeric:\n\t\t\t\t\tcase jbvBool:\n\t\t\t\t\t\tres = compareJsonbScalarValue(&va, &vb);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvArray:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This could be a \"raw scalar\" pseudo array.  That's\n\t\t\t\t\t\t * a special case here though, since we still want the\n\t\t\t\t\t\t * general type-based comparisons to apply, and as far\n\t\t\t\t\t\t * as we're concerned a pseudo array is just a scalar.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (va.val.array.rawScalar != vb.val.array.rawScalar)\n\t\t\t\t\t\t\tres = (va.val.array.rawScalar) ? -1 : 1;\n\t\t\t\t\t\tif (va.val.array.nElems != vb.val.array.nElems)\n\t\t\t\t\t\t\tres = (va.val.array.nElems > vb.val.array.nElems) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tif (va.val.object.nPairs != vb.val.object.nPairs)\n\t\t\t\t\t\t\tres = (va.val.object.nPairs > vb.val.object.nPairs) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvBinary:\n\t\t\t\t\t\telog(ERROR, \"unexpected jbvBinary value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Type-defined order */\n\t\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * It's safe to assume that the types differed, and that the va\n\t\t\t * and vb values passed were set.\n\t\t\t *\n\t\t\t * If the two values were of the same container type, then there'd\n\t\t\t * have been a chance to observe the variation in the number of\n\t\t\t * elements/pairs (when processing WJB_BEGIN_OBJECT, say). They're\n\t\t\t * either two heterogeneously-typed containers, or a container and\n\t\t\t * some scalar type.\n\t\t\t *\n\t\t\t * We don't have to consider the WJB_END_ARRAY and WJB_END_OBJECT\n\t\t\t * cases here, because we would have seen the corresponding\n\t\t\t * WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT tokens first, and\n\t\t\t * concluded that they don't match.\n\t\t\t */\n\t\t\tAssert(ra != WJB_END_ARRAY && ra != WJB_END_OBJECT);\n\t\t\tAssert(rb != WJB_END_ARRAY && rb != WJB_END_OBJECT);\n\n\t\t\tAssert(va.type != vb.type);\n\t\t\tAssert(va.type != jbvBinary);\n\t\t\tAssert(vb.type != jbvBinary);\n\t\t\t/* Type-defined order */\n\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t}\n\t}\n\twhile (res == 0);\n\n\twhile (ita != NULL)\n\t{\n\t\tJsonbIterator *i = ita->parent;\n\n\t\tpfree(ita);\n\t\tita = i;\n\t}\n\twhile (itb != NULL)\n\t{\n\t\tJsonbIterator *i = itb->parent;\n\n\t\tpfree(itb);\n\t\titb = i;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static int\tlengthCompareJsonbStringValue(const void *a, const void *b);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic int\tlengthCompareJsonbStringValue(const void *a, const void *b);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nint\ncompareJsonbContainers(JsonbContainer *a, JsonbContainer *b)\n{\n\tJsonbIterator *ita,\n\t\t\t   *itb;\n\tint\t\t\tres = 0;\n\n\tita = JsonbIteratorInit(a);\n\titb = JsonbIteratorInit(b);\n\n\tdo\n\t{\n\t\tJsonbValue\tva,\n\t\t\t\t\tvb;\n\t\tJsonbIteratorToken ra,\n\t\t\t\t\trb;\n\n\t\tra = JsonbIteratorNext(&ita, &va, false);\n\t\trb = JsonbIteratorNext(&itb, &vb, false);\n\n\t\tif (ra == rb)\n\t\t{\n\t\t\tif (ra == WJB_DONE)\n\t\t\t{\n\t\t\t\t/* Decisively equal */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ra == WJB_END_ARRAY || ra == WJB_END_OBJECT)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * There is no array or object to compare at this stage of\n\t\t\t\t * processing.  jbvArray/jbvObject values are compared\n\t\t\t\t * initially, at the WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT\n\t\t\t\t * tokens.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (va.type == vb.type)\n\t\t\t{\n\t\t\t\tswitch (va.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvString:\n\t\t\t\t\tcase jbvNull:\n\t\t\t\t\tcase jbvNumeric:\n\t\t\t\t\tcase jbvBool:\n\t\t\t\t\t\tres = compareJsonbScalarValue(&va, &vb);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvArray:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This could be a \"raw scalar\" pseudo array.  That's\n\t\t\t\t\t\t * a special case here though, since we still want the\n\t\t\t\t\t\t * general type-based comparisons to apply, and as far\n\t\t\t\t\t\t * as we're concerned a pseudo array is just a scalar.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (va.val.array.rawScalar != vb.val.array.rawScalar)\n\t\t\t\t\t\t\tres = (va.val.array.rawScalar) ? -1 : 1;\n\t\t\t\t\t\tif (va.val.array.nElems != vb.val.array.nElems)\n\t\t\t\t\t\t\tres = (va.val.array.nElems > vb.val.array.nElems) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tif (va.val.object.nPairs != vb.val.object.nPairs)\n\t\t\t\t\t\t\tres = (va.val.object.nPairs > vb.val.object.nPairs) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvBinary:\n\t\t\t\t\t\telog(ERROR, \"unexpected jbvBinary value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Type-defined order */\n\t\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * It's safe to assume that the types differed, and that the va\n\t\t\t * and vb values passed were set.\n\t\t\t *\n\t\t\t * If the two values were of the same container type, then there'd\n\t\t\t * have been a chance to observe the variation in the number of\n\t\t\t * elements/pairs (when processing WJB_BEGIN_OBJECT, say). They're\n\t\t\t * either two heterogeneously-typed containers, or a container and\n\t\t\t * some scalar type.\n\t\t\t *\n\t\t\t * We don't have to consider the WJB_END_ARRAY and WJB_END_OBJECT\n\t\t\t * cases here, because we would have seen the corresponding\n\t\t\t * WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT tokens first, and\n\t\t\t * concluded that they don't match.\n\t\t\t */\n\t\t\tAssert(ra != WJB_END_ARRAY && ra != WJB_END_OBJECT);\n\t\t\tAssert(rb != WJB_END_ARRAY && rb != WJB_END_OBJECT);\n\n\t\t\tAssert(va.type != vb.type);\n\t\t\tAssert(va.type != jbvBinary);\n\t\t\tAssert(vb.type != jbvBinary);\n\t\t\t/* Type-defined order */\n\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t}\n\t}\n\twhile (res == 0);\n\n\twhile (ita != NULL)\n\t{\n\t\tJsonbIterator *i = ita->parent;\n\n\t\tpfree(ita);\n\t\tita = i;\n\t}\n\twhile (itb != NULL)\n\t{\n\t\tJsonbIterator *i = itb->parent;\n\n\t\tpfree(itb);\n\t\titb = i;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "1"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_lt(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jba = PG_GETARG_JSONB_P(0);\n\tJsonb\t   *jbb = PG_GETARG_JSONB_P(1);\n\tbool\t\tres;\n\n\tres = (compareJsonbContainers(&jba->root, &jbb->root) < 0);\n\n\tPG_FREE_IF_COPY(jba, 0);\n\tPG_FREE_IF_COPY(jbb, 1);\n\tPG_RETURN_BOOL(res);\n}"
  },
  {
    "function_name": "jsonb_ne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_op.c",
    "lines": "149-161",
    "snippet": "Datum\njsonb_ne(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jba = PG_GETARG_JSONB_P(0);\n\tJsonb\t   *jbb = PG_GETARG_JSONB_P(1);\n\tbool\t\tres;\n\n\tres = (compareJsonbContainers(&jba->root, &jbb->root) != 0);\n\n\tPG_FREE_IF_COPY(jba, 0);\n\tPG_FREE_IF_COPY(jbb, 1);\n\tPG_RETURN_BOOL(res);\n}",
    "includes": [
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "jbb",
            "1"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "jba",
            "0"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compareJsonbContainers",
          "args": [
            "&jba->root",
            "&jbb->root"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "compareJsonbContainers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "177-298",
          "snippet": "int\ncompareJsonbContainers(JsonbContainer *a, JsonbContainer *b)\n{\n\tJsonbIterator *ita,\n\t\t\t   *itb;\n\tint\t\t\tres = 0;\n\n\tita = JsonbIteratorInit(a);\n\titb = JsonbIteratorInit(b);\n\n\tdo\n\t{\n\t\tJsonbValue\tva,\n\t\t\t\t\tvb;\n\t\tJsonbIteratorToken ra,\n\t\t\t\t\trb;\n\n\t\tra = JsonbIteratorNext(&ita, &va, false);\n\t\trb = JsonbIteratorNext(&itb, &vb, false);\n\n\t\tif (ra == rb)\n\t\t{\n\t\t\tif (ra == WJB_DONE)\n\t\t\t{\n\t\t\t\t/* Decisively equal */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ra == WJB_END_ARRAY || ra == WJB_END_OBJECT)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * There is no array or object to compare at this stage of\n\t\t\t\t * processing.  jbvArray/jbvObject values are compared\n\t\t\t\t * initially, at the WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT\n\t\t\t\t * tokens.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (va.type == vb.type)\n\t\t\t{\n\t\t\t\tswitch (va.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvString:\n\t\t\t\t\tcase jbvNull:\n\t\t\t\t\tcase jbvNumeric:\n\t\t\t\t\tcase jbvBool:\n\t\t\t\t\t\tres = compareJsonbScalarValue(&va, &vb);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvArray:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This could be a \"raw scalar\" pseudo array.  That's\n\t\t\t\t\t\t * a special case here though, since we still want the\n\t\t\t\t\t\t * general type-based comparisons to apply, and as far\n\t\t\t\t\t\t * as we're concerned a pseudo array is just a scalar.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (va.val.array.rawScalar != vb.val.array.rawScalar)\n\t\t\t\t\t\t\tres = (va.val.array.rawScalar) ? -1 : 1;\n\t\t\t\t\t\tif (va.val.array.nElems != vb.val.array.nElems)\n\t\t\t\t\t\t\tres = (va.val.array.nElems > vb.val.array.nElems) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tif (va.val.object.nPairs != vb.val.object.nPairs)\n\t\t\t\t\t\t\tres = (va.val.object.nPairs > vb.val.object.nPairs) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvBinary:\n\t\t\t\t\t\telog(ERROR, \"unexpected jbvBinary value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Type-defined order */\n\t\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * It's safe to assume that the types differed, and that the va\n\t\t\t * and vb values passed were set.\n\t\t\t *\n\t\t\t * If the two values were of the same container type, then there'd\n\t\t\t * have been a chance to observe the variation in the number of\n\t\t\t * elements/pairs (when processing WJB_BEGIN_OBJECT, say). They're\n\t\t\t * either two heterogeneously-typed containers, or a container and\n\t\t\t * some scalar type.\n\t\t\t *\n\t\t\t * We don't have to consider the WJB_END_ARRAY and WJB_END_OBJECT\n\t\t\t * cases here, because we would have seen the corresponding\n\t\t\t * WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT tokens first, and\n\t\t\t * concluded that they don't match.\n\t\t\t */\n\t\t\tAssert(ra != WJB_END_ARRAY && ra != WJB_END_OBJECT);\n\t\t\tAssert(rb != WJB_END_ARRAY && rb != WJB_END_OBJECT);\n\n\t\t\tAssert(va.type != vb.type);\n\t\t\tAssert(va.type != jbvBinary);\n\t\t\tAssert(vb.type != jbvBinary);\n\t\t\t/* Type-defined order */\n\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t}\n\t}\n\twhile (res == 0);\n\n\twhile (ita != NULL)\n\t{\n\t\tJsonbIterator *i = ita->parent;\n\n\t\tpfree(ita);\n\t\tita = i;\n\t}\n\twhile (itb != NULL)\n\t{\n\t\tJsonbIterator *i = itb->parent;\n\n\t\tpfree(itb);\n\t\titb = i;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static int\tlengthCompareJsonbStringValue(const void *a, const void *b);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic bool equalsJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic int\tcompareJsonbScalarValue(JsonbValue *a, JsonbValue *b);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic int\tlengthCompareJsonbStringValue(const void *a, const void *b);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nint\ncompareJsonbContainers(JsonbContainer *a, JsonbContainer *b)\n{\n\tJsonbIterator *ita,\n\t\t\t   *itb;\n\tint\t\t\tres = 0;\n\n\tita = JsonbIteratorInit(a);\n\titb = JsonbIteratorInit(b);\n\n\tdo\n\t{\n\t\tJsonbValue\tva,\n\t\t\t\t\tvb;\n\t\tJsonbIteratorToken ra,\n\t\t\t\t\trb;\n\n\t\tra = JsonbIteratorNext(&ita, &va, false);\n\t\trb = JsonbIteratorNext(&itb, &vb, false);\n\n\t\tif (ra == rb)\n\t\t{\n\t\t\tif (ra == WJB_DONE)\n\t\t\t{\n\t\t\t\t/* Decisively equal */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ra == WJB_END_ARRAY || ra == WJB_END_OBJECT)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * There is no array or object to compare at this stage of\n\t\t\t\t * processing.  jbvArray/jbvObject values are compared\n\t\t\t\t * initially, at the WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT\n\t\t\t\t * tokens.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (va.type == vb.type)\n\t\t\t{\n\t\t\t\tswitch (va.type)\n\t\t\t\t{\n\t\t\t\t\tcase jbvString:\n\t\t\t\t\tcase jbvNull:\n\t\t\t\t\tcase jbvNumeric:\n\t\t\t\t\tcase jbvBool:\n\t\t\t\t\t\tres = compareJsonbScalarValue(&va, &vb);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvArray:\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * This could be a \"raw scalar\" pseudo array.  That's\n\t\t\t\t\t\t * a special case here though, since we still want the\n\t\t\t\t\t\t * general type-based comparisons to apply, and as far\n\t\t\t\t\t\t * as we're concerned a pseudo array is just a scalar.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (va.val.array.rawScalar != vb.val.array.rawScalar)\n\t\t\t\t\t\t\tres = (va.val.array.rawScalar) ? -1 : 1;\n\t\t\t\t\t\tif (va.val.array.nElems != vb.val.array.nElems)\n\t\t\t\t\t\t\tres = (va.val.array.nElems > vb.val.array.nElems) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvObject:\n\t\t\t\t\t\tif (va.val.object.nPairs != vb.val.object.nPairs)\n\t\t\t\t\t\t\tres = (va.val.object.nPairs > vb.val.object.nPairs) ? 1 : -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase jbvBinary:\n\t\t\t\t\t\telog(ERROR, \"unexpected jbvBinary value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Type-defined order */\n\t\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * It's safe to assume that the types differed, and that the va\n\t\t\t * and vb values passed were set.\n\t\t\t *\n\t\t\t * If the two values were of the same container type, then there'd\n\t\t\t * have been a chance to observe the variation in the number of\n\t\t\t * elements/pairs (when processing WJB_BEGIN_OBJECT, say). They're\n\t\t\t * either two heterogeneously-typed containers, or a container and\n\t\t\t * some scalar type.\n\t\t\t *\n\t\t\t * We don't have to consider the WJB_END_ARRAY and WJB_END_OBJECT\n\t\t\t * cases here, because we would have seen the corresponding\n\t\t\t * WJB_BEGIN_ARRAY and WJB_BEGIN_OBJECT tokens first, and\n\t\t\t * concluded that they don't match.\n\t\t\t */\n\t\t\tAssert(ra != WJB_END_ARRAY && ra != WJB_END_OBJECT);\n\t\t\tAssert(rb != WJB_END_ARRAY && rb != WJB_END_OBJECT);\n\n\t\t\tAssert(va.type != vb.type);\n\t\t\tAssert(va.type != jbvBinary);\n\t\t\tAssert(vb.type != jbvBinary);\n\t\t\t/* Type-defined order */\n\t\t\tres = (va.type > vb.type) ? 1 : -1;\n\t\t}\n\t}\n\twhile (res == 0);\n\n\twhile (ita != NULL)\n\t{\n\t\tJsonbIterator *i = ita->parent;\n\n\t\tpfree(ita);\n\t\tita = i;\n\t}\n\twhile (itb != NULL)\n\t{\n\t\tJsonbIterator *i = itb->parent;\n\n\t\tpfree(itb);\n\t\titb = i;\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "1"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_ne(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jba = PG_GETARG_JSONB_P(0);\n\tJsonb\t   *jbb = PG_GETARG_JSONB_P(1);\n\tbool\t\tres;\n\n\tres = (compareJsonbContainers(&jba->root, &jbb->root) != 0);\n\n\tPG_FREE_IF_COPY(jba, 0);\n\tPG_FREE_IF_COPY(jbb, 1);\n\tPG_RETURN_BOOL(res);\n}"
  },
  {
    "function_name": "jsonb_contained",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_op.c",
    "lines": "130-147",
    "snippet": "Datum\njsonb_contained(PG_FUNCTION_ARGS)\n{\n\t/* Commutator of \"contains\" */\n\tJsonb\t   *tmpl = PG_GETARG_JSONB_P(0);\n\tJsonb\t   *val = PG_GETARG_JSONB_P(1);\n\n\tJsonbIterator *it1,\n\t\t\t   *it2;\n\n\tif (JB_ROOT_IS_OBJECT(val) != JB_ROOT_IS_OBJECT(tmpl))\n\t\tPG_RETURN_BOOL(false);\n\n\tit1 = JsonbIteratorInit(&val->root);\n\tit2 = JsonbIteratorInit(&tmpl->root);\n\n\tPG_RETURN_BOOL(JsonbDeepContains(&it1, &it2));\n}",
    "includes": [
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "JsonbDeepContains(&it1, &it2)"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbDeepContains",
          "args": [
            "&it1",
            "&it2"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbDeepContains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "962-1204",
          "snippet": "bool\nJsonbDeepContains(JsonbIterator **val, JsonbIterator **mContained)\n{\n\tJsonbValue\tvval,\n\t\t\t\tvcontained;\n\tJsonbIteratorToken rval,\n\t\t\t\trcont;\n\n\t/*\n\t * Guard against stack overflow due to overly complex Jsonb.\n\t *\n\t * Functions called here independently take this precaution, but that\n\t * might not be sufficient since this is also a recursive function.\n\t */\n\tcheck_stack_depth();\n\n\trval = JsonbIteratorNext(val, &vval, false);\n\trcont = JsonbIteratorNext(mContained, &vcontained, false);\n\n\tif (rval != rcont)\n\t{\n\t\t/*\n\t\t * The differing return values can immediately be taken as indicating\n\t\t * two differing container types at this nesting level, which is\n\t\t * sufficient reason to give up entirely (but it should be the case\n\t\t * that they're both some container type).\n\t\t */\n\t\tAssert(rval == WJB_BEGIN_OBJECT || rval == WJB_BEGIN_ARRAY);\n\t\tAssert(rcont == WJB_BEGIN_OBJECT || rcont == WJB_BEGIN_ARRAY);\n\t\treturn false;\n\t}\n\telse if (rcont == WJB_BEGIN_OBJECT)\n\t{\n\t\tAssert(vval.type == jbvObject);\n\t\tAssert(vcontained.type == jbvObject);\n\n\t\t/*\n\t\t * If the lhs has fewer pairs than the rhs, it can't possibly contain\n\t\t * the rhs.  (This conclusion is safe only because we de-duplicate\n\t\t * keys in all Jsonb objects; thus there can be no corresponding\n\t\t * optimization in the array case.)  The case probably won't arise\n\t\t * often, but since it's such a cheap check we may as well make it.\n\t\t */\n\t\tif (vval.val.object.nPairs < vcontained.val.object.nPairs)\n\t\t\treturn false;\n\n\t\t/* Work through rhs \"is it contained within?\" object */\n\t\tfor (;;)\n\t\t{\n\t\t\tJsonbValue *lhsVal; /* lhsVal is from pair in lhs object */\n\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, false);\n\n\t\t\t/*\n\t\t\t * When we get through caller's rhs \"is it contained within?\"\n\t\t\t * object without failing to find one of its values, it's\n\t\t\t * contained.\n\t\t\t */\n\t\t\tif (rcont == WJB_END_OBJECT)\n\t\t\t\treturn true;\n\n\t\t\tAssert(rcont == WJB_KEY);\n\n\t\t\t/* First, find value by key... */\n\t\t\tlhsVal = findJsonbValueFromContainer((*val)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t &vcontained);\n\n\t\t\tif (!lhsVal)\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * ...at this stage it is apparent that there is at least a key\n\t\t\t * match for this rhs pair.\n\t\t\t */\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, true);\n\n\t\t\tAssert(rcont == WJB_VALUE);\n\n\t\t\t/*\n\t\t\t * Compare rhs pair's value with lhs pair's value just found using\n\t\t\t * key\n\t\t\t */\n\t\t\tif (lhsVal->type != vcontained.type)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (IsAJsonbScalar(lhsVal))\n\t\t\t{\n\t\t\t\tif (!equalsJsonbScalarValue(lhsVal, &vcontained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Nested container value (object or array) */\n\t\t\t\tJsonbIterator *nestval,\n\t\t\t\t\t\t   *nestContained;\n\n\t\t\t\tAssert(lhsVal->type == jbvBinary);\n\t\t\t\tAssert(vcontained.type == jbvBinary);\n\n\t\t\t\tnestval = JsonbIteratorInit(lhsVal->val.binary.data);\n\t\t\t\tnestContained = JsonbIteratorInit(vcontained.val.binary.data);\n\n\t\t\t\t/*\n\t\t\t\t * Match \"value\" side of rhs datum object's pair recursively.\n\t\t\t\t * It's a nested structure.\n\t\t\t\t *\n\t\t\t\t * Note that nesting still has to \"match up\" at the right\n\t\t\t\t * nesting sub-levels.  However, there need only be zero or\n\t\t\t\t * more matching pairs (or elements) at each nesting level\n\t\t\t\t * (provided the *rhs* pairs/elements *all* match on each\n\t\t\t\t * level), which enables searching nested structures for a\n\t\t\t\t * single String or other primitive type sub-datum quite\n\t\t\t\t * effectively (provided the user constructed the rhs nested\n\t\t\t\t * structure such that we \"know where to look\").\n\t\t\t\t *\n\t\t\t\t * In other words, the mapping of container nodes in the rhs\n\t\t\t\t * \"vcontained\" Jsonb to internal nodes on the lhs is\n\t\t\t\t * injective, and parent-child edges on the rhs must be mapped\n\t\t\t\t * to parent-child edges on the lhs to satisfy the condition\n\t\t\t\t * of containment (plus of course the mapped nodes must be\n\t\t\t\t * equal).\n\t\t\t\t */\n\t\t\t\tif (!JsonbDeepContains(&nestval, &nestContained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\telse if (rcont == WJB_BEGIN_ARRAY)\n\t{\n\t\tJsonbValue *lhsConts = NULL;\n\t\tuint32\t\tnLhsElems = vval.val.array.nElems;\n\n\t\tAssert(vval.type == jbvArray);\n\t\tAssert(vcontained.type == jbvArray);\n\n\t\t/*\n\t\t * Handle distinction between \"raw scalar\" pseudo arrays, and real\n\t\t * arrays.\n\t\t *\n\t\t * A raw scalar may contain another raw scalar, and an array may\n\t\t * contain a raw scalar, but a raw scalar may not contain an array. We\n\t\t * don't do something like this for the object case, since objects can\n\t\t * only contain pairs, never raw scalars (a pair is represented by an\n\t\t * rhs object argument with a single contained pair).\n\t\t */\n\t\tif (vval.val.array.rawScalar && !vcontained.val.array.rawScalar)\n\t\t\treturn false;\n\n\t\t/* Work through rhs \"is it contained within?\" array */\n\t\tfor (;;)\n\t\t{\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, true);\n\n\t\t\t/*\n\t\t\t * When we get through caller's rhs \"is it contained within?\"\n\t\t\t * array without failing to find one of its values, it's\n\t\t\t * contained.\n\t\t\t */\n\t\t\tif (rcont == WJB_END_ARRAY)\n\t\t\t\treturn true;\n\n\t\t\tAssert(rcont == WJB_ELEM);\n\n\t\t\tif (IsAJsonbScalar(&vcontained))\n\t\t\t{\n\t\t\t\tif (!findJsonbValueFromContainer((*val)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t JB_FARRAY,\n\t\t\t\t\t\t\t\t\t\t\t\t &vcontained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuint32\t\ti;\n\n\t\t\t\t/*\n\t\t\t\t * If this is first container found in rhs array (at this\n\t\t\t\t * depth), initialize temp lhs array of containers\n\t\t\t\t */\n\t\t\t\tif (lhsConts == NULL)\n\t\t\t\t{\n\t\t\t\t\tuint32\t\tj = 0;\n\n\t\t\t\t\t/* Make room for all possible values */\n\t\t\t\t\tlhsConts = palloc(sizeof(JsonbValue) * nLhsElems);\n\n\t\t\t\t\tfor (i = 0; i < nLhsElems; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Store all lhs elements in temp array */\n\t\t\t\t\t\trcont = JsonbIteratorNext(val, &vval, true);\n\t\t\t\t\t\tAssert(rcont == WJB_ELEM);\n\n\t\t\t\t\t\tif (vval.type == jbvBinary)\n\t\t\t\t\t\t\tlhsConts[j++] = vval;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* No container elements in temp array, so give up now */\n\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t/* We may have only partially filled array */\n\t\t\t\t\tnLhsElems = j;\n\t\t\t\t}\n\n\t\t\t\t/* XXX: Nested array containment is O(N^2) */\n\t\t\t\tfor (i = 0; i < nLhsElems; i++)\n\t\t\t\t{\n\t\t\t\t\t/* Nested container value (object or array) */\n\t\t\t\t\tJsonbIterator *nestval,\n\t\t\t\t\t\t\t   *nestContained;\n\t\t\t\t\tbool\t\tcontains;\n\n\t\t\t\t\tnestval = JsonbIteratorInit(lhsConts[i].val.binary.data);\n\t\t\t\t\tnestContained = JsonbIteratorInit(vcontained.val.binary.data);\n\n\t\t\t\t\tcontains = JsonbDeepContains(&nestval, &nestContained);\n\n\t\t\t\t\tif (nestval)\n\t\t\t\t\t\tpfree(nestval);\n\t\t\t\t\tif (nestContained)\n\t\t\t\t\t\tpfree(nestContained);\n\t\t\t\t\tif (contains)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Report rhs container value is not contained if couldn't\n\t\t\t\t * match rhs container to *some* lhs cont\n\t\t\t\t */\n\t\t\t\tif (i == nLhsElems)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"invalid jsonb container type\");\n\t}\n\n\telog(ERROR, \"unexpectedly fell off end of jsonb container\");\n\treturn false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nbool\nJsonbDeepContains(JsonbIterator **val, JsonbIterator **mContained)\n{\n\tJsonbValue\tvval,\n\t\t\t\tvcontained;\n\tJsonbIteratorToken rval,\n\t\t\t\trcont;\n\n\t/*\n\t * Guard against stack overflow due to overly complex Jsonb.\n\t *\n\t * Functions called here independently take this precaution, but that\n\t * might not be sufficient since this is also a recursive function.\n\t */\n\tcheck_stack_depth();\n\n\trval = JsonbIteratorNext(val, &vval, false);\n\trcont = JsonbIteratorNext(mContained, &vcontained, false);\n\n\tif (rval != rcont)\n\t{\n\t\t/*\n\t\t * The differing return values can immediately be taken as indicating\n\t\t * two differing container types at this nesting level, which is\n\t\t * sufficient reason to give up entirely (but it should be the case\n\t\t * that they're both some container type).\n\t\t */\n\t\tAssert(rval == WJB_BEGIN_OBJECT || rval == WJB_BEGIN_ARRAY);\n\t\tAssert(rcont == WJB_BEGIN_OBJECT || rcont == WJB_BEGIN_ARRAY);\n\t\treturn false;\n\t}\n\telse if (rcont == WJB_BEGIN_OBJECT)\n\t{\n\t\tAssert(vval.type == jbvObject);\n\t\tAssert(vcontained.type == jbvObject);\n\n\t\t/*\n\t\t * If the lhs has fewer pairs than the rhs, it can't possibly contain\n\t\t * the rhs.  (This conclusion is safe only because we de-duplicate\n\t\t * keys in all Jsonb objects; thus there can be no corresponding\n\t\t * optimization in the array case.)  The case probably won't arise\n\t\t * often, but since it's such a cheap check we may as well make it.\n\t\t */\n\t\tif (vval.val.object.nPairs < vcontained.val.object.nPairs)\n\t\t\treturn false;\n\n\t\t/* Work through rhs \"is it contained within?\" object */\n\t\tfor (;;)\n\t\t{\n\t\t\tJsonbValue *lhsVal; /* lhsVal is from pair in lhs object */\n\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, false);\n\n\t\t\t/*\n\t\t\t * When we get through caller's rhs \"is it contained within?\"\n\t\t\t * object without failing to find one of its values, it's\n\t\t\t * contained.\n\t\t\t */\n\t\t\tif (rcont == WJB_END_OBJECT)\n\t\t\t\treturn true;\n\n\t\t\tAssert(rcont == WJB_KEY);\n\n\t\t\t/* First, find value by key... */\n\t\t\tlhsVal = findJsonbValueFromContainer((*val)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t &vcontained);\n\n\t\t\tif (!lhsVal)\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * ...at this stage it is apparent that there is at least a key\n\t\t\t * match for this rhs pair.\n\t\t\t */\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, true);\n\n\t\t\tAssert(rcont == WJB_VALUE);\n\n\t\t\t/*\n\t\t\t * Compare rhs pair's value with lhs pair's value just found using\n\t\t\t * key\n\t\t\t */\n\t\t\tif (lhsVal->type != vcontained.type)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (IsAJsonbScalar(lhsVal))\n\t\t\t{\n\t\t\t\tif (!equalsJsonbScalarValue(lhsVal, &vcontained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Nested container value (object or array) */\n\t\t\t\tJsonbIterator *nestval,\n\t\t\t\t\t\t   *nestContained;\n\n\t\t\t\tAssert(lhsVal->type == jbvBinary);\n\t\t\t\tAssert(vcontained.type == jbvBinary);\n\n\t\t\t\tnestval = JsonbIteratorInit(lhsVal->val.binary.data);\n\t\t\t\tnestContained = JsonbIteratorInit(vcontained.val.binary.data);\n\n\t\t\t\t/*\n\t\t\t\t * Match \"value\" side of rhs datum object's pair recursively.\n\t\t\t\t * It's a nested structure.\n\t\t\t\t *\n\t\t\t\t * Note that nesting still has to \"match up\" at the right\n\t\t\t\t * nesting sub-levels.  However, there need only be zero or\n\t\t\t\t * more matching pairs (or elements) at each nesting level\n\t\t\t\t * (provided the *rhs* pairs/elements *all* match on each\n\t\t\t\t * level), which enables searching nested structures for a\n\t\t\t\t * single String or other primitive type sub-datum quite\n\t\t\t\t * effectively (provided the user constructed the rhs nested\n\t\t\t\t * structure such that we \"know where to look\").\n\t\t\t\t *\n\t\t\t\t * In other words, the mapping of container nodes in the rhs\n\t\t\t\t * \"vcontained\" Jsonb to internal nodes on the lhs is\n\t\t\t\t * injective, and parent-child edges on the rhs must be mapped\n\t\t\t\t * to parent-child edges on the lhs to satisfy the condition\n\t\t\t\t * of containment (plus of course the mapped nodes must be\n\t\t\t\t * equal).\n\t\t\t\t */\n\t\t\t\tif (!JsonbDeepContains(&nestval, &nestContained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\telse if (rcont == WJB_BEGIN_ARRAY)\n\t{\n\t\tJsonbValue *lhsConts = NULL;\n\t\tuint32\t\tnLhsElems = vval.val.array.nElems;\n\n\t\tAssert(vval.type == jbvArray);\n\t\tAssert(vcontained.type == jbvArray);\n\n\t\t/*\n\t\t * Handle distinction between \"raw scalar\" pseudo arrays, and real\n\t\t * arrays.\n\t\t *\n\t\t * A raw scalar may contain another raw scalar, and an array may\n\t\t * contain a raw scalar, but a raw scalar may not contain an array. We\n\t\t * don't do something like this for the object case, since objects can\n\t\t * only contain pairs, never raw scalars (a pair is represented by an\n\t\t * rhs object argument with a single contained pair).\n\t\t */\n\t\tif (vval.val.array.rawScalar && !vcontained.val.array.rawScalar)\n\t\t\treturn false;\n\n\t\t/* Work through rhs \"is it contained within?\" array */\n\t\tfor (;;)\n\t\t{\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, true);\n\n\t\t\t/*\n\t\t\t * When we get through caller's rhs \"is it contained within?\"\n\t\t\t * array without failing to find one of its values, it's\n\t\t\t * contained.\n\t\t\t */\n\t\t\tif (rcont == WJB_END_ARRAY)\n\t\t\t\treturn true;\n\n\t\t\tAssert(rcont == WJB_ELEM);\n\n\t\t\tif (IsAJsonbScalar(&vcontained))\n\t\t\t{\n\t\t\t\tif (!findJsonbValueFromContainer((*val)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t JB_FARRAY,\n\t\t\t\t\t\t\t\t\t\t\t\t &vcontained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuint32\t\ti;\n\n\t\t\t\t/*\n\t\t\t\t * If this is first container found in rhs array (at this\n\t\t\t\t * depth), initialize temp lhs array of containers\n\t\t\t\t */\n\t\t\t\tif (lhsConts == NULL)\n\t\t\t\t{\n\t\t\t\t\tuint32\t\tj = 0;\n\n\t\t\t\t\t/* Make room for all possible values */\n\t\t\t\t\tlhsConts = palloc(sizeof(JsonbValue) * nLhsElems);\n\n\t\t\t\t\tfor (i = 0; i < nLhsElems; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Store all lhs elements in temp array */\n\t\t\t\t\t\trcont = JsonbIteratorNext(val, &vval, true);\n\t\t\t\t\t\tAssert(rcont == WJB_ELEM);\n\n\t\t\t\t\t\tif (vval.type == jbvBinary)\n\t\t\t\t\t\t\tlhsConts[j++] = vval;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* No container elements in temp array, so give up now */\n\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t/* We may have only partially filled array */\n\t\t\t\t\tnLhsElems = j;\n\t\t\t\t}\n\n\t\t\t\t/* XXX: Nested array containment is O(N^2) */\n\t\t\t\tfor (i = 0; i < nLhsElems; i++)\n\t\t\t\t{\n\t\t\t\t\t/* Nested container value (object or array) */\n\t\t\t\t\tJsonbIterator *nestval,\n\t\t\t\t\t\t\t   *nestContained;\n\t\t\t\t\tbool\t\tcontains;\n\n\t\t\t\t\tnestval = JsonbIteratorInit(lhsConts[i].val.binary.data);\n\t\t\t\t\tnestContained = JsonbIteratorInit(vcontained.val.binary.data);\n\n\t\t\t\t\tcontains = JsonbDeepContains(&nestval, &nestContained);\n\n\t\t\t\t\tif (nestval)\n\t\t\t\t\t\tpfree(nestval);\n\t\t\t\t\tif (nestContained)\n\t\t\t\t\t\tpfree(nestContained);\n\t\t\t\t\tif (contains)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Report rhs container value is not contained if couldn't\n\t\t\t\t * match rhs container to *some* lhs cont\n\t\t\t\t */\n\t\t\t\tif (i == nLhsElems)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"invalid jsonb container type\");\n\t}\n\n\telog(ERROR, \"unexpectedly fell off end of jsonb container\");\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&tmpl->root"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_OBJECT",
          "args": [
            "tmpl"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_OBJECT",
          "args": [
            "val"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "1"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_contained(PG_FUNCTION_ARGS)\n{\n\t/* Commutator of \"contains\" */\n\tJsonb\t   *tmpl = PG_GETARG_JSONB_P(0);\n\tJsonb\t   *val = PG_GETARG_JSONB_P(1);\n\n\tJsonbIterator *it1,\n\t\t\t   *it2;\n\n\tif (JB_ROOT_IS_OBJECT(val) != JB_ROOT_IS_OBJECT(tmpl))\n\t\tPG_RETURN_BOOL(false);\n\n\tit1 = JsonbIteratorInit(&val->root);\n\tit2 = JsonbIteratorInit(&tmpl->root);\n\n\tPG_RETURN_BOOL(JsonbDeepContains(&it1, &it2));\n}"
  },
  {
    "function_name": "jsonb_contains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_op.c",
    "lines": "112-128",
    "snippet": "Datum\njsonb_contains(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *val = PG_GETARG_JSONB_P(0);\n\tJsonb\t   *tmpl = PG_GETARG_JSONB_P(1);\n\n\tJsonbIterator *it1,\n\t\t\t   *it2;\n\n\tif (JB_ROOT_IS_OBJECT(val) != JB_ROOT_IS_OBJECT(tmpl))\n\t\tPG_RETURN_BOOL(false);\n\n\tit1 = JsonbIteratorInit(&val->root);\n\tit2 = JsonbIteratorInit(&tmpl->root);\n\n\tPG_RETURN_BOOL(JsonbDeepContains(&it1, &it2));\n}",
    "includes": [
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "JsonbDeepContains(&it1, &it2)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JsonbDeepContains",
          "args": [
            "&it1",
            "&it2"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbDeepContains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "962-1204",
          "snippet": "bool\nJsonbDeepContains(JsonbIterator **val, JsonbIterator **mContained)\n{\n\tJsonbValue\tvval,\n\t\t\t\tvcontained;\n\tJsonbIteratorToken rval,\n\t\t\t\trcont;\n\n\t/*\n\t * Guard against stack overflow due to overly complex Jsonb.\n\t *\n\t * Functions called here independently take this precaution, but that\n\t * might not be sufficient since this is also a recursive function.\n\t */\n\tcheck_stack_depth();\n\n\trval = JsonbIteratorNext(val, &vval, false);\n\trcont = JsonbIteratorNext(mContained, &vcontained, false);\n\n\tif (rval != rcont)\n\t{\n\t\t/*\n\t\t * The differing return values can immediately be taken as indicating\n\t\t * two differing container types at this nesting level, which is\n\t\t * sufficient reason to give up entirely (but it should be the case\n\t\t * that they're both some container type).\n\t\t */\n\t\tAssert(rval == WJB_BEGIN_OBJECT || rval == WJB_BEGIN_ARRAY);\n\t\tAssert(rcont == WJB_BEGIN_OBJECT || rcont == WJB_BEGIN_ARRAY);\n\t\treturn false;\n\t}\n\telse if (rcont == WJB_BEGIN_OBJECT)\n\t{\n\t\tAssert(vval.type == jbvObject);\n\t\tAssert(vcontained.type == jbvObject);\n\n\t\t/*\n\t\t * If the lhs has fewer pairs than the rhs, it can't possibly contain\n\t\t * the rhs.  (This conclusion is safe only because we de-duplicate\n\t\t * keys in all Jsonb objects; thus there can be no corresponding\n\t\t * optimization in the array case.)  The case probably won't arise\n\t\t * often, but since it's such a cheap check we may as well make it.\n\t\t */\n\t\tif (vval.val.object.nPairs < vcontained.val.object.nPairs)\n\t\t\treturn false;\n\n\t\t/* Work through rhs \"is it contained within?\" object */\n\t\tfor (;;)\n\t\t{\n\t\t\tJsonbValue *lhsVal; /* lhsVal is from pair in lhs object */\n\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, false);\n\n\t\t\t/*\n\t\t\t * When we get through caller's rhs \"is it contained within?\"\n\t\t\t * object without failing to find one of its values, it's\n\t\t\t * contained.\n\t\t\t */\n\t\t\tif (rcont == WJB_END_OBJECT)\n\t\t\t\treturn true;\n\n\t\t\tAssert(rcont == WJB_KEY);\n\n\t\t\t/* First, find value by key... */\n\t\t\tlhsVal = findJsonbValueFromContainer((*val)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t &vcontained);\n\n\t\t\tif (!lhsVal)\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * ...at this stage it is apparent that there is at least a key\n\t\t\t * match for this rhs pair.\n\t\t\t */\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, true);\n\n\t\t\tAssert(rcont == WJB_VALUE);\n\n\t\t\t/*\n\t\t\t * Compare rhs pair's value with lhs pair's value just found using\n\t\t\t * key\n\t\t\t */\n\t\t\tif (lhsVal->type != vcontained.type)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (IsAJsonbScalar(lhsVal))\n\t\t\t{\n\t\t\t\tif (!equalsJsonbScalarValue(lhsVal, &vcontained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Nested container value (object or array) */\n\t\t\t\tJsonbIterator *nestval,\n\t\t\t\t\t\t   *nestContained;\n\n\t\t\t\tAssert(lhsVal->type == jbvBinary);\n\t\t\t\tAssert(vcontained.type == jbvBinary);\n\n\t\t\t\tnestval = JsonbIteratorInit(lhsVal->val.binary.data);\n\t\t\t\tnestContained = JsonbIteratorInit(vcontained.val.binary.data);\n\n\t\t\t\t/*\n\t\t\t\t * Match \"value\" side of rhs datum object's pair recursively.\n\t\t\t\t * It's a nested structure.\n\t\t\t\t *\n\t\t\t\t * Note that nesting still has to \"match up\" at the right\n\t\t\t\t * nesting sub-levels.  However, there need only be zero or\n\t\t\t\t * more matching pairs (or elements) at each nesting level\n\t\t\t\t * (provided the *rhs* pairs/elements *all* match on each\n\t\t\t\t * level), which enables searching nested structures for a\n\t\t\t\t * single String or other primitive type sub-datum quite\n\t\t\t\t * effectively (provided the user constructed the rhs nested\n\t\t\t\t * structure such that we \"know where to look\").\n\t\t\t\t *\n\t\t\t\t * In other words, the mapping of container nodes in the rhs\n\t\t\t\t * \"vcontained\" Jsonb to internal nodes on the lhs is\n\t\t\t\t * injective, and parent-child edges on the rhs must be mapped\n\t\t\t\t * to parent-child edges on the lhs to satisfy the condition\n\t\t\t\t * of containment (plus of course the mapped nodes must be\n\t\t\t\t * equal).\n\t\t\t\t */\n\t\t\t\tif (!JsonbDeepContains(&nestval, &nestContained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\telse if (rcont == WJB_BEGIN_ARRAY)\n\t{\n\t\tJsonbValue *lhsConts = NULL;\n\t\tuint32\t\tnLhsElems = vval.val.array.nElems;\n\n\t\tAssert(vval.type == jbvArray);\n\t\tAssert(vcontained.type == jbvArray);\n\n\t\t/*\n\t\t * Handle distinction between \"raw scalar\" pseudo arrays, and real\n\t\t * arrays.\n\t\t *\n\t\t * A raw scalar may contain another raw scalar, and an array may\n\t\t * contain a raw scalar, but a raw scalar may not contain an array. We\n\t\t * don't do something like this for the object case, since objects can\n\t\t * only contain pairs, never raw scalars (a pair is represented by an\n\t\t * rhs object argument with a single contained pair).\n\t\t */\n\t\tif (vval.val.array.rawScalar && !vcontained.val.array.rawScalar)\n\t\t\treturn false;\n\n\t\t/* Work through rhs \"is it contained within?\" array */\n\t\tfor (;;)\n\t\t{\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, true);\n\n\t\t\t/*\n\t\t\t * When we get through caller's rhs \"is it contained within?\"\n\t\t\t * array without failing to find one of its values, it's\n\t\t\t * contained.\n\t\t\t */\n\t\t\tif (rcont == WJB_END_ARRAY)\n\t\t\t\treturn true;\n\n\t\t\tAssert(rcont == WJB_ELEM);\n\n\t\t\tif (IsAJsonbScalar(&vcontained))\n\t\t\t{\n\t\t\t\tif (!findJsonbValueFromContainer((*val)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t JB_FARRAY,\n\t\t\t\t\t\t\t\t\t\t\t\t &vcontained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuint32\t\ti;\n\n\t\t\t\t/*\n\t\t\t\t * If this is first container found in rhs array (at this\n\t\t\t\t * depth), initialize temp lhs array of containers\n\t\t\t\t */\n\t\t\t\tif (lhsConts == NULL)\n\t\t\t\t{\n\t\t\t\t\tuint32\t\tj = 0;\n\n\t\t\t\t\t/* Make room for all possible values */\n\t\t\t\t\tlhsConts = palloc(sizeof(JsonbValue) * nLhsElems);\n\n\t\t\t\t\tfor (i = 0; i < nLhsElems; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Store all lhs elements in temp array */\n\t\t\t\t\t\trcont = JsonbIteratorNext(val, &vval, true);\n\t\t\t\t\t\tAssert(rcont == WJB_ELEM);\n\n\t\t\t\t\t\tif (vval.type == jbvBinary)\n\t\t\t\t\t\t\tlhsConts[j++] = vval;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* No container elements in temp array, so give up now */\n\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t/* We may have only partially filled array */\n\t\t\t\t\tnLhsElems = j;\n\t\t\t\t}\n\n\t\t\t\t/* XXX: Nested array containment is O(N^2) */\n\t\t\t\tfor (i = 0; i < nLhsElems; i++)\n\t\t\t\t{\n\t\t\t\t\t/* Nested container value (object or array) */\n\t\t\t\t\tJsonbIterator *nestval,\n\t\t\t\t\t\t\t   *nestContained;\n\t\t\t\t\tbool\t\tcontains;\n\n\t\t\t\t\tnestval = JsonbIteratorInit(lhsConts[i].val.binary.data);\n\t\t\t\t\tnestContained = JsonbIteratorInit(vcontained.val.binary.data);\n\n\t\t\t\t\tcontains = JsonbDeepContains(&nestval, &nestContained);\n\n\t\t\t\t\tif (nestval)\n\t\t\t\t\t\tpfree(nestval);\n\t\t\t\t\tif (nestContained)\n\t\t\t\t\t\tpfree(nestContained);\n\t\t\t\t\tif (contains)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Report rhs container value is not contained if couldn't\n\t\t\t\t * match rhs container to *some* lhs cont\n\t\t\t\t */\n\t\t\t\tif (i == nLhsElems)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"invalid jsonb container type\");\n\t}\n\n\telog(ERROR, \"unexpectedly fell off end of jsonb container\");\n\treturn false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);",
            "static JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);",
            "static JsonbIterator *freeAndGetParent(JsonbIterator *it);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic void convertJsonbValue(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic void convertJsonbObject(StringInfo buffer, JEntry *header, JsonbValue *val, int level);\nstatic JsonbIterator *iteratorFromContainer(JsonbContainer *container, JsonbIterator *parent);\nstatic JsonbIterator *freeAndGetParent(JsonbIterator *it);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nbool\nJsonbDeepContains(JsonbIterator **val, JsonbIterator **mContained)\n{\n\tJsonbValue\tvval,\n\t\t\t\tvcontained;\n\tJsonbIteratorToken rval,\n\t\t\t\trcont;\n\n\t/*\n\t * Guard against stack overflow due to overly complex Jsonb.\n\t *\n\t * Functions called here independently take this precaution, but that\n\t * might not be sufficient since this is also a recursive function.\n\t */\n\tcheck_stack_depth();\n\n\trval = JsonbIteratorNext(val, &vval, false);\n\trcont = JsonbIteratorNext(mContained, &vcontained, false);\n\n\tif (rval != rcont)\n\t{\n\t\t/*\n\t\t * The differing return values can immediately be taken as indicating\n\t\t * two differing container types at this nesting level, which is\n\t\t * sufficient reason to give up entirely (but it should be the case\n\t\t * that they're both some container type).\n\t\t */\n\t\tAssert(rval == WJB_BEGIN_OBJECT || rval == WJB_BEGIN_ARRAY);\n\t\tAssert(rcont == WJB_BEGIN_OBJECT || rcont == WJB_BEGIN_ARRAY);\n\t\treturn false;\n\t}\n\telse if (rcont == WJB_BEGIN_OBJECT)\n\t{\n\t\tAssert(vval.type == jbvObject);\n\t\tAssert(vcontained.type == jbvObject);\n\n\t\t/*\n\t\t * If the lhs has fewer pairs than the rhs, it can't possibly contain\n\t\t * the rhs.  (This conclusion is safe only because we de-duplicate\n\t\t * keys in all Jsonb objects; thus there can be no corresponding\n\t\t * optimization in the array case.)  The case probably won't arise\n\t\t * often, but since it's such a cheap check we may as well make it.\n\t\t */\n\t\tif (vval.val.object.nPairs < vcontained.val.object.nPairs)\n\t\t\treturn false;\n\n\t\t/* Work through rhs \"is it contained within?\" object */\n\t\tfor (;;)\n\t\t{\n\t\t\tJsonbValue *lhsVal; /* lhsVal is from pair in lhs object */\n\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, false);\n\n\t\t\t/*\n\t\t\t * When we get through caller's rhs \"is it contained within?\"\n\t\t\t * object without failing to find one of its values, it's\n\t\t\t * contained.\n\t\t\t */\n\t\t\tif (rcont == WJB_END_OBJECT)\n\t\t\t\treturn true;\n\n\t\t\tAssert(rcont == WJB_KEY);\n\n\t\t\t/* First, find value by key... */\n\t\t\tlhsVal = findJsonbValueFromContainer((*val)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t JB_FOBJECT,\n\t\t\t\t\t\t\t\t\t\t\t\t &vcontained);\n\n\t\t\tif (!lhsVal)\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * ...at this stage it is apparent that there is at least a key\n\t\t\t * match for this rhs pair.\n\t\t\t */\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, true);\n\n\t\t\tAssert(rcont == WJB_VALUE);\n\n\t\t\t/*\n\t\t\t * Compare rhs pair's value with lhs pair's value just found using\n\t\t\t * key\n\t\t\t */\n\t\t\tif (lhsVal->type != vcontained.type)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (IsAJsonbScalar(lhsVal))\n\t\t\t{\n\t\t\t\tif (!equalsJsonbScalarValue(lhsVal, &vcontained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* Nested container value (object or array) */\n\t\t\t\tJsonbIterator *nestval,\n\t\t\t\t\t\t   *nestContained;\n\n\t\t\t\tAssert(lhsVal->type == jbvBinary);\n\t\t\t\tAssert(vcontained.type == jbvBinary);\n\n\t\t\t\tnestval = JsonbIteratorInit(lhsVal->val.binary.data);\n\t\t\t\tnestContained = JsonbIteratorInit(vcontained.val.binary.data);\n\n\t\t\t\t/*\n\t\t\t\t * Match \"value\" side of rhs datum object's pair recursively.\n\t\t\t\t * It's a nested structure.\n\t\t\t\t *\n\t\t\t\t * Note that nesting still has to \"match up\" at the right\n\t\t\t\t * nesting sub-levels.  However, there need only be zero or\n\t\t\t\t * more matching pairs (or elements) at each nesting level\n\t\t\t\t * (provided the *rhs* pairs/elements *all* match on each\n\t\t\t\t * level), which enables searching nested structures for a\n\t\t\t\t * single String or other primitive type sub-datum quite\n\t\t\t\t * effectively (provided the user constructed the rhs nested\n\t\t\t\t * structure such that we \"know where to look\").\n\t\t\t\t *\n\t\t\t\t * In other words, the mapping of container nodes in the rhs\n\t\t\t\t * \"vcontained\" Jsonb to internal nodes on the lhs is\n\t\t\t\t * injective, and parent-child edges on the rhs must be mapped\n\t\t\t\t * to parent-child edges on the lhs to satisfy the condition\n\t\t\t\t * of containment (plus of course the mapped nodes must be\n\t\t\t\t * equal).\n\t\t\t\t */\n\t\t\t\tif (!JsonbDeepContains(&nestval, &nestContained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\telse if (rcont == WJB_BEGIN_ARRAY)\n\t{\n\t\tJsonbValue *lhsConts = NULL;\n\t\tuint32\t\tnLhsElems = vval.val.array.nElems;\n\n\t\tAssert(vval.type == jbvArray);\n\t\tAssert(vcontained.type == jbvArray);\n\n\t\t/*\n\t\t * Handle distinction between \"raw scalar\" pseudo arrays, and real\n\t\t * arrays.\n\t\t *\n\t\t * A raw scalar may contain another raw scalar, and an array may\n\t\t * contain a raw scalar, but a raw scalar may not contain an array. We\n\t\t * don't do something like this for the object case, since objects can\n\t\t * only contain pairs, never raw scalars (a pair is represented by an\n\t\t * rhs object argument with a single contained pair).\n\t\t */\n\t\tif (vval.val.array.rawScalar && !vcontained.val.array.rawScalar)\n\t\t\treturn false;\n\n\t\t/* Work through rhs \"is it contained within?\" array */\n\t\tfor (;;)\n\t\t{\n\t\t\trcont = JsonbIteratorNext(mContained, &vcontained, true);\n\n\t\t\t/*\n\t\t\t * When we get through caller's rhs \"is it contained within?\"\n\t\t\t * array without failing to find one of its values, it's\n\t\t\t * contained.\n\t\t\t */\n\t\t\tif (rcont == WJB_END_ARRAY)\n\t\t\t\treturn true;\n\n\t\t\tAssert(rcont == WJB_ELEM);\n\n\t\t\tif (IsAJsonbScalar(&vcontained))\n\t\t\t{\n\t\t\t\tif (!findJsonbValueFromContainer((*val)->container,\n\t\t\t\t\t\t\t\t\t\t\t\t JB_FARRAY,\n\t\t\t\t\t\t\t\t\t\t\t\t &vcontained))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuint32\t\ti;\n\n\t\t\t\t/*\n\t\t\t\t * If this is first container found in rhs array (at this\n\t\t\t\t * depth), initialize temp lhs array of containers\n\t\t\t\t */\n\t\t\t\tif (lhsConts == NULL)\n\t\t\t\t{\n\t\t\t\t\tuint32\t\tj = 0;\n\n\t\t\t\t\t/* Make room for all possible values */\n\t\t\t\t\tlhsConts = palloc(sizeof(JsonbValue) * nLhsElems);\n\n\t\t\t\t\tfor (i = 0; i < nLhsElems; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Store all lhs elements in temp array */\n\t\t\t\t\t\trcont = JsonbIteratorNext(val, &vval, true);\n\t\t\t\t\t\tAssert(rcont == WJB_ELEM);\n\n\t\t\t\t\t\tif (vval.type == jbvBinary)\n\t\t\t\t\t\t\tlhsConts[j++] = vval;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* No container elements in temp array, so give up now */\n\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t/* We may have only partially filled array */\n\t\t\t\t\tnLhsElems = j;\n\t\t\t\t}\n\n\t\t\t\t/* XXX: Nested array containment is O(N^2) */\n\t\t\t\tfor (i = 0; i < nLhsElems; i++)\n\t\t\t\t{\n\t\t\t\t\t/* Nested container value (object or array) */\n\t\t\t\t\tJsonbIterator *nestval,\n\t\t\t\t\t\t\t   *nestContained;\n\t\t\t\t\tbool\t\tcontains;\n\n\t\t\t\t\tnestval = JsonbIteratorInit(lhsConts[i].val.binary.data);\n\t\t\t\t\tnestContained = JsonbIteratorInit(vcontained.val.binary.data);\n\n\t\t\t\t\tcontains = JsonbDeepContains(&nestval, &nestContained);\n\n\t\t\t\t\tif (nestval)\n\t\t\t\t\t\tpfree(nestval);\n\t\t\t\t\tif (nestContained)\n\t\t\t\t\t\tpfree(nestContained);\n\t\t\t\t\tif (contains)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Report rhs container value is not contained if couldn't\n\t\t\t\t * match rhs container to *some* lhs cont\n\t\t\t\t */\n\t\t\t\tif (i == nLhsElems)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\telog(ERROR, \"invalid jsonb container type\");\n\t}\n\n\telog(ERROR, \"unexpectedly fell off end of jsonb container\");\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JsonbIteratorInit",
          "args": [
            "&tmpl->root"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "JsonbIteratorInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "717-721",
          "snippet": "JsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nJsonbIterator *\nJsonbIteratorInit(JsonbContainer *container)\n{\n\treturn iteratorFromContainer(container, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_OBJECT",
          "args": [
            "tmpl"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JB_ROOT_IS_OBJECT",
          "args": [
            "val"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "1"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_contains(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *val = PG_GETARG_JSONB_P(0);\n\tJsonb\t   *tmpl = PG_GETARG_JSONB_P(1);\n\n\tJsonbIterator *it1,\n\t\t\t   *it2;\n\n\tif (JB_ROOT_IS_OBJECT(val) != JB_ROOT_IS_OBJECT(tmpl))\n\t\tPG_RETURN_BOOL(false);\n\n\tit1 = JsonbIteratorInit(&val->root);\n\tit2 = JsonbIteratorInit(&tmpl->root);\n\n\tPG_RETURN_BOOL(JsonbDeepContains(&it1, &it2));\n}"
  },
  {
    "function_name": "jsonb_exists_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_op.c",
    "lines": "79-110",
    "snippet": "Datum\njsonb_exists_all(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tArrayType  *keys = PG_GETARG_ARRAYTYPE_P(1);\n\tint\t\t\ti;\n\tDatum\t   *key_datums;\n\tbool\t   *key_nulls;\n\tint\t\t\telem_count;\n\n\tdeconstruct_array(keys, TEXTOID, -1, false, 'i', &key_datums, &key_nulls,\n\t\t\t\t\t  &elem_count);\n\n\tfor (i = 0; i < elem_count; i++)\n\t{\n\t\tJsonbValue\tstrVal;\n\n\t\tif (key_nulls[i])\n\t\t\tcontinue;\n\n\t\tstrVal.type = jbvString;\n\t\tstrVal.val.string.val = VARDATA(key_datums[i]);\n\t\tstrVal.val.string.len = VARSIZE(key_datums[i]) - VARHDRSZ;\n\n\t\tif (findJsonbValueFromContainer(&jb->root,\n\t\t\t\t\t\t\t\t\t\tJB_FOBJECT | JB_FARRAY,\n\t\t\t\t\t\t\t\t\t\t&strVal) == NULL)\n\t\t\tPG_RETURN_BOOL(false);\n\t}\n\n\tPG_RETURN_BOOL(true);\n}",
    "includes": [
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findJsonbValueFromContainer",
          "args": [
            "&jb->root",
            "JB_FOBJECT | JB_FARRAY",
            "&strVal"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "findJsonbValueFromContainer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "326-411",
          "snippet": "JsonbValue *\nfindJsonbValueFromContainer(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\tJsonbValue *key)\n{\n\tJEntry\t   *children = container->children;\n\tint\t\t\tcount = JsonContainerSize(container);\n\tJsonbValue *result;\n\n\tAssert((flags & ~(JB_FARRAY | JB_FOBJECT)) == 0);\n\n\t/* Quick out without a palloc cycle if object/array is empty */\n\tif (count <= 0)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbValue));\n\n\tif ((flags & JB_FARRAY) && JsonContainerIsArray(container))\n\t{\n\t\tchar\t   *base_addr = (char *) (children + count);\n\t\tuint32\t\toffset = 0;\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t{\n\t\t\tfillJsonbValue(container, i, base_addr, offset, result);\n\n\t\t\tif (key->type == result->type)\n\t\t\t{\n\t\t\t\tif (equalsJsonbScalarValue(key, result))\n\t\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tJBE_ADVANCE_OFFSET(offset, children[i]);\n\t\t}\n\t}\n\telse if ((flags & JB_FOBJECT) && JsonContainerIsObject(container))\n\t{\n\t\t/* Since this is an object, account for *Pairs* of Jentrys */\n\t\tchar\t   *base_addr = (char *) (children + count * 2);\n\t\tuint32\t\tstopLow = 0,\n\t\t\t\t\tstopHigh = count;\n\n\t\t/* Object key passed by caller must be a string */\n\t\tAssert(key->type == jbvString);\n\n\t\t/* Binary search on object/pair keys *only* */\n\t\twhile (stopLow < stopHigh)\n\t\t{\n\t\t\tuint32\t\tstopMiddle;\n\t\t\tint\t\t\tdifference;\n\t\t\tJsonbValue\tcandidate;\n\n\t\t\tstopMiddle = stopLow + (stopHigh - stopLow) / 2;\n\n\t\t\tcandidate.type = jbvString;\n\t\t\tcandidate.val.string.val =\n\t\t\t\tbase_addr + getJsonbOffset(container, stopMiddle);\n\t\t\tcandidate.val.string.len = getJsonbLength(container, stopMiddle);\n\n\t\t\tdifference = lengthCompareJsonbStringValue(&candidate, key);\n\n\t\t\tif (difference == 0)\n\t\t\t{\n\t\t\t\t/* Found our key, return corresponding value */\n\t\t\t\tint\t\t\tindex = stopMiddle + count;\n\n\t\t\t\tfillJsonbValue(container, index, base_addr,\n\t\t\t\t\t\t\t   getJsonbOffset(container, index),\n\t\t\t\t\t\t\t   result);\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (difference < 0)\n\t\t\t\t\tstopLow = stopMiddle + 1;\n\t\t\t\telse\n\t\t\t\t\tstopHigh = stopMiddle;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Not found */\n\tpfree(result);\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbValue *\nfindJsonbValueFromContainer(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\tJsonbValue *key)\n{\n\tJEntry\t   *children = container->children;\n\tint\t\t\tcount = JsonContainerSize(container);\n\tJsonbValue *result;\n\n\tAssert((flags & ~(JB_FARRAY | JB_FOBJECT)) == 0);\n\n\t/* Quick out without a palloc cycle if object/array is empty */\n\tif (count <= 0)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbValue));\n\n\tif ((flags & JB_FARRAY) && JsonContainerIsArray(container))\n\t{\n\t\tchar\t   *base_addr = (char *) (children + count);\n\t\tuint32\t\toffset = 0;\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t{\n\t\t\tfillJsonbValue(container, i, base_addr, offset, result);\n\n\t\t\tif (key->type == result->type)\n\t\t\t{\n\t\t\t\tif (equalsJsonbScalarValue(key, result))\n\t\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tJBE_ADVANCE_OFFSET(offset, children[i]);\n\t\t}\n\t}\n\telse if ((flags & JB_FOBJECT) && JsonContainerIsObject(container))\n\t{\n\t\t/* Since this is an object, account for *Pairs* of Jentrys */\n\t\tchar\t   *base_addr = (char *) (children + count * 2);\n\t\tuint32\t\tstopLow = 0,\n\t\t\t\t\tstopHigh = count;\n\n\t\t/* Object key passed by caller must be a string */\n\t\tAssert(key->type == jbvString);\n\n\t\t/* Binary search on object/pair keys *only* */\n\t\twhile (stopLow < stopHigh)\n\t\t{\n\t\t\tuint32\t\tstopMiddle;\n\t\t\tint\t\t\tdifference;\n\t\t\tJsonbValue\tcandidate;\n\n\t\t\tstopMiddle = stopLow + (stopHigh - stopLow) / 2;\n\n\t\t\tcandidate.type = jbvString;\n\t\t\tcandidate.val.string.val =\n\t\t\t\tbase_addr + getJsonbOffset(container, stopMiddle);\n\t\t\tcandidate.val.string.len = getJsonbLength(container, stopMiddle);\n\n\t\t\tdifference = lengthCompareJsonbStringValue(&candidate, key);\n\n\t\t\tif (difference == 0)\n\t\t\t{\n\t\t\t\t/* Found our key, return corresponding value */\n\t\t\t\tint\t\t\tindex = stopMiddle + count;\n\n\t\t\t\tfillJsonbValue(container, index, base_addr,\n\t\t\t\t\t\t\t   getJsonbOffset(container, index),\n\t\t\t\t\t\t\t   result);\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (difference < 0)\n\t\t\t\t\tstopLow = stopMiddle + 1;\n\t\t\t\telse\n\t\t\t\t\tstopHigh = stopMiddle;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Not found */\n\tpfree(result);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "key_datums[i]"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "key_datums[i]"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "keys",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&key_datums",
            "&key_nulls",
            "&elem_count"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_exists_all(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tArrayType  *keys = PG_GETARG_ARRAYTYPE_P(1);\n\tint\t\t\ti;\n\tDatum\t   *key_datums;\n\tbool\t   *key_nulls;\n\tint\t\t\telem_count;\n\n\tdeconstruct_array(keys, TEXTOID, -1, false, 'i', &key_datums, &key_nulls,\n\t\t\t\t\t  &elem_count);\n\n\tfor (i = 0; i < elem_count; i++)\n\t{\n\t\tJsonbValue\tstrVal;\n\n\t\tif (key_nulls[i])\n\t\t\tcontinue;\n\n\t\tstrVal.type = jbvString;\n\t\tstrVal.val.string.val = VARDATA(key_datums[i]);\n\t\tstrVal.val.string.len = VARSIZE(key_datums[i]) - VARHDRSZ;\n\n\t\tif (findJsonbValueFromContainer(&jb->root,\n\t\t\t\t\t\t\t\t\t\tJB_FOBJECT | JB_FARRAY,\n\t\t\t\t\t\t\t\t\t\t&strVal) == NULL)\n\t\t\tPG_RETURN_BOOL(false);\n\t}\n\n\tPG_RETURN_BOOL(true);\n}"
  },
  {
    "function_name": "jsonb_exists_any",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_op.c",
    "lines": "46-77",
    "snippet": "Datum\njsonb_exists_any(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tArrayType  *keys = PG_GETARG_ARRAYTYPE_P(1);\n\tint\t\t\ti;\n\tDatum\t   *key_datums;\n\tbool\t   *key_nulls;\n\tint\t\t\telem_count;\n\n\tdeconstruct_array(keys, TEXTOID, -1, false, 'i', &key_datums, &key_nulls,\n\t\t\t\t\t  &elem_count);\n\n\tfor (i = 0; i < elem_count; i++)\n\t{\n\t\tJsonbValue\tstrVal;\n\n\t\tif (key_nulls[i])\n\t\t\tcontinue;\n\n\t\tstrVal.type = jbvString;\n\t\tstrVal.val.string.val = VARDATA(key_datums[i]);\n\t\tstrVal.val.string.len = VARSIZE(key_datums[i]) - VARHDRSZ;\n\n\t\tif (findJsonbValueFromContainer(&jb->root,\n\t\t\t\t\t\t\t\t\t\tJB_FOBJECT | JB_FARRAY,\n\t\t\t\t\t\t\t\t\t\t&strVal) != NULL)\n\t\t\tPG_RETURN_BOOL(true);\n\t}\n\n\tPG_RETURN_BOOL(false);\n}",
    "includes": [
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "true"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findJsonbValueFromContainer",
          "args": [
            "&jb->root",
            "JB_FOBJECT | JB_FARRAY",
            "&strVal"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "findJsonbValueFromContainer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "326-411",
          "snippet": "JsonbValue *\nfindJsonbValueFromContainer(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\tJsonbValue *key)\n{\n\tJEntry\t   *children = container->children;\n\tint\t\t\tcount = JsonContainerSize(container);\n\tJsonbValue *result;\n\n\tAssert((flags & ~(JB_FARRAY | JB_FOBJECT)) == 0);\n\n\t/* Quick out without a palloc cycle if object/array is empty */\n\tif (count <= 0)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbValue));\n\n\tif ((flags & JB_FARRAY) && JsonContainerIsArray(container))\n\t{\n\t\tchar\t   *base_addr = (char *) (children + count);\n\t\tuint32\t\toffset = 0;\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t{\n\t\t\tfillJsonbValue(container, i, base_addr, offset, result);\n\n\t\t\tif (key->type == result->type)\n\t\t\t{\n\t\t\t\tif (equalsJsonbScalarValue(key, result))\n\t\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tJBE_ADVANCE_OFFSET(offset, children[i]);\n\t\t}\n\t}\n\telse if ((flags & JB_FOBJECT) && JsonContainerIsObject(container))\n\t{\n\t\t/* Since this is an object, account for *Pairs* of Jentrys */\n\t\tchar\t   *base_addr = (char *) (children + count * 2);\n\t\tuint32\t\tstopLow = 0,\n\t\t\t\t\tstopHigh = count;\n\n\t\t/* Object key passed by caller must be a string */\n\t\tAssert(key->type == jbvString);\n\n\t\t/* Binary search on object/pair keys *only* */\n\t\twhile (stopLow < stopHigh)\n\t\t{\n\t\t\tuint32\t\tstopMiddle;\n\t\t\tint\t\t\tdifference;\n\t\t\tJsonbValue\tcandidate;\n\n\t\t\tstopMiddle = stopLow + (stopHigh - stopLow) / 2;\n\n\t\t\tcandidate.type = jbvString;\n\t\t\tcandidate.val.string.val =\n\t\t\t\tbase_addr + getJsonbOffset(container, stopMiddle);\n\t\t\tcandidate.val.string.len = getJsonbLength(container, stopMiddle);\n\n\t\t\tdifference = lengthCompareJsonbStringValue(&candidate, key);\n\n\t\t\tif (difference == 0)\n\t\t\t{\n\t\t\t\t/* Found our key, return corresponding value */\n\t\t\t\tint\t\t\tindex = stopMiddle + count;\n\n\t\t\t\tfillJsonbValue(container, index, base_addr,\n\t\t\t\t\t\t\t   getJsonbOffset(container, index),\n\t\t\t\t\t\t\t   result);\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (difference < 0)\n\t\t\t\t\tstopLow = stopMiddle + 1;\n\t\t\t\telse\n\t\t\t\t\tstopHigh = stopMiddle;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Not found */\n\tpfree(result);\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbValue *\nfindJsonbValueFromContainer(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\tJsonbValue *key)\n{\n\tJEntry\t   *children = container->children;\n\tint\t\t\tcount = JsonContainerSize(container);\n\tJsonbValue *result;\n\n\tAssert((flags & ~(JB_FARRAY | JB_FOBJECT)) == 0);\n\n\t/* Quick out without a palloc cycle if object/array is empty */\n\tif (count <= 0)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbValue));\n\n\tif ((flags & JB_FARRAY) && JsonContainerIsArray(container))\n\t{\n\t\tchar\t   *base_addr = (char *) (children + count);\n\t\tuint32\t\toffset = 0;\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t{\n\t\t\tfillJsonbValue(container, i, base_addr, offset, result);\n\n\t\t\tif (key->type == result->type)\n\t\t\t{\n\t\t\t\tif (equalsJsonbScalarValue(key, result))\n\t\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tJBE_ADVANCE_OFFSET(offset, children[i]);\n\t\t}\n\t}\n\telse if ((flags & JB_FOBJECT) && JsonContainerIsObject(container))\n\t{\n\t\t/* Since this is an object, account for *Pairs* of Jentrys */\n\t\tchar\t   *base_addr = (char *) (children + count * 2);\n\t\tuint32\t\tstopLow = 0,\n\t\t\t\t\tstopHigh = count;\n\n\t\t/* Object key passed by caller must be a string */\n\t\tAssert(key->type == jbvString);\n\n\t\t/* Binary search on object/pair keys *only* */\n\t\twhile (stopLow < stopHigh)\n\t\t{\n\t\t\tuint32\t\tstopMiddle;\n\t\t\tint\t\t\tdifference;\n\t\t\tJsonbValue\tcandidate;\n\n\t\t\tstopMiddle = stopLow + (stopHigh - stopLow) / 2;\n\n\t\t\tcandidate.type = jbvString;\n\t\t\tcandidate.val.string.val =\n\t\t\t\tbase_addr + getJsonbOffset(container, stopMiddle);\n\t\t\tcandidate.val.string.len = getJsonbLength(container, stopMiddle);\n\n\t\t\tdifference = lengthCompareJsonbStringValue(&candidate, key);\n\n\t\t\tif (difference == 0)\n\t\t\t{\n\t\t\t\t/* Found our key, return corresponding value */\n\t\t\t\tint\t\t\tindex = stopMiddle + count;\n\n\t\t\t\tfillJsonbValue(container, index, base_addr,\n\t\t\t\t\t\t\t   getJsonbOffset(container, index),\n\t\t\t\t\t\t\t   result);\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (difference < 0)\n\t\t\t\t\tstopLow = stopMiddle + 1;\n\t\t\t\telse\n\t\t\t\t\tstopHigh = stopMiddle;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Not found */\n\tpfree(result);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "key_datums[i]"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "key_datums[i]"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "keys",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&key_datums",
            "&key_nulls",
            "&elem_count"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_exists_any(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\tArrayType  *keys = PG_GETARG_ARRAYTYPE_P(1);\n\tint\t\t\ti;\n\tDatum\t   *key_datums;\n\tbool\t   *key_nulls;\n\tint\t\t\telem_count;\n\n\tdeconstruct_array(keys, TEXTOID, -1, false, 'i', &key_datums, &key_nulls,\n\t\t\t\t\t  &elem_count);\n\n\tfor (i = 0; i < elem_count; i++)\n\t{\n\t\tJsonbValue\tstrVal;\n\n\t\tif (key_nulls[i])\n\t\t\tcontinue;\n\n\t\tstrVal.type = jbvString;\n\t\tstrVal.val.string.val = VARDATA(key_datums[i]);\n\t\tstrVal.val.string.len = VARSIZE(key_datums[i]) - VARHDRSZ;\n\n\t\tif (findJsonbValueFromContainer(&jb->root,\n\t\t\t\t\t\t\t\t\t\tJB_FOBJECT | JB_FARRAY,\n\t\t\t\t\t\t\t\t\t\t&strVal) != NULL)\n\t\t\tPG_RETURN_BOOL(true);\n\t}\n\n\tPG_RETURN_BOOL(false);\n}"
  },
  {
    "function_name": "jsonb_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_op.c",
    "lines": "21-44",
    "snippet": "Datum\njsonb_exists(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\ttext\t   *key = PG_GETARG_TEXT_PP(1);\n\tJsonbValue\tkval;\n\tJsonbValue *v = NULL;\n\n\t/*\n\t * We only match Object keys (which are naturally always Strings), or\n\t * string elements in arrays.  In particular, we do not match non-string\n\t * scalar elements.  Existence of a key/element is only considered at the\n\t * top level.  No recursion occurs.\n\t */\n\tkval.type = jbvString;\n\tkval.val.string.val = VARDATA_ANY(key);\n\tkval.val.string.len = VARSIZE_ANY_EXHDR(key);\n\n\tv = findJsonbValueFromContainer(&jb->root,\n\t\t\t\t\t\t\t\t\tJB_FOBJECT | JB_FARRAY,\n\t\t\t\t\t\t\t\t\t&kval);\n\n\tPG_RETURN_BOOL(v != NULL);\n}",
    "includes": [
      "#include \"utils/jsonb.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"miscadmin.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "v != NULL"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "findJsonbValueFromContainer",
          "args": [
            "&jb->root",
            "JB_FOBJECT | JB_FARRAY",
            "&kval"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "findJsonbValueFromContainer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/jsonb_util.c",
          "lines": "326-411",
          "snippet": "JsonbValue *\nfindJsonbValueFromContainer(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\tJsonbValue *key)\n{\n\tJEntry\t   *children = container->children;\n\tint\t\t\tcount = JsonContainerSize(container);\n\tJsonbValue *result;\n\n\tAssert((flags & ~(JB_FARRAY | JB_FOBJECT)) == 0);\n\n\t/* Quick out without a palloc cycle if object/array is empty */\n\tif (count <= 0)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbValue));\n\n\tif ((flags & JB_FARRAY) && JsonContainerIsArray(container))\n\t{\n\t\tchar\t   *base_addr = (char *) (children + count);\n\t\tuint32\t\toffset = 0;\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t{\n\t\t\tfillJsonbValue(container, i, base_addr, offset, result);\n\n\t\t\tif (key->type == result->type)\n\t\t\t{\n\t\t\t\tif (equalsJsonbScalarValue(key, result))\n\t\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tJBE_ADVANCE_OFFSET(offset, children[i]);\n\t\t}\n\t}\n\telse if ((flags & JB_FOBJECT) && JsonContainerIsObject(container))\n\t{\n\t\t/* Since this is an object, account for *Pairs* of Jentrys */\n\t\tchar\t   *base_addr = (char *) (children + count * 2);\n\t\tuint32\t\tstopLow = 0,\n\t\t\t\t\tstopHigh = count;\n\n\t\t/* Object key passed by caller must be a string */\n\t\tAssert(key->type == jbvString);\n\n\t\t/* Binary search on object/pair keys *only* */\n\t\twhile (stopLow < stopHigh)\n\t\t{\n\t\t\tuint32\t\tstopMiddle;\n\t\t\tint\t\t\tdifference;\n\t\t\tJsonbValue\tcandidate;\n\n\t\t\tstopMiddle = stopLow + (stopHigh - stopLow) / 2;\n\n\t\t\tcandidate.type = jbvString;\n\t\t\tcandidate.val.string.val =\n\t\t\t\tbase_addr + getJsonbOffset(container, stopMiddle);\n\t\t\tcandidate.val.string.len = getJsonbLength(container, stopMiddle);\n\n\t\t\tdifference = lengthCompareJsonbStringValue(&candidate, key);\n\n\t\t\tif (difference == 0)\n\t\t\t{\n\t\t\t\t/* Found our key, return corresponding value */\n\t\t\t\tint\t\t\tindex = stopMiddle + count;\n\n\t\t\t\tfillJsonbValue(container, index, base_addr,\n\t\t\t\t\t\t\t   getJsonbOffset(container, index),\n\t\t\t\t\t\t\t   result);\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (difference < 0)\n\t\t\t\t\tstopLow = stopMiddle + 1;\n\t\t\t\telse\n\t\t\t\t\tstopHigh = stopMiddle;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Not found */\n\tpfree(result);\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/jsonb.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);",
            "static Jsonb *convertToJsonb(JsonbValue *val);",
            "static int\treserveFromBuffer(StringInfo buffer, int len);",
            "static void appendToBuffer(StringInfo buffer, const char *data, int len);",
            "static void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);",
            "static void uniqueifyJsonbObject(JsonbValue *object);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/memutils.h\"\n#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic void fillJsonbValue(JsonbContainer *container, int index,\n\t\t\t   char *base_addr, uint32 offset,\n\t\t\t   JsonbValue *result);\nstatic Jsonb *convertToJsonb(JsonbValue *val);\nstatic int\treserveFromBuffer(StringInfo buffer, int len);\nstatic void appendToBuffer(StringInfo buffer, const char *data, int len);\nstatic void copyToBuffer(StringInfo buffer, int offset, const char *data, int len);\nstatic void uniqueifyJsonbObject(JsonbValue *object);\n\nJsonbValue *\nfindJsonbValueFromContainer(JsonbContainer *container, uint32 flags,\n\t\t\t\t\t\t\tJsonbValue *key)\n{\n\tJEntry\t   *children = container->children;\n\tint\t\t\tcount = JsonContainerSize(container);\n\tJsonbValue *result;\n\n\tAssert((flags & ~(JB_FARRAY | JB_FOBJECT)) == 0);\n\n\t/* Quick out without a palloc cycle if object/array is empty */\n\tif (count <= 0)\n\t\treturn NULL;\n\n\tresult = palloc(sizeof(JsonbValue));\n\n\tif ((flags & JB_FARRAY) && JsonContainerIsArray(container))\n\t{\n\t\tchar\t   *base_addr = (char *) (children + count);\n\t\tuint32\t\toffset = 0;\n\t\tint\t\t\ti;\n\n\t\tfor (i = 0; i < count; i++)\n\t\t{\n\t\t\tfillJsonbValue(container, i, base_addr, offset, result);\n\n\t\t\tif (key->type == result->type)\n\t\t\t{\n\t\t\t\tif (equalsJsonbScalarValue(key, result))\n\t\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tJBE_ADVANCE_OFFSET(offset, children[i]);\n\t\t}\n\t}\n\telse if ((flags & JB_FOBJECT) && JsonContainerIsObject(container))\n\t{\n\t\t/* Since this is an object, account for *Pairs* of Jentrys */\n\t\tchar\t   *base_addr = (char *) (children + count * 2);\n\t\tuint32\t\tstopLow = 0,\n\t\t\t\t\tstopHigh = count;\n\n\t\t/* Object key passed by caller must be a string */\n\t\tAssert(key->type == jbvString);\n\n\t\t/* Binary search on object/pair keys *only* */\n\t\twhile (stopLow < stopHigh)\n\t\t{\n\t\t\tuint32\t\tstopMiddle;\n\t\t\tint\t\t\tdifference;\n\t\t\tJsonbValue\tcandidate;\n\n\t\t\tstopMiddle = stopLow + (stopHigh - stopLow) / 2;\n\n\t\t\tcandidate.type = jbvString;\n\t\t\tcandidate.val.string.val =\n\t\t\t\tbase_addr + getJsonbOffset(container, stopMiddle);\n\t\t\tcandidate.val.string.len = getJsonbLength(container, stopMiddle);\n\n\t\t\tdifference = lengthCompareJsonbStringValue(&candidate, key);\n\n\t\t\tif (difference == 0)\n\t\t\t{\n\t\t\t\t/* Found our key, return corresponding value */\n\t\t\t\tint\t\t\tindex = stopMiddle + count;\n\n\t\t\t\tfillJsonbValue(container, index, base_addr,\n\t\t\t\t\t\t\t   getJsonbOffset(container, index),\n\t\t\t\t\t\t\t   result);\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (difference < 0)\n\t\t\t\t\tstopLow = stopMiddle + 1;\n\t\t\t\telse\n\t\t\t\t\tstopHigh = stopMiddle;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Not found */\n\tpfree(result);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "key"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "key"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_JSONB_P",
          "args": [
            "0"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/jsonb.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"postgres.h\"\n\nDatum\njsonb_exists(PG_FUNCTION_ARGS)\n{\n\tJsonb\t   *jb = PG_GETARG_JSONB_P(0);\n\ttext\t   *key = PG_GETARG_TEXT_PP(1);\n\tJsonbValue\tkval;\n\tJsonbValue *v = NULL;\n\n\t/*\n\t * We only match Object keys (which are naturally always Strings), or\n\t * string elements in arrays.  In particular, we do not match non-string\n\t * scalar elements.  Existence of a key/element is only considered at the\n\t * top level.  No recursion occurs.\n\t */\n\tkval.type = jbvString;\n\tkval.val.string.val = VARDATA_ANY(key);\n\tkval.val.string.len = VARSIZE_ANY_EXHDR(key);\n\n\tv = findJsonbValueFromContainer(&jb->root,\n\t\t\t\t\t\t\t\t\tJB_FOBJECT | JB_FARRAY,\n\t\t\t\t\t\t\t\t\t&kval);\n\n\tPG_RETURN_BOOL(v != NULL);\n}"
  }
]