[
  {
    "function_name": "calc_hist_selectivity_contains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
    "lines": "1107-1178",
    "snippet": "static double\ncalc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues)\n{\n\tint\t\t\ti,\n\t\t\t\tlower_index;\n\tdouble\t\tbin_width,\n\t\t\t\tlower_bin_width;\n\tdouble\t\tsum_frac;\n\tfloat8\t\tprev_dist;\n\n\t/* Find the bin containing the lower bound of query range. */\n\tlower_index = rbound_bsearch(typcache, lower, hist_lower, hist_nvalues,\n\t\t\t\t\t\t\t\t true);\n\n\t/*\n\t * Calculate lower_bin_width, ie. the fraction of the of (lower_index,\n\t * lower_index + 1) bin which is greater than lower bound of query range\n\t * using linear interpolation of subdiff function.\n\t */\n\tif (lower_index >= 0 && lower_index < hist_nvalues - 1)\n\t\tlower_bin_width = get_position(typcache, lower, &hist_lower[lower_index],\n\t\t\t\t\t\t\t\t\t   &hist_lower[lower_index + 1]);\n\telse\n\t\tlower_bin_width = 0.0;\n\n\t/*\n\t * Loop through all the lower bound bins, smaller than the query lower\n\t * bound. In the loop, dist and prev_dist are the distance of the\n\t * \"current\" bin's lower and upper bounds from the constant upper bound.\n\t * We begin from query lower bound, and walk backwards, so the first bin's\n\t * upper bound is the query lower bound, and its distance to the query\n\t * upper bound is the length of the query range.\n\t *\n\t * bin_width represents the width of the current bin. Normally it is 1.0,\n\t * meaning a full width bin, except for the first bin, which is only\n\t * counted up to the constant lower bound.\n\t */\n\tprev_dist = get_distance(typcache, lower, upper);\n\tsum_frac = 0.0;\n\tbin_width = lower_bin_width;\n\tfor (i = lower_index; i >= 0; i--)\n\t{\n\t\tfloat8\t\tdist;\n\t\tdouble\t\tlength_hist_frac;\n\n\t\t/*\n\t\t * dist -- distance from upper bound of query range to current value\n\t\t * of lower bound histogram or lower bound of query range (if we've\n\t\t * reach it).\n\t\t */\n\t\tdist = get_distance(typcache, &hist_lower[i], upper);\n\n\t\t/*\n\t\t * Get average fraction of length histogram which covers intervals\n\t\t * longer than (or equal to) distance to upper bound of query range.\n\t\t */\n\t\tlength_hist_frac =\n\t\t\t1.0 - calc_length_hist_frac(length_hist_values,\n\t\t\t\t\t\t\t\t\t\tlength_hist_nvalues,\n\t\t\t\t\t\t\t\t\t\tprev_dist, dist, false);\n\n\t\tsum_frac += length_hist_frac * bin_width / (double) (hist_nvalues - 1);\n\n\t\tbin_width = 1.0;\n\t\tprev_dist = dist;\n\t}\n\n\treturn sum_frac;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
      "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
      "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
      "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);",
      "static double calc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues);",
      "static double calc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "calc_length_hist_frac",
          "args": [
            "length_hist_values",
            "length_hist_nvalues",
            "prev_dist",
            "dist",
            "false"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "calc_length_hist_frac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "834-986",
          "snippet": "static double\ncalc_length_hist_frac(Datum *length_hist_values, int length_hist_nvalues,\n\t\t\t\t\t  double length1, double length2, bool equal)\n{\n\tdouble\t\tfrac;\n\tdouble\t\tA,\n\t\t\t\tB,\n\t\t\t\tPA,\n\t\t\t\tPB;\n\tdouble\t\tpos;\n\tint\t\t\ti;\n\tdouble\t\tarea;\n\n\tAssert(length2 >= length1);\n\n\tif (length2 < 0.0)\n\t\treturn 0.0;\t\t\t\t/* shouldn't happen, but doesn't hurt to check */\n\n\t/* All lengths in the table are <= infinite. */\n\tif (is_infinite(length2) && equal)\n\t\treturn 1.0;\n\n\t/*----------\n\t * The average of a function between A and B can be calculated by the\n\t * formula:\n\t *\n\t *\t\t\tB\n\t *\t  1\t\t/\n\t * -------\t| P(x)dx\n\t *\tB - A\t/\n\t *\t\t\tA\n\t *\n\t * The geometrical interpretation of the integral is the area under the\n\t * graph of P(x). P(x) is defined by the length histogram. We calculate\n\t * the area in a piecewise fashion, iterating through the length histogram\n\t * bins. Each bin is a trapezoid:\n\t *\n\t *\t\t P(x2)\n\t *\t\t  /|\n\t *\t\t / |\n\t * P(x1)/  |\n\t *\t   |   |\n\t *\t   |   |\n\t *\t---+---+--\n\t *\t   x1  x2\n\t *\n\t * where x1 and x2 are the boundaries of the current histogram, and P(x1)\n\t * and P(x1) are the cumulative fraction of tuples at the boundaries.\n\t *\n\t * The area of each trapezoid is 1/2 * (P(x2) + P(x1)) * (x2 - x1)\n\t *\n\t * The first bin contains the lower bound passed by the caller, so we\n\t * use linear interpolation between the previous and next histogram bin\n\t * boundary to calculate P(x1). Likewise for the last bin: we use linear\n\t * interpolation to calculate P(x2). For the bins in between, x1 and x2\n\t * lie on histogram bin boundaries, so P(x1) and P(x2) are simply:\n\t * P(x1) =\t  (bin index) / (number of bins)\n\t * P(x2) = (bin index + 1 / (number of bins)\n\t */\n\n\t/* First bin, the one that contains lower bound */\n\ti = length_hist_bsearch(length_hist_values, length_hist_nvalues, length1, equal);\n\tif (i >= length_hist_nvalues - 1)\n\t\treturn 1.0;\n\n\tif (i < 0)\n\t{\n\t\ti = 0;\n\t\tpos = 0.0;\n\t}\n\telse\n\t{\n\t\t/* interpolate length1's position in the bin */\n\t\tpos = get_len_position(length1,\n\t\t\t\t\t\t\t   DatumGetFloat8(length_hist_values[i]),\n\t\t\t\t\t\t\t   DatumGetFloat8(length_hist_values[i + 1]));\n\t}\n\tPB = (((double) i) + pos) / (double) (length_hist_nvalues - 1);\n\tB = length1;\n\n\t/*\n\t * In the degenerate case that length1 == length2, simply return\n\t * P(length1). This is not merely an optimization: if length1 == length2,\n\t * we'd divide by zero later on.\n\t */\n\tif (length2 == length1)\n\t\treturn PB;\n\n\t/*\n\t * Loop through all the bins, until we hit the last bin, the one that\n\t * contains the upper bound. (if lower and upper bounds are in the same\n\t * bin, this falls out immediately)\n\t */\n\tarea = 0.0;\n\tfor (; i < length_hist_nvalues - 1; i++)\n\t{\n\t\tdouble\t\tbin_upper = DatumGetFloat8(length_hist_values[i + 1]);\n\n\t\t/* check if we've reached the last bin */\n\t\tif (!(bin_upper < length2 || (equal && bin_upper <= length2)))\n\t\t\tbreak;\n\n\t\t/* the upper bound of previous bin is the lower bound of this bin */\n\t\tA = B;\n\t\tPA = PB;\n\n\t\tB = bin_upper;\n\t\tPB = (double) i / (double) (length_hist_nvalues - 1);\n\n\t\t/*\n\t\t * Add the area of this trapezoid to the total. The point of the\n\t\t * if-check is to avoid NaN, in the corner case that PA == PB == 0,\n\t\t * and B - A == Inf. The area of a zero-height trapezoid (PA == PB ==\n\t\t * 0) is zero, regardless of the width (B - A).\n\t\t */\n\t\tif (PA > 0 || PB > 0)\n\t\t\tarea += 0.5 * (PB + PA) * (B - A);\n\t}\n\n\t/* Last bin */\n\tA = B;\n\tPA = PB;\n\n\tB = length2;\t\t\t\t/* last bin ends at the query upper bound */\n\tif (i >= length_hist_nvalues - 1)\n\t\tpos = 0.0;\n\telse\n\t{\n\t\tif (DatumGetFloat8(length_hist_values[i]) == DatumGetFloat8(length_hist_values[i + 1]))\n\t\t\tpos = 0.0;\n\t\telse\n\t\t\tpos = get_len_position(length2, DatumGetFloat8(length_hist_values[i]), DatumGetFloat8(length_hist_values[i + 1]));\n\t}\n\tPB = (((double) i) + pos) / (double) (length_hist_nvalues - 1);\n\n\tif (PA > 0 || PB > 0)\n\t\tarea += 0.5 * (PB + PA) * (B - A);\n\n\t/*\n\t * Ok, we have calculated the area, ie. the integral. Divide by width to\n\t * get the requested average.\n\t *\n\t * Avoid NaN arising from infinite / infinite. This happens at least if\n\t * length2 is infinite. It's not clear what the correct value would be in\n\t * that case, so 0.5 seems as good as any value.\n\t */\n\tif (is_infinite(area) && is_infinite(length2))\n\t\tfrac = 0.5;\n\telse\n\t\tfrac = area / (length2 - length1);\n\n\treturn frac;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
            "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
            "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
            "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);",
            "static double calc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues);",
            "static double calc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\nstatic double calc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues);\nstatic double calc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues);\n\nstatic double\ncalc_length_hist_frac(Datum *length_hist_values, int length_hist_nvalues,\n\t\t\t\t\t  double length1, double length2, bool equal)\n{\n\tdouble\t\tfrac;\n\tdouble\t\tA,\n\t\t\t\tB,\n\t\t\t\tPA,\n\t\t\t\tPB;\n\tdouble\t\tpos;\n\tint\t\t\ti;\n\tdouble\t\tarea;\n\n\tAssert(length2 >= length1);\n\n\tif (length2 < 0.0)\n\t\treturn 0.0;\t\t\t\t/* shouldn't happen, but doesn't hurt to check */\n\n\t/* All lengths in the table are <= infinite. */\n\tif (is_infinite(length2) && equal)\n\t\treturn 1.0;\n\n\t/*----------\n\t * The average of a function between A and B can be calculated by the\n\t * formula:\n\t *\n\t *\t\t\tB\n\t *\t  1\t\t/\n\t * -------\t| P(x)dx\n\t *\tB - A\t/\n\t *\t\t\tA\n\t *\n\t * The geometrical interpretation of the integral is the area under the\n\t * graph of P(x). P(x) is defined by the length histogram. We calculate\n\t * the area in a piecewise fashion, iterating through the length histogram\n\t * bins. Each bin is a trapezoid:\n\t *\n\t *\t\t P(x2)\n\t *\t\t  /|\n\t *\t\t / |\n\t * P(x1)/  |\n\t *\t   |   |\n\t *\t   |   |\n\t *\t---+---+--\n\t *\t   x1  x2\n\t *\n\t * where x1 and x2 are the boundaries of the current histogram, and P(x1)\n\t * and P(x1) are the cumulative fraction of tuples at the boundaries.\n\t *\n\t * The area of each trapezoid is 1/2 * (P(x2) + P(x1)) * (x2 - x1)\n\t *\n\t * The first bin contains the lower bound passed by the caller, so we\n\t * use linear interpolation between the previous and next histogram bin\n\t * boundary to calculate P(x1). Likewise for the last bin: we use linear\n\t * interpolation to calculate P(x2). For the bins in between, x1 and x2\n\t * lie on histogram bin boundaries, so P(x1) and P(x2) are simply:\n\t * P(x1) =\t  (bin index) / (number of bins)\n\t * P(x2) = (bin index + 1 / (number of bins)\n\t */\n\n\t/* First bin, the one that contains lower bound */\n\ti = length_hist_bsearch(length_hist_values, length_hist_nvalues, length1, equal);\n\tif (i >= length_hist_nvalues - 1)\n\t\treturn 1.0;\n\n\tif (i < 0)\n\t{\n\t\ti = 0;\n\t\tpos = 0.0;\n\t}\n\telse\n\t{\n\t\t/* interpolate length1's position in the bin */\n\t\tpos = get_len_position(length1,\n\t\t\t\t\t\t\t   DatumGetFloat8(length_hist_values[i]),\n\t\t\t\t\t\t\t   DatumGetFloat8(length_hist_values[i + 1]));\n\t}\n\tPB = (((double) i) + pos) / (double) (length_hist_nvalues - 1);\n\tB = length1;\n\n\t/*\n\t * In the degenerate case that length1 == length2, simply return\n\t * P(length1). This is not merely an optimization: if length1 == length2,\n\t * we'd divide by zero later on.\n\t */\n\tif (length2 == length1)\n\t\treturn PB;\n\n\t/*\n\t * Loop through all the bins, until we hit the last bin, the one that\n\t * contains the upper bound. (if lower and upper bounds are in the same\n\t * bin, this falls out immediately)\n\t */\n\tarea = 0.0;\n\tfor (; i < length_hist_nvalues - 1; i++)\n\t{\n\t\tdouble\t\tbin_upper = DatumGetFloat8(length_hist_values[i + 1]);\n\n\t\t/* check if we've reached the last bin */\n\t\tif (!(bin_upper < length2 || (equal && bin_upper <= length2)))\n\t\t\tbreak;\n\n\t\t/* the upper bound of previous bin is the lower bound of this bin */\n\t\tA = B;\n\t\tPA = PB;\n\n\t\tB = bin_upper;\n\t\tPB = (double) i / (double) (length_hist_nvalues - 1);\n\n\t\t/*\n\t\t * Add the area of this trapezoid to the total. The point of the\n\t\t * if-check is to avoid NaN, in the corner case that PA == PB == 0,\n\t\t * and B - A == Inf. The area of a zero-height trapezoid (PA == PB ==\n\t\t * 0) is zero, regardless of the width (B - A).\n\t\t */\n\t\tif (PA > 0 || PB > 0)\n\t\t\tarea += 0.5 * (PB + PA) * (B - A);\n\t}\n\n\t/* Last bin */\n\tA = B;\n\tPA = PB;\n\n\tB = length2;\t\t\t\t/* last bin ends at the query upper bound */\n\tif (i >= length_hist_nvalues - 1)\n\t\tpos = 0.0;\n\telse\n\t{\n\t\tif (DatumGetFloat8(length_hist_values[i]) == DatumGetFloat8(length_hist_values[i + 1]))\n\t\t\tpos = 0.0;\n\t\telse\n\t\t\tpos = get_len_position(length2, DatumGetFloat8(length_hist_values[i]), DatumGetFloat8(length_hist_values[i + 1]));\n\t}\n\tPB = (((double) i) + pos) / (double) (length_hist_nvalues - 1);\n\n\tif (PA > 0 || PB > 0)\n\t\tarea += 0.5 * (PB + PA) * (B - A);\n\n\t/*\n\t * Ok, we have calculated the area, ie. the integral. Divide by width to\n\t * get the requested average.\n\t *\n\t * Avoid NaN arising from infinite / infinite. This happens at least if\n\t * length2 is infinite. It's not clear what the correct value would be in\n\t * that case, so 0.5 seems as good as any value.\n\t */\n\tif (is_infinite(area) && is_infinite(length2))\n\t\tfrac = 0.5;\n\telse\n\t\tfrac = area / (length2 - length1);\n\n\treturn frac;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_distance",
          "args": [
            "typcache",
            "&hist_lower[i]",
            "upper"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "get_distance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "794-827",
          "snippet": "static float8\nget_distance(TypeCacheEntry *typcache, RangeBound *bound1, RangeBound *bound2)\n{\n\tbool\t\thas_subdiff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\n\tif (!bound1->infinite && !bound2->infinite)\n\t{\n\t\t/*\n\t\t * No bounds are infinite, use subdiff function or return default\n\t\t * value of 1.0 if no subdiff is available.\n\t\t */\n\t\tif (has_subdiff)\n\t\t\treturn\n\t\t\t\tDatumGetFloat8(FunctionCall2Coll(&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t bound2->val,\n\t\t\t\t\t\t\t\t\t\t\t\t bound1->val));\n\t\telse\n\t\t\treturn 1.0;\n\t}\n\telse if (bound1->infinite && bound2->infinite)\n\t{\n\t\t/* Both bounds are infinite */\n\t\tif (bound1->lower == bound2->lower)\n\t\t\treturn 0.0;\n\t\telse\n\t\t\treturn get_float8_infinity();\n\t}\n\telse\n\t{\n\t\t/* One bound is infinite, another is not */\n\t\treturn get_float8_infinity();\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float8 get_distance(TypeCacheEntry *typcache, RangeBound *bound1,\n\t\t\t RangeBound *bound2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic float8 get_distance(TypeCacheEntry *typcache, RangeBound *bound1,\n\t\t\t RangeBound *bound2);\n\nstatic float8\nget_distance(TypeCacheEntry *typcache, RangeBound *bound1, RangeBound *bound2)\n{\n\tbool\t\thas_subdiff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\n\tif (!bound1->infinite && !bound2->infinite)\n\t{\n\t\t/*\n\t\t * No bounds are infinite, use subdiff function or return default\n\t\t * value of 1.0 if no subdiff is available.\n\t\t */\n\t\tif (has_subdiff)\n\t\t\treturn\n\t\t\t\tDatumGetFloat8(FunctionCall2Coll(&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t bound2->val,\n\t\t\t\t\t\t\t\t\t\t\t\t bound1->val));\n\t\telse\n\t\t\treturn 1.0;\n\t}\n\telse if (bound1->infinite && bound2->infinite)\n\t{\n\t\t/* Both bounds are infinite */\n\t\tif (bound1->lower == bound2->lower)\n\t\t\treturn 0.0;\n\t\telse\n\t\t\treturn get_float8_infinity();\n\t}\n\telse\n\t{\n\t\t/* One bound is infinite, another is not */\n\t\treturn get_float8_infinity();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_position",
          "args": [
            "typcache",
            "lower",
            "&hist_lower[lower_index]",
            "&hist_lower[lower_index + 1]"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "get_position",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "672-743",
          "snippet": "static float8\nget_position(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist1,\n\t\t\t RangeBound *hist2)\n{\n\tbool\t\thas_subdiff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\tfloat8\t\tposition;\n\n\tif (!hist1->infinite && !hist2->infinite)\n\t{\n\t\tfloat8\t\tbin_width;\n\n\t\t/*\n\t\t * Both bounds are finite. Assuming the subtype's comparison function\n\t\t * works sanely, the value must be finite, too, because it lies\n\t\t * somewhere between the bounds. If it doesn't, just return something.\n\t\t */\n\t\tif (value->infinite)\n\t\t\treturn 0.5;\n\n\t\t/* Can't interpolate without subdiff function */\n\t\tif (!has_subdiff)\n\t\t\treturn 0.5;\n\n\t\t/* Calculate relative position using subdiff function. */\n\t\tbin_width = DatumGetFloat8(FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t &typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hist2->val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hist1->val));\n\t\tif (bin_width <= 0.0)\n\t\t\treturn 0.5;\t\t\t/* zero width bin */\n\n\t\tposition = DatumGetFloat8(FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\ttypcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue->val,\n\t\t\t\t\t\t\t\t\t\t\t\t\thist1->val))\n\t\t\t/ bin_width;\n\n\t\t/* Relative position must be in [0,1] range */\n\t\tposition = Max(position, 0.0);\n\t\tposition = Min(position, 1.0);\n\t\treturn position;\n\t}\n\telse if (hist1->infinite && !hist2->infinite)\n\t{\n\t\t/*\n\t\t * Lower bin boundary is -infinite, upper is finite. If the value is\n\t\t * -infinite, return 0.0 to indicate it's equal to the lower bound.\n\t\t * Otherwise return 1.0 to indicate it's infinitely far from the lower\n\t\t * bound.\n\t\t */\n\t\treturn ((value->infinite && value->lower) ? 0.0 : 1.0);\n\t}\n\telse if (!hist1->infinite && hist2->infinite)\n\t{\n\t\t/* same as above, but in reverse */\n\t\treturn ((value->infinite && !value->lower) ? 1.0 : 0.0);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If both bin boundaries are infinite, they should be equal to each\n\t\t * other, and the value should also be infinite and equal to both\n\t\t * bounds. (But don't Assert that, to avoid crashing if a user creates\n\t\t * a datatype with a broken comparison function).\n\t\t *\n\t\t * Assume the value to lie in the middle of the infinite bounds.\n\t\t */\n\t\treturn 0.5;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
            "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
            "static float8 get_position(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t RangeBound *hist1, RangeBound *hist2);",
            "static float8 get_len_position(double value, double hist1, double hist2);",
            "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
            "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic float8 get_position(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t RangeBound *hist1, RangeBound *hist2);\nstatic float8 get_len_position(double value, double hist1, double hist2);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\n\nstatic float8\nget_position(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist1,\n\t\t\t RangeBound *hist2)\n{\n\tbool\t\thas_subdiff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\tfloat8\t\tposition;\n\n\tif (!hist1->infinite && !hist2->infinite)\n\t{\n\t\tfloat8\t\tbin_width;\n\n\t\t/*\n\t\t * Both bounds are finite. Assuming the subtype's comparison function\n\t\t * works sanely, the value must be finite, too, because it lies\n\t\t * somewhere between the bounds. If it doesn't, just return something.\n\t\t */\n\t\tif (value->infinite)\n\t\t\treturn 0.5;\n\n\t\t/* Can't interpolate without subdiff function */\n\t\tif (!has_subdiff)\n\t\t\treturn 0.5;\n\n\t\t/* Calculate relative position using subdiff function. */\n\t\tbin_width = DatumGetFloat8(FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t &typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hist2->val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hist1->val));\n\t\tif (bin_width <= 0.0)\n\t\t\treturn 0.5;\t\t\t/* zero width bin */\n\n\t\tposition = DatumGetFloat8(FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\ttypcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue->val,\n\t\t\t\t\t\t\t\t\t\t\t\t\thist1->val))\n\t\t\t/ bin_width;\n\n\t\t/* Relative position must be in [0,1] range */\n\t\tposition = Max(position, 0.0);\n\t\tposition = Min(position, 1.0);\n\t\treturn position;\n\t}\n\telse if (hist1->infinite && !hist2->infinite)\n\t{\n\t\t/*\n\t\t * Lower bin boundary is -infinite, upper is finite. If the value is\n\t\t * -infinite, return 0.0 to indicate it's equal to the lower bound.\n\t\t * Otherwise return 1.0 to indicate it's infinitely far from the lower\n\t\t * bound.\n\t\t */\n\t\treturn ((value->infinite && value->lower) ? 0.0 : 1.0);\n\t}\n\telse if (!hist1->infinite && hist2->infinite)\n\t{\n\t\t/* same as above, but in reverse */\n\t\treturn ((value->infinite && !value->lower) ? 1.0 : 0.0);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If both bin boundaries are infinite, they should be equal to each\n\t\t * other, and the value should also be infinite and equal to both\n\t\t * bounds. (But don't Assert that, to avoid crashing if a user creates\n\t\t * a datatype with a broken comparison function).\n\t\t *\n\t\t * Assume the value to lie in the middle of the infinite bounds.\n\t\t */\n\t\treturn 0.5;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rbound_bsearch",
          "args": [
            "typcache",
            "lower",
            "hist_lower",
            "hist_nvalues",
            "true"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "rbound_bsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "617-637",
          "snippet": "static int\nrbound_bsearch(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist,\n\t\t\t   int hist_length, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = hist_length - 1,\n\t\t\t\tcmp,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tmiddle = (lower + upper + 1) / 2;\n\t\tcmp = range_cmp_bounds(typcache, &hist[middle], value);\n\n\t\tif (cmp < 0 || (equal && cmp == 0))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
            "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
            "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
            "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\n\nstatic int\nrbound_bsearch(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist,\n\t\t\t   int hist_length, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = hist_length - 1,\n\t\t\t\tcmp,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tmiddle = (lower + upper + 1) / 2;\n\t\tcmp = range_cmp_bounds(typcache, &hist[middle], value);\n\n\t\tif (cmp < 0 || (equal && cmp == 0))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\nstatic double calc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues);\nstatic double calc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues);\n\nstatic double\ncalc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues)\n{\n\tint\t\t\ti,\n\t\t\t\tlower_index;\n\tdouble\t\tbin_width,\n\t\t\t\tlower_bin_width;\n\tdouble\t\tsum_frac;\n\tfloat8\t\tprev_dist;\n\n\t/* Find the bin containing the lower bound of query range. */\n\tlower_index = rbound_bsearch(typcache, lower, hist_lower, hist_nvalues,\n\t\t\t\t\t\t\t\t true);\n\n\t/*\n\t * Calculate lower_bin_width, ie. the fraction of the of (lower_index,\n\t * lower_index + 1) bin which is greater than lower bound of query range\n\t * using linear interpolation of subdiff function.\n\t */\n\tif (lower_index >= 0 && lower_index < hist_nvalues - 1)\n\t\tlower_bin_width = get_position(typcache, lower, &hist_lower[lower_index],\n\t\t\t\t\t\t\t\t\t   &hist_lower[lower_index + 1]);\n\telse\n\t\tlower_bin_width = 0.0;\n\n\t/*\n\t * Loop through all the lower bound bins, smaller than the query lower\n\t * bound. In the loop, dist and prev_dist are the distance of the\n\t * \"current\" bin's lower and upper bounds from the constant upper bound.\n\t * We begin from query lower bound, and walk backwards, so the first bin's\n\t * upper bound is the query lower bound, and its distance to the query\n\t * upper bound is the length of the query range.\n\t *\n\t * bin_width represents the width of the current bin. Normally it is 1.0,\n\t * meaning a full width bin, except for the first bin, which is only\n\t * counted up to the constant lower bound.\n\t */\n\tprev_dist = get_distance(typcache, lower, upper);\n\tsum_frac = 0.0;\n\tbin_width = lower_bin_width;\n\tfor (i = lower_index; i >= 0; i--)\n\t{\n\t\tfloat8\t\tdist;\n\t\tdouble\t\tlength_hist_frac;\n\n\t\t/*\n\t\t * dist -- distance from upper bound of query range to current value\n\t\t * of lower bound histogram or lower bound of query range (if we've\n\t\t * reach it).\n\t\t */\n\t\tdist = get_distance(typcache, &hist_lower[i], upper);\n\n\t\t/*\n\t\t * Get average fraction of length histogram which covers intervals\n\t\t * longer than (or equal to) distance to upper bound of query range.\n\t\t */\n\t\tlength_hist_frac =\n\t\t\t1.0 - calc_length_hist_frac(length_hist_values,\n\t\t\t\t\t\t\t\t\t\tlength_hist_nvalues,\n\t\t\t\t\t\t\t\t\t\tprev_dist, dist, false);\n\n\t\tsum_frac += length_hist_frac * bin_width / (double) (hist_nvalues - 1);\n\n\t\tbin_width = 1.0;\n\t\tprev_dist = dist;\n\t}\n\n\treturn sum_frac;\n}"
  },
  {
    "function_name": "calc_hist_selectivity_contained",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
    "lines": "997-1096",
    "snippet": "static double\ncalc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues)\n{\n\tint\t\t\ti,\n\t\t\t\tupper_index;\n\tfloat8\t\tprev_dist;\n\tdouble\t\tbin_width;\n\tdouble\t\tupper_bin_width;\n\tdouble\t\tsum_frac;\n\n\t/*\n\t * Begin by finding the bin containing the upper bound, in the lower bound\n\t * histogram. Any range with a lower bound > constant upper bound can't\n\t * match, ie. there are no matches in bins greater than upper_index.\n\t */\n\tupper->inclusive = !upper->inclusive;\n\tupper->lower = true;\n\tupper_index = rbound_bsearch(typcache, upper, hist_lower, hist_nvalues,\n\t\t\t\t\t\t\t\t false);\n\n\t/*\n\t * Calculate upper_bin_width, ie. the fraction of the (upper_index,\n\t * upper_index + 1) bin which is greater than upper bound of query range\n\t * using linear interpolation of subdiff function.\n\t */\n\tif (upper_index >= 0 && upper_index < hist_nvalues - 1)\n\t\tupper_bin_width = get_position(typcache, upper,\n\t\t\t\t\t\t\t\t\t   &hist_lower[upper_index],\n\t\t\t\t\t\t\t\t\t   &hist_lower[upper_index + 1]);\n\telse\n\t\tupper_bin_width = 0.0;\n\n\t/*\n\t * In the loop, dist and prev_dist are the distance of the \"current\" bin's\n\t * lower and upper bounds from the constant upper bound.\n\t *\n\t * bin_width represents the width of the current bin. Normally it is 1.0,\n\t * meaning a full width bin, but can be less in the corner cases: start\n\t * and end of the loop. We start with bin_width = upper_bin_width, because\n\t * we begin at the bin containing the upper bound.\n\t */\n\tprev_dist = 0.0;\n\tbin_width = upper_bin_width;\n\n\tsum_frac = 0.0;\n\tfor (i = upper_index; i >= 0; i--)\n\t{\n\t\tdouble\t\tdist;\n\t\tdouble\t\tlength_hist_frac;\n\t\tbool\t\tfinal_bin = false;\n\n\t\t/*\n\t\t * dist -- distance from upper bound of query range to lower bound of\n\t\t * the current bin in the lower bound histogram. Or to the lower bound\n\t\t * of the constant range, if this is the final bin, containing the\n\t\t * constant lower bound.\n\t\t */\n\t\tif (range_cmp_bounds(typcache, &hist_lower[i], lower) < 0)\n\t\t{\n\t\t\tdist = get_distance(typcache, lower, upper);\n\n\t\t\t/*\n\t\t\t * Subtract from bin_width the portion of this bin that we want to\n\t\t\t * ignore.\n\t\t\t */\n\t\t\tbin_width -= get_position(typcache, lower, &hist_lower[i],\n\t\t\t\t\t\t\t\t\t  &hist_lower[i + 1]);\n\t\t\tif (bin_width < 0.0)\n\t\t\t\tbin_width = 0.0;\n\t\t\tfinal_bin = true;\n\t\t}\n\t\telse\n\t\t\tdist = get_distance(typcache, &hist_lower[i], upper);\n\n\t\t/*\n\t\t * Estimate the fraction of tuples in this bin that are narrow enough\n\t\t * to not exceed the distance to the upper bound of the query range.\n\t\t */\n\t\tlength_hist_frac = calc_length_hist_frac(length_hist_values,\n\t\t\t\t\t\t\t\t\t\t\t\t length_hist_nvalues,\n\t\t\t\t\t\t\t\t\t\t\t\t prev_dist, dist, true);\n\n\t\t/*\n\t\t * Add the fraction of tuples in this bin, with a suitable length, to\n\t\t * the total.\n\t\t */\n\t\tsum_frac += length_hist_frac * bin_width / (double) (hist_nvalues - 1);\n\n\t\tif (final_bin)\n\t\t\tbreak;\n\n\t\tbin_width = 1.0;\n\t\tprev_dist = dist;\n\t}\n\n\treturn sum_frac;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double calc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues);",
      "static double calc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "calc_length_hist_frac",
          "args": [
            "length_hist_values",
            "length_hist_nvalues",
            "prev_dist",
            "dist",
            "true"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "calc_length_hist_frac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "834-986",
          "snippet": "static double\ncalc_length_hist_frac(Datum *length_hist_values, int length_hist_nvalues,\n\t\t\t\t\t  double length1, double length2, bool equal)\n{\n\tdouble\t\tfrac;\n\tdouble\t\tA,\n\t\t\t\tB,\n\t\t\t\tPA,\n\t\t\t\tPB;\n\tdouble\t\tpos;\n\tint\t\t\ti;\n\tdouble\t\tarea;\n\n\tAssert(length2 >= length1);\n\n\tif (length2 < 0.0)\n\t\treturn 0.0;\t\t\t\t/* shouldn't happen, but doesn't hurt to check */\n\n\t/* All lengths in the table are <= infinite. */\n\tif (is_infinite(length2) && equal)\n\t\treturn 1.0;\n\n\t/*----------\n\t * The average of a function between A and B can be calculated by the\n\t * formula:\n\t *\n\t *\t\t\tB\n\t *\t  1\t\t/\n\t * -------\t| P(x)dx\n\t *\tB - A\t/\n\t *\t\t\tA\n\t *\n\t * The geometrical interpretation of the integral is the area under the\n\t * graph of P(x). P(x) is defined by the length histogram. We calculate\n\t * the area in a piecewise fashion, iterating through the length histogram\n\t * bins. Each bin is a trapezoid:\n\t *\n\t *\t\t P(x2)\n\t *\t\t  /|\n\t *\t\t / |\n\t * P(x1)/  |\n\t *\t   |   |\n\t *\t   |   |\n\t *\t---+---+--\n\t *\t   x1  x2\n\t *\n\t * where x1 and x2 are the boundaries of the current histogram, and P(x1)\n\t * and P(x1) are the cumulative fraction of tuples at the boundaries.\n\t *\n\t * The area of each trapezoid is 1/2 * (P(x2) + P(x1)) * (x2 - x1)\n\t *\n\t * The first bin contains the lower bound passed by the caller, so we\n\t * use linear interpolation between the previous and next histogram bin\n\t * boundary to calculate P(x1). Likewise for the last bin: we use linear\n\t * interpolation to calculate P(x2). For the bins in between, x1 and x2\n\t * lie on histogram bin boundaries, so P(x1) and P(x2) are simply:\n\t * P(x1) =\t  (bin index) / (number of bins)\n\t * P(x2) = (bin index + 1 / (number of bins)\n\t */\n\n\t/* First bin, the one that contains lower bound */\n\ti = length_hist_bsearch(length_hist_values, length_hist_nvalues, length1, equal);\n\tif (i >= length_hist_nvalues - 1)\n\t\treturn 1.0;\n\n\tif (i < 0)\n\t{\n\t\ti = 0;\n\t\tpos = 0.0;\n\t}\n\telse\n\t{\n\t\t/* interpolate length1's position in the bin */\n\t\tpos = get_len_position(length1,\n\t\t\t\t\t\t\t   DatumGetFloat8(length_hist_values[i]),\n\t\t\t\t\t\t\t   DatumGetFloat8(length_hist_values[i + 1]));\n\t}\n\tPB = (((double) i) + pos) / (double) (length_hist_nvalues - 1);\n\tB = length1;\n\n\t/*\n\t * In the degenerate case that length1 == length2, simply return\n\t * P(length1). This is not merely an optimization: if length1 == length2,\n\t * we'd divide by zero later on.\n\t */\n\tif (length2 == length1)\n\t\treturn PB;\n\n\t/*\n\t * Loop through all the bins, until we hit the last bin, the one that\n\t * contains the upper bound. (if lower and upper bounds are in the same\n\t * bin, this falls out immediately)\n\t */\n\tarea = 0.0;\n\tfor (; i < length_hist_nvalues - 1; i++)\n\t{\n\t\tdouble\t\tbin_upper = DatumGetFloat8(length_hist_values[i + 1]);\n\n\t\t/* check if we've reached the last bin */\n\t\tif (!(bin_upper < length2 || (equal && bin_upper <= length2)))\n\t\t\tbreak;\n\n\t\t/* the upper bound of previous bin is the lower bound of this bin */\n\t\tA = B;\n\t\tPA = PB;\n\n\t\tB = bin_upper;\n\t\tPB = (double) i / (double) (length_hist_nvalues - 1);\n\n\t\t/*\n\t\t * Add the area of this trapezoid to the total. The point of the\n\t\t * if-check is to avoid NaN, in the corner case that PA == PB == 0,\n\t\t * and B - A == Inf. The area of a zero-height trapezoid (PA == PB ==\n\t\t * 0) is zero, regardless of the width (B - A).\n\t\t */\n\t\tif (PA > 0 || PB > 0)\n\t\t\tarea += 0.5 * (PB + PA) * (B - A);\n\t}\n\n\t/* Last bin */\n\tA = B;\n\tPA = PB;\n\n\tB = length2;\t\t\t\t/* last bin ends at the query upper bound */\n\tif (i >= length_hist_nvalues - 1)\n\t\tpos = 0.0;\n\telse\n\t{\n\t\tif (DatumGetFloat8(length_hist_values[i]) == DatumGetFloat8(length_hist_values[i + 1]))\n\t\t\tpos = 0.0;\n\t\telse\n\t\t\tpos = get_len_position(length2, DatumGetFloat8(length_hist_values[i]), DatumGetFloat8(length_hist_values[i + 1]));\n\t}\n\tPB = (((double) i) + pos) / (double) (length_hist_nvalues - 1);\n\n\tif (PA > 0 || PB > 0)\n\t\tarea += 0.5 * (PB + PA) * (B - A);\n\n\t/*\n\t * Ok, we have calculated the area, ie. the integral. Divide by width to\n\t * get the requested average.\n\t *\n\t * Avoid NaN arising from infinite / infinite. This happens at least if\n\t * length2 is infinite. It's not clear what the correct value would be in\n\t * that case, so 0.5 seems as good as any value.\n\t */\n\tif (is_infinite(area) && is_infinite(length2))\n\t\tfrac = 0.5;\n\telse\n\t\tfrac = area / (length2 - length1);\n\n\treturn frac;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
            "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
            "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
            "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);",
            "static double calc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues);",
            "static double calc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\nstatic double calc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues);\nstatic double calc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues);\n\nstatic double\ncalc_length_hist_frac(Datum *length_hist_values, int length_hist_nvalues,\n\t\t\t\t\t  double length1, double length2, bool equal)\n{\n\tdouble\t\tfrac;\n\tdouble\t\tA,\n\t\t\t\tB,\n\t\t\t\tPA,\n\t\t\t\tPB;\n\tdouble\t\tpos;\n\tint\t\t\ti;\n\tdouble\t\tarea;\n\n\tAssert(length2 >= length1);\n\n\tif (length2 < 0.0)\n\t\treturn 0.0;\t\t\t\t/* shouldn't happen, but doesn't hurt to check */\n\n\t/* All lengths in the table are <= infinite. */\n\tif (is_infinite(length2) && equal)\n\t\treturn 1.0;\n\n\t/*----------\n\t * The average of a function between A and B can be calculated by the\n\t * formula:\n\t *\n\t *\t\t\tB\n\t *\t  1\t\t/\n\t * -------\t| P(x)dx\n\t *\tB - A\t/\n\t *\t\t\tA\n\t *\n\t * The geometrical interpretation of the integral is the area under the\n\t * graph of P(x). P(x) is defined by the length histogram. We calculate\n\t * the area in a piecewise fashion, iterating through the length histogram\n\t * bins. Each bin is a trapezoid:\n\t *\n\t *\t\t P(x2)\n\t *\t\t  /|\n\t *\t\t / |\n\t * P(x1)/  |\n\t *\t   |   |\n\t *\t   |   |\n\t *\t---+---+--\n\t *\t   x1  x2\n\t *\n\t * where x1 and x2 are the boundaries of the current histogram, and P(x1)\n\t * and P(x1) are the cumulative fraction of tuples at the boundaries.\n\t *\n\t * The area of each trapezoid is 1/2 * (P(x2) + P(x1)) * (x2 - x1)\n\t *\n\t * The first bin contains the lower bound passed by the caller, so we\n\t * use linear interpolation between the previous and next histogram bin\n\t * boundary to calculate P(x1). Likewise for the last bin: we use linear\n\t * interpolation to calculate P(x2). For the bins in between, x1 and x2\n\t * lie on histogram bin boundaries, so P(x1) and P(x2) are simply:\n\t * P(x1) =\t  (bin index) / (number of bins)\n\t * P(x2) = (bin index + 1 / (number of bins)\n\t */\n\n\t/* First bin, the one that contains lower bound */\n\ti = length_hist_bsearch(length_hist_values, length_hist_nvalues, length1, equal);\n\tif (i >= length_hist_nvalues - 1)\n\t\treturn 1.0;\n\n\tif (i < 0)\n\t{\n\t\ti = 0;\n\t\tpos = 0.0;\n\t}\n\telse\n\t{\n\t\t/* interpolate length1's position in the bin */\n\t\tpos = get_len_position(length1,\n\t\t\t\t\t\t\t   DatumGetFloat8(length_hist_values[i]),\n\t\t\t\t\t\t\t   DatumGetFloat8(length_hist_values[i + 1]));\n\t}\n\tPB = (((double) i) + pos) / (double) (length_hist_nvalues - 1);\n\tB = length1;\n\n\t/*\n\t * In the degenerate case that length1 == length2, simply return\n\t * P(length1). This is not merely an optimization: if length1 == length2,\n\t * we'd divide by zero later on.\n\t */\n\tif (length2 == length1)\n\t\treturn PB;\n\n\t/*\n\t * Loop through all the bins, until we hit the last bin, the one that\n\t * contains the upper bound. (if lower and upper bounds are in the same\n\t * bin, this falls out immediately)\n\t */\n\tarea = 0.0;\n\tfor (; i < length_hist_nvalues - 1; i++)\n\t{\n\t\tdouble\t\tbin_upper = DatumGetFloat8(length_hist_values[i + 1]);\n\n\t\t/* check if we've reached the last bin */\n\t\tif (!(bin_upper < length2 || (equal && bin_upper <= length2)))\n\t\t\tbreak;\n\n\t\t/* the upper bound of previous bin is the lower bound of this bin */\n\t\tA = B;\n\t\tPA = PB;\n\n\t\tB = bin_upper;\n\t\tPB = (double) i / (double) (length_hist_nvalues - 1);\n\n\t\t/*\n\t\t * Add the area of this trapezoid to the total. The point of the\n\t\t * if-check is to avoid NaN, in the corner case that PA == PB == 0,\n\t\t * and B - A == Inf. The area of a zero-height trapezoid (PA == PB ==\n\t\t * 0) is zero, regardless of the width (B - A).\n\t\t */\n\t\tif (PA > 0 || PB > 0)\n\t\t\tarea += 0.5 * (PB + PA) * (B - A);\n\t}\n\n\t/* Last bin */\n\tA = B;\n\tPA = PB;\n\n\tB = length2;\t\t\t\t/* last bin ends at the query upper bound */\n\tif (i >= length_hist_nvalues - 1)\n\t\tpos = 0.0;\n\telse\n\t{\n\t\tif (DatumGetFloat8(length_hist_values[i]) == DatumGetFloat8(length_hist_values[i + 1]))\n\t\t\tpos = 0.0;\n\t\telse\n\t\t\tpos = get_len_position(length2, DatumGetFloat8(length_hist_values[i]), DatumGetFloat8(length_hist_values[i + 1]));\n\t}\n\tPB = (((double) i) + pos) / (double) (length_hist_nvalues - 1);\n\n\tif (PA > 0 || PB > 0)\n\t\tarea += 0.5 * (PB + PA) * (B - A);\n\n\t/*\n\t * Ok, we have calculated the area, ie. the integral. Divide by width to\n\t * get the requested average.\n\t *\n\t * Avoid NaN arising from infinite / infinite. This happens at least if\n\t * length2 is infinite. It's not clear what the correct value would be in\n\t * that case, so 0.5 seems as good as any value.\n\t */\n\tif (is_infinite(area) && is_infinite(length2))\n\t\tfrac = 0.5;\n\telse\n\t\tfrac = area / (length2 - length1);\n\n\treturn frac;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_distance",
          "args": [
            "typcache",
            "&hist_lower[i]",
            "upper"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "get_distance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "794-827",
          "snippet": "static float8\nget_distance(TypeCacheEntry *typcache, RangeBound *bound1, RangeBound *bound2)\n{\n\tbool\t\thas_subdiff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\n\tif (!bound1->infinite && !bound2->infinite)\n\t{\n\t\t/*\n\t\t * No bounds are infinite, use subdiff function or return default\n\t\t * value of 1.0 if no subdiff is available.\n\t\t */\n\t\tif (has_subdiff)\n\t\t\treturn\n\t\t\t\tDatumGetFloat8(FunctionCall2Coll(&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t bound2->val,\n\t\t\t\t\t\t\t\t\t\t\t\t bound1->val));\n\t\telse\n\t\t\treturn 1.0;\n\t}\n\telse if (bound1->infinite && bound2->infinite)\n\t{\n\t\t/* Both bounds are infinite */\n\t\tif (bound1->lower == bound2->lower)\n\t\t\treturn 0.0;\n\t\telse\n\t\t\treturn get_float8_infinity();\n\t}\n\telse\n\t{\n\t\t/* One bound is infinite, another is not */\n\t\treturn get_float8_infinity();\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static float8 get_distance(TypeCacheEntry *typcache, RangeBound *bound1,\n\t\t\t RangeBound *bound2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic float8 get_distance(TypeCacheEntry *typcache, RangeBound *bound1,\n\t\t\t RangeBound *bound2);\n\nstatic float8\nget_distance(TypeCacheEntry *typcache, RangeBound *bound1, RangeBound *bound2)\n{\n\tbool\t\thas_subdiff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\n\tif (!bound1->infinite && !bound2->infinite)\n\t{\n\t\t/*\n\t\t * No bounds are infinite, use subdiff function or return default\n\t\t * value of 1.0 if no subdiff is available.\n\t\t */\n\t\tif (has_subdiff)\n\t\t\treturn\n\t\t\t\tDatumGetFloat8(FunctionCall2Coll(&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t bound2->val,\n\t\t\t\t\t\t\t\t\t\t\t\t bound1->val));\n\t\telse\n\t\t\treturn 1.0;\n\t}\n\telse if (bound1->infinite && bound2->infinite)\n\t{\n\t\t/* Both bounds are infinite */\n\t\tif (bound1->lower == bound2->lower)\n\t\t\treturn 0.0;\n\t\telse\n\t\t\treturn get_float8_infinity();\n\t}\n\telse\n\t{\n\t\t/* One bound is infinite, another is not */\n\t\treturn get_float8_infinity();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_position",
          "args": [
            "typcache",
            "lower",
            "&hist_lower[i]",
            "&hist_lower[i + 1]"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "get_position",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "672-743",
          "snippet": "static float8\nget_position(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist1,\n\t\t\t RangeBound *hist2)\n{\n\tbool\t\thas_subdiff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\tfloat8\t\tposition;\n\n\tif (!hist1->infinite && !hist2->infinite)\n\t{\n\t\tfloat8\t\tbin_width;\n\n\t\t/*\n\t\t * Both bounds are finite. Assuming the subtype's comparison function\n\t\t * works sanely, the value must be finite, too, because it lies\n\t\t * somewhere between the bounds. If it doesn't, just return something.\n\t\t */\n\t\tif (value->infinite)\n\t\t\treturn 0.5;\n\n\t\t/* Can't interpolate without subdiff function */\n\t\tif (!has_subdiff)\n\t\t\treturn 0.5;\n\n\t\t/* Calculate relative position using subdiff function. */\n\t\tbin_width = DatumGetFloat8(FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t &typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hist2->val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hist1->val));\n\t\tif (bin_width <= 0.0)\n\t\t\treturn 0.5;\t\t\t/* zero width bin */\n\n\t\tposition = DatumGetFloat8(FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\ttypcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue->val,\n\t\t\t\t\t\t\t\t\t\t\t\t\thist1->val))\n\t\t\t/ bin_width;\n\n\t\t/* Relative position must be in [0,1] range */\n\t\tposition = Max(position, 0.0);\n\t\tposition = Min(position, 1.0);\n\t\treturn position;\n\t}\n\telse if (hist1->infinite && !hist2->infinite)\n\t{\n\t\t/*\n\t\t * Lower bin boundary is -infinite, upper is finite. If the value is\n\t\t * -infinite, return 0.0 to indicate it's equal to the lower bound.\n\t\t * Otherwise return 1.0 to indicate it's infinitely far from the lower\n\t\t * bound.\n\t\t */\n\t\treturn ((value->infinite && value->lower) ? 0.0 : 1.0);\n\t}\n\telse if (!hist1->infinite && hist2->infinite)\n\t{\n\t\t/* same as above, but in reverse */\n\t\treturn ((value->infinite && !value->lower) ? 1.0 : 0.0);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If both bin boundaries are infinite, they should be equal to each\n\t\t * other, and the value should also be infinite and equal to both\n\t\t * bounds. (But don't Assert that, to avoid crashing if a user creates\n\t\t * a datatype with a broken comparison function).\n\t\t *\n\t\t * Assume the value to lie in the middle of the infinite bounds.\n\t\t */\n\t\treturn 0.5;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
            "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
            "static float8 get_position(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t RangeBound *hist1, RangeBound *hist2);",
            "static float8 get_len_position(double value, double hist1, double hist2);",
            "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
            "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic float8 get_position(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t RangeBound *hist1, RangeBound *hist2);\nstatic float8 get_len_position(double value, double hist1, double hist2);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\n\nstatic float8\nget_position(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist1,\n\t\t\t RangeBound *hist2)\n{\n\tbool\t\thas_subdiff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\tfloat8\t\tposition;\n\n\tif (!hist1->infinite && !hist2->infinite)\n\t{\n\t\tfloat8\t\tbin_width;\n\n\t\t/*\n\t\t * Both bounds are finite. Assuming the subtype's comparison function\n\t\t * works sanely, the value must be finite, too, because it lies\n\t\t * somewhere between the bounds. If it doesn't, just return something.\n\t\t */\n\t\tif (value->infinite)\n\t\t\treturn 0.5;\n\n\t\t/* Can't interpolate without subdiff function */\n\t\tif (!has_subdiff)\n\t\t\treturn 0.5;\n\n\t\t/* Calculate relative position using subdiff function. */\n\t\tbin_width = DatumGetFloat8(FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t &typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hist2->val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hist1->val));\n\t\tif (bin_width <= 0.0)\n\t\t\treturn 0.5;\t\t\t/* zero width bin */\n\n\t\tposition = DatumGetFloat8(FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\ttypcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue->val,\n\t\t\t\t\t\t\t\t\t\t\t\t\thist1->val))\n\t\t\t/ bin_width;\n\n\t\t/* Relative position must be in [0,1] range */\n\t\tposition = Max(position, 0.0);\n\t\tposition = Min(position, 1.0);\n\t\treturn position;\n\t}\n\telse if (hist1->infinite && !hist2->infinite)\n\t{\n\t\t/*\n\t\t * Lower bin boundary is -infinite, upper is finite. If the value is\n\t\t * -infinite, return 0.0 to indicate it's equal to the lower bound.\n\t\t * Otherwise return 1.0 to indicate it's infinitely far from the lower\n\t\t * bound.\n\t\t */\n\t\treturn ((value->infinite && value->lower) ? 0.0 : 1.0);\n\t}\n\telse if (!hist1->infinite && hist2->infinite)\n\t{\n\t\t/* same as above, but in reverse */\n\t\treturn ((value->infinite && !value->lower) ? 1.0 : 0.0);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If both bin boundaries are infinite, they should be equal to each\n\t\t * other, and the value should also be infinite and equal to both\n\t\t * bounds. (But don't Assert that, to avoid crashing if a user creates\n\t\t * a datatype with a broken comparison function).\n\t\t *\n\t\t * Assume the value to lie in the middle of the infinite bounds.\n\t\t */\n\t\treturn 0.5;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&hist_lower[i]",
            "lower"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rbound_bsearch",
          "args": [
            "typcache",
            "upper",
            "hist_lower",
            "hist_nvalues",
            "false"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "rbound_bsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "617-637",
          "snippet": "static int\nrbound_bsearch(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist,\n\t\t\t   int hist_length, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = hist_length - 1,\n\t\t\t\tcmp,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tmiddle = (lower + upper + 1) / 2;\n\t\tcmp = range_cmp_bounds(typcache, &hist[middle], value);\n\n\t\tif (cmp < 0 || (equal && cmp == 0))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
            "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
            "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
            "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\n\nstatic int\nrbound_bsearch(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist,\n\t\t\t   int hist_length, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = hist_length - 1,\n\t\t\t\tcmp,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tmiddle = (lower + upper + 1) / 2;\n\t\tcmp = range_cmp_bounds(typcache, &hist[middle], value);\n\n\t\tif (cmp < 0 || (equal && cmp == 0))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues);\nstatic double calc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues);\n\nstatic double\ncalc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues)\n{\n\tint\t\t\ti,\n\t\t\t\tupper_index;\n\tfloat8\t\tprev_dist;\n\tdouble\t\tbin_width;\n\tdouble\t\tupper_bin_width;\n\tdouble\t\tsum_frac;\n\n\t/*\n\t * Begin by finding the bin containing the upper bound, in the lower bound\n\t * histogram. Any range with a lower bound > constant upper bound can't\n\t * match, ie. there are no matches in bins greater than upper_index.\n\t */\n\tupper->inclusive = !upper->inclusive;\n\tupper->lower = true;\n\tupper_index = rbound_bsearch(typcache, upper, hist_lower, hist_nvalues,\n\t\t\t\t\t\t\t\t false);\n\n\t/*\n\t * Calculate upper_bin_width, ie. the fraction of the (upper_index,\n\t * upper_index + 1) bin which is greater than upper bound of query range\n\t * using linear interpolation of subdiff function.\n\t */\n\tif (upper_index >= 0 && upper_index < hist_nvalues - 1)\n\t\tupper_bin_width = get_position(typcache, upper,\n\t\t\t\t\t\t\t\t\t   &hist_lower[upper_index],\n\t\t\t\t\t\t\t\t\t   &hist_lower[upper_index + 1]);\n\telse\n\t\tupper_bin_width = 0.0;\n\n\t/*\n\t * In the loop, dist and prev_dist are the distance of the \"current\" bin's\n\t * lower and upper bounds from the constant upper bound.\n\t *\n\t * bin_width represents the width of the current bin. Normally it is 1.0,\n\t * meaning a full width bin, but can be less in the corner cases: start\n\t * and end of the loop. We start with bin_width = upper_bin_width, because\n\t * we begin at the bin containing the upper bound.\n\t */\n\tprev_dist = 0.0;\n\tbin_width = upper_bin_width;\n\n\tsum_frac = 0.0;\n\tfor (i = upper_index; i >= 0; i--)\n\t{\n\t\tdouble\t\tdist;\n\t\tdouble\t\tlength_hist_frac;\n\t\tbool\t\tfinal_bin = false;\n\n\t\t/*\n\t\t * dist -- distance from upper bound of query range to lower bound of\n\t\t * the current bin in the lower bound histogram. Or to the lower bound\n\t\t * of the constant range, if this is the final bin, containing the\n\t\t * constant lower bound.\n\t\t */\n\t\tif (range_cmp_bounds(typcache, &hist_lower[i], lower) < 0)\n\t\t{\n\t\t\tdist = get_distance(typcache, lower, upper);\n\n\t\t\t/*\n\t\t\t * Subtract from bin_width the portion of this bin that we want to\n\t\t\t * ignore.\n\t\t\t */\n\t\t\tbin_width -= get_position(typcache, lower, &hist_lower[i],\n\t\t\t\t\t\t\t\t\t  &hist_lower[i + 1]);\n\t\t\tif (bin_width < 0.0)\n\t\t\t\tbin_width = 0.0;\n\t\t\tfinal_bin = true;\n\t\t}\n\t\telse\n\t\t\tdist = get_distance(typcache, &hist_lower[i], upper);\n\n\t\t/*\n\t\t * Estimate the fraction of tuples in this bin that are narrow enough\n\t\t * to not exceed the distance to the upper bound of the query range.\n\t\t */\n\t\tlength_hist_frac = calc_length_hist_frac(length_hist_values,\n\t\t\t\t\t\t\t\t\t\t\t\t length_hist_nvalues,\n\t\t\t\t\t\t\t\t\t\t\t\t prev_dist, dist, true);\n\n\t\t/*\n\t\t * Add the fraction of tuples in this bin, with a suitable length, to\n\t\t * the total.\n\t\t */\n\t\tsum_frac += length_hist_frac * bin_width / (double) (hist_nvalues - 1);\n\n\t\tif (final_bin)\n\t\t\tbreak;\n\n\t\tbin_width = 1.0;\n\t\tprev_dist = dist;\n\t}\n\n\treturn sum_frac;\n}"
  },
  {
    "function_name": "calc_length_hist_frac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
    "lines": "834-986",
    "snippet": "static double\ncalc_length_hist_frac(Datum *length_hist_values, int length_hist_nvalues,\n\t\t\t\t\t  double length1, double length2, bool equal)\n{\n\tdouble\t\tfrac;\n\tdouble\t\tA,\n\t\t\t\tB,\n\t\t\t\tPA,\n\t\t\t\tPB;\n\tdouble\t\tpos;\n\tint\t\t\ti;\n\tdouble\t\tarea;\n\n\tAssert(length2 >= length1);\n\n\tif (length2 < 0.0)\n\t\treturn 0.0;\t\t\t\t/* shouldn't happen, but doesn't hurt to check */\n\n\t/* All lengths in the table are <= infinite. */\n\tif (is_infinite(length2) && equal)\n\t\treturn 1.0;\n\n\t/*----------\n\t * The average of a function between A and B can be calculated by the\n\t * formula:\n\t *\n\t *\t\t\tB\n\t *\t  1\t\t/\n\t * -------\t| P(x)dx\n\t *\tB - A\t/\n\t *\t\t\tA\n\t *\n\t * The geometrical interpretation of the integral is the area under the\n\t * graph of P(x). P(x) is defined by the length histogram. We calculate\n\t * the area in a piecewise fashion, iterating through the length histogram\n\t * bins. Each bin is a trapezoid:\n\t *\n\t *\t\t P(x2)\n\t *\t\t  /|\n\t *\t\t / |\n\t * P(x1)/  |\n\t *\t   |   |\n\t *\t   |   |\n\t *\t---+---+--\n\t *\t   x1  x2\n\t *\n\t * where x1 and x2 are the boundaries of the current histogram, and P(x1)\n\t * and P(x1) are the cumulative fraction of tuples at the boundaries.\n\t *\n\t * The area of each trapezoid is 1/2 * (P(x2) + P(x1)) * (x2 - x1)\n\t *\n\t * The first bin contains the lower bound passed by the caller, so we\n\t * use linear interpolation between the previous and next histogram bin\n\t * boundary to calculate P(x1). Likewise for the last bin: we use linear\n\t * interpolation to calculate P(x2). For the bins in between, x1 and x2\n\t * lie on histogram bin boundaries, so P(x1) and P(x2) are simply:\n\t * P(x1) =\t  (bin index) / (number of bins)\n\t * P(x2) = (bin index + 1 / (number of bins)\n\t */\n\n\t/* First bin, the one that contains lower bound */\n\ti = length_hist_bsearch(length_hist_values, length_hist_nvalues, length1, equal);\n\tif (i >= length_hist_nvalues - 1)\n\t\treturn 1.0;\n\n\tif (i < 0)\n\t{\n\t\ti = 0;\n\t\tpos = 0.0;\n\t}\n\telse\n\t{\n\t\t/* interpolate length1's position in the bin */\n\t\tpos = get_len_position(length1,\n\t\t\t\t\t\t\t   DatumGetFloat8(length_hist_values[i]),\n\t\t\t\t\t\t\t   DatumGetFloat8(length_hist_values[i + 1]));\n\t}\n\tPB = (((double) i) + pos) / (double) (length_hist_nvalues - 1);\n\tB = length1;\n\n\t/*\n\t * In the degenerate case that length1 == length2, simply return\n\t * P(length1). This is not merely an optimization: if length1 == length2,\n\t * we'd divide by zero later on.\n\t */\n\tif (length2 == length1)\n\t\treturn PB;\n\n\t/*\n\t * Loop through all the bins, until we hit the last bin, the one that\n\t * contains the upper bound. (if lower and upper bounds are in the same\n\t * bin, this falls out immediately)\n\t */\n\tarea = 0.0;\n\tfor (; i < length_hist_nvalues - 1; i++)\n\t{\n\t\tdouble\t\tbin_upper = DatumGetFloat8(length_hist_values[i + 1]);\n\n\t\t/* check if we've reached the last bin */\n\t\tif (!(bin_upper < length2 || (equal && bin_upper <= length2)))\n\t\t\tbreak;\n\n\t\t/* the upper bound of previous bin is the lower bound of this bin */\n\t\tA = B;\n\t\tPA = PB;\n\n\t\tB = bin_upper;\n\t\tPB = (double) i / (double) (length_hist_nvalues - 1);\n\n\t\t/*\n\t\t * Add the area of this trapezoid to the total. The point of the\n\t\t * if-check is to avoid NaN, in the corner case that PA == PB == 0,\n\t\t * and B - A == Inf. The area of a zero-height trapezoid (PA == PB ==\n\t\t * 0) is zero, regardless of the width (B - A).\n\t\t */\n\t\tif (PA > 0 || PB > 0)\n\t\t\tarea += 0.5 * (PB + PA) * (B - A);\n\t}\n\n\t/* Last bin */\n\tA = B;\n\tPA = PB;\n\n\tB = length2;\t\t\t\t/* last bin ends at the query upper bound */\n\tif (i >= length_hist_nvalues - 1)\n\t\tpos = 0.0;\n\telse\n\t{\n\t\tif (DatumGetFloat8(length_hist_values[i]) == DatumGetFloat8(length_hist_values[i + 1]))\n\t\t\tpos = 0.0;\n\t\telse\n\t\t\tpos = get_len_position(length2, DatumGetFloat8(length_hist_values[i]), DatumGetFloat8(length_hist_values[i + 1]));\n\t}\n\tPB = (((double) i) + pos) / (double) (length_hist_nvalues - 1);\n\n\tif (PA > 0 || PB > 0)\n\t\tarea += 0.5 * (PB + PA) * (B - A);\n\n\t/*\n\t * Ok, we have calculated the area, ie. the integral. Divide by width to\n\t * get the requested average.\n\t *\n\t * Avoid NaN arising from infinite / infinite. This happens at least if\n\t * length2 is infinite. It's not clear what the correct value would be in\n\t * that case, so 0.5 seems as good as any value.\n\t */\n\tif (is_infinite(area) && is_infinite(length2))\n\t\tfrac = 0.5;\n\telse\n\t\tfrac = area / (length2 - length1);\n\n\treturn frac;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
      "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
      "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
      "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);",
      "static double calc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues);",
      "static double calc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_infinite",
          "args": [
            "length2"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "is_infinite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "195-206",
          "snippet": "int\nis_infinite(double val)\n{\n\tint\t\t\tinf = isinf(val);\n\n\tif (inf == 0)\n\t\treturn 0;\n\telse if (val > 0)\n\t\treturn 1;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nis_infinite(double val)\n{\n\tint\t\t\tinf = isinf(val);\n\n\tif (inf == 0)\n\t\treturn 0;\n\telse if (val > 0)\n\t\treturn 1;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_len_position",
          "args": [
            "length2",
            "DatumGetFloat8(length_hist_values[i])",
            "DatumGetFloat8(length_hist_values[i + 1])"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "get_len_position",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "749-789",
          "snippet": "static double\nget_len_position(double value, double hist1, double hist2)\n{\n\tif (!is_infinite(hist1) && !is_infinite(hist2))\n\t{\n\t\t/*\n\t\t * Both bounds are finite. The value should be finite too, because it\n\t\t * lies somewhere between the bounds. If it doesn't, just return\n\t\t * something.\n\t\t */\n\t\tif (is_infinite(value))\n\t\t\treturn 0.5;\n\n\t\treturn 1.0 - (hist2 - value) / (hist2 - hist1);\n\t}\n\telse if (is_infinite(hist1) && !is_infinite(hist2))\n\t{\n\t\t/*\n\t\t * Lower bin boundary is -infinite, upper is finite. Return 1.0 to\n\t\t * indicate the value is infinitely far from the lower bound.\n\t\t */\n\t\treturn 1.0;\n\t}\n\telse if (is_infinite(hist1) && is_infinite(hist2))\n\t{\n\t\t/* same as above, but in reverse */\n\t\treturn 0.0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If both bin boundaries are infinite, they should be equal to each\n\t\t * other, and the value should also be infinite and equal to both\n\t\t * bounds. (But don't Assert that, to avoid crashing unnecessarily if\n\t\t * the caller messes up)\n\t\t *\n\t\t * Assume the value to lie in the middle of the infinite bounds.\n\t\t */\n\t\treturn 0.5;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
            "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
            "static float8 get_position(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t RangeBound *hist1, RangeBound *hist2);",
            "static float8 get_len_position(double value, double hist1, double hist2);",
            "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
            "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic float8 get_position(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t RangeBound *hist1, RangeBound *hist2);\nstatic float8 get_len_position(double value, double hist1, double hist2);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\n\nstatic double\nget_len_position(double value, double hist1, double hist2)\n{\n\tif (!is_infinite(hist1) && !is_infinite(hist2))\n\t{\n\t\t/*\n\t\t * Both bounds are finite. The value should be finite too, because it\n\t\t * lies somewhere between the bounds. If it doesn't, just return\n\t\t * something.\n\t\t */\n\t\tif (is_infinite(value))\n\t\t\treturn 0.5;\n\n\t\treturn 1.0 - (hist2 - value) / (hist2 - hist1);\n\t}\n\telse if (is_infinite(hist1) && !is_infinite(hist2))\n\t{\n\t\t/*\n\t\t * Lower bin boundary is -infinite, upper is finite. Return 1.0 to\n\t\t * indicate the value is infinitely far from the lower bound.\n\t\t */\n\t\treturn 1.0;\n\t}\n\telse if (is_infinite(hist1) && is_infinite(hist2))\n\t{\n\t\t/* same as above, but in reverse */\n\t\treturn 0.0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If both bin boundaries are infinite, they should be equal to each\n\t\t * other, and the value should also be infinite and equal to both\n\t\t * bounds. (But don't Assert that, to avoid crashing unnecessarily if\n\t\t * the caller messes up)\n\t\t *\n\t\t * Assume the value to lie in the middle of the infinite bounds.\n\t\t */\n\t\treturn 0.5;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "length_hist_values[i + 1]"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "length_hist_values[i]"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "length_hist_values[i + 1]"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "length_hist_values[i]"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "length_hist_values[i + 1]"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "length_hist_values[i + 1]"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "length_hist_values[i]"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "length_hist_bsearch",
          "args": [
            "length_hist_values",
            "length_hist_nvalues",
            "length1",
            "equal"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "length_hist_bsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "646-667",
          "snippet": "static int\nlength_hist_bsearch(Datum *length_hist_values, int length_hist_nvalues,\n\t\t\t\t\tdouble value, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = length_hist_nvalues - 1,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tdouble\t\tmiddleval;\n\n\t\tmiddle = (lower + upper + 1) / 2;\n\n\t\tmiddleval = DatumGetFloat8(length_hist_values[middle]);\n\t\tif (middleval < value || (equal && middleval <= value))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
            "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
            "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
            "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);",
            "static double calc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues);",
            "static double calc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\nstatic double calc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues);\nstatic double calc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues);\n\nstatic int\nlength_hist_bsearch(Datum *length_hist_values, int length_hist_nvalues,\n\t\t\t\t\tdouble value, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = length_hist_nvalues - 1,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tdouble\t\tmiddleval;\n\n\t\tmiddle = (lower + upper + 1) / 2;\n\n\t\tmiddleval = DatumGetFloat8(length_hist_values[middle]);\n\t\tif (middleval < value || (equal && middleval <= value))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "length2 >= length1"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\nstatic double calc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues);\nstatic double calc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues);\n\nstatic double\ncalc_length_hist_frac(Datum *length_hist_values, int length_hist_nvalues,\n\t\t\t\t\t  double length1, double length2, bool equal)\n{\n\tdouble\t\tfrac;\n\tdouble\t\tA,\n\t\t\t\tB,\n\t\t\t\tPA,\n\t\t\t\tPB;\n\tdouble\t\tpos;\n\tint\t\t\ti;\n\tdouble\t\tarea;\n\n\tAssert(length2 >= length1);\n\n\tif (length2 < 0.0)\n\t\treturn 0.0;\t\t\t\t/* shouldn't happen, but doesn't hurt to check */\n\n\t/* All lengths in the table are <= infinite. */\n\tif (is_infinite(length2) && equal)\n\t\treturn 1.0;\n\n\t/*----------\n\t * The average of a function between A and B can be calculated by the\n\t * formula:\n\t *\n\t *\t\t\tB\n\t *\t  1\t\t/\n\t * -------\t| P(x)dx\n\t *\tB - A\t/\n\t *\t\t\tA\n\t *\n\t * The geometrical interpretation of the integral is the area under the\n\t * graph of P(x). P(x) is defined by the length histogram. We calculate\n\t * the area in a piecewise fashion, iterating through the length histogram\n\t * bins. Each bin is a trapezoid:\n\t *\n\t *\t\t P(x2)\n\t *\t\t  /|\n\t *\t\t / |\n\t * P(x1)/  |\n\t *\t   |   |\n\t *\t   |   |\n\t *\t---+---+--\n\t *\t   x1  x2\n\t *\n\t * where x1 and x2 are the boundaries of the current histogram, and P(x1)\n\t * and P(x1) are the cumulative fraction of tuples at the boundaries.\n\t *\n\t * The area of each trapezoid is 1/2 * (P(x2) + P(x1)) * (x2 - x1)\n\t *\n\t * The first bin contains the lower bound passed by the caller, so we\n\t * use linear interpolation between the previous and next histogram bin\n\t * boundary to calculate P(x1). Likewise for the last bin: we use linear\n\t * interpolation to calculate P(x2). For the bins in between, x1 and x2\n\t * lie on histogram bin boundaries, so P(x1) and P(x2) are simply:\n\t * P(x1) =\t  (bin index) / (number of bins)\n\t * P(x2) = (bin index + 1 / (number of bins)\n\t */\n\n\t/* First bin, the one that contains lower bound */\n\ti = length_hist_bsearch(length_hist_values, length_hist_nvalues, length1, equal);\n\tif (i >= length_hist_nvalues - 1)\n\t\treturn 1.0;\n\n\tif (i < 0)\n\t{\n\t\ti = 0;\n\t\tpos = 0.0;\n\t}\n\telse\n\t{\n\t\t/* interpolate length1's position in the bin */\n\t\tpos = get_len_position(length1,\n\t\t\t\t\t\t\t   DatumGetFloat8(length_hist_values[i]),\n\t\t\t\t\t\t\t   DatumGetFloat8(length_hist_values[i + 1]));\n\t}\n\tPB = (((double) i) + pos) / (double) (length_hist_nvalues - 1);\n\tB = length1;\n\n\t/*\n\t * In the degenerate case that length1 == length2, simply return\n\t * P(length1). This is not merely an optimization: if length1 == length2,\n\t * we'd divide by zero later on.\n\t */\n\tif (length2 == length1)\n\t\treturn PB;\n\n\t/*\n\t * Loop through all the bins, until we hit the last bin, the one that\n\t * contains the upper bound. (if lower and upper bounds are in the same\n\t * bin, this falls out immediately)\n\t */\n\tarea = 0.0;\n\tfor (; i < length_hist_nvalues - 1; i++)\n\t{\n\t\tdouble\t\tbin_upper = DatumGetFloat8(length_hist_values[i + 1]);\n\n\t\t/* check if we've reached the last bin */\n\t\tif (!(bin_upper < length2 || (equal && bin_upper <= length2)))\n\t\t\tbreak;\n\n\t\t/* the upper bound of previous bin is the lower bound of this bin */\n\t\tA = B;\n\t\tPA = PB;\n\n\t\tB = bin_upper;\n\t\tPB = (double) i / (double) (length_hist_nvalues - 1);\n\n\t\t/*\n\t\t * Add the area of this trapezoid to the total. The point of the\n\t\t * if-check is to avoid NaN, in the corner case that PA == PB == 0,\n\t\t * and B - A == Inf. The area of a zero-height trapezoid (PA == PB ==\n\t\t * 0) is zero, regardless of the width (B - A).\n\t\t */\n\t\tif (PA > 0 || PB > 0)\n\t\t\tarea += 0.5 * (PB + PA) * (B - A);\n\t}\n\n\t/* Last bin */\n\tA = B;\n\tPA = PB;\n\n\tB = length2;\t\t\t\t/* last bin ends at the query upper bound */\n\tif (i >= length_hist_nvalues - 1)\n\t\tpos = 0.0;\n\telse\n\t{\n\t\tif (DatumGetFloat8(length_hist_values[i]) == DatumGetFloat8(length_hist_values[i + 1]))\n\t\t\tpos = 0.0;\n\t\telse\n\t\t\tpos = get_len_position(length2, DatumGetFloat8(length_hist_values[i]), DatumGetFloat8(length_hist_values[i + 1]));\n\t}\n\tPB = (((double) i) + pos) / (double) (length_hist_nvalues - 1);\n\n\tif (PA > 0 || PB > 0)\n\t\tarea += 0.5 * (PB + PA) * (B - A);\n\n\t/*\n\t * Ok, we have calculated the area, ie. the integral. Divide by width to\n\t * get the requested average.\n\t *\n\t * Avoid NaN arising from infinite / infinite. This happens at least if\n\t * length2 is infinite. It's not clear what the correct value would be in\n\t * that case, so 0.5 seems as good as any value.\n\t */\n\tif (is_infinite(area) && is_infinite(length2))\n\t\tfrac = 0.5;\n\telse\n\t\tfrac = area / (length2 - length1);\n\n\treturn frac;\n}"
  },
  {
    "function_name": "get_distance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
    "lines": "794-827",
    "snippet": "static float8\nget_distance(TypeCacheEntry *typcache, RangeBound *bound1, RangeBound *bound2)\n{\n\tbool\t\thas_subdiff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\n\tif (!bound1->infinite && !bound2->infinite)\n\t{\n\t\t/*\n\t\t * No bounds are infinite, use subdiff function or return default\n\t\t * value of 1.0 if no subdiff is available.\n\t\t */\n\t\tif (has_subdiff)\n\t\t\treturn\n\t\t\t\tDatumGetFloat8(FunctionCall2Coll(&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t bound2->val,\n\t\t\t\t\t\t\t\t\t\t\t\t bound1->val));\n\t\telse\n\t\t\treturn 1.0;\n\t}\n\telse if (bound1->infinite && bound2->infinite)\n\t{\n\t\t/* Both bounds are infinite */\n\t\tif (bound1->lower == bound2->lower)\n\t\t\treturn 0.0;\n\t\telse\n\t\t\treturn get_float8_infinity();\n\t}\n\telse\n\t{\n\t\t/* One bound is infinite, another is not */\n\t\treturn get_float8_infinity();\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static float8 get_distance(TypeCacheEntry *typcache, RangeBound *bound1,\n\t\t\t RangeBound *bound2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_float8_infinity",
          "args": [],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "get_float8_infinity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "117-132",
          "snippet": "double\nget_float8_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (double) INFINITY;\n#else\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (double) (HUGE_VAL * HUGE_VAL);\n#endif\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ndouble\nget_float8_infinity(void)\n{\n#ifdef INFINITY\n\t/* C99 standard way */\n\treturn (double) INFINITY;\n#else\n\n\t/*\n\t * On some platforms, HUGE_VAL is an infinity, elsewhere it's just the\n\t * largest normal double.  We assume forcing an overflow will get us a\n\t * true infinity.\n\t */\n\treturn (double) (HUGE_VAL * HUGE_VAL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "FunctionCall2Coll(&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t bound2->val,\n\t\t\t\t\t\t\t\t\t\t\t\t bound1->val)"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "&typcache->rng_subdiff_finfo",
            "typcache->rng_collation",
            "bound2->val",
            "bound1->val"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typcache->rng_subdiff_finfo.fn_oid"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic float8 get_distance(TypeCacheEntry *typcache, RangeBound *bound1,\n\t\t\t RangeBound *bound2);\n\nstatic float8\nget_distance(TypeCacheEntry *typcache, RangeBound *bound1, RangeBound *bound2)\n{\n\tbool\t\thas_subdiff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\n\tif (!bound1->infinite && !bound2->infinite)\n\t{\n\t\t/*\n\t\t * No bounds are infinite, use subdiff function or return default\n\t\t * value of 1.0 if no subdiff is available.\n\t\t */\n\t\tif (has_subdiff)\n\t\t\treturn\n\t\t\t\tDatumGetFloat8(FunctionCall2Coll(&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t bound2->val,\n\t\t\t\t\t\t\t\t\t\t\t\t bound1->val));\n\t\telse\n\t\t\treturn 1.0;\n\t}\n\telse if (bound1->infinite && bound2->infinite)\n\t{\n\t\t/* Both bounds are infinite */\n\t\tif (bound1->lower == bound2->lower)\n\t\t\treturn 0.0;\n\t\telse\n\t\t\treturn get_float8_infinity();\n\t}\n\telse\n\t{\n\t\t/* One bound is infinite, another is not */\n\t\treturn get_float8_infinity();\n\t}\n}"
  },
  {
    "function_name": "get_len_position",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
    "lines": "749-789",
    "snippet": "static double\nget_len_position(double value, double hist1, double hist2)\n{\n\tif (!is_infinite(hist1) && !is_infinite(hist2))\n\t{\n\t\t/*\n\t\t * Both bounds are finite. The value should be finite too, because it\n\t\t * lies somewhere between the bounds. If it doesn't, just return\n\t\t * something.\n\t\t */\n\t\tif (is_infinite(value))\n\t\t\treturn 0.5;\n\n\t\treturn 1.0 - (hist2 - value) / (hist2 - hist1);\n\t}\n\telse if (is_infinite(hist1) && !is_infinite(hist2))\n\t{\n\t\t/*\n\t\t * Lower bin boundary is -infinite, upper is finite. Return 1.0 to\n\t\t * indicate the value is infinitely far from the lower bound.\n\t\t */\n\t\treturn 1.0;\n\t}\n\telse if (is_infinite(hist1) && is_infinite(hist2))\n\t{\n\t\t/* same as above, but in reverse */\n\t\treturn 0.0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If both bin boundaries are infinite, they should be equal to each\n\t\t * other, and the value should also be infinite and equal to both\n\t\t * bounds. (But don't Assert that, to avoid crashing unnecessarily if\n\t\t * the caller messes up)\n\t\t *\n\t\t * Assume the value to lie in the middle of the infinite bounds.\n\t\t */\n\t\treturn 0.5;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
      "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
      "static float8 get_position(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t RangeBound *hist1, RangeBound *hist2);",
      "static float8 get_len_position(double value, double hist1, double hist2);",
      "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
      "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_infinite",
          "args": [
            "hist2"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "is_infinite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/float.c",
          "lines": "195-206",
          "snippet": "int\nis_infinite(double val)\n{\n\tint\t\t\tinf = isinf(val);\n\n\tif (inf == 0)\n\t\treturn 0;\n\telse if (val > 0)\n\t\treturn 1;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/sortsupport.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nint\nis_infinite(double val)\n{\n\tint\t\t\tinf = isinf(val);\n\n\tif (inf == 0)\n\t\treturn 0;\n\telse if (val > 0)\n\t\treturn 1;\n\telse\n\t\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic float8 get_position(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t RangeBound *hist1, RangeBound *hist2);\nstatic float8 get_len_position(double value, double hist1, double hist2);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\n\nstatic double\nget_len_position(double value, double hist1, double hist2)\n{\n\tif (!is_infinite(hist1) && !is_infinite(hist2))\n\t{\n\t\t/*\n\t\t * Both bounds are finite. The value should be finite too, because it\n\t\t * lies somewhere between the bounds. If it doesn't, just return\n\t\t * something.\n\t\t */\n\t\tif (is_infinite(value))\n\t\t\treturn 0.5;\n\n\t\treturn 1.0 - (hist2 - value) / (hist2 - hist1);\n\t}\n\telse if (is_infinite(hist1) && !is_infinite(hist2))\n\t{\n\t\t/*\n\t\t * Lower bin boundary is -infinite, upper is finite. Return 1.0 to\n\t\t * indicate the value is infinitely far from the lower bound.\n\t\t */\n\t\treturn 1.0;\n\t}\n\telse if (is_infinite(hist1) && is_infinite(hist2))\n\t{\n\t\t/* same as above, but in reverse */\n\t\treturn 0.0;\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If both bin boundaries are infinite, they should be equal to each\n\t\t * other, and the value should also be infinite and equal to both\n\t\t * bounds. (But don't Assert that, to avoid crashing unnecessarily if\n\t\t * the caller messes up)\n\t\t *\n\t\t * Assume the value to lie in the middle of the infinite bounds.\n\t\t */\n\t\treturn 0.5;\n\t}\n}"
  },
  {
    "function_name": "get_position",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
    "lines": "672-743",
    "snippet": "static float8\nget_position(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist1,\n\t\t\t RangeBound *hist2)\n{\n\tbool\t\thas_subdiff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\tfloat8\t\tposition;\n\n\tif (!hist1->infinite && !hist2->infinite)\n\t{\n\t\tfloat8\t\tbin_width;\n\n\t\t/*\n\t\t * Both bounds are finite. Assuming the subtype's comparison function\n\t\t * works sanely, the value must be finite, too, because it lies\n\t\t * somewhere between the bounds. If it doesn't, just return something.\n\t\t */\n\t\tif (value->infinite)\n\t\t\treturn 0.5;\n\n\t\t/* Can't interpolate without subdiff function */\n\t\tif (!has_subdiff)\n\t\t\treturn 0.5;\n\n\t\t/* Calculate relative position using subdiff function. */\n\t\tbin_width = DatumGetFloat8(FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t &typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hist2->val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hist1->val));\n\t\tif (bin_width <= 0.0)\n\t\t\treturn 0.5;\t\t\t/* zero width bin */\n\n\t\tposition = DatumGetFloat8(FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\ttypcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue->val,\n\t\t\t\t\t\t\t\t\t\t\t\t\thist1->val))\n\t\t\t/ bin_width;\n\n\t\t/* Relative position must be in [0,1] range */\n\t\tposition = Max(position, 0.0);\n\t\tposition = Min(position, 1.0);\n\t\treturn position;\n\t}\n\telse if (hist1->infinite && !hist2->infinite)\n\t{\n\t\t/*\n\t\t * Lower bin boundary is -infinite, upper is finite. If the value is\n\t\t * -infinite, return 0.0 to indicate it's equal to the lower bound.\n\t\t * Otherwise return 1.0 to indicate it's infinitely far from the lower\n\t\t * bound.\n\t\t */\n\t\treturn ((value->infinite && value->lower) ? 0.0 : 1.0);\n\t}\n\telse if (!hist1->infinite && hist2->infinite)\n\t{\n\t\t/* same as above, but in reverse */\n\t\treturn ((value->infinite && !value->lower) ? 1.0 : 0.0);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If both bin boundaries are infinite, they should be equal to each\n\t\t * other, and the value should also be infinite and equal to both\n\t\t * bounds. (But don't Assert that, to avoid crashing if a user creates\n\t\t * a datatype with a broken comparison function).\n\t\t *\n\t\t * Assume the value to lie in the middle of the infinite bounds.\n\t\t */\n\t\treturn 0.5;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
      "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
      "static float8 get_position(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t RangeBound *hist1, RangeBound *hist2);",
      "static float8 get_len_position(double value, double hist1, double hist2);",
      "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
      "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "position",
            "1.0"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "position",
            "0.0"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\ttypcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue->val,\n\t\t\t\t\t\t\t\t\t\t\t\t\thist1->val)"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FunctionCall2Coll",
          "args": [
            "&typcache->rng_subdiff_finfo",
            "typcache->rng_collation",
            "value->val",
            "hist1->val"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "OidFunctionCall2Coll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/fmgr/fmgr.c",
          "lines": "1427-1450",
          "snippet": "Datum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgrtab.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"pgstat.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"executor/functions.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgrtab.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"pgstat.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"executor/functions.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_language.h\"\n#include \"access/tuptoaster.h\"\n#include \"postgres.h\"\n\nDatum\nOidFunctionCall2Coll(Oid functionId, Oid collation, Datum arg1, Datum arg2)\n{\n\tFmgrInfo\tflinfo;\n\tFunctionCallInfoData fcinfo;\n\tDatum\t\tresult;\n\n\tfmgr_info(functionId, &flinfo);\n\n\tInitFunctionCallInfoData(fcinfo, &flinfo, 2, collation, NULL, NULL);\n\n\tfcinfo.arg[0] = arg1;\n\tfcinfo.arg[1] = arg2;\n\tfcinfo.argnull[0] = false;\n\tfcinfo.argnull[1] = false;\n\n\tresult = FunctionCallInvoke(&fcinfo);\n\n\t/* Check for null result, since caller is clearly not expecting one */\n\tif (fcinfo.isnull)\n\t\telog(ERROR, \"function %u returned NULL\", flinfo.fn_oid);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t &typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hist2->val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hist1->val)"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typcache->rng_subdiff_finfo.fn_oid"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic float8 get_position(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t RangeBound *hist1, RangeBound *hist2);\nstatic float8 get_len_position(double value, double hist1, double hist2);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\n\nstatic float8\nget_position(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist1,\n\t\t\t RangeBound *hist2)\n{\n\tbool\t\thas_subdiff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\tfloat8\t\tposition;\n\n\tif (!hist1->infinite && !hist2->infinite)\n\t{\n\t\tfloat8\t\tbin_width;\n\n\t\t/*\n\t\t * Both bounds are finite. Assuming the subtype's comparison function\n\t\t * works sanely, the value must be finite, too, because it lies\n\t\t * somewhere between the bounds. If it doesn't, just return something.\n\t\t */\n\t\tif (value->infinite)\n\t\t\treturn 0.5;\n\n\t\t/* Can't interpolate without subdiff function */\n\t\tif (!has_subdiff)\n\t\t\treturn 0.5;\n\n\t\t/* Calculate relative position using subdiff function. */\n\t\tbin_width = DatumGetFloat8(FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t &typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hist2->val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hist1->val));\n\t\tif (bin_width <= 0.0)\n\t\t\treturn 0.5;\t\t\t/* zero width bin */\n\n\t\tposition = DatumGetFloat8(FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\ttypcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue->val,\n\t\t\t\t\t\t\t\t\t\t\t\t\thist1->val))\n\t\t\t/ bin_width;\n\n\t\t/* Relative position must be in [0,1] range */\n\t\tposition = Max(position, 0.0);\n\t\tposition = Min(position, 1.0);\n\t\treturn position;\n\t}\n\telse if (hist1->infinite && !hist2->infinite)\n\t{\n\t\t/*\n\t\t * Lower bin boundary is -infinite, upper is finite. If the value is\n\t\t * -infinite, return 0.0 to indicate it's equal to the lower bound.\n\t\t * Otherwise return 1.0 to indicate it's infinitely far from the lower\n\t\t * bound.\n\t\t */\n\t\treturn ((value->infinite && value->lower) ? 0.0 : 1.0);\n\t}\n\telse if (!hist1->infinite && hist2->infinite)\n\t{\n\t\t/* same as above, but in reverse */\n\t\treturn ((value->infinite && !value->lower) ? 1.0 : 0.0);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If both bin boundaries are infinite, they should be equal to each\n\t\t * other, and the value should also be infinite and equal to both\n\t\t * bounds. (But don't Assert that, to avoid crashing if a user creates\n\t\t * a datatype with a broken comparison function).\n\t\t *\n\t\t * Assume the value to lie in the middle of the infinite bounds.\n\t\t */\n\t\treturn 0.5;\n\t}\n}"
  },
  {
    "function_name": "length_hist_bsearch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
    "lines": "646-667",
    "snippet": "static int\nlength_hist_bsearch(Datum *length_hist_values, int length_hist_nvalues,\n\t\t\t\t\tdouble value, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = length_hist_nvalues - 1,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tdouble\t\tmiddleval;\n\n\t\tmiddle = (lower + upper + 1) / 2;\n\n\t\tmiddleval = DatumGetFloat8(length_hist_values[middle]);\n\t\tif (middleval < value || (equal && middleval <= value))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
      "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
      "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
      "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);",
      "static double calc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues);",
      "static double calc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DatumGetFloat8",
          "args": [
            "length_hist_values[middle]"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\nstatic double calc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues);\nstatic double calc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues);\n\nstatic int\nlength_hist_bsearch(Datum *length_hist_values, int length_hist_nvalues,\n\t\t\t\t\tdouble value, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = length_hist_nvalues - 1,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tdouble\t\tmiddleval;\n\n\t\tmiddle = (lower + upper + 1) / 2;\n\n\t\tmiddleval = DatumGetFloat8(length_hist_values[middle]);\n\t\tif (middleval < value || (equal && middleval <= value))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}"
  },
  {
    "function_name": "rbound_bsearch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
    "lines": "617-637",
    "snippet": "static int\nrbound_bsearch(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist,\n\t\t\t   int hist_length, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = hist_length - 1,\n\t\t\t\tcmp,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tmiddle = (lower + upper + 1) / 2;\n\t\tcmp = range_cmp_bounds(typcache, &hist[middle], value);\n\n\t\tif (cmp < 0 || (equal && cmp == 0))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
      "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
      "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
      "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "range_cmp_bounds",
          "args": [
            "typcache",
            "&hist[middle]",
            "value"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "range_cmp_bounds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1831-1894",
          "snippet": "int\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nint\nrange_cmp_bounds(TypeCacheEntry *typcache, RangeBound *b1, RangeBound *b2)\n{\n\tint32\t\tresult;\n\n\t/*\n\t * First, handle cases involving infinity, which don't require invoking\n\t * the comparison proc.\n\t */\n\tif (b1->infinite && b2->infinite)\n\t{\n\t\t/*\n\t\t * Both are infinity, so they are equal unless one is lower and the\n\t\t * other not.\n\t\t */\n\t\tif (b1->lower == b2->lower)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn b1->lower ? -1 : 1;\n\t}\n\telse if (b1->infinite)\n\t\treturn b1->lower ? -1 : 1;\n\telse if (b2->infinite)\n\t\treturn b2->lower ? 1 : -1;\n\n\t/*\n\t * Both boundaries are finite, so compare the held values.\n\t */\n\tresult = DatumGetInt32(FunctionCall2Coll(&typcache->rng_cmp_proc_finfo,\n\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t b1->val, b2->val));\n\n\t/*\n\t * If the comparison is anything other than equal, we're done. If they\n\t * compare equal though, we still have to consider whether the boundaries\n\t * are inclusive or exclusive.\n\t */\n\tif (result == 0)\n\t{\n\t\tif (!b1->inclusive && !b2->inclusive)\n\t\t{\n\t\t\t/* both are exclusive */\n\t\t\tif (b1->lower == b2->lower)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn b1->lower ? 1 : -1;\n\t\t}\n\t\telse if (!b1->inclusive)\n\t\t\treturn b1->lower ? 1 : -1;\n\t\telse if (!b2->inclusive)\n\t\t\treturn b2->lower ? -1 : 1;\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * Both are inclusive and the values held are equal, so they are\n\t\t\t * equal regardless of whether they are upper or lower boundaries,\n\t\t\t * or a mix.\n\t\t\t */\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\n\nstatic int\nrbound_bsearch(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist,\n\t\t\t   int hist_length, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = hist_length - 1,\n\t\t\t\tcmp,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tmiddle = (lower + upper + 1) / 2;\n\t\tcmp = range_cmp_bounds(typcache, &hist[middle], value);\n\n\t\tif (cmp < 0 || (equal && cmp == 0))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}"
  },
  {
    "function_name": "calc_hist_selectivity_scalar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
    "lines": "585-605",
    "snippet": "static double\ncalc_hist_selectivity_scalar(TypeCacheEntry *typcache, RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues, bool equal)\n{\n\tSelectivity selec;\n\tint\t\t\tindex;\n\n\t/*\n\t * Find the histogram bin the given constant falls into. Estimate\n\t * selectivity as the number of preceding whole bins.\n\t */\n\tindex = rbound_bsearch(typcache, constbound, hist, hist_nvalues, equal);\n\tselec = (Selectivity) (Max(index, 0)) / (Selectivity) (hist_nvalues - 1);\n\n\t/* Adjust using linear interpolation within the bin */\n\tif (index >= 0 && index < hist_nvalues - 1)\n\t\tselec += get_position(typcache, constbound, &hist[index],\n\t\t\t\t\t\t\t  &hist[index + 1]) / (Selectivity) (hist_nvalues - 1);\n\n\treturn selec;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
      "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
      "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
      "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "hist_nvalues - 1"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_position",
          "args": [
            "typcache",
            "constbound",
            "&hist[index]",
            "&hist[index + 1]"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "get_position",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "672-743",
          "snippet": "static float8\nget_position(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist1,\n\t\t\t RangeBound *hist2)\n{\n\tbool\t\thas_subdiff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\tfloat8\t\tposition;\n\n\tif (!hist1->infinite && !hist2->infinite)\n\t{\n\t\tfloat8\t\tbin_width;\n\n\t\t/*\n\t\t * Both bounds are finite. Assuming the subtype's comparison function\n\t\t * works sanely, the value must be finite, too, because it lies\n\t\t * somewhere between the bounds. If it doesn't, just return something.\n\t\t */\n\t\tif (value->infinite)\n\t\t\treturn 0.5;\n\n\t\t/* Can't interpolate without subdiff function */\n\t\tif (!has_subdiff)\n\t\t\treturn 0.5;\n\n\t\t/* Calculate relative position using subdiff function. */\n\t\tbin_width = DatumGetFloat8(FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t &typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hist2->val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hist1->val));\n\t\tif (bin_width <= 0.0)\n\t\t\treturn 0.5;\t\t\t/* zero width bin */\n\n\t\tposition = DatumGetFloat8(FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\ttypcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue->val,\n\t\t\t\t\t\t\t\t\t\t\t\t\thist1->val))\n\t\t\t/ bin_width;\n\n\t\t/* Relative position must be in [0,1] range */\n\t\tposition = Max(position, 0.0);\n\t\tposition = Min(position, 1.0);\n\t\treturn position;\n\t}\n\telse if (hist1->infinite && !hist2->infinite)\n\t{\n\t\t/*\n\t\t * Lower bin boundary is -infinite, upper is finite. If the value is\n\t\t * -infinite, return 0.0 to indicate it's equal to the lower bound.\n\t\t * Otherwise return 1.0 to indicate it's infinitely far from the lower\n\t\t * bound.\n\t\t */\n\t\treturn ((value->infinite && value->lower) ? 0.0 : 1.0);\n\t}\n\telse if (!hist1->infinite && hist2->infinite)\n\t{\n\t\t/* same as above, but in reverse */\n\t\treturn ((value->infinite && !value->lower) ? 1.0 : 0.0);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If both bin boundaries are infinite, they should be equal to each\n\t\t * other, and the value should also be infinite and equal to both\n\t\t * bounds. (But don't Assert that, to avoid crashing if a user creates\n\t\t * a datatype with a broken comparison function).\n\t\t *\n\t\t * Assume the value to lie in the middle of the infinite bounds.\n\t\t */\n\t\treturn 0.5;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
            "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
            "static float8 get_position(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t RangeBound *hist1, RangeBound *hist2);",
            "static float8 get_len_position(double value, double hist1, double hist2);",
            "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
            "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic float8 get_position(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t RangeBound *hist1, RangeBound *hist2);\nstatic float8 get_len_position(double value, double hist1, double hist2);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\n\nstatic float8\nget_position(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist1,\n\t\t\t RangeBound *hist2)\n{\n\tbool\t\thas_subdiff = OidIsValid(typcache->rng_subdiff_finfo.fn_oid);\n\tfloat8\t\tposition;\n\n\tif (!hist1->infinite && !hist2->infinite)\n\t{\n\t\tfloat8\t\tbin_width;\n\n\t\t/*\n\t\t * Both bounds are finite. Assuming the subtype's comparison function\n\t\t * works sanely, the value must be finite, too, because it lies\n\t\t * somewhere between the bounds. If it doesn't, just return something.\n\t\t */\n\t\tif (value->infinite)\n\t\t\treturn 0.5;\n\n\t\t/* Can't interpolate without subdiff function */\n\t\tif (!has_subdiff)\n\t\t\treturn 0.5;\n\n\t\t/* Calculate relative position using subdiff function. */\n\t\tbin_width = DatumGetFloat8(FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t &typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t typcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hist2->val,\n\t\t\t\t\t\t\t\t\t\t\t\t\t hist1->val));\n\t\tif (bin_width <= 0.0)\n\t\t\treturn 0.5;\t\t\t/* zero width bin */\n\n\t\tposition = DatumGetFloat8(FunctionCall2Coll(\n\t\t\t\t\t\t\t\t\t\t\t\t\t&typcache->rng_subdiff_finfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\ttypcache->rng_collation,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue->val,\n\t\t\t\t\t\t\t\t\t\t\t\t\thist1->val))\n\t\t\t/ bin_width;\n\n\t\t/* Relative position must be in [0,1] range */\n\t\tposition = Max(position, 0.0);\n\t\tposition = Min(position, 1.0);\n\t\treturn position;\n\t}\n\telse if (hist1->infinite && !hist2->infinite)\n\t{\n\t\t/*\n\t\t * Lower bin boundary is -infinite, upper is finite. If the value is\n\t\t * -infinite, return 0.0 to indicate it's equal to the lower bound.\n\t\t * Otherwise return 1.0 to indicate it's infinitely far from the lower\n\t\t * bound.\n\t\t */\n\t\treturn ((value->infinite && value->lower) ? 0.0 : 1.0);\n\t}\n\telse if (!hist1->infinite && hist2->infinite)\n\t{\n\t\t/* same as above, but in reverse */\n\t\treturn ((value->infinite && !value->lower) ? 1.0 : 0.0);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If both bin boundaries are infinite, they should be equal to each\n\t\t * other, and the value should also be infinite and equal to both\n\t\t * bounds. (But don't Assert that, to avoid crashing if a user creates\n\t\t * a datatype with a broken comparison function).\n\t\t *\n\t\t * Assume the value to lie in the middle of the infinite bounds.\n\t\t */\n\t\treturn 0.5;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "hist_nvalues - 1"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "Max(index, 0)"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "index",
            "0"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rbound_bsearch",
          "args": [
            "typcache",
            "constbound",
            "hist",
            "hist_nvalues",
            "equal"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "rbound_bsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "617-637",
          "snippet": "static int\nrbound_bsearch(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist,\n\t\t\t   int hist_length, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = hist_length - 1,\n\t\t\t\tcmp,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tmiddle = (lower + upper + 1) / 2;\n\t\tcmp = range_cmp_bounds(typcache, &hist[middle], value);\n\n\t\tif (cmp < 0 || (equal && cmp == 0))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
            "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
            "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
            "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\n\nstatic int\nrbound_bsearch(TypeCacheEntry *typcache, RangeBound *value, RangeBound *hist,\n\t\t\t   int hist_length, bool equal)\n{\n\tint\t\t\tlower = -1,\n\t\t\t\tupper = hist_length - 1,\n\t\t\t\tcmp,\n\t\t\t\tmiddle;\n\n\twhile (lower < upper)\n\t{\n\t\tmiddle = (lower + upper + 1) / 2;\n\t\tcmp = range_cmp_bounds(typcache, &hist[middle], value);\n\n\t\tif (cmp < 0 || (equal && cmp == 0))\n\t\t\tlower = middle;\n\t\telse\n\t\t\tupper = middle - 1;\n\t}\n\treturn lower;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\n\nstatic double\ncalc_hist_selectivity_scalar(TypeCacheEntry *typcache, RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues, bool equal)\n{\n\tSelectivity selec;\n\tint\t\t\tindex;\n\n\t/*\n\t * Find the histogram bin the given constant falls into. Estimate\n\t * selectivity as the number of preceding whole bins.\n\t */\n\tindex = rbound_bsearch(typcache, constbound, hist, hist_nvalues, equal);\n\tselec = (Selectivity) (Max(index, 0)) / (Selectivity) (hist_nvalues - 1);\n\n\t/* Adjust using linear interpolation within the bin */\n\tif (index >= 0 && index < hist_nvalues - 1)\n\t\tselec += get_position(typcache, constbound, &hist[index],\n\t\t\t\t\t\t\t  &hist[index + 1]) / (Selectivity) (hist_nvalues - 1);\n\n\treturn selec;\n}"
  },
  {
    "function_name": "calc_hist_selectivity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
    "lines": "369-578",
    "snippet": "static double\ncalc_hist_selectivity(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t\t\t  RangeType *constval, Oid operator)\n{\n\tAttStatsSlot hslot;\n\tAttStatsSlot lslot;\n\tint\t\t\tnhist;\n\tRangeBound *hist_lower;\n\tRangeBound *hist_upper;\n\tint\t\t\ti;\n\tRangeBound\tconst_lower;\n\tRangeBound\tconst_upper;\n\tbool\t\tempty;\n\tdouble\t\thist_selec;\n\n\t/* Can't use the histogram with insecure range support functions */\n\tif (!statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t   typcache->rng_cmp_proc_finfo.fn_oid))\n\t\treturn -1;\n\tif (OidIsValid(typcache->rng_subdiff_finfo.fn_oid) &&\n\t\t!statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t   typcache->rng_subdiff_finfo.fn_oid))\n\t\treturn -1;\n\n\t/* Try to get histogram of ranges */\n\tif (!(HeapTupleIsValid(vardata->statsTuple) &&\n\t\t  get_attstatsslot(&hslot, vardata->statsTuple,\n\t\t\t\t\t\t   STATISTIC_KIND_BOUNDS_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t   ATTSTATSSLOT_VALUES)))\n\t\treturn -1.0;\n\n\t/*\n\t * Convert histogram of ranges into histograms of its lower and upper\n\t * bounds.\n\t */\n\tnhist = hslot.nvalues;\n\thist_lower = (RangeBound *) palloc(sizeof(RangeBound) * nhist);\n\thist_upper = (RangeBound *) palloc(sizeof(RangeBound) * nhist);\n\tfor (i = 0; i < nhist; i++)\n\t{\n\t\trange_deserialize(typcache, DatumGetRangeTypeP(hslot.values[i]),\n\t\t\t\t\t\t  &hist_lower[i], &hist_upper[i], &empty);\n\t\t/* The histogram should not contain any empty ranges */\n\t\tif (empty)\n\t\t\telog(ERROR, \"bounds histogram contains an empty range\");\n\t}\n\n\t/* @> and @< also need a histogram of range lengths */\n\tif (operator == OID_RANGE_CONTAINS_OP ||\n\t\toperator == OID_RANGE_CONTAINED_OP)\n\t{\n\t\tif (!(HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t  get_attstatsslot(&lslot, vardata->statsTuple,\n\t\t\t\t\t\t\t   STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM,\n\t\t\t\t\t\t\t   InvalidOid,\n\t\t\t\t\t\t\t   ATTSTATSSLOT_VALUES)))\n\t\t{\n\t\t\tfree_attstatsslot(&hslot);\n\t\t\treturn -1.0;\n\t\t}\n\n\t\t/* check that it's a histogram, not just a dummy entry */\n\t\tif (lslot.nvalues < 2)\n\t\t{\n\t\t\tfree_attstatsslot(&lslot);\n\t\t\tfree_attstatsslot(&hslot);\n\t\t\treturn -1.0;\n\t\t}\n\t}\n\telse\n\t\tmemset(&lslot, 0, sizeof(lslot));\n\n\t/* Extract the bounds of the constant value. */\n\trange_deserialize(typcache, constval, &const_lower, &const_upper, &empty);\n\tAssert(!empty);\n\n\t/*\n\t * Calculate selectivity comparing the lower or upper bound of the\n\t * constant with the histogram of lower or upper bounds.\n\t */\n\tswitch (operator)\n\t{\n\t\tcase OID_RANGE_LESS_OP:\n\n\t\t\t/*\n\t\t\t * The regular b-tree comparison operators (<, <=, >, >=) compare\n\t\t\t * the lower bounds first, and the upper bounds for values with\n\t\t\t * equal lower bounds. Estimate that by comparing the lower bounds\n\t\t\t * only. This gives a fairly accurate estimate assuming there\n\t\t\t * aren't many rows with a lower bound equal to the constant's\n\t\t\t * lower bound.\n\t\t\t */\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, false);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_LESS_EQUAL_OP:\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, true);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_GREATER_OP:\n\t\t\thist_selec =\n\t\t\t\t1 - calc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, false);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_GREATER_EQUAL_OP:\n\t\t\thist_selec =\n\t\t\t\t1 - calc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, true);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_LEFT_OP:\n\t\t\t/* var << const when upper(var) < lower(const) */\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t hist_upper, nhist, false);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_RIGHT_OP:\n\t\t\t/* var >> const when lower(var) > upper(const) */\n\t\t\thist_selec =\n\t\t\t\t1 - calc_hist_selectivity_scalar(typcache, &const_upper,\n\t\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, true);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_OVERLAPS_RIGHT_OP:\n\t\t\t/* compare lower bounds */\n\t\t\thist_selec =\n\t\t\t\t1 - calc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, false);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_OVERLAPS_LEFT_OP:\n\t\t\t/* compare upper bounds */\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_upper,\n\t\t\t\t\t\t\t\t\t\t\t hist_upper, nhist, true);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_OVERLAP_OP:\n\t\tcase OID_RANGE_CONTAINS_ELEM_OP:\n\n\t\t\t/*\n\t\t\t * A && B <=> NOT (A << B OR A >> B).\n\t\t\t *\n\t\t\t * Since A << B and A >> B are mutually exclusive events we can\n\t\t\t * sum their probabilities to find probability of (A << B OR A >>\n\t\t\t * B).\n\t\t\t *\n\t\t\t * \"range @> elem\" is equivalent to \"range && [elem,elem]\". The\n\t\t\t * caller already constructed the singular range from the element\n\t\t\t * constant, so just treat it the same as &&.\n\t\t\t */\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_lower, hist_upper,\n\t\t\t\t\t\t\t\t\t\t\t nhist, false);\n\t\t\thist_selec +=\n\t\t\t\t(1.0 - calc_hist_selectivity_scalar(typcache, &const_upper, hist_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnhist, true));\n\t\t\thist_selec = 1.0 - hist_selec;\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_CONTAINS_OP:\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_contains(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t   &const_upper, hist_lower, nhist,\n\t\t\t\t\t\t\t\t\t\t\t   lslot.values, lslot.nvalues);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_CONTAINED_OP:\n\t\t\tif (const_lower.infinite)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Lower bound no longer matters. Just estimate the fraction\n\t\t\t\t * with an upper bound <= const upper bound\n\t\t\t\t */\n\t\t\t\thist_selec =\n\t\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_upper,\n\t\t\t\t\t\t\t\t\t\t\t\t hist_upper, nhist, true);\n\t\t\t}\n\t\t\telse if (const_upper.infinite)\n\t\t\t{\n\t\t\t\thist_selec =\n\t\t\t\t\t1.0 - calc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   hist_lower, nhist, false);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thist_selec =\n\t\t\t\t\tcalc_hist_selectivity_contained(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t\t&const_upper, hist_lower, nhist,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlslot.values, lslot.nvalues);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown range operator %u\", operator);\n\t\t\thist_selec = -1.0;\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\tfree_attstatsslot(&lslot);\n\tfree_attstatsslot(&hslot);\n\n\treturn hist_selec;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double calc_rangesel(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t  RangeType *constval, Oid operator);",
      "static double default_range_selectivity(Oid operator);",
      "static double calc_hist_selectivity(TypeCacheEntry *typcache,\n\t\t\t\t\t  VariableStatData *vardata, RangeType *constval,\n\t\t\t\t\t  Oid operator);",
      "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
      "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
      "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
      "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_attstatsslot",
          "args": [
            "&hslot"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unknown range operator %u\"",
            "operator"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_hist_selectivity_contained",
          "args": [
            "typcache",
            "&const_lower",
            "&const_upper",
            "hist_lower",
            "nhist",
            "lslot.values",
            "lslot.nvalues"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "calc_hist_selectivity_contained",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "997-1096",
          "snippet": "static double\ncalc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues)\n{\n\tint\t\t\ti,\n\t\t\t\tupper_index;\n\tfloat8\t\tprev_dist;\n\tdouble\t\tbin_width;\n\tdouble\t\tupper_bin_width;\n\tdouble\t\tsum_frac;\n\n\t/*\n\t * Begin by finding the bin containing the upper bound, in the lower bound\n\t * histogram. Any range with a lower bound > constant upper bound can't\n\t * match, ie. there are no matches in bins greater than upper_index.\n\t */\n\tupper->inclusive = !upper->inclusive;\n\tupper->lower = true;\n\tupper_index = rbound_bsearch(typcache, upper, hist_lower, hist_nvalues,\n\t\t\t\t\t\t\t\t false);\n\n\t/*\n\t * Calculate upper_bin_width, ie. the fraction of the (upper_index,\n\t * upper_index + 1) bin which is greater than upper bound of query range\n\t * using linear interpolation of subdiff function.\n\t */\n\tif (upper_index >= 0 && upper_index < hist_nvalues - 1)\n\t\tupper_bin_width = get_position(typcache, upper,\n\t\t\t\t\t\t\t\t\t   &hist_lower[upper_index],\n\t\t\t\t\t\t\t\t\t   &hist_lower[upper_index + 1]);\n\telse\n\t\tupper_bin_width = 0.0;\n\n\t/*\n\t * In the loop, dist and prev_dist are the distance of the \"current\" bin's\n\t * lower and upper bounds from the constant upper bound.\n\t *\n\t * bin_width represents the width of the current bin. Normally it is 1.0,\n\t * meaning a full width bin, but can be less in the corner cases: start\n\t * and end of the loop. We start with bin_width = upper_bin_width, because\n\t * we begin at the bin containing the upper bound.\n\t */\n\tprev_dist = 0.0;\n\tbin_width = upper_bin_width;\n\n\tsum_frac = 0.0;\n\tfor (i = upper_index; i >= 0; i--)\n\t{\n\t\tdouble\t\tdist;\n\t\tdouble\t\tlength_hist_frac;\n\t\tbool\t\tfinal_bin = false;\n\n\t\t/*\n\t\t * dist -- distance from upper bound of query range to lower bound of\n\t\t * the current bin in the lower bound histogram. Or to the lower bound\n\t\t * of the constant range, if this is the final bin, containing the\n\t\t * constant lower bound.\n\t\t */\n\t\tif (range_cmp_bounds(typcache, &hist_lower[i], lower) < 0)\n\t\t{\n\t\t\tdist = get_distance(typcache, lower, upper);\n\n\t\t\t/*\n\t\t\t * Subtract from bin_width the portion of this bin that we want to\n\t\t\t * ignore.\n\t\t\t */\n\t\t\tbin_width -= get_position(typcache, lower, &hist_lower[i],\n\t\t\t\t\t\t\t\t\t  &hist_lower[i + 1]);\n\t\t\tif (bin_width < 0.0)\n\t\t\t\tbin_width = 0.0;\n\t\t\tfinal_bin = true;\n\t\t}\n\t\telse\n\t\t\tdist = get_distance(typcache, &hist_lower[i], upper);\n\n\t\t/*\n\t\t * Estimate the fraction of tuples in this bin that are narrow enough\n\t\t * to not exceed the distance to the upper bound of the query range.\n\t\t */\n\t\tlength_hist_frac = calc_length_hist_frac(length_hist_values,\n\t\t\t\t\t\t\t\t\t\t\t\t length_hist_nvalues,\n\t\t\t\t\t\t\t\t\t\t\t\t prev_dist, dist, true);\n\n\t\t/*\n\t\t * Add the fraction of tuples in this bin, with a suitable length, to\n\t\t * the total.\n\t\t */\n\t\tsum_frac += length_hist_frac * bin_width / (double) (hist_nvalues - 1);\n\n\t\tif (final_bin)\n\t\t\tbreak;\n\n\t\tbin_width = 1.0;\n\t\tprev_dist = dist;\n\t}\n\n\treturn sum_frac;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues);",
            "static double calc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues);\nstatic double calc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues);\n\nstatic double\ncalc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues)\n{\n\tint\t\t\ti,\n\t\t\t\tupper_index;\n\tfloat8\t\tprev_dist;\n\tdouble\t\tbin_width;\n\tdouble\t\tupper_bin_width;\n\tdouble\t\tsum_frac;\n\n\t/*\n\t * Begin by finding the bin containing the upper bound, in the lower bound\n\t * histogram. Any range with a lower bound > constant upper bound can't\n\t * match, ie. there are no matches in bins greater than upper_index.\n\t */\n\tupper->inclusive = !upper->inclusive;\n\tupper->lower = true;\n\tupper_index = rbound_bsearch(typcache, upper, hist_lower, hist_nvalues,\n\t\t\t\t\t\t\t\t false);\n\n\t/*\n\t * Calculate upper_bin_width, ie. the fraction of the (upper_index,\n\t * upper_index + 1) bin which is greater than upper bound of query range\n\t * using linear interpolation of subdiff function.\n\t */\n\tif (upper_index >= 0 && upper_index < hist_nvalues - 1)\n\t\tupper_bin_width = get_position(typcache, upper,\n\t\t\t\t\t\t\t\t\t   &hist_lower[upper_index],\n\t\t\t\t\t\t\t\t\t   &hist_lower[upper_index + 1]);\n\telse\n\t\tupper_bin_width = 0.0;\n\n\t/*\n\t * In the loop, dist and prev_dist are the distance of the \"current\" bin's\n\t * lower and upper bounds from the constant upper bound.\n\t *\n\t * bin_width represents the width of the current bin. Normally it is 1.0,\n\t * meaning a full width bin, but can be less in the corner cases: start\n\t * and end of the loop. We start with bin_width = upper_bin_width, because\n\t * we begin at the bin containing the upper bound.\n\t */\n\tprev_dist = 0.0;\n\tbin_width = upper_bin_width;\n\n\tsum_frac = 0.0;\n\tfor (i = upper_index; i >= 0; i--)\n\t{\n\t\tdouble\t\tdist;\n\t\tdouble\t\tlength_hist_frac;\n\t\tbool\t\tfinal_bin = false;\n\n\t\t/*\n\t\t * dist -- distance from upper bound of query range to lower bound of\n\t\t * the current bin in the lower bound histogram. Or to the lower bound\n\t\t * of the constant range, if this is the final bin, containing the\n\t\t * constant lower bound.\n\t\t */\n\t\tif (range_cmp_bounds(typcache, &hist_lower[i], lower) < 0)\n\t\t{\n\t\t\tdist = get_distance(typcache, lower, upper);\n\n\t\t\t/*\n\t\t\t * Subtract from bin_width the portion of this bin that we want to\n\t\t\t * ignore.\n\t\t\t */\n\t\t\tbin_width -= get_position(typcache, lower, &hist_lower[i],\n\t\t\t\t\t\t\t\t\t  &hist_lower[i + 1]);\n\t\t\tif (bin_width < 0.0)\n\t\t\t\tbin_width = 0.0;\n\t\t\tfinal_bin = true;\n\t\t}\n\t\telse\n\t\t\tdist = get_distance(typcache, &hist_lower[i], upper);\n\n\t\t/*\n\t\t * Estimate the fraction of tuples in this bin that are narrow enough\n\t\t * to not exceed the distance to the upper bound of the query range.\n\t\t */\n\t\tlength_hist_frac = calc_length_hist_frac(length_hist_values,\n\t\t\t\t\t\t\t\t\t\t\t\t length_hist_nvalues,\n\t\t\t\t\t\t\t\t\t\t\t\t prev_dist, dist, true);\n\n\t\t/*\n\t\t * Add the fraction of tuples in this bin, with a suitable length, to\n\t\t * the total.\n\t\t */\n\t\tsum_frac += length_hist_frac * bin_width / (double) (hist_nvalues - 1);\n\n\t\tif (final_bin)\n\t\t\tbreak;\n\n\t\tbin_width = 1.0;\n\t\tprev_dist = dist;\n\t}\n\n\treturn sum_frac;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_hist_selectivity_scalar",
          "args": [
            "typcache",
            "&const_lower",
            "hist_lower",
            "nhist",
            "false"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "calc_hist_selectivity_scalar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "585-605",
          "snippet": "static double\ncalc_hist_selectivity_scalar(TypeCacheEntry *typcache, RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues, bool equal)\n{\n\tSelectivity selec;\n\tint\t\t\tindex;\n\n\t/*\n\t * Find the histogram bin the given constant falls into. Estimate\n\t * selectivity as the number of preceding whole bins.\n\t */\n\tindex = rbound_bsearch(typcache, constbound, hist, hist_nvalues, equal);\n\tselec = (Selectivity) (Max(index, 0)) / (Selectivity) (hist_nvalues - 1);\n\n\t/* Adjust using linear interpolation within the bin */\n\tif (index >= 0 && index < hist_nvalues - 1)\n\t\tselec += get_position(typcache, constbound, &hist[index],\n\t\t\t\t\t\t\t  &hist[index + 1]) / (Selectivity) (hist_nvalues - 1);\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
            "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
            "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
            "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\n\nstatic double\ncalc_hist_selectivity_scalar(TypeCacheEntry *typcache, RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues, bool equal)\n{\n\tSelectivity selec;\n\tint\t\t\tindex;\n\n\t/*\n\t * Find the histogram bin the given constant falls into. Estimate\n\t * selectivity as the number of preceding whole bins.\n\t */\n\tindex = rbound_bsearch(typcache, constbound, hist, hist_nvalues, equal);\n\tselec = (Selectivity) (Max(index, 0)) / (Selectivity) (hist_nvalues - 1);\n\n\t/* Adjust using linear interpolation within the bin */\n\tif (index >= 0 && index < hist_nvalues - 1)\n\t\tselec += get_position(typcache, constbound, &hist[index],\n\t\t\t\t\t\t\t  &hist[index + 1]) / (Selectivity) (hist_nvalues - 1);\n\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_hist_selectivity_contains",
          "args": [
            "typcache",
            "&const_lower",
            "&const_upper",
            "hist_lower",
            "nhist",
            "lslot.values",
            "lslot.nvalues"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "calc_hist_selectivity_contains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "1107-1178",
          "snippet": "static double\ncalc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues)\n{\n\tint\t\t\ti,\n\t\t\t\tlower_index;\n\tdouble\t\tbin_width,\n\t\t\t\tlower_bin_width;\n\tdouble\t\tsum_frac;\n\tfloat8\t\tprev_dist;\n\n\t/* Find the bin containing the lower bound of query range. */\n\tlower_index = rbound_bsearch(typcache, lower, hist_lower, hist_nvalues,\n\t\t\t\t\t\t\t\t true);\n\n\t/*\n\t * Calculate lower_bin_width, ie. the fraction of the of (lower_index,\n\t * lower_index + 1) bin which is greater than lower bound of query range\n\t * using linear interpolation of subdiff function.\n\t */\n\tif (lower_index >= 0 && lower_index < hist_nvalues - 1)\n\t\tlower_bin_width = get_position(typcache, lower, &hist_lower[lower_index],\n\t\t\t\t\t\t\t\t\t   &hist_lower[lower_index + 1]);\n\telse\n\t\tlower_bin_width = 0.0;\n\n\t/*\n\t * Loop through all the lower bound bins, smaller than the query lower\n\t * bound. In the loop, dist and prev_dist are the distance of the\n\t * \"current\" bin's lower and upper bounds from the constant upper bound.\n\t * We begin from query lower bound, and walk backwards, so the first bin's\n\t * upper bound is the query lower bound, and its distance to the query\n\t * upper bound is the length of the query range.\n\t *\n\t * bin_width represents the width of the current bin. Normally it is 1.0,\n\t * meaning a full width bin, except for the first bin, which is only\n\t * counted up to the constant lower bound.\n\t */\n\tprev_dist = get_distance(typcache, lower, upper);\n\tsum_frac = 0.0;\n\tbin_width = lower_bin_width;\n\tfor (i = lower_index; i >= 0; i--)\n\t{\n\t\tfloat8\t\tdist;\n\t\tdouble\t\tlength_hist_frac;\n\n\t\t/*\n\t\t * dist -- distance from upper bound of query range to current value\n\t\t * of lower bound histogram or lower bound of query range (if we've\n\t\t * reach it).\n\t\t */\n\t\tdist = get_distance(typcache, &hist_lower[i], upper);\n\n\t\t/*\n\t\t * Get average fraction of length histogram which covers intervals\n\t\t * longer than (or equal to) distance to upper bound of query range.\n\t\t */\n\t\tlength_hist_frac =\n\t\t\t1.0 - calc_length_hist_frac(length_hist_values,\n\t\t\t\t\t\t\t\t\t\tlength_hist_nvalues,\n\t\t\t\t\t\t\t\t\t\tprev_dist, dist, false);\n\n\t\tsum_frac += length_hist_frac * bin_width / (double) (hist_nvalues - 1);\n\n\t\tbin_width = 1.0;\n\t\tprev_dist = dist;\n\t}\n\n\treturn sum_frac;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
            "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
            "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
            "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);",
            "static double calc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues);",
            "static double calc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\nstatic double calc_hist_selectivity_contained(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t\tRangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t\tRangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t\tDatum *length_hist_values, int length_hist_nvalues);\nstatic double calc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues);\n\nstatic double\ncalc_hist_selectivity_contains(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t   RangeBound *lower, RangeBound *upper,\n\t\t\t\t\t\t\t   RangeBound *hist_lower, int hist_nvalues,\n\t\t\t\t\t\t\t   Datum *length_hist_values, int length_hist_nvalues)\n{\n\tint\t\t\ti,\n\t\t\t\tlower_index;\n\tdouble\t\tbin_width,\n\t\t\t\tlower_bin_width;\n\tdouble\t\tsum_frac;\n\tfloat8\t\tprev_dist;\n\n\t/* Find the bin containing the lower bound of query range. */\n\tlower_index = rbound_bsearch(typcache, lower, hist_lower, hist_nvalues,\n\t\t\t\t\t\t\t\t true);\n\n\t/*\n\t * Calculate lower_bin_width, ie. the fraction of the of (lower_index,\n\t * lower_index + 1) bin which is greater than lower bound of query range\n\t * using linear interpolation of subdiff function.\n\t */\n\tif (lower_index >= 0 && lower_index < hist_nvalues - 1)\n\t\tlower_bin_width = get_position(typcache, lower, &hist_lower[lower_index],\n\t\t\t\t\t\t\t\t\t   &hist_lower[lower_index + 1]);\n\telse\n\t\tlower_bin_width = 0.0;\n\n\t/*\n\t * Loop through all the lower bound bins, smaller than the query lower\n\t * bound. In the loop, dist and prev_dist are the distance of the\n\t * \"current\" bin's lower and upper bounds from the constant upper bound.\n\t * We begin from query lower bound, and walk backwards, so the first bin's\n\t * upper bound is the query lower bound, and its distance to the query\n\t * upper bound is the length of the query range.\n\t *\n\t * bin_width represents the width of the current bin. Normally it is 1.0,\n\t * meaning a full width bin, except for the first bin, which is only\n\t * counted up to the constant lower bound.\n\t */\n\tprev_dist = get_distance(typcache, lower, upper);\n\tsum_frac = 0.0;\n\tbin_width = lower_bin_width;\n\tfor (i = lower_index; i >= 0; i--)\n\t{\n\t\tfloat8\t\tdist;\n\t\tdouble\t\tlength_hist_frac;\n\n\t\t/*\n\t\t * dist -- distance from upper bound of query range to current value\n\t\t * of lower bound histogram or lower bound of query range (if we've\n\t\t * reach it).\n\t\t */\n\t\tdist = get_distance(typcache, &hist_lower[i], upper);\n\n\t\t/*\n\t\t * Get average fraction of length histogram which covers intervals\n\t\t * longer than (or equal to) distance to upper bound of query range.\n\t\t */\n\t\tlength_hist_frac =\n\t\t\t1.0 - calc_length_hist_frac(length_hist_values,\n\t\t\t\t\t\t\t\t\t\tlength_hist_nvalues,\n\t\t\t\t\t\t\t\t\t\tprev_dist, dist, false);\n\n\t\tsum_frac += length_hist_frac * bin_width / (double) (hist_nvalues - 1);\n\n\t\tbin_width = 1.0;\n\t\tprev_dist = dist;\n\t}\n\n\treturn sum_frac;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!empty"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_deserialize",
          "args": [
            "typcache",
            "constval",
            "&const_lower",
            "&const_upper",
            "&empty"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "range_deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1695-1754",
          "snippet": "void\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\n\nvoid\nrange_deserialize(TypeCacheEntry *typcache, RangeType *range,\n\t\t\t\t  RangeBound *lower, RangeBound *upper, bool *empty)\n{\n\tchar\t\tflags;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tPointer\t\tptr;\n\tDatum\t\tlbound;\n\tDatum\t\tubound;\n\n\t/* assert caller passed the right typcache entry */\n\tAssert(RangeTypeGetOid(range) == typcache->type_id);\n\n\t/* fetch the flag byte from datum's last byte */\n\tflags = *((char *) range + VARSIZE(range) - 1);\n\n\t/* fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\n\t/* initialize data pointer just after the range OID */\n\tptr = (Pointer) (range + 1);\n\n\t/* fetch lower bound, if any */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/* att_align_pointer cannot be necessary here */\n\t\tlbound = fetch_att(ptr, typbyval, typlen);\n\t\tptr = (Pointer) att_addlength_pointer(ptr, typlen, ptr);\n\t}\n\telse\n\t\tlbound = (Datum) 0;\n\n\t/* fetch upper bound, if any */\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tptr = (Pointer) att_align_pointer(ptr, typalign, typlen, ptr);\n\t\tubound = fetch_att(ptr, typbyval, typlen);\n\t\t/* no need for att_addlength_pointer */\n\t}\n\telse\n\t\tubound = (Datum) 0;\n\n\t/* emit results */\n\n\t*empty = (flags & RANGE_EMPTY) != 0;\n\n\tlower->val = lbound;\n\tlower->infinite = (flags & RANGE_LB_INF) != 0;\n\tlower->inclusive = (flags & RANGE_LB_INC) != 0;\n\tlower->lower = true;\n\n\tupper->val = ubound;\n\tupper->infinite = (flags & RANGE_UB_INF) != 0;\n\tupper->inclusive = (flags & RANGE_UB_INC) != 0;\n\tupper->lower = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&lslot",
            "0",
            "sizeof(lslot)"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_attstatsslot",
          "args": [
            "&lslot",
            "vardata->statsTuple",
            "STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM",
            "InvalidOid",
            "ATTSTATSSLOT_VALUES"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "get_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2936-3046",
          "snippet": "bool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "hslot.values[i]"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(RangeBound) * nhist"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "statistic_proc_security_check",
          "args": [
            "vardata",
            "typcache->rng_subdiff_finfo.fn_oid"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "statistic_proc_security_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "5167-5183",
          "snippet": "bool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nbool\nstatistic_proc_security_check(VariableStatData *vardata, Oid func_oid)\n{\n\tif (vardata->acl_ok)\n\t\treturn true;\n\n\tif (!OidIsValid(func_oid))\n\t\treturn false;\n\n\tif (get_func_leakproof(func_oid))\n\t\treturn true;\n\n\tereport(DEBUG2,\n\t\t\t(errmsg_internal(\"not using statistics because function \\\"%s\\\" is not leak-proof\",\n\t\t\t\t\t\t\t get_func_name(func_oid))));\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "typcache->rng_subdiff_finfo.fn_oid"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_rangesel(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t  RangeType *constval, Oid operator);\nstatic double default_range_selectivity(Oid operator);\nstatic double calc_hist_selectivity(TypeCacheEntry *typcache,\n\t\t\t\t\t  VariableStatData *vardata, RangeType *constval,\n\t\t\t\t\t  Oid operator);\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\n\nstatic double\ncalc_hist_selectivity(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t\t\t  RangeType *constval, Oid operator)\n{\n\tAttStatsSlot hslot;\n\tAttStatsSlot lslot;\n\tint\t\t\tnhist;\n\tRangeBound *hist_lower;\n\tRangeBound *hist_upper;\n\tint\t\t\ti;\n\tRangeBound\tconst_lower;\n\tRangeBound\tconst_upper;\n\tbool\t\tempty;\n\tdouble\t\thist_selec;\n\n\t/* Can't use the histogram with insecure range support functions */\n\tif (!statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t   typcache->rng_cmp_proc_finfo.fn_oid))\n\t\treturn -1;\n\tif (OidIsValid(typcache->rng_subdiff_finfo.fn_oid) &&\n\t\t!statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t   typcache->rng_subdiff_finfo.fn_oid))\n\t\treturn -1;\n\n\t/* Try to get histogram of ranges */\n\tif (!(HeapTupleIsValid(vardata->statsTuple) &&\n\t\t  get_attstatsslot(&hslot, vardata->statsTuple,\n\t\t\t\t\t\t   STATISTIC_KIND_BOUNDS_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t   ATTSTATSSLOT_VALUES)))\n\t\treturn -1.0;\n\n\t/*\n\t * Convert histogram of ranges into histograms of its lower and upper\n\t * bounds.\n\t */\n\tnhist = hslot.nvalues;\n\thist_lower = (RangeBound *) palloc(sizeof(RangeBound) * nhist);\n\thist_upper = (RangeBound *) palloc(sizeof(RangeBound) * nhist);\n\tfor (i = 0; i < nhist; i++)\n\t{\n\t\trange_deserialize(typcache, DatumGetRangeTypeP(hslot.values[i]),\n\t\t\t\t\t\t  &hist_lower[i], &hist_upper[i], &empty);\n\t\t/* The histogram should not contain any empty ranges */\n\t\tif (empty)\n\t\t\telog(ERROR, \"bounds histogram contains an empty range\");\n\t}\n\n\t/* @> and @< also need a histogram of range lengths */\n\tif (operator == OID_RANGE_CONTAINS_OP ||\n\t\toperator == OID_RANGE_CONTAINED_OP)\n\t{\n\t\tif (!(HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t  get_attstatsslot(&lslot, vardata->statsTuple,\n\t\t\t\t\t\t\t   STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM,\n\t\t\t\t\t\t\t   InvalidOid,\n\t\t\t\t\t\t\t   ATTSTATSSLOT_VALUES)))\n\t\t{\n\t\t\tfree_attstatsslot(&hslot);\n\t\t\treturn -1.0;\n\t\t}\n\n\t\t/* check that it's a histogram, not just a dummy entry */\n\t\tif (lslot.nvalues < 2)\n\t\t{\n\t\t\tfree_attstatsslot(&lslot);\n\t\t\tfree_attstatsslot(&hslot);\n\t\t\treturn -1.0;\n\t\t}\n\t}\n\telse\n\t\tmemset(&lslot, 0, sizeof(lslot));\n\n\t/* Extract the bounds of the constant value. */\n\trange_deserialize(typcache, constval, &const_lower, &const_upper, &empty);\n\tAssert(!empty);\n\n\t/*\n\t * Calculate selectivity comparing the lower or upper bound of the\n\t * constant with the histogram of lower or upper bounds.\n\t */\n\tswitch (operator)\n\t{\n\t\tcase OID_RANGE_LESS_OP:\n\n\t\t\t/*\n\t\t\t * The regular b-tree comparison operators (<, <=, >, >=) compare\n\t\t\t * the lower bounds first, and the upper bounds for values with\n\t\t\t * equal lower bounds. Estimate that by comparing the lower bounds\n\t\t\t * only. This gives a fairly accurate estimate assuming there\n\t\t\t * aren't many rows with a lower bound equal to the constant's\n\t\t\t * lower bound.\n\t\t\t */\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, false);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_LESS_EQUAL_OP:\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, true);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_GREATER_OP:\n\t\t\thist_selec =\n\t\t\t\t1 - calc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, false);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_GREATER_EQUAL_OP:\n\t\t\thist_selec =\n\t\t\t\t1 - calc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, true);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_LEFT_OP:\n\t\t\t/* var << const when upper(var) < lower(const) */\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t hist_upper, nhist, false);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_RIGHT_OP:\n\t\t\t/* var >> const when lower(var) > upper(const) */\n\t\t\thist_selec =\n\t\t\t\t1 - calc_hist_selectivity_scalar(typcache, &const_upper,\n\t\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, true);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_OVERLAPS_RIGHT_OP:\n\t\t\t/* compare lower bounds */\n\t\t\thist_selec =\n\t\t\t\t1 - calc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, false);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_OVERLAPS_LEFT_OP:\n\t\t\t/* compare upper bounds */\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_upper,\n\t\t\t\t\t\t\t\t\t\t\t hist_upper, nhist, true);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_OVERLAP_OP:\n\t\tcase OID_RANGE_CONTAINS_ELEM_OP:\n\n\t\t\t/*\n\t\t\t * A && B <=> NOT (A << B OR A >> B).\n\t\t\t *\n\t\t\t * Since A << B and A >> B are mutually exclusive events we can\n\t\t\t * sum their probabilities to find probability of (A << B OR A >>\n\t\t\t * B).\n\t\t\t *\n\t\t\t * \"range @> elem\" is equivalent to \"range && [elem,elem]\". The\n\t\t\t * caller already constructed the singular range from the element\n\t\t\t * constant, so just treat it the same as &&.\n\t\t\t */\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_lower, hist_upper,\n\t\t\t\t\t\t\t\t\t\t\t nhist, false);\n\t\t\thist_selec +=\n\t\t\t\t(1.0 - calc_hist_selectivity_scalar(typcache, &const_upper, hist_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnhist, true));\n\t\t\thist_selec = 1.0 - hist_selec;\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_CONTAINS_OP:\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_contains(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t   &const_upper, hist_lower, nhist,\n\t\t\t\t\t\t\t\t\t\t\t   lslot.values, lslot.nvalues);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_CONTAINED_OP:\n\t\t\tif (const_lower.infinite)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Lower bound no longer matters. Just estimate the fraction\n\t\t\t\t * with an upper bound <= const upper bound\n\t\t\t\t */\n\t\t\t\thist_selec =\n\t\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_upper,\n\t\t\t\t\t\t\t\t\t\t\t\t hist_upper, nhist, true);\n\t\t\t}\n\t\t\telse if (const_upper.infinite)\n\t\t\t{\n\t\t\t\thist_selec =\n\t\t\t\t\t1.0 - calc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   hist_lower, nhist, false);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thist_selec =\n\t\t\t\t\tcalc_hist_selectivity_contained(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t\t&const_upper, hist_lower, nhist,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlslot.values, lslot.nvalues);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown range operator %u\", operator);\n\t\t\thist_selec = -1.0;\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\tfree_attstatsslot(&lslot);\n\tfree_attstatsslot(&hslot);\n\n\treturn hist_selec;\n}"
  },
  {
    "function_name": "calc_rangesel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
    "lines": "227-361",
    "snippet": "static double\ncalc_rangesel(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t  RangeType *constval, Oid operator)\n{\n\tdouble\t\thist_selec;\n\tdouble\t\tselec;\n\tfloat4\t\tempty_frac,\n\t\t\t\tnull_frac;\n\n\t/*\n\t * First look up the fraction of NULLs and empty ranges from pg_statistic.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\t\tAttStatsSlot sslot;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tnull_frac = stats->stanullfrac;\n\n\t\t/* Try to get fraction of empty ranges */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM,\n\t\t\t\t\t\t\t InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\tif (sslot.nnumbers != 1)\n\t\t\t\telog(ERROR, \"invalid empty fraction statistic\");\t/* shouldn't happen */\n\t\t\tempty_frac = sslot.numbers[0];\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* No empty fraction statistic. Assume no empty ranges. */\n\t\t\tempty_frac = 0.0;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No stats are available. Follow through the calculations below\n\t\t * anyway, assuming no NULLs and no empty ranges. This still allows us\n\t\t * to give a better-than-nothing estimate based on whether the\n\t\t * constant is an empty range or not.\n\t\t */\n\t\tnull_frac = 0.0;\n\t\tempty_frac = 0.0;\n\t}\n\n\tif (RangeIsEmpty(constval))\n\t{\n\t\t/*\n\t\t * An empty range matches all ranges, all empty ranges, or nothing,\n\t\t * depending on the operator\n\t\t */\n\t\tswitch (operator)\n\t\t{\n\t\t\t\t/* these return false if either argument is empty */\n\t\t\tcase OID_RANGE_OVERLAP_OP:\n\t\t\tcase OID_RANGE_OVERLAPS_LEFT_OP:\n\t\t\tcase OID_RANGE_OVERLAPS_RIGHT_OP:\n\t\t\tcase OID_RANGE_LEFT_OP:\n\t\t\tcase OID_RANGE_RIGHT_OP:\n\t\t\t\t/* nothing is less than an empty range */\n\t\t\tcase OID_RANGE_LESS_OP:\n\t\t\t\tselec = 0.0;\n\t\t\t\tbreak;\n\n\t\t\t\t/* only empty ranges can be contained by an empty range */\n\t\t\tcase OID_RANGE_CONTAINED_OP:\n\t\t\t\t/* only empty ranges are <= an empty range */\n\t\t\tcase OID_RANGE_LESS_EQUAL_OP:\n\t\t\t\tselec = empty_frac;\n\t\t\t\tbreak;\n\n\t\t\t\t/* everything contains an empty range */\n\t\t\tcase OID_RANGE_CONTAINS_OP:\n\t\t\t\t/* everything is >= an empty range */\n\t\t\tcase OID_RANGE_GREATER_EQUAL_OP:\n\t\t\t\tselec = 1.0;\n\t\t\t\tbreak;\n\n\t\t\t\t/* all non-empty ranges are > an empty range */\n\t\t\tcase OID_RANGE_GREATER_OP:\n\t\t\t\tselec = 1.0 - empty_frac;\n\t\t\t\tbreak;\n\n\t\t\t\t/* an element cannot be empty */\n\t\t\tcase OID_RANGE_CONTAINS_ELEM_OP:\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected operator %u\", operator);\n\t\t\t\tselec = 0.0;\t/* keep compiler quiet */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Calculate selectivity using bound histograms. If that fails for\n\t\t * some reason, e.g no histogram in pg_statistic, use the default\n\t\t * constant estimate for the fraction of non-empty values. This is\n\t\t * still somewhat better than just returning the default estimate,\n\t\t * because this still takes into account the fraction of empty and\n\t\t * NULL tuples, if we had statistics for them.\n\t\t */\n\t\thist_selec = calc_hist_selectivity(typcache, vardata, constval,\n\t\t\t\t\t\t\t\t\t\t   operator);\n\t\tif (hist_selec < 0.0)\n\t\t\thist_selec = default_range_selectivity(operator);\n\n\t\t/*\n\t\t * Now merge the results for the empty ranges and histogram\n\t\t * calculations, realizing that the histogram covers only the\n\t\t * non-null, non-empty values.\n\t\t */\n\t\tif (operator == OID_RANGE_CONTAINED_OP)\n\t\t{\n\t\t\t/* empty is contained by anything non-empty */\n\t\t\tselec = (1.0 - empty_frac) * hist_selec + empty_frac;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* with any other operator, empty Op non-empty matches nothing */\n\t\t\tselec = (1.0 - empty_frac) * hist_selec;\n\t\t}\n\t}\n\n\t/* all range operators are strict */\n\tselec *= (1.0 - null_frac);\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double calc_rangesel(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t  RangeType *constval, Oid operator);",
      "static double default_range_selectivity(Oid operator);",
      "static double calc_hist_selectivity(TypeCacheEntry *typcache,\n\t\t\t\t\t  VariableStatData *vardata, RangeType *constval,\n\t\t\t\t\t  Oid operator);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "selec"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "default_range_selectivity",
          "args": [
            "operator"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "default_range_selectivity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "64-100",
          "snippet": "static double\ndefault_range_selectivity(Oid operator)\n{\n\tswitch (operator)\n\t{\n\t\tcase OID_RANGE_OVERLAP_OP:\n\t\t\treturn 0.01;\n\n\t\tcase OID_RANGE_CONTAINS_OP:\n\t\tcase OID_RANGE_CONTAINED_OP:\n\t\t\treturn 0.005;\n\n\t\tcase OID_RANGE_CONTAINS_ELEM_OP:\n\t\tcase OID_RANGE_ELEM_CONTAINED_OP:\n\n\t\t\t/*\n\t\t\t * \"range @> elem\" is more or less identical to a scalar\n\t\t\t * inequality \"A >= b AND A <= c\".\n\t\t\t */\n\t\t\treturn DEFAULT_RANGE_INEQ_SEL;\n\n\t\tcase OID_RANGE_LESS_OP:\n\t\tcase OID_RANGE_LESS_EQUAL_OP:\n\t\tcase OID_RANGE_GREATER_OP:\n\t\tcase OID_RANGE_GREATER_EQUAL_OP:\n\t\tcase OID_RANGE_LEFT_OP:\n\t\tcase OID_RANGE_RIGHT_OP:\n\t\tcase OID_RANGE_OVERLAPS_LEFT_OP:\n\t\tcase OID_RANGE_OVERLAPS_RIGHT_OP:\n\t\t\t/* these are similar to regular scalar inequalities */\n\t\t\treturn DEFAULT_INEQ_SEL;\n\n\t\tdefault:\n\t\t\t/* all range operators should be handled above, but just in case */\n\t\t\treturn 0.01;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_rangesel(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t  RangeType *constval, Oid operator);",
            "static double default_range_selectivity(Oid operator);",
            "static double calc_hist_selectivity(TypeCacheEntry *typcache,\n\t\t\t\t\t  VariableStatData *vardata, RangeType *constval,\n\t\t\t\t\t  Oid operator);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_rangesel(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t  RangeType *constval, Oid operator);\nstatic double default_range_selectivity(Oid operator);\nstatic double calc_hist_selectivity(TypeCacheEntry *typcache,\n\t\t\t\t\t  VariableStatData *vardata, RangeType *constval,\n\t\t\t\t\t  Oid operator);\n\nstatic double\ndefault_range_selectivity(Oid operator)\n{\n\tswitch (operator)\n\t{\n\t\tcase OID_RANGE_OVERLAP_OP:\n\t\t\treturn 0.01;\n\n\t\tcase OID_RANGE_CONTAINS_OP:\n\t\tcase OID_RANGE_CONTAINED_OP:\n\t\t\treturn 0.005;\n\n\t\tcase OID_RANGE_CONTAINS_ELEM_OP:\n\t\tcase OID_RANGE_ELEM_CONTAINED_OP:\n\n\t\t\t/*\n\t\t\t * \"range @> elem\" is more or less identical to a scalar\n\t\t\t * inequality \"A >= b AND A <= c\".\n\t\t\t */\n\t\t\treturn DEFAULT_RANGE_INEQ_SEL;\n\n\t\tcase OID_RANGE_LESS_OP:\n\t\tcase OID_RANGE_LESS_EQUAL_OP:\n\t\tcase OID_RANGE_GREATER_OP:\n\t\tcase OID_RANGE_GREATER_EQUAL_OP:\n\t\tcase OID_RANGE_LEFT_OP:\n\t\tcase OID_RANGE_RIGHT_OP:\n\t\tcase OID_RANGE_OVERLAPS_LEFT_OP:\n\t\tcase OID_RANGE_OVERLAPS_RIGHT_OP:\n\t\t\t/* these are similar to regular scalar inequalities */\n\t\t\treturn DEFAULT_INEQ_SEL;\n\n\t\tdefault:\n\t\t\t/* all range operators should be handled above, but just in case */\n\t\t\treturn 0.01;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_hist_selectivity",
          "args": [
            "typcache",
            "vardata",
            "constval",
            "operator"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "calc_hist_selectivity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "369-578",
          "snippet": "static double\ncalc_hist_selectivity(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t\t\t  RangeType *constval, Oid operator)\n{\n\tAttStatsSlot hslot;\n\tAttStatsSlot lslot;\n\tint\t\t\tnhist;\n\tRangeBound *hist_lower;\n\tRangeBound *hist_upper;\n\tint\t\t\ti;\n\tRangeBound\tconst_lower;\n\tRangeBound\tconst_upper;\n\tbool\t\tempty;\n\tdouble\t\thist_selec;\n\n\t/* Can't use the histogram with insecure range support functions */\n\tif (!statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t   typcache->rng_cmp_proc_finfo.fn_oid))\n\t\treturn -1;\n\tif (OidIsValid(typcache->rng_subdiff_finfo.fn_oid) &&\n\t\t!statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t   typcache->rng_subdiff_finfo.fn_oid))\n\t\treturn -1;\n\n\t/* Try to get histogram of ranges */\n\tif (!(HeapTupleIsValid(vardata->statsTuple) &&\n\t\t  get_attstatsslot(&hslot, vardata->statsTuple,\n\t\t\t\t\t\t   STATISTIC_KIND_BOUNDS_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t   ATTSTATSSLOT_VALUES)))\n\t\treturn -1.0;\n\n\t/*\n\t * Convert histogram of ranges into histograms of its lower and upper\n\t * bounds.\n\t */\n\tnhist = hslot.nvalues;\n\thist_lower = (RangeBound *) palloc(sizeof(RangeBound) * nhist);\n\thist_upper = (RangeBound *) palloc(sizeof(RangeBound) * nhist);\n\tfor (i = 0; i < nhist; i++)\n\t{\n\t\trange_deserialize(typcache, DatumGetRangeTypeP(hslot.values[i]),\n\t\t\t\t\t\t  &hist_lower[i], &hist_upper[i], &empty);\n\t\t/* The histogram should not contain any empty ranges */\n\t\tif (empty)\n\t\t\telog(ERROR, \"bounds histogram contains an empty range\");\n\t}\n\n\t/* @> and @< also need a histogram of range lengths */\n\tif (operator == OID_RANGE_CONTAINS_OP ||\n\t\toperator == OID_RANGE_CONTAINED_OP)\n\t{\n\t\tif (!(HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t  get_attstatsslot(&lslot, vardata->statsTuple,\n\t\t\t\t\t\t\t   STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM,\n\t\t\t\t\t\t\t   InvalidOid,\n\t\t\t\t\t\t\t   ATTSTATSSLOT_VALUES)))\n\t\t{\n\t\t\tfree_attstatsslot(&hslot);\n\t\t\treturn -1.0;\n\t\t}\n\n\t\t/* check that it's a histogram, not just a dummy entry */\n\t\tif (lslot.nvalues < 2)\n\t\t{\n\t\t\tfree_attstatsslot(&lslot);\n\t\t\tfree_attstatsslot(&hslot);\n\t\t\treturn -1.0;\n\t\t}\n\t}\n\telse\n\t\tmemset(&lslot, 0, sizeof(lslot));\n\n\t/* Extract the bounds of the constant value. */\n\trange_deserialize(typcache, constval, &const_lower, &const_upper, &empty);\n\tAssert(!empty);\n\n\t/*\n\t * Calculate selectivity comparing the lower or upper bound of the\n\t * constant with the histogram of lower or upper bounds.\n\t */\n\tswitch (operator)\n\t{\n\t\tcase OID_RANGE_LESS_OP:\n\n\t\t\t/*\n\t\t\t * The regular b-tree comparison operators (<, <=, >, >=) compare\n\t\t\t * the lower bounds first, and the upper bounds for values with\n\t\t\t * equal lower bounds. Estimate that by comparing the lower bounds\n\t\t\t * only. This gives a fairly accurate estimate assuming there\n\t\t\t * aren't many rows with a lower bound equal to the constant's\n\t\t\t * lower bound.\n\t\t\t */\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, false);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_LESS_EQUAL_OP:\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, true);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_GREATER_OP:\n\t\t\thist_selec =\n\t\t\t\t1 - calc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, false);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_GREATER_EQUAL_OP:\n\t\t\thist_selec =\n\t\t\t\t1 - calc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, true);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_LEFT_OP:\n\t\t\t/* var << const when upper(var) < lower(const) */\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t hist_upper, nhist, false);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_RIGHT_OP:\n\t\t\t/* var >> const when lower(var) > upper(const) */\n\t\t\thist_selec =\n\t\t\t\t1 - calc_hist_selectivity_scalar(typcache, &const_upper,\n\t\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, true);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_OVERLAPS_RIGHT_OP:\n\t\t\t/* compare lower bounds */\n\t\t\thist_selec =\n\t\t\t\t1 - calc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, false);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_OVERLAPS_LEFT_OP:\n\t\t\t/* compare upper bounds */\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_upper,\n\t\t\t\t\t\t\t\t\t\t\t hist_upper, nhist, true);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_OVERLAP_OP:\n\t\tcase OID_RANGE_CONTAINS_ELEM_OP:\n\n\t\t\t/*\n\t\t\t * A && B <=> NOT (A << B OR A >> B).\n\t\t\t *\n\t\t\t * Since A << B and A >> B are mutually exclusive events we can\n\t\t\t * sum their probabilities to find probability of (A << B OR A >>\n\t\t\t * B).\n\t\t\t *\n\t\t\t * \"range @> elem\" is equivalent to \"range && [elem,elem]\". The\n\t\t\t * caller already constructed the singular range from the element\n\t\t\t * constant, so just treat it the same as &&.\n\t\t\t */\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_lower, hist_upper,\n\t\t\t\t\t\t\t\t\t\t\t nhist, false);\n\t\t\thist_selec +=\n\t\t\t\t(1.0 - calc_hist_selectivity_scalar(typcache, &const_upper, hist_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnhist, true));\n\t\t\thist_selec = 1.0 - hist_selec;\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_CONTAINS_OP:\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_contains(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t   &const_upper, hist_lower, nhist,\n\t\t\t\t\t\t\t\t\t\t\t   lslot.values, lslot.nvalues);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_CONTAINED_OP:\n\t\t\tif (const_lower.infinite)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Lower bound no longer matters. Just estimate the fraction\n\t\t\t\t * with an upper bound <= const upper bound\n\t\t\t\t */\n\t\t\t\thist_selec =\n\t\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_upper,\n\t\t\t\t\t\t\t\t\t\t\t\t hist_upper, nhist, true);\n\t\t\t}\n\t\t\telse if (const_upper.infinite)\n\t\t\t{\n\t\t\t\thist_selec =\n\t\t\t\t\t1.0 - calc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   hist_lower, nhist, false);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thist_selec =\n\t\t\t\t\tcalc_hist_selectivity_contained(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t\t&const_upper, hist_lower, nhist,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlslot.values, lslot.nvalues);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown range operator %u\", operator);\n\t\t\thist_selec = -1.0;\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\tfree_attstatsslot(&lslot);\n\tfree_attstatsslot(&hslot);\n\n\treturn hist_selec;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_rangesel(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t  RangeType *constval, Oid operator);",
            "static double default_range_selectivity(Oid operator);",
            "static double calc_hist_selectivity(TypeCacheEntry *typcache,\n\t\t\t\t\t  VariableStatData *vardata, RangeType *constval,\n\t\t\t\t\t  Oid operator);",
            "static double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);",
            "static int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);",
            "static int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);",
            "static double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_rangesel(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t  RangeType *constval, Oid operator);\nstatic double default_range_selectivity(Oid operator);\nstatic double calc_hist_selectivity(TypeCacheEntry *typcache,\n\t\t\t\t\t  VariableStatData *vardata, RangeType *constval,\n\t\t\t\t\t  Oid operator);\nstatic double calc_hist_selectivity_scalar(TypeCacheEntry *typcache,\n\t\t\t\t\t\t\t RangeBound *constbound,\n\t\t\t\t\t\t\t RangeBound *hist, int hist_nvalues,\n\t\t\t\t\t\t\t bool equal);\nstatic int rbound_bsearch(TypeCacheEntry *typcache, RangeBound *value,\n\t\t\t   RangeBound *hist, int hist_length, bool equal);\nstatic int length_hist_bsearch(Datum *length_hist_values,\n\t\t\t\t\tint length_hist_nvalues, double value, bool equal);\nstatic double calc_length_hist_frac(Datum *length_hist_values,\n\t\t\t\t\t  int length_hist_nvalues, double length1, double length2, bool equal);\n\nstatic double\ncalc_hist_selectivity(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t\t\t  RangeType *constval, Oid operator)\n{\n\tAttStatsSlot hslot;\n\tAttStatsSlot lslot;\n\tint\t\t\tnhist;\n\tRangeBound *hist_lower;\n\tRangeBound *hist_upper;\n\tint\t\t\ti;\n\tRangeBound\tconst_lower;\n\tRangeBound\tconst_upper;\n\tbool\t\tempty;\n\tdouble\t\thist_selec;\n\n\t/* Can't use the histogram with insecure range support functions */\n\tif (!statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t   typcache->rng_cmp_proc_finfo.fn_oid))\n\t\treturn -1;\n\tif (OidIsValid(typcache->rng_subdiff_finfo.fn_oid) &&\n\t\t!statistic_proc_security_check(vardata,\n\t\t\t\t\t\t\t\t\t   typcache->rng_subdiff_finfo.fn_oid))\n\t\treturn -1;\n\n\t/* Try to get histogram of ranges */\n\tif (!(HeapTupleIsValid(vardata->statsTuple) &&\n\t\t  get_attstatsslot(&hslot, vardata->statsTuple,\n\t\t\t\t\t\t   STATISTIC_KIND_BOUNDS_HISTOGRAM, InvalidOid,\n\t\t\t\t\t\t   ATTSTATSSLOT_VALUES)))\n\t\treturn -1.0;\n\n\t/*\n\t * Convert histogram of ranges into histograms of its lower and upper\n\t * bounds.\n\t */\n\tnhist = hslot.nvalues;\n\thist_lower = (RangeBound *) palloc(sizeof(RangeBound) * nhist);\n\thist_upper = (RangeBound *) palloc(sizeof(RangeBound) * nhist);\n\tfor (i = 0; i < nhist; i++)\n\t{\n\t\trange_deserialize(typcache, DatumGetRangeTypeP(hslot.values[i]),\n\t\t\t\t\t\t  &hist_lower[i], &hist_upper[i], &empty);\n\t\t/* The histogram should not contain any empty ranges */\n\t\tif (empty)\n\t\t\telog(ERROR, \"bounds histogram contains an empty range\");\n\t}\n\n\t/* @> and @< also need a histogram of range lengths */\n\tif (operator == OID_RANGE_CONTAINS_OP ||\n\t\toperator == OID_RANGE_CONTAINED_OP)\n\t{\n\t\tif (!(HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t  get_attstatsslot(&lslot, vardata->statsTuple,\n\t\t\t\t\t\t\t   STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM,\n\t\t\t\t\t\t\t   InvalidOid,\n\t\t\t\t\t\t\t   ATTSTATSSLOT_VALUES)))\n\t\t{\n\t\t\tfree_attstatsslot(&hslot);\n\t\t\treturn -1.0;\n\t\t}\n\n\t\t/* check that it's a histogram, not just a dummy entry */\n\t\tif (lslot.nvalues < 2)\n\t\t{\n\t\t\tfree_attstatsslot(&lslot);\n\t\t\tfree_attstatsslot(&hslot);\n\t\t\treturn -1.0;\n\t\t}\n\t}\n\telse\n\t\tmemset(&lslot, 0, sizeof(lslot));\n\n\t/* Extract the bounds of the constant value. */\n\trange_deserialize(typcache, constval, &const_lower, &const_upper, &empty);\n\tAssert(!empty);\n\n\t/*\n\t * Calculate selectivity comparing the lower or upper bound of the\n\t * constant with the histogram of lower or upper bounds.\n\t */\n\tswitch (operator)\n\t{\n\t\tcase OID_RANGE_LESS_OP:\n\n\t\t\t/*\n\t\t\t * The regular b-tree comparison operators (<, <=, >, >=) compare\n\t\t\t * the lower bounds first, and the upper bounds for values with\n\t\t\t * equal lower bounds. Estimate that by comparing the lower bounds\n\t\t\t * only. This gives a fairly accurate estimate assuming there\n\t\t\t * aren't many rows with a lower bound equal to the constant's\n\t\t\t * lower bound.\n\t\t\t */\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, false);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_LESS_EQUAL_OP:\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, true);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_GREATER_OP:\n\t\t\thist_selec =\n\t\t\t\t1 - calc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, false);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_GREATER_EQUAL_OP:\n\t\t\thist_selec =\n\t\t\t\t1 - calc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, true);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_LEFT_OP:\n\t\t\t/* var << const when upper(var) < lower(const) */\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t hist_upper, nhist, false);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_RIGHT_OP:\n\t\t\t/* var >> const when lower(var) > upper(const) */\n\t\t\thist_selec =\n\t\t\t\t1 - calc_hist_selectivity_scalar(typcache, &const_upper,\n\t\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, true);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_OVERLAPS_RIGHT_OP:\n\t\t\t/* compare lower bounds */\n\t\t\thist_selec =\n\t\t\t\t1 - calc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t hist_lower, nhist, false);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_OVERLAPS_LEFT_OP:\n\t\t\t/* compare upper bounds */\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_upper,\n\t\t\t\t\t\t\t\t\t\t\t hist_upper, nhist, true);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_OVERLAP_OP:\n\t\tcase OID_RANGE_CONTAINS_ELEM_OP:\n\n\t\t\t/*\n\t\t\t * A && B <=> NOT (A << B OR A >> B).\n\t\t\t *\n\t\t\t * Since A << B and A >> B are mutually exclusive events we can\n\t\t\t * sum their probabilities to find probability of (A << B OR A >>\n\t\t\t * B).\n\t\t\t *\n\t\t\t * \"range @> elem\" is equivalent to \"range && [elem,elem]\". The\n\t\t\t * caller already constructed the singular range from the element\n\t\t\t * constant, so just treat it the same as &&.\n\t\t\t */\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_lower, hist_upper,\n\t\t\t\t\t\t\t\t\t\t\t nhist, false);\n\t\t\thist_selec +=\n\t\t\t\t(1.0 - calc_hist_selectivity_scalar(typcache, &const_upper, hist_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnhist, true));\n\t\t\thist_selec = 1.0 - hist_selec;\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_CONTAINS_OP:\n\t\t\thist_selec =\n\t\t\t\tcalc_hist_selectivity_contains(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t   &const_upper, hist_lower, nhist,\n\t\t\t\t\t\t\t\t\t\t\t   lslot.values, lslot.nvalues);\n\t\t\tbreak;\n\n\t\tcase OID_RANGE_CONTAINED_OP:\n\t\t\tif (const_lower.infinite)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Lower bound no longer matters. Just estimate the fraction\n\t\t\t\t * with an upper bound <= const upper bound\n\t\t\t\t */\n\t\t\t\thist_selec =\n\t\t\t\t\tcalc_hist_selectivity_scalar(typcache, &const_upper,\n\t\t\t\t\t\t\t\t\t\t\t\t hist_upper, nhist, true);\n\t\t\t}\n\t\t\telse if (const_upper.infinite)\n\t\t\t{\n\t\t\t\thist_selec =\n\t\t\t\t\t1.0 - calc_hist_selectivity_scalar(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   hist_lower, nhist, false);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thist_selec =\n\t\t\t\t\tcalc_hist_selectivity_contained(typcache, &const_lower,\n\t\t\t\t\t\t\t\t\t\t\t\t\t&const_upper, hist_lower, nhist,\n\t\t\t\t\t\t\t\t\t\t\t\t\tlslot.values, lslot.nvalues);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unknown range operator %u\", operator);\n\t\t\thist_selec = -1.0;\t/* keep compiler quiet */\n\t\t\tbreak;\n\t}\n\n\tfree_attstatsslot(&lslot);\n\tfree_attstatsslot(&hslot);\n\n\treturn hist_selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unexpected operator %u\"",
            "operator"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RangeIsEmpty",
          "args": [
            "constval"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_attstatsslot",
          "args": [
            "&sslot"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_attstatsslot",
          "args": [
            "&sslot",
            "vardata->statsTuple",
            "STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM",
            "InvalidOid",
            "ATTSTATSSLOT_NUMBERS"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "get_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "2936-3046",
          "snippet": "bool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nbool\nget_attstatsslot(AttStatsSlot *sslot, HeapTuple statstuple,\n\t\t\t\t int reqkind, Oid reqop, int flags)\n{\n\tForm_pg_statistic stats = (Form_pg_statistic) GETSTRUCT(statstuple);\n\tint\t\t\ti;\n\tDatum\t\tval;\n\tbool\t\tisnull;\n\tArrayType  *statarray;\n\tOid\t\t\tarrayelemtype;\n\tint\t\t\tnarrayelem;\n\tHeapTuple\ttypeTuple;\n\tForm_pg_type typeForm;\n\n\t/* initialize *sslot properly */\n\tmemset(sslot, 0, sizeof(AttStatsSlot));\n\n\tfor (i = 0; i < STATISTIC_NUM_SLOTS; i++)\n\t{\n\t\tif ((&stats->stakind1)[i] == reqkind &&\n\t\t\t(reqop == InvalidOid || (&stats->staop1)[i] == reqop))\n\t\t\tbreak;\n\t}\n\tif (i >= STATISTIC_NUM_SLOTS)\n\t\treturn false;\t\t\t/* not there */\n\n\tsslot->staop = (&stats->staop1)[i];\n\n\tif (flags & ATTSTATSSLOT_VALUES)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stavalues1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stavalues is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * Extract the actual array element type, and pass it back in case the\n\t\t * caller needs it.\n\t\t */\n\t\tsslot->valuetype = arrayelemtype = ARR_ELEMTYPE(statarray);\n\n\t\t/* Need info about element type */\n\t\ttypeTuple = SearchSysCache1(TYPEOID, ObjectIdGetDatum(arrayelemtype));\n\t\tif (!HeapTupleIsValid(typeTuple))\n\t\t\telog(ERROR, \"cache lookup failed for type %u\", arrayelemtype);\n\t\ttypeForm = (Form_pg_type) GETSTRUCT(typeTuple);\n\n\t\t/* Deconstruct array into Datum elements; NULLs not expected */\n\t\tdeconstruct_array(statarray,\n\t\t\t\t\t\t  arrayelemtype,\n\t\t\t\t\t\t  typeForm->typlen,\n\t\t\t\t\t\t  typeForm->typbyval,\n\t\t\t\t\t\t  typeForm->typalign,\n\t\t\t\t\t\t  &sslot->values, NULL, &sslot->nvalues);\n\n\t\t/*\n\t\t * If the element type is pass-by-reference, we now have a bunch of\n\t\t * Datums that are pointers into the statarray, so we need to keep\n\t\t * that until free_attstatsslot.  Otherwise, all the useful info is in\n\t\t * sslot->values[], so we can free the array object immediately.\n\t\t */\n\t\tif (!typeForm->typbyval)\n\t\t\tsslot->values_arr = statarray;\n\t\telse\n\t\t\tpfree(statarray);\n\n\t\tReleaseSysCache(typeTuple);\n\t}\n\n\tif (flags & ATTSTATSSLOT_NUMBERS)\n\t{\n\t\tval = SysCacheGetAttr(STATRELATTINH, statstuple,\n\t\t\t\t\t\t\t  Anum_pg_statistic_stanumbers1 + i,\n\t\t\t\t\t\t\t  &isnull);\n\t\tif (isnull)\n\t\t\telog(ERROR, \"stanumbers is null\");\n\n\t\t/*\n\t\t * Detoast the array if needed, and in any case make a copy that's\n\t\t * under control of this AttStatsSlot.\n\t\t */\n\t\tstatarray = DatumGetArrayTypePCopy(val);\n\n\t\t/*\n\t\t * We expect the array to be a 1-D float4 array; verify that. We don't\n\t\t * need to use deconstruct_array() since the array data is just going\n\t\t * to look like a C array of float4 values.\n\t\t */\n\t\tnarrayelem = ARR_DIMS(statarray)[0];\n\t\tif (ARR_NDIM(statarray) != 1 || narrayelem <= 0 ||\n\t\t\tARR_HASNULL(statarray) ||\n\t\t\tARR_ELEMTYPE(statarray) != FLOAT4OID)\n\t\t\telog(ERROR, \"stanumbers is not a 1-D float4 array\");\n\n\t\t/* Give caller a pointer directly into the statarray */\n\t\tsslot->numbers = (float4 *) ARR_DATA_PTR(statarray);\n\t\tsslot->nnumbers = narrayelem;\n\n\t\t/* We'll free the statarray in free_attstatsslot */\n\t\tsslot->numbers_arr = statarray;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "vardata->statsTuple"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_rangesel(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t  RangeType *constval, Oid operator);\nstatic double default_range_selectivity(Oid operator);\nstatic double calc_hist_selectivity(TypeCacheEntry *typcache,\n\t\t\t\t\t  VariableStatData *vardata, RangeType *constval,\n\t\t\t\t\t  Oid operator);\n\nstatic double\ncalc_rangesel(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t  RangeType *constval, Oid operator)\n{\n\tdouble\t\thist_selec;\n\tdouble\t\tselec;\n\tfloat4\t\tempty_frac,\n\t\t\t\tnull_frac;\n\n\t/*\n\t * First look up the fraction of NULLs and empty ranges from pg_statistic.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\t\tAttStatsSlot sslot;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tnull_frac = stats->stanullfrac;\n\n\t\t/* Try to get fraction of empty ranges */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM,\n\t\t\t\t\t\t\t InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\tif (sslot.nnumbers != 1)\n\t\t\t\telog(ERROR, \"invalid empty fraction statistic\");\t/* shouldn't happen */\n\t\t\tempty_frac = sslot.numbers[0];\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* No empty fraction statistic. Assume no empty ranges. */\n\t\t\tempty_frac = 0.0;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No stats are available. Follow through the calculations below\n\t\t * anyway, assuming no NULLs and no empty ranges. This still allows us\n\t\t * to give a better-than-nothing estimate based on whether the\n\t\t * constant is an empty range or not.\n\t\t */\n\t\tnull_frac = 0.0;\n\t\tempty_frac = 0.0;\n\t}\n\n\tif (RangeIsEmpty(constval))\n\t{\n\t\t/*\n\t\t * An empty range matches all ranges, all empty ranges, or nothing,\n\t\t * depending on the operator\n\t\t */\n\t\tswitch (operator)\n\t\t{\n\t\t\t\t/* these return false if either argument is empty */\n\t\t\tcase OID_RANGE_OVERLAP_OP:\n\t\t\tcase OID_RANGE_OVERLAPS_LEFT_OP:\n\t\t\tcase OID_RANGE_OVERLAPS_RIGHT_OP:\n\t\t\tcase OID_RANGE_LEFT_OP:\n\t\t\tcase OID_RANGE_RIGHT_OP:\n\t\t\t\t/* nothing is less than an empty range */\n\t\t\tcase OID_RANGE_LESS_OP:\n\t\t\t\tselec = 0.0;\n\t\t\t\tbreak;\n\n\t\t\t\t/* only empty ranges can be contained by an empty range */\n\t\t\tcase OID_RANGE_CONTAINED_OP:\n\t\t\t\t/* only empty ranges are <= an empty range */\n\t\t\tcase OID_RANGE_LESS_EQUAL_OP:\n\t\t\t\tselec = empty_frac;\n\t\t\t\tbreak;\n\n\t\t\t\t/* everything contains an empty range */\n\t\t\tcase OID_RANGE_CONTAINS_OP:\n\t\t\t\t/* everything is >= an empty range */\n\t\t\tcase OID_RANGE_GREATER_EQUAL_OP:\n\t\t\t\tselec = 1.0;\n\t\t\t\tbreak;\n\n\t\t\t\t/* all non-empty ranges are > an empty range */\n\t\t\tcase OID_RANGE_GREATER_OP:\n\t\t\t\tselec = 1.0 - empty_frac;\n\t\t\t\tbreak;\n\n\t\t\t\t/* an element cannot be empty */\n\t\t\tcase OID_RANGE_CONTAINS_ELEM_OP:\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected operator %u\", operator);\n\t\t\t\tselec = 0.0;\t/* keep compiler quiet */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Calculate selectivity using bound histograms. If that fails for\n\t\t * some reason, e.g no histogram in pg_statistic, use the default\n\t\t * constant estimate for the fraction of non-empty values. This is\n\t\t * still somewhat better than just returning the default estimate,\n\t\t * because this still takes into account the fraction of empty and\n\t\t * NULL tuples, if we had statistics for them.\n\t\t */\n\t\thist_selec = calc_hist_selectivity(typcache, vardata, constval,\n\t\t\t\t\t\t\t\t\t\t   operator);\n\t\tif (hist_selec < 0.0)\n\t\t\thist_selec = default_range_selectivity(operator);\n\n\t\t/*\n\t\t * Now merge the results for the empty ranges and histogram\n\t\t * calculations, realizing that the histogram covers only the\n\t\t * non-null, non-empty values.\n\t\t */\n\t\tif (operator == OID_RANGE_CONTAINED_OP)\n\t\t{\n\t\t\t/* empty is contained by anything non-empty */\n\t\t\tselec = (1.0 - empty_frac) * hist_selec + empty_frac;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* with any other operator, empty Op non-empty matches nothing */\n\t\t\tselec = (1.0 - empty_frac) * hist_selec;\n\t\t}\n\t}\n\n\t/* all range operators are strict */\n\tselec *= (1.0 - null_frac);\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}"
  },
  {
    "function_name": "rangesel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
    "lines": "105-225",
    "snippet": "Datum\nrangesel(PG_FUNCTION_ARGS)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tSelectivity selec;\n\tTypeCacheEntry *typcache = NULL;\n\tRangeType  *constrange = NULL;\n\n\t/*\n\t * If expression is not (variable op something) or (something op\n\t * variable), then punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\tPG_RETURN_FLOAT8(default_range_selectivity(operator));\n\n\t/*\n\t * Can't do anything useful if the something is not a constant, either.\n\t */\n\tif (!IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(default_range_selectivity(operator));\n\t}\n\n\t/*\n\t * All the range operators are strict, so we can cope with a NULL constant\n\t * right away.\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(0.0);\n\t}\n\n\t/*\n\t * If var is on the right, commute the operator, so that we can assume the\n\t * var is on the left in what follows.\n\t */\n\tif (!varonleft)\n\t{\n\t\t/* we have other Op var, commute to make var Op other */\n\t\toperator = get_commutator(operator);\n\t\tif (!operator)\n\t\t{\n\t\t\t/* Use default selectivity (should we raise an error instead?) */\n\t\t\tReleaseVariableStats(vardata);\n\t\t\tPG_RETURN_FLOAT8(default_range_selectivity(operator));\n\t\t}\n\t}\n\n\t/*\n\t * OK, there's a Var and a Const we're dealing with here.  We need the\n\t * Const to be of same range type as the column, else we can't do anything\n\t * useful. (Such cases will likely fail at runtime, but here we'd rather\n\t * just return a default estimate.)\n\t *\n\t * If the operator is \"range @> element\", the constant should be of the\n\t * element type of the range column. Convert it to a range that includes\n\t * only that single point, so that we don't need special handling for that\n\t * in what follows.\n\t */\n\tif (operator == OID_RANGE_CONTAINS_ELEM_OP)\n\t{\n\t\ttypcache = range_get_typcache(fcinfo, vardata.vartype);\n\n\t\tif (((Const *) other)->consttype == typcache->rngelemtype->type_id)\n\t\t{\n\t\t\tRangeBound\tlower,\n\t\t\t\t\t\tupper;\n\n\t\t\tlower.inclusive = true;\n\t\t\tlower.val = ((Const *) other)->constvalue;\n\t\t\tlower.infinite = false;\n\t\t\tlower.lower = true;\n\t\t\tupper.inclusive = true;\n\t\t\tupper.val = ((Const *) other)->constvalue;\n\t\t\tupper.infinite = false;\n\t\t\tupper.lower = false;\n\t\t\tconstrange = range_serialize(typcache, &lower, &upper, false);\n\t\t}\n\t}\n\telse if (operator == OID_RANGE_ELEM_CONTAINED_OP)\n\t{\n\t\t/*\n\t\t * Here, the Var is the elem, not the range.  For now we just punt and\n\t\t * return the default estimate.  In future we could disassemble the\n\t\t * range constant and apply scalarineqsel ...\n\t\t */\n\t}\n\telse if (((Const *) other)->consttype == vardata.vartype)\n\t{\n\t\t/* Both sides are the same range type */\n\t\ttypcache = range_get_typcache(fcinfo, vardata.vartype);\n\n\t\tconstrange = DatumGetRangeTypeP(((Const *) other)->constvalue);\n\t}\n\n\t/*\n\t * If we got a valid constant on one side of the operator, proceed to\n\t * estimate using statistics. Otherwise punt and return a default constant\n\t * estimate.  Note that calc_rangesel need not handle\n\t * OID_RANGE_ELEM_CONTAINED_OP.\n\t */\n\tif (constrange)\n\t\tselec = calc_rangesel(typcache, &vardata, constrange, operator);\n\telse\n\t\tselec = default_range_selectivity(operator);\n\n\tReleaseVariableStats(vardata);\n\n\tCLAMP_PROBABILITY(selec);\n\n\tPG_RETURN_FLOAT8((float8) selec);\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double calc_rangesel(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t  RangeType *constval, Oid operator);",
      "static double default_range_selectivity(Oid operator);",
      "static double calc_hist_selectivity(TypeCacheEntry *typcache,\n\t\t\t\t\t  VariableStatData *vardata, RangeType *constval,\n\t\t\t\t\t  Oid operator);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "(float8) selec"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLAMP_PROBABILITY",
          "args": [
            "selec"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "default_range_selectivity",
          "args": [
            "operator"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "default_range_selectivity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "64-100",
          "snippet": "static double\ndefault_range_selectivity(Oid operator)\n{\n\tswitch (operator)\n\t{\n\t\tcase OID_RANGE_OVERLAP_OP:\n\t\t\treturn 0.01;\n\n\t\tcase OID_RANGE_CONTAINS_OP:\n\t\tcase OID_RANGE_CONTAINED_OP:\n\t\t\treturn 0.005;\n\n\t\tcase OID_RANGE_CONTAINS_ELEM_OP:\n\t\tcase OID_RANGE_ELEM_CONTAINED_OP:\n\n\t\t\t/*\n\t\t\t * \"range @> elem\" is more or less identical to a scalar\n\t\t\t * inequality \"A >= b AND A <= c\".\n\t\t\t */\n\t\t\treturn DEFAULT_RANGE_INEQ_SEL;\n\n\t\tcase OID_RANGE_LESS_OP:\n\t\tcase OID_RANGE_LESS_EQUAL_OP:\n\t\tcase OID_RANGE_GREATER_OP:\n\t\tcase OID_RANGE_GREATER_EQUAL_OP:\n\t\tcase OID_RANGE_LEFT_OP:\n\t\tcase OID_RANGE_RIGHT_OP:\n\t\tcase OID_RANGE_OVERLAPS_LEFT_OP:\n\t\tcase OID_RANGE_OVERLAPS_RIGHT_OP:\n\t\t\t/* these are similar to regular scalar inequalities */\n\t\t\treturn DEFAULT_INEQ_SEL;\n\n\t\tdefault:\n\t\t\t/* all range operators should be handled above, but just in case */\n\t\t\treturn 0.01;\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_rangesel(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t  RangeType *constval, Oid operator);",
            "static double default_range_selectivity(Oid operator);",
            "static double calc_hist_selectivity(TypeCacheEntry *typcache,\n\t\t\t\t\t  VariableStatData *vardata, RangeType *constval,\n\t\t\t\t\t  Oid operator);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_rangesel(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t  RangeType *constval, Oid operator);\nstatic double default_range_selectivity(Oid operator);\nstatic double calc_hist_selectivity(TypeCacheEntry *typcache,\n\t\t\t\t\t  VariableStatData *vardata, RangeType *constval,\n\t\t\t\t\t  Oid operator);\n\nstatic double\ndefault_range_selectivity(Oid operator)\n{\n\tswitch (operator)\n\t{\n\t\tcase OID_RANGE_OVERLAP_OP:\n\t\t\treturn 0.01;\n\n\t\tcase OID_RANGE_CONTAINS_OP:\n\t\tcase OID_RANGE_CONTAINED_OP:\n\t\t\treturn 0.005;\n\n\t\tcase OID_RANGE_CONTAINS_ELEM_OP:\n\t\tcase OID_RANGE_ELEM_CONTAINED_OP:\n\n\t\t\t/*\n\t\t\t * \"range @> elem\" is more or less identical to a scalar\n\t\t\t * inequality \"A >= b AND A <= c\".\n\t\t\t */\n\t\t\treturn DEFAULT_RANGE_INEQ_SEL;\n\n\t\tcase OID_RANGE_LESS_OP:\n\t\tcase OID_RANGE_LESS_EQUAL_OP:\n\t\tcase OID_RANGE_GREATER_OP:\n\t\tcase OID_RANGE_GREATER_EQUAL_OP:\n\t\tcase OID_RANGE_LEFT_OP:\n\t\tcase OID_RANGE_RIGHT_OP:\n\t\tcase OID_RANGE_OVERLAPS_LEFT_OP:\n\t\tcase OID_RANGE_OVERLAPS_RIGHT_OP:\n\t\t\t/* these are similar to regular scalar inequalities */\n\t\t\treturn DEFAULT_INEQ_SEL;\n\n\t\tdefault:\n\t\t\t/* all range operators should be handled above, but just in case */\n\t\t\treturn 0.01;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_rangesel",
          "args": [
            "typcache",
            "&vardata",
            "constrange",
            "operator"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "calc_rangesel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
          "lines": "227-361",
          "snippet": "static double\ncalc_rangesel(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t  RangeType *constval, Oid operator)\n{\n\tdouble\t\thist_selec;\n\tdouble\t\tselec;\n\tfloat4\t\tempty_frac,\n\t\t\t\tnull_frac;\n\n\t/*\n\t * First look up the fraction of NULLs and empty ranges from pg_statistic.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\t\tAttStatsSlot sslot;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tnull_frac = stats->stanullfrac;\n\n\t\t/* Try to get fraction of empty ranges */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM,\n\t\t\t\t\t\t\t InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\tif (sslot.nnumbers != 1)\n\t\t\t\telog(ERROR, \"invalid empty fraction statistic\");\t/* shouldn't happen */\n\t\t\tempty_frac = sslot.numbers[0];\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* No empty fraction statistic. Assume no empty ranges. */\n\t\t\tempty_frac = 0.0;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No stats are available. Follow through the calculations below\n\t\t * anyway, assuming no NULLs and no empty ranges. This still allows us\n\t\t * to give a better-than-nothing estimate based on whether the\n\t\t * constant is an empty range or not.\n\t\t */\n\t\tnull_frac = 0.0;\n\t\tempty_frac = 0.0;\n\t}\n\n\tif (RangeIsEmpty(constval))\n\t{\n\t\t/*\n\t\t * An empty range matches all ranges, all empty ranges, or nothing,\n\t\t * depending on the operator\n\t\t */\n\t\tswitch (operator)\n\t\t{\n\t\t\t\t/* these return false if either argument is empty */\n\t\t\tcase OID_RANGE_OVERLAP_OP:\n\t\t\tcase OID_RANGE_OVERLAPS_LEFT_OP:\n\t\t\tcase OID_RANGE_OVERLAPS_RIGHT_OP:\n\t\t\tcase OID_RANGE_LEFT_OP:\n\t\t\tcase OID_RANGE_RIGHT_OP:\n\t\t\t\t/* nothing is less than an empty range */\n\t\t\tcase OID_RANGE_LESS_OP:\n\t\t\t\tselec = 0.0;\n\t\t\t\tbreak;\n\n\t\t\t\t/* only empty ranges can be contained by an empty range */\n\t\t\tcase OID_RANGE_CONTAINED_OP:\n\t\t\t\t/* only empty ranges are <= an empty range */\n\t\t\tcase OID_RANGE_LESS_EQUAL_OP:\n\t\t\t\tselec = empty_frac;\n\t\t\t\tbreak;\n\n\t\t\t\t/* everything contains an empty range */\n\t\t\tcase OID_RANGE_CONTAINS_OP:\n\t\t\t\t/* everything is >= an empty range */\n\t\t\tcase OID_RANGE_GREATER_EQUAL_OP:\n\t\t\t\tselec = 1.0;\n\t\t\t\tbreak;\n\n\t\t\t\t/* all non-empty ranges are > an empty range */\n\t\t\tcase OID_RANGE_GREATER_OP:\n\t\t\t\tselec = 1.0 - empty_frac;\n\t\t\t\tbreak;\n\n\t\t\t\t/* an element cannot be empty */\n\t\t\tcase OID_RANGE_CONTAINS_ELEM_OP:\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected operator %u\", operator);\n\t\t\t\tselec = 0.0;\t/* keep compiler quiet */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Calculate selectivity using bound histograms. If that fails for\n\t\t * some reason, e.g no histogram in pg_statistic, use the default\n\t\t * constant estimate for the fraction of non-empty values. This is\n\t\t * still somewhat better than just returning the default estimate,\n\t\t * because this still takes into account the fraction of empty and\n\t\t * NULL tuples, if we had statistics for them.\n\t\t */\n\t\thist_selec = calc_hist_selectivity(typcache, vardata, constval,\n\t\t\t\t\t\t\t\t\t\t   operator);\n\t\tif (hist_selec < 0.0)\n\t\t\thist_selec = default_range_selectivity(operator);\n\n\t\t/*\n\t\t * Now merge the results for the empty ranges and histogram\n\t\t * calculations, realizing that the histogram covers only the\n\t\t * non-null, non-empty values.\n\t\t */\n\t\tif (operator == OID_RANGE_CONTAINED_OP)\n\t\t{\n\t\t\t/* empty is contained by anything non-empty */\n\t\t\tselec = (1.0 - empty_frac) * hist_selec + empty_frac;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* with any other operator, empty Op non-empty matches nothing */\n\t\t\tselec = (1.0 - empty_frac) * hist_selec;\n\t\t}\n\t}\n\n\t/* all range operators are strict */\n\tselec *= (1.0 - null_frac);\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double calc_rangesel(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t  RangeType *constval, Oid operator);",
            "static double default_range_selectivity(Oid operator);",
            "static double calc_hist_selectivity(TypeCacheEntry *typcache,\n\t\t\t\t\t  VariableStatData *vardata, RangeType *constval,\n\t\t\t\t\t  Oid operator);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_rangesel(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t  RangeType *constval, Oid operator);\nstatic double default_range_selectivity(Oid operator);\nstatic double calc_hist_selectivity(TypeCacheEntry *typcache,\n\t\t\t\t\t  VariableStatData *vardata, RangeType *constval,\n\t\t\t\t\t  Oid operator);\n\nstatic double\ncalc_rangesel(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t  RangeType *constval, Oid operator)\n{\n\tdouble\t\thist_selec;\n\tdouble\t\tselec;\n\tfloat4\t\tempty_frac,\n\t\t\t\tnull_frac;\n\n\t/*\n\t * First look up the fraction of NULLs and empty ranges from pg_statistic.\n\t */\n\tif (HeapTupleIsValid(vardata->statsTuple))\n\t{\n\t\tForm_pg_statistic stats;\n\t\tAttStatsSlot sslot;\n\n\t\tstats = (Form_pg_statistic) GETSTRUCT(vardata->statsTuple);\n\t\tnull_frac = stats->stanullfrac;\n\n\t\t/* Try to get fraction of empty ranges */\n\t\tif (get_attstatsslot(&sslot, vardata->statsTuple,\n\t\t\t\t\t\t\t STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM,\n\t\t\t\t\t\t\t InvalidOid,\n\t\t\t\t\t\t\t ATTSTATSSLOT_NUMBERS))\n\t\t{\n\t\t\tif (sslot.nnumbers != 1)\n\t\t\t\telog(ERROR, \"invalid empty fraction statistic\");\t/* shouldn't happen */\n\t\t\tempty_frac = sslot.numbers[0];\n\t\t\tfree_attstatsslot(&sslot);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* No empty fraction statistic. Assume no empty ranges. */\n\t\t\tempty_frac = 0.0;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * No stats are available. Follow through the calculations below\n\t\t * anyway, assuming no NULLs and no empty ranges. This still allows us\n\t\t * to give a better-than-nothing estimate based on whether the\n\t\t * constant is an empty range or not.\n\t\t */\n\t\tnull_frac = 0.0;\n\t\tempty_frac = 0.0;\n\t}\n\n\tif (RangeIsEmpty(constval))\n\t{\n\t\t/*\n\t\t * An empty range matches all ranges, all empty ranges, or nothing,\n\t\t * depending on the operator\n\t\t */\n\t\tswitch (operator)\n\t\t{\n\t\t\t\t/* these return false if either argument is empty */\n\t\t\tcase OID_RANGE_OVERLAP_OP:\n\t\t\tcase OID_RANGE_OVERLAPS_LEFT_OP:\n\t\t\tcase OID_RANGE_OVERLAPS_RIGHT_OP:\n\t\t\tcase OID_RANGE_LEFT_OP:\n\t\t\tcase OID_RANGE_RIGHT_OP:\n\t\t\t\t/* nothing is less than an empty range */\n\t\t\tcase OID_RANGE_LESS_OP:\n\t\t\t\tselec = 0.0;\n\t\t\t\tbreak;\n\n\t\t\t\t/* only empty ranges can be contained by an empty range */\n\t\t\tcase OID_RANGE_CONTAINED_OP:\n\t\t\t\t/* only empty ranges are <= an empty range */\n\t\t\tcase OID_RANGE_LESS_EQUAL_OP:\n\t\t\t\tselec = empty_frac;\n\t\t\t\tbreak;\n\n\t\t\t\t/* everything contains an empty range */\n\t\t\tcase OID_RANGE_CONTAINS_OP:\n\t\t\t\t/* everything is >= an empty range */\n\t\t\tcase OID_RANGE_GREATER_EQUAL_OP:\n\t\t\t\tselec = 1.0;\n\t\t\t\tbreak;\n\n\t\t\t\t/* all non-empty ranges are > an empty range */\n\t\t\tcase OID_RANGE_GREATER_OP:\n\t\t\t\tselec = 1.0 - empty_frac;\n\t\t\t\tbreak;\n\n\t\t\t\t/* an element cannot be empty */\n\t\t\tcase OID_RANGE_CONTAINS_ELEM_OP:\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unexpected operator %u\", operator);\n\t\t\t\tselec = 0.0;\t/* keep compiler quiet */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Calculate selectivity using bound histograms. If that fails for\n\t\t * some reason, e.g no histogram in pg_statistic, use the default\n\t\t * constant estimate for the fraction of non-empty values. This is\n\t\t * still somewhat better than just returning the default estimate,\n\t\t * because this still takes into account the fraction of empty and\n\t\t * NULL tuples, if we had statistics for them.\n\t\t */\n\t\thist_selec = calc_hist_selectivity(typcache, vardata, constval,\n\t\t\t\t\t\t\t\t\t\t   operator);\n\t\tif (hist_selec < 0.0)\n\t\t\thist_selec = default_range_selectivity(operator);\n\n\t\t/*\n\t\t * Now merge the results for the empty ranges and histogram\n\t\t * calculations, realizing that the histogram covers only the\n\t\t * non-null, non-empty values.\n\t\t */\n\t\tif (operator == OID_RANGE_CONTAINED_OP)\n\t\t{\n\t\t\t/* empty is contained by anything non-empty */\n\t\t\tselec = (1.0 - empty_frac) * hist_selec + empty_frac;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* with any other operator, empty Op non-empty matches nothing */\n\t\t\tselec = (1.0 - empty_frac) * hist_selec;\n\t\t}\n\t}\n\n\t/* all range operators are strict */\n\tselec *= (1.0 - null_frac);\n\n\t/* result should be in range, but make sure... */\n\tCLAMP_PROBABILITY(selec);\n\n\treturn selec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetRangeTypeP",
          "args": [
            "((Const *) other)->constvalue"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "range_get_typcache",
          "args": [
            "fcinfo",
            "vardata.vartype"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "range_get_typcache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1542-1557",
          "snippet": "TypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nTypeCacheEntry *\nrange_get_typcache(FunctionCallInfo fcinfo, Oid rngtypid)\n{\n\tTypeCacheEntry *typcache = (TypeCacheEntry *) fcinfo->flinfo->fn_extra;\n\n\tif (typcache == NULL ||\n\t\ttypcache->type_id != rngtypid)\n\t{\n\t\ttypcache = lookup_type_cache(rngtypid, TYPECACHE_RANGE_INFO);\n\t\tif (typcache->rngelemtype == NULL)\n\t\t\telog(ERROR, \"type %u is not a range type\", rngtypid);\n\t\tfcinfo->flinfo->fn_extra = (void *) typcache;\n\t}\n\n\treturn typcache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "range_serialize",
          "args": [
            "typcache",
            "&lower",
            "&upper",
            "false"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "range_serialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes.c",
          "lines": "1566-1684",
          "snippet": "RangeType *\nrange_serialize(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t\t\tbool empty)\n{\n\tRangeType  *range;\n\tint\t\t\tcmp;\n\tSize\t\tmsize;\n\tPointer\t\tptr;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t\ttypstorage;\n\tchar\t\tflags = 0;\n\n\t/*\n\t * Verify range is not invalid on its face, and construct flags value,\n\t * preventing any non-canonical combinations such as infinite+inclusive.\n\t */\n\tAssert(lower->lower);\n\tAssert(!upper->lower);\n\n\tif (empty)\n\t\tflags |= RANGE_EMPTY;\n\telse\n\t{\n\t\tcmp = range_cmp_bound_values(typcache, lower, upper);\n\n\t\t/* error check: if lower bound value is above upper, it's wrong */\n\t\tif (cmp > 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"range lower bound must be less than or equal to range upper bound\")));\n\n\t\t/* if bounds are equal, and not both inclusive, range is empty */\n\t\tif (cmp == 0 && !(lower->inclusive && upper->inclusive))\n\t\t\tflags |= RANGE_EMPTY;\n\t\telse\n\t\t{\n\t\t\t/* infinite boundaries are never inclusive */\n\t\t\tif (lower->infinite)\n\t\t\t\tflags |= RANGE_LB_INF;\n\t\t\telse if (lower->inclusive)\n\t\t\t\tflags |= RANGE_LB_INC;\n\t\t\tif (upper->infinite)\n\t\t\t\tflags |= RANGE_UB_INF;\n\t\t\telse if (upper->inclusive)\n\t\t\t\tflags |= RANGE_UB_INC;\n\t\t}\n\t}\n\n\t/* Fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\ttypstorage = typcache->rngelemtype->typstorage;\n\n\t/* Count space for varlena header and range type's OID */\n\tmsize = sizeof(RangeType);\n\tAssert(msize == MAXALIGN(msize));\n\n\t/* Count space for bounds */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/*\n\t\t * Make sure item to be inserted is not toasted.  It is essential that\n\t\t * we not insert an out-of-line toast value pointer into a range\n\t\t * object, for the same reasons that arrays and records can't contain\n\t\t * them.  It would work to store a compressed-in-line value, but we\n\t\t * prefer to decompress and then let compression be applied to the\n\t\t * whole range object if necessary.  But, unlike arrays, we do allow\n\t\t * short-header varlena objects to stay as-is.\n\t\t */\n\t\tif (typlen == -1)\n\t\t\tlower->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(lower->val));\n\n\t\tmsize = datum_compute_size(msize, lower->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\t/* Make sure item to be inserted is not toasted */\n\t\tif (typlen == -1)\n\t\t\tupper->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(upper->val));\n\n\t\tmsize = datum_compute_size(msize, upper->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\t/* Add space for flag byte */\n\tmsize += sizeof(char);\n\n\t/* Note: zero-fill is required here, just as in heap tuples */\n\trange = (RangeType *) palloc0(msize);\n\tSET_VARSIZE(range, msize);\n\n\t/* Now fill in the datum */\n\trange->rangetypid = typcache->type_id;\n\n\tptr = (char *) (range + 1);\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\tAssert(lower->lower);\n\t\tptr = datum_write(ptr, lower->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tAssert(!upper->lower);\n\t\tptr = datum_write(ptr, upper->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\t*((char *) ptr) = flags;\n\n\treturn range;\n}",
          "includes": [
            "#include \"utils/timestamp.h\"",
            "#include \"utils/rangetypes.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/int8.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);",
            "static char *range_bound_escape(const char *value);",
            "static Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);",
            "static Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/timestamp.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/int8.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nstatic const char *range_parse_bound(const char *string, const char *ptr,\n\t\t\t\t  char **bound_str, bool *infinite);\nstatic char *range_bound_escape(const char *value);\nstatic Size datum_compute_size(Size sz, Datum datum, bool typbyval,\n\t\t\t\t   char typalign, int16 typlen, char typstorage);\nstatic Pointer datum_write(Pointer ptr, Datum datum, bool typbyval,\n\t\t\tchar typalign, int16 typlen, char typstorage);\n\nRangeType *\nrange_serialize(TypeCacheEntry *typcache, RangeBound *lower, RangeBound *upper,\n\t\t\t\tbool empty)\n{\n\tRangeType  *range;\n\tint\t\t\tcmp;\n\tSize\t\tmsize;\n\tPointer\t\tptr;\n\tint16\t\ttyplen;\n\tbool\t\ttypbyval;\n\tchar\t\ttypalign;\n\tchar\t\ttypstorage;\n\tchar\t\tflags = 0;\n\n\t/*\n\t * Verify range is not invalid on its face, and construct flags value,\n\t * preventing any non-canonical combinations such as infinite+inclusive.\n\t */\n\tAssert(lower->lower);\n\tAssert(!upper->lower);\n\n\tif (empty)\n\t\tflags |= RANGE_EMPTY;\n\telse\n\t{\n\t\tcmp = range_cmp_bound_values(typcache, lower, upper);\n\n\t\t/* error check: if lower bound value is above upper, it's wrong */\n\t\tif (cmp > 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATA_EXCEPTION),\n\t\t\t\t\t errmsg(\"range lower bound must be less than or equal to range upper bound\")));\n\n\t\t/* if bounds are equal, and not both inclusive, range is empty */\n\t\tif (cmp == 0 && !(lower->inclusive && upper->inclusive))\n\t\t\tflags |= RANGE_EMPTY;\n\t\telse\n\t\t{\n\t\t\t/* infinite boundaries are never inclusive */\n\t\t\tif (lower->infinite)\n\t\t\t\tflags |= RANGE_LB_INF;\n\t\t\telse if (lower->inclusive)\n\t\t\t\tflags |= RANGE_LB_INC;\n\t\t\tif (upper->infinite)\n\t\t\t\tflags |= RANGE_UB_INF;\n\t\t\telse if (upper->inclusive)\n\t\t\t\tflags |= RANGE_UB_INC;\n\t\t}\n\t}\n\n\t/* Fetch information about range's element type */\n\ttyplen = typcache->rngelemtype->typlen;\n\ttypbyval = typcache->rngelemtype->typbyval;\n\ttypalign = typcache->rngelemtype->typalign;\n\ttypstorage = typcache->rngelemtype->typstorage;\n\n\t/* Count space for varlena header and range type's OID */\n\tmsize = sizeof(RangeType);\n\tAssert(msize == MAXALIGN(msize));\n\n\t/* Count space for bounds */\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\t/*\n\t\t * Make sure item to be inserted is not toasted.  It is essential that\n\t\t * we not insert an out-of-line toast value pointer into a range\n\t\t * object, for the same reasons that arrays and records can't contain\n\t\t * them.  It would work to store a compressed-in-line value, but we\n\t\t * prefer to decompress and then let compression be applied to the\n\t\t * whole range object if necessary.  But, unlike arrays, we do allow\n\t\t * short-header varlena objects to stay as-is.\n\t\t */\n\t\tif (typlen == -1)\n\t\t\tlower->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(lower->val));\n\n\t\tmsize = datum_compute_size(msize, lower->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\t/* Make sure item to be inserted is not toasted */\n\t\tif (typlen == -1)\n\t\t\tupper->val = PointerGetDatum(PG_DETOAST_DATUM_PACKED(upper->val));\n\n\t\tmsize = datum_compute_size(msize, upper->val, typbyval, typalign,\n\t\t\t\t\t\t\t\t   typlen, typstorage);\n\t}\n\n\t/* Add space for flag byte */\n\tmsize += sizeof(char);\n\n\t/* Note: zero-fill is required here, just as in heap tuples */\n\trange = (RangeType *) palloc0(msize);\n\tSET_VARSIZE(range, msize);\n\n\t/* Now fill in the datum */\n\trange->rangetypid = typcache->type_id;\n\n\tptr = (char *) (range + 1);\n\n\tif (RANGE_HAS_LBOUND(flags))\n\t{\n\t\tAssert(lower->lower);\n\t\tptr = datum_write(ptr, lower->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\tif (RANGE_HAS_UBOUND(flags))\n\t{\n\t\tAssert(!upper->lower);\n\t\tptr = datum_write(ptr, upper->val, typbyval, typalign, typlen,\n\t\t\t\t\t\t  typstorage);\n\t}\n\n\t*((char *) ptr) = flags;\n\n\treturn range;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "default_range_selectivity(operator)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_commutator",
          "args": [
            "operator"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "get_commutator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "1297-1314",
          "snippet": "Oid\nget_commutator(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = optup->oprcom;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nOid\nget_commutator(Oid opno)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(OPEROID, ObjectIdGetDatum(opno));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_operator optup = (Form_pg_operator) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = optup->oprcom;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "0.0"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "default_range_selectivity(operator)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseVariableStats",
          "args": [
            "vardata"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsA",
          "args": [
            "other",
            "Const"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_FLOAT8",
          "args": [
            "default_range_selectivity(operator)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_restriction_variable",
          "args": [
            "root",
            "args",
            "varRelid",
            "&vardata",
            "&other",
            "&varonleft"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "get_restriction_variable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
          "lines": "4653-4701",
          "snippet": "bool\nget_restriction_variable(PlannerInfo *root, List *args, int varRelid,\n\t\t\t\t\t\t VariableStatData *vardata, Node **other,\n\t\t\t\t\t\t bool *varonleft)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\tVariableStatData rdata;\n\n\t/* Fail if not a binary opclause (probably shouldn't happen) */\n\tif (list_length(args) != 2)\n\t\treturn false;\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\t/*\n\t * Examine both sides.  Note that when varRelid is nonzero, Vars of other\n\t * relations will be treated as pseudoconstants.\n\t */\n\texamine_variable(root, left, varRelid, vardata);\n\texamine_variable(root, right, varRelid, &rdata);\n\n\t/*\n\t * If one side is a variable and the other not, we win.\n\t */\n\tif (vardata->rel && rdata.rel == NULL)\n\t{\n\t\t*varonleft = true;\n\t\t*other = estimate_expression_value(root, rdata.var);\n\t\t/* Assume we need no ReleaseVariableStats(rdata) here */\n\t\treturn true;\n\t}\n\n\tif (vardata->rel == NULL && rdata.rel)\n\t{\n\t\t*varonleft = false;\n\t\t*other = estimate_expression_value(root, vardata->var);\n\t\t/* Assume we need no ReleaseVariableStats(*vardata) here */\n\t\t*vardata = rdata;\n\t\treturn true;\n\t}\n\n\t/* Oops, clause has wrong structure (probably var op var) */\n\tReleaseVariableStats(*vardata);\n\tReleaseVariableStats(rdata);\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/timestamp.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/spccache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/selfuncs.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/nabstime.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/index_selfuncs.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"statistics/statistics.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"parser/parse_clause.h\"",
            "#include \"optimizer/var.h\"",
            "#include \"optimizer/restrictinfo.h\"",
            "#include \"optimizer/predtest.h\"",
            "#include \"optimizer/plancat.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/pathnode.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"optimizer/clauses.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"executor/executor.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/index.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/brin.h\"",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nbool\nget_restriction_variable(PlannerInfo *root, List *args, int varRelid,\n\t\t\t\t\t\t VariableStatData *vardata, Node **other,\n\t\t\t\t\t\t bool *varonleft)\n{\n\tNode\t   *left,\n\t\t\t   *right;\n\tVariableStatData rdata;\n\n\t/* Fail if not a binary opclause (probably shouldn't happen) */\n\tif (list_length(args) != 2)\n\t\treturn false;\n\n\tleft = (Node *) linitial(args);\n\tright = (Node *) lsecond(args);\n\n\t/*\n\t * Examine both sides.  Note that when varRelid is nonzero, Vars of other\n\t * relations will be treated as pseudoconstants.\n\t */\n\texamine_variable(root, left, varRelid, vardata);\n\texamine_variable(root, right, varRelid, &rdata);\n\n\t/*\n\t * If one side is a variable and the other not, we win.\n\t */\n\tif (vardata->rel && rdata.rel == NULL)\n\t{\n\t\t*varonleft = true;\n\t\t*other = estimate_expression_value(root, rdata.var);\n\t\t/* Assume we need no ReleaseVariableStats(rdata) here */\n\t\treturn true;\n\t}\n\n\tif (vardata->rel == NULL && rdata.rel)\n\t{\n\t\t*varonleft = false;\n\t\t*other = estimate_expression_value(root, vardata->var);\n\t\t/* Assume we need no ReleaseVariableStats(*vardata) here */\n\t\t*vardata = rdata;\n\t\treturn true;\n\t}\n\n\t/* Oops, clause has wrong structure (probably var op var) */\n\tReleaseVariableStats(*vardata);\n\tReleaseVariableStats(rdata);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_INT32",
          "args": [
            "3"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "2"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "1"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_rangesel(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t  RangeType *constval, Oid operator);\nstatic double default_range_selectivity(Oid operator);\nstatic double calc_hist_selectivity(TypeCacheEntry *typcache,\n\t\t\t\t\t  VariableStatData *vardata, RangeType *constval,\n\t\t\t\t\t  Oid operator);\n\nDatum\nrangesel(PG_FUNCTION_ARGS)\n{\n\tPlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0);\n\tOid\t\t\toperator = PG_GETARG_OID(1);\n\tList\t   *args = (List *) PG_GETARG_POINTER(2);\n\tint\t\t\tvarRelid = PG_GETARG_INT32(3);\n\tVariableStatData vardata;\n\tNode\t   *other;\n\tbool\t\tvaronleft;\n\tSelectivity selec;\n\tTypeCacheEntry *typcache = NULL;\n\tRangeType  *constrange = NULL;\n\n\t/*\n\t * If expression is not (variable op something) or (something op\n\t * variable), then punt and return a default estimate.\n\t */\n\tif (!get_restriction_variable(root, args, varRelid,\n\t\t\t\t\t\t\t\t  &vardata, &other, &varonleft))\n\t\tPG_RETURN_FLOAT8(default_range_selectivity(operator));\n\n\t/*\n\t * Can't do anything useful if the something is not a constant, either.\n\t */\n\tif (!IsA(other, Const))\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(default_range_selectivity(operator));\n\t}\n\n\t/*\n\t * All the range operators are strict, so we can cope with a NULL constant\n\t * right away.\n\t */\n\tif (((Const *) other)->constisnull)\n\t{\n\t\tReleaseVariableStats(vardata);\n\t\tPG_RETURN_FLOAT8(0.0);\n\t}\n\n\t/*\n\t * If var is on the right, commute the operator, so that we can assume the\n\t * var is on the left in what follows.\n\t */\n\tif (!varonleft)\n\t{\n\t\t/* we have other Op var, commute to make var Op other */\n\t\toperator = get_commutator(operator);\n\t\tif (!operator)\n\t\t{\n\t\t\t/* Use default selectivity (should we raise an error instead?) */\n\t\t\tReleaseVariableStats(vardata);\n\t\t\tPG_RETURN_FLOAT8(default_range_selectivity(operator));\n\t\t}\n\t}\n\n\t/*\n\t * OK, there's a Var and a Const we're dealing with here.  We need the\n\t * Const to be of same range type as the column, else we can't do anything\n\t * useful. (Such cases will likely fail at runtime, but here we'd rather\n\t * just return a default estimate.)\n\t *\n\t * If the operator is \"range @> element\", the constant should be of the\n\t * element type of the range column. Convert it to a range that includes\n\t * only that single point, so that we don't need special handling for that\n\t * in what follows.\n\t */\n\tif (operator == OID_RANGE_CONTAINS_ELEM_OP)\n\t{\n\t\ttypcache = range_get_typcache(fcinfo, vardata.vartype);\n\n\t\tif (((Const *) other)->consttype == typcache->rngelemtype->type_id)\n\t\t{\n\t\t\tRangeBound\tlower,\n\t\t\t\t\t\tupper;\n\n\t\t\tlower.inclusive = true;\n\t\t\tlower.val = ((Const *) other)->constvalue;\n\t\t\tlower.infinite = false;\n\t\t\tlower.lower = true;\n\t\t\tupper.inclusive = true;\n\t\t\tupper.val = ((Const *) other)->constvalue;\n\t\t\tupper.infinite = false;\n\t\t\tupper.lower = false;\n\t\t\tconstrange = range_serialize(typcache, &lower, &upper, false);\n\t\t}\n\t}\n\telse if (operator == OID_RANGE_ELEM_CONTAINED_OP)\n\t{\n\t\t/*\n\t\t * Here, the Var is the elem, not the range.  For now we just punt and\n\t\t * return the default estimate.  In future we could disassemble the\n\t\t * range constant and apply scalarineqsel ...\n\t\t */\n\t}\n\telse if (((Const *) other)->consttype == vardata.vartype)\n\t{\n\t\t/* Both sides are the same range type */\n\t\ttypcache = range_get_typcache(fcinfo, vardata.vartype);\n\n\t\tconstrange = DatumGetRangeTypeP(((Const *) other)->constvalue);\n\t}\n\n\t/*\n\t * If we got a valid constant on one side of the operator, proceed to\n\t * estimate using statistics. Otherwise punt and return a default constant\n\t * estimate.  Note that calc_rangesel need not handle\n\t * OID_RANGE_ELEM_CONTAINED_OP.\n\t */\n\tif (constrange)\n\t\tselec = calc_rangesel(typcache, &vardata, constrange, operator);\n\telse\n\t\tselec = default_range_selectivity(operator);\n\n\tReleaseVariableStats(vardata);\n\n\tCLAMP_PROBABILITY(selec);\n\n\tPG_RETURN_FLOAT8((float8) selec);\n}"
  },
  {
    "function_name": "default_range_selectivity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/rangetypes_selfuncs.c",
    "lines": "64-100",
    "snippet": "static double\ndefault_range_selectivity(Oid operator)\n{\n\tswitch (operator)\n\t{\n\t\tcase OID_RANGE_OVERLAP_OP:\n\t\t\treturn 0.01;\n\n\t\tcase OID_RANGE_CONTAINS_OP:\n\t\tcase OID_RANGE_CONTAINED_OP:\n\t\t\treturn 0.005;\n\n\t\tcase OID_RANGE_CONTAINS_ELEM_OP:\n\t\tcase OID_RANGE_ELEM_CONTAINED_OP:\n\n\t\t\t/*\n\t\t\t * \"range @> elem\" is more or less identical to a scalar\n\t\t\t * inequality \"A >= b AND A <= c\".\n\t\t\t */\n\t\t\treturn DEFAULT_RANGE_INEQ_SEL;\n\n\t\tcase OID_RANGE_LESS_OP:\n\t\tcase OID_RANGE_LESS_EQUAL_OP:\n\t\tcase OID_RANGE_GREATER_OP:\n\t\tcase OID_RANGE_GREATER_EQUAL_OP:\n\t\tcase OID_RANGE_LEFT_OP:\n\t\tcase OID_RANGE_RIGHT_OP:\n\t\tcase OID_RANGE_OVERLAPS_LEFT_OP:\n\t\tcase OID_RANGE_OVERLAPS_RIGHT_OP:\n\t\t\t/* these are similar to regular scalar inequalities */\n\t\t\treturn DEFAULT_INEQ_SEL;\n\n\t\tdefault:\n\t\t\t/* all range operators should be handled above, but just in case */\n\t\t\treturn 0.01;\n\t}\n}",
    "includes": [
      "#include \"utils/typcache.h\"",
      "#include \"utils/selfuncs.h\"",
      "#include \"utils/rangetypes.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_statistic.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"access/htup_details.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static double calc_rangesel(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t  RangeType *constval, Oid operator);",
      "static double default_range_selectivity(Oid operator);",
      "static double calc_hist_selectivity(TypeCacheEntry *typcache,\n\t\t\t\t\t  VariableStatData *vardata, RangeType *constval,\n\t\t\t\t\t  Oid operator);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rangetypes.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_operator.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic double calc_rangesel(TypeCacheEntry *typcache, VariableStatData *vardata,\n\t\t\t  RangeType *constval, Oid operator);\nstatic double default_range_selectivity(Oid operator);\nstatic double calc_hist_selectivity(TypeCacheEntry *typcache,\n\t\t\t\t\t  VariableStatData *vardata, RangeType *constval,\n\t\t\t\t\t  Oid operator);\n\nstatic double\ndefault_range_selectivity(Oid operator)\n{\n\tswitch (operator)\n\t{\n\t\tcase OID_RANGE_OVERLAP_OP:\n\t\t\treturn 0.01;\n\n\t\tcase OID_RANGE_CONTAINS_OP:\n\t\tcase OID_RANGE_CONTAINED_OP:\n\t\t\treturn 0.005;\n\n\t\tcase OID_RANGE_CONTAINS_ELEM_OP:\n\t\tcase OID_RANGE_ELEM_CONTAINED_OP:\n\n\t\t\t/*\n\t\t\t * \"range @> elem\" is more or less identical to a scalar\n\t\t\t * inequality \"A >= b AND A <= c\".\n\t\t\t */\n\t\t\treturn DEFAULT_RANGE_INEQ_SEL;\n\n\t\tcase OID_RANGE_LESS_OP:\n\t\tcase OID_RANGE_LESS_EQUAL_OP:\n\t\tcase OID_RANGE_GREATER_OP:\n\t\tcase OID_RANGE_GREATER_EQUAL_OP:\n\t\tcase OID_RANGE_LEFT_OP:\n\t\tcase OID_RANGE_RIGHT_OP:\n\t\tcase OID_RANGE_OVERLAPS_LEFT_OP:\n\t\tcase OID_RANGE_OVERLAPS_RIGHT_OP:\n\t\t\t/* these are similar to regular scalar inequalities */\n\t\t\treturn DEFAULT_INEQ_SEL;\n\n\t\tdefault:\n\t\t\t/* all range operators should be handled above, but just in case */\n\t\t\treturn 0.01;\n\t}\n}"
  }
]