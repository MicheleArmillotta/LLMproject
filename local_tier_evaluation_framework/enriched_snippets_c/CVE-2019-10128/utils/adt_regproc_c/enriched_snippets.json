[
  {
    "function_name": "parseNameAndArgTypes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1734-1872",
    "snippet": "static void\nparseNameAndArgTypes(const char *string, bool allowNone, List **names,\n\t\t\t\t\t int *nargs, Oid *argtypes)\n{\n\tchar\t   *rawname;\n\tchar\t   *ptr;\n\tchar\t   *ptr2;\n\tchar\t   *typename;\n\tbool\t\tin_quote;\n\tbool\t\thad_comma;\n\tint\t\t\tparen_count;\n\tOid\t\t\ttypeid;\n\tint32\t\ttypmod;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\t/* Scan to find the expected left paren; mustn't be quoted */\n\tin_quote = false;\n\tfor (ptr = rawname; *ptr; ptr++)\n\t{\n\t\tif (*ptr == '\"')\n\t\t\tin_quote = !in_quote;\n\t\telse if (*ptr == '(' && !in_quote)\n\t\t\tbreak;\n\t}\n\tif (*ptr == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a left parenthesis\")));\n\n\t/* Separate the name and parse it into a list */\n\t*ptr++ = '\\0';\n\t*names = stringToQualifiedNameList(rawname);\n\n\t/* Check for the trailing right parenthesis and remove it */\n\tptr2 = ptr + strlen(ptr);\n\twhile (--ptr2 > ptr)\n\t{\n\t\tif (!scanner_isspace(*ptr2))\n\t\t\tbreak;\n\t}\n\tif (*ptr2 != ')')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a right parenthesis\")));\n\n\t*ptr2 = '\\0';\n\n\t/* Separate the remaining string into comma-separated type names */\n\t*nargs = 0;\n\thad_comma = false;\n\n\tfor (;;)\n\t{\n\t\t/* allow leading whitespace */\n\t\twhile (scanner_isspace(*ptr))\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t{\n\t\t\t/* End of string.  Okay unless we had a comma before. */\n\t\t\tif (had_comma)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"expected a type name\")));\n\t\t\tbreak;\n\t\t}\n\t\ttypename = ptr;\n\t\t/* Find end of type name --- end of string or comma */\n\t\t/* ... but not a quoted or parenthesized comma */\n\t\tin_quote = false;\n\t\tparen_count = 0;\n\t\tfor (; *ptr; ptr++)\n\t\t{\n\t\t\tif (*ptr == '\"')\n\t\t\t\tin_quote = !in_quote;\n\t\t\telse if (*ptr == ',' && !in_quote && paren_count == 0)\n\t\t\t\tbreak;\n\t\t\telse if (!in_quote)\n\t\t\t{\n\t\t\t\tswitch (*ptr)\n\t\t\t\t{\n\t\t\t\t\tcase '(':\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tparen_count++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ')':\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tparen_count--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (in_quote || paren_count != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"improper type name\")));\n\n\t\tptr2 = ptr;\n\t\tif (*ptr == ',')\n\t\t{\n\t\t\thad_comma = true;\n\t\t\t*ptr++ = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\thad_comma = false;\n\t\t\tAssert(*ptr == '\\0');\n\t\t}\n\t\t/* Lop off trailing whitespace */\n\t\twhile (--ptr2 >= typename)\n\t\t{\n\t\t\tif (!scanner_isspace(*ptr2))\n\t\t\t\tbreak;\n\t\t\t*ptr2 = '\\0';\n\t\t}\n\n\t\tif (allowNone && pg_strcasecmp(typename, \"none\") == 0)\n\t\t{\n\t\t\t/* Special case for NONE */\n\t\t\ttypeid = InvalidOid;\n\t\t\ttypmod = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Use full parser to resolve the type name */\n\t\t\tparseTypeString(typename, &typeid, &typmod, false);\n\t\t}\n\t\tif (*nargs >= FUNC_MAX_ARGS)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_ARGUMENTS),\n\t\t\t\t\t errmsg(\"too many arguments\")));\n\n\t\targtypes[*nargs] = typeid;\n\t\t(*nargs)++;\n\t}\n\n\tpfree(rawname);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void parseNameAndArgTypes(const char *string, bool allowNone,\n\t\t\t\t\t List **names, int *nargs, Oid *argtypes);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "rawname"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_TOO_MANY_ARGUMENTS),\n\t\t\t\t\t errmsg(\"too many arguments\"))"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"too many arguments\""
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_TOO_MANY_ARGUMENTS"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "parseTypeString",
          "args": [
            "typename",
            "&typeid",
            "&typmod",
            "false"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strcasecmp",
          "args": [
            "typename",
            "\"none\""
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_isspace",
          "args": [
            "*ptr2"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "*ptr == '\\0'"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"improper type name\"))"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"expected a type name\"))"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_isspace",
          "args": [
            "*ptr"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a right parenthesis\"))"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanner_isspace",
          "args": [
            "*ptr2"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptr"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stringToQualifiedNameList",
          "args": [
            "rawname"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "stringToQualifiedNameList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "1686-1718",
          "snippet": "List *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a left parenthesis\"))"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "string"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void parseNameAndArgTypes(const char *string, bool allowNone,\n\t\t\t\t\t List **names, int *nargs, Oid *argtypes);\n\nstatic void\nparseNameAndArgTypes(const char *string, bool allowNone, List **names,\n\t\t\t\t\t int *nargs, Oid *argtypes)\n{\n\tchar\t   *rawname;\n\tchar\t   *ptr;\n\tchar\t   *ptr2;\n\tchar\t   *typename;\n\tbool\t\tin_quote;\n\tbool\t\thad_comma;\n\tint\t\t\tparen_count;\n\tOid\t\t\ttypeid;\n\tint32\t\ttypmod;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\t/* Scan to find the expected left paren; mustn't be quoted */\n\tin_quote = false;\n\tfor (ptr = rawname; *ptr; ptr++)\n\t{\n\t\tif (*ptr == '\"')\n\t\t\tin_quote = !in_quote;\n\t\telse if (*ptr == '(' && !in_quote)\n\t\t\tbreak;\n\t}\n\tif (*ptr == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a left parenthesis\")));\n\n\t/* Separate the name and parse it into a list */\n\t*ptr++ = '\\0';\n\t*names = stringToQualifiedNameList(rawname);\n\n\t/* Check for the trailing right parenthesis and remove it */\n\tptr2 = ptr + strlen(ptr);\n\twhile (--ptr2 > ptr)\n\t{\n\t\tif (!scanner_isspace(*ptr2))\n\t\t\tbreak;\n\t}\n\tif (*ptr2 != ')')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a right parenthesis\")));\n\n\t*ptr2 = '\\0';\n\n\t/* Separate the remaining string into comma-separated type names */\n\t*nargs = 0;\n\thad_comma = false;\n\n\tfor (;;)\n\t{\n\t\t/* allow leading whitespace */\n\t\twhile (scanner_isspace(*ptr))\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t{\n\t\t\t/* End of string.  Okay unless we had a comma before. */\n\t\t\tif (had_comma)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"expected a type name\")));\n\t\t\tbreak;\n\t\t}\n\t\ttypename = ptr;\n\t\t/* Find end of type name --- end of string or comma */\n\t\t/* ... but not a quoted or parenthesized comma */\n\t\tin_quote = false;\n\t\tparen_count = 0;\n\t\tfor (; *ptr; ptr++)\n\t\t{\n\t\t\tif (*ptr == '\"')\n\t\t\t\tin_quote = !in_quote;\n\t\t\telse if (*ptr == ',' && !in_quote && paren_count == 0)\n\t\t\t\tbreak;\n\t\t\telse if (!in_quote)\n\t\t\t{\n\t\t\t\tswitch (*ptr)\n\t\t\t\t{\n\t\t\t\t\tcase '(':\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tparen_count++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ')':\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tparen_count--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (in_quote || paren_count != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"improper type name\")));\n\n\t\tptr2 = ptr;\n\t\tif (*ptr == ',')\n\t\t{\n\t\t\thad_comma = true;\n\t\t\t*ptr++ = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\thad_comma = false;\n\t\t\tAssert(*ptr == '\\0');\n\t\t}\n\t\t/* Lop off trailing whitespace */\n\t\twhile (--ptr2 >= typename)\n\t\t{\n\t\t\tif (!scanner_isspace(*ptr2))\n\t\t\t\tbreak;\n\t\t\t*ptr2 = '\\0';\n\t\t}\n\n\t\tif (allowNone && pg_strcasecmp(typename, \"none\") == 0)\n\t\t{\n\t\t\t/* Special case for NONE */\n\t\t\ttypeid = InvalidOid;\n\t\t\ttypmod = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Use full parser to resolve the type name */\n\t\t\tparseTypeString(typename, &typeid, &typmod, false);\n\t\t}\n\t\tif (*nargs >= FUNC_MAX_ARGS)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_ARGUMENTS),\n\t\t\t\t\t errmsg(\"too many arguments\")));\n\n\t\targtypes[*nargs] = typeid;\n\t\t(*nargs)++;\n\t}\n\n\tpfree(rawname);\n}"
  },
  {
    "function_name": "stringToQualifiedNameList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1686-1718",
    "snippet": "List *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_free",
          "args": [
            "namelist"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "rawname"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "result",
            "makeString(pstrdup(curname))"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeString",
          "args": [
            "pstrdup(curname)"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "makeStringAggState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4765-4787",
          "snippet": "static StringInfo\nmakeStringAggState(FunctionCallInfo fcinfo)\n{\n\tStringInfo\tstate;\n\tMemoryContext aggcontext;\n\tMemoryContext oldcontext;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"string_agg_transfn called in non-aggregate context\");\n\t}\n\n\t/*\n\t * Create state in aggregate context.  It'll stay there across subsequent\n\t * calls.\n\t */\n\toldcontext = MemoryContextSwitchTo(aggcontext);\n\tstate = makeStringInfo();\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\n\nstatic StringInfo\nmakeStringAggState(FunctionCallInfo fcinfo)\n{\n\tStringInfo\tstate;\n\tMemoryContext aggcontext;\n\tMemoryContext oldcontext;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"string_agg_transfn called in non-aggregate context\");\n\t}\n\n\t/*\n\t * Create state in aggregate context.  It'll stay there across subsequent\n\t * calls.\n\t */\n\toldcontext = MemoryContextSwitchTo(aggcontext);\n\tstate = makeStringInfo();\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "curname"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lfirst",
          "args": [
            "l"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "foreach",
          "args": [
            "l",
            "namelist"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\"))"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid name syntax\""
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_NAME"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\"))"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SplitIdentifierString",
          "args": [
            "rawname",
            "'.'",
            "&namelist"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "SplitIdentifierString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "3289-3388",
          "snippet": "bool\nSplitIdentifierString(char *rawstring, char separator,\n\t\t\t\t\t  List **namelist)\n{\n\tchar\t   *nextp = rawstring;\n\tbool\t\tdone = false;\n\n\t*namelist = NIL;\n\n\twhile (scanner_isspace(*nextp))\n\t\tnextp++;\t\t\t\t/* skip leading whitespace */\n\n\tif (*nextp == '\\0')\n\t\treturn true;\t\t\t/* allow empty string */\n\n\t/* At the top of the loop, we are at start of a new identifier. */\n\tdo\n\t{\n\t\tchar\t   *curname;\n\t\tchar\t   *endp;\n\n\t\tif (*nextp == '\"')\n\t\t{\n\t\t\t/* Quoted name --- collapse quote-quote pairs, no downcasing */\n\t\t\tcurname = nextp + 1;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tendp = strchr(nextp + 1, '\"');\n\t\t\t\tif (endp == NULL)\n\t\t\t\t\treturn false;\t/* mismatched quotes */\n\t\t\t\tif (endp[1] != '\"')\n\t\t\t\t\tbreak;\t\t/* found end of quoted name */\n\t\t\t\t/* Collapse adjacent quotes into one quote, and look again */\n\t\t\t\tmemmove(endp, endp + 1, strlen(endp));\n\t\t\t\tnextp = endp;\n\t\t\t}\n\t\t\t/* endp now points at the terminating quote */\n\t\t\tnextp = endp + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Unquoted name --- extends to separator or whitespace */\n\t\t\tchar\t   *downname;\n\t\t\tint\t\t\tlen;\n\n\t\t\tcurname = nextp;\n\t\t\twhile (*nextp && *nextp != separator &&\n\t\t\t\t   !scanner_isspace(*nextp))\n\t\t\t\tnextp++;\n\t\t\tendp = nextp;\n\t\t\tif (curname == nextp)\n\t\t\t\treturn false;\t/* empty unquoted name not allowed */\n\n\t\t\t/*\n\t\t\t * Downcase the identifier, using same code as main lexer does.\n\t\t\t *\n\t\t\t * XXX because we want to overwrite the input in-place, we cannot\n\t\t\t * support a downcasing transformation that increases the string\n\t\t\t * length.  This is not a problem given the current implementation\n\t\t\t * of downcase_truncate_identifier, but we'll probably have to do\n\t\t\t * something about this someday.\n\t\t\t */\n\t\t\tlen = endp - curname;\n\t\t\tdownname = downcase_truncate_identifier(curname, len, false);\n\t\t\tAssert(strlen(downname) <= len);\n\t\t\tstrncpy(curname, downname, len);\t/* strncpy is required here */\n\t\t\tpfree(downname);\n\t\t}\n\n\t\twhile (scanner_isspace(*nextp))\n\t\t\tnextp++;\t\t\t/* skip trailing whitespace */\n\n\t\tif (*nextp == separator)\n\t\t{\n\t\t\tnextp++;\n\t\t\twhile (scanner_isspace(*nextp))\n\t\t\t\tnextp++;\t\t/* skip leading whitespace for next */\n\t\t\t/* we expect another name, so done remains false */\n\t\t}\n\t\telse if (*nextp == '\\0')\n\t\t\tdone = true;\n\t\telse\n\t\t\treturn false;\t\t/* invalid syntax */\n\n\t\t/* Now safe to overwrite separator with a null */\n\t\t*endp = '\\0';\n\n\t\t/* Truncate name if it's overlength */\n\t\ttruncate_identifier(curname, strlen(curname), false);\n\n\t\t/*\n\t\t * Finished isolating current name --- add it to list\n\t\t */\n\t\t*namelist = lappend(*namelist, curname);\n\n\t\t/* Loop back if we didn't reach end of string */\n\t} while (!done);\n\n\treturn true;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nbool\nSplitIdentifierString(char *rawstring, char separator,\n\t\t\t\t\t  List **namelist)\n{\n\tchar\t   *nextp = rawstring;\n\tbool\t\tdone = false;\n\n\t*namelist = NIL;\n\n\twhile (scanner_isspace(*nextp))\n\t\tnextp++;\t\t\t\t/* skip leading whitespace */\n\n\tif (*nextp == '\\0')\n\t\treturn true;\t\t\t/* allow empty string */\n\n\t/* At the top of the loop, we are at start of a new identifier. */\n\tdo\n\t{\n\t\tchar\t   *curname;\n\t\tchar\t   *endp;\n\n\t\tif (*nextp == '\"')\n\t\t{\n\t\t\t/* Quoted name --- collapse quote-quote pairs, no downcasing */\n\t\t\tcurname = nextp + 1;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\tendp = strchr(nextp + 1, '\"');\n\t\t\t\tif (endp == NULL)\n\t\t\t\t\treturn false;\t/* mismatched quotes */\n\t\t\t\tif (endp[1] != '\"')\n\t\t\t\t\tbreak;\t\t/* found end of quoted name */\n\t\t\t\t/* Collapse adjacent quotes into one quote, and look again */\n\t\t\t\tmemmove(endp, endp + 1, strlen(endp));\n\t\t\t\tnextp = endp;\n\t\t\t}\n\t\t\t/* endp now points at the terminating quote */\n\t\t\tnextp = endp + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Unquoted name --- extends to separator or whitespace */\n\t\t\tchar\t   *downname;\n\t\t\tint\t\t\tlen;\n\n\t\t\tcurname = nextp;\n\t\t\twhile (*nextp && *nextp != separator &&\n\t\t\t\t   !scanner_isspace(*nextp))\n\t\t\t\tnextp++;\n\t\t\tendp = nextp;\n\t\t\tif (curname == nextp)\n\t\t\t\treturn false;\t/* empty unquoted name not allowed */\n\n\t\t\t/*\n\t\t\t * Downcase the identifier, using same code as main lexer does.\n\t\t\t *\n\t\t\t * XXX because we want to overwrite the input in-place, we cannot\n\t\t\t * support a downcasing transformation that increases the string\n\t\t\t * length.  This is not a problem given the current implementation\n\t\t\t * of downcase_truncate_identifier, but we'll probably have to do\n\t\t\t * something about this someday.\n\t\t\t */\n\t\t\tlen = endp - curname;\n\t\t\tdownname = downcase_truncate_identifier(curname, len, false);\n\t\t\tAssert(strlen(downname) <= len);\n\t\t\tstrncpy(curname, downname, len);\t/* strncpy is required here */\n\t\t\tpfree(downname);\n\t\t}\n\n\t\twhile (scanner_isspace(*nextp))\n\t\t\tnextp++;\t\t\t/* skip trailing whitespace */\n\n\t\tif (*nextp == separator)\n\t\t{\n\t\t\tnextp++;\n\t\t\twhile (scanner_isspace(*nextp))\n\t\t\t\tnextp++;\t\t/* skip leading whitespace for next */\n\t\t\t/* we expect another name, so done remains false */\n\t\t}\n\t\telse if (*nextp == '\\0')\n\t\t\tdone = true;\n\t\telse\n\t\t\treturn false;\t\t/* invalid syntax */\n\n\t\t/* Now safe to overwrite separator with a null */\n\t\t*endp = '\\0';\n\n\t\t/* Truncate name if it's overlength */\n\t\ttruncate_identifier(curname, strlen(curname), false);\n\n\t\t/*\n\t\t * Finished isolating current name --- add it to list\n\t\t */\n\t\t*namelist = lappend(*namelist, curname);\n\n\t\t/* Loop back if we didn't reach end of string */\n\t} while (!done);\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}"
  },
  {
    "function_name": "text_regclass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1667-1680",
    "snippet": "Datum\ntext_regclass(PG_FUNCTION_ARGS)\n{\n\ttext\t   *relname = PG_GETARG_TEXT_PP(0);\n\tOid\t\t\tresult;\n\tRangeVar   *rv;\n\n\trv = makeRangeVarFromNameList(textToQualifiedNameList(relname));\n\n\t/* We might not even have permissions on this relation; don't lock it. */\n\tresult = RangeVarGetRelid(rv, NoLock, false);\n\n\tPG_RETURN_OID(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeVarGetRelid",
          "args": [
            "rv",
            "NoLock",
            "false"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeRangeVarFromNameList",
          "args": [
            "textToQualifiedNameList(relname)"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "textToQualifiedNameList",
          "args": [
            "relname"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "textToQualifiedNameList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "3231-3264",
          "snippet": "List *\ntextToQualifiedNameList(text *textval)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* Convert to C string (handles possible detoasting). */\n\t/* Note we rely on being able to modify rawname below. */\n\trawname = text_to_cstring(textval);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\ntextToQualifiedNameList(text *textval)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* Convert to C string (handles possible detoasting). */\n\t/* Note we rely on being able to modify rawname below. */\n\trawname = text_to_cstring(textval);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\ntext_regclass(PG_FUNCTION_ARGS)\n{\n\ttext\t   *relname = PG_GETARG_TEXT_PP(0);\n\tOid\t\t\tresult;\n\tRangeVar   *rv;\n\n\trv = makeRangeVarFromNameList(textToQualifiedNameList(relname));\n\n\t/* We might not even have permissions on this relation; don't lock it. */\n\tresult = RangeVarGetRelid(rv, NoLock, false);\n\n\tPG_RETURN_OID(result);\n}"
  },
  {
    "function_name": "regnamespacesend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1653-1658",
    "snippet": "Datum\nregnamespacesend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidsend, so share code */\n\treturn oidsend(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oidsend",
          "args": [
            "fcinfo"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "oidsend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "150-159",
          "snippet": "Datum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregnamespacesend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidsend, so share code */\n\treturn oidsend(fcinfo);\n}"
  },
  {
    "function_name": "regnamespacerecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1643-1648",
    "snippet": "Datum\nregnamespacerecv(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidrecv, so share code */\n\treturn oidrecv(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oidrecv",
          "args": [
            "fcinfo"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "oidrecv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "139-145",
          "snippet": "Datum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregnamespacerecv(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidrecv, so share code */\n\treturn oidrecv(fcinfo);\n}"
  },
  {
    "function_name": "regnamespaceout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1611-1638",
    "snippet": "Datum\nregnamespaceout(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tnspid = PG_GETARG_OID(0);\n\tchar\t   *result;\n\n\tif (nspid == InvalidOid)\n\t{\n\t\tresult = pstrdup(\"-\");\n\t\tPG_RETURN_CSTRING(result);\n\t}\n\n\tresult = get_namespace_name(nspid);\n\n\tif (result)\n\t{\n\t\t/* pstrdup is not really necessary, but it avoids a compiler warning */\n\t\tresult = pstrdup(quote_identifier(result));\n\t}\n\telse\n\t{\n\t\t/* If OID doesn't match any namespace, return it numerically */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", nspid);\n\t}\n\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "NAMEDATALEN",
            "\"%u\"",
            "nspid"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "NAMEDATALEN"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "quote_identifier(result)"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "quote_identifier",
          "args": [
            "result"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "quote_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "10550-10628",
          "snippet": "const char *\nquote_identifier(const char *ident)\n{\n\t/*\n\t * Can avoid quoting if ident starts with a lowercase letter or underscore\n\t * and contains only lowercase letters, digits, and underscores, *and* is\n\t * not any SQL keyword.  Otherwise, supply quotes.\n\t */\n\tint\t\t\tnquotes = 0;\n\tbool\t\tsafe;\n\tconst char *ptr;\n\tchar\t   *result;\n\tchar\t   *optr;\n\n\t/*\n\t * would like to use <ctype.h> macros here, but they might yield unwanted\n\t * locale-specific results...\n\t */\n\tsafe = ((ident[0] >= 'a' && ident[0] <= 'z') || ident[0] == '_');\n\n\tfor (ptr = ident; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif ((ch >= 'a' && ch <= 'z') ||\n\t\t\t(ch >= '0' && ch <= '9') ||\n\t\t\t(ch == '_'))\n\t\t{\n\t\t\t/* okay */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsafe = false;\n\t\t\tif (ch == '\"')\n\t\t\t\tnquotes++;\n\t\t}\n\t}\n\n\tif (quote_all_identifiers)\n\t\tsafe = false;\n\n\tif (safe)\n\t{\n\t\t/*\n\t\t * Check for keyword.  We quote keywords except for unreserved ones.\n\t\t * (In some cases we could avoid quoting a col_name or type_func_name\n\t\t * keyword, but it seems much harder than it's worth to tell that.)\n\t\t *\n\t\t * Note: ScanKeywordLookup() does case-insensitive comparison, but\n\t\t * that's fine, since we already know we have all-lower-case.\n\t\t */\n\t\tconst ScanKeyword *keyword = ScanKeywordLookup(ident,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ScanKeywords,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   NumScanKeywords);\n\n\t\tif (keyword != NULL && keyword->category != UNRESERVED_KEYWORD)\n\t\t\tsafe = false;\n\t}\n\n\tif (safe)\n\t\treturn ident;\t\t\t/* no change needed */\n\n\tresult = (char *) palloc(strlen(ident) + nquotes + 2 + 1);\n\n\toptr = result;\n\t*optr++ = '\"';\n\tfor (ptr = ident; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif (ch == '\"')\n\t\t\t*optr++ = '\"';\n\t\t*optr++ = ch;\n\t}\n\t*optr++ = '\"';\n\t*optr = '\\0';\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool\t\tquote_all_identifiers = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\t\tquote_all_identifiers = false;\n\nconst char *\nquote_identifier(const char *ident)\n{\n\t/*\n\t * Can avoid quoting if ident starts with a lowercase letter or underscore\n\t * and contains only lowercase letters, digits, and underscores, *and* is\n\t * not any SQL keyword.  Otherwise, supply quotes.\n\t */\n\tint\t\t\tnquotes = 0;\n\tbool\t\tsafe;\n\tconst char *ptr;\n\tchar\t   *result;\n\tchar\t   *optr;\n\n\t/*\n\t * would like to use <ctype.h> macros here, but they might yield unwanted\n\t * locale-specific results...\n\t */\n\tsafe = ((ident[0] >= 'a' && ident[0] <= 'z') || ident[0] == '_');\n\n\tfor (ptr = ident; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif ((ch >= 'a' && ch <= 'z') ||\n\t\t\t(ch >= '0' && ch <= '9') ||\n\t\t\t(ch == '_'))\n\t\t{\n\t\t\t/* okay */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsafe = false;\n\t\t\tif (ch == '\"')\n\t\t\t\tnquotes++;\n\t\t}\n\t}\n\n\tif (quote_all_identifiers)\n\t\tsafe = false;\n\n\tif (safe)\n\t{\n\t\t/*\n\t\t * Check for keyword.  We quote keywords except for unreserved ones.\n\t\t * (In some cases we could avoid quoting a col_name or type_func_name\n\t\t * keyword, but it seems much harder than it's worth to tell that.)\n\t\t *\n\t\t * Note: ScanKeywordLookup() does case-insensitive comparison, but\n\t\t * that's fine, since we already know we have all-lower-case.\n\t\t */\n\t\tconst ScanKeyword *keyword = ScanKeywordLookup(ident,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ScanKeywords,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   NumScanKeywords);\n\n\t\tif (keyword != NULL && keyword->category != UNRESERVED_KEYWORD)\n\t\t\tsafe = false;\n\t}\n\n\tif (safe)\n\t\treturn ident;\t\t\t/* no change needed */\n\n\tresult = (char *) palloc(strlen(ident) + nquotes + 2 + 1);\n\n\toptr = result;\n\t*optr++ = '\"';\n\tfor (ptr = ident; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif (ch == '\"')\n\t\t\t*optr++ = '\"';\n\t\t*optr++ = ch;\n\t}\n\t*optr++ = '\"';\n\t*optr = '\\0';\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_namespace_name",
          "args": [
            "nspid"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregnamespaceout(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tnspid = PG_GETARG_OID(0);\n\tchar\t   *result;\n\n\tif (nspid == InvalidOid)\n\t{\n\t\tresult = pstrdup(\"-\");\n\t\tPG_RETURN_CSTRING(result);\n\t}\n\n\tresult = get_namespace_name(nspid);\n\n\tif (result)\n\t{\n\t\t/* pstrdup is not really necessary, but it avoids a compiler warning */\n\t\tresult = pstrdup(quote_identifier(result));\n\t}\n\telse\n\t{\n\t\t/* If OID doesn't match any namespace, return it numerically */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", nspid);\n\t}\n\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "to_regnamespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1586-1606",
    "snippet": "Datum\nto_regnamespace(PG_FUNCTION_ARGS)\n{\n\tchar\t   *nsp_name = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tOid\t\t\tresult;\n\tList\t   *names;\n\n\tnames = stringToQualifiedNameList(nsp_name);\n\n\tif (list_length(names) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tresult = get_namespace_oid(strVal(linitial(names)), true);\n\n\tif (OidIsValid(result))\n\t\tPG_RETURN_OID(result);\n\telse\n\t\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "result"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_namespace_oid",
          "args": [
            "strVal(linitial(names))",
            "true"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strVal",
          "args": [
            "linitial(names)"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial",
          "args": [
            "names"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\"))"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid name syntax\""
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_NAME"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "names"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringToQualifiedNameList",
          "args": [
            "nsp_name"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "stringToQualifiedNameList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "1686-1718",
          "snippet": "List *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(0)"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nto_regnamespace(PG_FUNCTION_ARGS)\n{\n\tchar\t   *nsp_name = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tOid\t\t\tresult;\n\tList\t   *names;\n\n\tnames = stringToQualifiedNameList(nsp_name);\n\n\tif (list_length(names) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tresult = get_namespace_oid(strVal(linitial(names)), true);\n\n\tif (OidIsValid(result))\n\t\tPG_RETURN_OID(result);\n\telse\n\t\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "regnamespacein",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1543-1579",
    "snippet": "Datum\nregnamespacein(PG_FUNCTION_ARGS)\n{\n\tchar\t   *nsp_name_or_oid = PG_GETARG_CSTRING(0);\n\tOid\t\t\tresult;\n\tList\t   *names;\n\n\t/* '-' ? */\n\tif (strcmp(nsp_name_or_oid, \"-\") == 0)\n\t\tPG_RETURN_OID(InvalidOid);\n\n\t/* Numeric OID? */\n\tif (nsp_name_or_oid[0] >= '0' &&\n\t\tnsp_name_or_oid[0] <= '9' &&\n\t\tstrspn(nsp_name_or_oid, \"0123456789\") == strlen(nsp_name_or_oid))\n\t{\n\t\tresult = DatumGetObjectId(DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(nsp_name_or_oid)));\n\t\tPG_RETURN_OID(result);\n\t}\n\n\t/* The rest of this wouldn't work in bootstrap mode */\n\tif (IsBootstrapProcessingMode())\n\t\telog(ERROR, \"regnamespace values must be OIDs in bootstrap mode\");\n\n\t/* Normal case: see if the name matches any pg_namespace entry. */\n\tnames = stringToQualifiedNameList(nsp_name_or_oid);\n\n\tif (list_length(names) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tresult = get_namespace_oid(strVal(linitial(names)), false);\n\n\tPG_RETURN_OID(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_namespace_oid",
          "args": [
            "strVal(linitial(names))",
            "false"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strVal",
          "args": [
            "linitial(names)"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial",
          "args": [
            "names"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\"))"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid name syntax\""
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_NAME"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "names"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringToQualifiedNameList",
          "args": [
            "nsp_name_or_oid"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "stringToQualifiedNameList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "1686-1718",
          "snippet": "List *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"regnamespace values must be OIDs in bootstrap mode\""
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetObjectId",
          "args": [
            "DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(nsp_name_or_oid))"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "oidin",
            "CStringGetDatum(nsp_name_or_oid)"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "nsp_name_or_oid"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nsp_name_or_oid"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "nsp_name_or_oid",
            "\"0123456789\""
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "InvalidOid"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "nsp_name_or_oid",
            "\"-\""
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregnamespacein(PG_FUNCTION_ARGS)\n{\n\tchar\t   *nsp_name_or_oid = PG_GETARG_CSTRING(0);\n\tOid\t\t\tresult;\n\tList\t   *names;\n\n\t/* '-' ? */\n\tif (strcmp(nsp_name_or_oid, \"-\") == 0)\n\t\tPG_RETURN_OID(InvalidOid);\n\n\t/* Numeric OID? */\n\tif (nsp_name_or_oid[0] >= '0' &&\n\t\tnsp_name_or_oid[0] <= '9' &&\n\t\tstrspn(nsp_name_or_oid, \"0123456789\") == strlen(nsp_name_or_oid))\n\t{\n\t\tresult = DatumGetObjectId(DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(nsp_name_or_oid)));\n\t\tPG_RETURN_OID(result);\n\t}\n\n\t/* The rest of this wouldn't work in bootstrap mode */\n\tif (IsBootstrapProcessingMode())\n\t\telog(ERROR, \"regnamespace values must be OIDs in bootstrap mode\");\n\n\t/* Normal case: see if the name matches any pg_namespace entry. */\n\tnames = stringToQualifiedNameList(nsp_name_or_oid);\n\n\tif (list_length(names) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tresult = get_namespace_oid(strVal(linitial(names)), false);\n\n\tPG_RETURN_OID(result);\n}"
  },
  {
    "function_name": "regrolesend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1528-1533",
    "snippet": "Datum\nregrolesend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidsend, so share code */\n\treturn oidsend(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oidsend",
          "args": [
            "fcinfo"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "oidsend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "150-159",
          "snippet": "Datum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregrolesend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidsend, so share code */\n\treturn oidsend(fcinfo);\n}"
  },
  {
    "function_name": "regrolerecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1518-1523",
    "snippet": "Datum\nregrolerecv(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidrecv, so share code */\n\treturn oidrecv(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oidrecv",
          "args": [
            "fcinfo"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "oidrecv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "139-145",
          "snippet": "Datum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregrolerecv(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidrecv, so share code */\n\treturn oidrecv(fcinfo);\n}"
  },
  {
    "function_name": "regroleout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1486-1513",
    "snippet": "Datum\nregroleout(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\troleoid = PG_GETARG_OID(0);\n\tchar\t   *result;\n\n\tif (roleoid == InvalidOid)\n\t{\n\t\tresult = pstrdup(\"-\");\n\t\tPG_RETURN_CSTRING(result);\n\t}\n\n\tresult = GetUserNameFromId(roleoid, true);\n\n\tif (result)\n\t{\n\t\t/* pstrdup is not really necessary, but it avoids a compiler warning */\n\t\tresult = pstrdup(quote_identifier(result));\n\t}\n\telse\n\t{\n\t\t/* If OID doesn't match any role, return it numerically */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", roleoid);\n\t}\n\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "NAMEDATALEN",
            "\"%u\"",
            "roleoid"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "NAMEDATALEN"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "quote_identifier(result)"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "quote_identifier",
          "args": [
            "result"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "quote_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "10550-10628",
          "snippet": "const char *\nquote_identifier(const char *ident)\n{\n\t/*\n\t * Can avoid quoting if ident starts with a lowercase letter or underscore\n\t * and contains only lowercase letters, digits, and underscores, *and* is\n\t * not any SQL keyword.  Otherwise, supply quotes.\n\t */\n\tint\t\t\tnquotes = 0;\n\tbool\t\tsafe;\n\tconst char *ptr;\n\tchar\t   *result;\n\tchar\t   *optr;\n\n\t/*\n\t * would like to use <ctype.h> macros here, but they might yield unwanted\n\t * locale-specific results...\n\t */\n\tsafe = ((ident[0] >= 'a' && ident[0] <= 'z') || ident[0] == '_');\n\n\tfor (ptr = ident; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif ((ch >= 'a' && ch <= 'z') ||\n\t\t\t(ch >= '0' && ch <= '9') ||\n\t\t\t(ch == '_'))\n\t\t{\n\t\t\t/* okay */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsafe = false;\n\t\t\tif (ch == '\"')\n\t\t\t\tnquotes++;\n\t\t}\n\t}\n\n\tif (quote_all_identifiers)\n\t\tsafe = false;\n\n\tif (safe)\n\t{\n\t\t/*\n\t\t * Check for keyword.  We quote keywords except for unreserved ones.\n\t\t * (In some cases we could avoid quoting a col_name or type_func_name\n\t\t * keyword, but it seems much harder than it's worth to tell that.)\n\t\t *\n\t\t * Note: ScanKeywordLookup() does case-insensitive comparison, but\n\t\t * that's fine, since we already know we have all-lower-case.\n\t\t */\n\t\tconst ScanKeyword *keyword = ScanKeywordLookup(ident,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ScanKeywords,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   NumScanKeywords);\n\n\t\tif (keyword != NULL && keyword->category != UNRESERVED_KEYWORD)\n\t\t\tsafe = false;\n\t}\n\n\tif (safe)\n\t\treturn ident;\t\t\t/* no change needed */\n\n\tresult = (char *) palloc(strlen(ident) + nquotes + 2 + 1);\n\n\toptr = result;\n\t*optr++ = '\"';\n\tfor (ptr = ident; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif (ch == '\"')\n\t\t\t*optr++ = '\"';\n\t\t*optr++ = ch;\n\t}\n\t*optr++ = '\"';\n\t*optr = '\\0';\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool\t\tquote_all_identifiers = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\t\tquote_all_identifiers = false;\n\nconst char *\nquote_identifier(const char *ident)\n{\n\t/*\n\t * Can avoid quoting if ident starts with a lowercase letter or underscore\n\t * and contains only lowercase letters, digits, and underscores, *and* is\n\t * not any SQL keyword.  Otherwise, supply quotes.\n\t */\n\tint\t\t\tnquotes = 0;\n\tbool\t\tsafe;\n\tconst char *ptr;\n\tchar\t   *result;\n\tchar\t   *optr;\n\n\t/*\n\t * would like to use <ctype.h> macros here, but they might yield unwanted\n\t * locale-specific results...\n\t */\n\tsafe = ((ident[0] >= 'a' && ident[0] <= 'z') || ident[0] == '_');\n\n\tfor (ptr = ident; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif ((ch >= 'a' && ch <= 'z') ||\n\t\t\t(ch >= '0' && ch <= '9') ||\n\t\t\t(ch == '_'))\n\t\t{\n\t\t\t/* okay */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsafe = false;\n\t\t\tif (ch == '\"')\n\t\t\t\tnquotes++;\n\t\t}\n\t}\n\n\tif (quote_all_identifiers)\n\t\tsafe = false;\n\n\tif (safe)\n\t{\n\t\t/*\n\t\t * Check for keyword.  We quote keywords except for unreserved ones.\n\t\t * (In some cases we could avoid quoting a col_name or type_func_name\n\t\t * keyword, but it seems much harder than it's worth to tell that.)\n\t\t *\n\t\t * Note: ScanKeywordLookup() does case-insensitive comparison, but\n\t\t * that's fine, since we already know we have all-lower-case.\n\t\t */\n\t\tconst ScanKeyword *keyword = ScanKeywordLookup(ident,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ScanKeywords,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   NumScanKeywords);\n\n\t\tif (keyword != NULL && keyword->category != UNRESERVED_KEYWORD)\n\t\t\tsafe = false;\n\t}\n\n\tif (safe)\n\t\treturn ident;\t\t\t/* no change needed */\n\n\tresult = (char *) palloc(strlen(ident) + nquotes + 2 + 1);\n\n\toptr = result;\n\t*optr++ = '\"';\n\tfor (ptr = ident; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif (ch == '\"')\n\t\t\t*optr++ = '\"';\n\t\t*optr++ = ch;\n\t}\n\t*optr++ = '\"';\n\t*optr = '\\0';\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetUserNameFromId",
          "args": [
            "roleoid",
            "true"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "GetUserNameFromId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/init/miscinit.c",
          "lines": "794-815",
          "snippet": "char *\nGetUserNameFromId(Oid roleid, bool noerr)\n{\n\tHeapTuple\ttuple;\n\tchar\t   *result;\n\n\ttuple = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));\n\tif (!HeapTupleIsValid(tuple))\n\t{\n\t\tif (!noerr)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"invalid role OID: %u\", roleid)));\n\t\tresult = NULL;\n\t}\n\telse\n\t{\n\t\tresult = pstrdup(NameStr(((Form_pg_authid) GETSTRUCT(tuple))->rolname));\n\t\tReleaseSysCache(tuple);\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/pidfile.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"storage/procarray.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/latch.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"storage/fd.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"common/file_perm.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"access/htup_details.h\"",
            "#include <utime.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <pwd.h>",
            "#include <grp.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/file.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <sys/param.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/pidfile.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"utils/builtins.h\"\n#include \"storage/procarray.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/latch.h\"\n#include \"storage/ipc.h\"\n#include \"storage/fd.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/libpq.h\"\n#include \"common/file_perm.h\"\n#include \"catalog/pg_authid.h\"\n#include \"access/htup_details.h\"\n#include <utime.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <time.h>\n#include <signal.h>\n#include <sys/param.h>\n#include \"postgres.h\"\n\nchar *\nGetUserNameFromId(Oid roleid, bool noerr)\n{\n\tHeapTuple\ttuple;\n\tchar\t   *result;\n\n\ttuple = SearchSysCache1(AUTHOID, ObjectIdGetDatum(roleid));\n\tif (!HeapTupleIsValid(tuple))\n\t{\n\t\tif (!noerr)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t\t errmsg(\"invalid role OID: %u\", roleid)));\n\t\tresult = NULL;\n\t}\n\telse\n\t{\n\t\tresult = pstrdup(NameStr(((Form_pg_authid) GETSTRUCT(tuple))->rolname));\n\t\tReleaseSysCache(tuple);\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregroleout(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\troleoid = PG_GETARG_OID(0);\n\tchar\t   *result;\n\n\tif (roleoid == InvalidOid)\n\t{\n\t\tresult = pstrdup(\"-\");\n\t\tPG_RETURN_CSTRING(result);\n\t}\n\n\tresult = GetUserNameFromId(roleoid, true);\n\n\tif (result)\n\t{\n\t\t/* pstrdup is not really necessary, but it avoids a compiler warning */\n\t\tresult = pstrdup(quote_identifier(result));\n\t}\n\telse\n\t{\n\t\t/* If OID doesn't match any role, return it numerically */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", roleoid);\n\t}\n\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "to_regrole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1461-1481",
    "snippet": "Datum\nto_regrole(PG_FUNCTION_ARGS)\n{\n\tchar\t   *role_name = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tOid\t\t\tresult;\n\tList\t   *names;\n\n\tnames = stringToQualifiedNameList(role_name);\n\n\tif (list_length(names) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tresult = get_role_oid(strVal(linitial(names)), true);\n\n\tif (OidIsValid(result))\n\t\tPG_RETURN_OID(result);\n\telse\n\t\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "result"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_role_oid",
          "args": [
            "strVal(linitial(names))",
            "true"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "get_role_oid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/acl.c",
          "lines": "5190-5201",
          "snippet": "Oid\nget_role_oid(const char *rolname, bool missing_ok)\n{\n\tOid\t\t\toid;\n\n\toid = GetSysCacheOid1(AUTHNAME, CStringGetDatum(rolname));\n\tif (!OidIsValid(oid) && !missing_ok)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"role \\\"%s\\\" does not exist\", rolname)));\n\treturn oid;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"foreign/foreign.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/proclang.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void putid(char *p, const char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"foreign/foreign.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/proclang.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void putid(char *p, const char *s);\n\nOid\nget_role_oid(const char *rolname, bool missing_ok)\n{\n\tOid\t\t\toid;\n\n\toid = GetSysCacheOid1(AUTHNAME, CStringGetDatum(rolname));\n\tif (!OidIsValid(oid) && !missing_ok)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"role \\\"%s\\\" does not exist\", rolname)));\n\treturn oid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strVal",
          "args": [
            "linitial(names)"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial",
          "args": [
            "names"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\"))"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid name syntax\""
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_NAME"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "names"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringToQualifiedNameList",
          "args": [
            "role_name"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "stringToQualifiedNameList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "1686-1718",
          "snippet": "List *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(0)"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nto_regrole(PG_FUNCTION_ARGS)\n{\n\tchar\t   *role_name = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tOid\t\t\tresult;\n\tList\t   *names;\n\n\tnames = stringToQualifiedNameList(role_name);\n\n\tif (list_length(names) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tresult = get_role_oid(strVal(linitial(names)), true);\n\n\tif (OidIsValid(result))\n\t\tPG_RETURN_OID(result);\n\telse\n\t\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "regrolein",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1418-1454",
    "snippet": "Datum\nregrolein(PG_FUNCTION_ARGS)\n{\n\tchar\t   *role_name_or_oid = PG_GETARG_CSTRING(0);\n\tOid\t\t\tresult;\n\tList\t   *names;\n\n\t/* '-' ? */\n\tif (strcmp(role_name_or_oid, \"-\") == 0)\n\t\tPG_RETURN_OID(InvalidOid);\n\n\t/* Numeric OID? */\n\tif (role_name_or_oid[0] >= '0' &&\n\t\trole_name_or_oid[0] <= '9' &&\n\t\tstrspn(role_name_or_oid, \"0123456789\") == strlen(role_name_or_oid))\n\t{\n\t\tresult = DatumGetObjectId(DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(role_name_or_oid)));\n\t\tPG_RETURN_OID(result);\n\t}\n\n\t/* The rest of this wouldn't work in bootstrap mode */\n\tif (IsBootstrapProcessingMode())\n\t\telog(ERROR, \"regrole values must be OIDs in bootstrap mode\");\n\n\t/* Normal case: see if the name matches any pg_authid entry. */\n\tnames = stringToQualifiedNameList(role_name_or_oid);\n\n\tif (list_length(names) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tresult = get_role_oid(strVal(linitial(names)), false);\n\n\tPG_RETURN_OID(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_role_oid",
          "args": [
            "strVal(linitial(names))",
            "false"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "get_role_oid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/acl.c",
          "lines": "5190-5201",
          "snippet": "Oid\nget_role_oid(const char *rolname, bool missing_ok)\n{\n\tOid\t\t\toid;\n\n\toid = GetSysCacheOid1(AUTHNAME, CStringGetDatum(rolname));\n\tif (!OidIsValid(oid) && !missing_ok)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"role \\\"%s\\\" does not exist\", rolname)));\n\treturn oid;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/inval.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"foreign/foreign.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/proclang.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void putid(char *p, const char *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/inval.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"foreign/foreign.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/proclang.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void putid(char *p, const char *s);\n\nOid\nget_role_oid(const char *rolname, bool missing_ok)\n{\n\tOid\t\t\toid;\n\n\toid = GetSysCacheOid1(AUTHNAME, CStringGetDatum(rolname));\n\tif (!OidIsValid(oid) && !missing_ok)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_OBJECT),\n\t\t\t\t errmsg(\"role \\\"%s\\\" does not exist\", rolname)));\n\treturn oid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strVal",
          "args": [
            "linitial(names)"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linitial",
          "args": [
            "names"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\"))"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"invalid name syntax\""
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_NAME"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "names"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringToQualifiedNameList",
          "args": [
            "role_name_or_oid"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "stringToQualifiedNameList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "1686-1718",
          "snippet": "List *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"regrole values must be OIDs in bootstrap mode\""
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetObjectId",
          "args": [
            "DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(role_name_or_oid))"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "oidin",
            "CStringGetDatum(role_name_or_oid)"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "role_name_or_oid"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "role_name_or_oid"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "role_name_or_oid",
            "\"0123456789\""
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "InvalidOid"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "role_name_or_oid",
            "\"-\""
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregrolein(PG_FUNCTION_ARGS)\n{\n\tchar\t   *role_name_or_oid = PG_GETARG_CSTRING(0);\n\tOid\t\t\tresult;\n\tList\t   *names;\n\n\t/* '-' ? */\n\tif (strcmp(role_name_or_oid, \"-\") == 0)\n\t\tPG_RETURN_OID(InvalidOid);\n\n\t/* Numeric OID? */\n\tif (role_name_or_oid[0] >= '0' &&\n\t\trole_name_or_oid[0] <= '9' &&\n\t\tstrspn(role_name_or_oid, \"0123456789\") == strlen(role_name_or_oid))\n\t{\n\t\tresult = DatumGetObjectId(DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(role_name_or_oid)));\n\t\tPG_RETURN_OID(result);\n\t}\n\n\t/* The rest of this wouldn't work in bootstrap mode */\n\tif (IsBootstrapProcessingMode())\n\t\telog(ERROR, \"regrole values must be OIDs in bootstrap mode\");\n\n\t/* Normal case: see if the name matches any pg_authid entry. */\n\tnames = stringToQualifiedNameList(role_name_or_oid);\n\n\tif (list_length(names) != 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tresult = get_role_oid(strVal(linitial(names)), false);\n\n\tPG_RETURN_OID(result);\n}"
  },
  {
    "function_name": "regdictionarysend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1403-1408",
    "snippet": "Datum\nregdictionarysend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidsend, so share code */\n\treturn oidsend(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oidsend",
          "args": [
            "fcinfo"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "oidsend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "150-159",
          "snippet": "Datum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregdictionarysend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidsend, so share code */\n\treturn oidsend(fcinfo);\n}"
  },
  {
    "function_name": "regdictionaryrecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1393-1398",
    "snippet": "Datum\nregdictionaryrecv(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidrecv, so share code */\n\treturn oidrecv(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oidrecv",
          "args": [
            "fcinfo"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "oidrecv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "139-145",
          "snippet": "Datum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregdictionaryrecv(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidrecv, so share code */\n\treturn oidrecv(fcinfo);\n}"
  },
  {
    "function_name": "regdictionaryout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1346-1388",
    "snippet": "Datum\nregdictionaryout(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tdictid = PG_GETARG_OID(0);\n\tchar\t   *result;\n\tHeapTuple\tdicttup;\n\n\tif (dictid == InvalidOid)\n\t{\n\t\tresult = pstrdup(\"-\");\n\t\tPG_RETURN_CSTRING(result);\n\t}\n\n\tdicttup = SearchSysCache1(TSDICTOID, ObjectIdGetDatum(dictid));\n\n\tif (HeapTupleIsValid(dicttup))\n\t{\n\t\tForm_pg_ts_dict dictform = (Form_pg_ts_dict) GETSTRUCT(dicttup);\n\t\tchar\t   *dictname = NameStr(dictform->dictname);\n\t\tchar\t   *nspname;\n\n\t\t/*\n\t\t * Would this dictionary be found by regdictionaryin? If not, qualify\n\t\t * it.\n\t\t */\n\t\tif (TSDictionaryIsVisible(dictid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name(dictform->dictnamespace);\n\n\t\tresult = quote_qualified_identifier(nspname, dictname);\n\n\t\tReleaseSysCache(dicttup);\n\t}\n\telse\n\t{\n\t\t/* If OID doesn't match any pg_ts_dict row, return it numerically */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", dictid);\n\t}\n\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "NAMEDATALEN",
            "\"%u\"",
            "dictid"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "NAMEDATALEN"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "dicttup"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "quote_qualified_identifier",
          "args": [
            "nspname",
            "dictname"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "quote_qualified_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "10636-10647",
          "snippet": "char *\nquote_qualified_identifier(const char *qualifier,\n\t\t\t\t\t\t   const char *ident)\n{\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\tif (qualifier)\n\t\tappendStringInfo(&buf, \"%s.\", quote_identifier(qualifier));\n\tappendStringInfoString(&buf, quote_identifier(ident));\n\treturn buf.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int decompile_column_index_array(Datum column_index_array, Oid relId,\n\t\t\t\t\t\t\t StringInfo buf);",
            "static void get_opclass_name(Oid opclass, Oid actual_datatype,\n\t\t\t\t StringInfo buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int decompile_column_index_array(Datum column_index_array, Oid relId,\n\t\t\t\t\t\t\t StringInfo buf);\nstatic void get_opclass_name(Oid opclass, Oid actual_datatype,\n\t\t\t\t StringInfo buf);\n\nchar *\nquote_qualified_identifier(const char *qualifier,\n\t\t\t\t\t\t   const char *ident)\n{\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\tif (qualifier)\n\t\tappendStringInfo(&buf, \"%s.\", quote_identifier(qualifier));\n\tappendStringInfoString(&buf, quote_identifier(ident));\n\treturn buf.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_namespace_name",
          "args": [
            "dictform->dictnamespace"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSDictionaryIsVisible",
          "args": [
            "dictid"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "dictform->dictname"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "dicttup"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "dicttup"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "TSDICTOID",
            "ObjectIdGetDatum(dictid)"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "dictid"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "\"-\""
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregdictionaryout(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tdictid = PG_GETARG_OID(0);\n\tchar\t   *result;\n\tHeapTuple\tdicttup;\n\n\tif (dictid == InvalidOid)\n\t{\n\t\tresult = pstrdup(\"-\");\n\t\tPG_RETURN_CSTRING(result);\n\t}\n\n\tdicttup = SearchSysCache1(TSDICTOID, ObjectIdGetDatum(dictid));\n\n\tif (HeapTupleIsValid(dicttup))\n\t{\n\t\tForm_pg_ts_dict dictform = (Form_pg_ts_dict) GETSTRUCT(dicttup);\n\t\tchar\t   *dictname = NameStr(dictform->dictname);\n\t\tchar\t   *nspname;\n\n\t\t/*\n\t\t * Would this dictionary be found by regdictionaryin? If not, qualify\n\t\t * it.\n\t\t */\n\t\tif (TSDictionaryIsVisible(dictid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name(dictform->dictnamespace);\n\n\t\tresult = quote_qualified_identifier(nspname, dictname);\n\n\t\tReleaseSysCache(dicttup);\n\t}\n\telse\n\t{\n\t\t/* If OID doesn't match any pg_ts_dict row, return it numerically */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", dictid);\n\t}\n\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "regdictionaryin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1307-1341",
    "snippet": "Datum\nregdictionaryin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *dict_name_or_oid = PG_GETARG_CSTRING(0);\n\tOid\t\t\tresult;\n\tList\t   *names;\n\n\t/* '-' ? */\n\tif (strcmp(dict_name_or_oid, \"-\") == 0)\n\t\tPG_RETURN_OID(InvalidOid);\n\n\t/* Numeric OID? */\n\tif (dict_name_or_oid[0] >= '0' &&\n\t\tdict_name_or_oid[0] <= '9' &&\n\t\tstrspn(dict_name_or_oid, \"0123456789\") == strlen(dict_name_or_oid))\n\t{\n\t\tresult = DatumGetObjectId(DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(dict_name_or_oid)));\n\t\tPG_RETURN_OID(result);\n\t}\n\n\t/* The rest of this wouldn't work in bootstrap mode */\n\tif (IsBootstrapProcessingMode())\n\t\telog(ERROR, \"regdictionary values must be OIDs in bootstrap mode\");\n\n\t/*\n\t * Normal case: parse the name into components and see if it matches any\n\t * pg_ts_dict entries in the current search path.\n\t */\n\tnames = stringToQualifiedNameList(dict_name_or_oid);\n\n\tresult = get_ts_dict_oid(names, false);\n\n\tPG_RETURN_OID(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ts_dict_oid",
          "args": [
            "names",
            "false"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringToQualifiedNameList",
          "args": [
            "dict_name_or_oid"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "stringToQualifiedNameList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "1686-1718",
          "snippet": "List *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"regdictionary values must be OIDs in bootstrap mode\""
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetObjectId",
          "args": [
            "DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(dict_name_or_oid))"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "oidin",
            "CStringGetDatum(dict_name_or_oid)"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "dict_name_or_oid"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dict_name_or_oid"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "dict_name_or_oid",
            "\"0123456789\""
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "InvalidOid"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dict_name_or_oid",
            "\"-\""
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregdictionaryin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *dict_name_or_oid = PG_GETARG_CSTRING(0);\n\tOid\t\t\tresult;\n\tList\t   *names;\n\n\t/* '-' ? */\n\tif (strcmp(dict_name_or_oid, \"-\") == 0)\n\t\tPG_RETURN_OID(InvalidOid);\n\n\t/* Numeric OID? */\n\tif (dict_name_or_oid[0] >= '0' &&\n\t\tdict_name_or_oid[0] <= '9' &&\n\t\tstrspn(dict_name_or_oid, \"0123456789\") == strlen(dict_name_or_oid))\n\t{\n\t\tresult = DatumGetObjectId(DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(dict_name_or_oid)));\n\t\tPG_RETURN_OID(result);\n\t}\n\n\t/* The rest of this wouldn't work in bootstrap mode */\n\tif (IsBootstrapProcessingMode())\n\t\telog(ERROR, \"regdictionary values must be OIDs in bootstrap mode\");\n\n\t/*\n\t * Normal case: parse the name into components and see if it matches any\n\t * pg_ts_dict entries in the current search path.\n\t */\n\tnames = stringToQualifiedNameList(dict_name_or_oid);\n\n\tresult = get_ts_dict_oid(names, false);\n\n\tPG_RETURN_OID(result);\n}"
  },
  {
    "function_name": "regconfigsend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1291-1296",
    "snippet": "Datum\nregconfigsend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidsend, so share code */\n\treturn oidsend(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oidsend",
          "args": [
            "fcinfo"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "oidsend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "150-159",
          "snippet": "Datum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregconfigsend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidsend, so share code */\n\treturn oidsend(fcinfo);\n}"
  },
  {
    "function_name": "regconfigrecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1281-1286",
    "snippet": "Datum\nregconfigrecv(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidrecv, so share code */\n\treturn oidrecv(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oidrecv",
          "args": [
            "fcinfo"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "oidrecv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "139-145",
          "snippet": "Datum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregconfigrecv(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidrecv, so share code */\n\treturn oidrecv(fcinfo);\n}"
  },
  {
    "function_name": "regconfigout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1235-1276",
    "snippet": "Datum\nregconfigout(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tcfgid = PG_GETARG_OID(0);\n\tchar\t   *result;\n\tHeapTuple\tcfgtup;\n\n\tif (cfgid == InvalidOid)\n\t{\n\t\tresult = pstrdup(\"-\");\n\t\tPG_RETURN_CSTRING(result);\n\t}\n\n\tcfgtup = SearchSysCache1(TSCONFIGOID, ObjectIdGetDatum(cfgid));\n\n\tif (HeapTupleIsValid(cfgtup))\n\t{\n\t\tForm_pg_ts_config cfgform = (Form_pg_ts_config) GETSTRUCT(cfgtup);\n\t\tchar\t   *cfgname = NameStr(cfgform->cfgname);\n\t\tchar\t   *nspname;\n\n\t\t/*\n\t\t * Would this config be found by regconfigin? If not, qualify it.\n\t\t */\n\t\tif (TSConfigIsVisible(cfgid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name(cfgform->cfgnamespace);\n\n\t\tresult = quote_qualified_identifier(nspname, cfgname);\n\n\t\tReleaseSysCache(cfgtup);\n\t}\n\telse\n\t{\n\t\t/* If OID doesn't match any pg_ts_config row, return it numerically */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", cfgid);\n\t}\n\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "NAMEDATALEN",
            "\"%u\"",
            "cfgid"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "NAMEDATALEN"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "cfgtup"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "quote_qualified_identifier",
          "args": [
            "nspname",
            "cfgname"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "quote_qualified_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "10636-10647",
          "snippet": "char *\nquote_qualified_identifier(const char *qualifier,\n\t\t\t\t\t\t   const char *ident)\n{\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\tif (qualifier)\n\t\tappendStringInfo(&buf, \"%s.\", quote_identifier(qualifier));\n\tappendStringInfoString(&buf, quote_identifier(ident));\n\treturn buf.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int decompile_column_index_array(Datum column_index_array, Oid relId,\n\t\t\t\t\t\t\t StringInfo buf);",
            "static void get_opclass_name(Oid opclass, Oid actual_datatype,\n\t\t\t\t StringInfo buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int decompile_column_index_array(Datum column_index_array, Oid relId,\n\t\t\t\t\t\t\t StringInfo buf);\nstatic void get_opclass_name(Oid opclass, Oid actual_datatype,\n\t\t\t\t StringInfo buf);\n\nchar *\nquote_qualified_identifier(const char *qualifier,\n\t\t\t\t\t\t   const char *ident)\n{\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\tif (qualifier)\n\t\tappendStringInfo(&buf, \"%s.\", quote_identifier(qualifier));\n\tappendStringInfoString(&buf, quote_identifier(ident));\n\treturn buf.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_namespace_name",
          "args": [
            "cfgform->cfgnamespace"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TSConfigIsVisible",
          "args": [
            "cfgid"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "cfgform->cfgname"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "cfgtup"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "cfgtup"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "TSCONFIGOID",
            "ObjectIdGetDatum(cfgid)"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "cfgid"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "\"-\""
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregconfigout(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tcfgid = PG_GETARG_OID(0);\n\tchar\t   *result;\n\tHeapTuple\tcfgtup;\n\n\tif (cfgid == InvalidOid)\n\t{\n\t\tresult = pstrdup(\"-\");\n\t\tPG_RETURN_CSTRING(result);\n\t}\n\n\tcfgtup = SearchSysCache1(TSCONFIGOID, ObjectIdGetDatum(cfgid));\n\n\tif (HeapTupleIsValid(cfgtup))\n\t{\n\t\tForm_pg_ts_config cfgform = (Form_pg_ts_config) GETSTRUCT(cfgtup);\n\t\tchar\t   *cfgname = NameStr(cfgform->cfgname);\n\t\tchar\t   *nspname;\n\n\t\t/*\n\t\t * Would this config be found by regconfigin? If not, qualify it.\n\t\t */\n\t\tif (TSConfigIsVisible(cfgid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name(cfgform->cfgnamespace);\n\n\t\tresult = quote_qualified_identifier(nspname, cfgname);\n\n\t\tReleaseSysCache(cfgtup);\n\t}\n\telse\n\t{\n\t\t/* If OID doesn't match any pg_ts_config row, return it numerically */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", cfgid);\n\t}\n\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "regconfigin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1196-1230",
    "snippet": "Datum\nregconfigin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *cfg_name_or_oid = PG_GETARG_CSTRING(0);\n\tOid\t\t\tresult;\n\tList\t   *names;\n\n\t/* '-' ? */\n\tif (strcmp(cfg_name_or_oid, \"-\") == 0)\n\t\tPG_RETURN_OID(InvalidOid);\n\n\t/* Numeric OID? */\n\tif (cfg_name_or_oid[0] >= '0' &&\n\t\tcfg_name_or_oid[0] <= '9' &&\n\t\tstrspn(cfg_name_or_oid, \"0123456789\") == strlen(cfg_name_or_oid))\n\t{\n\t\tresult = DatumGetObjectId(DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(cfg_name_or_oid)));\n\t\tPG_RETURN_OID(result);\n\t}\n\n\t/* The rest of this wouldn't work in bootstrap mode */\n\tif (IsBootstrapProcessingMode())\n\t\telog(ERROR, \"regconfig values must be OIDs in bootstrap mode\");\n\n\t/*\n\t * Normal case: parse the name into components and see if it matches any\n\t * pg_ts_config entries in the current search path.\n\t */\n\tnames = stringToQualifiedNameList(cfg_name_or_oid);\n\n\tresult = get_ts_config_oid(names, false);\n\n\tPG_RETURN_OID(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ts_config_oid",
          "args": [
            "names",
            "false"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringToQualifiedNameList",
          "args": [
            "cfg_name_or_oid"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "stringToQualifiedNameList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "1686-1718",
          "snippet": "List *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"regconfig values must be OIDs in bootstrap mode\""
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetObjectId",
          "args": [
            "DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(cfg_name_or_oid))"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "oidin",
            "CStringGetDatum(cfg_name_or_oid)"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "cfg_name_or_oid"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cfg_name_or_oid"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "cfg_name_or_oid",
            "\"0123456789\""
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "InvalidOid"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cfg_name_or_oid",
            "\"-\""
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregconfigin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *cfg_name_or_oid = PG_GETARG_CSTRING(0);\n\tOid\t\t\tresult;\n\tList\t   *names;\n\n\t/* '-' ? */\n\tif (strcmp(cfg_name_or_oid, \"-\") == 0)\n\t\tPG_RETURN_OID(InvalidOid);\n\n\t/* Numeric OID? */\n\tif (cfg_name_or_oid[0] >= '0' &&\n\t\tcfg_name_or_oid[0] <= '9' &&\n\t\tstrspn(cfg_name_or_oid, \"0123456789\") == strlen(cfg_name_or_oid))\n\t{\n\t\tresult = DatumGetObjectId(DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(cfg_name_or_oid)));\n\t\tPG_RETURN_OID(result);\n\t}\n\n\t/* The rest of this wouldn't work in bootstrap mode */\n\tif (IsBootstrapProcessingMode())\n\t\telog(ERROR, \"regconfig values must be OIDs in bootstrap mode\");\n\n\t/*\n\t * Normal case: parse the name into components and see if it matches any\n\t * pg_ts_config entries in the current search path.\n\t */\n\tnames = stringToQualifiedNameList(cfg_name_or_oid);\n\n\tresult = get_ts_config_oid(names, false);\n\n\tPG_RETURN_OID(result);\n}"
  },
  {
    "function_name": "regtypesend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1180-1185",
    "snippet": "Datum\nregtypesend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidsend, so share code */\n\treturn oidsend(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oidsend",
          "args": [
            "fcinfo"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "oidsend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "150-159",
          "snippet": "Datum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregtypesend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidsend, so share code */\n\treturn oidsend(fcinfo);\n}"
  },
  {
    "function_name": "regtyperecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1170-1175",
    "snippet": "Datum\nregtyperecv(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidrecv, so share code */\n\treturn oidrecv(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oidrecv",
          "args": [
            "fcinfo"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "oidrecv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "139-145",
          "snippet": "Datum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregtyperecv(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidrecv, so share code */\n\treturn oidrecv(fcinfo);\n}"
  },
  {
    "function_name": "regtypeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1122-1165",
    "snippet": "Datum\nregtypeout(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ttypid = PG_GETARG_OID(0);\n\tchar\t   *result;\n\tHeapTuple\ttypetup;\n\n\tif (typid == InvalidOid)\n\t{\n\t\tresult = pstrdup(\"-\");\n\t\tPG_RETURN_CSTRING(result);\n\t}\n\n\ttypetup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\n\tif (HeapTupleIsValid(typetup))\n\t{\n\t\tForm_pg_type typeform = (Form_pg_type) GETSTRUCT(typetup);\n\n\t\t/*\n\t\t * In bootstrap mode, skip the fancy namespace stuff and just return\n\t\t * the type name.  (This path is only needed for debugging output\n\t\t * anyway.)\n\t\t */\n\t\tif (IsBootstrapProcessingMode())\n\t\t{\n\t\t\tchar\t   *typname = NameStr(typeform->typname);\n\n\t\t\tresult = pstrdup(typname);\n\t\t}\n\t\telse\n\t\t\tresult = format_type_be(typid);\n\n\t\tReleaseSysCache(typetup);\n\t}\n\telse\n\t{\n\t\t/* If OID doesn't match any pg_type entry, return it numerically */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", typid);\n\t}\n\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "NAMEDATALEN",
            "\"%u\"",
            "typid"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "NAMEDATALEN"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "typetup"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "typid"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "typname"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "typeform->typname"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "typetup"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "typetup"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "TYPEOID",
            "ObjectIdGetDatum(typid)"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "typid"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregtypeout(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\ttypid = PG_GETARG_OID(0);\n\tchar\t   *result;\n\tHeapTuple\ttypetup;\n\n\tif (typid == InvalidOid)\n\t{\n\t\tresult = pstrdup(\"-\");\n\t\tPG_RETURN_CSTRING(result);\n\t}\n\n\ttypetup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid));\n\n\tif (HeapTupleIsValid(typetup))\n\t{\n\t\tForm_pg_type typeform = (Form_pg_type) GETSTRUCT(typetup);\n\n\t\t/*\n\t\t * In bootstrap mode, skip the fancy namespace stuff and just return\n\t\t * the type name.  (This path is only needed for debugging output\n\t\t * anyway.)\n\t\t */\n\t\tif (IsBootstrapProcessingMode())\n\t\t{\n\t\t\tchar\t   *typname = NameStr(typeform->typname);\n\n\t\t\tresult = pstrdup(typname);\n\t\t}\n\t\telse\n\t\t\tresult = format_type_be(typid);\n\n\t\tReleaseSysCache(typetup);\n\t}\n\telse\n\t{\n\t\t/* If OID doesn't match any pg_type entry, return it numerically */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", typid);\n\t}\n\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "to_regtype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1101-1117",
    "snippet": "Datum\nto_regtype(PG_FUNCTION_ARGS)\n{\n\tchar\t   *typ_name = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tOid\t\t\tresult;\n\tint32\t\ttypmod;\n\n\t/*\n\t * Invoke the full parser to deal with special cases such as array syntax.\n\t */\n\tparseTypeString(typ_name, &result, &typmod, true);\n\n\tif (OidIsValid(result))\n\t\tPG_RETURN_OID(result);\n\telse\n\t\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "result"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseTypeString",
          "args": [
            "typ_name",
            "&result",
            "&typmod",
            "true"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(0)"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nto_regtype(PG_FUNCTION_ARGS)\n{\n\tchar\t   *typ_name = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tOid\t\t\tresult;\n\tint32\t\ttypmod;\n\n\t/*\n\t * Invoke the full parser to deal with special cases such as array syntax.\n\t */\n\tparseTypeString(typ_name, &result, &typmod, true);\n\n\tif (OidIsValid(result))\n\t\tPG_RETURN_OID(result);\n\telse\n\t\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "regtypein",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1060-1094",
    "snippet": "Datum\nregtypein(PG_FUNCTION_ARGS)\n{\n\tchar\t   *typ_name_or_oid = PG_GETARG_CSTRING(0);\n\tOid\t\t\tresult = InvalidOid;\n\tint32\t\ttypmod;\n\n\t/* '-' ? */\n\tif (strcmp(typ_name_or_oid, \"-\") == 0)\n\t\tPG_RETURN_OID(InvalidOid);\n\n\t/* Numeric OID? */\n\tif (typ_name_or_oid[0] >= '0' &&\n\t\ttyp_name_or_oid[0] <= '9' &&\n\t\tstrspn(typ_name_or_oid, \"0123456789\") == strlen(typ_name_or_oid))\n\t{\n\t\tresult = DatumGetObjectId(DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(typ_name_or_oid)));\n\t\tPG_RETURN_OID(result);\n\t}\n\n\t/* Else it's a type name, possibly schema-qualified or decorated */\n\n\t/* The rest of this wouldn't work in bootstrap mode */\n\tif (IsBootstrapProcessingMode())\n\t\telog(ERROR, \"regtype values must be OIDs in bootstrap mode\");\n\n\t/*\n\t * Normal case: invoke the full parser to deal with special cases such as\n\t * array syntax.\n\t */\n\tparseTypeString(typ_name_or_oid, &result, &typmod, false);\n\n\tPG_RETURN_OID(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseTypeString",
          "args": [
            "typ_name_or_oid",
            "&result",
            "&typmod",
            "false"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"regtype values must be OIDs in bootstrap mode\""
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetObjectId",
          "args": [
            "DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(typ_name_or_oid))"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "oidin",
            "CStringGetDatum(typ_name_or_oid)"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "typ_name_or_oid"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "typ_name_or_oid"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "typ_name_or_oid",
            "\"0123456789\""
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "InvalidOid"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "typ_name_or_oid",
            "\"-\""
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregtypein(PG_FUNCTION_ARGS)\n{\n\tchar\t   *typ_name_or_oid = PG_GETARG_CSTRING(0);\n\tOid\t\t\tresult = InvalidOid;\n\tint32\t\ttypmod;\n\n\t/* '-' ? */\n\tif (strcmp(typ_name_or_oid, \"-\") == 0)\n\t\tPG_RETURN_OID(InvalidOid);\n\n\t/* Numeric OID? */\n\tif (typ_name_or_oid[0] >= '0' &&\n\t\ttyp_name_or_oid[0] <= '9' &&\n\t\tstrspn(typ_name_or_oid, \"0123456789\") == strlen(typ_name_or_oid))\n\t{\n\t\tresult = DatumGetObjectId(DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(typ_name_or_oid)));\n\t\tPG_RETURN_OID(result);\n\t}\n\n\t/* Else it's a type name, possibly schema-qualified or decorated */\n\n\t/* The rest of this wouldn't work in bootstrap mode */\n\tif (IsBootstrapProcessingMode())\n\t\telog(ERROR, \"regtype values must be OIDs in bootstrap mode\");\n\n\t/*\n\t * Normal case: invoke the full parser to deal with special cases such as\n\t * array syntax.\n\t */\n\tparseTypeString(typ_name_or_oid, &result, &typmod, false);\n\n\tPG_RETURN_OID(result);\n}"
  },
  {
    "function_name": "regclasssend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1038-1043",
    "snippet": "Datum\nregclasssend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidsend, so share code */\n\treturn oidsend(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oidsend",
          "args": [
            "fcinfo"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "oidsend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "150-159",
          "snippet": "Datum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregclasssend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidsend, so share code */\n\treturn oidsend(fcinfo);\n}"
  },
  {
    "function_name": "regclassrecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "1028-1033",
    "snippet": "Datum\nregclassrecv(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidrecv, so share code */\n\treturn oidrecv(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oidrecv",
          "args": [
            "fcinfo"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "oidrecv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "139-145",
          "snippet": "Datum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregclassrecv(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidrecv, so share code */\n\treturn oidrecv(fcinfo);\n}"
  },
  {
    "function_name": "regclassout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "971-1023",
    "snippet": "Datum\nregclassout(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tclassid = PG_GETARG_OID(0);\n\tchar\t   *result;\n\tHeapTuple\tclasstup;\n\n\tif (classid == InvalidOid)\n\t{\n\t\tresult = pstrdup(\"-\");\n\t\tPG_RETURN_CSTRING(result);\n\t}\n\n\tclasstup = SearchSysCache1(RELOID, ObjectIdGetDatum(classid));\n\n\tif (HeapTupleIsValid(classtup))\n\t{\n\t\tForm_pg_class classform = (Form_pg_class) GETSTRUCT(classtup);\n\t\tchar\t   *classname = NameStr(classform->relname);\n\n\t\t/*\n\t\t * In bootstrap mode, skip the fancy namespace stuff and just return\n\t\t * the class name.  (This path is only needed for debugging output\n\t\t * anyway.)\n\t\t */\n\t\tif (IsBootstrapProcessingMode())\n\t\t\tresult = pstrdup(classname);\n\t\telse\n\t\t{\n\t\t\tchar\t   *nspname;\n\n\t\t\t/*\n\t\t\t * Would this class be found by regclassin? If not, qualify it.\n\t\t\t */\n\t\t\tif (RelationIsVisible(classid))\n\t\t\t\tnspname = NULL;\n\t\t\telse\n\t\t\t\tnspname = get_namespace_name(classform->relnamespace);\n\n\t\t\tresult = quote_qualified_identifier(nspname, classname);\n\t\t}\n\n\t\tReleaseSysCache(classtup);\n\t}\n\telse\n\t{\n\t\t/* If OID doesn't match any pg_class entry, return it numerically */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", classid);\n\t}\n\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "NAMEDATALEN",
            "\"%u\"",
            "classid"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "NAMEDATALEN"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "classtup"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "quote_qualified_identifier",
          "args": [
            "nspname",
            "classname"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "quote_qualified_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "10636-10647",
          "snippet": "char *\nquote_qualified_identifier(const char *qualifier,\n\t\t\t\t\t\t   const char *ident)\n{\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\tif (qualifier)\n\t\tappendStringInfo(&buf, \"%s.\", quote_identifier(qualifier));\n\tappendStringInfoString(&buf, quote_identifier(ident));\n\treturn buf.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int decompile_column_index_array(Datum column_index_array, Oid relId,\n\t\t\t\t\t\t\t StringInfo buf);",
            "static void get_opclass_name(Oid opclass, Oid actual_datatype,\n\t\t\t\t StringInfo buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int decompile_column_index_array(Datum column_index_array, Oid relId,\n\t\t\t\t\t\t\t StringInfo buf);\nstatic void get_opclass_name(Oid opclass, Oid actual_datatype,\n\t\t\t\t StringInfo buf);\n\nchar *\nquote_qualified_identifier(const char *qualifier,\n\t\t\t\t\t\t   const char *ident)\n{\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\tif (qualifier)\n\t\tappendStringInfo(&buf, \"%s.\", quote_identifier(qualifier));\n\tappendStringInfoString(&buf, quote_identifier(ident));\n\treturn buf.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_namespace_name",
          "args": [
            "classform->relnamespace"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelationIsVisible",
          "args": [
            "classid"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "classname"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "classform->relname"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "classtup"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "classtup"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "RELOID",
            "ObjectIdGetDatum(classid)"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "classid"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregclassout(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\tclassid = PG_GETARG_OID(0);\n\tchar\t   *result;\n\tHeapTuple\tclasstup;\n\n\tif (classid == InvalidOid)\n\t{\n\t\tresult = pstrdup(\"-\");\n\t\tPG_RETURN_CSTRING(result);\n\t}\n\n\tclasstup = SearchSysCache1(RELOID, ObjectIdGetDatum(classid));\n\n\tif (HeapTupleIsValid(classtup))\n\t{\n\t\tForm_pg_class classform = (Form_pg_class) GETSTRUCT(classtup);\n\t\tchar\t   *classname = NameStr(classform->relname);\n\n\t\t/*\n\t\t * In bootstrap mode, skip the fancy namespace stuff and just return\n\t\t * the class name.  (This path is only needed for debugging output\n\t\t * anyway.)\n\t\t */\n\t\tif (IsBootstrapProcessingMode())\n\t\t\tresult = pstrdup(classname);\n\t\telse\n\t\t{\n\t\t\tchar\t   *nspname;\n\n\t\t\t/*\n\t\t\t * Would this class be found by regclassin? If not, qualify it.\n\t\t\t */\n\t\t\tif (RelationIsVisible(classid))\n\t\t\t\tnspname = NULL;\n\t\t\telse\n\t\t\t\tnspname = get_namespace_name(classform->relnamespace);\n\n\t\t\tresult = quote_qualified_identifier(nspname, classname);\n\t\t}\n\n\t\tReleaseSysCache(classtup);\n\t}\n\telse\n\t{\n\t\t/* If OID doesn't match any pg_class entry, return it numerically */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", classid);\n\t}\n\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "to_regclass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "946-966",
    "snippet": "Datum\nto_regclass(PG_FUNCTION_ARGS)\n{\n\tchar\t   *class_name = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tOid\t\t\tresult;\n\tList\t   *names;\n\n\t/*\n\t * Parse the name into components and see if it matches any pg_class\n\t * entries in the current search path.\n\t */\n\tnames = stringToQualifiedNameList(class_name);\n\n\t/* We might not even have permissions on this relation; don't lock it. */\n\tresult = RangeVarGetRelid(makeRangeVarFromNameList(names), NoLock, true);\n\n\tif (OidIsValid(result))\n\t\tPG_RETURN_OID(result);\n\telse\n\t\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "result"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeVarGetRelid",
          "args": [
            "makeRangeVarFromNameList(names)",
            "NoLock",
            "true"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeRangeVarFromNameList",
          "args": [
            "names"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringToQualifiedNameList",
          "args": [
            "class_name"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "stringToQualifiedNameList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "1686-1718",
          "snippet": "List *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(0)"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nto_regclass(PG_FUNCTION_ARGS)\n{\n\tchar\t   *class_name = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tOid\t\t\tresult;\n\tList\t   *names;\n\n\t/*\n\t * Parse the name into components and see if it matches any pg_class\n\t * entries in the current search path.\n\t */\n\tnames = stringToQualifiedNameList(class_name);\n\n\t/* We might not even have permissions on this relation; don't lock it. */\n\tresult = RangeVarGetRelid(makeRangeVarFromNameList(names), NoLock, true);\n\n\tif (OidIsValid(result))\n\t\tPG_RETURN_OID(result);\n\telse\n\t\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "regclassin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "902-939",
    "snippet": "Datum\nregclassin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *class_name_or_oid = PG_GETARG_CSTRING(0);\n\tOid\t\t\tresult = InvalidOid;\n\tList\t   *names;\n\n\t/* '-' ? */\n\tif (strcmp(class_name_or_oid, \"-\") == 0)\n\t\tPG_RETURN_OID(InvalidOid);\n\n\t/* Numeric OID? */\n\tif (class_name_or_oid[0] >= '0' &&\n\t\tclass_name_or_oid[0] <= '9' &&\n\t\tstrspn(class_name_or_oid, \"0123456789\") == strlen(class_name_or_oid))\n\t{\n\t\tresult = DatumGetObjectId(DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(class_name_or_oid)));\n\t\tPG_RETURN_OID(result);\n\t}\n\n\t/* Else it's a name, possibly schema-qualified */\n\n\t/* The rest of this wouldn't work in bootstrap mode */\n\tif (IsBootstrapProcessingMode())\n\t\telog(ERROR, \"regclass values must be OIDs in bootstrap mode\");\n\n\t/*\n\t * Normal case: parse the name into components and see if it matches any\n\t * pg_class entries in the current search path.\n\t */\n\tnames = stringToQualifiedNameList(class_name_or_oid);\n\n\t/* We might not even have permissions on this relation; don't lock it. */\n\tresult = RangeVarGetRelid(makeRangeVarFromNameList(names), NoLock, false);\n\n\tPG_RETURN_OID(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RangeVarGetRelid",
          "args": [
            "makeRangeVarFromNameList(names)",
            "NoLock",
            "false"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeRangeVarFromNameList",
          "args": [
            "names"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringToQualifiedNameList",
          "args": [
            "class_name_or_oid"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "stringToQualifiedNameList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "1686-1718",
          "snippet": "List *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"regclass values must be OIDs in bootstrap mode\""
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetObjectId",
          "args": [
            "DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(class_name_or_oid))"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "oidin",
            "CStringGetDatum(class_name_or_oid)"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "class_name_or_oid"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "class_name_or_oid"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "class_name_or_oid",
            "\"0123456789\""
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "InvalidOid"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "class_name_or_oid",
            "\"-\""
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregclassin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *class_name_or_oid = PG_GETARG_CSTRING(0);\n\tOid\t\t\tresult = InvalidOid;\n\tList\t   *names;\n\n\t/* '-' ? */\n\tif (strcmp(class_name_or_oid, \"-\") == 0)\n\t\tPG_RETURN_OID(InvalidOid);\n\n\t/* Numeric OID? */\n\tif (class_name_or_oid[0] >= '0' &&\n\t\tclass_name_or_oid[0] <= '9' &&\n\t\tstrspn(class_name_or_oid, \"0123456789\") == strlen(class_name_or_oid))\n\t{\n\t\tresult = DatumGetObjectId(DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(class_name_or_oid)));\n\t\tPG_RETURN_OID(result);\n\t}\n\n\t/* Else it's a name, possibly schema-qualified */\n\n\t/* The rest of this wouldn't work in bootstrap mode */\n\tif (IsBootstrapProcessingMode())\n\t\telog(ERROR, \"regclass values must be OIDs in bootstrap mode\");\n\n\t/*\n\t * Normal case: parse the name into components and see if it matches any\n\t * pg_class entries in the current search path.\n\t */\n\tnames = stringToQualifiedNameList(class_name_or_oid);\n\n\t/* We might not even have permissions on this relation; don't lock it. */\n\tresult = RangeVarGetRelid(makeRangeVarFromNameList(names), NoLock, false);\n\n\tPG_RETURN_OID(result);\n}"
  },
  {
    "function_name": "regoperatorsend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "886-891",
    "snippet": "Datum\nregoperatorsend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidsend, so share code */\n\treturn oidsend(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oidsend",
          "args": [
            "fcinfo"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "oidsend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "150-159",
          "snippet": "Datum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregoperatorsend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidsend, so share code */\n\treturn oidsend(fcinfo);\n}"
  },
  {
    "function_name": "regoperatorrecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "876-881",
    "snippet": "Datum\nregoperatorrecv(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidrecv, so share code */\n\treturn oidrecv(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oidrecv",
          "args": [
            "fcinfo"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "oidrecv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "139-145",
          "snippet": "Datum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregoperatorrecv(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidrecv, so share code */\n\treturn oidrecv(fcinfo);\n}"
  },
  {
    "function_name": "regoperatorout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "859-871",
    "snippet": "Datum\nregoperatorout(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\toprid = PG_GETARG_OID(0);\n\tchar\t   *result;\n\n\tif (oprid == InvalidOid)\n\t\tresult = pstrdup(\"0\");\n\telse\n\t\tresult = format_operator(oprid);\n\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format_operator",
          "args": [
            "oprid"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "format_operator_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "825-829",
          "snippet": "char *\nformat_operator_qualified(Oid operator_oid)\n{\n\treturn format_operator_internal(operator_oid, true);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_operator_qualified(Oid operator_oid)\n{\n\treturn format_operator_internal(operator_oid, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "\"0\""
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregoperatorout(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\toprid = PG_GETARG_OID(0);\n\tchar\t   *result;\n\n\tif (oprid == InvalidOid)\n\t\tresult = pstrdup(\"0\");\n\telse\n\t\tresult = format_operator(oprid);\n\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "format_operator_parts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "831-854",
    "snippet": "void\nformat_operator_parts(Oid operator_oid, List **objnames, List **objargs)\n{\n\tHeapTuple\topertup;\n\tForm_pg_operator oprForm;\n\n\topertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(operator_oid));\n\tif (!HeapTupleIsValid(opertup))\n\t\telog(ERROR, \"cache lookup failed for operator with OID %u\",\n\t\t\t operator_oid);\n\n\toprForm = (Form_pg_operator) GETSTRUCT(opertup);\n\t*objnames = list_make2(get_namespace_name_or_temp(oprForm->oprnamespace),\n\t\t\t\t\t\t   pstrdup(NameStr(oprForm->oprname)));\n\t*objargs = NIL;\n\tif (oprForm->oprleft)\n\t\t*objargs = lappend(*objargs,\n\t\t\t\t\t\t   format_type_be_qualified(oprForm->oprleft));\n\tif (oprForm->oprright)\n\t\t*objargs = lappend(*objargs,\n\t\t\t\t\t\t   format_type_be_qualified(oprForm->oprright));\n\n\tReleaseSysCache(opertup);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "opertup"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "*objargs",
            "format_type_be_qualified(oprForm->oprright)"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format_type_be_qualified",
          "args": [
            "oprForm->oprright"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "*objargs",
            "format_type_be_qualified(oprForm->oprleft)"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_make2",
          "args": [
            "get_namespace_name_or_temp(oprForm->oprnamespace)",
            "pstrdup(NameStr(oprForm->oprname))"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "NameStr(oprForm->oprname)"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "oprForm->oprname"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_namespace_name_or_temp",
          "args": [
            "oprForm->oprnamespace"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "opertup"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for operator with OID %u\"",
            "operator_oid"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "opertup"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "OPEROID",
            "ObjectIdGetDatum(operator_oid)"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "operator_oid"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nformat_operator_parts(Oid operator_oid, List **objnames, List **objargs)\n{\n\tHeapTuple\topertup;\n\tForm_pg_operator oprForm;\n\n\topertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(operator_oid));\n\tif (!HeapTupleIsValid(opertup))\n\t\telog(ERROR, \"cache lookup failed for operator with OID %u\",\n\t\t\t operator_oid);\n\n\toprForm = (Form_pg_operator) GETSTRUCT(opertup);\n\t*objnames = list_make2(get_namespace_name_or_temp(oprForm->oprnamespace),\n\t\t\t\t\t\t   pstrdup(NameStr(oprForm->oprname)));\n\t*objargs = NIL;\n\tif (oprForm->oprleft)\n\t\t*objargs = lappend(*objargs,\n\t\t\t\t\t\t   format_type_be_qualified(oprForm->oprleft));\n\tif (oprForm->oprright)\n\t\t*objargs = lappend(*objargs,\n\t\t\t\t\t\t   format_type_be_qualified(oprForm->oprright));\n\n\tReleaseSysCache(opertup);\n}"
  },
  {
    "function_name": "format_operator_qualified",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "825-829",
    "snippet": "char *\nformat_operator_qualified(Oid operator_oid)\n{\n\treturn format_operator_internal(operator_oid, true);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "format_operator_internal",
          "args": [
            "operator_oid",
            "true"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "format_operator_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "754-817",
          "snippet": "static char *\nformat_operator_internal(Oid operator_oid, bool force_qualify)\n{\n\tchar\t   *result;\n\tHeapTuple\topertup;\n\n\topertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(operator_oid));\n\n\tif (HeapTupleIsValid(opertup))\n\t{\n\t\tForm_pg_operator operform = (Form_pg_operator) GETSTRUCT(opertup);\n\t\tchar\t   *oprname = NameStr(operform->oprname);\n\t\tchar\t   *nspname;\n\t\tStringInfoData buf;\n\n\t\t/* XXX no support here for bootstrap mode */\n\t\tAssert(!IsBootstrapProcessingMode());\n\n\t\tinitStringInfo(&buf);\n\n\t\t/*\n\t\t * Would this oper be found (given the right args) by regoperatorin?\n\t\t * If not, or if caller explicitly requests it, we need to qualify it.\n\t\t */\n\t\tif (force_qualify || !OperatorIsVisible(operator_oid))\n\t\t{\n\t\t\tnspname = get_namespace_name(operform->oprnamespace);\n\t\t\tappendStringInfo(&buf, \"%s.\",\n\t\t\t\t\t\t\t quote_identifier(nspname));\n\t\t}\n\n\t\tappendStringInfo(&buf, \"%s(\", oprname);\n\n\t\tif (operform->oprleft)\n\t\t\tappendStringInfo(&buf, \"%s,\",\n\t\t\t\t\t\t\t force_qualify ?\n\t\t\t\t\t\t\t format_type_be_qualified(operform->oprleft) :\n\t\t\t\t\t\t\t format_type_be(operform->oprleft));\n\t\telse\n\t\t\tappendStringInfoString(&buf, \"NONE,\");\n\n\t\tif (operform->oprright)\n\t\t\tappendStringInfo(&buf, \"%s)\",\n\t\t\t\t\t\t\t force_qualify ?\n\t\t\t\t\t\t\t format_type_be_qualified(operform->oprright) :\n\t\t\t\t\t\t\t format_type_be(operform->oprright));\n\t\telse\n\t\t\tappendStringInfoString(&buf, \"NONE)\");\n\n\t\tresult = buf.data;\n\n\t\tReleaseSysCache(opertup);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If OID doesn't match any pg_operator entry, return it numerically\n\t\t */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", operator_oid);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *format_operator_internal(Oid operator_oid, bool force_qualify);",
            "static char *format_procedure_internal(Oid procedure_oid, bool force_qualify);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *format_operator_internal(Oid operator_oid, bool force_qualify);\nstatic char *format_procedure_internal(Oid procedure_oid, bool force_qualify);\n\nstatic char *\nformat_operator_internal(Oid operator_oid, bool force_qualify)\n{\n\tchar\t   *result;\n\tHeapTuple\topertup;\n\n\topertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(operator_oid));\n\n\tif (HeapTupleIsValid(opertup))\n\t{\n\t\tForm_pg_operator operform = (Form_pg_operator) GETSTRUCT(opertup);\n\t\tchar\t   *oprname = NameStr(operform->oprname);\n\t\tchar\t   *nspname;\n\t\tStringInfoData buf;\n\n\t\t/* XXX no support here for bootstrap mode */\n\t\tAssert(!IsBootstrapProcessingMode());\n\n\t\tinitStringInfo(&buf);\n\n\t\t/*\n\t\t * Would this oper be found (given the right args) by regoperatorin?\n\t\t * If not, or if caller explicitly requests it, we need to qualify it.\n\t\t */\n\t\tif (force_qualify || !OperatorIsVisible(operator_oid))\n\t\t{\n\t\t\tnspname = get_namespace_name(operform->oprnamespace);\n\t\t\tappendStringInfo(&buf, \"%s.\",\n\t\t\t\t\t\t\t quote_identifier(nspname));\n\t\t}\n\n\t\tappendStringInfo(&buf, \"%s(\", oprname);\n\n\t\tif (operform->oprleft)\n\t\t\tappendStringInfo(&buf, \"%s,\",\n\t\t\t\t\t\t\t force_qualify ?\n\t\t\t\t\t\t\t format_type_be_qualified(operform->oprleft) :\n\t\t\t\t\t\t\t format_type_be(operform->oprleft));\n\t\telse\n\t\t\tappendStringInfoString(&buf, \"NONE,\");\n\n\t\tif (operform->oprright)\n\t\t\tappendStringInfo(&buf, \"%s)\",\n\t\t\t\t\t\t\t force_qualify ?\n\t\t\t\t\t\t\t format_type_be_qualified(operform->oprright) :\n\t\t\t\t\t\t\t format_type_be(operform->oprright));\n\t\telse\n\t\t\tappendStringInfoString(&buf, \"NONE)\");\n\n\t\tresult = buf.data;\n\n\t\tReleaseSysCache(opertup);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If OID doesn't match any pg_operator entry, return it numerically\n\t\t */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", operator_oid);\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_operator_qualified(Oid operator_oid)\n{\n\treturn format_operator_internal(operator_oid, true);\n}"
  },
  {
    "function_name": "format_operator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "819-823",
    "snippet": "char *\nformat_operator(Oid operator_oid)\n{\n\treturn format_operator_internal(operator_oid, false);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "format_operator_internal",
          "args": [
            "operator_oid",
            "false"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "format_operator_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "754-817",
          "snippet": "static char *\nformat_operator_internal(Oid operator_oid, bool force_qualify)\n{\n\tchar\t   *result;\n\tHeapTuple\topertup;\n\n\topertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(operator_oid));\n\n\tif (HeapTupleIsValid(opertup))\n\t{\n\t\tForm_pg_operator operform = (Form_pg_operator) GETSTRUCT(opertup);\n\t\tchar\t   *oprname = NameStr(operform->oprname);\n\t\tchar\t   *nspname;\n\t\tStringInfoData buf;\n\n\t\t/* XXX no support here for bootstrap mode */\n\t\tAssert(!IsBootstrapProcessingMode());\n\n\t\tinitStringInfo(&buf);\n\n\t\t/*\n\t\t * Would this oper be found (given the right args) by regoperatorin?\n\t\t * If not, or if caller explicitly requests it, we need to qualify it.\n\t\t */\n\t\tif (force_qualify || !OperatorIsVisible(operator_oid))\n\t\t{\n\t\t\tnspname = get_namespace_name(operform->oprnamespace);\n\t\t\tappendStringInfo(&buf, \"%s.\",\n\t\t\t\t\t\t\t quote_identifier(nspname));\n\t\t}\n\n\t\tappendStringInfo(&buf, \"%s(\", oprname);\n\n\t\tif (operform->oprleft)\n\t\t\tappendStringInfo(&buf, \"%s,\",\n\t\t\t\t\t\t\t force_qualify ?\n\t\t\t\t\t\t\t format_type_be_qualified(operform->oprleft) :\n\t\t\t\t\t\t\t format_type_be(operform->oprleft));\n\t\telse\n\t\t\tappendStringInfoString(&buf, \"NONE,\");\n\n\t\tif (operform->oprright)\n\t\t\tappendStringInfo(&buf, \"%s)\",\n\t\t\t\t\t\t\t force_qualify ?\n\t\t\t\t\t\t\t format_type_be_qualified(operform->oprright) :\n\t\t\t\t\t\t\t format_type_be(operform->oprright));\n\t\telse\n\t\t\tappendStringInfoString(&buf, \"NONE)\");\n\n\t\tresult = buf.data;\n\n\t\tReleaseSysCache(opertup);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If OID doesn't match any pg_operator entry, return it numerically\n\t\t */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", operator_oid);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *format_operator_internal(Oid operator_oid, bool force_qualify);",
            "static char *format_procedure_internal(Oid procedure_oid, bool force_qualify);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *format_operator_internal(Oid operator_oid, bool force_qualify);\nstatic char *format_procedure_internal(Oid procedure_oid, bool force_qualify);\n\nstatic char *\nformat_operator_internal(Oid operator_oid, bool force_qualify)\n{\n\tchar\t   *result;\n\tHeapTuple\topertup;\n\n\topertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(operator_oid));\n\n\tif (HeapTupleIsValid(opertup))\n\t{\n\t\tForm_pg_operator operform = (Form_pg_operator) GETSTRUCT(opertup);\n\t\tchar\t   *oprname = NameStr(operform->oprname);\n\t\tchar\t   *nspname;\n\t\tStringInfoData buf;\n\n\t\t/* XXX no support here for bootstrap mode */\n\t\tAssert(!IsBootstrapProcessingMode());\n\n\t\tinitStringInfo(&buf);\n\n\t\t/*\n\t\t * Would this oper be found (given the right args) by regoperatorin?\n\t\t * If not, or if caller explicitly requests it, we need to qualify it.\n\t\t */\n\t\tif (force_qualify || !OperatorIsVisible(operator_oid))\n\t\t{\n\t\t\tnspname = get_namespace_name(operform->oprnamespace);\n\t\t\tappendStringInfo(&buf, \"%s.\",\n\t\t\t\t\t\t\t quote_identifier(nspname));\n\t\t}\n\n\t\tappendStringInfo(&buf, \"%s(\", oprname);\n\n\t\tif (operform->oprleft)\n\t\t\tappendStringInfo(&buf, \"%s,\",\n\t\t\t\t\t\t\t force_qualify ?\n\t\t\t\t\t\t\t format_type_be_qualified(operform->oprleft) :\n\t\t\t\t\t\t\t format_type_be(operform->oprleft));\n\t\telse\n\t\t\tappendStringInfoString(&buf, \"NONE,\");\n\n\t\tif (operform->oprright)\n\t\t\tappendStringInfo(&buf, \"%s)\",\n\t\t\t\t\t\t\t force_qualify ?\n\t\t\t\t\t\t\t format_type_be_qualified(operform->oprright) :\n\t\t\t\t\t\t\t format_type_be(operform->oprright));\n\t\telse\n\t\t\tappendStringInfoString(&buf, \"NONE)\");\n\n\t\tresult = buf.data;\n\n\t\tReleaseSysCache(opertup);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If OID doesn't match any pg_operator entry, return it numerically\n\t\t */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", operator_oid);\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_operator(Oid operator_oid)\n{\n\treturn format_operator_internal(operator_oid, false);\n}"
  },
  {
    "function_name": "format_operator_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "754-817",
    "snippet": "static char *\nformat_operator_internal(Oid operator_oid, bool force_qualify)\n{\n\tchar\t   *result;\n\tHeapTuple\topertup;\n\n\topertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(operator_oid));\n\n\tif (HeapTupleIsValid(opertup))\n\t{\n\t\tForm_pg_operator operform = (Form_pg_operator) GETSTRUCT(opertup);\n\t\tchar\t   *oprname = NameStr(operform->oprname);\n\t\tchar\t   *nspname;\n\t\tStringInfoData buf;\n\n\t\t/* XXX no support here for bootstrap mode */\n\t\tAssert(!IsBootstrapProcessingMode());\n\n\t\tinitStringInfo(&buf);\n\n\t\t/*\n\t\t * Would this oper be found (given the right args) by regoperatorin?\n\t\t * If not, or if caller explicitly requests it, we need to qualify it.\n\t\t */\n\t\tif (force_qualify || !OperatorIsVisible(operator_oid))\n\t\t{\n\t\t\tnspname = get_namespace_name(operform->oprnamespace);\n\t\t\tappendStringInfo(&buf, \"%s.\",\n\t\t\t\t\t\t\t quote_identifier(nspname));\n\t\t}\n\n\t\tappendStringInfo(&buf, \"%s(\", oprname);\n\n\t\tif (operform->oprleft)\n\t\t\tappendStringInfo(&buf, \"%s,\",\n\t\t\t\t\t\t\t force_qualify ?\n\t\t\t\t\t\t\t format_type_be_qualified(operform->oprleft) :\n\t\t\t\t\t\t\t format_type_be(operform->oprleft));\n\t\telse\n\t\t\tappendStringInfoString(&buf, \"NONE,\");\n\n\t\tif (operform->oprright)\n\t\t\tappendStringInfo(&buf, \"%s)\",\n\t\t\t\t\t\t\t force_qualify ?\n\t\t\t\t\t\t\t format_type_be_qualified(operform->oprright) :\n\t\t\t\t\t\t\t format_type_be(operform->oprright));\n\t\telse\n\t\t\tappendStringInfoString(&buf, \"NONE)\");\n\n\t\tresult = buf.data;\n\n\t\tReleaseSysCache(opertup);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If OID doesn't match any pg_operator entry, return it numerically\n\t\t */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", operator_oid);\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *format_operator_internal(Oid operator_oid, bool force_qualify);",
      "static char *format_procedure_internal(Oid procedure_oid, bool force_qualify);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "NAMEDATALEN",
            "\"%u\"",
            "operator_oid"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "NAMEDATALEN"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "opertup"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "\"NONE)\""
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"%s)\"",
            "force_qualify ?\n\t\t\t\t\t\t\t format_type_be_qualified(operform->oprright) :\n\t\t\t\t\t\t\t format_type_be(operform->oprright)"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "operform->oprright"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "\"NONE,\""
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"%s,\"",
            "force_qualify ?\n\t\t\t\t\t\t\t format_type_be_qualified(operform->oprleft) :\n\t\t\t\t\t\t\t format_type_be(operform->oprleft)"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"%s(\"",
            "oprname"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"%s.\"",
            "quote_identifier(nspname)"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quote_identifier",
          "args": [
            "nspname"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "quote_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "10550-10628",
          "snippet": "const char *\nquote_identifier(const char *ident)\n{\n\t/*\n\t * Can avoid quoting if ident starts with a lowercase letter or underscore\n\t * and contains only lowercase letters, digits, and underscores, *and* is\n\t * not any SQL keyword.  Otherwise, supply quotes.\n\t */\n\tint\t\t\tnquotes = 0;\n\tbool\t\tsafe;\n\tconst char *ptr;\n\tchar\t   *result;\n\tchar\t   *optr;\n\n\t/*\n\t * would like to use <ctype.h> macros here, but they might yield unwanted\n\t * locale-specific results...\n\t */\n\tsafe = ((ident[0] >= 'a' && ident[0] <= 'z') || ident[0] == '_');\n\n\tfor (ptr = ident; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif ((ch >= 'a' && ch <= 'z') ||\n\t\t\t(ch >= '0' && ch <= '9') ||\n\t\t\t(ch == '_'))\n\t\t{\n\t\t\t/* okay */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsafe = false;\n\t\t\tif (ch == '\"')\n\t\t\t\tnquotes++;\n\t\t}\n\t}\n\n\tif (quote_all_identifiers)\n\t\tsafe = false;\n\n\tif (safe)\n\t{\n\t\t/*\n\t\t * Check for keyword.  We quote keywords except for unreserved ones.\n\t\t * (In some cases we could avoid quoting a col_name or type_func_name\n\t\t * keyword, but it seems much harder than it's worth to tell that.)\n\t\t *\n\t\t * Note: ScanKeywordLookup() does case-insensitive comparison, but\n\t\t * that's fine, since we already know we have all-lower-case.\n\t\t */\n\t\tconst ScanKeyword *keyword = ScanKeywordLookup(ident,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ScanKeywords,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   NumScanKeywords);\n\n\t\tif (keyword != NULL && keyword->category != UNRESERVED_KEYWORD)\n\t\t\tsafe = false;\n\t}\n\n\tif (safe)\n\t\treturn ident;\t\t\t/* no change needed */\n\n\tresult = (char *) palloc(strlen(ident) + nquotes + 2 + 1);\n\n\toptr = result;\n\t*optr++ = '\"';\n\tfor (ptr = ident; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif (ch == '\"')\n\t\t\t*optr++ = '\"';\n\t\t*optr++ = ch;\n\t}\n\t*optr++ = '\"';\n\t*optr = '\\0';\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool\t\tquote_all_identifiers = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\t\tquote_all_identifiers = false;\n\nconst char *\nquote_identifier(const char *ident)\n{\n\t/*\n\t * Can avoid quoting if ident starts with a lowercase letter or underscore\n\t * and contains only lowercase letters, digits, and underscores, *and* is\n\t * not any SQL keyword.  Otherwise, supply quotes.\n\t */\n\tint\t\t\tnquotes = 0;\n\tbool\t\tsafe;\n\tconst char *ptr;\n\tchar\t   *result;\n\tchar\t   *optr;\n\n\t/*\n\t * would like to use <ctype.h> macros here, but they might yield unwanted\n\t * locale-specific results...\n\t */\n\tsafe = ((ident[0] >= 'a' && ident[0] <= 'z') || ident[0] == '_');\n\n\tfor (ptr = ident; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif ((ch >= 'a' && ch <= 'z') ||\n\t\t\t(ch >= '0' && ch <= '9') ||\n\t\t\t(ch == '_'))\n\t\t{\n\t\t\t/* okay */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsafe = false;\n\t\t\tif (ch == '\"')\n\t\t\t\tnquotes++;\n\t\t}\n\t}\n\n\tif (quote_all_identifiers)\n\t\tsafe = false;\n\n\tif (safe)\n\t{\n\t\t/*\n\t\t * Check for keyword.  We quote keywords except for unreserved ones.\n\t\t * (In some cases we could avoid quoting a col_name or type_func_name\n\t\t * keyword, but it seems much harder than it's worth to tell that.)\n\t\t *\n\t\t * Note: ScanKeywordLookup() does case-insensitive comparison, but\n\t\t * that's fine, since we already know we have all-lower-case.\n\t\t */\n\t\tconst ScanKeyword *keyword = ScanKeywordLookup(ident,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ScanKeywords,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   NumScanKeywords);\n\n\t\tif (keyword != NULL && keyword->category != UNRESERVED_KEYWORD)\n\t\t\tsafe = false;\n\t}\n\n\tif (safe)\n\t\treturn ident;\t\t\t/* no change needed */\n\n\tresult = (char *) palloc(strlen(ident) + nquotes + 2 + 1);\n\n\toptr = result;\n\t*optr++ = '\"';\n\tfor (ptr = ident; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif (ch == '\"')\n\t\t\t*optr++ = '\"';\n\t\t*optr++ = ch;\n\t}\n\t*optr++ = '\"';\n\t*optr = '\\0';\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_namespace_name",
          "args": [
            "operform->oprnamespace"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OperatorIsVisible",
          "args": [
            "operator_oid"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!IsBootstrapProcessingMode()"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "operform->oprname"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "opertup"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "opertup"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "OPEROID",
            "ObjectIdGetDatum(operator_oid)"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "operator_oid"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *format_operator_internal(Oid operator_oid, bool force_qualify);\nstatic char *format_procedure_internal(Oid procedure_oid, bool force_qualify);\n\nstatic char *\nformat_operator_internal(Oid operator_oid, bool force_qualify)\n{\n\tchar\t   *result;\n\tHeapTuple\topertup;\n\n\topertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(operator_oid));\n\n\tif (HeapTupleIsValid(opertup))\n\t{\n\t\tForm_pg_operator operform = (Form_pg_operator) GETSTRUCT(opertup);\n\t\tchar\t   *oprname = NameStr(operform->oprname);\n\t\tchar\t   *nspname;\n\t\tStringInfoData buf;\n\n\t\t/* XXX no support here for bootstrap mode */\n\t\tAssert(!IsBootstrapProcessingMode());\n\n\t\tinitStringInfo(&buf);\n\n\t\t/*\n\t\t * Would this oper be found (given the right args) by regoperatorin?\n\t\t * If not, or if caller explicitly requests it, we need to qualify it.\n\t\t */\n\t\tif (force_qualify || !OperatorIsVisible(operator_oid))\n\t\t{\n\t\t\tnspname = get_namespace_name(operform->oprnamespace);\n\t\t\tappendStringInfo(&buf, \"%s.\",\n\t\t\t\t\t\t\t quote_identifier(nspname));\n\t\t}\n\n\t\tappendStringInfo(&buf, \"%s(\", oprname);\n\n\t\tif (operform->oprleft)\n\t\t\tappendStringInfo(&buf, \"%s,\",\n\t\t\t\t\t\t\t force_qualify ?\n\t\t\t\t\t\t\t format_type_be_qualified(operform->oprleft) :\n\t\t\t\t\t\t\t format_type_be(operform->oprleft));\n\t\telse\n\t\t\tappendStringInfoString(&buf, \"NONE,\");\n\n\t\tif (operform->oprright)\n\t\t\tappendStringInfo(&buf, \"%s)\",\n\t\t\t\t\t\t\t force_qualify ?\n\t\t\t\t\t\t\t format_type_be_qualified(operform->oprright) :\n\t\t\t\t\t\t\t format_type_be(operform->oprright));\n\t\telse\n\t\t\tappendStringInfoString(&buf, \"NONE)\");\n\n\t\tresult = buf.data;\n\n\t\tReleaseSysCache(opertup);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If OID doesn't match any pg_operator entry, return it numerically\n\t\t */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", operator_oid);\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "to_regoperator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "714-746",
    "snippet": "Datum\nto_regoperator(PG_FUNCTION_ARGS)\n{\n\tchar\t   *opr_name_or_oid = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tOid\t\t\tresult;\n\tList\t   *names;\n\tint\t\t\tnargs;\n\tOid\t\t\targtypes[FUNC_MAX_ARGS];\n\n\t/*\n\t * Parse the name and arguments, look up potential matches in the current\n\t * namespace search list, and scan to see which one exactly matches the\n\t * given argument types.    (There will not be more than one match.)\n\t */\n\tparseNameAndArgTypes(opr_name_or_oid, true, &names, &nargs, argtypes);\n\tif (nargs == 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_PARAMETER),\n\t\t\t\t errmsg(\"missing argument\"),\n\t\t\t\t errhint(\"Use NONE to denote the missing argument of a unary operator.\")));\n\tif (nargs != 2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_TOO_MANY_ARGUMENTS),\n\t\t\t\t errmsg(\"too many arguments\"),\n\t\t\t\t errhint(\"Provide two argument types for operator.\")));\n\n\tresult = OpernameGetOprid(names, argtypes[0], argtypes[1]);\n\n\tif (!OidIsValid(result))\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_OID(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void parseNameAndArgTypes(const char *string, bool allowNone,\n\t\t\t\t\t List **names, int *nargs, Oid *argtypes);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "result"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OpernameGetOprid",
          "args": [
            "names",
            "argtypes[0]",
            "argtypes[1]"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_TOO_MANY_ARGUMENTS),\n\t\t\t\t errmsg(\"too many arguments\"),\n\t\t\t\t errhint(\"Provide two argument types for operator.\"))"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Provide two argument types for operator.\""
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"too many arguments\""
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_TOO_MANY_ARGUMENTS"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_PARAMETER),\n\t\t\t\t errmsg(\"missing argument\"),\n\t\t\t\t errhint(\"Use NONE to denote the missing argument of a unary operator.\"))"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseNameAndArgTypes",
          "args": [
            "opr_name_or_oid",
            "true",
            "&names",
            "&nargs",
            "argtypes"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "parseNameAndArgTypes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "1734-1872",
          "snippet": "static void\nparseNameAndArgTypes(const char *string, bool allowNone, List **names,\n\t\t\t\t\t int *nargs, Oid *argtypes)\n{\n\tchar\t   *rawname;\n\tchar\t   *ptr;\n\tchar\t   *ptr2;\n\tchar\t   *typename;\n\tbool\t\tin_quote;\n\tbool\t\thad_comma;\n\tint\t\t\tparen_count;\n\tOid\t\t\ttypeid;\n\tint32\t\ttypmod;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\t/* Scan to find the expected left paren; mustn't be quoted */\n\tin_quote = false;\n\tfor (ptr = rawname; *ptr; ptr++)\n\t{\n\t\tif (*ptr == '\"')\n\t\t\tin_quote = !in_quote;\n\t\telse if (*ptr == '(' && !in_quote)\n\t\t\tbreak;\n\t}\n\tif (*ptr == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a left parenthesis\")));\n\n\t/* Separate the name and parse it into a list */\n\t*ptr++ = '\\0';\n\t*names = stringToQualifiedNameList(rawname);\n\n\t/* Check for the trailing right parenthesis and remove it */\n\tptr2 = ptr + strlen(ptr);\n\twhile (--ptr2 > ptr)\n\t{\n\t\tif (!scanner_isspace(*ptr2))\n\t\t\tbreak;\n\t}\n\tif (*ptr2 != ')')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a right parenthesis\")));\n\n\t*ptr2 = '\\0';\n\n\t/* Separate the remaining string into comma-separated type names */\n\t*nargs = 0;\n\thad_comma = false;\n\n\tfor (;;)\n\t{\n\t\t/* allow leading whitespace */\n\t\twhile (scanner_isspace(*ptr))\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t{\n\t\t\t/* End of string.  Okay unless we had a comma before. */\n\t\t\tif (had_comma)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"expected a type name\")));\n\t\t\tbreak;\n\t\t}\n\t\ttypename = ptr;\n\t\t/* Find end of type name --- end of string or comma */\n\t\t/* ... but not a quoted or parenthesized comma */\n\t\tin_quote = false;\n\t\tparen_count = 0;\n\t\tfor (; *ptr; ptr++)\n\t\t{\n\t\t\tif (*ptr == '\"')\n\t\t\t\tin_quote = !in_quote;\n\t\t\telse if (*ptr == ',' && !in_quote && paren_count == 0)\n\t\t\t\tbreak;\n\t\t\telse if (!in_quote)\n\t\t\t{\n\t\t\t\tswitch (*ptr)\n\t\t\t\t{\n\t\t\t\t\tcase '(':\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tparen_count++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ')':\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tparen_count--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (in_quote || paren_count != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"improper type name\")));\n\n\t\tptr2 = ptr;\n\t\tif (*ptr == ',')\n\t\t{\n\t\t\thad_comma = true;\n\t\t\t*ptr++ = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\thad_comma = false;\n\t\t\tAssert(*ptr == '\\0');\n\t\t}\n\t\t/* Lop off trailing whitespace */\n\t\twhile (--ptr2 >= typename)\n\t\t{\n\t\t\tif (!scanner_isspace(*ptr2))\n\t\t\t\tbreak;\n\t\t\t*ptr2 = '\\0';\n\t\t}\n\n\t\tif (allowNone && pg_strcasecmp(typename, \"none\") == 0)\n\t\t{\n\t\t\t/* Special case for NONE */\n\t\t\ttypeid = InvalidOid;\n\t\t\ttypmod = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Use full parser to resolve the type name */\n\t\t\tparseTypeString(typename, &typeid, &typmod, false);\n\t\t}\n\t\tif (*nargs >= FUNC_MAX_ARGS)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_ARGUMENTS),\n\t\t\t\t\t errmsg(\"too many arguments\")));\n\n\t\targtypes[*nargs] = typeid;\n\t\t(*nargs)++;\n\t}\n\n\tpfree(rawname);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void parseNameAndArgTypes(const char *string, bool allowNone,\n\t\t\t\t\t List **names, int *nargs, Oid *argtypes);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void parseNameAndArgTypes(const char *string, bool allowNone,\n\t\t\t\t\t List **names, int *nargs, Oid *argtypes);\n\nstatic void\nparseNameAndArgTypes(const char *string, bool allowNone, List **names,\n\t\t\t\t\t int *nargs, Oid *argtypes)\n{\n\tchar\t   *rawname;\n\tchar\t   *ptr;\n\tchar\t   *ptr2;\n\tchar\t   *typename;\n\tbool\t\tin_quote;\n\tbool\t\thad_comma;\n\tint\t\t\tparen_count;\n\tOid\t\t\ttypeid;\n\tint32\t\ttypmod;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\t/* Scan to find the expected left paren; mustn't be quoted */\n\tin_quote = false;\n\tfor (ptr = rawname; *ptr; ptr++)\n\t{\n\t\tif (*ptr == '\"')\n\t\t\tin_quote = !in_quote;\n\t\telse if (*ptr == '(' && !in_quote)\n\t\t\tbreak;\n\t}\n\tif (*ptr == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a left parenthesis\")));\n\n\t/* Separate the name and parse it into a list */\n\t*ptr++ = '\\0';\n\t*names = stringToQualifiedNameList(rawname);\n\n\t/* Check for the trailing right parenthesis and remove it */\n\tptr2 = ptr + strlen(ptr);\n\twhile (--ptr2 > ptr)\n\t{\n\t\tif (!scanner_isspace(*ptr2))\n\t\t\tbreak;\n\t}\n\tif (*ptr2 != ')')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a right parenthesis\")));\n\n\t*ptr2 = '\\0';\n\n\t/* Separate the remaining string into comma-separated type names */\n\t*nargs = 0;\n\thad_comma = false;\n\n\tfor (;;)\n\t{\n\t\t/* allow leading whitespace */\n\t\twhile (scanner_isspace(*ptr))\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t{\n\t\t\t/* End of string.  Okay unless we had a comma before. */\n\t\t\tif (had_comma)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"expected a type name\")));\n\t\t\tbreak;\n\t\t}\n\t\ttypename = ptr;\n\t\t/* Find end of type name --- end of string or comma */\n\t\t/* ... but not a quoted or parenthesized comma */\n\t\tin_quote = false;\n\t\tparen_count = 0;\n\t\tfor (; *ptr; ptr++)\n\t\t{\n\t\t\tif (*ptr == '\"')\n\t\t\t\tin_quote = !in_quote;\n\t\t\telse if (*ptr == ',' && !in_quote && paren_count == 0)\n\t\t\t\tbreak;\n\t\t\telse if (!in_quote)\n\t\t\t{\n\t\t\t\tswitch (*ptr)\n\t\t\t\t{\n\t\t\t\t\tcase '(':\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tparen_count++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ')':\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tparen_count--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (in_quote || paren_count != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"improper type name\")));\n\n\t\tptr2 = ptr;\n\t\tif (*ptr == ',')\n\t\t{\n\t\t\thad_comma = true;\n\t\t\t*ptr++ = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\thad_comma = false;\n\t\t\tAssert(*ptr == '\\0');\n\t\t}\n\t\t/* Lop off trailing whitespace */\n\t\twhile (--ptr2 >= typename)\n\t\t{\n\t\t\tif (!scanner_isspace(*ptr2))\n\t\t\t\tbreak;\n\t\t\t*ptr2 = '\\0';\n\t\t}\n\n\t\tif (allowNone && pg_strcasecmp(typename, \"none\") == 0)\n\t\t{\n\t\t\t/* Special case for NONE */\n\t\t\ttypeid = InvalidOid;\n\t\t\ttypmod = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Use full parser to resolve the type name */\n\t\t\tparseTypeString(typename, &typeid, &typmod, false);\n\t\t}\n\t\tif (*nargs >= FUNC_MAX_ARGS)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_ARGUMENTS),\n\t\t\t\t\t errmsg(\"too many arguments\")));\n\n\t\targtypes[*nargs] = typeid;\n\t\t(*nargs)++;\n\t}\n\n\tpfree(rawname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(0)"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void parseNameAndArgTypes(const char *string, bool allowNone,\n\t\t\t\t\t List **names, int *nargs, Oid *argtypes);\n\nDatum\nto_regoperator(PG_FUNCTION_ARGS)\n{\n\tchar\t   *opr_name_or_oid = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tOid\t\t\tresult;\n\tList\t   *names;\n\tint\t\t\tnargs;\n\tOid\t\t\targtypes[FUNC_MAX_ARGS];\n\n\t/*\n\t * Parse the name and arguments, look up potential matches in the current\n\t * namespace search list, and scan to see which one exactly matches the\n\t * given argument types.    (There will not be more than one match.)\n\t */\n\tparseNameAndArgTypes(opr_name_or_oid, true, &names, &nargs, argtypes);\n\tif (nargs == 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_PARAMETER),\n\t\t\t\t errmsg(\"missing argument\"),\n\t\t\t\t errhint(\"Use NONE to denote the missing argument of a unary operator.\")));\n\tif (nargs != 2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_TOO_MANY_ARGUMENTS),\n\t\t\t\t errmsg(\"too many arguments\"),\n\t\t\t\t errhint(\"Provide two argument types for operator.\")));\n\n\tresult = OpernameGetOprid(names, argtypes[0], argtypes[1]);\n\n\tif (!OidIsValid(result))\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_OID(result);\n}"
  },
  {
    "function_name": "regoperatorin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "654-707",
    "snippet": "Datum\nregoperatorin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *opr_name_or_oid = PG_GETARG_CSTRING(0);\n\tOid\t\t\tresult;\n\tList\t   *names;\n\tint\t\t\tnargs;\n\tOid\t\t\targtypes[FUNC_MAX_ARGS];\n\n\t/* '0' ? */\n\tif (strcmp(opr_name_or_oid, \"0\") == 0)\n\t\tPG_RETURN_OID(InvalidOid);\n\n\t/* Numeric OID? */\n\tif (opr_name_or_oid[0] >= '0' &&\n\t\topr_name_or_oid[0] <= '9' &&\n\t\tstrspn(opr_name_or_oid, \"0123456789\") == strlen(opr_name_or_oid))\n\t{\n\t\tresult = DatumGetObjectId(DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(opr_name_or_oid)));\n\t\tPG_RETURN_OID(result);\n\t}\n\n\t/* The rest of this wouldn't work in bootstrap mode */\n\tif (IsBootstrapProcessingMode())\n\t\telog(ERROR, \"regoperator values must be OIDs in bootstrap mode\");\n\n\t/*\n\t * Else it's a name and arguments.  Parse the name and arguments, look up\n\t * potential matches in the current namespace search list, and scan to see\n\t * which one exactly matches the given argument types.  (There will not be\n\t * more than one match.)\n\t */\n\tparseNameAndArgTypes(opr_name_or_oid, true, &names, &nargs, argtypes);\n\tif (nargs == 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_PARAMETER),\n\t\t\t\t errmsg(\"missing argument\"),\n\t\t\t\t errhint(\"Use NONE to denote the missing argument of a unary operator.\")));\n\tif (nargs != 2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_TOO_MANY_ARGUMENTS),\n\t\t\t\t errmsg(\"too many arguments\"),\n\t\t\t\t errhint(\"Provide two argument types for operator.\")));\n\n\tresult = OpernameGetOprid(names, argtypes[0], argtypes[1]);\n\n\tif (!OidIsValid(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"operator does not exist: %s\", opr_name_or_oid)));\n\n\tPG_RETURN_OID(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void parseNameAndArgTypes(const char *string, bool allowNone,\n\t\t\t\t\t List **names, int *nargs, Oid *argtypes);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"operator does not exist: %s\", opr_name_or_oid))"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"operator does not exist: %s\"",
            "opr_name_or_oid"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_FUNCTION"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "OidIsValid",
          "args": [
            "result"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OpernameGetOprid",
          "args": [
            "names",
            "argtypes[0]",
            "argtypes[1]"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_TOO_MANY_ARGUMENTS),\n\t\t\t\t errmsg(\"too many arguments\"),\n\t\t\t\t errhint(\"Provide two argument types for operator.\"))"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errhint",
          "args": [
            "\"Provide two argument types for operator.\""
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "errhint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "984-999",
          "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_PARAMETER),\n\t\t\t\t errmsg(\"missing argument\"),\n\t\t\t\t errhint(\"Use NONE to denote the missing argument of a unary operator.\"))"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseNameAndArgTypes",
          "args": [
            "opr_name_or_oid",
            "true",
            "&names",
            "&nargs",
            "argtypes"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "parseNameAndArgTypes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "1734-1872",
          "snippet": "static void\nparseNameAndArgTypes(const char *string, bool allowNone, List **names,\n\t\t\t\t\t int *nargs, Oid *argtypes)\n{\n\tchar\t   *rawname;\n\tchar\t   *ptr;\n\tchar\t   *ptr2;\n\tchar\t   *typename;\n\tbool\t\tin_quote;\n\tbool\t\thad_comma;\n\tint\t\t\tparen_count;\n\tOid\t\t\ttypeid;\n\tint32\t\ttypmod;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\t/* Scan to find the expected left paren; mustn't be quoted */\n\tin_quote = false;\n\tfor (ptr = rawname; *ptr; ptr++)\n\t{\n\t\tif (*ptr == '\"')\n\t\t\tin_quote = !in_quote;\n\t\telse if (*ptr == '(' && !in_quote)\n\t\t\tbreak;\n\t}\n\tif (*ptr == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a left parenthesis\")));\n\n\t/* Separate the name and parse it into a list */\n\t*ptr++ = '\\0';\n\t*names = stringToQualifiedNameList(rawname);\n\n\t/* Check for the trailing right parenthesis and remove it */\n\tptr2 = ptr + strlen(ptr);\n\twhile (--ptr2 > ptr)\n\t{\n\t\tif (!scanner_isspace(*ptr2))\n\t\t\tbreak;\n\t}\n\tif (*ptr2 != ')')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a right parenthesis\")));\n\n\t*ptr2 = '\\0';\n\n\t/* Separate the remaining string into comma-separated type names */\n\t*nargs = 0;\n\thad_comma = false;\n\n\tfor (;;)\n\t{\n\t\t/* allow leading whitespace */\n\t\twhile (scanner_isspace(*ptr))\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t{\n\t\t\t/* End of string.  Okay unless we had a comma before. */\n\t\t\tif (had_comma)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"expected a type name\")));\n\t\t\tbreak;\n\t\t}\n\t\ttypename = ptr;\n\t\t/* Find end of type name --- end of string or comma */\n\t\t/* ... but not a quoted or parenthesized comma */\n\t\tin_quote = false;\n\t\tparen_count = 0;\n\t\tfor (; *ptr; ptr++)\n\t\t{\n\t\t\tif (*ptr == '\"')\n\t\t\t\tin_quote = !in_quote;\n\t\t\telse if (*ptr == ',' && !in_quote && paren_count == 0)\n\t\t\t\tbreak;\n\t\t\telse if (!in_quote)\n\t\t\t{\n\t\t\t\tswitch (*ptr)\n\t\t\t\t{\n\t\t\t\t\tcase '(':\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tparen_count++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ')':\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tparen_count--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (in_quote || paren_count != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"improper type name\")));\n\n\t\tptr2 = ptr;\n\t\tif (*ptr == ',')\n\t\t{\n\t\t\thad_comma = true;\n\t\t\t*ptr++ = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\thad_comma = false;\n\t\t\tAssert(*ptr == '\\0');\n\t\t}\n\t\t/* Lop off trailing whitespace */\n\t\twhile (--ptr2 >= typename)\n\t\t{\n\t\t\tif (!scanner_isspace(*ptr2))\n\t\t\t\tbreak;\n\t\t\t*ptr2 = '\\0';\n\t\t}\n\n\t\tif (allowNone && pg_strcasecmp(typename, \"none\") == 0)\n\t\t{\n\t\t\t/* Special case for NONE */\n\t\t\ttypeid = InvalidOid;\n\t\t\ttypmod = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Use full parser to resolve the type name */\n\t\t\tparseTypeString(typename, &typeid, &typmod, false);\n\t\t}\n\t\tif (*nargs >= FUNC_MAX_ARGS)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_ARGUMENTS),\n\t\t\t\t\t errmsg(\"too many arguments\")));\n\n\t\targtypes[*nargs] = typeid;\n\t\t(*nargs)++;\n\t}\n\n\tpfree(rawname);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void parseNameAndArgTypes(const char *string, bool allowNone,\n\t\t\t\t\t List **names, int *nargs, Oid *argtypes);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void parseNameAndArgTypes(const char *string, bool allowNone,\n\t\t\t\t\t List **names, int *nargs, Oid *argtypes);\n\nstatic void\nparseNameAndArgTypes(const char *string, bool allowNone, List **names,\n\t\t\t\t\t int *nargs, Oid *argtypes)\n{\n\tchar\t   *rawname;\n\tchar\t   *ptr;\n\tchar\t   *ptr2;\n\tchar\t   *typename;\n\tbool\t\tin_quote;\n\tbool\t\thad_comma;\n\tint\t\t\tparen_count;\n\tOid\t\t\ttypeid;\n\tint32\t\ttypmod;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\t/* Scan to find the expected left paren; mustn't be quoted */\n\tin_quote = false;\n\tfor (ptr = rawname; *ptr; ptr++)\n\t{\n\t\tif (*ptr == '\"')\n\t\t\tin_quote = !in_quote;\n\t\telse if (*ptr == '(' && !in_quote)\n\t\t\tbreak;\n\t}\n\tif (*ptr == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a left parenthesis\")));\n\n\t/* Separate the name and parse it into a list */\n\t*ptr++ = '\\0';\n\t*names = stringToQualifiedNameList(rawname);\n\n\t/* Check for the trailing right parenthesis and remove it */\n\tptr2 = ptr + strlen(ptr);\n\twhile (--ptr2 > ptr)\n\t{\n\t\tif (!scanner_isspace(*ptr2))\n\t\t\tbreak;\n\t}\n\tif (*ptr2 != ')')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a right parenthesis\")));\n\n\t*ptr2 = '\\0';\n\n\t/* Separate the remaining string into comma-separated type names */\n\t*nargs = 0;\n\thad_comma = false;\n\n\tfor (;;)\n\t{\n\t\t/* allow leading whitespace */\n\t\twhile (scanner_isspace(*ptr))\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t{\n\t\t\t/* End of string.  Okay unless we had a comma before. */\n\t\t\tif (had_comma)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"expected a type name\")));\n\t\t\tbreak;\n\t\t}\n\t\ttypename = ptr;\n\t\t/* Find end of type name --- end of string or comma */\n\t\t/* ... but not a quoted or parenthesized comma */\n\t\tin_quote = false;\n\t\tparen_count = 0;\n\t\tfor (; *ptr; ptr++)\n\t\t{\n\t\t\tif (*ptr == '\"')\n\t\t\t\tin_quote = !in_quote;\n\t\t\telse if (*ptr == ',' && !in_quote && paren_count == 0)\n\t\t\t\tbreak;\n\t\t\telse if (!in_quote)\n\t\t\t{\n\t\t\t\tswitch (*ptr)\n\t\t\t\t{\n\t\t\t\t\tcase '(':\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tparen_count++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ')':\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tparen_count--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (in_quote || paren_count != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"improper type name\")));\n\n\t\tptr2 = ptr;\n\t\tif (*ptr == ',')\n\t\t{\n\t\t\thad_comma = true;\n\t\t\t*ptr++ = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\thad_comma = false;\n\t\t\tAssert(*ptr == '\\0');\n\t\t}\n\t\t/* Lop off trailing whitespace */\n\t\twhile (--ptr2 >= typename)\n\t\t{\n\t\t\tif (!scanner_isspace(*ptr2))\n\t\t\t\tbreak;\n\t\t\t*ptr2 = '\\0';\n\t\t}\n\n\t\tif (allowNone && pg_strcasecmp(typename, \"none\") == 0)\n\t\t{\n\t\t\t/* Special case for NONE */\n\t\t\ttypeid = InvalidOid;\n\t\t\ttypmod = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Use full parser to resolve the type name */\n\t\t\tparseTypeString(typename, &typeid, &typmod, false);\n\t\t}\n\t\tif (*nargs >= FUNC_MAX_ARGS)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_ARGUMENTS),\n\t\t\t\t\t errmsg(\"too many arguments\")));\n\n\t\targtypes[*nargs] = typeid;\n\t\t(*nargs)++;\n\t}\n\n\tpfree(rawname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"regoperator values must be OIDs in bootstrap mode\""
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetObjectId",
          "args": [
            "DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(opr_name_or_oid))"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "oidin",
            "CStringGetDatum(opr_name_or_oid)"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "opr_name_or_oid"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "opr_name_or_oid"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "opr_name_or_oid",
            "\"0123456789\""
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "InvalidOid"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opr_name_or_oid",
            "\"0\""
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void parseNameAndArgTypes(const char *string, bool allowNone,\n\t\t\t\t\t List **names, int *nargs, Oid *argtypes);\n\nDatum\nregoperatorin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *opr_name_or_oid = PG_GETARG_CSTRING(0);\n\tOid\t\t\tresult;\n\tList\t   *names;\n\tint\t\t\tnargs;\n\tOid\t\t\targtypes[FUNC_MAX_ARGS];\n\n\t/* '0' ? */\n\tif (strcmp(opr_name_or_oid, \"0\") == 0)\n\t\tPG_RETURN_OID(InvalidOid);\n\n\t/* Numeric OID? */\n\tif (opr_name_or_oid[0] >= '0' &&\n\t\topr_name_or_oid[0] <= '9' &&\n\t\tstrspn(opr_name_or_oid, \"0123456789\") == strlen(opr_name_or_oid))\n\t{\n\t\tresult = DatumGetObjectId(DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(opr_name_or_oid)));\n\t\tPG_RETURN_OID(result);\n\t}\n\n\t/* The rest of this wouldn't work in bootstrap mode */\n\tif (IsBootstrapProcessingMode())\n\t\telog(ERROR, \"regoperator values must be OIDs in bootstrap mode\");\n\n\t/*\n\t * Else it's a name and arguments.  Parse the name and arguments, look up\n\t * potential matches in the current namespace search list, and scan to see\n\t * which one exactly matches the given argument types.  (There will not be\n\t * more than one match.)\n\t */\n\tparseNameAndArgTypes(opr_name_or_oid, true, &names, &nargs, argtypes);\n\tif (nargs == 1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_PARAMETER),\n\t\t\t\t errmsg(\"missing argument\"),\n\t\t\t\t errhint(\"Use NONE to denote the missing argument of a unary operator.\")));\n\tif (nargs != 2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_TOO_MANY_ARGUMENTS),\n\t\t\t\t errmsg(\"too many arguments\"),\n\t\t\t\t errhint(\"Provide two argument types for operator.\")));\n\n\tresult = OpernameGetOprid(names, argtypes[0], argtypes[1]);\n\n\tif (!OidIsValid(result))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"operator does not exist: %s\", opr_name_or_oid)));\n\n\tPG_RETURN_OID(result);\n}"
  },
  {
    "function_name": "regopersend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "638-643",
    "snippet": "Datum\nregopersend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidsend, so share code */\n\treturn oidsend(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oidsend",
          "args": [
            "fcinfo"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "oidsend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "150-159",
          "snippet": "Datum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregopersend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidsend, so share code */\n\treturn oidsend(fcinfo);\n}"
  },
  {
    "function_name": "regoperrecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "628-633",
    "snippet": "Datum\nregoperrecv(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidrecv, so share code */\n\treturn oidrecv(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oidrecv",
          "args": [
            "fcinfo"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "oidrecv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "139-145",
          "snippet": "Datum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregoperrecv(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidrecv, so share code */\n\treturn oidrecv(fcinfo);\n}"
  },
  {
    "function_name": "regoperout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "560-623",
    "snippet": "Datum\nregoperout(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\toprid = PG_GETARG_OID(0);\n\tchar\t   *result;\n\tHeapTuple\topertup;\n\n\tif (oprid == InvalidOid)\n\t{\n\t\tresult = pstrdup(\"0\");\n\t\tPG_RETURN_CSTRING(result);\n\t}\n\n\topertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(oprid));\n\n\tif (HeapTupleIsValid(opertup))\n\t{\n\t\tForm_pg_operator operform = (Form_pg_operator) GETSTRUCT(opertup);\n\t\tchar\t   *oprname = NameStr(operform->oprname);\n\n\t\t/*\n\t\t * In bootstrap mode, skip the fancy namespace stuff and just return\n\t\t * the oper name.  (This path is only needed for debugging output\n\t\t * anyway.)\n\t\t */\n\t\tif (IsBootstrapProcessingMode())\n\t\t\tresult = pstrdup(oprname);\n\t\telse\n\t\t{\n\t\t\tFuncCandidateList clist;\n\n\t\t\t/*\n\t\t\t * Would this oper be found (uniquely!) by regoperin? If not,\n\t\t\t * qualify it.\n\t\t\t */\n\t\t\tclist = OpernameGetCandidates(list_make1(makeString(oprname)),\n\t\t\t\t\t\t\t\t\t\t  '\\0', false);\n\t\t\tif (clist != NULL && clist->next == NULL &&\n\t\t\t\tclist->oid == oprid)\n\t\t\t\tresult = pstrdup(oprname);\n\t\t\telse\n\t\t\t{\n\t\t\t\tconst char *nspname;\n\n\t\t\t\tnspname = get_namespace_name(operform->oprnamespace);\n\t\t\t\tnspname = quote_identifier(nspname);\n\t\t\t\tresult = (char *) palloc(strlen(nspname) + strlen(oprname) + 2);\n\t\t\t\tsprintf(result, \"%s.%s\", nspname, oprname);\n\t\t\t}\n\t\t}\n\n\t\tReleaseSysCache(opertup);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If OID doesn't match any pg_operator entry, return it numerically\n\t\t */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", oprid);\n\t}\n\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "NAMEDATALEN",
            "\"%u\"",
            "oprid"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "NAMEDATALEN"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "opertup"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "result",
            "\"%s.%s\"",
            "nspname",
            "oprname"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "oprname"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "quote_identifier",
          "args": [
            "nspname"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "quote_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "10550-10628",
          "snippet": "const char *\nquote_identifier(const char *ident)\n{\n\t/*\n\t * Can avoid quoting if ident starts with a lowercase letter or underscore\n\t * and contains only lowercase letters, digits, and underscores, *and* is\n\t * not any SQL keyword.  Otherwise, supply quotes.\n\t */\n\tint\t\t\tnquotes = 0;\n\tbool\t\tsafe;\n\tconst char *ptr;\n\tchar\t   *result;\n\tchar\t   *optr;\n\n\t/*\n\t * would like to use <ctype.h> macros here, but they might yield unwanted\n\t * locale-specific results...\n\t */\n\tsafe = ((ident[0] >= 'a' && ident[0] <= 'z') || ident[0] == '_');\n\n\tfor (ptr = ident; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif ((ch >= 'a' && ch <= 'z') ||\n\t\t\t(ch >= '0' && ch <= '9') ||\n\t\t\t(ch == '_'))\n\t\t{\n\t\t\t/* okay */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsafe = false;\n\t\t\tif (ch == '\"')\n\t\t\t\tnquotes++;\n\t\t}\n\t}\n\n\tif (quote_all_identifiers)\n\t\tsafe = false;\n\n\tif (safe)\n\t{\n\t\t/*\n\t\t * Check for keyword.  We quote keywords except for unreserved ones.\n\t\t * (In some cases we could avoid quoting a col_name or type_func_name\n\t\t * keyword, but it seems much harder than it's worth to tell that.)\n\t\t *\n\t\t * Note: ScanKeywordLookup() does case-insensitive comparison, but\n\t\t * that's fine, since we already know we have all-lower-case.\n\t\t */\n\t\tconst ScanKeyword *keyword = ScanKeywordLookup(ident,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ScanKeywords,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   NumScanKeywords);\n\n\t\tif (keyword != NULL && keyword->category != UNRESERVED_KEYWORD)\n\t\t\tsafe = false;\n\t}\n\n\tif (safe)\n\t\treturn ident;\t\t\t/* no change needed */\n\n\tresult = (char *) palloc(strlen(ident) + nquotes + 2 + 1);\n\n\toptr = result;\n\t*optr++ = '\"';\n\tfor (ptr = ident; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif (ch == '\"')\n\t\t\t*optr++ = '\"';\n\t\t*optr++ = ch;\n\t}\n\t*optr++ = '\"';\n\t*optr = '\\0';\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool\t\tquote_all_identifiers = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nbool\t\tquote_all_identifiers = false;\n\nconst char *\nquote_identifier(const char *ident)\n{\n\t/*\n\t * Can avoid quoting if ident starts with a lowercase letter or underscore\n\t * and contains only lowercase letters, digits, and underscores, *and* is\n\t * not any SQL keyword.  Otherwise, supply quotes.\n\t */\n\tint\t\t\tnquotes = 0;\n\tbool\t\tsafe;\n\tconst char *ptr;\n\tchar\t   *result;\n\tchar\t   *optr;\n\n\t/*\n\t * would like to use <ctype.h> macros here, but they might yield unwanted\n\t * locale-specific results...\n\t */\n\tsafe = ((ident[0] >= 'a' && ident[0] <= 'z') || ident[0] == '_');\n\n\tfor (ptr = ident; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif ((ch >= 'a' && ch <= 'z') ||\n\t\t\t(ch >= '0' && ch <= '9') ||\n\t\t\t(ch == '_'))\n\t\t{\n\t\t\t/* okay */\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsafe = false;\n\t\t\tif (ch == '\"')\n\t\t\t\tnquotes++;\n\t\t}\n\t}\n\n\tif (quote_all_identifiers)\n\t\tsafe = false;\n\n\tif (safe)\n\t{\n\t\t/*\n\t\t * Check for keyword.  We quote keywords except for unreserved ones.\n\t\t * (In some cases we could avoid quoting a col_name or type_func_name\n\t\t * keyword, but it seems much harder than it's worth to tell that.)\n\t\t *\n\t\t * Note: ScanKeywordLookup() does case-insensitive comparison, but\n\t\t * that's fine, since we already know we have all-lower-case.\n\t\t */\n\t\tconst ScanKeyword *keyword = ScanKeywordLookup(ident,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ScanKeywords,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   NumScanKeywords);\n\n\t\tif (keyword != NULL && keyword->category != UNRESERVED_KEYWORD)\n\t\t\tsafe = false;\n\t}\n\n\tif (safe)\n\t\treturn ident;\t\t\t/* no change needed */\n\n\tresult = (char *) palloc(strlen(ident) + nquotes + 2 + 1);\n\n\toptr = result;\n\t*optr++ = '\"';\n\tfor (ptr = ident; *ptr; ptr++)\n\t{\n\t\tchar\t\tch = *ptr;\n\n\t\tif (ch == '\"')\n\t\t\t*optr++ = '\"';\n\t\t*optr++ = ch;\n\t}\n\t*optr++ = '\"';\n\t*optr = '\\0';\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_namespace_name",
          "args": [
            "operform->oprnamespace"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "oprname"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OpernameGetCandidates",
          "args": [
            "list_make1(makeString(oprname))",
            "'\\0'",
            "false"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_make1",
          "args": [
            "makeString(oprname)"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeString",
          "args": [
            "oprname"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "makeStringAggState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4765-4787",
          "snippet": "static StringInfo\nmakeStringAggState(FunctionCallInfo fcinfo)\n{\n\tStringInfo\tstate;\n\tMemoryContext aggcontext;\n\tMemoryContext oldcontext;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"string_agg_transfn called in non-aggregate context\");\n\t}\n\n\t/*\n\t * Create state in aggregate context.  It'll stay there across subsequent\n\t * calls.\n\t */\n\toldcontext = MemoryContextSwitchTo(aggcontext);\n\tstate = makeStringInfo();\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\n\nstatic StringInfo\nmakeStringAggState(FunctionCallInfo fcinfo)\n{\n\tStringInfo\tstate;\n\tMemoryContext aggcontext;\n\tMemoryContext oldcontext;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"string_agg_transfn called in non-aggregate context\");\n\t}\n\n\t/*\n\t * Create state in aggregate context.  It'll stay there across subsequent\n\t * calls.\n\t */\n\toldcontext = MemoryContextSwitchTo(aggcontext);\n\tstate = makeStringInfo();\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "operform->oprname"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "opertup"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "opertup"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "OPEROID",
            "ObjectIdGetDatum(oprid)"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "oprid"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregoperout(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\toprid = PG_GETARG_OID(0);\n\tchar\t   *result;\n\tHeapTuple\topertup;\n\n\tif (oprid == InvalidOid)\n\t{\n\t\tresult = pstrdup(\"0\");\n\t\tPG_RETURN_CSTRING(result);\n\t}\n\n\topertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(oprid));\n\n\tif (HeapTupleIsValid(opertup))\n\t{\n\t\tForm_pg_operator operform = (Form_pg_operator) GETSTRUCT(opertup);\n\t\tchar\t   *oprname = NameStr(operform->oprname);\n\n\t\t/*\n\t\t * In bootstrap mode, skip the fancy namespace stuff and just return\n\t\t * the oper name.  (This path is only needed for debugging output\n\t\t * anyway.)\n\t\t */\n\t\tif (IsBootstrapProcessingMode())\n\t\t\tresult = pstrdup(oprname);\n\t\telse\n\t\t{\n\t\t\tFuncCandidateList clist;\n\n\t\t\t/*\n\t\t\t * Would this oper be found (uniquely!) by regoperin? If not,\n\t\t\t * qualify it.\n\t\t\t */\n\t\t\tclist = OpernameGetCandidates(list_make1(makeString(oprname)),\n\t\t\t\t\t\t\t\t\t\t  '\\0', false);\n\t\t\tif (clist != NULL && clist->next == NULL &&\n\t\t\t\tclist->oid == oprid)\n\t\t\t\tresult = pstrdup(oprname);\n\t\t\telse\n\t\t\t{\n\t\t\t\tconst char *nspname;\n\n\t\t\t\tnspname = get_namespace_name(operform->oprnamespace);\n\t\t\t\tnspname = quote_identifier(nspname);\n\t\t\t\tresult = (char *) palloc(strlen(nspname) + strlen(oprname) + 2);\n\t\t\t\tsprintf(result, \"%s.%s\", nspname, oprname);\n\t\t\t}\n\t\t}\n\n\t\tReleaseSysCache(opertup);\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * If OID doesn't match any pg_operator entry, return it numerically\n\t\t */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", oprid);\n\t}\n\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "to_regoper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "537-555",
    "snippet": "Datum\nto_regoper(PG_FUNCTION_ARGS)\n{\n\tchar\t   *opr_name = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tList\t   *names;\n\tFuncCandidateList clist;\n\n\t/*\n\t * Parse the name into components and see if it matches any pg_operator\n\t * entries in the current search path.\n\t */\n\tnames = stringToQualifiedNameList(opr_name);\n\tclist = OpernameGetCandidates(names, '\\0', true);\n\n\tif (clist == NULL || clist->next != NULL)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_OID(clist->oid);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "clist->oid"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OpernameGetCandidates",
          "args": [
            "names",
            "'\\0'",
            "true"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringToQualifiedNameList",
          "args": [
            "opr_name"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "stringToQualifiedNameList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "1686-1718",
          "snippet": "List *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(0)"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nto_regoper(PG_FUNCTION_ARGS)\n{\n\tchar\t   *opr_name = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tList\t   *names;\n\tFuncCandidateList clist;\n\n\t/*\n\t * Parse the name into components and see if it matches any pg_operator\n\t * entries in the current search path.\n\t */\n\tnames = stringToQualifiedNameList(opr_name);\n\tclist = OpernameGetCandidates(names, '\\0', true);\n\n\tif (clist == NULL || clist->next != NULL)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_OID(clist->oid);\n}"
  },
  {
    "function_name": "regoperin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "482-530",
    "snippet": "Datum\nregoperin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *opr_name_or_oid = PG_GETARG_CSTRING(0);\n\tOid\t\t\tresult = InvalidOid;\n\tList\t   *names;\n\tFuncCandidateList clist;\n\n\t/* '0' ? */\n\tif (strcmp(opr_name_or_oid, \"0\") == 0)\n\t\tPG_RETURN_OID(InvalidOid);\n\n\t/* Numeric OID? */\n\tif (opr_name_or_oid[0] >= '0' &&\n\t\topr_name_or_oid[0] <= '9' &&\n\t\tstrspn(opr_name_or_oid, \"0123456789\") == strlen(opr_name_or_oid))\n\t{\n\t\tresult = DatumGetObjectId(DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(opr_name_or_oid)));\n\t\tPG_RETURN_OID(result);\n\t}\n\n\t/* Else it's a name, possibly schema-qualified */\n\n\t/* The rest of this wouldn't work in bootstrap mode */\n\tif (IsBootstrapProcessingMode())\n\t\telog(ERROR, \"regoper values must be OIDs in bootstrap mode\");\n\n\t/*\n\t * Normal case: parse the name into components and see if it matches any\n\t * pg_operator entries in the current search path.\n\t */\n\tnames = stringToQualifiedNameList(opr_name_or_oid);\n\tclist = OpernameGetCandidates(names, '\\0', false);\n\n\tif (clist == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"operator does not exist: %s\", opr_name_or_oid)));\n\telse if (clist->next != NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_AMBIGUOUS_FUNCTION),\n\t\t\t\t errmsg(\"more than one operator named %s\",\n\t\t\t\t\t\topr_name_or_oid)));\n\n\tresult = clist->oid;\n\n\tPG_RETURN_OID(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_AMBIGUOUS_FUNCTION),\n\t\t\t\t errmsg(\"more than one operator named %s\",\n\t\t\t\t\t\topr_name_or_oid))"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"more than one operator named %s\"",
            "opr_name_or_oid"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_AMBIGUOUS_FUNCTION"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"operator does not exist: %s\", opr_name_or_oid))"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OpernameGetCandidates",
          "args": [
            "names",
            "'\\0'",
            "false"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringToQualifiedNameList",
          "args": [
            "opr_name_or_oid"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "stringToQualifiedNameList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "1686-1718",
          "snippet": "List *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"regoper values must be OIDs in bootstrap mode\""
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetObjectId",
          "args": [
            "DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(opr_name_or_oid))"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "oidin",
            "CStringGetDatum(opr_name_or_oid)"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "opr_name_or_oid"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "opr_name_or_oid"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "opr_name_or_oid",
            "\"0123456789\""
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "InvalidOid"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "opr_name_or_oid",
            "\"0\""
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregoperin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *opr_name_or_oid = PG_GETARG_CSTRING(0);\n\tOid\t\t\tresult = InvalidOid;\n\tList\t   *names;\n\tFuncCandidateList clist;\n\n\t/* '0' ? */\n\tif (strcmp(opr_name_or_oid, \"0\") == 0)\n\t\tPG_RETURN_OID(InvalidOid);\n\n\t/* Numeric OID? */\n\tif (opr_name_or_oid[0] >= '0' &&\n\t\topr_name_or_oid[0] <= '9' &&\n\t\tstrspn(opr_name_or_oid, \"0123456789\") == strlen(opr_name_or_oid))\n\t{\n\t\tresult = DatumGetObjectId(DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(opr_name_or_oid)));\n\t\tPG_RETURN_OID(result);\n\t}\n\n\t/* Else it's a name, possibly schema-qualified */\n\n\t/* The rest of this wouldn't work in bootstrap mode */\n\tif (IsBootstrapProcessingMode())\n\t\telog(ERROR, \"regoper values must be OIDs in bootstrap mode\");\n\n\t/*\n\t * Normal case: parse the name into components and see if it matches any\n\t * pg_operator entries in the current search path.\n\t */\n\tnames = stringToQualifiedNameList(opr_name_or_oid);\n\tclist = OpernameGetCandidates(names, '\\0', false);\n\n\tif (clist == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"operator does not exist: %s\", opr_name_or_oid)));\n\telse if (clist->next != NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_AMBIGUOUS_FUNCTION),\n\t\t\t\t errmsg(\"more than one operator named %s\",\n\t\t\t\t\t\topr_name_or_oid)));\n\n\tresult = clist->oid;\n\n\tPG_RETURN_OID(result);\n}"
  },
  {
    "function_name": "regproceduresend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "466-471",
    "snippet": "Datum\nregproceduresend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidsend, so share code */\n\treturn oidsend(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oidsend",
          "args": [
            "fcinfo"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "oidsend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "150-159",
          "snippet": "Datum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregproceduresend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidsend, so share code */\n\treturn oidsend(fcinfo);\n}"
  },
  {
    "function_name": "regprocedurerecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "456-461",
    "snippet": "Datum\nregprocedurerecv(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidrecv, so share code */\n\treturn oidrecv(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oidrecv",
          "args": [
            "fcinfo"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "oidrecv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "139-145",
          "snippet": "Datum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregprocedurerecv(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidrecv, so share code */\n\treturn oidrecv(fcinfo);\n}"
  },
  {
    "function_name": "regprocedureout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "439-451",
    "snippet": "Datum\nregprocedureout(PG_FUNCTION_ARGS)\n{\n\tRegProcedure proid = PG_GETARG_OID(0);\n\tchar\t   *result;\n\n\tif (proid == InvalidOid)\n\t\tresult = pstrdup(\"-\");\n\telse\n\t\tresult = format_procedure(proid);\n\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format_procedure",
          "args": [
            "proid"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "format_procedure_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "328-332",
          "snippet": "char *\nformat_procedure_qualified(Oid procedure_oid)\n{\n\treturn format_procedure_internal(procedure_oid, true);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_procedure_qualified(Oid procedure_oid)\n{\n\treturn format_procedure_internal(procedure_oid, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "\"-\""
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregprocedureout(PG_FUNCTION_ARGS)\n{\n\tRegProcedure proid = PG_GETARG_OID(0);\n\tchar\t   *result;\n\n\tif (proid == InvalidOid)\n\t\tresult = pstrdup(\"-\");\n\telse\n\t\tresult = format_procedure(proid);\n\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "format_procedure_parts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "407-434",
    "snippet": "void\nformat_procedure_parts(Oid procedure_oid, List **objnames, List **objargs)\n{\n\tHeapTuple\tproctup;\n\tForm_pg_proc procform;\n\tint\t\t\tnargs;\n\tint\t\t\ti;\n\n\tproctup = SearchSysCache1(PROCOID, ObjectIdGetDatum(procedure_oid));\n\n\tif (!HeapTupleIsValid(proctup))\n\t\telog(ERROR, \"cache lookup failed for procedure with OID %u\", procedure_oid);\n\n\tprocform = (Form_pg_proc) GETSTRUCT(proctup);\n\tnargs = procform->pronargs;\n\n\t*objnames = list_make2(get_namespace_name_or_temp(procform->pronamespace),\n\t\t\t\t\t\t   pstrdup(NameStr(procform->proname)));\n\t*objargs = NIL;\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tOid\t\t\tthisargtype = procform->proargtypes.values[i];\n\n\t\t*objargs = lappend(*objargs, format_type_be_qualified(thisargtype));\n\t}\n\n\tReleaseSysCache(proctup);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "proctup"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lappend",
          "args": [
            "*objargs",
            "format_type_be_qualified(thisargtype)"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format_type_be_qualified",
          "args": [
            "thisargtype"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_make2",
          "args": [
            "get_namespace_name_or_temp(procform->pronamespace)",
            "pstrdup(NameStr(procform->proname))"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "NameStr(procform->proname)"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "procform->proname"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_namespace_name_or_temp",
          "args": [
            "procform->pronamespace"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "proctup"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"cache lookup failed for procedure with OID %u\"",
            "procedure_oid"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "proctup"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "PROCOID",
            "ObjectIdGetDatum(procedure_oid)"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "procedure_oid"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nvoid\nformat_procedure_parts(Oid procedure_oid, List **objnames, List **objargs)\n{\n\tHeapTuple\tproctup;\n\tForm_pg_proc procform;\n\tint\t\t\tnargs;\n\tint\t\t\ti;\n\n\tproctup = SearchSysCache1(PROCOID, ObjectIdGetDatum(procedure_oid));\n\n\tif (!HeapTupleIsValid(proctup))\n\t\telog(ERROR, \"cache lookup failed for procedure with OID %u\", procedure_oid);\n\n\tprocform = (Form_pg_proc) GETSTRUCT(proctup);\n\tnargs = procform->pronargs;\n\n\t*objnames = list_make2(get_namespace_name_or_temp(procform->pronamespace),\n\t\t\t\t\t\t   pstrdup(NameStr(procform->proname)));\n\t*objargs = NIL;\n\tfor (i = 0; i < nargs; i++)\n\t{\n\t\tOid\t\t\tthisargtype = procform->proargtypes.values[i];\n\n\t\t*objargs = lappend(*objargs, format_type_be_qualified(thisargtype));\n\t}\n\n\tReleaseSysCache(proctup);\n}"
  },
  {
    "function_name": "format_procedure_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "341-399",
    "snippet": "static char *\nformat_procedure_internal(Oid procedure_oid, bool force_qualify)\n{\n\tchar\t   *result;\n\tHeapTuple\tproctup;\n\n\tproctup = SearchSysCache1(PROCOID, ObjectIdGetDatum(procedure_oid));\n\n\tif (HeapTupleIsValid(proctup))\n\t{\n\t\tForm_pg_proc procform = (Form_pg_proc) GETSTRUCT(proctup);\n\t\tchar\t   *proname = NameStr(procform->proname);\n\t\tint\t\t\tnargs = procform->pronargs;\n\t\tint\t\t\ti;\n\t\tchar\t   *nspname;\n\t\tStringInfoData buf;\n\n\t\t/* XXX no support here for bootstrap mode */\n\t\tAssert(!IsBootstrapProcessingMode());\n\n\t\tinitStringInfo(&buf);\n\n\t\t/*\n\t\t * Would this proc be found (given the right args) by regprocedurein?\n\t\t * If not, or if caller requests it, we need to qualify it.\n\t\t */\n\t\tif (!force_qualify && FunctionIsVisible(procedure_oid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name(procform->pronamespace);\n\n\t\tappendStringInfo(&buf, \"%s(\",\n\t\t\t\t\t\t quote_qualified_identifier(nspname, proname));\n\t\tfor (i = 0; i < nargs; i++)\n\t\t{\n\t\t\tOid\t\t\tthisargtype = procform->proargtypes.values[i];\n\n\t\t\tif (i > 0)\n\t\t\t\tappendStringInfoChar(&buf, ',');\n\t\t\tappendStringInfoString(&buf,\n\t\t\t\t\t\t\t\t   force_qualify ?\n\t\t\t\t\t\t\t\t   format_type_be_qualified(thisargtype) :\n\t\t\t\t\t\t\t\t   format_type_be(thisargtype));\n\t\t}\n\t\tappendStringInfoChar(&buf, ')');\n\n\t\tresult = buf.data;\n\n\t\tReleaseSysCache(proctup);\n\t}\n\telse\n\t{\n\t\t/* If OID doesn't match any pg_proc entry, return it numerically */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", procedure_oid);\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *format_operator_internal(Oid operator_oid, bool force_qualify);",
      "static char *format_procedure_internal(Oid procedure_oid, bool force_qualify);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "NAMEDATALEN",
            "\"%u\"",
            "procedure_oid"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "NAMEDATALEN"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "proctup"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "')'"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "force_qualify ?\n\t\t\t\t\t\t\t\t   format_type_be_qualified(thisargtype) :\n\t\t\t\t\t\t\t\t   format_type_be(thisargtype)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format_type_be",
          "args": [
            "thisargtype"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "format_type_be_qualified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/format_type.c",
          "lines": "337-341",
          "snippet": "char *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"utils/syscache.h\"\n#include \"utils/numeric.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_type_be_qualified(Oid type_oid)\n{\n\treturn format_type_extended(type_oid, -1, FORMAT_TYPE_FORCE_QUALIFY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"%s(\"",
            "quote_qualified_identifier(nspname, proname)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quote_qualified_identifier",
          "args": [
            "nspname",
            "proname"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "quote_qualified_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "10636-10647",
          "snippet": "char *\nquote_qualified_identifier(const char *qualifier,\n\t\t\t\t\t\t   const char *ident)\n{\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\tif (qualifier)\n\t\tappendStringInfo(&buf, \"%s.\", quote_identifier(qualifier));\n\tappendStringInfoString(&buf, quote_identifier(ident));\n\treturn buf.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int decompile_column_index_array(Datum column_index_array, Oid relId,\n\t\t\t\t\t\t\t StringInfo buf);",
            "static void get_opclass_name(Oid opclass, Oid actual_datatype,\n\t\t\t\t StringInfo buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int decompile_column_index_array(Datum column_index_array, Oid relId,\n\t\t\t\t\t\t\t StringInfo buf);\nstatic void get_opclass_name(Oid opclass, Oid actual_datatype,\n\t\t\t\t StringInfo buf);\n\nchar *\nquote_qualified_identifier(const char *qualifier,\n\t\t\t\t\t\t   const char *ident)\n{\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\tif (qualifier)\n\t\tappendStringInfo(&buf, \"%s.\", quote_identifier(qualifier));\n\tappendStringInfoString(&buf, quote_identifier(ident));\n\treturn buf.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_namespace_name",
          "args": [
            "procform->pronamespace"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FunctionIsVisible",
          "args": [
            "procedure_oid"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "!IsBootstrapProcessingMode()"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "procform->proname"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "proctup"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "proctup"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "PROCOID",
            "ObjectIdGetDatum(procedure_oid)"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "procedure_oid"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *format_operator_internal(Oid operator_oid, bool force_qualify);\nstatic char *format_procedure_internal(Oid procedure_oid, bool force_qualify);\n\nstatic char *\nformat_procedure_internal(Oid procedure_oid, bool force_qualify)\n{\n\tchar\t   *result;\n\tHeapTuple\tproctup;\n\n\tproctup = SearchSysCache1(PROCOID, ObjectIdGetDatum(procedure_oid));\n\n\tif (HeapTupleIsValid(proctup))\n\t{\n\t\tForm_pg_proc procform = (Form_pg_proc) GETSTRUCT(proctup);\n\t\tchar\t   *proname = NameStr(procform->proname);\n\t\tint\t\t\tnargs = procform->pronargs;\n\t\tint\t\t\ti;\n\t\tchar\t   *nspname;\n\t\tStringInfoData buf;\n\n\t\t/* XXX no support here for bootstrap mode */\n\t\tAssert(!IsBootstrapProcessingMode());\n\n\t\tinitStringInfo(&buf);\n\n\t\t/*\n\t\t * Would this proc be found (given the right args) by regprocedurein?\n\t\t * If not, or if caller requests it, we need to qualify it.\n\t\t */\n\t\tif (!force_qualify && FunctionIsVisible(procedure_oid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name(procform->pronamespace);\n\n\t\tappendStringInfo(&buf, \"%s(\",\n\t\t\t\t\t\t quote_qualified_identifier(nspname, proname));\n\t\tfor (i = 0; i < nargs; i++)\n\t\t{\n\t\t\tOid\t\t\tthisargtype = procform->proargtypes.values[i];\n\n\t\t\tif (i > 0)\n\t\t\t\tappendStringInfoChar(&buf, ',');\n\t\t\tappendStringInfoString(&buf,\n\t\t\t\t\t\t\t\t   force_qualify ?\n\t\t\t\t\t\t\t\t   format_type_be_qualified(thisargtype) :\n\t\t\t\t\t\t\t\t   format_type_be(thisargtype));\n\t\t}\n\t\tappendStringInfoChar(&buf, ')');\n\n\t\tresult = buf.data;\n\n\t\tReleaseSysCache(proctup);\n\t}\n\telse\n\t{\n\t\t/* If OID doesn't match any pg_proc entry, return it numerically */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", procedure_oid);\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "format_procedure_qualified",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "328-332",
    "snippet": "char *\nformat_procedure_qualified(Oid procedure_oid)\n{\n\treturn format_procedure_internal(procedure_oid, true);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "format_procedure_internal",
          "args": [
            "procedure_oid",
            "true"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "format_procedure_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "341-399",
          "snippet": "static char *\nformat_procedure_internal(Oid procedure_oid, bool force_qualify)\n{\n\tchar\t   *result;\n\tHeapTuple\tproctup;\n\n\tproctup = SearchSysCache1(PROCOID, ObjectIdGetDatum(procedure_oid));\n\n\tif (HeapTupleIsValid(proctup))\n\t{\n\t\tForm_pg_proc procform = (Form_pg_proc) GETSTRUCT(proctup);\n\t\tchar\t   *proname = NameStr(procform->proname);\n\t\tint\t\t\tnargs = procform->pronargs;\n\t\tint\t\t\ti;\n\t\tchar\t   *nspname;\n\t\tStringInfoData buf;\n\n\t\t/* XXX no support here for bootstrap mode */\n\t\tAssert(!IsBootstrapProcessingMode());\n\n\t\tinitStringInfo(&buf);\n\n\t\t/*\n\t\t * Would this proc be found (given the right args) by regprocedurein?\n\t\t * If not, or if caller requests it, we need to qualify it.\n\t\t */\n\t\tif (!force_qualify && FunctionIsVisible(procedure_oid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name(procform->pronamespace);\n\n\t\tappendStringInfo(&buf, \"%s(\",\n\t\t\t\t\t\t quote_qualified_identifier(nspname, proname));\n\t\tfor (i = 0; i < nargs; i++)\n\t\t{\n\t\t\tOid\t\t\tthisargtype = procform->proargtypes.values[i];\n\n\t\t\tif (i > 0)\n\t\t\t\tappendStringInfoChar(&buf, ',');\n\t\t\tappendStringInfoString(&buf,\n\t\t\t\t\t\t\t\t   force_qualify ?\n\t\t\t\t\t\t\t\t   format_type_be_qualified(thisargtype) :\n\t\t\t\t\t\t\t\t   format_type_be(thisargtype));\n\t\t}\n\t\tappendStringInfoChar(&buf, ')');\n\n\t\tresult = buf.data;\n\n\t\tReleaseSysCache(proctup);\n\t}\n\telse\n\t{\n\t\t/* If OID doesn't match any pg_proc entry, return it numerically */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", procedure_oid);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *format_operator_internal(Oid operator_oid, bool force_qualify);",
            "static char *format_procedure_internal(Oid procedure_oid, bool force_qualify);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *format_operator_internal(Oid operator_oid, bool force_qualify);\nstatic char *format_procedure_internal(Oid procedure_oid, bool force_qualify);\n\nstatic char *\nformat_procedure_internal(Oid procedure_oid, bool force_qualify)\n{\n\tchar\t   *result;\n\tHeapTuple\tproctup;\n\n\tproctup = SearchSysCache1(PROCOID, ObjectIdGetDatum(procedure_oid));\n\n\tif (HeapTupleIsValid(proctup))\n\t{\n\t\tForm_pg_proc procform = (Form_pg_proc) GETSTRUCT(proctup);\n\t\tchar\t   *proname = NameStr(procform->proname);\n\t\tint\t\t\tnargs = procform->pronargs;\n\t\tint\t\t\ti;\n\t\tchar\t   *nspname;\n\t\tStringInfoData buf;\n\n\t\t/* XXX no support here for bootstrap mode */\n\t\tAssert(!IsBootstrapProcessingMode());\n\n\t\tinitStringInfo(&buf);\n\n\t\t/*\n\t\t * Would this proc be found (given the right args) by regprocedurein?\n\t\t * If not, or if caller requests it, we need to qualify it.\n\t\t */\n\t\tif (!force_qualify && FunctionIsVisible(procedure_oid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name(procform->pronamespace);\n\n\t\tappendStringInfo(&buf, \"%s(\",\n\t\t\t\t\t\t quote_qualified_identifier(nspname, proname));\n\t\tfor (i = 0; i < nargs; i++)\n\t\t{\n\t\t\tOid\t\t\tthisargtype = procform->proargtypes.values[i];\n\n\t\t\tif (i > 0)\n\t\t\t\tappendStringInfoChar(&buf, ',');\n\t\t\tappendStringInfoString(&buf,\n\t\t\t\t\t\t\t\t   force_qualify ?\n\t\t\t\t\t\t\t\t   format_type_be_qualified(thisargtype) :\n\t\t\t\t\t\t\t\t   format_type_be(thisargtype));\n\t\t}\n\t\tappendStringInfoChar(&buf, ')');\n\n\t\tresult = buf.data;\n\n\t\tReleaseSysCache(proctup);\n\t}\n\telse\n\t{\n\t\t/* If OID doesn't match any pg_proc entry, return it numerically */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", procedure_oid);\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_procedure_qualified(Oid procedure_oid)\n{\n\treturn format_procedure_internal(procedure_oid, true);\n}"
  },
  {
    "function_name": "format_procedure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "322-326",
    "snippet": "char *\nformat_procedure(Oid procedure_oid)\n{\n\treturn format_procedure_internal(procedure_oid, false);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "format_procedure_internal",
          "args": [
            "procedure_oid",
            "false"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "format_procedure_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "341-399",
          "snippet": "static char *\nformat_procedure_internal(Oid procedure_oid, bool force_qualify)\n{\n\tchar\t   *result;\n\tHeapTuple\tproctup;\n\n\tproctup = SearchSysCache1(PROCOID, ObjectIdGetDatum(procedure_oid));\n\n\tif (HeapTupleIsValid(proctup))\n\t{\n\t\tForm_pg_proc procform = (Form_pg_proc) GETSTRUCT(proctup);\n\t\tchar\t   *proname = NameStr(procform->proname);\n\t\tint\t\t\tnargs = procform->pronargs;\n\t\tint\t\t\ti;\n\t\tchar\t   *nspname;\n\t\tStringInfoData buf;\n\n\t\t/* XXX no support here for bootstrap mode */\n\t\tAssert(!IsBootstrapProcessingMode());\n\n\t\tinitStringInfo(&buf);\n\n\t\t/*\n\t\t * Would this proc be found (given the right args) by regprocedurein?\n\t\t * If not, or if caller requests it, we need to qualify it.\n\t\t */\n\t\tif (!force_qualify && FunctionIsVisible(procedure_oid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name(procform->pronamespace);\n\n\t\tappendStringInfo(&buf, \"%s(\",\n\t\t\t\t\t\t quote_qualified_identifier(nspname, proname));\n\t\tfor (i = 0; i < nargs; i++)\n\t\t{\n\t\t\tOid\t\t\tthisargtype = procform->proargtypes.values[i];\n\n\t\t\tif (i > 0)\n\t\t\t\tappendStringInfoChar(&buf, ',');\n\t\t\tappendStringInfoString(&buf,\n\t\t\t\t\t\t\t\t   force_qualify ?\n\t\t\t\t\t\t\t\t   format_type_be_qualified(thisargtype) :\n\t\t\t\t\t\t\t\t   format_type_be(thisargtype));\n\t\t}\n\t\tappendStringInfoChar(&buf, ')');\n\n\t\tresult = buf.data;\n\n\t\tReleaseSysCache(proctup);\n\t}\n\telse\n\t{\n\t\t/* If OID doesn't match any pg_proc entry, return it numerically */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", procedure_oid);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *format_operator_internal(Oid operator_oid, bool force_qualify);",
            "static char *format_procedure_internal(Oid procedure_oid, bool force_qualify);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic char *format_operator_internal(Oid operator_oid, bool force_qualify);\nstatic char *format_procedure_internal(Oid procedure_oid, bool force_qualify);\n\nstatic char *\nformat_procedure_internal(Oid procedure_oid, bool force_qualify)\n{\n\tchar\t   *result;\n\tHeapTuple\tproctup;\n\n\tproctup = SearchSysCache1(PROCOID, ObjectIdGetDatum(procedure_oid));\n\n\tif (HeapTupleIsValid(proctup))\n\t{\n\t\tForm_pg_proc procform = (Form_pg_proc) GETSTRUCT(proctup);\n\t\tchar\t   *proname = NameStr(procform->proname);\n\t\tint\t\t\tnargs = procform->pronargs;\n\t\tint\t\t\ti;\n\t\tchar\t   *nspname;\n\t\tStringInfoData buf;\n\n\t\t/* XXX no support here for bootstrap mode */\n\t\tAssert(!IsBootstrapProcessingMode());\n\n\t\tinitStringInfo(&buf);\n\n\t\t/*\n\t\t * Would this proc be found (given the right args) by regprocedurein?\n\t\t * If not, or if caller requests it, we need to qualify it.\n\t\t */\n\t\tif (!force_qualify && FunctionIsVisible(procedure_oid))\n\t\t\tnspname = NULL;\n\t\telse\n\t\t\tnspname = get_namespace_name(procform->pronamespace);\n\n\t\tappendStringInfo(&buf, \"%s(\",\n\t\t\t\t\t\t quote_qualified_identifier(nspname, proname));\n\t\tfor (i = 0; i < nargs; i++)\n\t\t{\n\t\t\tOid\t\t\tthisargtype = procform->proargtypes.values[i];\n\n\t\t\tif (i > 0)\n\t\t\t\tappendStringInfoChar(&buf, ',');\n\t\t\tappendStringInfoString(&buf,\n\t\t\t\t\t\t\t\t   force_qualify ?\n\t\t\t\t\t\t\t\t   format_type_be_qualified(thisargtype) :\n\t\t\t\t\t\t\t\t   format_type_be(thisargtype));\n\t\t}\n\t\tappendStringInfoChar(&buf, ')');\n\n\t\tresult = buf.data;\n\n\t\tReleaseSysCache(proctup);\n\t}\n\telse\n\t{\n\t\t/* If OID doesn't match any pg_proc entry, return it numerically */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", procedure_oid);\n\t}\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nchar *\nformat_procedure(Oid procedure_oid)\n{\n\treturn format_procedure_internal(procedure_oid, false);\n}"
  },
  {
    "function_name": "to_regprocedure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "289-314",
    "snippet": "Datum\nto_regprocedure(PG_FUNCTION_ARGS)\n{\n\tchar\t   *pro_name = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tList\t   *names;\n\tint\t\t\tnargs;\n\tOid\t\t\targtypes[FUNC_MAX_ARGS];\n\tFuncCandidateList clist;\n\n\t/*\n\t * Parse the name and arguments, look up potential matches in the current\n\t * namespace search list, and scan to see which one exactly matches the\n\t * given argument types.    (There will not be more than one match.)\n\t */\n\tparseNameAndArgTypes(pro_name, false, &names, &nargs, argtypes);\n\n\tclist = FuncnameGetCandidates(names, nargs, NIL, false, false, true);\n\n\tfor (; clist; clist = clist->next)\n\t{\n\t\tif (memcmp(clist->args, argtypes, nargs * sizeof(Oid)) == 0)\n\t\t\tPG_RETURN_OID(clist->oid);\n\t}\n\n\tPG_RETURN_NULL();\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void parseNameAndArgTypes(const char *string, bool allowNone,\n\t\t\t\t\t List **names, int *nargs, Oid *argtypes);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "clist->oid"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "clist->args",
            "argtypes",
            "nargs * sizeof(Oid)"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FuncnameGetCandidates",
          "args": [
            "names",
            "nargs",
            "NIL",
            "false",
            "false",
            "true"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseNameAndArgTypes",
          "args": [
            "pro_name",
            "false",
            "&names",
            "&nargs",
            "argtypes"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "parseNameAndArgTypes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "1734-1872",
          "snippet": "static void\nparseNameAndArgTypes(const char *string, bool allowNone, List **names,\n\t\t\t\t\t int *nargs, Oid *argtypes)\n{\n\tchar\t   *rawname;\n\tchar\t   *ptr;\n\tchar\t   *ptr2;\n\tchar\t   *typename;\n\tbool\t\tin_quote;\n\tbool\t\thad_comma;\n\tint\t\t\tparen_count;\n\tOid\t\t\ttypeid;\n\tint32\t\ttypmod;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\t/* Scan to find the expected left paren; mustn't be quoted */\n\tin_quote = false;\n\tfor (ptr = rawname; *ptr; ptr++)\n\t{\n\t\tif (*ptr == '\"')\n\t\t\tin_quote = !in_quote;\n\t\telse if (*ptr == '(' && !in_quote)\n\t\t\tbreak;\n\t}\n\tif (*ptr == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a left parenthesis\")));\n\n\t/* Separate the name and parse it into a list */\n\t*ptr++ = '\\0';\n\t*names = stringToQualifiedNameList(rawname);\n\n\t/* Check for the trailing right parenthesis and remove it */\n\tptr2 = ptr + strlen(ptr);\n\twhile (--ptr2 > ptr)\n\t{\n\t\tif (!scanner_isspace(*ptr2))\n\t\t\tbreak;\n\t}\n\tif (*ptr2 != ')')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a right parenthesis\")));\n\n\t*ptr2 = '\\0';\n\n\t/* Separate the remaining string into comma-separated type names */\n\t*nargs = 0;\n\thad_comma = false;\n\n\tfor (;;)\n\t{\n\t\t/* allow leading whitespace */\n\t\twhile (scanner_isspace(*ptr))\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t{\n\t\t\t/* End of string.  Okay unless we had a comma before. */\n\t\t\tif (had_comma)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"expected a type name\")));\n\t\t\tbreak;\n\t\t}\n\t\ttypename = ptr;\n\t\t/* Find end of type name --- end of string or comma */\n\t\t/* ... but not a quoted or parenthesized comma */\n\t\tin_quote = false;\n\t\tparen_count = 0;\n\t\tfor (; *ptr; ptr++)\n\t\t{\n\t\t\tif (*ptr == '\"')\n\t\t\t\tin_quote = !in_quote;\n\t\t\telse if (*ptr == ',' && !in_quote && paren_count == 0)\n\t\t\t\tbreak;\n\t\t\telse if (!in_quote)\n\t\t\t{\n\t\t\t\tswitch (*ptr)\n\t\t\t\t{\n\t\t\t\t\tcase '(':\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tparen_count++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ')':\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tparen_count--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (in_quote || paren_count != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"improper type name\")));\n\n\t\tptr2 = ptr;\n\t\tif (*ptr == ',')\n\t\t{\n\t\t\thad_comma = true;\n\t\t\t*ptr++ = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\thad_comma = false;\n\t\t\tAssert(*ptr == '\\0');\n\t\t}\n\t\t/* Lop off trailing whitespace */\n\t\twhile (--ptr2 >= typename)\n\t\t{\n\t\t\tif (!scanner_isspace(*ptr2))\n\t\t\t\tbreak;\n\t\t\t*ptr2 = '\\0';\n\t\t}\n\n\t\tif (allowNone && pg_strcasecmp(typename, \"none\") == 0)\n\t\t{\n\t\t\t/* Special case for NONE */\n\t\t\ttypeid = InvalidOid;\n\t\t\ttypmod = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Use full parser to resolve the type name */\n\t\t\tparseTypeString(typename, &typeid, &typmod, false);\n\t\t}\n\t\tif (*nargs >= FUNC_MAX_ARGS)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_ARGUMENTS),\n\t\t\t\t\t errmsg(\"too many arguments\")));\n\n\t\targtypes[*nargs] = typeid;\n\t\t(*nargs)++;\n\t}\n\n\tpfree(rawname);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void parseNameAndArgTypes(const char *string, bool allowNone,\n\t\t\t\t\t List **names, int *nargs, Oid *argtypes);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void parseNameAndArgTypes(const char *string, bool allowNone,\n\t\t\t\t\t List **names, int *nargs, Oid *argtypes);\n\nstatic void\nparseNameAndArgTypes(const char *string, bool allowNone, List **names,\n\t\t\t\t\t int *nargs, Oid *argtypes)\n{\n\tchar\t   *rawname;\n\tchar\t   *ptr;\n\tchar\t   *ptr2;\n\tchar\t   *typename;\n\tbool\t\tin_quote;\n\tbool\t\thad_comma;\n\tint\t\t\tparen_count;\n\tOid\t\t\ttypeid;\n\tint32\t\ttypmod;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\t/* Scan to find the expected left paren; mustn't be quoted */\n\tin_quote = false;\n\tfor (ptr = rawname; *ptr; ptr++)\n\t{\n\t\tif (*ptr == '\"')\n\t\t\tin_quote = !in_quote;\n\t\telse if (*ptr == '(' && !in_quote)\n\t\t\tbreak;\n\t}\n\tif (*ptr == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a left parenthesis\")));\n\n\t/* Separate the name and parse it into a list */\n\t*ptr++ = '\\0';\n\t*names = stringToQualifiedNameList(rawname);\n\n\t/* Check for the trailing right parenthesis and remove it */\n\tptr2 = ptr + strlen(ptr);\n\twhile (--ptr2 > ptr)\n\t{\n\t\tif (!scanner_isspace(*ptr2))\n\t\t\tbreak;\n\t}\n\tif (*ptr2 != ')')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a right parenthesis\")));\n\n\t*ptr2 = '\\0';\n\n\t/* Separate the remaining string into comma-separated type names */\n\t*nargs = 0;\n\thad_comma = false;\n\n\tfor (;;)\n\t{\n\t\t/* allow leading whitespace */\n\t\twhile (scanner_isspace(*ptr))\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t{\n\t\t\t/* End of string.  Okay unless we had a comma before. */\n\t\t\tif (had_comma)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"expected a type name\")));\n\t\t\tbreak;\n\t\t}\n\t\ttypename = ptr;\n\t\t/* Find end of type name --- end of string or comma */\n\t\t/* ... but not a quoted or parenthesized comma */\n\t\tin_quote = false;\n\t\tparen_count = 0;\n\t\tfor (; *ptr; ptr++)\n\t\t{\n\t\t\tif (*ptr == '\"')\n\t\t\t\tin_quote = !in_quote;\n\t\t\telse if (*ptr == ',' && !in_quote && paren_count == 0)\n\t\t\t\tbreak;\n\t\t\telse if (!in_quote)\n\t\t\t{\n\t\t\t\tswitch (*ptr)\n\t\t\t\t{\n\t\t\t\t\tcase '(':\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tparen_count++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ')':\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tparen_count--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (in_quote || paren_count != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"improper type name\")));\n\n\t\tptr2 = ptr;\n\t\tif (*ptr == ',')\n\t\t{\n\t\t\thad_comma = true;\n\t\t\t*ptr++ = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\thad_comma = false;\n\t\t\tAssert(*ptr == '\\0');\n\t\t}\n\t\t/* Lop off trailing whitespace */\n\t\twhile (--ptr2 >= typename)\n\t\t{\n\t\t\tif (!scanner_isspace(*ptr2))\n\t\t\t\tbreak;\n\t\t\t*ptr2 = '\\0';\n\t\t}\n\n\t\tif (allowNone && pg_strcasecmp(typename, \"none\") == 0)\n\t\t{\n\t\t\t/* Special case for NONE */\n\t\t\ttypeid = InvalidOid;\n\t\t\ttypmod = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Use full parser to resolve the type name */\n\t\t\tparseTypeString(typename, &typeid, &typmod, false);\n\t\t}\n\t\tif (*nargs >= FUNC_MAX_ARGS)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_ARGUMENTS),\n\t\t\t\t\t errmsg(\"too many arguments\")));\n\n\t\targtypes[*nargs] = typeid;\n\t\t(*nargs)++;\n\t}\n\n\tpfree(rawname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(0)"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void parseNameAndArgTypes(const char *string, bool allowNone,\n\t\t\t\t\t List **names, int *nargs, Oid *argtypes);\n\nDatum\nto_regprocedure(PG_FUNCTION_ARGS)\n{\n\tchar\t   *pro_name = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tList\t   *names;\n\tint\t\t\tnargs;\n\tOid\t\t\targtypes[FUNC_MAX_ARGS];\n\tFuncCandidateList clist;\n\n\t/*\n\t * Parse the name and arguments, look up potential matches in the current\n\t * namespace search list, and scan to see which one exactly matches the\n\t * given argument types.    (There will not be more than one match.)\n\t */\n\tparseNameAndArgTypes(pro_name, false, &names, &nargs, argtypes);\n\n\tclist = FuncnameGetCandidates(names, nargs, NIL, false, false, true);\n\n\tfor (; clist; clist = clist->next)\n\t{\n\t\tif (memcmp(clist->args, argtypes, nargs * sizeof(Oid)) == 0)\n\t\t\tPG_RETURN_OID(clist->oid);\n\t}\n\n\tPG_RETURN_NULL();\n}"
  },
  {
    "function_name": "regprocedurein",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "230-282",
    "snippet": "Datum\nregprocedurein(PG_FUNCTION_ARGS)\n{\n\tchar\t   *pro_name_or_oid = PG_GETARG_CSTRING(0);\n\tRegProcedure result = InvalidOid;\n\tList\t   *names;\n\tint\t\t\tnargs;\n\tOid\t\t\targtypes[FUNC_MAX_ARGS];\n\tFuncCandidateList clist;\n\n\t/* '-' ? */\n\tif (strcmp(pro_name_or_oid, \"-\") == 0)\n\t\tPG_RETURN_OID(InvalidOid);\n\n\t/* Numeric OID? */\n\tif (pro_name_or_oid[0] >= '0' &&\n\t\tpro_name_or_oid[0] <= '9' &&\n\t\tstrspn(pro_name_or_oid, \"0123456789\") == strlen(pro_name_or_oid))\n\t{\n\t\tresult = DatumGetObjectId(DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(pro_name_or_oid)));\n\t\tPG_RETURN_OID(result);\n\t}\n\n\t/* The rest of this wouldn't work in bootstrap mode */\n\tif (IsBootstrapProcessingMode())\n\t\telog(ERROR, \"regprocedure values must be OIDs in bootstrap mode\");\n\n\t/*\n\t * Else it's a name and arguments.  Parse the name and arguments, look up\n\t * potential matches in the current namespace search list, and scan to see\n\t * which one exactly matches the given argument types.  (There will not be\n\t * more than one match.)\n\t */\n\tparseNameAndArgTypes(pro_name_or_oid, false, &names, &nargs, argtypes);\n\n\tclist = FuncnameGetCandidates(names, nargs, NIL, false, false, false);\n\n\tfor (; clist; clist = clist->next)\n\t{\n\t\tif (memcmp(clist->args, argtypes, nargs * sizeof(Oid)) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (clist == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"function \\\"%s\\\" does not exist\", pro_name_or_oid)));\n\n\tresult = clist->oid;\n\n\tPG_RETURN_OID(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void parseNameAndArgTypes(const char *string, bool allowNone,\n\t\t\t\t\t List **names, int *nargs, Oid *argtypes);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"function \\\"%s\\\" does not exist\", pro_name_or_oid))"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"function \\\"%s\\\" does not exist\"",
            "pro_name_or_oid"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_UNDEFINED_FUNCTION"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "clist->args",
            "argtypes",
            "nargs * sizeof(Oid)"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FuncnameGetCandidates",
          "args": [
            "names",
            "nargs",
            "NIL",
            "false",
            "false",
            "false"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parseNameAndArgTypes",
          "args": [
            "pro_name_or_oid",
            "false",
            "&names",
            "&nargs",
            "argtypes"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "parseNameAndArgTypes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "1734-1872",
          "snippet": "static void\nparseNameAndArgTypes(const char *string, bool allowNone, List **names,\n\t\t\t\t\t int *nargs, Oid *argtypes)\n{\n\tchar\t   *rawname;\n\tchar\t   *ptr;\n\tchar\t   *ptr2;\n\tchar\t   *typename;\n\tbool\t\tin_quote;\n\tbool\t\thad_comma;\n\tint\t\t\tparen_count;\n\tOid\t\t\ttypeid;\n\tint32\t\ttypmod;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\t/* Scan to find the expected left paren; mustn't be quoted */\n\tin_quote = false;\n\tfor (ptr = rawname; *ptr; ptr++)\n\t{\n\t\tif (*ptr == '\"')\n\t\t\tin_quote = !in_quote;\n\t\telse if (*ptr == '(' && !in_quote)\n\t\t\tbreak;\n\t}\n\tif (*ptr == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a left parenthesis\")));\n\n\t/* Separate the name and parse it into a list */\n\t*ptr++ = '\\0';\n\t*names = stringToQualifiedNameList(rawname);\n\n\t/* Check for the trailing right parenthesis and remove it */\n\tptr2 = ptr + strlen(ptr);\n\twhile (--ptr2 > ptr)\n\t{\n\t\tif (!scanner_isspace(*ptr2))\n\t\t\tbreak;\n\t}\n\tif (*ptr2 != ')')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a right parenthesis\")));\n\n\t*ptr2 = '\\0';\n\n\t/* Separate the remaining string into comma-separated type names */\n\t*nargs = 0;\n\thad_comma = false;\n\n\tfor (;;)\n\t{\n\t\t/* allow leading whitespace */\n\t\twhile (scanner_isspace(*ptr))\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t{\n\t\t\t/* End of string.  Okay unless we had a comma before. */\n\t\t\tif (had_comma)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"expected a type name\")));\n\t\t\tbreak;\n\t\t}\n\t\ttypename = ptr;\n\t\t/* Find end of type name --- end of string or comma */\n\t\t/* ... but not a quoted or parenthesized comma */\n\t\tin_quote = false;\n\t\tparen_count = 0;\n\t\tfor (; *ptr; ptr++)\n\t\t{\n\t\t\tif (*ptr == '\"')\n\t\t\t\tin_quote = !in_quote;\n\t\t\telse if (*ptr == ',' && !in_quote && paren_count == 0)\n\t\t\t\tbreak;\n\t\t\telse if (!in_quote)\n\t\t\t{\n\t\t\t\tswitch (*ptr)\n\t\t\t\t{\n\t\t\t\t\tcase '(':\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tparen_count++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ')':\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tparen_count--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (in_quote || paren_count != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"improper type name\")));\n\n\t\tptr2 = ptr;\n\t\tif (*ptr == ',')\n\t\t{\n\t\t\thad_comma = true;\n\t\t\t*ptr++ = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\thad_comma = false;\n\t\t\tAssert(*ptr == '\\0');\n\t\t}\n\t\t/* Lop off trailing whitespace */\n\t\twhile (--ptr2 >= typename)\n\t\t{\n\t\t\tif (!scanner_isspace(*ptr2))\n\t\t\t\tbreak;\n\t\t\t*ptr2 = '\\0';\n\t\t}\n\n\t\tif (allowNone && pg_strcasecmp(typename, \"none\") == 0)\n\t\t{\n\t\t\t/* Special case for NONE */\n\t\t\ttypeid = InvalidOid;\n\t\t\ttypmod = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Use full parser to resolve the type name */\n\t\t\tparseTypeString(typename, &typeid, &typmod, false);\n\t\t}\n\t\tif (*nargs >= FUNC_MAX_ARGS)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_ARGUMENTS),\n\t\t\t\t\t errmsg(\"too many arguments\")));\n\n\t\targtypes[*nargs] = typeid;\n\t\t(*nargs)++;\n\t}\n\n\tpfree(rawname);\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void parseNameAndArgTypes(const char *string, bool allowNone,\n\t\t\t\t\t List **names, int *nargs, Oid *argtypes);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void parseNameAndArgTypes(const char *string, bool allowNone,\n\t\t\t\t\t List **names, int *nargs, Oid *argtypes);\n\nstatic void\nparseNameAndArgTypes(const char *string, bool allowNone, List **names,\n\t\t\t\t\t int *nargs, Oid *argtypes)\n{\n\tchar\t   *rawname;\n\tchar\t   *ptr;\n\tchar\t   *ptr2;\n\tchar\t   *typename;\n\tbool\t\tin_quote;\n\tbool\t\thad_comma;\n\tint\t\t\tparen_count;\n\tOid\t\t\ttypeid;\n\tint32\t\ttypmod;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\t/* Scan to find the expected left paren; mustn't be quoted */\n\tin_quote = false;\n\tfor (ptr = rawname; *ptr; ptr++)\n\t{\n\t\tif (*ptr == '\"')\n\t\t\tin_quote = !in_quote;\n\t\telse if (*ptr == '(' && !in_quote)\n\t\t\tbreak;\n\t}\n\tif (*ptr == '\\0')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a left parenthesis\")));\n\n\t/* Separate the name and parse it into a list */\n\t*ptr++ = '\\0';\n\t*names = stringToQualifiedNameList(rawname);\n\n\t/* Check for the trailing right parenthesis and remove it */\n\tptr2 = ptr + strlen(ptr);\n\twhile (--ptr2 > ptr)\n\t{\n\t\tif (!scanner_isspace(*ptr2))\n\t\t\tbreak;\n\t}\n\tif (*ptr2 != ')')\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"expected a right parenthesis\")));\n\n\t*ptr2 = '\\0';\n\n\t/* Separate the remaining string into comma-separated type names */\n\t*nargs = 0;\n\thad_comma = false;\n\n\tfor (;;)\n\t{\n\t\t/* allow leading whitespace */\n\t\twhile (scanner_isspace(*ptr))\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t{\n\t\t\t/* End of string.  Okay unless we had a comma before. */\n\t\t\tif (had_comma)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t\t errmsg(\"expected a type name\")));\n\t\t\tbreak;\n\t\t}\n\t\ttypename = ptr;\n\t\t/* Find end of type name --- end of string or comma */\n\t\t/* ... but not a quoted or parenthesized comma */\n\t\tin_quote = false;\n\t\tparen_count = 0;\n\t\tfor (; *ptr; ptr++)\n\t\t{\n\t\t\tif (*ptr == '\"')\n\t\t\t\tin_quote = !in_quote;\n\t\t\telse if (*ptr == ',' && !in_quote && paren_count == 0)\n\t\t\t\tbreak;\n\t\t\telse if (!in_quote)\n\t\t\t{\n\t\t\t\tswitch (*ptr)\n\t\t\t\t{\n\t\t\t\t\tcase '(':\n\t\t\t\t\tcase '[':\n\t\t\t\t\t\tparen_count++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ')':\n\t\t\t\t\tcase ']':\n\t\t\t\t\t\tparen_count--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (in_quote || paren_count != 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t\t errmsg(\"improper type name\")));\n\n\t\tptr2 = ptr;\n\t\tif (*ptr == ',')\n\t\t{\n\t\t\thad_comma = true;\n\t\t\t*ptr++ = '\\0';\n\t\t}\n\t\telse\n\t\t{\n\t\t\thad_comma = false;\n\t\t\tAssert(*ptr == '\\0');\n\t\t}\n\t\t/* Lop off trailing whitespace */\n\t\twhile (--ptr2 >= typename)\n\t\t{\n\t\t\tif (!scanner_isspace(*ptr2))\n\t\t\t\tbreak;\n\t\t\t*ptr2 = '\\0';\n\t\t}\n\n\t\tif (allowNone && pg_strcasecmp(typename, \"none\") == 0)\n\t\t{\n\t\t\t/* Special case for NONE */\n\t\t\ttypeid = InvalidOid;\n\t\t\ttypmod = -1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Use full parser to resolve the type name */\n\t\t\tparseTypeString(typename, &typeid, &typmod, false);\n\t\t}\n\t\tif (*nargs >= FUNC_MAX_ARGS)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_TOO_MANY_ARGUMENTS),\n\t\t\t\t\t errmsg(\"too many arguments\")));\n\n\t\targtypes[*nargs] = typeid;\n\t\t(*nargs)++;\n\t}\n\n\tpfree(rawname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"regprocedure values must be OIDs in bootstrap mode\""
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetObjectId",
          "args": [
            "DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(pro_name_or_oid))"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "oidin",
            "CStringGetDatum(pro_name_or_oid)"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "pro_name_or_oid"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pro_name_or_oid"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "pro_name_or_oid",
            "\"0123456789\""
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "InvalidOid"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pro_name_or_oid",
            "\"-\""
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void parseNameAndArgTypes(const char *string, bool allowNone,\n\t\t\t\t\t List **names, int *nargs, Oid *argtypes);\n\nDatum\nregprocedurein(PG_FUNCTION_ARGS)\n{\n\tchar\t   *pro_name_or_oid = PG_GETARG_CSTRING(0);\n\tRegProcedure result = InvalidOid;\n\tList\t   *names;\n\tint\t\t\tnargs;\n\tOid\t\t\targtypes[FUNC_MAX_ARGS];\n\tFuncCandidateList clist;\n\n\t/* '-' ? */\n\tif (strcmp(pro_name_or_oid, \"-\") == 0)\n\t\tPG_RETURN_OID(InvalidOid);\n\n\t/* Numeric OID? */\n\tif (pro_name_or_oid[0] >= '0' &&\n\t\tpro_name_or_oid[0] <= '9' &&\n\t\tstrspn(pro_name_or_oid, \"0123456789\") == strlen(pro_name_or_oid))\n\t{\n\t\tresult = DatumGetObjectId(DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(pro_name_or_oid)));\n\t\tPG_RETURN_OID(result);\n\t}\n\n\t/* The rest of this wouldn't work in bootstrap mode */\n\tif (IsBootstrapProcessingMode())\n\t\telog(ERROR, \"regprocedure values must be OIDs in bootstrap mode\");\n\n\t/*\n\t * Else it's a name and arguments.  Parse the name and arguments, look up\n\t * potential matches in the current namespace search list, and scan to see\n\t * which one exactly matches the given argument types.  (There will not be\n\t * more than one match.)\n\t */\n\tparseNameAndArgTypes(pro_name_or_oid, false, &names, &nargs, argtypes);\n\n\tclist = FuncnameGetCandidates(names, nargs, NIL, false, false, false);\n\n\tfor (; clist; clist = clist->next)\n\t{\n\t\tif (memcmp(clist->args, argtypes, nargs * sizeof(Oid)) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (clist == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"function \\\"%s\\\" does not exist\", pro_name_or_oid)));\n\n\tresult = clist->oid;\n\n\tPG_RETURN_OID(result);\n}"
  },
  {
    "function_name": "regprocsend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "214-219",
    "snippet": "Datum\nregprocsend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidsend, so share code */\n\treturn oidsend(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oidsend",
          "args": [
            "fcinfo"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "oidsend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "150-159",
          "snippet": "Datum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidsend(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\targ1 = PG_GETARG_OID(0);\n\tStringInfoData buf;\n\n\tpq_begintypsend(&buf);\n\tpq_sendint32(&buf, arg1);\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregprocsend(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidsend, so share code */\n\treturn oidsend(fcinfo);\n}"
  },
  {
    "function_name": "regprocrecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "204-209",
    "snippet": "Datum\nregprocrecv(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidrecv, so share code */\n\treturn oidrecv(fcinfo);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "oidrecv",
          "args": [
            "fcinfo"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "oidrecv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/oid.c",
          "lines": "139-145",
          "snippet": "Datum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}",
          "includes": [
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/value.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/value.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\noidrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\n\tPG_RETURN_OID((Oid) pq_getmsgint(buf, sizeof(Oid)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregprocrecv(PG_FUNCTION_ARGS)\n{\n\t/* Exactly the same as oidrecv, so share code */\n\treturn oidrecv(fcinfo);\n}"
  },
  {
    "function_name": "regprocout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "142-199",
    "snippet": "Datum\nregprocout(PG_FUNCTION_ARGS)\n{\n\tRegProcedure proid = PG_GETARG_OID(0);\n\tchar\t   *result;\n\tHeapTuple\tproctup;\n\n\tif (proid == InvalidOid)\n\t{\n\t\tresult = pstrdup(\"-\");\n\t\tPG_RETURN_CSTRING(result);\n\t}\n\n\tproctup = SearchSysCache1(PROCOID, ObjectIdGetDatum(proid));\n\n\tif (HeapTupleIsValid(proctup))\n\t{\n\t\tForm_pg_proc procform = (Form_pg_proc) GETSTRUCT(proctup);\n\t\tchar\t   *proname = NameStr(procform->proname);\n\n\t\t/*\n\t\t * In bootstrap mode, skip the fancy namespace stuff and just return\n\t\t * the proc name.  (This path is only needed for debugging output\n\t\t * anyway.)\n\t\t */\n\t\tif (IsBootstrapProcessingMode())\n\t\t\tresult = pstrdup(proname);\n\t\telse\n\t\t{\n\t\t\tchar\t   *nspname;\n\t\t\tFuncCandidateList clist;\n\n\t\t\t/*\n\t\t\t * Would this proc be found (uniquely!) by regprocin? If not,\n\t\t\t * qualify it.\n\t\t\t */\n\t\t\tclist = FuncnameGetCandidates(list_make1(makeString(proname)),\n\t\t\t\t\t\t\t\t\t\t  -1, NIL, false, false, false);\n\t\t\tif (clist != NULL && clist->next == NULL &&\n\t\t\t\tclist->oid == proid)\n\t\t\t\tnspname = NULL;\n\t\t\telse\n\t\t\t\tnspname = get_namespace_name(procform->pronamespace);\n\n\t\t\tresult = quote_qualified_identifier(nspname, proname);\n\t\t}\n\n\t\tReleaseSysCache(proctup);\n\t}\n\telse\n\t{\n\t\t/* If OID doesn't match any pg_proc entry, return it numerically */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", proid);\n\t}\n\n\tPG_RETURN_CSTRING(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "NAMEDATALEN",
            "\"%u\"",
            "proid"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "NAMEDATALEN"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReleaseSysCache",
          "args": [
            "proctup"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "ReleaseSysCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1159-1163",
          "snippet": "void\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nvoid\nReleaseSysCache(HeapTuple tuple)\n{\n\tReleaseCatCache(tuple);\n}"
        }
      },
      {
        "call_info": {
          "callee": "quote_qualified_identifier",
          "args": [
            "nspname",
            "proname"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "quote_qualified_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/ruleutils.c",
          "lines": "10636-10647",
          "snippet": "char *\nquote_qualified_identifier(const char *qualifier,\n\t\t\t\t\t\t   const char *ident)\n{\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\tif (qualifier)\n\t\tappendStringInfo(&buf, \"%s.\", quote_identifier(qualifier));\n\tappendStringInfoString(&buf, quote_identifier(ident));\n\treturn buf.data;\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/typcache.h\"",
            "#include \"utils/tqual.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/ruleutils.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/partcache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/hsearch.h\"",
            "#include \"utils/guc.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"rewrite/rewriteSupport.h\"",
            "#include \"rewrite/rewriteManip.h\"",
            "#include \"rewrite/rewriteHandler.h\"",
            "#include \"parser/parsetree.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_oper.h\"",
            "#include \"parser/parse_func.h\"",
            "#include \"parser/parse_agg.h\"",
            "#include \"parser/parse_node.h\"",
            "#include \"optimizer/tlist.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"common/keywords.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/defrem.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_trigger.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"catalog/dependency.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/amapi.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int decompile_column_index_array(Datum column_index_array, Oid relId,\n\t\t\t\t\t\t\t StringInfo buf);",
            "static void get_opclass_name(Oid opclass, Oid actual_datatype,\n\t\t\t\t StringInfo buf);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/syscache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/ruleutils.h\"\n#include \"utils/rel.h\"\n#include \"utils/partcache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/hsearch.h\"\n#include \"utils/guc.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"rewrite/rewriteSupport.h\"\n#include \"rewrite/rewriteManip.h\"\n#include \"rewrite/rewriteHandler.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_oper.h\"\n#include \"parser/parse_func.h\"\n#include \"parser/parse_agg.h\"\n#include \"parser/parse_node.h\"\n#include \"optimizer/tlist.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"common/keywords.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/defrem.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_trigger.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"catalog/dependency.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/amapi.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int decompile_column_index_array(Datum column_index_array, Oid relId,\n\t\t\t\t\t\t\t StringInfo buf);\nstatic void get_opclass_name(Oid opclass, Oid actual_datatype,\n\t\t\t\t StringInfo buf);\n\nchar *\nquote_qualified_identifier(const char *qualifier,\n\t\t\t\t\t\t   const char *ident)\n{\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\tif (qualifier)\n\t\tappendStringInfo(&buf, \"%s.\", quote_identifier(qualifier));\n\tappendStringInfoString(&buf, quote_identifier(ident));\n\treturn buf.data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_namespace_name",
          "args": [
            "procform->pronamespace"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "get_namespace_name_or_temp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3098-3105",
          "snippet": "char *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nchar *\nget_namespace_name_or_temp(Oid nspid)\n{\n\tif (isTempNamespace(nspid))\n\t\treturn \"pg_temp\";\n\telse\n\t\treturn get_namespace_name(nspid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FuncnameGetCandidates",
          "args": [
            "list_make1(makeString(proname))",
            "-1",
            "NIL",
            "false",
            "false",
            "false"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_make1",
          "args": [
            "makeString(proname)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makeString",
          "args": [
            "proname"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "makeStringAggState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4765-4787",
          "snippet": "static StringInfo\nmakeStringAggState(FunctionCallInfo fcinfo)\n{\n\tStringInfo\tstate;\n\tMemoryContext aggcontext;\n\tMemoryContext oldcontext;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"string_agg_transfn called in non-aggregate context\");\n\t}\n\n\t/*\n\t * Create state in aggregate context.  It'll stay there across subsequent\n\t * calls.\n\t */\n\toldcontext = MemoryContextSwitchTo(aggcontext);\n\tstate = makeStringInfo();\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void text_position_setup(text *t1, text *t2, TextPositionState *state);",
            "static int\ttext_position_next(int start_pos, TextPositionState *state);",
            "static void text_position_cleanup(TextPositionState *state);",
            "static StringInfo makeStringAggState(FunctionCallInfo fcinfo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void text_position_setup(text *t1, text *t2, TextPositionState *state);\nstatic int\ttext_position_next(int start_pos, TextPositionState *state);\nstatic void text_position_cleanup(TextPositionState *state);\nstatic StringInfo makeStringAggState(FunctionCallInfo fcinfo);\n\nstatic StringInfo\nmakeStringAggState(FunctionCallInfo fcinfo)\n{\n\tStringInfo\tstate;\n\tMemoryContext aggcontext;\n\tMemoryContext oldcontext;\n\n\tif (!AggCheckCallContext(fcinfo, &aggcontext))\n\t{\n\t\t/* cannot be called directly because of internal-type argument */\n\t\telog(ERROR, \"string_agg_transfn called in non-aggregate context\");\n\t}\n\n\t/*\n\t * Create state in aggregate context.  It'll stay there across subsequent\n\t * calls.\n\t */\n\toldcontext = MemoryContextSwitchTo(aggcontext);\n\tstate = makeStringInfo();\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "proname"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1658-1662",
          "snippet": "static char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic char *\nxml_pstrdup(const char *string)\n{\n\treturn MemoryContextStrdup(LibxmlContext, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NameStr",
          "args": [
            "procform->proname"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETSTRUCT",
          "args": [
            "proctup"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleIsValid",
          "args": [
            "proctup"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SearchSysCache1",
          "args": [
            "PROCOID",
            "ObjectIdGetDatum(proid)"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "SearchSysCache1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/syscache.c",
          "lines": "1111-1120",
          "snippet": "HeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"catalog/pg_user_mapping.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_template.h\"",
            "#include \"catalog/pg_ts_parser.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config_map.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_subscription_rel.h\"",
            "#include \"catalog/pg_subscription.h\"",
            "#include \"catalog/pg_statistic_ext.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_replication_origin.h\"",
            "#include \"catalog/pg_shseclabel.h\"",
            "#include \"catalog/pg_shdescription.h\"",
            "#include \"catalog/pg_shdepend.h\"",
            "#include \"catalog/pg_sequence.h\"",
            "#include \"catalog/pg_seclabel.h\"",
            "#include \"catalog/pg_rewrite.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_publication_rel.h\"",
            "#include \"catalog/pg_publication.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_partitioned_table.h\"",
            "#include \"catalog/pg_opfamily.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_foreign_table.h\"",
            "#include \"catalog/pg_foreign_server.h\"",
            "#include \"catalog/pg_foreign_data_wrapper.h\"",
            "#include \"catalog/pg_event_trigger.h\"",
            "#include \"catalog/pg_enum.h\"",
            "#include \"catalog/pg_description.h\"",
            "#include \"catalog/pg_depend.h\"",
            "#include \"catalog/pg_default_acl.h\"",
            "#include \"catalog/pg_db_role_setting.h\"",
            "#include \"catalog/pg_database.h\"",
            "#include \"catalog/pg_conversion.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_cast.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/pg_auth_members.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/pg_aggregate.h\"",
            "#include \"catalog/indexing.h\"",
            "#include \"access/sysattr.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CatCache *SysCache[SysCacheSize];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/catcache.h\"\n#include \"utils/rel.h\"\n#include \"catalog/pg_user_mapping.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_template.h\"\n#include \"catalog/pg_ts_parser.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config_map.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_subscription_rel.h\"\n#include \"catalog/pg_subscription.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_replication_origin.h\"\n#include \"catalog/pg_shseclabel.h\"\n#include \"catalog/pg_shdescription.h\"\n#include \"catalog/pg_shdepend.h\"\n#include \"catalog/pg_sequence.h\"\n#include \"catalog/pg_seclabel.h\"\n#include \"catalog/pg_rewrite.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_publication_rel.h\"\n#include \"catalog/pg_publication.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_partitioned_table.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_foreign_table.h\"\n#include \"catalog/pg_foreign_server.h\"\n#include \"catalog/pg_foreign_data_wrapper.h\"\n#include \"catalog/pg_event_trigger.h\"\n#include \"catalog/pg_enum.h\"\n#include \"catalog/pg_description.h\"\n#include \"catalog/pg_depend.h\"\n#include \"catalog/pg_default_acl.h\"\n#include \"catalog/pg_db_role_setting.h\"\n#include \"catalog/pg_database.h\"\n#include \"catalog/pg_conversion.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_cast.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/pg_auth_members.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/pg_aggregate.h\"\n#include \"catalog/indexing.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"postgres.h\"\n\nstatic CatCache *SysCache[SysCacheSize];\n\nHeapTuple\nSearchSysCache1(int cacheId,\n\t\t\t\tDatum key1)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 1);\n\n\treturn SearchCatCache1(SysCache[cacheId], key1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ObjectIdGetDatum",
          "args": [
            "proid"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "result"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_OID",
          "args": [
            "0"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregprocout(PG_FUNCTION_ARGS)\n{\n\tRegProcedure proid = PG_GETARG_OID(0);\n\tchar\t   *result;\n\tHeapTuple\tproctup;\n\n\tif (proid == InvalidOid)\n\t{\n\t\tresult = pstrdup(\"-\");\n\t\tPG_RETURN_CSTRING(result);\n\t}\n\n\tproctup = SearchSysCache1(PROCOID, ObjectIdGetDatum(proid));\n\n\tif (HeapTupleIsValid(proctup))\n\t{\n\t\tForm_pg_proc procform = (Form_pg_proc) GETSTRUCT(proctup);\n\t\tchar\t   *proname = NameStr(procform->proname);\n\n\t\t/*\n\t\t * In bootstrap mode, skip the fancy namespace stuff and just return\n\t\t * the proc name.  (This path is only needed for debugging output\n\t\t * anyway.)\n\t\t */\n\t\tif (IsBootstrapProcessingMode())\n\t\t\tresult = pstrdup(proname);\n\t\telse\n\t\t{\n\t\t\tchar\t   *nspname;\n\t\t\tFuncCandidateList clist;\n\n\t\t\t/*\n\t\t\t * Would this proc be found (uniquely!) by regprocin? If not,\n\t\t\t * qualify it.\n\t\t\t */\n\t\t\tclist = FuncnameGetCandidates(list_make1(makeString(proname)),\n\t\t\t\t\t\t\t\t\t\t  -1, NIL, false, false, false);\n\t\t\tif (clist != NULL && clist->next == NULL &&\n\t\t\t\tclist->oid == proid)\n\t\t\t\tnspname = NULL;\n\t\t\telse\n\t\t\t\tnspname = get_namespace_name(procform->pronamespace);\n\n\t\t\tresult = quote_qualified_identifier(nspname, proname);\n\t\t}\n\n\t\tReleaseSysCache(proctup);\n\t}\n\telse\n\t{\n\t\t/* If OID doesn't match any pg_proc entry, return it numerically */\n\t\tresult = (char *) palloc(NAMEDATALEN);\n\t\tsnprintf(result, NAMEDATALEN, \"%u\", proid);\n\t}\n\n\tPG_RETURN_CSTRING(result);\n}"
  },
  {
    "function_name": "to_regproc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "119-137",
    "snippet": "Datum\nto_regproc(PG_FUNCTION_ARGS)\n{\n\tchar\t   *pro_name = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tList\t   *names;\n\tFuncCandidateList clist;\n\n\t/*\n\t * Parse the name into components and see if it matches any pg_proc\n\t * entries in the current search path.\n\t */\n\tnames = stringToQualifiedNameList(pro_name);\n\tclist = FuncnameGetCandidates(names, -1, NIL, false, false, true);\n\n\tif (clist == NULL || clist->next != NULL)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_OID(clist->oid);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "clist->oid"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_NULL",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FuncnameGetCandidates",
          "args": [
            "names",
            "-1",
            "NIL",
            "false",
            "false",
            "true"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringToQualifiedNameList",
          "args": [
            "pro_name"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "stringToQualifiedNameList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "1686-1718",
          "snippet": "List *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "PG_GETARG_TEXT_PP(0)"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nto_regproc(PG_FUNCTION_ARGS)\n{\n\tchar\t   *pro_name = text_to_cstring(PG_GETARG_TEXT_PP(0));\n\tList\t   *names;\n\tFuncCandidateList clist;\n\n\t/*\n\t * Parse the name into components and see if it matches any pg_proc\n\t * entries in the current search path.\n\t */\n\tnames = stringToQualifiedNameList(pro_name);\n\tclist = FuncnameGetCandidates(names, -1, NIL, false, false, true);\n\n\tif (clist == NULL || clist->next != NULL)\n\t\tPG_RETURN_NULL();\n\n\tPG_RETURN_OID(clist->oid);\n}"
  },
  {
    "function_name": "regprocin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
    "lines": "61-112",
    "snippet": "Datum\nregprocin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *pro_name_or_oid = PG_GETARG_CSTRING(0);\n\tRegProcedure result = InvalidOid;\n\tList\t   *names;\n\tFuncCandidateList clist;\n\n\t/* '-' ? */\n\tif (strcmp(pro_name_or_oid, \"-\") == 0)\n\t\tPG_RETURN_OID(InvalidOid);\n\n\t/* Numeric OID? */\n\tif (pro_name_or_oid[0] >= '0' &&\n\t\tpro_name_or_oid[0] <= '9' &&\n\t\tstrspn(pro_name_or_oid, \"0123456789\") == strlen(pro_name_or_oid))\n\t{\n\t\tresult = DatumGetObjectId(DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(pro_name_or_oid)));\n\t\tPG_RETURN_OID(result);\n\t}\n\n\t/* Else it's a name, possibly schema-qualified */\n\n\t/*\n\t * We should never get here in bootstrap mode, as all references should\n\t * have been resolved by genbki.pl.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t\telog(ERROR, \"regproc values must be OIDs in bootstrap mode\");\n\n\t/*\n\t * Normal case: parse the name into components and see if it matches any\n\t * pg_proc entries in the current search path.\n\t */\n\tnames = stringToQualifiedNameList(pro_name_or_oid);\n\tclist = FuncnameGetCandidates(names, -1, NIL, false, false, false);\n\n\tif (clist == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"function \\\"%s\\\" does not exist\", pro_name_or_oid)));\n\telse if (clist->next != NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_AMBIGUOUS_FUNCTION),\n\t\t\t\t errmsg(\"more than one function named \\\"%s\\\"\",\n\t\t\t\t\t\tpro_name_or_oid)));\n\n\tresult = clist->oid;\n\n\tPG_RETURN_OID(result);\n}",
    "includes": [
      "#include \"utils/varlena.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/acl.h\"",
      "#include \"utils/syscache.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"parser/scansup.h\"",
      "#include \"parser/parse_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"lib/stringinfo.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/pg_ts_dict.h\"",
      "#include \"catalog/pg_ts_config.h\"",
      "#include \"catalog/pg_proc.h\"",
      "#include \"catalog/pg_operator.h\"",
      "#include \"catalog/pg_class.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <ctype.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_AMBIGUOUS_FUNCTION),\n\t\t\t\t errmsg(\"more than one function named \\\"%s\\\"\",\n\t\t\t\t\t\tpro_name_or_oid))"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"more than one function named \\\"%s\\\"\"",
            "pro_name_or_oid"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_AMBIGUOUS_FUNCTION"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"function \\\"%s\\\" does not exist\", pro_name_or_oid))"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FuncnameGetCandidates",
          "args": [
            "names",
            "-1",
            "NIL",
            "false",
            "false",
            "false"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringToQualifiedNameList",
          "args": [
            "pro_name_or_oid"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "stringToQualifiedNameList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "1686-1718",
          "snippet": "List *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"regproc values must be OIDs in bootstrap mode\""
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBootstrapProcessingMode",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "result"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetObjectId",
          "args": [
            "DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(pro_name_or_oid))"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "oidin",
            "CStringGetDatum(pro_name_or_oid)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CStringGetDatum",
          "args": [
            "pro_name_or_oid"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pro_name_or_oid"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "pro_name_or_oid",
            "\"0123456789\""
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_OID",
          "args": [
            "InvalidOid"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pro_name_or_oid",
            "\"-\""
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nDatum\nregprocin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *pro_name_or_oid = PG_GETARG_CSTRING(0);\n\tRegProcedure result = InvalidOid;\n\tList\t   *names;\n\tFuncCandidateList clist;\n\n\t/* '-' ? */\n\tif (strcmp(pro_name_or_oid, \"-\") == 0)\n\t\tPG_RETURN_OID(InvalidOid);\n\n\t/* Numeric OID? */\n\tif (pro_name_or_oid[0] >= '0' &&\n\t\tpro_name_or_oid[0] <= '9' &&\n\t\tstrspn(pro_name_or_oid, \"0123456789\") == strlen(pro_name_or_oid))\n\t{\n\t\tresult = DatumGetObjectId(DirectFunctionCall1(oidin,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  CStringGetDatum(pro_name_or_oid)));\n\t\tPG_RETURN_OID(result);\n\t}\n\n\t/* Else it's a name, possibly schema-qualified */\n\n\t/*\n\t * We should never get here in bootstrap mode, as all references should\n\t * have been resolved by genbki.pl.\n\t */\n\tif (IsBootstrapProcessingMode())\n\t\telog(ERROR, \"regproc values must be OIDs in bootstrap mode\");\n\n\t/*\n\t * Normal case: parse the name into components and see if it matches any\n\t * pg_proc entries in the current search path.\n\t */\n\tnames = stringToQualifiedNameList(pro_name_or_oid);\n\tclist = FuncnameGetCandidates(names, -1, NIL, false, false, false);\n\n\tif (clist == NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"function \\\"%s\\\" does not exist\", pro_name_or_oid)));\n\telse if (clist->next != NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_AMBIGUOUS_FUNCTION),\n\t\t\t\t errmsg(\"more than one function named \\\"%s\\\"\",\n\t\t\t\t\t\tpro_name_or_oid)));\n\n\tresult = clist->oid;\n\n\tPG_RETURN_OID(result);\n}"
  }
]