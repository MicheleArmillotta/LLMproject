[
  {
    "function_name": "tsvectorrecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector.c",
    "lines": "441-550",
    "snippet": "Datum\ntsvectorrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tTSVector\tvec;\n\tint\t\t\ti;\n\tint32\t\tnentries;\n\tint\t\t\tdatalen;\t\t/* number of bytes used in the variable size\n\t\t\t\t\t\t\t\t * area after fixed size TSVector header and\n\t\t\t\t\t\t\t\t * WordEntries */\n\tSize\t\thdrlen;\n\tSize\t\tlen;\t\t\t/* allocated size of vec */\n\tbool\t\tneedSort = false;\n\n\tnentries = pq_getmsgint(buf, sizeof(int32));\n\tif (nentries < 0 || nentries > (MaxAllocSize / sizeof(WordEntry)))\n\t\telog(ERROR, \"invalid size of tsvector\");\n\n\thdrlen = DATAHDRSIZE + sizeof(WordEntry) * nentries;\n\n\tlen = hdrlen * 2;\t\t\t/* times two to make room for lexemes */\n\tvec = (TSVector) palloc0(len);\n\tvec->size = nentries;\n\n\tdatalen = 0;\n\tfor (i = 0; i < nentries; i++)\n\t{\n\t\tconst char *lexeme;\n\t\tuint16\t\tnpos;\n\t\tsize_t\t\tlex_len;\n\n\t\tlexeme = pq_getmsgstring(buf);\n\t\tnpos = (uint16) pq_getmsgint(buf, sizeof(uint16));\n\n\t\t/* sanity checks */\n\n\t\tlex_len = strlen(lexeme);\n\t\tif (lex_len > MAXSTRLEN)\n\t\t\telog(ERROR, \"invalid tsvector: lexeme too long\");\n\n\t\tif (datalen > MAXSTRPOS)\n\t\t\telog(ERROR, \"invalid tsvector: maximum total lexeme length exceeded\");\n\n\t\tif (npos > MAXNUMPOS)\n\t\t\telog(ERROR, \"unexpected number of tsvector positions\");\n\n\t\t/*\n\t\t * Looks valid. Fill the WordEntry struct, and copy lexeme.\n\t\t *\n\t\t * But make sure the buffer is large enough first.\n\t\t */\n\t\twhile (hdrlen + SHORTALIGN(datalen + lex_len) +\n\t\t\t   (npos + 1) * sizeof(WordEntryPos) >= len)\n\t\t{\n\t\t\tlen *= 2;\n\t\t\tvec = (TSVector) repalloc(vec, len);\n\t\t}\n\n\t\tvec->entries[i].haspos = (npos > 0) ? 1 : 0;\n\t\tvec->entries[i].len = lex_len;\n\t\tvec->entries[i].pos = datalen;\n\n\t\tmemcpy(STRPTR(vec) + datalen, lexeme, lex_len);\n\n\t\tdatalen += lex_len;\n\n\t\tif (i > 0 && WordEntryCMP(&vec->entries[i],\n\t\t\t\t\t\t\t\t  &vec->entries[i - 1],\n\t\t\t\t\t\t\t\t  STRPTR(vec)) <= 0)\n\t\t\tneedSort = true;\n\n\t\t/* Receive positions */\n\t\tif (npos > 0)\n\t\t{\n\t\t\tuint16\t\tj;\n\t\t\tWordEntryPos *wepptr;\n\n\t\t\t/*\n\t\t\t * Pad to 2-byte alignment if necessary. Though we used palloc0\n\t\t\t * for the initial allocation, subsequent repalloc'd memory areas\n\t\t\t * are not initialized to zero.\n\t\t\t */\n\t\t\tif (datalen != SHORTALIGN(datalen))\n\t\t\t{\n\t\t\t\t*(STRPTR(vec) + datalen) = '\\0';\n\t\t\t\tdatalen = SHORTALIGN(datalen);\n\t\t\t}\n\n\t\t\tmemcpy(STRPTR(vec) + datalen, &npos, sizeof(uint16));\n\n\t\t\twepptr = POSDATAPTR(vec, &vec->entries[i]);\n\t\t\tfor (j = 0; j < npos; j++)\n\t\t\t{\n\t\t\t\twepptr[j] = (WordEntryPos) pq_getmsgint(buf, sizeof(WordEntryPos));\n\t\t\t\tif (j > 0 && WEP_GETPOS(wepptr[j]) <= WEP_GETPOS(wepptr[j - 1]))\n\t\t\t\t\telog(ERROR, \"position information is misordered\");\n\t\t\t}\n\n\t\t\tdatalen += (npos + 1) * sizeof(WordEntry);\n\t\t}\n\t}\n\n\tSET_VARSIZE(vec, hdrlen + datalen);\n\n\tif (needSort)\n\t\tqsort_arg((void *) ARRPTR(vec), vec->size, sizeof(WordEntry),\n\t\t\t\t  compareentry, (void *) STRPTR(vec));\n\n\tPG_RETURN_TSVECTOR(vec);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TSVECTOR",
          "args": [
            "vec"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort_arg",
          "args": [
            "(void *) ARRPTR(vec)",
            "vec->size",
            "sizeof(WordEntry)",
            "compareentry",
            "(void *) STRPTR(vec)"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "vec"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "vec"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "vec",
            "hdrlen + datalen"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"position information is misordered\""
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "wepptr[j - 1]"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "wepptr[j]"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(WordEntryPos)"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATAPTR",
          "args": [
            "vec",
            "&vec->entries[i]"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "STRPTR(vec) + datalen",
            "&npos",
            "sizeof(uint16)"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "vec"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHORTALIGN",
          "args": [
            "datalen"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "vec"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHORTALIGN",
          "args": [
            "datalen"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WordEntryCMP",
          "args": [
            "&vec->entries[i]",
            "&vec->entries[i - 1]",
            "STRPTR(vec)"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "WordEntryCMP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector.c",
          "lines": "169-173",
          "snippet": "static int\nWordEntryCMP(WordEntry *a, WordEntry *b, char *buf)\n{\n\treturn compareentry(a, b, buf);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic int\nWordEntryCMP(WordEntry *a, WordEntry *b, char *buf)\n{\n\treturn compareentry(a, b, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "vec"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "STRPTR(vec) + datalen",
            "lexeme",
            "lex_len"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "vec"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "vec",
            "len"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SHORTALIGN",
          "args": [
            "datalen + lex_len"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lexeme"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(uint16)"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_getmsgstring",
          "args": [
            "buf"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "len"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_getmsgint",
          "args": [
            "buf",
            "sizeof(int32)"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_POINTER",
          "args": [
            "0"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nDatum\ntsvectorrecv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tTSVector\tvec;\n\tint\t\t\ti;\n\tint32\t\tnentries;\n\tint\t\t\tdatalen;\t\t/* number of bytes used in the variable size\n\t\t\t\t\t\t\t\t * area after fixed size TSVector header and\n\t\t\t\t\t\t\t\t * WordEntries */\n\tSize\t\thdrlen;\n\tSize\t\tlen;\t\t\t/* allocated size of vec */\n\tbool\t\tneedSort = false;\n\n\tnentries = pq_getmsgint(buf, sizeof(int32));\n\tif (nentries < 0 || nentries > (MaxAllocSize / sizeof(WordEntry)))\n\t\telog(ERROR, \"invalid size of tsvector\");\n\n\thdrlen = DATAHDRSIZE + sizeof(WordEntry) * nentries;\n\n\tlen = hdrlen * 2;\t\t\t/* times two to make room for lexemes */\n\tvec = (TSVector) palloc0(len);\n\tvec->size = nentries;\n\n\tdatalen = 0;\n\tfor (i = 0; i < nentries; i++)\n\t{\n\t\tconst char *lexeme;\n\t\tuint16\t\tnpos;\n\t\tsize_t\t\tlex_len;\n\n\t\tlexeme = pq_getmsgstring(buf);\n\t\tnpos = (uint16) pq_getmsgint(buf, sizeof(uint16));\n\n\t\t/* sanity checks */\n\n\t\tlex_len = strlen(lexeme);\n\t\tif (lex_len > MAXSTRLEN)\n\t\t\telog(ERROR, \"invalid tsvector: lexeme too long\");\n\n\t\tif (datalen > MAXSTRPOS)\n\t\t\telog(ERROR, \"invalid tsvector: maximum total lexeme length exceeded\");\n\n\t\tif (npos > MAXNUMPOS)\n\t\t\telog(ERROR, \"unexpected number of tsvector positions\");\n\n\t\t/*\n\t\t * Looks valid. Fill the WordEntry struct, and copy lexeme.\n\t\t *\n\t\t * But make sure the buffer is large enough first.\n\t\t */\n\t\twhile (hdrlen + SHORTALIGN(datalen + lex_len) +\n\t\t\t   (npos + 1) * sizeof(WordEntryPos) >= len)\n\t\t{\n\t\t\tlen *= 2;\n\t\t\tvec = (TSVector) repalloc(vec, len);\n\t\t}\n\n\t\tvec->entries[i].haspos = (npos > 0) ? 1 : 0;\n\t\tvec->entries[i].len = lex_len;\n\t\tvec->entries[i].pos = datalen;\n\n\t\tmemcpy(STRPTR(vec) + datalen, lexeme, lex_len);\n\n\t\tdatalen += lex_len;\n\n\t\tif (i > 0 && WordEntryCMP(&vec->entries[i],\n\t\t\t\t\t\t\t\t  &vec->entries[i - 1],\n\t\t\t\t\t\t\t\t  STRPTR(vec)) <= 0)\n\t\t\tneedSort = true;\n\n\t\t/* Receive positions */\n\t\tif (npos > 0)\n\t\t{\n\t\t\tuint16\t\tj;\n\t\t\tWordEntryPos *wepptr;\n\n\t\t\t/*\n\t\t\t * Pad to 2-byte alignment if necessary. Though we used palloc0\n\t\t\t * for the initial allocation, subsequent repalloc'd memory areas\n\t\t\t * are not initialized to zero.\n\t\t\t */\n\t\t\tif (datalen != SHORTALIGN(datalen))\n\t\t\t{\n\t\t\t\t*(STRPTR(vec) + datalen) = '\\0';\n\t\t\t\tdatalen = SHORTALIGN(datalen);\n\t\t\t}\n\n\t\t\tmemcpy(STRPTR(vec) + datalen, &npos, sizeof(uint16));\n\n\t\t\twepptr = POSDATAPTR(vec, &vec->entries[i]);\n\t\t\tfor (j = 0; j < npos; j++)\n\t\t\t{\n\t\t\t\twepptr[j] = (WordEntryPos) pq_getmsgint(buf, sizeof(WordEntryPos));\n\t\t\t\tif (j > 0 && WEP_GETPOS(wepptr[j]) <= WEP_GETPOS(wepptr[j - 1]))\n\t\t\t\t\telog(ERROR, \"position information is misordered\");\n\t\t\t}\n\n\t\t\tdatalen += (npos + 1) * sizeof(WordEntry);\n\t\t}\n\t}\n\n\tSET_VARSIZE(vec, hdrlen + datalen);\n\n\tif (needSort)\n\t\tqsort_arg((void *) ARRPTR(vec), vec->size, sizeof(WordEntry),\n\t\t\t\t  compareentry, (void *) STRPTR(vec));\n\n\tPG_RETURN_TSVECTOR(vec);\n}"
  },
  {
    "function_name": "tsvectorsend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector.c",
    "lines": "402-439",
    "snippet": "Datum\ntsvectorsend(PG_FUNCTION_ARGS)\n{\n\tTSVector\tvec = PG_GETARG_TSVECTOR(0);\n\tStringInfoData buf;\n\tint\t\t\ti,\n\t\t\t\tj;\n\tWordEntry  *weptr = ARRPTR(vec);\n\n\tpq_begintypsend(&buf);\n\n\tpq_sendint32(&buf, vec->size);\n\tfor (i = 0; i < vec->size; i++)\n\t{\n\t\tuint16\t\tnpos;\n\n\t\t/*\n\t\t * the strings in the TSVector array are not null-terminated, so we\n\t\t * have to send the null-terminator separately\n\t\t */\n\t\tpq_sendtext(&buf, STRPTR(vec) + weptr->pos, weptr->len);\n\t\tpq_sendbyte(&buf, '\\0');\n\n\t\tnpos = POSDATALEN(vec, weptr);\n\t\tpq_sendint16(&buf, npos);\n\n\t\tif (npos > 0)\n\t\t{\n\t\t\tWordEntryPos *wepptr = POSDATAPTR(vec, weptr);\n\n\t\t\tfor (j = 0; j < npos; j++)\n\t\t\t\tpq_sendint16(&buf, wepptr[j]);\n\t\t}\n\t\tweptr++;\n\t}\n\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BYTEA_P",
          "args": [
            "pq_endtypsend(&buf)"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endtypsend",
          "args": [
            "&buf"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint16",
          "args": [
            "&buf",
            "wepptr[j]"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATAPTR",
          "args": [
            "vec",
            "weptr"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint16",
          "args": [
            "&buf",
            "npos"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "vec",
            "weptr"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&buf",
            "'\\0'"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendtext",
          "args": [
            "&buf",
            "STRPTR(vec) + weptr->pos",
            "weptr->len"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "vec"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendint32",
          "args": [
            "&buf",
            "vec->size"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_begintypsend",
          "args": [
            "&buf"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "vec"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "0"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nDatum\ntsvectorsend(PG_FUNCTION_ARGS)\n{\n\tTSVector\tvec = PG_GETARG_TSVECTOR(0);\n\tStringInfoData buf;\n\tint\t\t\ti,\n\t\t\t\tj;\n\tWordEntry  *weptr = ARRPTR(vec);\n\n\tpq_begintypsend(&buf);\n\n\tpq_sendint32(&buf, vec->size);\n\tfor (i = 0; i < vec->size; i++)\n\t{\n\t\tuint16\t\tnpos;\n\n\t\t/*\n\t\t * the strings in the TSVector array are not null-terminated, so we\n\t\t * have to send the null-terminator separately\n\t\t */\n\t\tpq_sendtext(&buf, STRPTR(vec) + weptr->pos, weptr->len);\n\t\tpq_sendbyte(&buf, '\\0');\n\n\t\tnpos = POSDATALEN(vec, weptr);\n\t\tpq_sendint16(&buf, npos);\n\n\t\tif (npos > 0)\n\t\t{\n\t\t\tWordEntryPos *wepptr = POSDATAPTR(vec, weptr);\n\n\t\t\tfor (j = 0; j < npos; j++)\n\t\t\t\tpq_sendint16(&buf, wepptr[j]);\n\t\t}\n\t\tweptr++;\n\t}\n\n\tPG_RETURN_BYTEA_P(pq_endtypsend(&buf));\n}"
  },
  {
    "function_name": "tsvectorout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector.c",
    "lines": "309-388",
    "snippet": "Datum\ntsvectorout(PG_FUNCTION_ARGS)\n{\n\tTSVector\tout = PG_GETARG_TSVECTOR(0);\n\tchar\t   *outbuf;\n\tint32\t\ti,\n\t\t\t\tlenbuf = 0,\n\t\t\t\tpp;\n\tWordEntry  *ptr = ARRPTR(out);\n\tchar\t   *curbegin,\n\t\t\t   *curin,\n\t\t\t   *curout;\n\n\tlenbuf = out->size * 2 /* '' */ + out->size - 1 /* space */ + 2 /* \\0 */ ;\n\tfor (i = 0; i < out->size; i++)\n\t{\n\t\tlenbuf += ptr[i].len * 2 * pg_database_encoding_max_length() /* for escape */ ;\n\t\tif (ptr[i].haspos)\n\t\t\tlenbuf += 1 /* : */ + 7 /* int2 + , + weight */ * POSDATALEN(out, &(ptr[i]));\n\t}\n\n\tcurout = outbuf = (char *) palloc(lenbuf);\n\tfor (i = 0; i < out->size; i++)\n\t{\n\t\tcurbegin = curin = STRPTR(out) + ptr->pos;\n\t\tif (i != 0)\n\t\t\t*curout++ = ' ';\n\t\t*curout++ = '\\'';\n\t\twhile (curin - curbegin < ptr->len)\n\t\t{\n\t\t\tint\t\t\tlen = pg_mblen(curin);\n\n\t\t\tif (t_iseq(curin, '\\''))\n\t\t\t\t*curout++ = '\\'';\n\t\t\telse if (t_iseq(curin, '\\\\'))\n\t\t\t\t*curout++ = '\\\\';\n\n\t\t\twhile (len--)\n\t\t\t\t*curout++ = *curin++;\n\t\t}\n\n\t\t*curout++ = '\\'';\n\t\tif ((pp = POSDATALEN(out, ptr)) != 0)\n\t\t{\n\t\t\tWordEntryPos *wptr;\n\n\t\t\t*curout++ = ':';\n\t\t\twptr = POSDATAPTR(out, ptr);\n\t\t\twhile (pp)\n\t\t\t{\n\t\t\t\tcurout += sprintf(curout, \"%d\", WEP_GETPOS(*wptr));\n\t\t\t\tswitch (WEP_GETWEIGHT(*wptr))\n\t\t\t\t{\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\t*curout++ = 'A';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t*curout++ = 'B';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t*curout++ = 'C';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (pp > 1)\n\t\t\t\t\t*curout++ = ',';\n\t\t\t\tpp--;\n\t\t\t\twptr++;\n\t\t\t}\n\t\t}\n\t\tptr++;\n\t}\n\n\t*curout = '\\0';\n\tPG_FREE_IF_COPY(out, 0);\n\tPG_RETURN_CSTRING(outbuf);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_CSTRING",
          "args": [
            "outbuf"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "out",
            "0"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "*wptr"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "curout",
            "\"%d\"",
            "WEP_GETPOS(*wptr)"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "*wptr"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATAPTR",
          "args": [
            "out",
            "ptr"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "out",
            "ptr"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t_iseq",
          "args": [
            "curin",
            "'\\\\'"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "text_isequal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "4281-4287",
          "snippet": "static bool\ntext_isequal(text *txt1, text *txt2)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2)));\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool\ntext_isequal(text *txt1, text *txt2)\n{\n\treturn DatumGetBool(DirectFunctionCall2(texteq,\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt1),\n\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(txt2)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "curin"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "out"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "lenbuf"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "out",
            "&(ptr[i])"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_database_encoding_max_length",
          "args": [],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "pg_database_encoding_max_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wchar.c",
          "lines": "1832-1836",
          "snippet": "int\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n#include \"postgres_fe.h\"\n\nconst pg_wchar_tbl pg_wchar_table[] = {\n\t{pg_ascii2wchar_with_len, pg_wchar2single_with_len, pg_ascii_mblen, pg_ascii_dsplen, pg_ascii_verifier, 1}, /* PG_SQL_ASCII */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JP */\n\t{pg_euccn2wchar_with_len, pg_wchar2euc_with_len, pg_euccn_mblen, pg_euccn_dsplen, pg_euccn_verifier, 2},\t/* PG_EUC_CN */\n\t{pg_euckr2wchar_with_len, pg_wchar2euc_with_len, pg_euckr_mblen, pg_euckr_dsplen, pg_euckr_verifier, 3},\t/* PG_EUC_KR */\n\t{pg_euctw2wchar_with_len, pg_wchar2euc_with_len, pg_euctw_mblen, pg_euctw_dsplen, pg_euctw_verifier, 4},\t/* PG_EUC_TW */\n\t{pg_eucjp2wchar_with_len, pg_wchar2euc_with_len, pg_eucjp_mblen, pg_eucjp_dsplen, pg_eucjp_verifier, 3},\t/* PG_EUC_JIS_2004 */\n\t{pg_utf2wchar_with_len, pg_wchar2utf_with_len, pg_utf_mblen, pg_utf_dsplen, pg_utf8_verifier, 4},\t/* PG_UTF8 */\n\t{pg_mule2wchar_with_len, pg_wchar2mule_with_len, pg_mule_mblen, pg_mule_dsplen, pg_mule_verifier, 4},\t/* PG_MULE_INTERNAL */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN1 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN2 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN3 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN4 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN9 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_LATIN10 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1256 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1258 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN866 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN874 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8R */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1251 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1252 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-5 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-6 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-7 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* ISO-8859-8 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1250 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1253 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1254 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1255 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_WIN1257 */\n\t{pg_latin12wchar_with_len, pg_wchar2single_with_len, pg_latin1_mblen, pg_latin1_dsplen, pg_latin1_verifier, 1}, /* PG_KOI8U */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}, /* PG_SJIS */\n\t{0, 0, pg_big5_mblen, pg_big5_dsplen, pg_big5_verifier, 2}, /* PG_BIG5 */\n\t{0, 0, pg_gbk_mblen, pg_gbk_dsplen, pg_gbk_verifier, 2},\t/* PG_GBK */\n\t{0, 0, pg_uhc_mblen, pg_uhc_dsplen, pg_uhc_verifier, 2},\t/* PG_UHC */\n\t{0, 0, pg_gb18030_mblen, pg_gb18030_dsplen, pg_gb18030_verifier, 4},\t/* PG_GB18030 */\n\t{0, 0, pg_johab_mblen, pg_johab_dsplen, pg_johab_verifier, 3},\t/* PG_JOHAB */\n\t{0, 0, pg_sjis_mblen, pg_sjis_dsplen, pg_sjis_verifier, 2}\t/* PG_SHIFT_JIS_2004 */\n};\n\nint\npg_database_encoding_max_length(void)\n{\n\treturn pg_wchar_table[GetDatabaseEncoding()].maxmblen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "out"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "0"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nDatum\ntsvectorout(PG_FUNCTION_ARGS)\n{\n\tTSVector\tout = PG_GETARG_TSVECTOR(0);\n\tchar\t   *outbuf;\n\tint32\t\ti,\n\t\t\t\tlenbuf = 0,\n\t\t\t\tpp;\n\tWordEntry  *ptr = ARRPTR(out);\n\tchar\t   *curbegin,\n\t\t\t   *curin,\n\t\t\t   *curout;\n\n\tlenbuf = out->size * 2 /* '' */ + out->size - 1 /* space */ + 2 /* \\0 */ ;\n\tfor (i = 0; i < out->size; i++)\n\t{\n\t\tlenbuf += ptr[i].len * 2 * pg_database_encoding_max_length() /* for escape */ ;\n\t\tif (ptr[i].haspos)\n\t\t\tlenbuf += 1 /* : */ + 7 /* int2 + , + weight */ * POSDATALEN(out, &(ptr[i]));\n\t}\n\n\tcurout = outbuf = (char *) palloc(lenbuf);\n\tfor (i = 0; i < out->size; i++)\n\t{\n\t\tcurbegin = curin = STRPTR(out) + ptr->pos;\n\t\tif (i != 0)\n\t\t\t*curout++ = ' ';\n\t\t*curout++ = '\\'';\n\t\twhile (curin - curbegin < ptr->len)\n\t\t{\n\t\t\tint\t\t\tlen = pg_mblen(curin);\n\n\t\t\tif (t_iseq(curin, '\\''))\n\t\t\t\t*curout++ = '\\'';\n\t\t\telse if (t_iseq(curin, '\\\\'))\n\t\t\t\t*curout++ = '\\\\';\n\n\t\t\twhile (len--)\n\t\t\t\t*curout++ = *curin++;\n\t\t}\n\n\t\t*curout++ = '\\'';\n\t\tif ((pp = POSDATALEN(out, ptr)) != 0)\n\t\t{\n\t\t\tWordEntryPos *wptr;\n\n\t\t\t*curout++ = ':';\n\t\t\twptr = POSDATAPTR(out, ptr);\n\t\t\twhile (pp)\n\t\t\t{\n\t\t\t\tcurout += sprintf(curout, \"%d\", WEP_GETPOS(*wptr));\n\t\t\t\tswitch (WEP_GETWEIGHT(*wptr))\n\t\t\t\t{\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\t*curout++ = 'A';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t*curout++ = 'B';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t*curout++ = 'C';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (pp > 1)\n\t\t\t\t\t*curout++ = ',';\n\t\t\t\tpp--;\n\t\t\t\twptr++;\n\t\t\t}\n\t\t}\n\t\tptr++;\n\t}\n\n\t*curout = '\\0';\n\tPG_FREE_IF_COPY(out, 0);\n\tPG_RETURN_CSTRING(outbuf);\n}"
  },
  {
    "function_name": "tsvectorin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector.c",
    "lines": "176-307",
    "snippet": "Datum\ntsvectorin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *buf = PG_GETARG_CSTRING(0);\n\tTSVectorParseState state;\n\tWordEntryIN *arr;\n\tint\t\t\ttotallen;\n\tint\t\t\tarrlen;\t\t\t/* allocated size of arr */\n\tWordEntry  *inarr;\n\tint\t\t\tlen = 0;\n\tTSVector\tin;\n\tint\t\t\ti;\n\tchar\t   *token;\n\tint\t\t\ttoklen;\n\tWordEntryPos *pos;\n\tint\t\t\tposlen;\n\tchar\t   *strbuf;\n\tint\t\t\tstroff;\n\n\t/*\n\t * Tokens are appended to tmpbuf, cur is a pointer to the end of used\n\t * space in tmpbuf.\n\t */\n\tchar\t   *tmpbuf;\n\tchar\t   *cur;\n\tint\t\t\tbuflen = 256;\t/* allocated size of tmpbuf */\n\n\tstate = init_tsvector_parser(buf, 0);\n\n\tarrlen = 64;\n\tarr = (WordEntryIN *) palloc(sizeof(WordEntryIN) * arrlen);\n\tcur = tmpbuf = (char *) palloc(buflen);\n\n\twhile (gettoken_tsvector(state, &token, &toklen, &pos, &poslen, NULL))\n\t{\n\t\tif (toklen >= MAXSTRLEN)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"word is too long (%ld bytes, max %ld bytes)\",\n\t\t\t\t\t\t\t(long) toklen,\n\t\t\t\t\t\t\t(long) (MAXSTRLEN - 1))));\n\n\t\tif (cur - tmpbuf > MAXSTRPOS)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"string is too long for tsvector (%ld bytes, max %ld bytes)\",\n\t\t\t\t\t\t\t(long) (cur - tmpbuf), (long) MAXSTRPOS)));\n\n\t\t/*\n\t\t * Enlarge buffers if needed\n\t\t */\n\t\tif (len >= arrlen)\n\t\t{\n\t\t\tarrlen *= 2;\n\t\t\tarr = (WordEntryIN *)\n\t\t\t\trepalloc((void *) arr, sizeof(WordEntryIN) * arrlen);\n\t\t}\n\t\twhile ((cur - tmpbuf) + toklen >= buflen)\n\t\t{\n\t\t\tint\t\t\tdist = cur - tmpbuf;\n\n\t\t\tbuflen *= 2;\n\t\t\ttmpbuf = (char *) repalloc((void *) tmpbuf, buflen);\n\t\t\tcur = tmpbuf + dist;\n\t\t}\n\t\tarr[len].entry.len = toklen;\n\t\tarr[len].entry.pos = cur - tmpbuf;\n\t\tmemcpy((void *) cur, (void *) token, toklen);\n\t\tcur += toklen;\n\n\t\tif (poslen != 0)\n\t\t{\n\t\t\tarr[len].entry.haspos = 1;\n\t\t\tarr[len].pos = pos;\n\t\t\tarr[len].poslen = poslen;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarr[len].entry.haspos = 0;\n\t\t\tarr[len].pos = NULL;\n\t\t\tarr[len].poslen = 0;\n\t\t}\n\t\tlen++;\n\t}\n\n\tclose_tsvector_parser(state);\n\n\tif (len > 0)\n\t\tlen = uniqueentry(arr, len, tmpbuf, &buflen);\n\telse\n\t\tbuflen = 0;\n\n\tif (buflen > MAXSTRPOS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"string is too long for tsvector (%d bytes, max %d bytes)\", buflen, MAXSTRPOS)));\n\n\ttotallen = CALCDATASIZE(len, buflen);\n\tin = (TSVector) palloc0(totallen);\n\tSET_VARSIZE(in, totallen);\n\tin->size = len;\n\tinarr = ARRPTR(in);\n\tstrbuf = STRPTR(in);\n\tstroff = 0;\n\tfor (i = 0; i < len; i++)\n\t{\n\t\tmemcpy(strbuf + stroff, &tmpbuf[arr[i].entry.pos], arr[i].entry.len);\n\t\tarr[i].entry.pos = stroff;\n\t\tstroff += arr[i].entry.len;\n\t\tif (arr[i].entry.haspos)\n\t\t{\n\t\t\tif (arr[i].poslen > 0xFFFF)\n\t\t\t\telog(ERROR, \"positions array too long\");\n\n\t\t\t/* Copy number of positions */\n\t\t\tstroff = SHORTALIGN(stroff);\n\t\t\t*(uint16 *) (strbuf + stroff) = (uint16) arr[i].poslen;\n\t\t\tstroff += sizeof(uint16);\n\n\t\t\t/* Copy positions */\n\t\t\tmemcpy(strbuf + stroff, arr[i].pos, arr[i].poslen * sizeof(WordEntryPos));\n\t\t\tstroff += arr[i].poslen * sizeof(WordEntryPos);\n\n\t\t\tpfree(arr[i].pos);\n\t\t}\n\t\tinarr[i] = arr[i].entry;\n\t}\n\n\tAssert((strbuf + stroff - (char *) in) == totallen);\n\n\tPG_RETURN_TSVECTOR(in);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_TSVECTOR",
          "args": [
            "in"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "(strbuf + stroff - (char *) in) == totallen"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "arr[i].pos"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "strbuf + stroff",
            "arr[i].pos",
            "arr[i].poslen * sizeof(WordEntryPos)"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHORTALIGN",
          "args": [
            "stroff"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"positions array too long\""
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "strbuf + stroff",
            "&tmpbuf[arr[i].entry.pos]",
            "arr[i].entry.len"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "in"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "in"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "in",
            "totallen"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "totallen"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CALCDATASIZE",
          "args": [
            "len",
            "buflen"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"string is too long for tsvector (%d bytes, max %d bytes)\", buflen, MAXSTRPOS))"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"string is too long for tsvector (%d bytes, max %d bytes)\"",
            "buflen",
            "MAXSTRPOS"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "uniqueentry",
          "args": [
            "arr",
            "len",
            "tmpbuf",
            "&buflen"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "uniqueentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector.c",
          "lines": "97-167",
          "snippet": "static int\nuniqueentry(WordEntryIN *a, int l, char *buf, int *outbuflen)\n{\n\tint\t\t\tbuflen;\n\tWordEntryIN *ptr,\n\t\t\t   *res;\n\n\tAssert(l >= 1);\n\n\tif (l > 1)\n\t\tqsort_arg((void *) a, l, sizeof(WordEntryIN), compareentry,\n\t\t\t\t  (void *) buf);\n\n\tbuflen = 0;\n\tres = a;\n\tptr = a + 1;\n\twhile (ptr - a < l)\n\t{\n\t\tif (!(ptr->entry.len == res->entry.len &&\n\t\t\t  strncmp(&buf[ptr->entry.pos], &buf[res->entry.pos],\n\t\t\t\t\t  res->entry.len) == 0))\n\t\t{\n\t\t\t/* done accumulating data into *res, count space needed */\n\t\t\tbuflen += res->entry.len;\n\t\t\tif (res->entry.haspos)\n\t\t\t{\n\t\t\t\tres->poslen = uniquePos(res->pos, res->poslen);\n\t\t\t\tbuflen = SHORTALIGN(buflen);\n\t\t\t\tbuflen += res->poslen * sizeof(WordEntryPos) + sizeof(uint16);\n\t\t\t}\n\t\t\tres++;\n\t\t\tif (res != ptr)\n\t\t\t\tmemcpy(res, ptr, sizeof(WordEntryIN));\n\t\t}\n\t\telse if (ptr->entry.haspos)\n\t\t{\n\t\t\tif (res->entry.haspos)\n\t\t\t{\n\t\t\t\t/* append ptr's positions to res's positions */\n\t\t\t\tint\t\t\tnewlen = ptr->poslen + res->poslen;\n\n\t\t\t\tres->pos = (WordEntryPos *)\n\t\t\t\t\trepalloc(res->pos, newlen * sizeof(WordEntryPos));\n\t\t\t\tmemcpy(&res->pos[res->poslen], ptr->pos,\n\t\t\t\t\t   ptr->poslen * sizeof(WordEntryPos));\n\t\t\t\tres->poslen = newlen;\n\t\t\t\tpfree(ptr->pos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* just give ptr's positions to pos */\n\t\t\t\tres->entry.haspos = 1;\n\t\t\t\tres->pos = ptr->pos;\n\t\t\t\tres->poslen = ptr->poslen;\n\t\t\t}\n\t\t}\n\t\tptr++;\n\t}\n\n\t/* count space needed for last item */\n\tbuflen += res->entry.len;\n\tif (res->entry.haspos)\n\t{\n\t\tres->poslen = uniquePos(res->pos, res->poslen);\n\t\tbuflen = SHORTALIGN(buflen);\n\t\tbuflen += res->poslen * sizeof(WordEntryPos) + sizeof(uint16);\n\t}\n\n\t*outbuflen = buflen;\n\treturn res + 1 - a;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic int\nuniqueentry(WordEntryIN *a, int l, char *buf, int *outbuflen)\n{\n\tint\t\t\tbuflen;\n\tWordEntryIN *ptr,\n\t\t\t   *res;\n\n\tAssert(l >= 1);\n\n\tif (l > 1)\n\t\tqsort_arg((void *) a, l, sizeof(WordEntryIN), compareentry,\n\t\t\t\t  (void *) buf);\n\n\tbuflen = 0;\n\tres = a;\n\tptr = a + 1;\n\twhile (ptr - a < l)\n\t{\n\t\tif (!(ptr->entry.len == res->entry.len &&\n\t\t\t  strncmp(&buf[ptr->entry.pos], &buf[res->entry.pos],\n\t\t\t\t\t  res->entry.len) == 0))\n\t\t{\n\t\t\t/* done accumulating data into *res, count space needed */\n\t\t\tbuflen += res->entry.len;\n\t\t\tif (res->entry.haspos)\n\t\t\t{\n\t\t\t\tres->poslen = uniquePos(res->pos, res->poslen);\n\t\t\t\tbuflen = SHORTALIGN(buflen);\n\t\t\t\tbuflen += res->poslen * sizeof(WordEntryPos) + sizeof(uint16);\n\t\t\t}\n\t\t\tres++;\n\t\t\tif (res != ptr)\n\t\t\t\tmemcpy(res, ptr, sizeof(WordEntryIN));\n\t\t}\n\t\telse if (ptr->entry.haspos)\n\t\t{\n\t\t\tif (res->entry.haspos)\n\t\t\t{\n\t\t\t\t/* append ptr's positions to res's positions */\n\t\t\t\tint\t\t\tnewlen = ptr->poslen + res->poslen;\n\n\t\t\t\tres->pos = (WordEntryPos *)\n\t\t\t\t\trepalloc(res->pos, newlen * sizeof(WordEntryPos));\n\t\t\t\tmemcpy(&res->pos[res->poslen], ptr->pos,\n\t\t\t\t\t   ptr->poslen * sizeof(WordEntryPos));\n\t\t\t\tres->poslen = newlen;\n\t\t\t\tpfree(ptr->pos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* just give ptr's positions to pos */\n\t\t\t\tres->entry.haspos = 1;\n\t\t\t\tres->pos = ptr->pos;\n\t\t\t\tres->poslen = ptr->poslen;\n\t\t\t}\n\t\t}\n\t\tptr++;\n\t}\n\n\t/* count space needed for last item */\n\tbuflen += res->entry.len;\n\tif (res->entry.haspos)\n\t{\n\t\tres->poslen = uniquePos(res->pos, res->poslen);\n\t\tbuflen = SHORTALIGN(buflen);\n\t\tbuflen += res->poslen * sizeof(WordEntryPos) + sizeof(uint16);\n\t}\n\n\t*outbuflen = buflen;\n\treturn res + 1 - a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close_tsvector_parser",
          "args": [
            "state"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "close_tsvector_parser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_parser.c",
          "lines": "75-80",
          "snippet": "void\nclose_tsvector_parser(TSVectorParseState state)\n{\n\tpfree(state->word);\n\tpfree(state);\n}",
          "includes": [
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"postgres.h\"\n\nvoid\nclose_tsvector_parser(TSVectorParseState state)\n{\n\tpfree(state->word);\n\tpfree(state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *) cur",
            "(void *) token",
            "toklen"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "(void *) tmpbuf",
            "buflen"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"string is too long for tsvector (%ld bytes, max %ld bytes)\",\n\t\t\t\t\t\t\t(long) (cur - tmpbuf), (long) MAXSTRPOS))"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"word is too long (%ld bytes, max %ld bytes)\",\n\t\t\t\t\t\t\t(long) toklen,\n\t\t\t\t\t\t\t(long) (MAXSTRLEN - 1)))"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettoken_tsvector",
          "args": [
            "state",
            "&token",
            "&toklen",
            "&pos",
            "&poslen",
            "NULL"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "gettoken_tsvector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_parser.c",
          "lines": "154-367",
          "snippet": "bool\ngettoken_tsvector(TSVectorParseState state,\n\t\t\t\t  char **strval, int *lenval,\n\t\t\t\t  WordEntryPos **pos_ptr, int *poslen,\n\t\t\t\t  char **endptr)\n{\n\tint\t\t\toldstate = 0;\n\tchar\t   *curpos = state->word;\n\tint\t\t\tstatecode = WAITWORD;\n\n\t/*\n\t * pos is for collecting the comma delimited list of positions followed by\n\t * the actual token.\n\t */\n\tWordEntryPos *pos = NULL;\n\tint\t\t\tnpos = 0;\t\t/* elements of pos used */\n\tint\t\t\tposalen = 0;\t/* allocated size of pos */\n\n\twhile (1)\n\t{\n\t\tif (statecode == WAITWORD)\n\t\t{\n\t\t\tif (*(state->prsbuf) == '\\0')\n\t\t\t\treturn false;\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t\tstatecode = WAITENDCMPLX;\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDWORD;\n\t\t\t}\n\t\t\telse if ((state->oprisdelim && ISOPERATOR(state->prsbuf)) ||\n\t\t\t\t\t (state->is_web && t_iseq(state->prsbuf, '\"')))\n\t\t\t\tPRSSYNTAXERROR;\n\t\t\telse if (!t_isspace(state->prsbuf))\n\t\t\t{\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tstatecode = WAITENDWORD;\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITNEXTCHAR)\n\t\t{\n\t\t\tif (*(state->prsbuf) == '\\0')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"there is no escaped character: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstate->bufstart)));\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tAssert(oldstate != 0);\n\t\t\t\tstatecode = oldstate;\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITENDWORD)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDWORD;\n\t\t\t}\n\t\t\telse if (t_isspace(state->prsbuf) || *(state->prsbuf) == '\\0' ||\n\t\t\t\t\t (state->oprisdelim && ISOPERATOR(state->prsbuf)) ||\n\t\t\t\t\t (state->is_web && t_iseq(state->prsbuf, '\"')))\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tRETURN_TOKEN;\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, ':'))\n\t\t\t{\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tif (state->oprisdelim)\n\t\t\t\t\tRETURN_TOKEN;\n\t\t\t\telse\n\t\t\t\t\tstatecode = INPOSINFO;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITENDCMPLX)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t{\n\t\t\t\tstatecode = WAITCHARCMPLX;\n\t\t\t}\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDCMPLX;\n\t\t\t}\n\t\t\telse if (*(state->prsbuf) == '\\0')\n\t\t\t\tPRSSYNTAXERROR;\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITCHARCMPLX)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tstatecode = WAITENDCMPLX;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tif (state->oprisdelim)\n\t\t\t\t{\n\t\t\t\t\t/* state->prsbuf+=pg_mblen(state->prsbuf); */\n\t\t\t\t\tRETURN_TOKEN;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstatecode = WAITPOSINFO;\n\t\t\t\tcontinue;\t\t/* recheck current character */\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITPOSINFO)\n\t\t{\n\t\t\tif (t_iseq(state->prsbuf, ':'))\n\t\t\t\tstatecode = INPOSINFO;\n\t\t\telse\n\t\t\t\tRETURN_TOKEN;\n\t\t}\n\t\telse if (statecode == INPOSINFO)\n\t\t{\n\t\t\tif (t_isdigit(state->prsbuf))\n\t\t\t{\n\t\t\t\tif (posalen == 0)\n\t\t\t\t{\n\t\t\t\t\tposalen = 4;\n\t\t\t\t\tpos = (WordEntryPos *) palloc(sizeof(WordEntryPos) * posalen);\n\t\t\t\t\tnpos = 0;\n\t\t\t\t}\n\t\t\t\telse if (npos + 1 >= posalen)\n\t\t\t\t{\n\t\t\t\t\tposalen *= 2;\n\t\t\t\t\tpos = (WordEntryPos *) repalloc(pos, sizeof(WordEntryPos) * posalen);\n\t\t\t\t}\n\t\t\t\tnpos++;\n\t\t\t\tWEP_SETPOS(pos[npos - 1], LIMITPOS(atoi(state->prsbuf)));\n\t\t\t\t/* we cannot get here in tsquery, so no need for 2 errmsgs */\n\t\t\t\tif (WEP_GETPOS(pos[npos - 1]) == 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t errmsg(\"wrong position info in tsvector: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstate->bufstart)));\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 0);\n\t\t\t\tstatecode = WAITPOSDELIM;\n\t\t\t}\n\t\t\telse\n\t\t\t\tPRSSYNTAXERROR;\n\t\t}\n\t\telse if (statecode == WAITPOSDELIM)\n\t\t{\n\t\t\tif (t_iseq(state->prsbuf, ','))\n\t\t\t\tstatecode = INPOSINFO;\n\t\t\telse if (t_iseq(state->prsbuf, 'a') || t_iseq(state->prsbuf, 'A') || t_iseq(state->prsbuf, '*'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 3);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'b') || t_iseq(state->prsbuf, 'B'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 2);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'c') || t_iseq(state->prsbuf, 'C'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 1);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'd') || t_iseq(state->prsbuf, 'D'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 0);\n\t\t\t}\n\t\t\telse if (t_isspace(state->prsbuf) ||\n\t\t\t\t\t *(state->prsbuf) == '\\0')\n\t\t\t\tRETURN_TOKEN;\n\t\t\telse if (!t_isdigit(state->prsbuf))\n\t\t\t\tPRSSYNTAXERROR;\n\t\t}\n\t\telse\t\t\t\t\t/* internal error */\n\t\t\telog(ERROR, \"unrecognized state in gettoken_tsvector: %d\",\n\t\t\t\t statecode);\n\n\t\t/* get next char */\n\t\tstate->prsbuf += pg_mblen(state->prsbuf);\n\t}\n}",
          "includes": [
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define PRSSYNTAXERROR prssyntaxerror(state)",
            "#define WAITCHARCMPLX\t8",
            "#define WAITPOSDELIM\t7",
            "#define INPOSINFO\t\t6",
            "#define WAITPOSINFO\t\t5",
            "#define WAITENDCMPLX\t4",
            "#define WAITNEXTCHAR\t3",
            "#define WAITENDWORD\t\t2",
            "#define WAITWORD\t\t1",
            "#define RETURN_TOKEN \\\ndo { \\\n\tif (pos_ptr != NULL) \\\n\t{ \\\n\t\t*pos_ptr = pos; \\\n\t\t*poslen = npos; \\\n\t} \\\n\telse if (pos != NULL) \\\n\t\tpfree(pos); \\\n\t\\\n\tif (strval != NULL) \\\n\t\t*strval = state->word; \\\n\tif (lenval != NULL) \\\n\t\t*lenval = curpos - state->word; \\\n\tif (endptr != NULL) \\\n\t\t*endptr = state->prsbuf; \\\n\treturn true; \\\n} while(0)",
            "#define RESIZEPRSBUF \\\ndo { \\\n\tint clen = curpos - state->word; \\\n\tif ( clen + state->eml >= state->len ) \\\n\t{ \\\n\t\tstate->len *= 2; \\\n\t\tstate->word = (char *) repalloc(state->word, state->len); \\\n\t\tcurpos = state->word + clen; \\\n\t} \\\n} while (0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"postgres.h\"\n\n#define PRSSYNTAXERROR prssyntaxerror(state)\n#define WAITCHARCMPLX\t8\n#define WAITPOSDELIM\t7\n#define INPOSINFO\t\t6\n#define WAITPOSINFO\t\t5\n#define WAITENDCMPLX\t4\n#define WAITNEXTCHAR\t3\n#define WAITENDWORD\t\t2\n#define WAITWORD\t\t1\n#define RETURN_TOKEN \\\ndo { \\\n\tif (pos_ptr != NULL) \\\n\t{ \\\n\t\t*pos_ptr = pos; \\\n\t\t*poslen = npos; \\\n\t} \\\n\telse if (pos != NULL) \\\n\t\tpfree(pos); \\\n\t\\\n\tif (strval != NULL) \\\n\t\t*strval = state->word; \\\n\tif (lenval != NULL) \\\n\t\t*lenval = curpos - state->word; \\\n\tif (endptr != NULL) \\\n\t\t*endptr = state->prsbuf; \\\n\treturn true; \\\n} while(0)\n#define RESIZEPRSBUF \\\ndo { \\\n\tint clen = curpos - state->word; \\\n\tif ( clen + state->eml >= state->len ) \\\n\t{ \\\n\t\tstate->len *= 2; \\\n\t\tstate->word = (char *) repalloc(state->word, state->len); \\\n\t\tcurpos = state->word + clen; \\\n\t} \\\n} while (0)\n\nbool\ngettoken_tsvector(TSVectorParseState state,\n\t\t\t\t  char **strval, int *lenval,\n\t\t\t\t  WordEntryPos **pos_ptr, int *poslen,\n\t\t\t\t  char **endptr)\n{\n\tint\t\t\toldstate = 0;\n\tchar\t   *curpos = state->word;\n\tint\t\t\tstatecode = WAITWORD;\n\n\t/*\n\t * pos is for collecting the comma delimited list of positions followed by\n\t * the actual token.\n\t */\n\tWordEntryPos *pos = NULL;\n\tint\t\t\tnpos = 0;\t\t/* elements of pos used */\n\tint\t\t\tposalen = 0;\t/* allocated size of pos */\n\n\twhile (1)\n\t{\n\t\tif (statecode == WAITWORD)\n\t\t{\n\t\t\tif (*(state->prsbuf) == '\\0')\n\t\t\t\treturn false;\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t\tstatecode = WAITENDCMPLX;\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDWORD;\n\t\t\t}\n\t\t\telse if ((state->oprisdelim && ISOPERATOR(state->prsbuf)) ||\n\t\t\t\t\t (state->is_web && t_iseq(state->prsbuf, '\"')))\n\t\t\t\tPRSSYNTAXERROR;\n\t\t\telse if (!t_isspace(state->prsbuf))\n\t\t\t{\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tstatecode = WAITENDWORD;\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITNEXTCHAR)\n\t\t{\n\t\t\tif (*(state->prsbuf) == '\\0')\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"there is no escaped character: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\tstate->bufstart)));\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tAssert(oldstate != 0);\n\t\t\t\tstatecode = oldstate;\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITENDWORD)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDWORD;\n\t\t\t}\n\t\t\telse if (t_isspace(state->prsbuf) || *(state->prsbuf) == '\\0' ||\n\t\t\t\t\t (state->oprisdelim && ISOPERATOR(state->prsbuf)) ||\n\t\t\t\t\t (state->is_web && t_iseq(state->prsbuf, '\"')))\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tRETURN_TOKEN;\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, ':'))\n\t\t\t{\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tif (state->oprisdelim)\n\t\t\t\t\tRETURN_TOKEN;\n\t\t\t\telse\n\t\t\t\t\tstatecode = INPOSINFO;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITENDCMPLX)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t{\n\t\t\t\tstatecode = WAITCHARCMPLX;\n\t\t\t}\n\t\t\telse if (!state->is_web && t_iseq(state->prsbuf, '\\\\'))\n\t\t\t{\n\t\t\t\tstatecode = WAITNEXTCHAR;\n\t\t\t\toldstate = WAITENDCMPLX;\n\t\t\t}\n\t\t\telse if (*(state->prsbuf) == '\\0')\n\t\t\t\tPRSSYNTAXERROR;\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITCHARCMPLX)\n\t\t{\n\t\t\tif (!state->is_web && t_iseq(state->prsbuf, '\\''))\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\tCOPYCHAR(curpos, state->prsbuf);\n\t\t\t\tcurpos += pg_mblen(state->prsbuf);\n\t\t\t\tstatecode = WAITENDCMPLX;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRESIZEPRSBUF;\n\t\t\t\t*(curpos) = '\\0';\n\t\t\t\tif (curpos == state->word)\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tif (state->oprisdelim)\n\t\t\t\t{\n\t\t\t\t\t/* state->prsbuf+=pg_mblen(state->prsbuf); */\n\t\t\t\t\tRETURN_TOKEN;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tstatecode = WAITPOSINFO;\n\t\t\t\tcontinue;\t\t/* recheck current character */\n\t\t\t}\n\t\t}\n\t\telse if (statecode == WAITPOSINFO)\n\t\t{\n\t\t\tif (t_iseq(state->prsbuf, ':'))\n\t\t\t\tstatecode = INPOSINFO;\n\t\t\telse\n\t\t\t\tRETURN_TOKEN;\n\t\t}\n\t\telse if (statecode == INPOSINFO)\n\t\t{\n\t\t\tif (t_isdigit(state->prsbuf))\n\t\t\t{\n\t\t\t\tif (posalen == 0)\n\t\t\t\t{\n\t\t\t\t\tposalen = 4;\n\t\t\t\t\tpos = (WordEntryPos *) palloc(sizeof(WordEntryPos) * posalen);\n\t\t\t\t\tnpos = 0;\n\t\t\t\t}\n\t\t\t\telse if (npos + 1 >= posalen)\n\t\t\t\t{\n\t\t\t\t\tposalen *= 2;\n\t\t\t\t\tpos = (WordEntryPos *) repalloc(pos, sizeof(WordEntryPos) * posalen);\n\t\t\t\t}\n\t\t\t\tnpos++;\n\t\t\t\tWEP_SETPOS(pos[npos - 1], LIMITPOS(atoi(state->prsbuf)));\n\t\t\t\t/* we cannot get here in tsquery, so no need for 2 errmsgs */\n\t\t\t\tif (WEP_GETPOS(pos[npos - 1]) == 0)\n\t\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t\t errmsg(\"wrong position info in tsvector: \\\"%s\\\"\",\n\t\t\t\t\t\t\t\t\tstate->bufstart)));\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 0);\n\t\t\t\tstatecode = WAITPOSDELIM;\n\t\t\t}\n\t\t\telse\n\t\t\t\tPRSSYNTAXERROR;\n\t\t}\n\t\telse if (statecode == WAITPOSDELIM)\n\t\t{\n\t\t\tif (t_iseq(state->prsbuf, ','))\n\t\t\t\tstatecode = INPOSINFO;\n\t\t\telse if (t_iseq(state->prsbuf, 'a') || t_iseq(state->prsbuf, 'A') || t_iseq(state->prsbuf, '*'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 3);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'b') || t_iseq(state->prsbuf, 'B'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 2);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'c') || t_iseq(state->prsbuf, 'C'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 1);\n\t\t\t}\n\t\t\telse if (t_iseq(state->prsbuf, 'd') || t_iseq(state->prsbuf, 'D'))\n\t\t\t{\n\t\t\t\tif (WEP_GETWEIGHT(pos[npos - 1]))\n\t\t\t\t\tPRSSYNTAXERROR;\n\t\t\t\tWEP_SETWEIGHT(pos[npos - 1], 0);\n\t\t\t}\n\t\t\telse if (t_isspace(state->prsbuf) ||\n\t\t\t\t\t *(state->prsbuf) == '\\0')\n\t\t\t\tRETURN_TOKEN;\n\t\t\telse if (!t_isdigit(state->prsbuf))\n\t\t\t\tPRSSYNTAXERROR;\n\t\t}\n\t\telse\t\t\t\t\t/* internal error */\n\t\t\telog(ERROR, \"unrecognized state in gettoken_tsvector: %d\",\n\t\t\t\t statecode);\n\n\t\t/* get next char */\n\t\tstate->prsbuf += pg_mblen(state->prsbuf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "buflen"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_tsvector_parser",
          "args": [
            "buf",
            "0"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "init_tsvector_parser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_parser.c",
          "lines": "45-61",
          "snippet": "TSVectorParseState\ninit_tsvector_parser(char *input, int flags)\n{\n\tTSVectorParseState state;\n\n\tstate = (TSVectorParseState) palloc(sizeof(struct TSVectorParseStateData));\n\tstate->prsbuf = input;\n\tstate->bufstart = input;\n\tstate->len = 32;\n\tstate->word = (char *) palloc(state->len);\n\tstate->eml = pg_database_encoding_max_length();\n\tstate->oprisdelim = (flags & P_TSV_OPR_IS_DELIM) != 0;\n\tstate->is_tsquery = (flags & P_TSV_IS_TSQUERY) != 0;\n\tstate->is_web = (flags & P_TSV_IS_WEB) != 0;\n\n\treturn state;\n}",
          "includes": [
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"postgres.h\"\n\nTSVectorParseState\ninit_tsvector_parser(char *input, int flags)\n{\n\tTSVectorParseState state;\n\n\tstate = (TSVectorParseState) palloc(sizeof(struct TSVectorParseStateData));\n\tstate->prsbuf = input;\n\tstate->bufstart = input;\n\tstate->len = 32;\n\tstate->word = (char *) palloc(state->len);\n\tstate->eml = pg_database_encoding_max_length();\n\tstate->oprisdelim = (flags & P_TSV_OPR_IS_DELIM) != 0;\n\tstate->is_tsquery = (flags & P_TSV_IS_TSQUERY) != 0;\n\tstate->is_web = (flags & P_TSV_IS_WEB) != 0;\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CSTRING",
          "args": [
            "0"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nDatum\ntsvectorin(PG_FUNCTION_ARGS)\n{\n\tchar\t   *buf = PG_GETARG_CSTRING(0);\n\tTSVectorParseState state;\n\tWordEntryIN *arr;\n\tint\t\t\ttotallen;\n\tint\t\t\tarrlen;\t\t\t/* allocated size of arr */\n\tWordEntry  *inarr;\n\tint\t\t\tlen = 0;\n\tTSVector\tin;\n\tint\t\t\ti;\n\tchar\t   *token;\n\tint\t\t\ttoklen;\n\tWordEntryPos *pos;\n\tint\t\t\tposlen;\n\tchar\t   *strbuf;\n\tint\t\t\tstroff;\n\n\t/*\n\t * Tokens are appended to tmpbuf, cur is a pointer to the end of used\n\t * space in tmpbuf.\n\t */\n\tchar\t   *tmpbuf;\n\tchar\t   *cur;\n\tint\t\t\tbuflen = 256;\t/* allocated size of tmpbuf */\n\n\tstate = init_tsvector_parser(buf, 0);\n\n\tarrlen = 64;\n\tarr = (WordEntryIN *) palloc(sizeof(WordEntryIN) * arrlen);\n\tcur = tmpbuf = (char *) palloc(buflen);\n\n\twhile (gettoken_tsvector(state, &token, &toklen, &pos, &poslen, NULL))\n\t{\n\t\tif (toklen >= MAXSTRLEN)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"word is too long (%ld bytes, max %ld bytes)\",\n\t\t\t\t\t\t\t(long) toklen,\n\t\t\t\t\t\t\t(long) (MAXSTRLEN - 1))));\n\n\t\tif (cur - tmpbuf > MAXSTRPOS)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t\t errmsg(\"string is too long for tsvector (%ld bytes, max %ld bytes)\",\n\t\t\t\t\t\t\t(long) (cur - tmpbuf), (long) MAXSTRPOS)));\n\n\t\t/*\n\t\t * Enlarge buffers if needed\n\t\t */\n\t\tif (len >= arrlen)\n\t\t{\n\t\t\tarrlen *= 2;\n\t\t\tarr = (WordEntryIN *)\n\t\t\t\trepalloc((void *) arr, sizeof(WordEntryIN) * arrlen);\n\t\t}\n\t\twhile ((cur - tmpbuf) + toklen >= buflen)\n\t\t{\n\t\t\tint\t\t\tdist = cur - tmpbuf;\n\n\t\t\tbuflen *= 2;\n\t\t\ttmpbuf = (char *) repalloc((void *) tmpbuf, buflen);\n\t\t\tcur = tmpbuf + dist;\n\t\t}\n\t\tarr[len].entry.len = toklen;\n\t\tarr[len].entry.pos = cur - tmpbuf;\n\t\tmemcpy((void *) cur, (void *) token, toklen);\n\t\tcur += toklen;\n\n\t\tif (poslen != 0)\n\t\t{\n\t\t\tarr[len].entry.haspos = 1;\n\t\t\tarr[len].pos = pos;\n\t\t\tarr[len].poslen = poslen;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarr[len].entry.haspos = 0;\n\t\t\tarr[len].pos = NULL;\n\t\t\tarr[len].poslen = 0;\n\t\t}\n\t\tlen++;\n\t}\n\n\tclose_tsvector_parser(state);\n\n\tif (len > 0)\n\t\tlen = uniqueentry(arr, len, tmpbuf, &buflen);\n\telse\n\t\tbuflen = 0;\n\n\tif (buflen > MAXSTRPOS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"string is too long for tsvector (%d bytes, max %d bytes)\", buflen, MAXSTRPOS)));\n\n\ttotallen = CALCDATASIZE(len, buflen);\n\tin = (TSVector) palloc0(totallen);\n\tSET_VARSIZE(in, totallen);\n\tin->size = len;\n\tinarr = ARRPTR(in);\n\tstrbuf = STRPTR(in);\n\tstroff = 0;\n\tfor (i = 0; i < len; i++)\n\t{\n\t\tmemcpy(strbuf + stroff, &tmpbuf[arr[i].entry.pos], arr[i].entry.len);\n\t\tarr[i].entry.pos = stroff;\n\t\tstroff += arr[i].entry.len;\n\t\tif (arr[i].entry.haspos)\n\t\t{\n\t\t\tif (arr[i].poslen > 0xFFFF)\n\t\t\t\telog(ERROR, \"positions array too long\");\n\n\t\t\t/* Copy number of positions */\n\t\t\tstroff = SHORTALIGN(stroff);\n\t\t\t*(uint16 *) (strbuf + stroff) = (uint16) arr[i].poslen;\n\t\t\tstroff += sizeof(uint16);\n\n\t\t\t/* Copy positions */\n\t\t\tmemcpy(strbuf + stroff, arr[i].pos, arr[i].poslen * sizeof(WordEntryPos));\n\t\t\tstroff += arr[i].poslen * sizeof(WordEntryPos);\n\n\t\t\tpfree(arr[i].pos);\n\t\t}\n\t\tinarr[i] = arr[i].entry;\n\t}\n\n\tAssert((strbuf + stroff - (char *) in) == totallen);\n\n\tPG_RETURN_TSVECTOR(in);\n}"
  },
  {
    "function_name": "WordEntryCMP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector.c",
    "lines": "169-173",
    "snippet": "static int\nWordEntryCMP(WordEntry *a, WordEntry *b, char *buf)\n{\n\treturn compareentry(a, b, buf);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compareentry",
          "args": [
            "a",
            "b",
            "buf"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "compareentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector.c",
          "lines": "81-91",
          "snippet": "static int\ncompareentry(const void *va, const void *vb, void *arg)\n{\n\tconst WordEntryIN *a = (const WordEntryIN *) va;\n\tconst WordEntryIN *b = (const WordEntryIN *) vb;\n\tchar\t   *BufferStr = (char *) arg;\n\n\treturn tsCompareString(&BufferStr[a->entry.pos], a->entry.len,\n\t\t\t\t\t\t   &BufferStr[b->entry.pos], b->entry.len,\n\t\t\t\t\t\t   false);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic int\ncompareentry(const void *va, const void *vb, void *arg)\n{\n\tconst WordEntryIN *a = (const WordEntryIN *) va;\n\tconst WordEntryIN *b = (const WordEntryIN *) vb;\n\tchar\t   *BufferStr = (char *) arg;\n\n\treturn tsCompareString(&BufferStr[a->entry.pos], a->entry.len,\n\t\t\t\t\t\t   &BufferStr[b->entry.pos], b->entry.len,\n\t\t\t\t\t\t   false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic int\nWordEntryCMP(WordEntry *a, WordEntry *b, char *buf)\n{\n\treturn compareentry(a, b, buf);\n}"
  },
  {
    "function_name": "uniqueentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector.c",
    "lines": "97-167",
    "snippet": "static int\nuniqueentry(WordEntryIN *a, int l, char *buf, int *outbuflen)\n{\n\tint\t\t\tbuflen;\n\tWordEntryIN *ptr,\n\t\t\t   *res;\n\n\tAssert(l >= 1);\n\n\tif (l > 1)\n\t\tqsort_arg((void *) a, l, sizeof(WordEntryIN), compareentry,\n\t\t\t\t  (void *) buf);\n\n\tbuflen = 0;\n\tres = a;\n\tptr = a + 1;\n\twhile (ptr - a < l)\n\t{\n\t\tif (!(ptr->entry.len == res->entry.len &&\n\t\t\t  strncmp(&buf[ptr->entry.pos], &buf[res->entry.pos],\n\t\t\t\t\t  res->entry.len) == 0))\n\t\t{\n\t\t\t/* done accumulating data into *res, count space needed */\n\t\t\tbuflen += res->entry.len;\n\t\t\tif (res->entry.haspos)\n\t\t\t{\n\t\t\t\tres->poslen = uniquePos(res->pos, res->poslen);\n\t\t\t\tbuflen = SHORTALIGN(buflen);\n\t\t\t\tbuflen += res->poslen * sizeof(WordEntryPos) + sizeof(uint16);\n\t\t\t}\n\t\t\tres++;\n\t\t\tif (res != ptr)\n\t\t\t\tmemcpy(res, ptr, sizeof(WordEntryIN));\n\t\t}\n\t\telse if (ptr->entry.haspos)\n\t\t{\n\t\t\tif (res->entry.haspos)\n\t\t\t{\n\t\t\t\t/* append ptr's positions to res's positions */\n\t\t\t\tint\t\t\tnewlen = ptr->poslen + res->poslen;\n\n\t\t\t\tres->pos = (WordEntryPos *)\n\t\t\t\t\trepalloc(res->pos, newlen * sizeof(WordEntryPos));\n\t\t\t\tmemcpy(&res->pos[res->poslen], ptr->pos,\n\t\t\t\t\t   ptr->poslen * sizeof(WordEntryPos));\n\t\t\t\tres->poslen = newlen;\n\t\t\t\tpfree(ptr->pos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* just give ptr's positions to pos */\n\t\t\t\tres->entry.haspos = 1;\n\t\t\t\tres->pos = ptr->pos;\n\t\t\t\tres->poslen = ptr->poslen;\n\t\t\t}\n\t\t}\n\t\tptr++;\n\t}\n\n\t/* count space needed for last item */\n\tbuflen += res->entry.len;\n\tif (res->entry.haspos)\n\t{\n\t\tres->poslen = uniquePos(res->pos, res->poslen);\n\t\tbuflen = SHORTALIGN(buflen);\n\t\tbuflen += res->poslen * sizeof(WordEntryPos) + sizeof(uint16);\n\t}\n\n\t*outbuflen = buflen;\n\treturn res + 1 - a;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SHORTALIGN",
          "args": [
            "buflen"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uniquePos",
          "args": [
            "res->pos",
            "res->poslen"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "uniquePos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector.c",
          "lines": "49-78",
          "snippet": "static int\nuniquePos(WordEntryPos *a, int l)\n{\n\tWordEntryPos *ptr,\n\t\t\t   *res;\n\n\tif (l <= 1)\n\t\treturn l;\n\n\tqsort((void *) a, l, sizeof(WordEntryPos), compareWordEntryPos);\n\n\tres = a;\n\tptr = a + 1;\n\twhile (ptr - a < l)\n\t{\n\t\tif (WEP_GETPOS(*ptr) != WEP_GETPOS(*res))\n\t\t{\n\t\t\tres++;\n\t\t\t*res = *ptr;\n\t\t\tif (res - a >= MAXNUMPOS - 1 ||\n\t\t\t\tWEP_GETPOS(*res) == MAXENTRYPOS - 1)\n\t\t\t\tbreak;\n\t\t}\n\t\telse if (WEP_GETWEIGHT(*ptr) > WEP_GETWEIGHT(*res))\n\t\t\tWEP_SETWEIGHT(*res, WEP_GETWEIGHT(*ptr));\n\t\tptr++;\n\t}\n\n\treturn res + 1 - a;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"tsearch/ts_locale.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic int\nuniquePos(WordEntryPos *a, int l)\n{\n\tWordEntryPos *ptr,\n\t\t\t   *res;\n\n\tif (l <= 1)\n\t\treturn l;\n\n\tqsort((void *) a, l, sizeof(WordEntryPos), compareWordEntryPos);\n\n\tres = a;\n\tptr = a + 1;\n\twhile (ptr - a < l)\n\t{\n\t\tif (WEP_GETPOS(*ptr) != WEP_GETPOS(*res))\n\t\t{\n\t\t\tres++;\n\t\t\t*res = *ptr;\n\t\t\tif (res - a >= MAXNUMPOS - 1 ||\n\t\t\t\tWEP_GETPOS(*res) == MAXENTRYPOS - 1)\n\t\t\t\tbreak;\n\t\t}\n\t\telse if (WEP_GETWEIGHT(*ptr) > WEP_GETWEIGHT(*res))\n\t\t\tWEP_SETWEIGHT(*res, WEP_GETWEIGHT(*ptr));\n\t\tptr++;\n\t}\n\n\treturn res + 1 - a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "ptr->pos"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&res->pos[res->poslen]",
            "ptr->pos",
            "ptr->poslen * sizeof(WordEntryPos)"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "res->pos",
            "newlen * sizeof(WordEntryPos)"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "res",
            "ptr",
            "sizeof(WordEntryIN)"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHORTALIGN",
          "args": [
            "buflen"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "&buf[ptr->entry.pos]",
            "&buf[res->entry.pos]",
            "res->entry.len"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "pg_char_and_wchar_strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/wstrncmp.c",
          "lines": "54-67",
          "snippet": "int\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres_fe.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mb/pg_wchar.h\"\n#include \"postgres_fe.h\"\n\nint\npg_char_and_wchar_strncmp(const char *s1, const pg_wchar *s2, size_t n)\n{\n\tif (n == 0)\n\t\treturn 0;\n\tdo\n\t{\n\t\tif ((pg_wchar) ((unsigned char) *s1) != *s2++)\n\t\t\treturn ((pg_wchar) ((unsigned char) *s1) - *(s2 - 1));\n\t\tif (*s1++ == 0)\n\t\t\tbreak;\n\t} while (--n != 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort_arg",
          "args": [
            "(void *) a",
            "l",
            "sizeof(WordEntryIN)",
            "compareentry",
            "(void *) buf"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "l >= 1"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic int\nuniqueentry(WordEntryIN *a, int l, char *buf, int *outbuflen)\n{\n\tint\t\t\tbuflen;\n\tWordEntryIN *ptr,\n\t\t\t   *res;\n\n\tAssert(l >= 1);\n\n\tif (l > 1)\n\t\tqsort_arg((void *) a, l, sizeof(WordEntryIN), compareentry,\n\t\t\t\t  (void *) buf);\n\n\tbuflen = 0;\n\tres = a;\n\tptr = a + 1;\n\twhile (ptr - a < l)\n\t{\n\t\tif (!(ptr->entry.len == res->entry.len &&\n\t\t\t  strncmp(&buf[ptr->entry.pos], &buf[res->entry.pos],\n\t\t\t\t\t  res->entry.len) == 0))\n\t\t{\n\t\t\t/* done accumulating data into *res, count space needed */\n\t\t\tbuflen += res->entry.len;\n\t\t\tif (res->entry.haspos)\n\t\t\t{\n\t\t\t\tres->poslen = uniquePos(res->pos, res->poslen);\n\t\t\t\tbuflen = SHORTALIGN(buflen);\n\t\t\t\tbuflen += res->poslen * sizeof(WordEntryPos) + sizeof(uint16);\n\t\t\t}\n\t\t\tres++;\n\t\t\tif (res != ptr)\n\t\t\t\tmemcpy(res, ptr, sizeof(WordEntryIN));\n\t\t}\n\t\telse if (ptr->entry.haspos)\n\t\t{\n\t\t\tif (res->entry.haspos)\n\t\t\t{\n\t\t\t\t/* append ptr's positions to res's positions */\n\t\t\t\tint\t\t\tnewlen = ptr->poslen + res->poslen;\n\n\t\t\t\tres->pos = (WordEntryPos *)\n\t\t\t\t\trepalloc(res->pos, newlen * sizeof(WordEntryPos));\n\t\t\t\tmemcpy(&res->pos[res->poslen], ptr->pos,\n\t\t\t\t\t   ptr->poslen * sizeof(WordEntryPos));\n\t\t\t\tres->poslen = newlen;\n\t\t\t\tpfree(ptr->pos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* just give ptr's positions to pos */\n\t\t\t\tres->entry.haspos = 1;\n\t\t\t\tres->pos = ptr->pos;\n\t\t\t\tres->poslen = ptr->poslen;\n\t\t\t}\n\t\t}\n\t\tptr++;\n\t}\n\n\t/* count space needed for last item */\n\tbuflen += res->entry.len;\n\tif (res->entry.haspos)\n\t{\n\t\tres->poslen = uniquePos(res->pos, res->poslen);\n\t\tbuflen = SHORTALIGN(buflen);\n\t\tbuflen += res->poslen * sizeof(WordEntryPos) + sizeof(uint16);\n\t}\n\n\t*outbuflen = buflen;\n\treturn res + 1 - a;\n}"
  },
  {
    "function_name": "compareentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector.c",
    "lines": "81-91",
    "snippet": "static int\ncompareentry(const void *va, const void *vb, void *arg)\n{\n\tconst WordEntryIN *a = (const WordEntryIN *) va;\n\tconst WordEntryIN *b = (const WordEntryIN *) vb;\n\tchar\t   *BufferStr = (char *) arg;\n\n\treturn tsCompareString(&BufferStr[a->entry.pos], a->entry.len,\n\t\t\t\t\t\t   &BufferStr[b->entry.pos], b->entry.len,\n\t\t\t\t\t\t   false);\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tsCompareString",
          "args": [
            "&BufferStr[a->entry.pos]",
            "a->entry.len",
            "&BufferStr[b->entry.pos]",
            "b->entry.len",
            "false"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "tsCompareString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "1159-1191",
          "snippet": "int32\ntsCompareString(char *a, int lena, char *b, int lenb, bool prefix)\n{\n\tint\t\t\tcmp;\n\n\tif (lena == 0)\n\t{\n\t\tif (prefix)\n\t\t\tcmp = 0;\t\t\t/* empty string is prefix of anything */\n\t\telse\n\t\t\tcmp = (lenb > 0) ? -1 : 0;\n\t}\n\telse if (lenb == 0)\n\t{\n\t\tcmp = (lena > 0) ? 1 : 0;\n\t}\n\telse\n\t{\n\t\tcmp = memcmp(a, b, Min(lena, lenb));\n\n\t\tif (prefix)\n\t\t{\n\t\t\tif (cmp == 0 && lena > lenb)\n\t\t\t\tcmp = 1;\t\t/* a is longer, so not a prefix of b */\n\t\t}\n\t\telse if (cmp == 0 && lena != lenb)\n\t\t{\n\t\t\tcmp = (lena < lenb) ? -1 : 1;\n\t\t}\n\t}\n\n\treturn cmp;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nint32\ntsCompareString(char *a, int lena, char *b, int lenb, bool prefix)\n{\n\tint\t\t\tcmp;\n\n\tif (lena == 0)\n\t{\n\t\tif (prefix)\n\t\t\tcmp = 0;\t\t\t/* empty string is prefix of anything */\n\t\telse\n\t\t\tcmp = (lenb > 0) ? -1 : 0;\n\t}\n\telse if (lenb == 0)\n\t{\n\t\tcmp = (lena > 0) ? 1 : 0;\n\t}\n\telse\n\t{\n\t\tcmp = memcmp(a, b, Min(lena, lenb));\n\n\t\tif (prefix)\n\t\t{\n\t\t\tif (cmp == 0 && lena > lenb)\n\t\t\t\tcmp = 1;\t\t/* a is longer, so not a prefix of b */\n\t\t}\n\t\telse if (cmp == 0 && lena != lenb)\n\t\t{\n\t\t\tcmp = (lena < lenb) ? -1 : 1;\n\t\t}\n\t}\n\n\treturn cmp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic int\ncompareentry(const void *va, const void *vb, void *arg)\n{\n\tconst WordEntryIN *a = (const WordEntryIN *) va;\n\tconst WordEntryIN *b = (const WordEntryIN *) vb;\n\tchar\t   *BufferStr = (char *) arg;\n\n\treturn tsCompareString(&BufferStr[a->entry.pos], a->entry.len,\n\t\t\t\t\t\t   &BufferStr[b->entry.pos], b->entry.len,\n\t\t\t\t\t\t   false);\n}"
  },
  {
    "function_name": "uniquePos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector.c",
    "lines": "49-78",
    "snippet": "static int\nuniquePos(WordEntryPos *a, int l)\n{\n\tWordEntryPos *ptr,\n\t\t\t   *res;\n\n\tif (l <= 1)\n\t\treturn l;\n\n\tqsort((void *) a, l, sizeof(WordEntryPos), compareWordEntryPos);\n\n\tres = a;\n\tptr = a + 1;\n\twhile (ptr - a < l)\n\t{\n\t\tif (WEP_GETPOS(*ptr) != WEP_GETPOS(*res))\n\t\t{\n\t\t\tres++;\n\t\t\t*res = *ptr;\n\t\t\tif (res - a >= MAXNUMPOS - 1 ||\n\t\t\t\tWEP_GETPOS(*res) == MAXENTRYPOS - 1)\n\t\t\t\tbreak;\n\t\t}\n\t\telse if (WEP_GETWEIGHT(*ptr) > WEP_GETWEIGHT(*res))\n\t\t\tWEP_SETWEIGHT(*res, WEP_GETWEIGHT(*ptr));\n\t\tptr++;\n\t}\n\n\treturn res + 1 - a;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WEP_SETWEIGHT",
          "args": [
            "*res",
            "WEP_GETWEIGHT(*ptr)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "*ptr"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "*res"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "*ptr"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "*res"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "*res"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "*ptr"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "(void *) a",
            "l",
            "sizeof(WordEntryPos)",
            "compareWordEntryPos"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nstatic int\nuniquePos(WordEntryPos *a, int l)\n{\n\tWordEntryPos *ptr,\n\t\t\t   *res;\n\n\tif (l <= 1)\n\t\treturn l;\n\n\tqsort((void *) a, l, sizeof(WordEntryPos), compareWordEntryPos);\n\n\tres = a;\n\tptr = a + 1;\n\twhile (ptr - a < l)\n\t{\n\t\tif (WEP_GETPOS(*ptr) != WEP_GETPOS(*res))\n\t\t{\n\t\t\tres++;\n\t\t\t*res = *ptr;\n\t\t\tif (res - a >= MAXNUMPOS - 1 ||\n\t\t\t\tWEP_GETPOS(*res) == MAXENTRYPOS - 1)\n\t\t\t\tbreak;\n\t\t}\n\t\telse if (WEP_GETWEIGHT(*ptr) > WEP_GETWEIGHT(*res))\n\t\t\tWEP_SETWEIGHT(*res, WEP_GETWEIGHT(*ptr));\n\t\tptr++;\n\t}\n\n\treturn res + 1 - a;\n}"
  },
  {
    "function_name": "compareWordEntryPos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector.c",
    "lines": "32-41",
    "snippet": "int\ncompareWordEntryPos(const void *a, const void *b)\n{\n\tint\t\t\tapos = WEP_GETPOS(*(const WordEntryPos *) a);\n\tint\t\t\tbpos = WEP_GETPOS(*(const WordEntryPos *) b);\n\n\tif (apos == bpos)\n\t\treturn 0;\n\treturn (apos > bpos) ? 1 : -1;\n}",
    "includes": [
      "#include \"utils/memutils.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"tsearch/ts_locale.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "*(const WordEntryPos *) b"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "*(const WordEntryPos *) a"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"tsearch/ts_locale.h\"\n#include \"libpq/pqformat.h\"\n#include \"postgres.h\"\n\nint\ncompareWordEntryPos(const void *a, const void *b)\n{\n\tint\t\t\tapos = WEP_GETPOS(*(const WordEntryPos *) a);\n\tint\t\t\tbpos = WEP_GETPOS(*(const WordEntryPos *) b);\n\n\tif (apos == bpos)\n\t\treturn 0;\n\treturn (apos > bpos) ? 1 : -1;\n}"
  }
]