[
  {
    "function_name": "pg_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/pg_config.c",
    "lines": "24-102",
    "snippet": "Datum\npg_config(PG_FUNCTION_ARGS)\n{\n\tReturnSetInfo *rsinfo = (ReturnSetInfo *) fcinfo->resultinfo;\n\tTuplestorestate *tupstore;\n\tHeapTuple\ttuple;\n\tTupleDesc\ttupdesc;\n\tAttInMetadata *attinmeta;\n\tMemoryContext per_query_ctx;\n\tMemoryContext oldcontext;\n\tConfigData *configdata;\n\tsize_t\t\tconfigdata_len;\n\tchar\t   *values[2];\n\tint\t\t\ti = 0;\n\n\t/* check to see if caller supports us returning a tuplestore */\n\tif (!rsinfo || !(rsinfo->allowedModes & SFRM_Materialize))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"materialize mode required, but it is not \"\n\t\t\t\t\t\t\"allowed in this context\")));\n\n\tper_query_ctx = rsinfo->econtext->ecxt_per_query_memory;\n\toldcontext = MemoryContextSwitchTo(per_query_ctx);\n\n\t/* get the requested return tuple description */\n\ttupdesc = CreateTupleDescCopy(rsinfo->expectedDesc);\n\n\t/*\n\t * Check to make sure we have a reasonable tuple descriptor\n\t */\n\tif (tupdesc->natts != 2 ||\n\t\tTupleDescAttr(tupdesc, 0)->atttypid != TEXTOID ||\n\t\tTupleDescAttr(tupdesc, 1)->atttypid != TEXTOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"query-specified return tuple and \"\n\t\t\t\t\t\t\"function return type are not compatible\")));\n\n\t/* OK to use it */\n\tattinmeta = TupleDescGetAttInMetadata(tupdesc);\n\n\t/* let the caller know we're sending back a tuplestore */\n\trsinfo->returnMode = SFRM_Materialize;\n\n\t/* initialize our tuplestore */\n\ttupstore = tuplestore_begin_heap(true, false, work_mem);\n\n\tconfigdata = get_configdata(my_exec_path, &configdata_len);\n\tfor (i = 0; i < configdata_len; i++)\n\t{\n\t\tvalues[0] = configdata[i].name;\n\t\tvalues[1] = configdata[i].setting;\n\n\t\ttuple = BuildTupleFromCStrings(attinmeta, values);\n\t\ttuplestore_puttuple(tupstore, tuple);\n\t}\n\n\t/*\n\t * no longer need the tuple descriptor reference created by\n\t * TupleDescGetAttInMetadata()\n\t */\n\tReleaseTupleDesc(tupdesc);\n\n\ttuplestore_donestoring(tupstore);\n\trsinfo->setResult = tupstore;\n\n\t/*\n\t * SFRM_Materialize mode expects us to return a NULL Datum. The actual\n\t * tuples are in our tuplestore and passed back through rsinfo->setResult.\n\t * rsinfo->setDesc is set to the tuple description that we actually used\n\t * to build our tuples with, so the caller can verify we did what it was\n\t * expecting.\n\t */\n\trsinfo->setDesc = tupdesc;\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn (Datum) 0;\n}",
    "includes": [
      "#include \"port.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"common/config_info.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"miscadmin.h\"",
      "#include \"funcapi.h\"",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplestore_donestoring",
          "args": [
            "tupstore"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReleaseTupleDesc",
          "args": [
            "tupdesc"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplestore_puttuple",
          "args": [
            "tupstore",
            "tuple"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_puttuple_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "764-892",
          "snippet": "static void\ntuplestore_puttuple_common(Tuplestorestate *state, void *tuple)\n{\n\tTSReadPointer *readptr;\n\tint\t\t\ti;\n\tResourceOwner oldowner;\n\n\tstate->tuples++;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grow the array as needed.  Note that we try to grow the array\n\t\t\t * when there is still one free slot remaining --- if we fail,\n\t\t\t * there'll still be room to store the incoming tuple, and then\n\t\t\t * we'll switch to tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\n\t\t\t/* Stash the tuple in the in-memory array */\n\t\t\tstate->memtuples[state->memtupcount++] = tuple;\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.  Make sure that\n\t\t\t * the temp file(s) are created in suitable temp tablespaces.\n\t\t\t */\n\t\t\tPrepareTempTablespaces();\n\n\t\t\t/* associate the file with the store's resource owner */\n\t\t\toldowner = CurrentResourceOwner;\n\t\t\tCurrentResourceOwner = state->resowner;\n\n\t\t\tstate->myfile = BufFileCreateTemp(state->interXact);\n\n\t\t\tCurrentResourceOwner = oldowner;\n\n\t\t\t/*\n\t\t\t * Freeze the decision about whether trailing length words will be\n\t\t\t * used.  We can't change this choice once data is on tape, even\n\t\t\t * though callers might drop the requirement.\n\t\t\t */\n\t\t\tstate->backward = (state->eflags & EXEC_FLAG_BACKWARD) != 0;\n\t\t\tstate->status = TSS_WRITEFILE;\n\t\t\tdumptuples(state);\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above. Note:\n\t\t\t * BufFileTell is quite cheap, so not worth trying to avoid\n\t\t\t * multiple calls.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&readptr->file,\n\t\t\t\t\t\t\t\t&readptr->offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * Switch from reading to writing.\n\t\t\t */\n\t\t\tif (!state->readptrs[state->activeptr].eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].file,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].offset);\n\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\tstate->writepos_file, state->writepos_offset,\n\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_WRITEFILE;\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->file = state->writepos_file;\n\t\t\t\t\treadptr->offset = state->writepos_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);",
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void tuplestore_puttuple_common(Tuplestorestate *state, void *tuple);\nstatic void dumptuples(Tuplestorestate *state);\n\nstatic void\ntuplestore_puttuple_common(Tuplestorestate *state, void *tuple)\n{\n\tTSReadPointer *readptr;\n\tint\t\t\ti;\n\tResourceOwner oldowner;\n\n\tstate->tuples++;\n\n\tswitch (state->status)\n\t{\n\t\tcase TSS_INMEM:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->current = state->memtupcount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Grow the array as needed.  Note that we try to grow the array\n\t\t\t * when there is still one free slot remaining --- if we fail,\n\t\t\t * there'll still be room to store the incoming tuple, and then\n\t\t\t * we'll switch to tape-based operation.\n\t\t\t */\n\t\t\tif (state->memtupcount >= state->memtupsize - 1)\n\t\t\t{\n\t\t\t\t(void) grow_memtuples(state);\n\t\t\t\tAssert(state->memtupcount < state->memtupsize);\n\t\t\t}\n\n\t\t\t/* Stash the tuple in the in-memory array */\n\t\t\tstate->memtuples[state->memtupcount++] = tuple;\n\n\t\t\t/*\n\t\t\t * Done if we still fit in available memory and have array slots.\n\t\t\t */\n\t\t\tif (state->memtupcount < state->memtupsize && !LACKMEM(state))\n\t\t\t\treturn;\n\n\t\t\t/*\n\t\t\t * Nope; time to switch to tape-based operation.  Make sure that\n\t\t\t * the temp file(s) are created in suitable temp tablespaces.\n\t\t\t */\n\t\t\tPrepareTempTablespaces();\n\n\t\t\t/* associate the file with the store's resource owner */\n\t\t\toldowner = CurrentResourceOwner;\n\t\t\tCurrentResourceOwner = state->resowner;\n\n\t\t\tstate->myfile = BufFileCreateTemp(state->interXact);\n\n\t\t\tCurrentResourceOwner = oldowner;\n\n\t\t\t/*\n\t\t\t * Freeze the decision about whether trailing length words will be\n\t\t\t * used.  We can't change this choice once data is on tape, even\n\t\t\t * though callers might drop the requirement.\n\t\t\t */\n\t\t\tstate->backward = (state->eflags & EXEC_FLAG_BACKWARD) != 0;\n\t\t\tstate->status = TSS_WRITEFILE;\n\t\t\tdumptuples(state);\n\t\t\tbreak;\n\t\tcase TSS_WRITEFILE:\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above. Note:\n\t\t\t * BufFileTell is quite cheap, so not worth trying to avoid\n\t\t\t * multiple calls.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t\t&readptr->file,\n\t\t\t\t\t\t\t\t&readptr->offset);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tcase TSS_READFILE:\n\n\t\t\t/*\n\t\t\t * Switch from reading to writing.\n\t\t\t */\n\t\t\tif (!state->readptrs[state->activeptr].eof_reached)\n\t\t\t\tBufFileTell(state->myfile,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].file,\n\t\t\t\t\t\t\t&state->readptrs[state->activeptr].offset);\n\t\t\tif (BufFileSeek(state->myfile,\n\t\t\t\t\t\t\tstate->writepos_file, state->writepos_offset,\n\t\t\t\t\t\t\tSEEK_SET) != 0)\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not seek in tuplestore temporary file: %m\")));\n\t\t\tstate->status = TSS_WRITEFILE;\n\n\t\t\t/*\n\t\t\t * Update read pointers as needed; see API spec above.\n\t\t\t */\n\t\t\treadptr = state->readptrs;\n\t\t\tfor (i = 0; i < state->readptrcount; readptr++, i++)\n\t\t\t{\n\t\t\t\tif (readptr->eof_reached && i != state->activeptr)\n\t\t\t\t{\n\t\t\t\t\treadptr->eof_reached = false;\n\t\t\t\t\treadptr->file = state->writepos_file;\n\t\t\t\t\treadptr->offset = state->writepos_offset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWRITETUP(state, tuple);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"invalid tuplestore state\");\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BuildTupleFromCStrings",
          "args": [
            "attinmeta",
            "values"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_configdata",
          "args": [
            "my_exec_path",
            "&configdata_len"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tuplestore_begin_heap",
          "args": [
            "true",
            "false",
            "work_mem"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "tuplestore_begin_heap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/sort/tuplestore.c",
          "lines": "317-338",
          "snippet": "Tuplestorestate *\ntuplestore_begin_heap(bool randomAccess, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\tint\t\t\teflags;\n\n\t/*\n\t * This interpretation of the meaning of randomAccess is compatible with\n\t * the pre-8.3 behavior of tuplestores.\n\t */\n\teflags = randomAccess ?\n\t\t(EXEC_FLAG_BACKWARD | EXEC_FLAG_REWIND) :\n\t\t(EXEC_FLAG_REWIND);\n\n\tstate = tuplestore_begin_common(eflags, interXact, maxKBytes);\n\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\treturn state;\n}",
          "includes": [
            "#include \"utils/resowner.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"storage/buffile.h\"",
            "#include \"miscadmin.h\"",
            "#include \"executor/executor.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);",
            "static void dumptuples(Tuplestorestate *state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/resowner.h\"\n#include \"utils/memutils.h\"\n#include \"storage/buffile.h\"\n#include \"miscadmin.h\"\n#include \"executor/executor.h\"\n#include \"commands/tablespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Tuplestorestate *tuplestore_begin_common(int eflags,\n\t\t\t\t\t\tbool interXact,\n\t\t\t\t\t\tint maxKBytes);\nstatic void dumptuples(Tuplestorestate *state);\n\nTuplestorestate *\ntuplestore_begin_heap(bool randomAccess, bool interXact, int maxKBytes)\n{\n\tTuplestorestate *state;\n\tint\t\t\teflags;\n\n\t/*\n\t * This interpretation of the meaning of randomAccess is compatible with\n\t * the pre-8.3 behavior of tuplestores.\n\t */\n\teflags = randomAccess ?\n\t\t(EXEC_FLAG_BACKWARD | EXEC_FLAG_REWIND) :\n\t\t(EXEC_FLAG_REWIND);\n\n\tstate = tuplestore_begin_common(eflags, interXact, maxKBytes);\n\n\tstate->copytup = copytup_heap;\n\tstate->writetup = writetup_heap;\n\tstate->readtup = readtup_heap;\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TupleDescGetAttInMetadata",
          "args": [
            "tupdesc"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"query-specified return tuple and \"\n\t\t\t\t\t\t\"function return type are not compatible\"))"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"query-specified return tuple and \"\n\t\t\t\t\t\t\"function return type are not compatible\""
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_SYNTAX_ERROR"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "GUC_check_errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/guc.c",
          "lines": "10064-10068",
          "snippet": "void\nGUC_check_errcode(int sqlerrcode)\n{\n\tGUC_check_errcode_value = sqlerrcode;\n}",
          "includes": [
            "#include \"guc-file.c\"",
            "#include \"utils/xml.h\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/tzparser.h\"",
            "#include \"utils/snapmgr.h\"",
            "#include \"utils/rls.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"utils/portal.h\"",
            "#include \"utils/plancache.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc_tables.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_cache.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/predicate.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/pg_shmem.h\"",
            "#include \"storage/large_object.h\"",
            "#include \"storage/fd.h\"",
            "#include \"storage/standby.h\"",
            "#include \"storage/dsm_impl.h\"",
            "#include \"storage/bufmgr.h\"",
            "#include \"replication/walsender.h\"",
            "#include \"replication/walreceiver.h\"",
            "#include \"replication/syncrep.h\"",
            "#include \"replication/slot.h\"",
            "#include \"replication/logicallauncher.h\"",
            "#include \"postmaster/walwriter.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"postmaster/bgwriter.h\"",
            "#include \"postmaster/bgworker_internals.h\"",
            "#include \"postmaster/autovacuum.h\"",
            "#include \"pgstat.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parser.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"parser/parse_expr.h\"",
            "#include \"optimizer/planmain.h\"",
            "#include \"optimizer/paths.h\"",
            "#include \"optimizer/geqo.h\"",
            "#include \"optimizer/cost.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"libpq/auth.h\"",
            "#include \"jit/jit.h\"",
            "#include \"funcapi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"commands/variable.h\"",
            "#include \"commands/vacuum.h\"",
            "#include \"commands/user.h\"",
            "#include \"commands/prepare.h\"",
            "#include \"commands/async.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xlog_internal.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/twophase.h\"",
            "#include \"access/transam.h\"",
            "#include \"access/rmgr.h\"",
            "#include \"access/gin.h\"",
            "#include \"access/commit_ts.h\"",
            "#include <syslog.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tGUC_check_errcode_value;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"guc-file.c\"\n#include \"utils/xml.h\"\n#include \"utils/varlena.h\"\n#include \"utils/tzparser.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/rls.h\"\n#include \"utils/ps_status.h\"\n#include \"utils/portal.h\"\n#include \"utils/plancache.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc_tables.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_cache.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/predicate.h\"\n#include \"storage/proc.h\"\n#include \"storage/pg_shmem.h\"\n#include \"storage/large_object.h\"\n#include \"storage/fd.h\"\n#include \"storage/standby.h\"\n#include \"storage/dsm_impl.h\"\n#include \"storage/bufmgr.h\"\n#include \"replication/walsender.h\"\n#include \"replication/walreceiver.h\"\n#include \"replication/syncrep.h\"\n#include \"replication/slot.h\"\n#include \"replication/logicallauncher.h\"\n#include \"postmaster/walwriter.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"postmaster/bgwriter.h\"\n#include \"postmaster/bgworker_internals.h\"\n#include \"postmaster/autovacuum.h\"\n#include \"pgstat.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parser.h\"\n#include \"parser/parse_type.h\"\n#include \"parser/parse_expr.h\"\n#include \"optimizer/planmain.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/geqo.h\"\n#include \"optimizer/cost.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"libpq/auth.h\"\n#include \"jit/jit.h\"\n#include \"funcapi.h\"\n#include \"commands/trigger.h\"\n#include \"commands/variable.h\"\n#include \"commands/vacuum.h\"\n#include \"commands/user.h\"\n#include \"commands/prepare.h\"\n#include \"commands/async.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xlog_internal.h\"\n#include \"access/xact.h\"\n#include \"access/twophase.h\"\n#include \"access/transam.h\"\n#include \"access/rmgr.h\"\n#include \"access/gin.h\"\n#include \"access/commit_ts.h\"\n#include <syslog.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int\tGUC_check_errcode_value;\n\nvoid\nGUC_check_errcode(int sqlerrcode)\n{\n\tGUC_check_errcode_value = sqlerrcode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "1"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescAttr",
          "args": [
            "tupdesc",
            "0"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTupleDescCopy",
          "args": [
            "rsinfo->expectedDesc"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "per_query_ctx"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"materialize mode required, but it is not \"\n\t\t\t\t\t\t\"allowed in this context\"))"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"port.h\"\n#include \"utils/builtins.h\"\n#include \"common/config_info.h\"\n#include \"catalog/pg_type.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"postgres.h\"\n\nDatum\npg_config(PG_FUNCTION_ARGS)\n{\n\tReturnSetInfo *rsinfo = (ReturnSetInfo *) fcinfo->resultinfo;\n\tTuplestorestate *tupstore;\n\tHeapTuple\ttuple;\n\tTupleDesc\ttupdesc;\n\tAttInMetadata *attinmeta;\n\tMemoryContext per_query_ctx;\n\tMemoryContext oldcontext;\n\tConfigData *configdata;\n\tsize_t\t\tconfigdata_len;\n\tchar\t   *values[2];\n\tint\t\t\ti = 0;\n\n\t/* check to see if caller supports us returning a tuplestore */\n\tif (!rsinfo || !(rsinfo->allowedModes & SFRM_Materialize))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"materialize mode required, but it is not \"\n\t\t\t\t\t\t\"allowed in this context\")));\n\n\tper_query_ctx = rsinfo->econtext->ecxt_per_query_memory;\n\toldcontext = MemoryContextSwitchTo(per_query_ctx);\n\n\t/* get the requested return tuple description */\n\ttupdesc = CreateTupleDescCopy(rsinfo->expectedDesc);\n\n\t/*\n\t * Check to make sure we have a reasonable tuple descriptor\n\t */\n\tif (tupdesc->natts != 2 ||\n\t\tTupleDescAttr(tupdesc, 0)->atttypid != TEXTOID ||\n\t\tTupleDescAttr(tupdesc, 1)->atttypid != TEXTOID)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"query-specified return tuple and \"\n\t\t\t\t\t\t\"function return type are not compatible\")));\n\n\t/* OK to use it */\n\tattinmeta = TupleDescGetAttInMetadata(tupdesc);\n\n\t/* let the caller know we're sending back a tuplestore */\n\trsinfo->returnMode = SFRM_Materialize;\n\n\t/* initialize our tuplestore */\n\ttupstore = tuplestore_begin_heap(true, false, work_mem);\n\n\tconfigdata = get_configdata(my_exec_path, &configdata_len);\n\tfor (i = 0; i < configdata_len; i++)\n\t{\n\t\tvalues[0] = configdata[i].name;\n\t\tvalues[1] = configdata[i].setting;\n\n\t\ttuple = BuildTupleFromCStrings(attinmeta, values);\n\t\ttuplestore_puttuple(tupstore, tuple);\n\t}\n\n\t/*\n\t * no longer need the tuple descriptor reference created by\n\t * TupleDescGetAttInMetadata()\n\t */\n\tReleaseTupleDesc(tupdesc);\n\n\ttuplestore_donestoring(tupstore);\n\trsinfo->setResult = tupstore;\n\n\t/*\n\t * SFRM_Materialize mode expects us to return a NULL Datum. The actual\n\t * tuples are in our tuplestore and passed back through rsinfo->setResult.\n\t * rsinfo->setDesc is set to the tuple description that we actually used\n\t * to build our tuples with, so the caller can verify we did what it was\n\t * expecting.\n\t */\n\trsinfo->setDesc = tupdesc;\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn (Datum) 0;\n}"
  }
]