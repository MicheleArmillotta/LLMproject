[
  {
    "function_name": "inet_cidr_ntop_ipv6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/inet_cidr_ntop.c",
    "lines": "164-294",
    "snippet": "static char *\ninet_cidr_ntop_ipv6(const u_char *src, int bits, char *dst, size_t size)\n{\n\tu_int\t\tm;\n\tint\t\t\tb;\n\tint\t\t\tp;\n\tint\t\t\tzero_s,\n\t\t\t\tzero_l,\n\t\t\t\ttmp_zero_s,\n\t\t\t\ttmp_zero_l;\n\tint\t\t\ti;\n\tint\t\t\tis_ipv4 = 0;\n\tunsigned char inbuf[16];\n\tchar\t\toutbuf[sizeof(\"xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255/128\")];\n\tchar\t   *cp;\n\tint\t\t\twords;\n\tu_char\t   *s;\n\n\tif (bits < 0 || bits > 128)\n\t{\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tcp = outbuf;\n\n\tif (bits == 0)\n\t{\n\t\t*cp++ = ':';\n\t\t*cp++ = ':';\n\t\t*cp = '\\0';\n\t}\n\telse\n\t{\n\t\t/* Copy src to private buffer.  Zero host part. */\n\t\tp = (bits + 7) / 8;\n\t\tmemcpy(inbuf, src, p);\n\t\tmemset(inbuf + p, 0, 16 - p);\n\t\tb = bits % 8;\n\t\tif (b != 0)\n\t\t{\n\t\t\tm = ((u_int) ~0) << (8 - b);\n\t\t\tinbuf[p - 1] &= m;\n\t\t}\n\n\t\ts = inbuf;\n\n\t\t/* how many words need to be displayed in output */\n\t\twords = (bits + 15) / 16;\n\t\tif (words == 1)\n\t\t\twords = 2;\n\n\t\t/* Find the longest substring of zero's */\n\t\tzero_s = zero_l = tmp_zero_s = tmp_zero_l = 0;\n\t\tfor (i = 0; i < (words * 2); i += 2)\n\t\t{\n\t\t\tif ((s[i] | s[i + 1]) == 0)\n\t\t\t{\n\t\t\t\tif (tmp_zero_l == 0)\n\t\t\t\t\ttmp_zero_s = i / 2;\n\t\t\t\ttmp_zero_l++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (tmp_zero_l && zero_l < tmp_zero_l)\n\t\t\t\t{\n\t\t\t\t\tzero_s = tmp_zero_s;\n\t\t\t\t\tzero_l = tmp_zero_l;\n\t\t\t\t\ttmp_zero_l = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmp_zero_l && zero_l < tmp_zero_l)\n\t\t{\n\t\t\tzero_s = tmp_zero_s;\n\t\t\tzero_l = tmp_zero_l;\n\t\t}\n\n\t\tif (zero_l != words && zero_s == 0 && ((zero_l == 6) ||\n\t\t\t\t\t\t\t\t\t\t\t   ((zero_l == 5 && s[10] == 0xff && s[11] == 0xff) ||\n\t\t\t\t\t\t\t\t\t\t\t\t((zero_l == 7 && s[14] != 0 && s[15] != 1)))))\n\t\t\tis_ipv4 = 1;\n\n\t\t/* Format whole words. */\n\t\tfor (p = 0; p < words; p++)\n\t\t{\n\t\t\tif (zero_l != 0 && p >= zero_s && p < zero_s + zero_l)\n\t\t\t{\n\t\t\t\t/* Time to skip some zeros */\n\t\t\t\tif (p == zero_s)\n\t\t\t\t\t*cp++ = ':';\n\t\t\t\tif (p == words - 1)\n\t\t\t\t\t*cp++ = ':';\n\t\t\t\ts++;\n\t\t\t\ts++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (is_ipv4 && p > 5)\n\t\t\t{\n\t\t\t\t*cp++ = (p == 6) ? ':' : '.';\n\t\t\t\tcp += SPRINTF((cp, \"%u\", *s++));\n\t\t\t\t/* we can potentially drop the last octet */\n\t\t\t\tif (p != 7 || bits > 120)\n\t\t\t\t{\n\t\t\t\t\t*cp++ = '.';\n\t\t\t\t\tcp += SPRINTF((cp, \"%u\", *s++));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (cp != outbuf)\n\t\t\t\t\t*cp++ = ':';\n\t\t\t\tcp += SPRINTF((cp, \"%x\", *s * 256 + s[1]));\n\t\t\t\ts += 2;\n\t\t\t}\n\t\t}\n\t}\n\t/* Format CIDR /width. */\n\t(void) SPRINTF((cp, \"/%u\", bits));\n\tif (strlen(outbuf) + 1 > size)\n\t\tgoto emsgsize;\n\tstrcpy(dst, outbuf);\n\n\treturn dst;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define SPRINTF(x) strlen(sprintf/**/x)"
    ],
    "globals_used": [
      "static char *inet_cidr_ntop_ipv4(const u_char *src, int bits,\n\t\t\t\t\tchar *dst, size_t size);",
      "static char *inet_cidr_ntop_ipv6(const u_char *src, int bits,\n\t\t\t\t\tchar *dst, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dst",
            "outbuf"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "215-222",
          "snippet": "int\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcpy(Name name, const char *str)\n{\n\tif (!name || !str)\n\t\treturn -1;\n\tStrNCpy(NameStr(*name), str, NAMEDATALEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "outbuf"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPRINTF",
          "args": [
            "(cp, \"/%u\", bits)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPRINTF",
          "args": [
            "(cp, \"%x\", *s * 256 + s[1])"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPRINTF",
          "args": [
            "(cp, \"%u\", *s++)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPRINTF",
          "args": [
            "(cp, \"%u\", *s++)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "inbuf + p",
            "0",
            "16 - p"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "inbuf",
            "src",
            "p"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\n#define SPRINTF(x) strlen(sprintf/**/x)\n\nstatic char *inet_cidr_ntop_ipv4(const u_char *src, int bits,\n\t\t\t\t\tchar *dst, size_t size);\nstatic char *inet_cidr_ntop_ipv6(const u_char *src, int bits,\n\t\t\t\t\tchar *dst, size_t size);\n\nstatic char *\ninet_cidr_ntop_ipv6(const u_char *src, int bits, char *dst, size_t size)\n{\n\tu_int\t\tm;\n\tint\t\t\tb;\n\tint\t\t\tp;\n\tint\t\t\tzero_s,\n\t\t\t\tzero_l,\n\t\t\t\ttmp_zero_s,\n\t\t\t\ttmp_zero_l;\n\tint\t\t\ti;\n\tint\t\t\tis_ipv4 = 0;\n\tunsigned char inbuf[16];\n\tchar\t\toutbuf[sizeof(\"xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255/128\")];\n\tchar\t   *cp;\n\tint\t\t\twords;\n\tu_char\t   *s;\n\n\tif (bits < 0 || bits > 128)\n\t{\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tcp = outbuf;\n\n\tif (bits == 0)\n\t{\n\t\t*cp++ = ':';\n\t\t*cp++ = ':';\n\t\t*cp = '\\0';\n\t}\n\telse\n\t{\n\t\t/* Copy src to private buffer.  Zero host part. */\n\t\tp = (bits + 7) / 8;\n\t\tmemcpy(inbuf, src, p);\n\t\tmemset(inbuf + p, 0, 16 - p);\n\t\tb = bits % 8;\n\t\tif (b != 0)\n\t\t{\n\t\t\tm = ((u_int) ~0) << (8 - b);\n\t\t\tinbuf[p - 1] &= m;\n\t\t}\n\n\t\ts = inbuf;\n\n\t\t/* how many words need to be displayed in output */\n\t\twords = (bits + 15) / 16;\n\t\tif (words == 1)\n\t\t\twords = 2;\n\n\t\t/* Find the longest substring of zero's */\n\t\tzero_s = zero_l = tmp_zero_s = tmp_zero_l = 0;\n\t\tfor (i = 0; i < (words * 2); i += 2)\n\t\t{\n\t\t\tif ((s[i] | s[i + 1]) == 0)\n\t\t\t{\n\t\t\t\tif (tmp_zero_l == 0)\n\t\t\t\t\ttmp_zero_s = i / 2;\n\t\t\t\ttmp_zero_l++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (tmp_zero_l && zero_l < tmp_zero_l)\n\t\t\t\t{\n\t\t\t\t\tzero_s = tmp_zero_s;\n\t\t\t\t\tzero_l = tmp_zero_l;\n\t\t\t\t\ttmp_zero_l = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmp_zero_l && zero_l < tmp_zero_l)\n\t\t{\n\t\t\tzero_s = tmp_zero_s;\n\t\t\tzero_l = tmp_zero_l;\n\t\t}\n\n\t\tif (zero_l != words && zero_s == 0 && ((zero_l == 6) ||\n\t\t\t\t\t\t\t\t\t\t\t   ((zero_l == 5 && s[10] == 0xff && s[11] == 0xff) ||\n\t\t\t\t\t\t\t\t\t\t\t\t((zero_l == 7 && s[14] != 0 && s[15] != 1)))))\n\t\t\tis_ipv4 = 1;\n\n\t\t/* Format whole words. */\n\t\tfor (p = 0; p < words; p++)\n\t\t{\n\t\t\tif (zero_l != 0 && p >= zero_s && p < zero_s + zero_l)\n\t\t\t{\n\t\t\t\t/* Time to skip some zeros */\n\t\t\t\tif (p == zero_s)\n\t\t\t\t\t*cp++ = ':';\n\t\t\t\tif (p == words - 1)\n\t\t\t\t\t*cp++ = ':';\n\t\t\t\ts++;\n\t\t\t\ts++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (is_ipv4 && p > 5)\n\t\t\t{\n\t\t\t\t*cp++ = (p == 6) ? ':' : '.';\n\t\t\t\tcp += SPRINTF((cp, \"%u\", *s++));\n\t\t\t\t/* we can potentially drop the last octet */\n\t\t\t\tif (p != 7 || bits > 120)\n\t\t\t\t{\n\t\t\t\t\t*cp++ = '.';\n\t\t\t\t\tcp += SPRINTF((cp, \"%u\", *s++));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (cp != outbuf)\n\t\t\t\t\t*cp++ = ':';\n\t\t\t\tcp += SPRINTF((cp, \"%x\", *s * 256 + s[1]));\n\t\t\t\ts += 2;\n\t\t\t}\n\t\t}\n\t}\n\t/* Format CIDR /width. */\n\t(void) SPRINTF((cp, \"/%u\", bits));\n\tif (strlen(outbuf) + 1 > size)\n\t\tgoto emsgsize;\n\tstrcpy(dst, outbuf);\n\n\treturn dst;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn NULL;\n}"
  },
  {
    "function_name": "inet_cidr_ntop_ipv4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/inet_cidr_ntop.c",
    "lines": "84-145",
    "snippet": "static char *\ninet_cidr_ntop_ipv4(const u_char *src, int bits, char *dst, size_t size)\n{\n\tchar\t   *odst = dst;\n\tchar\t   *t;\n\tu_int\t\tm;\n\tint\t\t\tb;\n\n\tif (bits < 0 || bits > 32)\n\t{\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (bits == 0)\n\t{\n\t\tif (size < sizeof \"0\")\n\t\t\tgoto emsgsize;\n\t\t*dst++ = '0';\n\t\tsize--;\n\t\t*dst = '\\0';\n\t}\n\n\t/* Format whole octets. */\n\tfor (b = bits / 8; b > 0; b--)\n\t{\n\t\tif (size <= sizeof \"255.\")\n\t\t\tgoto emsgsize;\n\t\tt = dst;\n\t\tdst += SPRINTF((dst, \"%u\", *src++));\n\t\tif (b > 1)\n\t\t{\n\t\t\t*dst++ = '.';\n\t\t\t*dst = '\\0';\n\t\t}\n\t\tsize -= (size_t) (dst - t);\n\t}\n\n\t/* Format partial octet. */\n\tb = bits % 8;\n\tif (b > 0)\n\t{\n\t\tif (size <= sizeof \".255\")\n\t\t\tgoto emsgsize;\n\t\tt = dst;\n\t\tif (dst != odst)\n\t\t\t*dst++ = '.';\n\t\tm = ((1 << b) - 1) << (8 - b);\n\t\tdst += SPRINTF((dst, \"%u\", *src & m));\n\t\tsize -= (size_t) (dst - t);\n\t}\n\n\t/* Format CIDR /width. */\n\tif (size <= sizeof \"/32\")\n\t\tgoto emsgsize;\n\tdst += SPRINTF((dst, \"/%u\", bits));\n\treturn odst;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define SPRINTF(x) strlen(sprintf/**/x)"
    ],
    "globals_used": [
      "static char *inet_cidr_ntop_ipv4(const u_char *src, int bits,\n\t\t\t\t\tchar *dst, size_t size);",
      "static char *inet_cidr_ntop_ipv6(const u_char *src, int bits,\n\t\t\t\t\tchar *dst, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SPRINTF",
          "args": [
            "(dst, \"/%u\", bits)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPRINTF",
          "args": [
            "(dst, \"%u\", *src & m)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPRINTF",
          "args": [
            "(dst, \"%u\", *src++)"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\n#define SPRINTF(x) strlen(sprintf/**/x)\n\nstatic char *inet_cidr_ntop_ipv4(const u_char *src, int bits,\n\t\t\t\t\tchar *dst, size_t size);\nstatic char *inet_cidr_ntop_ipv6(const u_char *src, int bits,\n\t\t\t\t\tchar *dst, size_t size);\n\nstatic char *\ninet_cidr_ntop_ipv4(const u_char *src, int bits, char *dst, size_t size)\n{\n\tchar\t   *odst = dst;\n\tchar\t   *t;\n\tu_int\t\tm;\n\tint\t\t\tb;\n\n\tif (bits < 0 || bits > 32)\n\t{\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (bits == 0)\n\t{\n\t\tif (size < sizeof \"0\")\n\t\t\tgoto emsgsize;\n\t\t*dst++ = '0';\n\t\tsize--;\n\t\t*dst = '\\0';\n\t}\n\n\t/* Format whole octets. */\n\tfor (b = bits / 8; b > 0; b--)\n\t{\n\t\tif (size <= sizeof \"255.\")\n\t\t\tgoto emsgsize;\n\t\tt = dst;\n\t\tdst += SPRINTF((dst, \"%u\", *src++));\n\t\tif (b > 1)\n\t\t{\n\t\t\t*dst++ = '.';\n\t\t\t*dst = '\\0';\n\t\t}\n\t\tsize -= (size_t) (dst - t);\n\t}\n\n\t/* Format partial octet. */\n\tb = bits % 8;\n\tif (b > 0)\n\t{\n\t\tif (size <= sizeof \".255\")\n\t\t\tgoto emsgsize;\n\t\tt = dst;\n\t\tif (dst != odst)\n\t\t\t*dst++ = '.';\n\t\tm = ((1 << b) - 1) << (8 - b);\n\t\tdst += SPRINTF((dst, \"%u\", *src & m));\n\t\tsize -= (size_t) (dst - t);\n\t}\n\n\t/* Format CIDR /width. */\n\tif (size <= sizeof \"/32\")\n\t\tgoto emsgsize;\n\tdst += SPRINTF((dst, \"/%u\", bits));\n\treturn odst;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn NULL;\n}"
  },
  {
    "function_name": "inet_cidr_ntop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/inet_cidr_ntop.c",
    "lines": "55-68",
    "snippet": "char *\ninet_cidr_ntop(int af, const void *src, int bits, char *dst, size_t size)\n{\n\tswitch (af)\n\t{\n\t\tcase PGSQL_AF_INET:\n\t\t\treturn inet_cidr_ntop_ipv4(src, bits, dst, size);\n\t\tcase PGSQL_AF_INET6:\n\t\t\treturn inet_cidr_ntop_ipv6(src, bits, dst, size);\n\t\tdefault:\n\t\t\terrno = EAFNOSUPPORT;\n\t\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include \"utils/inet.h\"",
      "#include \"utils/builtins.h\"",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *inet_cidr_ntop_ipv4(const u_char *src, int bits,\n\t\t\t\t\tchar *dst, size_t size);",
      "static char *inet_cidr_ntop_ipv6(const u_char *src, int bits,\n\t\t\t\t\tchar *dst, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inet_cidr_ntop_ipv6",
          "args": [
            "src",
            "bits",
            "dst",
            "size"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "inet_cidr_ntop_ipv6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/inet_cidr_ntop.c",
          "lines": "164-294",
          "snippet": "static char *\ninet_cidr_ntop_ipv6(const u_char *src, int bits, char *dst, size_t size)\n{\n\tu_int\t\tm;\n\tint\t\t\tb;\n\tint\t\t\tp;\n\tint\t\t\tzero_s,\n\t\t\t\tzero_l,\n\t\t\t\ttmp_zero_s,\n\t\t\t\ttmp_zero_l;\n\tint\t\t\ti;\n\tint\t\t\tis_ipv4 = 0;\n\tunsigned char inbuf[16];\n\tchar\t\toutbuf[sizeof(\"xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255/128\")];\n\tchar\t   *cp;\n\tint\t\t\twords;\n\tu_char\t   *s;\n\n\tif (bits < 0 || bits > 128)\n\t{\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tcp = outbuf;\n\n\tif (bits == 0)\n\t{\n\t\t*cp++ = ':';\n\t\t*cp++ = ':';\n\t\t*cp = '\\0';\n\t}\n\telse\n\t{\n\t\t/* Copy src to private buffer.  Zero host part. */\n\t\tp = (bits + 7) / 8;\n\t\tmemcpy(inbuf, src, p);\n\t\tmemset(inbuf + p, 0, 16 - p);\n\t\tb = bits % 8;\n\t\tif (b != 0)\n\t\t{\n\t\t\tm = ((u_int) ~0) << (8 - b);\n\t\t\tinbuf[p - 1] &= m;\n\t\t}\n\n\t\ts = inbuf;\n\n\t\t/* how many words need to be displayed in output */\n\t\twords = (bits + 15) / 16;\n\t\tif (words == 1)\n\t\t\twords = 2;\n\n\t\t/* Find the longest substring of zero's */\n\t\tzero_s = zero_l = tmp_zero_s = tmp_zero_l = 0;\n\t\tfor (i = 0; i < (words * 2); i += 2)\n\t\t{\n\t\t\tif ((s[i] | s[i + 1]) == 0)\n\t\t\t{\n\t\t\t\tif (tmp_zero_l == 0)\n\t\t\t\t\ttmp_zero_s = i / 2;\n\t\t\t\ttmp_zero_l++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (tmp_zero_l && zero_l < tmp_zero_l)\n\t\t\t\t{\n\t\t\t\t\tzero_s = tmp_zero_s;\n\t\t\t\t\tzero_l = tmp_zero_l;\n\t\t\t\t\ttmp_zero_l = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmp_zero_l && zero_l < tmp_zero_l)\n\t\t{\n\t\t\tzero_s = tmp_zero_s;\n\t\t\tzero_l = tmp_zero_l;\n\t\t}\n\n\t\tif (zero_l != words && zero_s == 0 && ((zero_l == 6) ||\n\t\t\t\t\t\t\t\t\t\t\t   ((zero_l == 5 && s[10] == 0xff && s[11] == 0xff) ||\n\t\t\t\t\t\t\t\t\t\t\t\t((zero_l == 7 && s[14] != 0 && s[15] != 1)))))\n\t\t\tis_ipv4 = 1;\n\n\t\t/* Format whole words. */\n\t\tfor (p = 0; p < words; p++)\n\t\t{\n\t\t\tif (zero_l != 0 && p >= zero_s && p < zero_s + zero_l)\n\t\t\t{\n\t\t\t\t/* Time to skip some zeros */\n\t\t\t\tif (p == zero_s)\n\t\t\t\t\t*cp++ = ':';\n\t\t\t\tif (p == words - 1)\n\t\t\t\t\t*cp++ = ':';\n\t\t\t\ts++;\n\t\t\t\ts++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (is_ipv4 && p > 5)\n\t\t\t{\n\t\t\t\t*cp++ = (p == 6) ? ':' : '.';\n\t\t\t\tcp += SPRINTF((cp, \"%u\", *s++));\n\t\t\t\t/* we can potentially drop the last octet */\n\t\t\t\tif (p != 7 || bits > 120)\n\t\t\t\t{\n\t\t\t\t\t*cp++ = '.';\n\t\t\t\t\tcp += SPRINTF((cp, \"%u\", *s++));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (cp != outbuf)\n\t\t\t\t\t*cp++ = ':';\n\t\t\t\tcp += SPRINTF((cp, \"%x\", *s * 256 + s[1]));\n\t\t\t\ts += 2;\n\t\t\t}\n\t\t}\n\t}\n\t/* Format CIDR /width. */\n\t(void) SPRINTF((cp, \"/%u\", bits));\n\tif (strlen(outbuf) + 1 > size)\n\t\tgoto emsgsize;\n\tstrcpy(dst, outbuf);\n\n\treturn dst;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define SPRINTF(x) strlen(sprintf/**/x)"
          ],
          "globals_used": [
            "static char *inet_cidr_ntop_ipv4(const u_char *src, int bits,\n\t\t\t\t\tchar *dst, size_t size);",
            "static char *inet_cidr_ntop_ipv6(const u_char *src, int bits,\n\t\t\t\t\tchar *dst, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\n#define SPRINTF(x) strlen(sprintf/**/x)\n\nstatic char *inet_cidr_ntop_ipv4(const u_char *src, int bits,\n\t\t\t\t\tchar *dst, size_t size);\nstatic char *inet_cidr_ntop_ipv6(const u_char *src, int bits,\n\t\t\t\t\tchar *dst, size_t size);\n\nstatic char *\ninet_cidr_ntop_ipv6(const u_char *src, int bits, char *dst, size_t size)\n{\n\tu_int\t\tm;\n\tint\t\t\tb;\n\tint\t\t\tp;\n\tint\t\t\tzero_s,\n\t\t\t\tzero_l,\n\t\t\t\ttmp_zero_s,\n\t\t\t\ttmp_zero_l;\n\tint\t\t\ti;\n\tint\t\t\tis_ipv4 = 0;\n\tunsigned char inbuf[16];\n\tchar\t\toutbuf[sizeof(\"xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255/128\")];\n\tchar\t   *cp;\n\tint\t\t\twords;\n\tu_char\t   *s;\n\n\tif (bits < 0 || bits > 128)\n\t{\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tcp = outbuf;\n\n\tif (bits == 0)\n\t{\n\t\t*cp++ = ':';\n\t\t*cp++ = ':';\n\t\t*cp = '\\0';\n\t}\n\telse\n\t{\n\t\t/* Copy src to private buffer.  Zero host part. */\n\t\tp = (bits + 7) / 8;\n\t\tmemcpy(inbuf, src, p);\n\t\tmemset(inbuf + p, 0, 16 - p);\n\t\tb = bits % 8;\n\t\tif (b != 0)\n\t\t{\n\t\t\tm = ((u_int) ~0) << (8 - b);\n\t\t\tinbuf[p - 1] &= m;\n\t\t}\n\n\t\ts = inbuf;\n\n\t\t/* how many words need to be displayed in output */\n\t\twords = (bits + 15) / 16;\n\t\tif (words == 1)\n\t\t\twords = 2;\n\n\t\t/* Find the longest substring of zero's */\n\t\tzero_s = zero_l = tmp_zero_s = tmp_zero_l = 0;\n\t\tfor (i = 0; i < (words * 2); i += 2)\n\t\t{\n\t\t\tif ((s[i] | s[i + 1]) == 0)\n\t\t\t{\n\t\t\t\tif (tmp_zero_l == 0)\n\t\t\t\t\ttmp_zero_s = i / 2;\n\t\t\t\ttmp_zero_l++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (tmp_zero_l && zero_l < tmp_zero_l)\n\t\t\t\t{\n\t\t\t\t\tzero_s = tmp_zero_s;\n\t\t\t\t\tzero_l = tmp_zero_l;\n\t\t\t\t\ttmp_zero_l = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmp_zero_l && zero_l < tmp_zero_l)\n\t\t{\n\t\t\tzero_s = tmp_zero_s;\n\t\t\tzero_l = tmp_zero_l;\n\t\t}\n\n\t\tif (zero_l != words && zero_s == 0 && ((zero_l == 6) ||\n\t\t\t\t\t\t\t\t\t\t\t   ((zero_l == 5 && s[10] == 0xff && s[11] == 0xff) ||\n\t\t\t\t\t\t\t\t\t\t\t\t((zero_l == 7 && s[14] != 0 && s[15] != 1)))))\n\t\t\tis_ipv4 = 1;\n\n\t\t/* Format whole words. */\n\t\tfor (p = 0; p < words; p++)\n\t\t{\n\t\t\tif (zero_l != 0 && p >= zero_s && p < zero_s + zero_l)\n\t\t\t{\n\t\t\t\t/* Time to skip some zeros */\n\t\t\t\tif (p == zero_s)\n\t\t\t\t\t*cp++ = ':';\n\t\t\t\tif (p == words - 1)\n\t\t\t\t\t*cp++ = ':';\n\t\t\t\ts++;\n\t\t\t\ts++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (is_ipv4 && p > 5)\n\t\t\t{\n\t\t\t\t*cp++ = (p == 6) ? ':' : '.';\n\t\t\t\tcp += SPRINTF((cp, \"%u\", *s++));\n\t\t\t\t/* we can potentially drop the last octet */\n\t\t\t\tif (p != 7 || bits > 120)\n\t\t\t\t{\n\t\t\t\t\t*cp++ = '.';\n\t\t\t\t\tcp += SPRINTF((cp, \"%u\", *s++));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (cp != outbuf)\n\t\t\t\t\t*cp++ = ':';\n\t\t\t\tcp += SPRINTF((cp, \"%x\", *s * 256 + s[1]));\n\t\t\t\ts += 2;\n\t\t\t}\n\t\t}\n\t}\n\t/* Format CIDR /width. */\n\t(void) SPRINTF((cp, \"/%u\", bits));\n\tif (strlen(outbuf) + 1 > size)\n\t\tgoto emsgsize;\n\tstrcpy(dst, outbuf);\n\n\treturn dst;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inet_cidr_ntop_ipv4",
          "args": [
            "src",
            "bits",
            "dst",
            "size"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "inet_cidr_ntop_ipv4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/inet_cidr_ntop.c",
          "lines": "84-145",
          "snippet": "static char *\ninet_cidr_ntop_ipv4(const u_char *src, int bits, char *dst, size_t size)\n{\n\tchar\t   *odst = dst;\n\tchar\t   *t;\n\tu_int\t\tm;\n\tint\t\t\tb;\n\n\tif (bits < 0 || bits > 32)\n\t{\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (bits == 0)\n\t{\n\t\tif (size < sizeof \"0\")\n\t\t\tgoto emsgsize;\n\t\t*dst++ = '0';\n\t\tsize--;\n\t\t*dst = '\\0';\n\t}\n\n\t/* Format whole octets. */\n\tfor (b = bits / 8; b > 0; b--)\n\t{\n\t\tif (size <= sizeof \"255.\")\n\t\t\tgoto emsgsize;\n\t\tt = dst;\n\t\tdst += SPRINTF((dst, \"%u\", *src++));\n\t\tif (b > 1)\n\t\t{\n\t\t\t*dst++ = '.';\n\t\t\t*dst = '\\0';\n\t\t}\n\t\tsize -= (size_t) (dst - t);\n\t}\n\n\t/* Format partial octet. */\n\tb = bits % 8;\n\tif (b > 0)\n\t{\n\t\tif (size <= sizeof \".255\")\n\t\t\tgoto emsgsize;\n\t\tt = dst;\n\t\tif (dst != odst)\n\t\t\t*dst++ = '.';\n\t\tm = ((1 << b) - 1) << (8 - b);\n\t\tdst += SPRINTF((dst, \"%u\", *src & m));\n\t\tsize -= (size_t) (dst - t);\n\t}\n\n\t/* Format CIDR /width. */\n\tif (size <= sizeof \"/32\")\n\t\tgoto emsgsize;\n\tdst += SPRINTF((dst, \"/%u\", bits));\n\treturn odst;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/inet.h\"",
            "#include \"utils/builtins.h\"",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/socket.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define SPRINTF(x) strlen(sprintf/**/x)"
          ],
          "globals_used": [
            "static char *inet_cidr_ntop_ipv4(const u_char *src, int bits,\n\t\t\t\t\tchar *dst, size_t size);",
            "static char *inet_cidr_ntop_ipv6(const u_char *src, int bits,\n\t\t\t\t\tchar *dst, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\n#define SPRINTF(x) strlen(sprintf/**/x)\n\nstatic char *inet_cidr_ntop_ipv4(const u_char *src, int bits,\n\t\t\t\t\tchar *dst, size_t size);\nstatic char *inet_cidr_ntop_ipv6(const u_char *src, int bits,\n\t\t\t\t\tchar *dst, size_t size);\n\nstatic char *\ninet_cidr_ntop_ipv4(const u_char *src, int bits, char *dst, size_t size)\n{\n\tchar\t   *odst = dst;\n\tchar\t   *t;\n\tu_int\t\tm;\n\tint\t\t\tb;\n\n\tif (bits < 0 || bits > 32)\n\t{\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif (bits == 0)\n\t{\n\t\tif (size < sizeof \"0\")\n\t\t\tgoto emsgsize;\n\t\t*dst++ = '0';\n\t\tsize--;\n\t\t*dst = '\\0';\n\t}\n\n\t/* Format whole octets. */\n\tfor (b = bits / 8; b > 0; b--)\n\t{\n\t\tif (size <= sizeof \"255.\")\n\t\t\tgoto emsgsize;\n\t\tt = dst;\n\t\tdst += SPRINTF((dst, \"%u\", *src++));\n\t\tif (b > 1)\n\t\t{\n\t\t\t*dst++ = '.';\n\t\t\t*dst = '\\0';\n\t\t}\n\t\tsize -= (size_t) (dst - t);\n\t}\n\n\t/* Format partial octet. */\n\tb = bits % 8;\n\tif (b > 0)\n\t{\n\t\tif (size <= sizeof \".255\")\n\t\t\tgoto emsgsize;\n\t\tt = dst;\n\t\tif (dst != odst)\n\t\t\t*dst++ = '.';\n\t\tm = ((1 << b) - 1) << (8 - b);\n\t\tdst += SPRINTF((dst, \"%u\", *src & m));\n\t\tsize -= (size_t) (dst - t);\n\t}\n\n\t/* Format CIDR /width. */\n\tif (size <= sizeof \"/32\")\n\t\tgoto emsgsize;\n\tdst += SPRINTF((dst, \"/%u\", bits));\n\treturn odst;\n\nemsgsize:\n\terrno = EMSGSIZE;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/inet.h\"\n#include \"utils/builtins.h\"\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include \"postgres.h\"\n\nstatic char *inet_cidr_ntop_ipv4(const u_char *src, int bits,\n\t\t\t\t\tchar *dst, size_t size);\nstatic char *inet_cidr_ntop_ipv6(const u_char *src, int bits,\n\t\t\t\t\tchar *dst, size_t size);\n\nchar *\ninet_cidr_ntop(int af, const void *src, int bits, char *dst, size_t size)\n{\n\tswitch (af)\n\t{\n\t\tcase PGSQL_AF_INET:\n\t\t\treturn inet_cidr_ntop_ipv4(src, bits, dst, size);\n\t\tcase PGSQL_AF_INET6:\n\t\t\treturn inet_cidr_ntop_ipv6(src, bits, dst, size);\n\t\tdefault:\n\t\t\terrno = EAFNOSUPPORT;\n\t\t\treturn NULL;\n\t}\n}"
  }
]