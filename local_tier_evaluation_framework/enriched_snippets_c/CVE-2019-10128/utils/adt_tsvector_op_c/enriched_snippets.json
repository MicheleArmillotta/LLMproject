[
  {
    "function_name": "tsvector_update_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "2453-2593",
    "snippet": "static Datum\ntsvector_update_trigger(PG_FUNCTION_ARGS, bool config_column)\n{\n\tTriggerData *trigdata;\n\tTrigger    *trigger;\n\tRelation\trel;\n\tHeapTuple\trettuple = NULL;\n\tint\t\t\ttsvector_attr_num,\n\t\t\t\ti;\n\tParsedText\tprs;\n\tDatum\t\tdatum;\n\tbool\t\tisnull;\n\ttext\t   *txt;\n\tOid\t\t\tcfgId;\n\n\t/* Check call context */\n\tif (!CALLED_AS_TRIGGER(fcinfo)) /* internal error */\n\t\telog(ERROR, \"tsvector_update_trigger: not fired by trigger manager\");\n\n\ttrigdata = (TriggerData *) fcinfo->context;\n\tif (!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\telog(ERROR, \"tsvector_update_trigger: must be fired for row\");\n\tif (!TRIGGER_FIRED_BEFORE(trigdata->tg_event))\n\t\telog(ERROR, \"tsvector_update_trigger: must be fired BEFORE event\");\n\n\tif (TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\trettuple = trigdata->tg_trigtuple;\n\telse if (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\trettuple = trigdata->tg_newtuple;\n\telse\n\t\telog(ERROR, \"tsvector_update_trigger: must be fired for INSERT or UPDATE\");\n\n\ttrigger = trigdata->tg_trigger;\n\trel = trigdata->tg_relation;\n\n\tif (trigger->tgnargs < 3)\n\t\telog(ERROR, \"tsvector_update_trigger: arguments must be tsvector_field, ts_config, text_field1, ...)\");\n\n\t/* Find the target tsvector column */\n\ttsvector_attr_num = SPI_fnumber(rel->rd_att, trigger->tgargs[0]);\n\tif (tsvector_attr_num == SPI_ERROR_NOATTRIBUTE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t errmsg(\"tsvector column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\ttrigger->tgargs[0])));\n\t/* This will effectively reject system columns, so no separate test: */\n\tif (!IsBinaryCoercible(SPI_gettypeid(rel->rd_att, tsvector_attr_num),\n\t\t\t\t\t\t   TSVECTOROID))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"column \\\"%s\\\" is not of tsvector type\",\n\t\t\t\t\t\ttrigger->tgargs[0])));\n\n\t/* Find the configuration to use */\n\tif (config_column)\n\t{\n\t\tint\t\t\tconfig_attr_num;\n\n\t\tconfig_attr_num = SPI_fnumber(rel->rd_att, trigger->tgargs[1]);\n\t\tif (config_attr_num == SPI_ERROR_NOATTRIBUTE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t\t errmsg(\"configuration column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\t\tif (!IsBinaryCoercible(SPI_gettypeid(rel->rd_att, config_attr_num),\n\t\t\t\t\t\t\t   REGCONFIGOID))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" is not of regconfig type\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\n\t\tdatum = SPI_getbinval(rettuple, rel->rd_att, config_attr_num, &isnull);\n\t\tif (isnull)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"configuration column \\\"%s\\\" must not be null\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\t\tcfgId = DatumGetObjectId(datum);\n\t}\n\telse\n\t{\n\t\tList\t   *names;\n\n\t\tnames = stringToQualifiedNameList(trigger->tgargs[1]);\n\t\t/* require a schema so that results are not search path dependent */\n\t\tif (list_length(names) < 2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"text search configuration name \\\"%s\\\" must be schema-qualified\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\t\tcfgId = get_ts_config_oid(names, false);\n\t}\n\n\t/* initialize parse state */\n\tprs.lenwords = 32;\n\tprs.curwords = 0;\n\tprs.pos = 0;\n\tprs.words = (ParsedWord *) palloc(sizeof(ParsedWord) * prs.lenwords);\n\n\t/* find all words in indexable column(s) */\n\tfor (i = 2; i < trigger->tgnargs; i++)\n\t{\n\t\tint\t\t\tnumattr;\n\n\t\tnumattr = SPI_fnumber(rel->rd_att, trigger->tgargs[i]);\n\t\tif (numattr == SPI_ERROR_NOATTRIBUTE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\ttrigger->tgargs[i])));\n\t\tif (!IsBinaryCoercible(SPI_gettypeid(rel->rd_att, numattr), TEXTOID))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" is not of a character type\",\n\t\t\t\t\t\t\ttrigger->tgargs[i])));\n\n\t\tdatum = SPI_getbinval(rettuple, rel->rd_att, numattr, &isnull);\n\t\tif (isnull)\n\t\t\tcontinue;\n\n\t\ttxt = DatumGetTextPP(datum);\n\n\t\tparsetext(cfgId, &prs, VARDATA_ANY(txt), VARSIZE_ANY_EXHDR(txt));\n\n\t\tif (txt != (text *) DatumGetPointer(datum))\n\t\t\tpfree(txt);\n\t}\n\n\t/* make tsvector value */\n\tdatum = TSVectorGetDatum(make_tsvector(&prs));\n\tisnull = false;\n\n\t/* and insert it into tuple */\n\trettuple = heap_modify_tuple_by_cols(rettuple, rel->rd_att,\n\t\t\t\t\t\t\t\t\t\t 1, &tsvector_attr_num,\n\t\t\t\t\t\t\t\t\t\t &datum, &isnull);\n\n\tpfree(DatumGetPointer(datum));\n\n\treturn PointerGetDatum(rettuple);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static Datum tsvector_update_trigger(PG_FUNCTION_ARGS, bool config_column);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "rettuple"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "DatumGetPointer(datum)"
          ],
          "line": 2590
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "datum"
          ],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_modify_tuple_by_cols",
          "args": [
            "rettuple",
            "rel->rd_att",
            "1",
            "&tsvector_attr_num",
            "&datum",
            "&isnull"
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSVectorGetDatum",
          "args": [
            "make_tsvector(&prs)"
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_tsvector",
          "args": [
            "&prs"
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "datum"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parsetext",
          "args": [
            "cfgId",
            "&prs",
            "VARDATA_ANY(txt)",
            "VARSIZE_ANY_EXHDR(txt)"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "txt"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "txt"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTextPP",
          "args": [
            "datum"
          ],
          "line": 2573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_getbinval",
          "args": [
            "rettuple",
            "rel->rd_att",
            "numattr",
            "&isnull"
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" is not of a character type\",\n\t\t\t\t\t\t\ttrigger->tgargs[i]))"
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"column \\\"%s\\\" is not of a character type\"",
            "trigger->tgargs[i]"
          ],
          "line": 2566
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_DATATYPE_MISMATCH"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBinaryCoercible",
          "args": [
            "SPI_gettypeid(rel->rd_att, numattr)",
            "TEXTOID"
          ],
          "line": 2563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_gettypeid",
          "args": [
            "rel->rd_att",
            "numattr"
          ],
          "line": 2563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\ttrigger->tgargs[i]))"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_fnumber",
          "args": [
            "rel->rd_att",
            "trigger->tgargs[i]"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(ParsedWord) * prs.lenwords"
          ],
          "line": 2550
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ts_config_oid",
          "args": [
            "names",
            "false"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"text search configuration name \\\"%s\\\" must be schema-qualified\",\n\t\t\t\t\t\t\ttrigger->tgargs[1]))"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_length",
          "args": [
            "names"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stringToQualifiedNameList",
          "args": [
            "trigger->tgargs[1]"
          ],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "stringToQualifiedNameList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/regproc.c",
          "lines": "1686-1718",
          "snippet": "List *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/varlena.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/acl.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"parser/parse_type.h\"",
            "#include \"miscadmin.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_ts_dict.h\"",
            "#include \"catalog/pg_ts_config.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/varlena.h\"\n#include \"utils/regproc.h\"\n#include \"utils/acl.h\"\n#include \"utils/syscache.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"parser/scansup.h\"\n#include \"parser/parse_type.h\"\n#include \"miscadmin.h\"\n#include \"lib/stringinfo.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_ts_dict.h\"\n#include \"catalog/pg_ts_config.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <ctype.h>\n#include \"postgres.h\"\n\nList *\nstringToQualifiedNameList(const char *string)\n{\n\tchar\t   *rawname;\n\tList\t   *result = NIL;\n\tList\t   *namelist;\n\tListCell   *l;\n\n\t/* We need a modifiable copy of the input string. */\n\trawname = pstrdup(string);\n\n\tif (!SplitIdentifierString(rawname, '.', &namelist))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tif (namelist == NIL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid name syntax\")));\n\n\tforeach(l, namelist)\n\t{\n\t\tchar\t   *curname = (char *) lfirst(l);\n\n\t\tresult = lappend(result, makeString(pstrdup(curname)));\n\t}\n\n\tpfree(rawname);\n\tlist_free(namelist);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetObjectId",
          "args": [
            "datum"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"configuration column \\\"%s\\\" must not be null\",\n\t\t\t\t\t\t\ttrigger->tgargs[1]))"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_getbinval",
          "args": [
            "rettuple",
            "rel->rd_att",
            "config_attr_num",
            "&isnull"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" is not of regconfig type\",\n\t\t\t\t\t\t\ttrigger->tgargs[1]))"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsBinaryCoercible",
          "args": [
            "SPI_gettypeid(rel->rd_att, config_attr_num)",
            "REGCONFIGOID"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_gettypeid",
          "args": [
            "rel->rd_att",
            "config_attr_num"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t\t errmsg(\"configuration column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\ttrigger->tgargs[1]))"
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_fnumber",
          "args": [
            "rel->rd_att",
            "trigger->tgargs[1]"
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"column \\\"%s\\\" is not of tsvector type\",\n\t\t\t\t\t\ttrigger->tgargs[0]))"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsBinaryCoercible",
          "args": [
            "SPI_gettypeid(rel->rd_att, tsvector_attr_num)",
            "TSVECTOROID"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_gettypeid",
          "args": [
            "rel->rd_att",
            "tsvector_attr_num"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t errmsg(\"tsvector column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\ttrigger->tgargs[0]))"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_fnumber",
          "args": [
            "rel->rd_att",
            "trigger->tgargs[0]"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"tsvector_update_trigger: arguments must be tsvector_field, ts_config, text_field1, ...)\""
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRIGGER_FIRED_BY_UPDATE",
          "args": [
            "trigdata->tg_event"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRIGGER_FIRED_BY_INSERT",
          "args": [
            "trigdata->tg_event"
          ],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRIGGER_FIRED_BEFORE",
          "args": [
            "trigdata->tg_event"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRIGGER_FIRED_FOR_ROW",
          "args": [
            "trigdata->tg_event"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CALLED_AS_TRIGGER",
          "args": [
            "fcinfo"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum tsvector_update_trigger(PG_FUNCTION_ARGS, bool config_column);\n\nstatic Datum\ntsvector_update_trigger(PG_FUNCTION_ARGS, bool config_column)\n{\n\tTriggerData *trigdata;\n\tTrigger    *trigger;\n\tRelation\trel;\n\tHeapTuple\trettuple = NULL;\n\tint\t\t\ttsvector_attr_num,\n\t\t\t\ti;\n\tParsedText\tprs;\n\tDatum\t\tdatum;\n\tbool\t\tisnull;\n\ttext\t   *txt;\n\tOid\t\t\tcfgId;\n\n\t/* Check call context */\n\tif (!CALLED_AS_TRIGGER(fcinfo)) /* internal error */\n\t\telog(ERROR, \"tsvector_update_trigger: not fired by trigger manager\");\n\n\ttrigdata = (TriggerData *) fcinfo->context;\n\tif (!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\telog(ERROR, \"tsvector_update_trigger: must be fired for row\");\n\tif (!TRIGGER_FIRED_BEFORE(trigdata->tg_event))\n\t\telog(ERROR, \"tsvector_update_trigger: must be fired BEFORE event\");\n\n\tif (TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\trettuple = trigdata->tg_trigtuple;\n\telse if (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\trettuple = trigdata->tg_newtuple;\n\telse\n\t\telog(ERROR, \"tsvector_update_trigger: must be fired for INSERT or UPDATE\");\n\n\ttrigger = trigdata->tg_trigger;\n\trel = trigdata->tg_relation;\n\n\tif (trigger->tgnargs < 3)\n\t\telog(ERROR, \"tsvector_update_trigger: arguments must be tsvector_field, ts_config, text_field1, ...)\");\n\n\t/* Find the target tsvector column */\n\ttsvector_attr_num = SPI_fnumber(rel->rd_att, trigger->tgargs[0]);\n\tif (tsvector_attr_num == SPI_ERROR_NOATTRIBUTE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t errmsg(\"tsvector column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\ttrigger->tgargs[0])));\n\t/* This will effectively reject system columns, so no separate test: */\n\tif (!IsBinaryCoercible(SPI_gettypeid(rel->rd_att, tsvector_attr_num),\n\t\t\t\t\t\t   TSVECTOROID))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"column \\\"%s\\\" is not of tsvector type\",\n\t\t\t\t\t\ttrigger->tgargs[0])));\n\n\t/* Find the configuration to use */\n\tif (config_column)\n\t{\n\t\tint\t\t\tconfig_attr_num;\n\n\t\tconfig_attr_num = SPI_fnumber(rel->rd_att, trigger->tgargs[1]);\n\t\tif (config_attr_num == SPI_ERROR_NOATTRIBUTE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t\t errmsg(\"configuration column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\t\tif (!IsBinaryCoercible(SPI_gettypeid(rel->rd_att, config_attr_num),\n\t\t\t\t\t\t\t   REGCONFIGOID))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" is not of regconfig type\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\n\t\tdatum = SPI_getbinval(rettuple, rel->rd_att, config_attr_num, &isnull);\n\t\tif (isnull)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"configuration column \\\"%s\\\" must not be null\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\t\tcfgId = DatumGetObjectId(datum);\n\t}\n\telse\n\t{\n\t\tList\t   *names;\n\n\t\tnames = stringToQualifiedNameList(trigger->tgargs[1]);\n\t\t/* require a schema so that results are not search path dependent */\n\t\tif (list_length(names) < 2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"text search configuration name \\\"%s\\\" must be schema-qualified\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\t\tcfgId = get_ts_config_oid(names, false);\n\t}\n\n\t/* initialize parse state */\n\tprs.lenwords = 32;\n\tprs.curwords = 0;\n\tprs.pos = 0;\n\tprs.words = (ParsedWord *) palloc(sizeof(ParsedWord) * prs.lenwords);\n\n\t/* find all words in indexable column(s) */\n\tfor (i = 2; i < trigger->tgnargs; i++)\n\t{\n\t\tint\t\t\tnumattr;\n\n\t\tnumattr = SPI_fnumber(rel->rd_att, trigger->tgargs[i]);\n\t\tif (numattr == SPI_ERROR_NOATTRIBUTE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\ttrigger->tgargs[i])));\n\t\tif (!IsBinaryCoercible(SPI_gettypeid(rel->rd_att, numattr), TEXTOID))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" is not of a character type\",\n\t\t\t\t\t\t\ttrigger->tgargs[i])));\n\n\t\tdatum = SPI_getbinval(rettuple, rel->rd_att, numattr, &isnull);\n\t\tif (isnull)\n\t\t\tcontinue;\n\n\t\ttxt = DatumGetTextPP(datum);\n\n\t\tparsetext(cfgId, &prs, VARDATA_ANY(txt), VARSIZE_ANY_EXHDR(txt));\n\n\t\tif (txt != (text *) DatumGetPointer(datum))\n\t\t\tpfree(txt);\n\t}\n\n\t/* make tsvector value */\n\tdatum = TSVectorGetDatum(make_tsvector(&prs));\n\tisnull = false;\n\n\t/* and insert it into tuple */\n\trettuple = heap_modify_tuple_by_cols(rettuple, rel->rd_att,\n\t\t\t\t\t\t\t\t\t\t 1, &tsvector_attr_num,\n\t\t\t\t\t\t\t\t\t\t &datum, &isnull);\n\n\tpfree(DatumGetPointer(datum));\n\n\treturn PointerGetDatum(rettuple);\n}"
  },
  {
    "function_name": "tsvector_update_trigger_bycolumn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "2447-2451",
    "snippet": "Datum\ntsvector_update_trigger_bycolumn(PG_FUNCTION_ARGS)\n{\n\treturn tsvector_update_trigger(fcinfo, true);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tsvector_update_trigger",
          "args": [
            "fcinfo",
            "true"
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "tsvector_update_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "2453-2593",
          "snippet": "static Datum\ntsvector_update_trigger(PG_FUNCTION_ARGS, bool config_column)\n{\n\tTriggerData *trigdata;\n\tTrigger    *trigger;\n\tRelation\trel;\n\tHeapTuple\trettuple = NULL;\n\tint\t\t\ttsvector_attr_num,\n\t\t\t\ti;\n\tParsedText\tprs;\n\tDatum\t\tdatum;\n\tbool\t\tisnull;\n\ttext\t   *txt;\n\tOid\t\t\tcfgId;\n\n\t/* Check call context */\n\tif (!CALLED_AS_TRIGGER(fcinfo)) /* internal error */\n\t\telog(ERROR, \"tsvector_update_trigger: not fired by trigger manager\");\n\n\ttrigdata = (TriggerData *) fcinfo->context;\n\tif (!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\telog(ERROR, \"tsvector_update_trigger: must be fired for row\");\n\tif (!TRIGGER_FIRED_BEFORE(trigdata->tg_event))\n\t\telog(ERROR, \"tsvector_update_trigger: must be fired BEFORE event\");\n\n\tif (TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\trettuple = trigdata->tg_trigtuple;\n\telse if (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\trettuple = trigdata->tg_newtuple;\n\telse\n\t\telog(ERROR, \"tsvector_update_trigger: must be fired for INSERT or UPDATE\");\n\n\ttrigger = trigdata->tg_trigger;\n\trel = trigdata->tg_relation;\n\n\tif (trigger->tgnargs < 3)\n\t\telog(ERROR, \"tsvector_update_trigger: arguments must be tsvector_field, ts_config, text_field1, ...)\");\n\n\t/* Find the target tsvector column */\n\ttsvector_attr_num = SPI_fnumber(rel->rd_att, trigger->tgargs[0]);\n\tif (tsvector_attr_num == SPI_ERROR_NOATTRIBUTE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t errmsg(\"tsvector column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\ttrigger->tgargs[0])));\n\t/* This will effectively reject system columns, so no separate test: */\n\tif (!IsBinaryCoercible(SPI_gettypeid(rel->rd_att, tsvector_attr_num),\n\t\t\t\t\t\t   TSVECTOROID))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"column \\\"%s\\\" is not of tsvector type\",\n\t\t\t\t\t\ttrigger->tgargs[0])));\n\n\t/* Find the configuration to use */\n\tif (config_column)\n\t{\n\t\tint\t\t\tconfig_attr_num;\n\n\t\tconfig_attr_num = SPI_fnumber(rel->rd_att, trigger->tgargs[1]);\n\t\tif (config_attr_num == SPI_ERROR_NOATTRIBUTE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t\t errmsg(\"configuration column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\t\tif (!IsBinaryCoercible(SPI_gettypeid(rel->rd_att, config_attr_num),\n\t\t\t\t\t\t\t   REGCONFIGOID))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" is not of regconfig type\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\n\t\tdatum = SPI_getbinval(rettuple, rel->rd_att, config_attr_num, &isnull);\n\t\tif (isnull)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"configuration column \\\"%s\\\" must not be null\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\t\tcfgId = DatumGetObjectId(datum);\n\t}\n\telse\n\t{\n\t\tList\t   *names;\n\n\t\tnames = stringToQualifiedNameList(trigger->tgargs[1]);\n\t\t/* require a schema so that results are not search path dependent */\n\t\tif (list_length(names) < 2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"text search configuration name \\\"%s\\\" must be schema-qualified\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\t\tcfgId = get_ts_config_oid(names, false);\n\t}\n\n\t/* initialize parse state */\n\tprs.lenwords = 32;\n\tprs.curwords = 0;\n\tprs.pos = 0;\n\tprs.words = (ParsedWord *) palloc(sizeof(ParsedWord) * prs.lenwords);\n\n\t/* find all words in indexable column(s) */\n\tfor (i = 2; i < trigger->tgnargs; i++)\n\t{\n\t\tint\t\t\tnumattr;\n\n\t\tnumattr = SPI_fnumber(rel->rd_att, trigger->tgargs[i]);\n\t\tif (numattr == SPI_ERROR_NOATTRIBUTE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\ttrigger->tgargs[i])));\n\t\tif (!IsBinaryCoercible(SPI_gettypeid(rel->rd_att, numattr), TEXTOID))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" is not of a character type\",\n\t\t\t\t\t\t\ttrigger->tgargs[i])));\n\n\t\tdatum = SPI_getbinval(rettuple, rel->rd_att, numattr, &isnull);\n\t\tif (isnull)\n\t\t\tcontinue;\n\n\t\ttxt = DatumGetTextPP(datum);\n\n\t\tparsetext(cfgId, &prs, VARDATA_ANY(txt), VARSIZE_ANY_EXHDR(txt));\n\n\t\tif (txt != (text *) DatumGetPointer(datum))\n\t\t\tpfree(txt);\n\t}\n\n\t/* make tsvector value */\n\tdatum = TSVectorGetDatum(make_tsvector(&prs));\n\tisnull = false;\n\n\t/* and insert it into tuple */\n\trettuple = heap_modify_tuple_by_cols(rettuple, rel->rd_att,\n\t\t\t\t\t\t\t\t\t\t 1, &tsvector_attr_num,\n\t\t\t\t\t\t\t\t\t\t &datum, &isnull);\n\n\tpfree(DatumGetPointer(datum));\n\n\treturn PointerGetDatum(rettuple);\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum tsvector_update_trigger(PG_FUNCTION_ARGS, bool config_column);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum tsvector_update_trigger(PG_FUNCTION_ARGS, bool config_column);\n\nstatic Datum\ntsvector_update_trigger(PG_FUNCTION_ARGS, bool config_column)\n{\n\tTriggerData *trigdata;\n\tTrigger    *trigger;\n\tRelation\trel;\n\tHeapTuple\trettuple = NULL;\n\tint\t\t\ttsvector_attr_num,\n\t\t\t\ti;\n\tParsedText\tprs;\n\tDatum\t\tdatum;\n\tbool\t\tisnull;\n\ttext\t   *txt;\n\tOid\t\t\tcfgId;\n\n\t/* Check call context */\n\tif (!CALLED_AS_TRIGGER(fcinfo)) /* internal error */\n\t\telog(ERROR, \"tsvector_update_trigger: not fired by trigger manager\");\n\n\ttrigdata = (TriggerData *) fcinfo->context;\n\tif (!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\telog(ERROR, \"tsvector_update_trigger: must be fired for row\");\n\tif (!TRIGGER_FIRED_BEFORE(trigdata->tg_event))\n\t\telog(ERROR, \"tsvector_update_trigger: must be fired BEFORE event\");\n\n\tif (TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\trettuple = trigdata->tg_trigtuple;\n\telse if (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\trettuple = trigdata->tg_newtuple;\n\telse\n\t\telog(ERROR, \"tsvector_update_trigger: must be fired for INSERT or UPDATE\");\n\n\ttrigger = trigdata->tg_trigger;\n\trel = trigdata->tg_relation;\n\n\tif (trigger->tgnargs < 3)\n\t\telog(ERROR, \"tsvector_update_trigger: arguments must be tsvector_field, ts_config, text_field1, ...)\");\n\n\t/* Find the target tsvector column */\n\ttsvector_attr_num = SPI_fnumber(rel->rd_att, trigger->tgargs[0]);\n\tif (tsvector_attr_num == SPI_ERROR_NOATTRIBUTE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t errmsg(\"tsvector column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\ttrigger->tgargs[0])));\n\t/* This will effectively reject system columns, so no separate test: */\n\tif (!IsBinaryCoercible(SPI_gettypeid(rel->rd_att, tsvector_attr_num),\n\t\t\t\t\t\t   TSVECTOROID))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"column \\\"%s\\\" is not of tsvector type\",\n\t\t\t\t\t\ttrigger->tgargs[0])));\n\n\t/* Find the configuration to use */\n\tif (config_column)\n\t{\n\t\tint\t\t\tconfig_attr_num;\n\n\t\tconfig_attr_num = SPI_fnumber(rel->rd_att, trigger->tgargs[1]);\n\t\tif (config_attr_num == SPI_ERROR_NOATTRIBUTE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t\t errmsg(\"configuration column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\t\tif (!IsBinaryCoercible(SPI_gettypeid(rel->rd_att, config_attr_num),\n\t\t\t\t\t\t\t   REGCONFIGOID))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" is not of regconfig type\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\n\t\tdatum = SPI_getbinval(rettuple, rel->rd_att, config_attr_num, &isnull);\n\t\tif (isnull)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"configuration column \\\"%s\\\" must not be null\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\t\tcfgId = DatumGetObjectId(datum);\n\t}\n\telse\n\t{\n\t\tList\t   *names;\n\n\t\tnames = stringToQualifiedNameList(trigger->tgargs[1]);\n\t\t/* require a schema so that results are not search path dependent */\n\t\tif (list_length(names) < 2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"text search configuration name \\\"%s\\\" must be schema-qualified\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\t\tcfgId = get_ts_config_oid(names, false);\n\t}\n\n\t/* initialize parse state */\n\tprs.lenwords = 32;\n\tprs.curwords = 0;\n\tprs.pos = 0;\n\tprs.words = (ParsedWord *) palloc(sizeof(ParsedWord) * prs.lenwords);\n\n\t/* find all words in indexable column(s) */\n\tfor (i = 2; i < trigger->tgnargs; i++)\n\t{\n\t\tint\t\t\tnumattr;\n\n\t\tnumattr = SPI_fnumber(rel->rd_att, trigger->tgargs[i]);\n\t\tif (numattr == SPI_ERROR_NOATTRIBUTE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\ttrigger->tgargs[i])));\n\t\tif (!IsBinaryCoercible(SPI_gettypeid(rel->rd_att, numattr), TEXTOID))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" is not of a character type\",\n\t\t\t\t\t\t\ttrigger->tgargs[i])));\n\n\t\tdatum = SPI_getbinval(rettuple, rel->rd_att, numattr, &isnull);\n\t\tif (isnull)\n\t\t\tcontinue;\n\n\t\ttxt = DatumGetTextPP(datum);\n\n\t\tparsetext(cfgId, &prs, VARDATA_ANY(txt), VARSIZE_ANY_EXHDR(txt));\n\n\t\tif (txt != (text *) DatumGetPointer(datum))\n\t\t\tpfree(txt);\n\t}\n\n\t/* make tsvector value */\n\tdatum = TSVectorGetDatum(make_tsvector(&prs));\n\tisnull = false;\n\n\t/* and insert it into tuple */\n\trettuple = heap_modify_tuple_by_cols(rettuple, rel->rd_att,\n\t\t\t\t\t\t\t\t\t\t 1, &tsvector_attr_num,\n\t\t\t\t\t\t\t\t\t\t &datum, &isnull);\n\n\tpfree(DatumGetPointer(datum));\n\n\treturn PointerGetDatum(rettuple);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ntsvector_update_trigger_bycolumn(PG_FUNCTION_ARGS)\n{\n\treturn tsvector_update_trigger(fcinfo, true);\n}"
  },
  {
    "function_name": "tsvector_update_trigger_byid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "2441-2445",
    "snippet": "Datum\ntsvector_update_trigger_byid(PG_FUNCTION_ARGS)\n{\n\treturn tsvector_update_trigger(fcinfo, false);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tsvector_update_trigger",
          "args": [
            "fcinfo",
            "false"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "tsvector_update_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "2453-2593",
          "snippet": "static Datum\ntsvector_update_trigger(PG_FUNCTION_ARGS, bool config_column)\n{\n\tTriggerData *trigdata;\n\tTrigger    *trigger;\n\tRelation\trel;\n\tHeapTuple\trettuple = NULL;\n\tint\t\t\ttsvector_attr_num,\n\t\t\t\ti;\n\tParsedText\tprs;\n\tDatum\t\tdatum;\n\tbool\t\tisnull;\n\ttext\t   *txt;\n\tOid\t\t\tcfgId;\n\n\t/* Check call context */\n\tif (!CALLED_AS_TRIGGER(fcinfo)) /* internal error */\n\t\telog(ERROR, \"tsvector_update_trigger: not fired by trigger manager\");\n\n\ttrigdata = (TriggerData *) fcinfo->context;\n\tif (!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\telog(ERROR, \"tsvector_update_trigger: must be fired for row\");\n\tif (!TRIGGER_FIRED_BEFORE(trigdata->tg_event))\n\t\telog(ERROR, \"tsvector_update_trigger: must be fired BEFORE event\");\n\n\tif (TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\trettuple = trigdata->tg_trigtuple;\n\telse if (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\trettuple = trigdata->tg_newtuple;\n\telse\n\t\telog(ERROR, \"tsvector_update_trigger: must be fired for INSERT or UPDATE\");\n\n\ttrigger = trigdata->tg_trigger;\n\trel = trigdata->tg_relation;\n\n\tif (trigger->tgnargs < 3)\n\t\telog(ERROR, \"tsvector_update_trigger: arguments must be tsvector_field, ts_config, text_field1, ...)\");\n\n\t/* Find the target tsvector column */\n\ttsvector_attr_num = SPI_fnumber(rel->rd_att, trigger->tgargs[0]);\n\tif (tsvector_attr_num == SPI_ERROR_NOATTRIBUTE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t errmsg(\"tsvector column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\ttrigger->tgargs[0])));\n\t/* This will effectively reject system columns, so no separate test: */\n\tif (!IsBinaryCoercible(SPI_gettypeid(rel->rd_att, tsvector_attr_num),\n\t\t\t\t\t\t   TSVECTOROID))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"column \\\"%s\\\" is not of tsvector type\",\n\t\t\t\t\t\ttrigger->tgargs[0])));\n\n\t/* Find the configuration to use */\n\tif (config_column)\n\t{\n\t\tint\t\t\tconfig_attr_num;\n\n\t\tconfig_attr_num = SPI_fnumber(rel->rd_att, trigger->tgargs[1]);\n\t\tif (config_attr_num == SPI_ERROR_NOATTRIBUTE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t\t errmsg(\"configuration column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\t\tif (!IsBinaryCoercible(SPI_gettypeid(rel->rd_att, config_attr_num),\n\t\t\t\t\t\t\t   REGCONFIGOID))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" is not of regconfig type\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\n\t\tdatum = SPI_getbinval(rettuple, rel->rd_att, config_attr_num, &isnull);\n\t\tif (isnull)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"configuration column \\\"%s\\\" must not be null\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\t\tcfgId = DatumGetObjectId(datum);\n\t}\n\telse\n\t{\n\t\tList\t   *names;\n\n\t\tnames = stringToQualifiedNameList(trigger->tgargs[1]);\n\t\t/* require a schema so that results are not search path dependent */\n\t\tif (list_length(names) < 2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"text search configuration name \\\"%s\\\" must be schema-qualified\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\t\tcfgId = get_ts_config_oid(names, false);\n\t}\n\n\t/* initialize parse state */\n\tprs.lenwords = 32;\n\tprs.curwords = 0;\n\tprs.pos = 0;\n\tprs.words = (ParsedWord *) palloc(sizeof(ParsedWord) * prs.lenwords);\n\n\t/* find all words in indexable column(s) */\n\tfor (i = 2; i < trigger->tgnargs; i++)\n\t{\n\t\tint\t\t\tnumattr;\n\n\t\tnumattr = SPI_fnumber(rel->rd_att, trigger->tgargs[i]);\n\t\tif (numattr == SPI_ERROR_NOATTRIBUTE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\ttrigger->tgargs[i])));\n\t\tif (!IsBinaryCoercible(SPI_gettypeid(rel->rd_att, numattr), TEXTOID))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" is not of a character type\",\n\t\t\t\t\t\t\ttrigger->tgargs[i])));\n\n\t\tdatum = SPI_getbinval(rettuple, rel->rd_att, numattr, &isnull);\n\t\tif (isnull)\n\t\t\tcontinue;\n\n\t\ttxt = DatumGetTextPP(datum);\n\n\t\tparsetext(cfgId, &prs, VARDATA_ANY(txt), VARSIZE_ANY_EXHDR(txt));\n\n\t\tif (txt != (text *) DatumGetPointer(datum))\n\t\t\tpfree(txt);\n\t}\n\n\t/* make tsvector value */\n\tdatum = TSVectorGetDatum(make_tsvector(&prs));\n\tisnull = false;\n\n\t/* and insert it into tuple */\n\trettuple = heap_modify_tuple_by_cols(rettuple, rel->rd_att,\n\t\t\t\t\t\t\t\t\t\t 1, &tsvector_attr_num,\n\t\t\t\t\t\t\t\t\t\t &datum, &isnull);\n\n\tpfree(DatumGetPointer(datum));\n\n\treturn PointerGetDatum(rettuple);\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum tsvector_update_trigger(PG_FUNCTION_ARGS, bool config_column);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum tsvector_update_trigger(PG_FUNCTION_ARGS, bool config_column);\n\nstatic Datum\ntsvector_update_trigger(PG_FUNCTION_ARGS, bool config_column)\n{\n\tTriggerData *trigdata;\n\tTrigger    *trigger;\n\tRelation\trel;\n\tHeapTuple\trettuple = NULL;\n\tint\t\t\ttsvector_attr_num,\n\t\t\t\ti;\n\tParsedText\tprs;\n\tDatum\t\tdatum;\n\tbool\t\tisnull;\n\ttext\t   *txt;\n\tOid\t\t\tcfgId;\n\n\t/* Check call context */\n\tif (!CALLED_AS_TRIGGER(fcinfo)) /* internal error */\n\t\telog(ERROR, \"tsvector_update_trigger: not fired by trigger manager\");\n\n\ttrigdata = (TriggerData *) fcinfo->context;\n\tif (!TRIGGER_FIRED_FOR_ROW(trigdata->tg_event))\n\t\telog(ERROR, \"tsvector_update_trigger: must be fired for row\");\n\tif (!TRIGGER_FIRED_BEFORE(trigdata->tg_event))\n\t\telog(ERROR, \"tsvector_update_trigger: must be fired BEFORE event\");\n\n\tif (TRIGGER_FIRED_BY_INSERT(trigdata->tg_event))\n\t\trettuple = trigdata->tg_trigtuple;\n\telse if (TRIGGER_FIRED_BY_UPDATE(trigdata->tg_event))\n\t\trettuple = trigdata->tg_newtuple;\n\telse\n\t\telog(ERROR, \"tsvector_update_trigger: must be fired for INSERT or UPDATE\");\n\n\ttrigger = trigdata->tg_trigger;\n\trel = trigdata->tg_relation;\n\n\tif (trigger->tgnargs < 3)\n\t\telog(ERROR, \"tsvector_update_trigger: arguments must be tsvector_field, ts_config, text_field1, ...)\");\n\n\t/* Find the target tsvector column */\n\ttsvector_attr_num = SPI_fnumber(rel->rd_att, trigger->tgargs[0]);\n\tif (tsvector_attr_num == SPI_ERROR_NOATTRIBUTE)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t errmsg(\"tsvector column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\ttrigger->tgargs[0])));\n\t/* This will effectively reject system columns, so no separate test: */\n\tif (!IsBinaryCoercible(SPI_gettypeid(rel->rd_att, tsvector_attr_num),\n\t\t\t\t\t\t   TSVECTOROID))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t errmsg(\"column \\\"%s\\\" is not of tsvector type\",\n\t\t\t\t\t\ttrigger->tgargs[0])));\n\n\t/* Find the configuration to use */\n\tif (config_column)\n\t{\n\t\tint\t\t\tconfig_attr_num;\n\n\t\tconfig_attr_num = SPI_fnumber(rel->rd_att, trigger->tgargs[1]);\n\t\tif (config_attr_num == SPI_ERROR_NOATTRIBUTE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t\t errmsg(\"configuration column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\t\tif (!IsBinaryCoercible(SPI_gettypeid(rel->rd_att, config_attr_num),\n\t\t\t\t\t\t\t   REGCONFIGOID))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" is not of regconfig type\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\n\t\tdatum = SPI_getbinval(rettuple, rel->rd_att, config_attr_num, &isnull);\n\t\tif (isnull)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"configuration column \\\"%s\\\" must not be null\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\t\tcfgId = DatumGetObjectId(datum);\n\t}\n\telse\n\t{\n\t\tList\t   *names;\n\n\t\tnames = stringToQualifiedNameList(trigger->tgargs[1]);\n\t\t/* require a schema so that results are not search path dependent */\n\t\tif (list_length(names) < 2)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t errmsg(\"text search configuration name \\\"%s\\\" must be schema-qualified\",\n\t\t\t\t\t\t\ttrigger->tgargs[1])));\n\t\tcfgId = get_ts_config_oid(names, false);\n\t}\n\n\t/* initialize parse state */\n\tprs.lenwords = 32;\n\tprs.curwords = 0;\n\tprs.pos = 0;\n\tprs.words = (ParsedWord *) palloc(sizeof(ParsedWord) * prs.lenwords);\n\n\t/* find all words in indexable column(s) */\n\tfor (i = 2; i < trigger->tgnargs; i++)\n\t{\n\t\tint\t\t\tnumattr;\n\n\t\tnumattr = SPI_fnumber(rel->rd_att, trigger->tgargs[i]);\n\t\tif (numattr == SPI_ERROR_NOATTRIBUTE)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_UNDEFINED_COLUMN),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" does not exist\",\n\t\t\t\t\t\t\ttrigger->tgargs[i])));\n\t\tif (!IsBinaryCoercible(SPI_gettypeid(rel->rd_att, numattr), TEXTOID))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_DATATYPE_MISMATCH),\n\t\t\t\t\t errmsg(\"column \\\"%s\\\" is not of a character type\",\n\t\t\t\t\t\t\ttrigger->tgargs[i])));\n\n\t\tdatum = SPI_getbinval(rettuple, rel->rd_att, numattr, &isnull);\n\t\tif (isnull)\n\t\t\tcontinue;\n\n\t\ttxt = DatumGetTextPP(datum);\n\n\t\tparsetext(cfgId, &prs, VARDATA_ANY(txt), VARSIZE_ANY_EXHDR(txt));\n\n\t\tif (txt != (text *) DatumGetPointer(datum))\n\t\t\tpfree(txt);\n\t}\n\n\t/* make tsvector value */\n\tdatum = TSVectorGetDatum(make_tsvector(&prs));\n\tisnull = false;\n\n\t/* and insert it into tuple */\n\trettuple = heap_modify_tuple_by_cols(rettuple, rel->rd_att,\n\t\t\t\t\t\t\t\t\t\t 1, &tsvector_attr_num,\n\t\t\t\t\t\t\t\t\t\t &datum, &isnull);\n\n\tpfree(DatumGetPointer(datum));\n\n\treturn PointerGetDatum(rettuple);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ntsvector_update_trigger_byid(PG_FUNCTION_ARGS)\n{\n\treturn tsvector_update_trigger(fcinfo, false);\n}"
  },
  {
    "function_name": "ts_stat2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "2403-2428",
    "snippet": "Datum\nts_stat2(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tDatum\t\tresult;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTSVectorStat *stat;\n\t\ttext\t   *txt = PG_GETARG_TEXT_PP(0);\n\t\ttext\t   *ws = PG_GETARG_TEXT_PP(1);\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\tSPI_connect();\n\t\tstat = ts_stat_sql(funcctx->multi_call_memory_ctx, txt, ws);\n\t\tPG_FREE_IF_COPY(txt, 0);\n\t\tPG_FREE_IF_COPY(ws, 1);\n\t\tts_setup_firstcall(fcinfo, funcctx, stat);\n\t\tSPI_finish();\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tif ((result = ts_process_call(funcctx)) != (Datum) 0)\n\t\tSRF_RETURN_NEXT(funcctx, result);\n\tSRF_RETURN_DONE(funcctx);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "funcctx",
            "result"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ts_process_call",
          "args": [
            "funcctx"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "ts_process_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "2249-2287",
          "snippet": "static Datum\nts_process_call(FuncCallContext *funcctx)\n{\n\tTSVectorStat *st;\n\tStatEntry  *entry;\n\n\tst = (TSVectorStat *) funcctx->user_fctx;\n\n\tentry = walkStatEntryTree(st);\n\n\tif (entry != NULL)\n\t{\n\t\tDatum\t\tresult;\n\t\tchar\t   *values[3];\n\t\tchar\t\tndoc[16];\n\t\tchar\t\tnentry[16];\n\t\tHeapTuple\ttuple;\n\n\t\tvalues[0] = palloc(entry->lenlexeme + 1);\n\t\tmemcpy(values[0], entry->lexeme, entry->lenlexeme);\n\t\t(values[0])[entry->lenlexeme] = '\\0';\n\t\tsprintf(ndoc, \"%d\", entry->ndoc);\n\t\tvalues[1] = ndoc;\n\t\tsprintf(nentry, \"%d\", entry->nentry);\n\t\tvalues[2] = nentry;\n\n\t\ttuple = BuildTupleFromCStrings(funcctx->attinmeta, values);\n\t\tresult = HeapTupleGetDatum(tuple);\n\n\t\tpfree(values[0]);\n\n\t\t/* mark entry as already visited */\n\t\tentry->ndoc = 0;\n\n\t\treturn result;\n\t}\n\n\treturn (Datum) 0;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum\nts_process_call(FuncCallContext *funcctx)\n{\n\tTSVectorStat *st;\n\tStatEntry  *entry;\n\n\tst = (TSVectorStat *) funcctx->user_fctx;\n\n\tentry = walkStatEntryTree(st);\n\n\tif (entry != NULL)\n\t{\n\t\tDatum\t\tresult;\n\t\tchar\t   *values[3];\n\t\tchar\t\tndoc[16];\n\t\tchar\t\tnentry[16];\n\t\tHeapTuple\ttuple;\n\n\t\tvalues[0] = palloc(entry->lenlexeme + 1);\n\t\tmemcpy(values[0], entry->lexeme, entry->lenlexeme);\n\t\t(values[0])[entry->lenlexeme] = '\\0';\n\t\tsprintf(ndoc, \"%d\", entry->ndoc);\n\t\tvalues[1] = ndoc;\n\t\tsprintf(nentry, \"%d\", entry->nentry);\n\t\tvalues[2] = nentry;\n\n\t\ttuple = BuildTupleFromCStrings(funcctx->attinmeta, values);\n\t\tresult = HeapTupleGetDatum(tuple);\n\n\t\tpfree(values[0]);\n\n\t\t/* mark entry as already visited */\n\t\tentry->ndoc = 0;\n\n\t\treturn result;\n\t}\n\n\treturn (Datum) 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRF_PERCALL_SETUP",
          "args": [],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_finish",
          "args": [],
          "line": 2421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ts_setup_firstcall",
          "args": [
            "fcinfo",
            "funcctx",
            "stat"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "ts_setup_firstcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "2157-2201",
          "snippet": "static void\nts_setup_firstcall(FunctionCallInfo fcinfo, FuncCallContext *funcctx,\n\t\t\t\t   TSVectorStat *stat)\n{\n\tTupleDesc\ttupdesc;\n\tMemoryContext oldcontext;\n\tStatEntry  *node;\n\n\tfuncctx->user_fctx = (void *) stat;\n\n\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\tstat->stack = palloc0(sizeof(StatEntry *) * (stat->maxdepth + 1));\n\tstat->stackpos = 0;\n\n\tnode = stat->root;\n\t/* find leftmost value */\n\tif (node == NULL)\n\t\tstat->stack[stat->stackpos] = NULL;\n\telse\n\t\tfor (;;)\n\t\t{\n\t\t\tstat->stack[stat->stackpos] = node;\n\t\t\tif (node->left)\n\t\t\t{\n\t\t\t\tstat->stackpos++;\n\t\t\t\tnode = node->left;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\tAssert(stat->stackpos <= stat->maxdepth);\n\n\ttupdesc = CreateTemplateTupleDesc(3, false);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"word\",\n\t\t\t\t\t   TEXTOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"ndoc\",\n\t\t\t\t\t   INT4OID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"nentry\",\n\t\t\t\t\t   INT4OID, -1, 0);\n\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\tfuncctx->attinmeta = TupleDescGetAttInMetadata(tupdesc);\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nts_setup_firstcall(FunctionCallInfo fcinfo, FuncCallContext *funcctx,\n\t\t\t\t   TSVectorStat *stat)\n{\n\tTupleDesc\ttupdesc;\n\tMemoryContext oldcontext;\n\tStatEntry  *node;\n\n\tfuncctx->user_fctx = (void *) stat;\n\n\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\tstat->stack = palloc0(sizeof(StatEntry *) * (stat->maxdepth + 1));\n\tstat->stackpos = 0;\n\n\tnode = stat->root;\n\t/* find leftmost value */\n\tif (node == NULL)\n\t\tstat->stack[stat->stackpos] = NULL;\n\telse\n\t\tfor (;;)\n\t\t{\n\t\t\tstat->stack[stat->stackpos] = node;\n\t\t\tif (node->left)\n\t\t\t{\n\t\t\t\tstat->stackpos++;\n\t\t\t\tnode = node->left;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\tAssert(stat->stackpos <= stat->maxdepth);\n\n\ttupdesc = CreateTemplateTupleDesc(3, false);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"word\",\n\t\t\t\t\t   TEXTOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"ndoc\",\n\t\t\t\t\t   INT4OID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"nentry\",\n\t\t\t\t\t   INT4OID, -1, 0);\n\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\tfuncctx->attinmeta = TupleDescGetAttInMetadata(tupdesc);\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "ws",
            "1"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "txt",
            "0"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ts_stat_sql",
          "args": [
            "funcctx->multi_call_memory_ctx",
            "txt",
            "ws"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "ts_stat_sql",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "2289-2376",
          "snippet": "static TSVectorStat *\nts_stat_sql(MemoryContext persistentContext, text *txt, text *ws)\n{\n\tchar\t   *query = text_to_cstring(txt);\n\tTSVectorStat *stat;\n\tbool\t\tisnull;\n\tPortal\t\tportal;\n\tSPIPlanPtr\tplan;\n\n\tif ((plan = SPI_prepare(query, 0, NULL)) == NULL)\n\t\t/* internal error */\n\t\telog(ERROR, \"SPI_prepare(\\\"%s\\\") failed\", query);\n\n\tif ((portal = SPI_cursor_open(NULL, plan, NULL, NULL, true)) == NULL)\n\t\t/* internal error */\n\t\telog(ERROR, \"SPI_cursor_open(\\\"%s\\\") failed\", query);\n\n\tSPI_cursor_fetch(portal, true, 100);\n\n\tif (SPI_tuptable == NULL ||\n\t\tSPI_tuptable->tupdesc->natts != 1 ||\n\t\t!IsBinaryCoercible(SPI_gettypeid(SPI_tuptable->tupdesc, 1),\n\t\t\t\t\t\t   TSVECTOROID))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"ts_stat query must return one tsvector column\")));\n\n\tstat = MemoryContextAllocZero(persistentContext, sizeof(TSVectorStat));\n\tstat->maxdepth = 1;\n\n\tif (ws)\n\t{\n\t\tchar\t   *buf;\n\n\t\tbuf = VARDATA_ANY(ws);\n\t\twhile (buf - VARDATA_ANY(ws) < VARSIZE_ANY_EXHDR(ws))\n\t\t{\n\t\t\tif (pg_mblen(buf) == 1)\n\t\t\t{\n\t\t\t\tswitch (*buf)\n\t\t\t\t{\n\t\t\t\t\tcase 'A':\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tstat->weight |= 1 << 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'B':\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tstat->weight |= 1 << 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'C':\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tstat->weight |= 1 << 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'D':\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\tstat->weight |= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstat->weight |= 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuf += pg_mblen(buf);\n\t\t}\n\t}\n\n\twhile (SPI_processed > 0)\n\t{\n\t\tuint64\t\ti;\n\n\t\tfor (i = 0; i < SPI_processed; i++)\n\t\t{\n\t\t\tDatum\t\tdata = SPI_getbinval(SPI_tuptable->vals[i], SPI_tuptable->tupdesc, 1, &isnull);\n\n\t\t\tif (!isnull)\n\t\t\t\tstat = ts_accum(persistentContext, stat, data);\n\t\t}\n\n\t\tSPI_freetuptable(SPI_tuptable);\n\t\tSPI_cursor_fetch(portal, true, 100);\n\t}\n\n\tSPI_freetuptable(SPI_tuptable);\n\tSPI_cursor_close(portal);\n\tSPI_freeplan(plan);\n\tpfree(query);\n\n\treturn stat;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TSVectorStat *\nts_stat_sql(MemoryContext persistentContext, text *txt, text *ws)\n{\n\tchar\t   *query = text_to_cstring(txt);\n\tTSVectorStat *stat;\n\tbool\t\tisnull;\n\tPortal\t\tportal;\n\tSPIPlanPtr\tplan;\n\n\tif ((plan = SPI_prepare(query, 0, NULL)) == NULL)\n\t\t/* internal error */\n\t\telog(ERROR, \"SPI_prepare(\\\"%s\\\") failed\", query);\n\n\tif ((portal = SPI_cursor_open(NULL, plan, NULL, NULL, true)) == NULL)\n\t\t/* internal error */\n\t\telog(ERROR, \"SPI_cursor_open(\\\"%s\\\") failed\", query);\n\n\tSPI_cursor_fetch(portal, true, 100);\n\n\tif (SPI_tuptable == NULL ||\n\t\tSPI_tuptable->tupdesc->natts != 1 ||\n\t\t!IsBinaryCoercible(SPI_gettypeid(SPI_tuptable->tupdesc, 1),\n\t\t\t\t\t\t   TSVECTOROID))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"ts_stat query must return one tsvector column\")));\n\n\tstat = MemoryContextAllocZero(persistentContext, sizeof(TSVectorStat));\n\tstat->maxdepth = 1;\n\n\tif (ws)\n\t{\n\t\tchar\t   *buf;\n\n\t\tbuf = VARDATA_ANY(ws);\n\t\twhile (buf - VARDATA_ANY(ws) < VARSIZE_ANY_EXHDR(ws))\n\t\t{\n\t\t\tif (pg_mblen(buf) == 1)\n\t\t\t{\n\t\t\t\tswitch (*buf)\n\t\t\t\t{\n\t\t\t\t\tcase 'A':\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tstat->weight |= 1 << 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'B':\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tstat->weight |= 1 << 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'C':\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tstat->weight |= 1 << 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'D':\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\tstat->weight |= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstat->weight |= 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuf += pg_mblen(buf);\n\t\t}\n\t}\n\n\twhile (SPI_processed > 0)\n\t{\n\t\tuint64\t\ti;\n\n\t\tfor (i = 0; i < SPI_processed; i++)\n\t\t{\n\t\t\tDatum\t\tdata = SPI_getbinval(SPI_tuptable->vals[i], SPI_tuptable->tupdesc, 1, &isnull);\n\n\t\t\tif (!isnull)\n\t\t\t\tstat = ts_accum(persistentContext, stat, data);\n\t\t}\n\n\t\tSPI_freetuptable(SPI_tuptable);\n\t\tSPI_cursor_fetch(portal, true, 100);\n\t}\n\n\tSPI_freetuptable(SPI_tuptable);\n\tSPI_cursor_close(portal);\n\tSPI_freeplan(plan);\n\tpfree(query);\n\n\treturn stat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_connect",
          "args": [],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_FIRSTCALL_INIT",
          "args": [],
          "line": 2415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_IS_FIRSTCALL",
          "args": [],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\nts_stat2(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tDatum\t\tresult;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTSVectorStat *stat;\n\t\ttext\t   *txt = PG_GETARG_TEXT_PP(0);\n\t\ttext\t   *ws = PG_GETARG_TEXT_PP(1);\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\tSPI_connect();\n\t\tstat = ts_stat_sql(funcctx->multi_call_memory_ctx, txt, ws);\n\t\tPG_FREE_IF_COPY(txt, 0);\n\t\tPG_FREE_IF_COPY(ws, 1);\n\t\tts_setup_firstcall(fcinfo, funcctx, stat);\n\t\tSPI_finish();\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tif ((result = ts_process_call(funcctx)) != (Datum) 0)\n\t\tSRF_RETURN_NEXT(funcctx, result);\n\tSRF_RETURN_DONE(funcctx);\n}"
  },
  {
    "function_name": "ts_stat1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "2378-2401",
    "snippet": "Datum\nts_stat1(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tDatum\t\tresult;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTSVectorStat *stat;\n\t\ttext\t   *txt = PG_GETARG_TEXT_PP(0);\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\tSPI_connect();\n\t\tstat = ts_stat_sql(funcctx->multi_call_memory_ctx, txt, NULL);\n\t\tPG_FREE_IF_COPY(txt, 0);\n\t\tts_setup_firstcall(fcinfo, funcctx, stat);\n\t\tSPI_finish();\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tif ((result = ts_process_call(funcctx)) != (Datum) 0)\n\t\tSRF_RETURN_NEXT(funcctx, result);\n\tSRF_RETURN_DONE(funcctx);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "funcctx",
            "result"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ts_process_call",
          "args": [
            "funcctx"
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "ts_process_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "2249-2287",
          "snippet": "static Datum\nts_process_call(FuncCallContext *funcctx)\n{\n\tTSVectorStat *st;\n\tStatEntry  *entry;\n\n\tst = (TSVectorStat *) funcctx->user_fctx;\n\n\tentry = walkStatEntryTree(st);\n\n\tif (entry != NULL)\n\t{\n\t\tDatum\t\tresult;\n\t\tchar\t   *values[3];\n\t\tchar\t\tndoc[16];\n\t\tchar\t\tnentry[16];\n\t\tHeapTuple\ttuple;\n\n\t\tvalues[0] = palloc(entry->lenlexeme + 1);\n\t\tmemcpy(values[0], entry->lexeme, entry->lenlexeme);\n\t\t(values[0])[entry->lenlexeme] = '\\0';\n\t\tsprintf(ndoc, \"%d\", entry->ndoc);\n\t\tvalues[1] = ndoc;\n\t\tsprintf(nentry, \"%d\", entry->nentry);\n\t\tvalues[2] = nentry;\n\n\t\ttuple = BuildTupleFromCStrings(funcctx->attinmeta, values);\n\t\tresult = HeapTupleGetDatum(tuple);\n\n\t\tpfree(values[0]);\n\n\t\t/* mark entry as already visited */\n\t\tentry->ndoc = 0;\n\n\t\treturn result;\n\t}\n\n\treturn (Datum) 0;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum\nts_process_call(FuncCallContext *funcctx)\n{\n\tTSVectorStat *st;\n\tStatEntry  *entry;\n\n\tst = (TSVectorStat *) funcctx->user_fctx;\n\n\tentry = walkStatEntryTree(st);\n\n\tif (entry != NULL)\n\t{\n\t\tDatum\t\tresult;\n\t\tchar\t   *values[3];\n\t\tchar\t\tndoc[16];\n\t\tchar\t\tnentry[16];\n\t\tHeapTuple\ttuple;\n\n\t\tvalues[0] = palloc(entry->lenlexeme + 1);\n\t\tmemcpy(values[0], entry->lexeme, entry->lenlexeme);\n\t\t(values[0])[entry->lenlexeme] = '\\0';\n\t\tsprintf(ndoc, \"%d\", entry->ndoc);\n\t\tvalues[1] = ndoc;\n\t\tsprintf(nentry, \"%d\", entry->nentry);\n\t\tvalues[2] = nentry;\n\n\t\ttuple = BuildTupleFromCStrings(funcctx->attinmeta, values);\n\t\tresult = HeapTupleGetDatum(tuple);\n\n\t\tpfree(values[0]);\n\n\t\t/* mark entry as already visited */\n\t\tentry->ndoc = 0;\n\n\t\treturn result;\n\t}\n\n\treturn (Datum) 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRF_PERCALL_SETUP",
          "args": [],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_finish",
          "args": [],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ts_setup_firstcall",
          "args": [
            "fcinfo",
            "funcctx",
            "stat"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "ts_setup_firstcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "2157-2201",
          "snippet": "static void\nts_setup_firstcall(FunctionCallInfo fcinfo, FuncCallContext *funcctx,\n\t\t\t\t   TSVectorStat *stat)\n{\n\tTupleDesc\ttupdesc;\n\tMemoryContext oldcontext;\n\tStatEntry  *node;\n\n\tfuncctx->user_fctx = (void *) stat;\n\n\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\tstat->stack = palloc0(sizeof(StatEntry *) * (stat->maxdepth + 1));\n\tstat->stackpos = 0;\n\n\tnode = stat->root;\n\t/* find leftmost value */\n\tif (node == NULL)\n\t\tstat->stack[stat->stackpos] = NULL;\n\telse\n\t\tfor (;;)\n\t\t{\n\t\t\tstat->stack[stat->stackpos] = node;\n\t\t\tif (node->left)\n\t\t\t{\n\t\t\t\tstat->stackpos++;\n\t\t\t\tnode = node->left;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\tAssert(stat->stackpos <= stat->maxdepth);\n\n\ttupdesc = CreateTemplateTupleDesc(3, false);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"word\",\n\t\t\t\t\t   TEXTOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"ndoc\",\n\t\t\t\t\t   INT4OID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"nentry\",\n\t\t\t\t\t   INT4OID, -1, 0);\n\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\tfuncctx->attinmeta = TupleDescGetAttInMetadata(tupdesc);\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nts_setup_firstcall(FunctionCallInfo fcinfo, FuncCallContext *funcctx,\n\t\t\t\t   TSVectorStat *stat)\n{\n\tTupleDesc\ttupdesc;\n\tMemoryContext oldcontext;\n\tStatEntry  *node;\n\n\tfuncctx->user_fctx = (void *) stat;\n\n\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\tstat->stack = palloc0(sizeof(StatEntry *) * (stat->maxdepth + 1));\n\tstat->stackpos = 0;\n\n\tnode = stat->root;\n\t/* find leftmost value */\n\tif (node == NULL)\n\t\tstat->stack[stat->stackpos] = NULL;\n\telse\n\t\tfor (;;)\n\t\t{\n\t\t\tstat->stack[stat->stackpos] = node;\n\t\t\tif (node->left)\n\t\t\t{\n\t\t\t\tstat->stackpos++;\n\t\t\t\tnode = node->left;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\tAssert(stat->stackpos <= stat->maxdepth);\n\n\ttupdesc = CreateTemplateTupleDesc(3, false);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"word\",\n\t\t\t\t\t   TEXTOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"ndoc\",\n\t\t\t\t\t   INT4OID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"nentry\",\n\t\t\t\t\t   INT4OID, -1, 0);\n\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\tfuncctx->attinmeta = TupleDescGetAttInMetadata(tupdesc);\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "txt",
            "0"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ts_stat_sql",
          "args": [
            "funcctx->multi_call_memory_ctx",
            "txt",
            "NULL"
          ],
          "line": 2391
        },
        "resolved": true,
        "details": {
          "function_name": "ts_stat_sql",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "2289-2376",
          "snippet": "static TSVectorStat *\nts_stat_sql(MemoryContext persistentContext, text *txt, text *ws)\n{\n\tchar\t   *query = text_to_cstring(txt);\n\tTSVectorStat *stat;\n\tbool\t\tisnull;\n\tPortal\t\tportal;\n\tSPIPlanPtr\tplan;\n\n\tif ((plan = SPI_prepare(query, 0, NULL)) == NULL)\n\t\t/* internal error */\n\t\telog(ERROR, \"SPI_prepare(\\\"%s\\\") failed\", query);\n\n\tif ((portal = SPI_cursor_open(NULL, plan, NULL, NULL, true)) == NULL)\n\t\t/* internal error */\n\t\telog(ERROR, \"SPI_cursor_open(\\\"%s\\\") failed\", query);\n\n\tSPI_cursor_fetch(portal, true, 100);\n\n\tif (SPI_tuptable == NULL ||\n\t\tSPI_tuptable->tupdesc->natts != 1 ||\n\t\t!IsBinaryCoercible(SPI_gettypeid(SPI_tuptable->tupdesc, 1),\n\t\t\t\t\t\t   TSVECTOROID))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"ts_stat query must return one tsvector column\")));\n\n\tstat = MemoryContextAllocZero(persistentContext, sizeof(TSVectorStat));\n\tstat->maxdepth = 1;\n\n\tif (ws)\n\t{\n\t\tchar\t   *buf;\n\n\t\tbuf = VARDATA_ANY(ws);\n\t\twhile (buf - VARDATA_ANY(ws) < VARSIZE_ANY_EXHDR(ws))\n\t\t{\n\t\t\tif (pg_mblen(buf) == 1)\n\t\t\t{\n\t\t\t\tswitch (*buf)\n\t\t\t\t{\n\t\t\t\t\tcase 'A':\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tstat->weight |= 1 << 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'B':\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tstat->weight |= 1 << 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'C':\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tstat->weight |= 1 << 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'D':\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\tstat->weight |= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstat->weight |= 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuf += pg_mblen(buf);\n\t\t}\n\t}\n\n\twhile (SPI_processed > 0)\n\t{\n\t\tuint64\t\ti;\n\n\t\tfor (i = 0; i < SPI_processed; i++)\n\t\t{\n\t\t\tDatum\t\tdata = SPI_getbinval(SPI_tuptable->vals[i], SPI_tuptable->tupdesc, 1, &isnull);\n\n\t\t\tif (!isnull)\n\t\t\t\tstat = ts_accum(persistentContext, stat, data);\n\t\t}\n\n\t\tSPI_freetuptable(SPI_tuptable);\n\t\tSPI_cursor_fetch(portal, true, 100);\n\t}\n\n\tSPI_freetuptable(SPI_tuptable);\n\tSPI_cursor_close(portal);\n\tSPI_freeplan(plan);\n\tpfree(query);\n\n\treturn stat;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TSVectorStat *\nts_stat_sql(MemoryContext persistentContext, text *txt, text *ws)\n{\n\tchar\t   *query = text_to_cstring(txt);\n\tTSVectorStat *stat;\n\tbool\t\tisnull;\n\tPortal\t\tportal;\n\tSPIPlanPtr\tplan;\n\n\tif ((plan = SPI_prepare(query, 0, NULL)) == NULL)\n\t\t/* internal error */\n\t\telog(ERROR, \"SPI_prepare(\\\"%s\\\") failed\", query);\n\n\tif ((portal = SPI_cursor_open(NULL, plan, NULL, NULL, true)) == NULL)\n\t\t/* internal error */\n\t\telog(ERROR, \"SPI_cursor_open(\\\"%s\\\") failed\", query);\n\n\tSPI_cursor_fetch(portal, true, 100);\n\n\tif (SPI_tuptable == NULL ||\n\t\tSPI_tuptable->tupdesc->natts != 1 ||\n\t\t!IsBinaryCoercible(SPI_gettypeid(SPI_tuptable->tupdesc, 1),\n\t\t\t\t\t\t   TSVECTOROID))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"ts_stat query must return one tsvector column\")));\n\n\tstat = MemoryContextAllocZero(persistentContext, sizeof(TSVectorStat));\n\tstat->maxdepth = 1;\n\n\tif (ws)\n\t{\n\t\tchar\t   *buf;\n\n\t\tbuf = VARDATA_ANY(ws);\n\t\twhile (buf - VARDATA_ANY(ws) < VARSIZE_ANY_EXHDR(ws))\n\t\t{\n\t\t\tif (pg_mblen(buf) == 1)\n\t\t\t{\n\t\t\t\tswitch (*buf)\n\t\t\t\t{\n\t\t\t\t\tcase 'A':\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tstat->weight |= 1 << 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'B':\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tstat->weight |= 1 << 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'C':\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tstat->weight |= 1 << 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'D':\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\tstat->weight |= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstat->weight |= 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuf += pg_mblen(buf);\n\t\t}\n\t}\n\n\twhile (SPI_processed > 0)\n\t{\n\t\tuint64\t\ti;\n\n\t\tfor (i = 0; i < SPI_processed; i++)\n\t\t{\n\t\t\tDatum\t\tdata = SPI_getbinval(SPI_tuptable->vals[i], SPI_tuptable->tupdesc, 1, &isnull);\n\n\t\t\tif (!isnull)\n\t\t\t\tstat = ts_accum(persistentContext, stat, data);\n\t\t}\n\n\t\tSPI_freetuptable(SPI_tuptable);\n\t\tSPI_cursor_fetch(portal, true, 100);\n\t}\n\n\tSPI_freetuptable(SPI_tuptable);\n\tSPI_cursor_close(portal);\n\tSPI_freeplan(plan);\n\tpfree(query);\n\n\treturn stat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_connect",
          "args": [],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_FIRSTCALL_INIT",
          "args": [],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "0"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_IS_FIRSTCALL",
          "args": [],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\nts_stat1(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tDatum\t\tresult;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTSVectorStat *stat;\n\t\ttext\t   *txt = PG_GETARG_TEXT_PP(0);\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\tSPI_connect();\n\t\tstat = ts_stat_sql(funcctx->multi_call_memory_ctx, txt, NULL);\n\t\tPG_FREE_IF_COPY(txt, 0);\n\t\tts_setup_firstcall(fcinfo, funcctx, stat);\n\t\tSPI_finish();\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\tif ((result = ts_process_call(funcctx)) != (Datum) 0)\n\t\tSRF_RETURN_NEXT(funcctx, result);\n\tSRF_RETURN_DONE(funcctx);\n}"
  },
  {
    "function_name": "ts_stat_sql",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "2289-2376",
    "snippet": "static TSVectorStat *\nts_stat_sql(MemoryContext persistentContext, text *txt, text *ws)\n{\n\tchar\t   *query = text_to_cstring(txt);\n\tTSVectorStat *stat;\n\tbool\t\tisnull;\n\tPortal\t\tportal;\n\tSPIPlanPtr\tplan;\n\n\tif ((plan = SPI_prepare(query, 0, NULL)) == NULL)\n\t\t/* internal error */\n\t\telog(ERROR, \"SPI_prepare(\\\"%s\\\") failed\", query);\n\n\tif ((portal = SPI_cursor_open(NULL, plan, NULL, NULL, true)) == NULL)\n\t\t/* internal error */\n\t\telog(ERROR, \"SPI_cursor_open(\\\"%s\\\") failed\", query);\n\n\tSPI_cursor_fetch(portal, true, 100);\n\n\tif (SPI_tuptable == NULL ||\n\t\tSPI_tuptable->tupdesc->natts != 1 ||\n\t\t!IsBinaryCoercible(SPI_gettypeid(SPI_tuptable->tupdesc, 1),\n\t\t\t\t\t\t   TSVECTOROID))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"ts_stat query must return one tsvector column\")));\n\n\tstat = MemoryContextAllocZero(persistentContext, sizeof(TSVectorStat));\n\tstat->maxdepth = 1;\n\n\tif (ws)\n\t{\n\t\tchar\t   *buf;\n\n\t\tbuf = VARDATA_ANY(ws);\n\t\twhile (buf - VARDATA_ANY(ws) < VARSIZE_ANY_EXHDR(ws))\n\t\t{\n\t\t\tif (pg_mblen(buf) == 1)\n\t\t\t{\n\t\t\t\tswitch (*buf)\n\t\t\t\t{\n\t\t\t\t\tcase 'A':\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tstat->weight |= 1 << 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'B':\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tstat->weight |= 1 << 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'C':\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tstat->weight |= 1 << 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'D':\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\tstat->weight |= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstat->weight |= 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuf += pg_mblen(buf);\n\t\t}\n\t}\n\n\twhile (SPI_processed > 0)\n\t{\n\t\tuint64\t\ti;\n\n\t\tfor (i = 0; i < SPI_processed; i++)\n\t\t{\n\t\t\tDatum\t\tdata = SPI_getbinval(SPI_tuptable->vals[i], SPI_tuptable->tupdesc, 1, &isnull);\n\n\t\t\tif (!isnull)\n\t\t\t\tstat = ts_accum(persistentContext, stat, data);\n\t\t}\n\n\t\tSPI_freetuptable(SPI_tuptable);\n\t\tSPI_cursor_fetch(portal, true, 100);\n\t}\n\n\tSPI_freetuptable(SPI_tuptable);\n\tSPI_cursor_close(portal);\n\tSPI_freeplan(plan);\n\tpfree(query);\n\n\treturn stat;\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "query"
          ],
          "line": 2373
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_freeplan",
          "args": [
            "plan"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_cursor_close",
          "args": [
            "portal"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_freetuptable",
          "args": [
            "SPI_tuptable"
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_cursor_fetch",
          "args": [
            "portal",
            "true",
            "100"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_freetuptable",
          "args": [
            "SPI_tuptable"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ts_accum",
          "args": [
            "persistentContext",
            "stat",
            "data"
          ],
          "line": 2363
        },
        "resolved": true,
        "details": {
          "function_name": "ts_accum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "2122-2155",
          "snippet": "static TSVectorStat *\nts_accum(MemoryContext persistentContext, TSVectorStat *stat, Datum data)\n{\n\tTSVector\ttxt = DatumGetTSVector(data);\n\tuint32\t\ti,\n\t\t\t\tnbit = 0,\n\t\t\t\toffset;\n\n\tif (stat == NULL)\n\t{\t\t\t\t\t\t\t/* Init in first */\n\t\tstat = MemoryContextAllocZero(persistentContext, sizeof(TSVectorStat));\n\t\tstat->maxdepth = 1;\n\t}\n\n\t/* simple check of correctness */\n\tif (txt == NULL || txt->size == 0)\n\t{\n\t\tif (txt && txt != (TSVector) DatumGetPointer(data))\n\t\t\tpfree(txt);\n\t\treturn stat;\n\t}\n\n\ti = txt->size - 1;\n\tfor (; i > 0; i >>= 1)\n\t\tnbit++;\n\n\tnbit = 1 << nbit;\n\toffset = (nbit - txt->size) / 2;\n\n\tinsertStatEntry(persistentContext, stat, txt, (nbit >> 1) - offset);\n\tchooseNextStatEntry(persistentContext, stat, txt, 0, nbit, offset);\n\n\treturn stat;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TSVectorStat *\nts_accum(MemoryContext persistentContext, TSVectorStat *stat, Datum data)\n{\n\tTSVector\ttxt = DatumGetTSVector(data);\n\tuint32\t\ti,\n\t\t\t\tnbit = 0,\n\t\t\t\toffset;\n\n\tif (stat == NULL)\n\t{\t\t\t\t\t\t\t/* Init in first */\n\t\tstat = MemoryContextAllocZero(persistentContext, sizeof(TSVectorStat));\n\t\tstat->maxdepth = 1;\n\t}\n\n\t/* simple check of correctness */\n\tif (txt == NULL || txt->size == 0)\n\t{\n\t\tif (txt && txt != (TSVector) DatumGetPointer(data))\n\t\t\tpfree(txt);\n\t\treturn stat;\n\t}\n\n\ti = txt->size - 1;\n\tfor (; i > 0; i >>= 1)\n\t\tnbit++;\n\n\tnbit = 1 << nbit;\n\toffset = (nbit - txt->size) / 2;\n\n\tinsertStatEntry(persistentContext, stat, txt, (nbit >> 1) - offset);\n\tchooseNextStatEntry(persistentContext, stat, txt, 0, nbit, offset);\n\n\treturn stat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_getbinval",
          "args": [
            "SPI_tuptable->vals[i]",
            "SPI_tuptable->tupdesc",
            "1",
            "&isnull"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_mblen",
          "args": [
            "buf"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mblen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "759-763",
          "snippet": "int\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\npg_mblen(const char *mbstr)\n{\n\treturn pg_wchar_table[DatabaseEncoding->encoding].mblen((const unsigned char *) mbstr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "ws"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "ws"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "ws"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "persistentContext",
            "sizeof(TSVectorStat)"
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"ts_stat query must return one tsvector column\"))"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"ts_stat query must return one tsvector column\""
          ],
          "line": 2314
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsBinaryCoercible",
          "args": [
            "SPI_gettypeid(SPI_tuptable->tupdesc, 1)",
            "TSVECTOROID"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_gettypeid",
          "args": [
            "SPI_tuptable->tupdesc",
            "1"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_cursor_fetch",
          "args": [
            "portal",
            "true",
            "100"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"SPI_cursor_open(\\\"%s\\\") failed\"",
            "query"
          ],
          "line": 2304
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SPI_cursor_open",
          "args": [
            "NULL",
            "plan",
            "NULL",
            "NULL",
            "true"
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPI_prepare",
          "args": [
            "query",
            "0",
            "NULL"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "text_to_cstring",
          "args": [
            "txt"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "text_to_cstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "181-197",
          "snippet": "char *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void appendStringInfoText(StringInfo str, const text *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic void appendStringInfoText(StringInfo str, const text *t);\n\nchar *\ntext_to_cstring(const text *t)\n{\n\t/* must cast away the const, unfortunately */\n\ttext\t   *tunpacked = pg_detoast_datum_packed((struct varlena *) t);\n\tint\t\t\tlen = VARSIZE_ANY_EXHDR(tunpacked);\n\tchar\t   *result;\n\n\tresult = (char *) palloc(len + 1);\n\tmemcpy(result, VARDATA_ANY(tunpacked), len);\n\tresult[len] = '\\0';\n\n\tif (tunpacked != t)\n\t\tpfree(tunpacked);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TSVectorStat *\nts_stat_sql(MemoryContext persistentContext, text *txt, text *ws)\n{\n\tchar\t   *query = text_to_cstring(txt);\n\tTSVectorStat *stat;\n\tbool\t\tisnull;\n\tPortal\t\tportal;\n\tSPIPlanPtr\tplan;\n\n\tif ((plan = SPI_prepare(query, 0, NULL)) == NULL)\n\t\t/* internal error */\n\t\telog(ERROR, \"SPI_prepare(\\\"%s\\\") failed\", query);\n\n\tif ((portal = SPI_cursor_open(NULL, plan, NULL, NULL, true)) == NULL)\n\t\t/* internal error */\n\t\telog(ERROR, \"SPI_cursor_open(\\\"%s\\\") failed\", query);\n\n\tSPI_cursor_fetch(portal, true, 100);\n\n\tif (SPI_tuptable == NULL ||\n\t\tSPI_tuptable->tupdesc->natts != 1 ||\n\t\t!IsBinaryCoercible(SPI_gettypeid(SPI_tuptable->tupdesc, 1),\n\t\t\t\t\t\t   TSVECTOROID))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"ts_stat query must return one tsvector column\")));\n\n\tstat = MemoryContextAllocZero(persistentContext, sizeof(TSVectorStat));\n\tstat->maxdepth = 1;\n\n\tif (ws)\n\t{\n\t\tchar\t   *buf;\n\n\t\tbuf = VARDATA_ANY(ws);\n\t\twhile (buf - VARDATA_ANY(ws) < VARSIZE_ANY_EXHDR(ws))\n\t\t{\n\t\t\tif (pg_mblen(buf) == 1)\n\t\t\t{\n\t\t\t\tswitch (*buf)\n\t\t\t\t{\n\t\t\t\t\tcase 'A':\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tstat->weight |= 1 << 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'B':\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tstat->weight |= 1 << 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'C':\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tstat->weight |= 1 << 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'D':\n\t\t\t\t\tcase 'd':\n\t\t\t\t\t\tstat->weight |= 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tstat->weight |= 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuf += pg_mblen(buf);\n\t\t}\n\t}\n\n\twhile (SPI_processed > 0)\n\t{\n\t\tuint64\t\ti;\n\n\t\tfor (i = 0; i < SPI_processed; i++)\n\t\t{\n\t\t\tDatum\t\tdata = SPI_getbinval(SPI_tuptable->vals[i], SPI_tuptable->tupdesc, 1, &isnull);\n\n\t\t\tif (!isnull)\n\t\t\t\tstat = ts_accum(persistentContext, stat, data);\n\t\t}\n\n\t\tSPI_freetuptable(SPI_tuptable);\n\t\tSPI_cursor_fetch(portal, true, 100);\n\t}\n\n\tSPI_freetuptable(SPI_tuptable);\n\tSPI_cursor_close(portal);\n\tSPI_freeplan(plan);\n\tpfree(query);\n\n\treturn stat;\n}"
  },
  {
    "function_name": "ts_process_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "2249-2287",
    "snippet": "static Datum\nts_process_call(FuncCallContext *funcctx)\n{\n\tTSVectorStat *st;\n\tStatEntry  *entry;\n\n\tst = (TSVectorStat *) funcctx->user_fctx;\n\n\tentry = walkStatEntryTree(st);\n\n\tif (entry != NULL)\n\t{\n\t\tDatum\t\tresult;\n\t\tchar\t   *values[3];\n\t\tchar\t\tndoc[16];\n\t\tchar\t\tnentry[16];\n\t\tHeapTuple\ttuple;\n\n\t\tvalues[0] = palloc(entry->lenlexeme + 1);\n\t\tmemcpy(values[0], entry->lexeme, entry->lenlexeme);\n\t\t(values[0])[entry->lenlexeme] = '\\0';\n\t\tsprintf(ndoc, \"%d\", entry->ndoc);\n\t\tvalues[1] = ndoc;\n\t\tsprintf(nentry, \"%d\", entry->nentry);\n\t\tvalues[2] = nentry;\n\n\t\ttuple = BuildTupleFromCStrings(funcctx->attinmeta, values);\n\t\tresult = HeapTupleGetDatum(tuple);\n\n\t\tpfree(values[0]);\n\n\t\t/* mark entry as already visited */\n\t\tentry->ndoc = 0;\n\n\t\treturn result;\n\t}\n\n\treturn (Datum) 0;\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "values[0]"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapTupleGetDatum",
          "args": [
            "tuple"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BuildTupleFromCStrings",
          "args": [
            "funcctx->attinmeta",
            "values"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "nentry",
            "\"%d\"",
            "entry->nentry"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ndoc",
            "\"%d\"",
            "entry->ndoc"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "values[0]",
            "entry->lexeme",
            "entry->lenlexeme"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "entry->lenlexeme + 1"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "walkStatEntryTree",
          "args": [
            "st"
          ],
          "line": 2257
        },
        "resolved": true,
        "details": {
          "function_name": "walkStatEntryTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "2203-2247",
          "snippet": "static StatEntry *\nwalkStatEntryTree(TSVectorStat *stat)\n{\n\tStatEntry  *node = stat->stack[stat->stackpos];\n\n\tif (node == NULL)\n\t\treturn NULL;\n\n\tif (node->ndoc != 0)\n\t{\n\t\t/* return entry itself: we already was at left sublink */\n\t\treturn node;\n\t}\n\telse if (node->right && node->right != stat->stack[stat->stackpos + 1])\n\t{\n\t\t/* go on right sublink */\n\t\tstat->stackpos++;\n\t\tnode = node->right;\n\n\t\t/* find most-left value */\n\t\tfor (;;)\n\t\t{\n\t\t\tstat->stack[stat->stackpos] = node;\n\t\t\tif (node->left)\n\t\t\t{\n\t\t\t\tstat->stackpos++;\n\t\t\t\tnode = node->left;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tAssert(stat->stackpos <= stat->maxdepth);\n\t}\n\telse\n\t{\n\t\t/* we already return all left subtree, itself and  right subtree */\n\t\tif (stat->stackpos == 0)\n\t\t\treturn NULL;\n\n\t\tstat->stackpos--;\n\t\treturn walkStatEntryTree(stat);\n\t}\n\n\treturn node;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic StatEntry *\nwalkStatEntryTree(TSVectorStat *stat)\n{\n\tStatEntry  *node = stat->stack[stat->stackpos];\n\n\tif (node == NULL)\n\t\treturn NULL;\n\n\tif (node->ndoc != 0)\n\t{\n\t\t/* return entry itself: we already was at left sublink */\n\t\treturn node;\n\t}\n\telse if (node->right && node->right != stat->stack[stat->stackpos + 1])\n\t{\n\t\t/* go on right sublink */\n\t\tstat->stackpos++;\n\t\tnode = node->right;\n\n\t\t/* find most-left value */\n\t\tfor (;;)\n\t\t{\n\t\t\tstat->stack[stat->stackpos] = node;\n\t\t\tif (node->left)\n\t\t\t{\n\t\t\t\tstat->stackpos++;\n\t\t\t\tnode = node->left;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tAssert(stat->stackpos <= stat->maxdepth);\n\t}\n\telse\n\t{\n\t\t/* we already return all left subtree, itself and  right subtree */\n\t\tif (stat->stackpos == 0)\n\t\t\treturn NULL;\n\n\t\tstat->stackpos--;\n\t\treturn walkStatEntryTree(stat);\n\t}\n\n\treturn node;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic Datum\nts_process_call(FuncCallContext *funcctx)\n{\n\tTSVectorStat *st;\n\tStatEntry  *entry;\n\n\tst = (TSVectorStat *) funcctx->user_fctx;\n\n\tentry = walkStatEntryTree(st);\n\n\tif (entry != NULL)\n\t{\n\t\tDatum\t\tresult;\n\t\tchar\t   *values[3];\n\t\tchar\t\tndoc[16];\n\t\tchar\t\tnentry[16];\n\t\tHeapTuple\ttuple;\n\n\t\tvalues[0] = palloc(entry->lenlexeme + 1);\n\t\tmemcpy(values[0], entry->lexeme, entry->lenlexeme);\n\t\t(values[0])[entry->lenlexeme] = '\\0';\n\t\tsprintf(ndoc, \"%d\", entry->ndoc);\n\t\tvalues[1] = ndoc;\n\t\tsprintf(nentry, \"%d\", entry->nentry);\n\t\tvalues[2] = nentry;\n\n\t\ttuple = BuildTupleFromCStrings(funcctx->attinmeta, values);\n\t\tresult = HeapTupleGetDatum(tuple);\n\n\t\tpfree(values[0]);\n\n\t\t/* mark entry as already visited */\n\t\tentry->ndoc = 0;\n\n\t\treturn result;\n\t}\n\n\treturn (Datum) 0;\n}"
  },
  {
    "function_name": "walkStatEntryTree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "2203-2247",
    "snippet": "static StatEntry *\nwalkStatEntryTree(TSVectorStat *stat)\n{\n\tStatEntry  *node = stat->stack[stat->stackpos];\n\n\tif (node == NULL)\n\t\treturn NULL;\n\n\tif (node->ndoc != 0)\n\t{\n\t\t/* return entry itself: we already was at left sublink */\n\t\treturn node;\n\t}\n\telse if (node->right && node->right != stat->stack[stat->stackpos + 1])\n\t{\n\t\t/* go on right sublink */\n\t\tstat->stackpos++;\n\t\tnode = node->right;\n\n\t\t/* find most-left value */\n\t\tfor (;;)\n\t\t{\n\t\t\tstat->stack[stat->stackpos] = node;\n\t\t\tif (node->left)\n\t\t\t{\n\t\t\t\tstat->stackpos++;\n\t\t\t\tnode = node->left;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tAssert(stat->stackpos <= stat->maxdepth);\n\t}\n\telse\n\t{\n\t\t/* we already return all left subtree, itself and  right subtree */\n\t\tif (stat->stackpos == 0)\n\t\t\treturn NULL;\n\n\t\tstat->stackpos--;\n\t\treturn walkStatEntryTree(stat);\n\t}\n\n\treturn node;\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walkStatEntryTree",
          "args": [
            "stat"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "walkStatEntryTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "2203-2247",
          "snippet": "static StatEntry *\nwalkStatEntryTree(TSVectorStat *stat)\n{\n\tStatEntry  *node = stat->stack[stat->stackpos];\n\n\tif (node == NULL)\n\t\treturn NULL;\n\n\tif (node->ndoc != 0)\n\t{\n\t\t/* return entry itself: we already was at left sublink */\n\t\treturn node;\n\t}\n\telse if (node->right && node->right != stat->stack[stat->stackpos + 1])\n\t{\n\t\t/* go on right sublink */\n\t\tstat->stackpos++;\n\t\tnode = node->right;\n\n\t\t/* find most-left value */\n\t\tfor (;;)\n\t\t{\n\t\t\tstat->stack[stat->stackpos] = node;\n\t\t\tif (node->left)\n\t\t\t{\n\t\t\t\tstat->stackpos++;\n\t\t\t\tnode = node->left;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tAssert(stat->stackpos <= stat->maxdepth);\n\t}\n\telse\n\t{\n\t\t/* we already return all left subtree, itself and  right subtree */\n\t\tif (stat->stackpos == 0)\n\t\t\treturn NULL;\n\n\t\tstat->stackpos--;\n\t\treturn walkStatEntryTree(stat);\n\t}\n\n\treturn node;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "stat->stackpos <= stat->maxdepth"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic StatEntry *\nwalkStatEntryTree(TSVectorStat *stat)\n{\n\tStatEntry  *node = stat->stack[stat->stackpos];\n\n\tif (node == NULL)\n\t\treturn NULL;\n\n\tif (node->ndoc != 0)\n\t{\n\t\t/* return entry itself: we already was at left sublink */\n\t\treturn node;\n\t}\n\telse if (node->right && node->right != stat->stack[stat->stackpos + 1])\n\t{\n\t\t/* go on right sublink */\n\t\tstat->stackpos++;\n\t\tnode = node->right;\n\n\t\t/* find most-left value */\n\t\tfor (;;)\n\t\t{\n\t\t\tstat->stack[stat->stackpos] = node;\n\t\t\tif (node->left)\n\t\t\t{\n\t\t\t\tstat->stackpos++;\n\t\t\t\tnode = node->left;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tAssert(stat->stackpos <= stat->maxdepth);\n\t}\n\telse\n\t{\n\t\t/* we already return all left subtree, itself and  right subtree */\n\t\tif (stat->stackpos == 0)\n\t\t\treturn NULL;\n\n\t\tstat->stackpos--;\n\t\treturn walkStatEntryTree(stat);\n\t}\n\n\treturn node;\n}"
  },
  {
    "function_name": "ts_setup_firstcall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "2157-2201",
    "snippet": "static void\nts_setup_firstcall(FunctionCallInfo fcinfo, FuncCallContext *funcctx,\n\t\t\t\t   TSVectorStat *stat)\n{\n\tTupleDesc\ttupdesc;\n\tMemoryContext oldcontext;\n\tStatEntry  *node;\n\n\tfuncctx->user_fctx = (void *) stat;\n\n\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\tstat->stack = palloc0(sizeof(StatEntry *) * (stat->maxdepth + 1));\n\tstat->stackpos = 0;\n\n\tnode = stat->root;\n\t/* find leftmost value */\n\tif (node == NULL)\n\t\tstat->stack[stat->stackpos] = NULL;\n\telse\n\t\tfor (;;)\n\t\t{\n\t\t\tstat->stack[stat->stackpos] = node;\n\t\t\tif (node->left)\n\t\t\t{\n\t\t\t\tstat->stackpos++;\n\t\t\t\tnode = node->left;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\tAssert(stat->stackpos <= stat->maxdepth);\n\n\ttupdesc = CreateTemplateTupleDesc(3, false);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"word\",\n\t\t\t\t\t   TEXTOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"ndoc\",\n\t\t\t\t\t   INT4OID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"nentry\",\n\t\t\t\t\t   INT4OID, -1, 0);\n\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\tfuncctx->attinmeta = TupleDescGetAttInMetadata(tupdesc);\n\n\tMemoryContextSwitchTo(oldcontext);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescGetAttInMetadata",
          "args": [
            "tupdesc"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlessTupleDesc",
          "args": [
            "tupdesc"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 3",
            "\"nentry\"",
            "INT4OID",
            "-1",
            "0"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 2",
            "\"ndoc\"",
            "INT4OID",
            "-1",
            "0"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 1",
            "\"word\"",
            "TEXTOID",
            "-1",
            "0"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTemplateTupleDesc",
          "args": [
            "3",
            "false"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "stat->stackpos <= stat->maxdepth"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "sizeof(StatEntry *) * (stat->maxdepth + 1)"
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "funcctx->multi_call_memory_ctx"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nts_setup_firstcall(FunctionCallInfo fcinfo, FuncCallContext *funcctx,\n\t\t\t\t   TSVectorStat *stat)\n{\n\tTupleDesc\ttupdesc;\n\tMemoryContext oldcontext;\n\tStatEntry  *node;\n\n\tfuncctx->user_fctx = (void *) stat;\n\n\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\tstat->stack = palloc0(sizeof(StatEntry *) * (stat->maxdepth + 1));\n\tstat->stackpos = 0;\n\n\tnode = stat->root;\n\t/* find leftmost value */\n\tif (node == NULL)\n\t\tstat->stack[stat->stackpos] = NULL;\n\telse\n\t\tfor (;;)\n\t\t{\n\t\t\tstat->stack[stat->stackpos] = node;\n\t\t\tif (node->left)\n\t\t\t{\n\t\t\t\tstat->stackpos++;\n\t\t\t\tnode = node->left;\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\tAssert(stat->stackpos <= stat->maxdepth);\n\n\ttupdesc = CreateTemplateTupleDesc(3, false);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"word\",\n\t\t\t\t\t   TEXTOID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"ndoc\",\n\t\t\t\t\t   INT4OID, -1, 0);\n\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"nentry\",\n\t\t\t\t\t   INT4OID, -1, 0);\n\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\tfuncctx->attinmeta = TupleDescGetAttInMetadata(tupdesc);\n\n\tMemoryContextSwitchTo(oldcontext);\n}"
  },
  {
    "function_name": "ts_accum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "2122-2155",
    "snippet": "static TSVectorStat *\nts_accum(MemoryContext persistentContext, TSVectorStat *stat, Datum data)\n{\n\tTSVector\ttxt = DatumGetTSVector(data);\n\tuint32\t\ti,\n\t\t\t\tnbit = 0,\n\t\t\t\toffset;\n\n\tif (stat == NULL)\n\t{\t\t\t\t\t\t\t/* Init in first */\n\t\tstat = MemoryContextAllocZero(persistentContext, sizeof(TSVectorStat));\n\t\tstat->maxdepth = 1;\n\t}\n\n\t/* simple check of correctness */\n\tif (txt == NULL || txt->size == 0)\n\t{\n\t\tif (txt && txt != (TSVector) DatumGetPointer(data))\n\t\t\tpfree(txt);\n\t\treturn stat;\n\t}\n\n\ti = txt->size - 1;\n\tfor (; i > 0; i >>= 1)\n\t\tnbit++;\n\n\tnbit = 1 << nbit;\n\toffset = (nbit - txt->size) / 2;\n\n\tinsertStatEntry(persistentContext, stat, txt, (nbit >> 1) - offset);\n\tchooseNextStatEntry(persistentContext, stat, txt, 0, nbit, offset);\n\n\treturn stat;\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chooseNextStatEntry",
          "args": [
            "persistentContext",
            "stat",
            "txt",
            "0",
            "nbit",
            "offset"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "chooseNextStatEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "2090-2108",
          "snippet": "static void\nchooseNextStatEntry(MemoryContext persistentContext, TSVectorStat *stat, TSVector txt,\n\t\t\t\t\tuint32 low, uint32 high, uint32 offset)\n{\n\tuint32\t\tpos;\n\tuint32\t\tmiddle = (low + high) >> 1;\n\n\tpos = (low + middle) >> 1;\n\tif (low != middle && pos >= offset && pos - offset < txt->size)\n\t\tinsertStatEntry(persistentContext, stat, txt, pos - offset);\n\tpos = (high + middle + 1) >> 1;\n\tif (middle + 1 != high && pos >= offset && pos - offset < txt->size)\n\t\tinsertStatEntry(persistentContext, stat, txt, pos - offset);\n\n\tif (low != middle)\n\t\tchooseNextStatEntry(persistentContext, stat, txt, low, middle, offset);\n\tif (high != middle + 1)\n\t\tchooseNextStatEntry(persistentContext, stat, txt, middle + 1, high, offset);\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nchooseNextStatEntry(MemoryContext persistentContext, TSVectorStat *stat, TSVector txt,\n\t\t\t\t\tuint32 low, uint32 high, uint32 offset)\n{\n\tuint32\t\tpos;\n\tuint32\t\tmiddle = (low + high) >> 1;\n\n\tpos = (low + middle) >> 1;\n\tif (low != middle && pos >= offset && pos - offset < txt->size)\n\t\tinsertStatEntry(persistentContext, stat, txt, pos - offset);\n\tpos = (high + middle + 1) >> 1;\n\tif (middle + 1 != high && pos >= offset && pos - offset < txt->size)\n\t\tinsertStatEntry(persistentContext, stat, txt, pos - offset);\n\n\tif (low != middle)\n\t\tchooseNextStatEntry(persistentContext, stat, txt, low, middle, offset);\n\tif (high != middle + 1)\n\t\tchooseNextStatEntry(persistentContext, stat, txt, middle + 1, high, offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insertStatEntry",
          "args": [
            "persistentContext",
            "stat",
            "txt",
            "(nbit >> 1) - offset"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "insertStatEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "2024-2088",
          "snippet": "static void\ninsertStatEntry(MemoryContext persistentContext, TSVectorStat *stat, TSVector txt, uint32 off)\n{\n\tWordEntry  *we = ARRPTR(txt) + off;\n\tStatEntry  *node = stat->root,\n\t\t\t   *pnode = NULL;\n\tint\t\t\tn,\n\t\t\t\tres = 0;\n\tuint32\t\tdepth = 1;\n\n\tif (stat->weight == 0)\n\t\tn = (we->haspos) ? POSDATALEN(txt, we) : 1;\n\telse\n\t\tn = (we->haspos) ? check_weight(txt, we, stat->weight) : 0;\n\n\tif (n == 0)\n\t\treturn;\t\t\t\t\t/* nothing to insert */\n\n\twhile (node)\n\t{\n\t\tres = compareStatWord(node, we, txt);\n\n\t\tif (res == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpnode = node;\n\t\t\tnode = (res < 0) ? node->left : node->right;\n\t\t}\n\t\tdepth++;\n\t}\n\n\tif (depth > stat->maxdepth)\n\t\tstat->maxdepth = depth;\n\n\tif (node == NULL)\n\t{\n\t\tnode = MemoryContextAlloc(persistentContext, STATENTRYHDRSZ + we->len);\n\t\tnode->left = node->right = NULL;\n\t\tnode->ndoc = 1;\n\t\tnode->nentry = n;\n\t\tnode->lenlexeme = we->len;\n\t\tmemcpy(node->lexeme, STRPTR(txt) + we->pos, node->lenlexeme);\n\n\t\tif (pnode == NULL)\n\t\t{\n\t\t\tstat->root = node;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (res < 0)\n\t\t\t\tpnode->left = node;\n\t\t\telse\n\t\t\t\tpnode->right = node;\n\t\t}\n\n\t}\n\telse\n\t{\n\t\tnode->ndoc++;\n\t\tnode->nentry += n;\n\t}\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define STATENTRYHDRSZ\t(offsetof(StatEntry, lexeme))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define STATENTRYHDRSZ\t(offsetof(StatEntry, lexeme))\n\nstatic void\ninsertStatEntry(MemoryContext persistentContext, TSVectorStat *stat, TSVector txt, uint32 off)\n{\n\tWordEntry  *we = ARRPTR(txt) + off;\n\tStatEntry  *node = stat->root,\n\t\t\t   *pnode = NULL;\n\tint\t\t\tn,\n\t\t\t\tres = 0;\n\tuint32\t\tdepth = 1;\n\n\tif (stat->weight == 0)\n\t\tn = (we->haspos) ? POSDATALEN(txt, we) : 1;\n\telse\n\t\tn = (we->haspos) ? check_weight(txt, we, stat->weight) : 0;\n\n\tif (n == 0)\n\t\treturn;\t\t\t\t\t/* nothing to insert */\n\n\twhile (node)\n\t{\n\t\tres = compareStatWord(node, we, txt);\n\n\t\tif (res == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpnode = node;\n\t\t\tnode = (res < 0) ? node->left : node->right;\n\t\t}\n\t\tdepth++;\n\t}\n\n\tif (depth > stat->maxdepth)\n\t\tstat->maxdepth = depth;\n\n\tif (node == NULL)\n\t{\n\t\tnode = MemoryContextAlloc(persistentContext, STATENTRYHDRSZ + we->len);\n\t\tnode->left = node->right = NULL;\n\t\tnode->ndoc = 1;\n\t\tnode->nentry = n;\n\t\tnode->lenlexeme = we->len;\n\t\tmemcpy(node->lexeme, STRPTR(txt) + we->pos, node->lenlexeme);\n\n\t\tif (pnode == NULL)\n\t\t{\n\t\t\tstat->root = node;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (res < 0)\n\t\t\t\tpnode->left = node;\n\t\t\telse\n\t\t\t\tpnode->right = node;\n\t\t}\n\n\t}\n\telse\n\t{\n\t\tnode->ndoc++;\n\t\tnode->nentry += n;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "txt"
          ],
          "line": 2140
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetPointer",
          "args": [
            "data"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAllocZero",
          "args": [
            "persistentContext",
            "sizeof(TSVectorStat)"
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocZeroAligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "851-880",
          "snippet": "void *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocZeroAligned(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetLoop(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetTSVector",
          "args": [
            "data"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TSVectorStat *\nts_accum(MemoryContext persistentContext, TSVectorStat *stat, Datum data)\n{\n\tTSVector\ttxt = DatumGetTSVector(data);\n\tuint32\t\ti,\n\t\t\t\tnbit = 0,\n\t\t\t\toffset;\n\n\tif (stat == NULL)\n\t{\t\t\t\t\t\t\t/* Init in first */\n\t\tstat = MemoryContextAllocZero(persistentContext, sizeof(TSVectorStat));\n\t\tstat->maxdepth = 1;\n\t}\n\n\t/* simple check of correctness */\n\tif (txt == NULL || txt->size == 0)\n\t{\n\t\tif (txt && txt != (TSVector) DatumGetPointer(data))\n\t\t\tpfree(txt);\n\t\treturn stat;\n\t}\n\n\ti = txt->size - 1;\n\tfor (; i > 0; i >>= 1)\n\t\tnbit++;\n\n\tnbit = 1 << nbit;\n\toffset = (nbit - txt->size) / 2;\n\n\tinsertStatEntry(persistentContext, stat, txt, (nbit >> 1) - offset);\n\tchooseNextStatEntry(persistentContext, stat, txt, 0, nbit, offset);\n\n\treturn stat;\n}"
  },
  {
    "function_name": "chooseNextStatEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "2090-2108",
    "snippet": "static void\nchooseNextStatEntry(MemoryContext persistentContext, TSVectorStat *stat, TSVector txt,\n\t\t\t\t\tuint32 low, uint32 high, uint32 offset)\n{\n\tuint32\t\tpos;\n\tuint32\t\tmiddle = (low + high) >> 1;\n\n\tpos = (low + middle) >> 1;\n\tif (low != middle && pos >= offset && pos - offset < txt->size)\n\t\tinsertStatEntry(persistentContext, stat, txt, pos - offset);\n\tpos = (high + middle + 1) >> 1;\n\tif (middle + 1 != high && pos >= offset && pos - offset < txt->size)\n\t\tinsertStatEntry(persistentContext, stat, txt, pos - offset);\n\n\tif (low != middle)\n\t\tchooseNextStatEntry(persistentContext, stat, txt, low, middle, offset);\n\tif (high != middle + 1)\n\t\tchooseNextStatEntry(persistentContext, stat, txt, middle + 1, high, offset);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chooseNextStatEntry",
          "args": [
            "persistentContext",
            "stat",
            "txt",
            "middle + 1",
            "high",
            "offset"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "chooseNextStatEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "2090-2108",
          "snippet": "static void\nchooseNextStatEntry(MemoryContext persistentContext, TSVectorStat *stat, TSVector txt,\n\t\t\t\t\tuint32 low, uint32 high, uint32 offset)\n{\n\tuint32\t\tpos;\n\tuint32\t\tmiddle = (low + high) >> 1;\n\n\tpos = (low + middle) >> 1;\n\tif (low != middle && pos >= offset && pos - offset < txt->size)\n\t\tinsertStatEntry(persistentContext, stat, txt, pos - offset);\n\tpos = (high + middle + 1) >> 1;\n\tif (middle + 1 != high && pos >= offset && pos - offset < txt->size)\n\t\tinsertStatEntry(persistentContext, stat, txt, pos - offset);\n\n\tif (low != middle)\n\t\tchooseNextStatEntry(persistentContext, stat, txt, low, middle, offset);\n\tif (high != middle + 1)\n\t\tchooseNextStatEntry(persistentContext, stat, txt, middle + 1, high, offset);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "insertStatEntry",
          "args": [
            "persistentContext",
            "stat",
            "txt",
            "pos - offset"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "insertStatEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "2024-2088",
          "snippet": "static void\ninsertStatEntry(MemoryContext persistentContext, TSVectorStat *stat, TSVector txt, uint32 off)\n{\n\tWordEntry  *we = ARRPTR(txt) + off;\n\tStatEntry  *node = stat->root,\n\t\t\t   *pnode = NULL;\n\tint\t\t\tn,\n\t\t\t\tres = 0;\n\tuint32\t\tdepth = 1;\n\n\tif (stat->weight == 0)\n\t\tn = (we->haspos) ? POSDATALEN(txt, we) : 1;\n\telse\n\t\tn = (we->haspos) ? check_weight(txt, we, stat->weight) : 0;\n\n\tif (n == 0)\n\t\treturn;\t\t\t\t\t/* nothing to insert */\n\n\twhile (node)\n\t{\n\t\tres = compareStatWord(node, we, txt);\n\n\t\tif (res == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpnode = node;\n\t\t\tnode = (res < 0) ? node->left : node->right;\n\t\t}\n\t\tdepth++;\n\t}\n\n\tif (depth > stat->maxdepth)\n\t\tstat->maxdepth = depth;\n\n\tif (node == NULL)\n\t{\n\t\tnode = MemoryContextAlloc(persistentContext, STATENTRYHDRSZ + we->len);\n\t\tnode->left = node->right = NULL;\n\t\tnode->ndoc = 1;\n\t\tnode->nentry = n;\n\t\tnode->lenlexeme = we->len;\n\t\tmemcpy(node->lexeme, STRPTR(txt) + we->pos, node->lenlexeme);\n\n\t\tif (pnode == NULL)\n\t\t{\n\t\t\tstat->root = node;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (res < 0)\n\t\t\t\tpnode->left = node;\n\t\t\telse\n\t\t\t\tpnode->right = node;\n\t\t}\n\n\t}\n\telse\n\t{\n\t\tnode->ndoc++;\n\t\tnode->nentry += n;\n\t}\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define STATENTRYHDRSZ\t(offsetof(StatEntry, lexeme))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define STATENTRYHDRSZ\t(offsetof(StatEntry, lexeme))\n\nstatic void\ninsertStatEntry(MemoryContext persistentContext, TSVectorStat *stat, TSVector txt, uint32 off)\n{\n\tWordEntry  *we = ARRPTR(txt) + off;\n\tStatEntry  *node = stat->root,\n\t\t\t   *pnode = NULL;\n\tint\t\t\tn,\n\t\t\t\tres = 0;\n\tuint32\t\tdepth = 1;\n\n\tif (stat->weight == 0)\n\t\tn = (we->haspos) ? POSDATALEN(txt, we) : 1;\n\telse\n\t\tn = (we->haspos) ? check_weight(txt, we, stat->weight) : 0;\n\n\tif (n == 0)\n\t\treturn;\t\t\t\t\t/* nothing to insert */\n\n\twhile (node)\n\t{\n\t\tres = compareStatWord(node, we, txt);\n\n\t\tif (res == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpnode = node;\n\t\t\tnode = (res < 0) ? node->left : node->right;\n\t\t}\n\t\tdepth++;\n\t}\n\n\tif (depth > stat->maxdepth)\n\t\tstat->maxdepth = depth;\n\n\tif (node == NULL)\n\t{\n\t\tnode = MemoryContextAlloc(persistentContext, STATENTRYHDRSZ + we->len);\n\t\tnode->left = node->right = NULL;\n\t\tnode->ndoc = 1;\n\t\tnode->nentry = n;\n\t\tnode->lenlexeme = we->len;\n\t\tmemcpy(node->lexeme, STRPTR(txt) + we->pos, node->lenlexeme);\n\n\t\tif (pnode == NULL)\n\t\t{\n\t\t\tstat->root = node;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (res < 0)\n\t\t\t\tpnode->left = node;\n\t\t\telse\n\t\t\t\tpnode->right = node;\n\t\t}\n\n\t}\n\telse\n\t{\n\t\tnode->ndoc++;\n\t\tnode->nentry += n;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic void\nchooseNextStatEntry(MemoryContext persistentContext, TSVectorStat *stat, TSVector txt,\n\t\t\t\t\tuint32 low, uint32 high, uint32 offset)\n{\n\tuint32\t\tpos;\n\tuint32\t\tmiddle = (low + high) >> 1;\n\n\tpos = (low + middle) >> 1;\n\tif (low != middle && pos >= offset && pos - offset < txt->size)\n\t\tinsertStatEntry(persistentContext, stat, txt, pos - offset);\n\tpos = (high + middle + 1) >> 1;\n\tif (middle + 1 != high && pos >= offset && pos - offset < txt->size)\n\t\tinsertStatEntry(persistentContext, stat, txt, pos - offset);\n\n\tif (low != middle)\n\t\tchooseNextStatEntry(persistentContext, stat, txt, low, middle, offset);\n\tif (high != middle + 1)\n\t\tchooseNextStatEntry(persistentContext, stat, txt, middle + 1, high, offset);\n}"
  },
  {
    "function_name": "insertStatEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "2024-2088",
    "snippet": "static void\ninsertStatEntry(MemoryContext persistentContext, TSVectorStat *stat, TSVector txt, uint32 off)\n{\n\tWordEntry  *we = ARRPTR(txt) + off;\n\tStatEntry  *node = stat->root,\n\t\t\t   *pnode = NULL;\n\tint\t\t\tn,\n\t\t\t\tres = 0;\n\tuint32\t\tdepth = 1;\n\n\tif (stat->weight == 0)\n\t\tn = (we->haspos) ? POSDATALEN(txt, we) : 1;\n\telse\n\t\tn = (we->haspos) ? check_weight(txt, we, stat->weight) : 0;\n\n\tif (n == 0)\n\t\treturn;\t\t\t\t\t/* nothing to insert */\n\n\twhile (node)\n\t{\n\t\tres = compareStatWord(node, we, txt);\n\n\t\tif (res == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpnode = node;\n\t\t\tnode = (res < 0) ? node->left : node->right;\n\t\t}\n\t\tdepth++;\n\t}\n\n\tif (depth > stat->maxdepth)\n\t\tstat->maxdepth = depth;\n\n\tif (node == NULL)\n\t{\n\t\tnode = MemoryContextAlloc(persistentContext, STATENTRYHDRSZ + we->len);\n\t\tnode->left = node->right = NULL;\n\t\tnode->ndoc = 1;\n\t\tnode->nentry = n;\n\t\tnode->lenlexeme = we->len;\n\t\tmemcpy(node->lexeme, STRPTR(txt) + we->pos, node->lenlexeme);\n\n\t\tif (pnode == NULL)\n\t\t{\n\t\t\tstat->root = node;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (res < 0)\n\t\t\t\tpnode->left = node;\n\t\t\telse\n\t\t\t\tpnode->right = node;\n\t\t}\n\n\t}\n\telse\n\t{\n\t\tnode->ndoc++;\n\t\tnode->nentry += n;\n\t}\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define STATENTRYHDRSZ\t(offsetof(StatEntry, lexeme))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "node->lexeme",
            "STRPTR(txt) + we->pos",
            "node->lenlexeme"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "txt"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextAlloc",
          "args": [
            "persistentContext",
            "STATENTRYHDRSZ + we->len"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextAllocHuge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1079-1106",
          "snippet": "void *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\nMemoryContextAllocHuge(MemoryContext context, Size size)\n{\n\tvoid\t   *ret;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocHugeSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compareStatWord",
          "args": [
            "node",
            "we",
            "txt"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_weight",
          "args": [
            "txt",
            "we",
            "stat->weight"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "check_weight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "2003-2017",
          "snippet": "static int\ncheck_weight(TSVector txt, WordEntry *wptr, int8 weight)\n{\n\tint\t\t\tlen = POSDATALEN(txt, wptr);\n\tint\t\t\tnum = 0;\n\tWordEntryPos *ptr = POSDATAPTR(txt, wptr);\n\n\twhile (len--)\n\t{\n\t\tif (weight & (1 << WEP_GETWEIGHT(*ptr)))\n\t\t\tnum++;\n\t\tptr++;\n\t}\n\treturn num;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\ncheck_weight(TSVector txt, WordEntry *wptr, int8 weight)\n{\n\tint\t\t\tlen = POSDATALEN(txt, wptr);\n\tint\t\t\tnum = 0;\n\tWordEntryPos *ptr = POSDATAPTR(txt, wptr);\n\n\twhile (len--)\n\t{\n\t\tif (weight & (1 << WEP_GETWEIGHT(*ptr)))\n\t\t\tnum++;\n\t\tptr++;\n\t}\n\treturn num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "txt",
            "we"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "txt"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define STATENTRYHDRSZ\t(offsetof(StatEntry, lexeme))\n\nstatic void\ninsertStatEntry(MemoryContext persistentContext, TSVectorStat *stat, TSVector txt, uint32 off)\n{\n\tWordEntry  *we = ARRPTR(txt) + off;\n\tStatEntry  *node = stat->root,\n\t\t\t   *pnode = NULL;\n\tint\t\t\tn,\n\t\t\t\tres = 0;\n\tuint32\t\tdepth = 1;\n\n\tif (stat->weight == 0)\n\t\tn = (we->haspos) ? POSDATALEN(txt, we) : 1;\n\telse\n\t\tn = (we->haspos) ? check_weight(txt, we, stat->weight) : 0;\n\n\tif (n == 0)\n\t\treturn;\t\t\t\t\t/* nothing to insert */\n\n\twhile (node)\n\t{\n\t\tres = compareStatWord(node, we, txt);\n\n\t\tif (res == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpnode = node;\n\t\t\tnode = (res < 0) ? node->left : node->right;\n\t\t}\n\t\tdepth++;\n\t}\n\n\tif (depth > stat->maxdepth)\n\t\tstat->maxdepth = depth;\n\n\tif (node == NULL)\n\t{\n\t\tnode = MemoryContextAlloc(persistentContext, STATENTRYHDRSZ + we->len);\n\t\tnode->left = node->right = NULL;\n\t\tnode->ndoc = 1;\n\t\tnode->nentry = n;\n\t\tnode->lenlexeme = we->len;\n\t\tmemcpy(node->lexeme, STRPTR(txt) + we->pos, node->lenlexeme);\n\n\t\tif (pnode == NULL)\n\t\t{\n\t\t\tstat->root = node;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (res < 0)\n\t\t\t\tpnode->left = node;\n\t\t\telse\n\t\t\t\tpnode->right = node;\n\t\t}\n\n\t}\n\telse\n\t{\n\t\tnode->ndoc++;\n\t\tnode->nentry += n;\n\t}\n}"
  },
  {
    "function_name": "check_weight",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "2003-2017",
    "snippet": "static int\ncheck_weight(TSVector txt, WordEntry *wptr, int8 weight)\n{\n\tint\t\t\tlen = POSDATALEN(txt, wptr);\n\tint\t\t\tnum = 0;\n\tWordEntryPos *ptr = POSDATAPTR(txt, wptr);\n\n\twhile (len--)\n\t{\n\t\tif (weight & (1 << WEP_GETWEIGHT(*ptr)))\n\t\t\tnum++;\n\t\tptr++;\n\t}\n\treturn num;\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "*ptr"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATAPTR",
          "args": [
            "txt",
            "wptr"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "txt",
            "wptr"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\ncheck_weight(TSVector txt, WordEntry *wptr, int8 weight)\n{\n\tint\t\t\tlen = POSDATALEN(txt, wptr);\n\tint\t\t\tnum = 0;\n\tWordEntryPos *ptr = POSDATAPTR(txt, wptr);\n\n\twhile (len--)\n\t{\n\t\tif (weight & (1 << WEP_GETWEIGHT(*ptr)))\n\t\t\tnum++;\n\t\tptr++;\n\t}\n\treturn num;\n}"
  },
  {
    "function_name": "ts_match_tq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "1974-1992",
    "snippet": "Datum\nts_match_tq(PG_FUNCTION_ARGS)\n{\n\tTSVector\tvector;\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(1);\n\tbool\t\tres;\n\n\tvector = DatumGetTSVector(DirectFunctionCall1(to_tsvector,\n\t\t\t\t\t\t\t\t\t\t\t\t  PG_GETARG_DATUM(0)));\n\n\tres = DatumGetBool(DirectFunctionCall2(ts_match_vq,\n\t\t\t\t\t\t\t\t\t\t   TSVectorGetDatum(vector),\n\t\t\t\t\t\t\t\t\t\t   TSQueryGetDatum(query)));\n\n\tpfree(vector);\n\tPG_FREE_IF_COPY(query, 1);\n\n\tPG_RETURN_BOOL(res);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "query",
            "1"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "vector"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(ts_match_vq,\n\t\t\t\t\t\t\t\t\t\t   TSVectorGetDatum(vector),\n\t\t\t\t\t\t\t\t\t\t   TSQueryGetDatum(query))"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "ts_match_vq",
            "TSVectorGetDatum(vector)",
            "TSQueryGetDatum(query)"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSQueryGetDatum",
          "args": [
            "query"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSVectorGetDatum",
          "args": [
            "vector"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTSVector",
          "args": [
            "DirectFunctionCall1(to_tsvector,\n\t\t\t\t\t\t\t\t\t\t\t\t  PG_GETARG_DATUM(0))"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "to_tsvector",
            "PG_GETARG_DATUM(0)"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "1"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\nts_match_tq(PG_FUNCTION_ARGS)\n{\n\tTSVector\tvector;\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(1);\n\tbool\t\tres;\n\n\tvector = DatumGetTSVector(DirectFunctionCall1(to_tsvector,\n\t\t\t\t\t\t\t\t\t\t\t\t  PG_GETARG_DATUM(0)));\n\n\tres = DatumGetBool(DirectFunctionCall2(ts_match_vq,\n\t\t\t\t\t\t\t\t\t\t   TSVectorGetDatum(vector),\n\t\t\t\t\t\t\t\t\t\t   TSQueryGetDatum(query)));\n\n\tpfree(vector);\n\tPG_FREE_IF_COPY(query, 1);\n\n\tPG_RETURN_BOOL(res);\n}"
  },
  {
    "function_name": "ts_match_tt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "1952-1972",
    "snippet": "Datum\nts_match_tt(PG_FUNCTION_ARGS)\n{\n\tTSVector\tvector;\n\tTSQuery\t\tquery;\n\tbool\t\tres;\n\n\tvector = DatumGetTSVector(DirectFunctionCall1(to_tsvector,\n\t\t\t\t\t\t\t\t\t\t\t\t  PG_GETARG_DATUM(0)));\n\tquery = DatumGetTSQuery(DirectFunctionCall1(plainto_tsquery,\n\t\t\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(1)));\n\n\tres = DatumGetBool(DirectFunctionCall2(ts_match_vq,\n\t\t\t\t\t\t\t\t\t\t   TSVectorGetDatum(vector),\n\t\t\t\t\t\t\t\t\t\t   TSQueryGetDatum(query)));\n\n\tpfree(vector);\n\tpfree(query);\n\n\tPG_RETURN_BOOL(res);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "res"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "query"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetBool",
          "args": [
            "DirectFunctionCall2(ts_match_vq,\n\t\t\t\t\t\t\t\t\t\t   TSVectorGetDatum(vector),\n\t\t\t\t\t\t\t\t\t\t   TSQueryGetDatum(query))"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "ts_match_vq",
            "TSVectorGetDatum(vector)",
            "TSQueryGetDatum(query)"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSQueryGetDatum",
          "args": [
            "query"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSVectorGetDatum",
          "args": [
            "vector"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTSQuery",
          "args": [
            "DirectFunctionCall1(plainto_tsquery,\n\t\t\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(1))"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "plainto_tsquery",
            "PG_GETARG_DATUM(1)"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DatumGetTSVector",
          "args": [
            "DirectFunctionCall1(to_tsvector,\n\t\t\t\t\t\t\t\t\t\t\t\t  PG_GETARG_DATUM(0))"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall1",
          "args": [
            "to_tsvector",
            "PG_GETARG_DATUM(0)"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\nts_match_tt(PG_FUNCTION_ARGS)\n{\n\tTSVector\tvector;\n\tTSQuery\t\tquery;\n\tbool\t\tres;\n\n\tvector = DatumGetTSVector(DirectFunctionCall1(to_tsvector,\n\t\t\t\t\t\t\t\t\t\t\t\t  PG_GETARG_DATUM(0)));\n\tquery = DatumGetTSQuery(DirectFunctionCall1(plainto_tsquery,\n\t\t\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(1)));\n\n\tres = DatumGetBool(DirectFunctionCall2(ts_match_vq,\n\t\t\t\t\t\t\t\t\t\t   TSVectorGetDatum(vector),\n\t\t\t\t\t\t\t\t\t\t   TSQueryGetDatum(query)));\n\n\tpfree(vector);\n\tpfree(query);\n\n\tPG_RETURN_BOOL(res);\n}"
  },
  {
    "function_name": "ts_match_vq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "1922-1950",
    "snippet": "Datum\nts_match_vq(PG_FUNCTION_ARGS)\n{\n\tTSVector\tval = PG_GETARG_TSVECTOR(0);\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(1);\n\tCHKVAL\t\tchkval;\n\tbool\t\tresult;\n\n\t/* empty query matches nothing */\n\tif (!query->size)\n\t{\n\t\tPG_FREE_IF_COPY(val, 0);\n\t\tPG_FREE_IF_COPY(query, 1);\n\t\tPG_RETURN_BOOL(false);\n\t}\n\n\tchkval.arrb = ARRPTR(val);\n\tchkval.arre = chkval.arrb + val->size;\n\tchkval.values = STRPTR(val);\n\tchkval.operand = GETOPERAND(query);\n\tresult = TS_execute(GETQUERY(query),\n\t\t\t\t\t\t&chkval,\n\t\t\t\t\t\tTS_EXEC_CALC_NOT,\n\t\t\t\t\t\tcheckcondition_str);\n\n\tPG_FREE_IF_COPY(val, 0);\n\tPG_FREE_IF_COPY(query, 1);\n\tPG_RETURN_BOOL(result);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "result"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "query",
            "1"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "val",
            "0"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS_execute",
          "args": [
            "GETQUERY(query)",
            "&chkval",
            "TS_EXEC_CALC_NOT",
            "checkcondition_str"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "TS_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "1814-1854",
          "snippet": "bool\nTS_execute(QueryItem *curitem, void *arg, uint32 flags,\n\t\t   TSExecuteCallback chkcond)\n{\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn chkcond(arg, (QueryOperand *) curitem,\n\t\t\t\t\t   NULL /* we don't need position info */ );\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\t\t\tif (flags & TS_EXEC_CALC_NOT)\n\t\t\t\treturn !TS_execute(curitem + 1, arg, flags, chkcond);\n\t\t\telse\n\t\t\t\treturn true;\n\n\t\tcase OP_AND:\n\t\t\tif (TS_execute(curitem + curitem->qoperator.left, arg, flags, chkcond))\n\t\t\t\treturn TS_execute(curitem + 1, arg, flags, chkcond);\n\t\t\telse\n\t\t\t\treturn false;\n\n\t\tcase OP_OR:\n\t\t\tif (TS_execute(curitem + curitem->qoperator.left, arg, flags, chkcond))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn TS_execute(curitem + 1, arg, flags, chkcond);\n\n\t\tcase OP_PHRASE:\n\t\t\treturn TS_phrase_execute(curitem, arg, flags, chkcond, NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nbool\nTS_execute(QueryItem *curitem, void *arg, uint32 flags,\n\t\t   TSExecuteCallback chkcond)\n{\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn chkcond(arg, (QueryOperand *) curitem,\n\t\t\t\t\t   NULL /* we don't need position info */ );\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\t\t\tif (flags & TS_EXEC_CALC_NOT)\n\t\t\t\treturn !TS_execute(curitem + 1, arg, flags, chkcond);\n\t\t\telse\n\t\t\t\treturn true;\n\n\t\tcase OP_AND:\n\t\t\tif (TS_execute(curitem + curitem->qoperator.left, arg, flags, chkcond))\n\t\t\t\treturn TS_execute(curitem + 1, arg, flags, chkcond);\n\t\t\telse\n\t\t\t\treturn false;\n\n\t\tcase OP_OR:\n\t\t\tif (TS_execute(curitem + curitem->qoperator.left, arg, flags, chkcond))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn TS_execute(curitem + 1, arg, flags, chkcond);\n\n\t\tcase OP_PHRASE:\n\t\t\treturn TS_phrase_execute(curitem, arg, flags, chkcond, NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GETQUERY",
          "args": [
            "query"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GETOPERAND",
          "args": [
            "query"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "val"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "val"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RETURN_BOOL",
          "args": [
            "false"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "query",
            "1"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "val",
            "0"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSQUERY",
          "args": [
            "1"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "0"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\nts_match_vq(PG_FUNCTION_ARGS)\n{\n\tTSVector\tval = PG_GETARG_TSVECTOR(0);\n\tTSQuery\t\tquery = PG_GETARG_TSQUERY(1);\n\tCHKVAL\t\tchkval;\n\tbool\t\tresult;\n\n\t/* empty query matches nothing */\n\tif (!query->size)\n\t{\n\t\tPG_FREE_IF_COPY(val, 0);\n\t\tPG_FREE_IF_COPY(query, 1);\n\t\tPG_RETURN_BOOL(false);\n\t}\n\n\tchkval.arrb = ARRPTR(val);\n\tchkval.arre = chkval.arrb + val->size;\n\tchkval.values = STRPTR(val);\n\tchkval.operand = GETOPERAND(query);\n\tresult = TS_execute(GETQUERY(query),\n\t\t\t\t\t\t&chkval,\n\t\t\t\t\t\tTS_EXEC_CALC_NOT,\n\t\t\t\t\t\tcheckcondition_str);\n\n\tPG_FREE_IF_COPY(val, 0);\n\tPG_FREE_IF_COPY(query, 1);\n\tPG_RETURN_BOOL(result);\n}"
  },
  {
    "function_name": "ts_match_qv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "1914-1920",
    "snippet": "Datum\nts_match_qv(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_DATUM(DirectFunctionCall2(ts_match_vq,\n\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(1),\n\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(0)));\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_DATUM",
          "args": [
            "DirectFunctionCall2(ts_match_vq,\n\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(1),\n\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(0))"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DirectFunctionCall2",
          "args": [
            "ts_match_vq",
            "PG_GETARG_DATUM(1)",
            "PG_GETARG_DATUM(0)"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "0"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_DATUM",
          "args": [
            "1"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\nts_match_qv(PG_FUNCTION_ARGS)\n{\n\tPG_RETURN_DATUM(DirectFunctionCall2(ts_match_vq,\n\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(1),\n\t\t\t\t\t\t\t\t\t\tPG_GETARG_DATUM(0)));\n}"
  },
  {
    "function_name": "tsquery_requires_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "1864-1909",
    "snippet": "bool\ntsquery_requires_match(QueryItem *curitem)\n{\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn true;\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\n\t\t\t/*\n\t\t\t * Assume there are no required matches underneath a NOT.  For\n\t\t\t * some cases with nested NOTs, we could prove there's a required\n\t\t\t * match, but it seems unlikely to be worth the trouble.\n\t\t\t */\n\t\t\treturn false;\n\n\t\tcase OP_PHRASE:\n\n\t\t\t/*\n\t\t\t * Treat OP_PHRASE as OP_AND here\n\t\t\t */\n\t\tcase OP_AND:\n\t\t\t/* If either side requires a match, we're good */\n\t\t\tif (tsquery_requires_match(curitem + curitem->qoperator.left))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn tsquery_requires_match(curitem + 1);\n\n\t\tcase OP_OR:\n\t\t\t/* Both sides must require a match */\n\t\t\tif (tsquery_requires_match(curitem + curitem->qoperator.left))\n\t\t\t\treturn tsquery_requires_match(curitem + 1);\n\t\t\telse\n\t\t\t\treturn false;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized operator: %d\"",
            "curitem->qoperator.oper"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsquery_requires_match",
          "args": [
            "curitem + 1"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "tsquery_requires_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "1864-1909",
          "snippet": "bool\ntsquery_requires_match(QueryItem *curitem)\n{\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn true;\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\n\t\t\t/*\n\t\t\t * Assume there are no required matches underneath a NOT.  For\n\t\t\t * some cases with nested NOTs, we could prove there's a required\n\t\t\t * match, but it seems unlikely to be worth the trouble.\n\t\t\t */\n\t\t\treturn false;\n\n\t\tcase OP_PHRASE:\n\n\t\t\t/*\n\t\t\t * Treat OP_PHRASE as OP_AND here\n\t\t\t */\n\t\tcase OP_AND:\n\t\t\t/* If either side requires a match, we're good */\n\t\t\tif (tsquery_requires_match(curitem + curitem->qoperator.left))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn tsquery_requires_match(curitem + 1);\n\n\t\tcase OP_OR:\n\t\t\t/* Both sides must require a match */\n\t\t\tif (tsquery_requires_match(curitem + curitem->qoperator.left))\n\t\t\t\treturn tsquery_requires_match(curitem + 1);\n\t\t\telse\n\t\t\t\treturn false;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nbool\ntsquery_requires_match(QueryItem *curitem)\n{\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn true;\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\n\t\t\t/*\n\t\t\t * Assume there are no required matches underneath a NOT.  For\n\t\t\t * some cases with nested NOTs, we could prove there's a required\n\t\t\t * match, but it seems unlikely to be worth the trouble.\n\t\t\t */\n\t\t\treturn false;\n\n\t\tcase OP_PHRASE:\n\n\t\t\t/*\n\t\t\t * Treat OP_PHRASE as OP_AND here\n\t\t\t */\n\t\tcase OP_AND:\n\t\t\t/* If either side requires a match, we're good */\n\t\t\tif (tsquery_requires_match(curitem + curitem->qoperator.left))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn tsquery_requires_match(curitem + 1);\n\n\t\tcase OP_OR:\n\t\t\t/* Both sides must require a match */\n\t\t\tif (tsquery_requires_match(curitem + curitem->qoperator.left))\n\t\t\t\treturn tsquery_requires_match(curitem + 1);\n\t\t\telse\n\t\t\t\treturn false;\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}"
  },
  {
    "function_name": "TS_execute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "1814-1854",
    "snippet": "bool\nTS_execute(QueryItem *curitem, void *arg, uint32 flags,\n\t\t   TSExecuteCallback chkcond)\n{\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn chkcond(arg, (QueryOperand *) curitem,\n\t\t\t\t\t   NULL /* we don't need position info */ );\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\t\t\tif (flags & TS_EXEC_CALC_NOT)\n\t\t\t\treturn !TS_execute(curitem + 1, arg, flags, chkcond);\n\t\t\telse\n\t\t\t\treturn true;\n\n\t\tcase OP_AND:\n\t\t\tif (TS_execute(curitem + curitem->qoperator.left, arg, flags, chkcond))\n\t\t\t\treturn TS_execute(curitem + 1, arg, flags, chkcond);\n\t\t\telse\n\t\t\t\treturn false;\n\n\t\tcase OP_OR:\n\t\t\tif (TS_execute(curitem + curitem->qoperator.left, arg, flags, chkcond))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn TS_execute(curitem + 1, arg, flags, chkcond);\n\n\t\tcase OP_PHRASE:\n\t\t\treturn TS_phrase_execute(curitem, arg, flags, chkcond, NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized operator: %d\"",
            "curitem->qoperator.oper"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TS_phrase_execute",
          "args": [
            "curitem",
            "arg",
            "flags",
            "chkcond",
            "NULL"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "TS_phrase_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "1571-1799",
          "snippet": "static bool\nTS_phrase_execute(QueryItem *curitem, void *arg, uint32 flags,\n\t\t\t\t  TSExecuteCallback chkcond,\n\t\t\t\t  ExecPhraseData *data)\n{\n\tExecPhraseData Ldata,\n\t\t\t\tRdata;\n\tbool\t\tlmatch,\n\t\t\t\trmatch;\n\tint\t\t\tLoffset,\n\t\t\t\tRoffset,\n\t\t\t\tmaxwidth;\n\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn chkcond(arg, (QueryOperand *) curitem, data);\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\n\t\t\t/*\n\t\t\t * Because a \"true\" result with no specific positions is taken as\n\t\t\t * uncertain, we need no special care here for !TS_EXEC_CALC_NOT.\n\t\t\t * If it's a false positive, the right things happen anyway.\n\t\t\t *\n\t\t\t * Also, we need not touch data->width, since a NOT operation does\n\t\t\t * not change the match width.\n\t\t\t */\n\t\t\tif (TS_phrase_execute(curitem + 1, arg, flags, chkcond, data))\n\t\t\t{\n\t\t\t\tif (data->npos > 0)\n\t\t\t\t{\n\t\t\t\t\t/* we have some positions, invert negate flag */\n\t\t\t\t\tdata->negate = !data->negate;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (data->negate)\n\t\t\t\t{\n\t\t\t\t\t/* change \"match everywhere\" to \"match nowhere\" */\n\t\t\t\t\tdata->negate = false;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/* match positions are, and remain, uncertain */\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* change \"match nowhere\" to \"match everywhere\" */\n\t\t\t\tAssert(data->npos == 0 && !data->negate);\n\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\tcase OP_PHRASE:\n\t\tcase OP_AND:\n\t\t\tmemset(&Ldata, 0, sizeof(Ldata));\n\t\t\tmemset(&Rdata, 0, sizeof(Rdata));\n\n\t\t\tif (!TS_phrase_execute(curitem + curitem->qoperator.left,\n\t\t\t\t\t\t\t\t   arg, flags, chkcond, &Ldata))\n\t\t\t\treturn false;\n\n\t\t\tif (!TS_phrase_execute(curitem + 1,\n\t\t\t\t\t\t\t\t   arg, flags, chkcond, &Rdata))\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * If either operand has no position information, then we can't\n\t\t\t * return position data, only a \"possible match\" result. \"Possible\n\t\t\t * match\" answers are only wanted when TS_EXEC_PHRASE_NO_POS flag\n\t\t\t * is set, otherwise return false.\n\t\t\t */\n\t\t\tif ((Ldata.npos == 0 && !Ldata.negate) ||\n\t\t\t\t(Rdata.npos == 0 && !Rdata.negate))\n\t\t\t\treturn (flags & TS_EXEC_PHRASE_NO_POS) ? true : false;\n\n\t\t\tif (curitem->qoperator.oper == OP_PHRASE)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Compute Loffset and Roffset suitable for phrase match, and\n\t\t\t\t * compute overall width of whole phrase match.\n\t\t\t\t */\n\t\t\t\tLoffset = curitem->qoperator.distance + Rdata.width;\n\t\t\t\tRoffset = 0;\n\t\t\t\tif (data)\n\t\t\t\t\tdata->width = curitem->qoperator.distance +\n\t\t\t\t\t\tLdata.width + Rdata.width;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For OP_AND, set output width and alignment like OP_OR (see\n\t\t\t\t * comment below)\n\t\t\t\t */\n\t\t\t\tmaxwidth = Max(Ldata.width, Rdata.width);\n\t\t\t\tLoffset = maxwidth - Ldata.width;\n\t\t\t\tRoffset = maxwidth - Rdata.width;\n\t\t\t\tif (data)\n\t\t\t\t\tdata->width = maxwidth;\n\t\t\t}\n\n\t\t\tif (Ldata.negate && Rdata.negate)\n\t\t\t{\n\t\t\t\t/* !L & !R: treat as !(L | R) */\n\t\t\t\t(void) TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_BOTH | TSPO_L_ONLY | TSPO_R_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tLdata.npos + Rdata.npos);\n\t\t\t\tif (data)\n\t\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (Ldata.negate)\n\t\t\t{\n\t\t\t\t/* !L & R */\n\t\t\t\treturn TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_R_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tRdata.npos);\n\t\t\t}\n\t\t\telse if (Rdata.negate)\n\t\t\t{\n\t\t\t\t/* L & !R */\n\t\t\t\treturn TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_L_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tLdata.npos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* straight AND */\n\t\t\t\treturn TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_BOTH,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tMin(Ldata.npos, Rdata.npos));\n\t\t\t}\n\n\t\tcase OP_OR:\n\t\t\tmemset(&Ldata, 0, sizeof(Ldata));\n\t\t\tmemset(&Rdata, 0, sizeof(Rdata));\n\n\t\t\tlmatch = TS_phrase_execute(curitem + curitem->qoperator.left,\n\t\t\t\t\t\t\t\t\t   arg, flags, chkcond, &Ldata);\n\t\t\trmatch = TS_phrase_execute(curitem + 1,\n\t\t\t\t\t\t\t\t\t   arg, flags, chkcond, &Rdata);\n\n\t\t\tif (!lmatch && !rmatch)\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * If a valid operand has no position information, then we can't\n\t\t\t * return position data, only a \"possible match\" result. \"Possible\n\t\t\t * match\" answers are only wanted when TS_EXEC_PHRASE_NO_POS flag\n\t\t\t * is set, otherwise return false.\n\t\t\t */\n\t\t\tif ((lmatch && Ldata.npos == 0 && !Ldata.negate) ||\n\t\t\t\t(rmatch && Rdata.npos == 0 && !Rdata.negate))\n\t\t\t\treturn (flags & TS_EXEC_PHRASE_NO_POS) ? true : false;\n\n\t\t\t/*\n\t\t\t * Cope with undefined output width from failed submatch.  (This\n\t\t\t * takes less code than trying to ensure that all failure returns\n\t\t\t * set data->width to zero.)\n\t\t\t */\n\t\t\tif (!lmatch)\n\t\t\t\tLdata.width = 0;\n\t\t\tif (!rmatch)\n\t\t\t\tRdata.width = 0;\n\n\t\t\t/*\n\t\t\t * For OP_AND and OP_OR, report the width of the wider of the two\n\t\t\t * inputs, and align the narrower input's positions to the right\n\t\t\t * end of that width.  This rule deals at least somewhat\n\t\t\t * reasonably with cases like \"x <-> (y | z <-> q)\".\n\t\t\t */\n\t\t\tmaxwidth = Max(Ldata.width, Rdata.width);\n\t\t\tLoffset = maxwidth - Ldata.width;\n\t\t\tRoffset = maxwidth - Rdata.width;\n\t\t\tdata->width = maxwidth;\n\n\t\t\tif (Ldata.negate && Rdata.negate)\n\t\t\t{\n\t\t\t\t/* !L | !R: treat as !(L & R) */\n\t\t\t\t(void) TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_BOTH,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tMin(Ldata.npos, Rdata.npos));\n\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (Ldata.negate)\n\t\t\t{\n\t\t\t\t/* !L | R: treat as !(L & !R) */\n\t\t\t\t(void) TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_L_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tLdata.npos);\n\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (Rdata.negate)\n\t\t\t{\n\t\t\t\t/* L | !R: treat as !(!L & R) */\n\t\t\t\t(void) TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_R_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tRdata.npos);\n\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* straight OR */\n\t\t\t\treturn TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_BOTH | TSPO_L_ONLY | TSPO_R_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tLdata.npos + Rdata.npos);\n\t\t\t}\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TSPO_BOTH\t\t0x04\t/* emit positions appearing in both L&R */",
            "#define TSPO_R_ONLY\t\t0x02\t/* emit positions appearing only in R */",
            "#define TSPO_L_ONLY\t\t0x01\t/* emit positions appearing only in L */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TSPO_BOTH\t\t0x04\t/* emit positions appearing in both L&R */\n#define TSPO_R_ONLY\t\t0x02\t/* emit positions appearing only in R */\n#define TSPO_L_ONLY\t\t0x01\t/* emit positions appearing only in L */\n\nstatic bool\nTS_phrase_execute(QueryItem *curitem, void *arg, uint32 flags,\n\t\t\t\t  TSExecuteCallback chkcond,\n\t\t\t\t  ExecPhraseData *data)\n{\n\tExecPhraseData Ldata,\n\t\t\t\tRdata;\n\tbool\t\tlmatch,\n\t\t\t\trmatch;\n\tint\t\t\tLoffset,\n\t\t\t\tRoffset,\n\t\t\t\tmaxwidth;\n\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn chkcond(arg, (QueryOperand *) curitem, data);\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\n\t\t\t/*\n\t\t\t * Because a \"true\" result with no specific positions is taken as\n\t\t\t * uncertain, we need no special care here for !TS_EXEC_CALC_NOT.\n\t\t\t * If it's a false positive, the right things happen anyway.\n\t\t\t *\n\t\t\t * Also, we need not touch data->width, since a NOT operation does\n\t\t\t * not change the match width.\n\t\t\t */\n\t\t\tif (TS_phrase_execute(curitem + 1, arg, flags, chkcond, data))\n\t\t\t{\n\t\t\t\tif (data->npos > 0)\n\t\t\t\t{\n\t\t\t\t\t/* we have some positions, invert negate flag */\n\t\t\t\t\tdata->negate = !data->negate;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (data->negate)\n\t\t\t\t{\n\t\t\t\t\t/* change \"match everywhere\" to \"match nowhere\" */\n\t\t\t\t\tdata->negate = false;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/* match positions are, and remain, uncertain */\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* change \"match nowhere\" to \"match everywhere\" */\n\t\t\t\tAssert(data->npos == 0 && !data->negate);\n\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\tcase OP_PHRASE:\n\t\tcase OP_AND:\n\t\t\tmemset(&Ldata, 0, sizeof(Ldata));\n\t\t\tmemset(&Rdata, 0, sizeof(Rdata));\n\n\t\t\tif (!TS_phrase_execute(curitem + curitem->qoperator.left,\n\t\t\t\t\t\t\t\t   arg, flags, chkcond, &Ldata))\n\t\t\t\treturn false;\n\n\t\t\tif (!TS_phrase_execute(curitem + 1,\n\t\t\t\t\t\t\t\t   arg, flags, chkcond, &Rdata))\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * If either operand has no position information, then we can't\n\t\t\t * return position data, only a \"possible match\" result. \"Possible\n\t\t\t * match\" answers are only wanted when TS_EXEC_PHRASE_NO_POS flag\n\t\t\t * is set, otherwise return false.\n\t\t\t */\n\t\t\tif ((Ldata.npos == 0 && !Ldata.negate) ||\n\t\t\t\t(Rdata.npos == 0 && !Rdata.negate))\n\t\t\t\treturn (flags & TS_EXEC_PHRASE_NO_POS) ? true : false;\n\n\t\t\tif (curitem->qoperator.oper == OP_PHRASE)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Compute Loffset and Roffset suitable for phrase match, and\n\t\t\t\t * compute overall width of whole phrase match.\n\t\t\t\t */\n\t\t\t\tLoffset = curitem->qoperator.distance + Rdata.width;\n\t\t\t\tRoffset = 0;\n\t\t\t\tif (data)\n\t\t\t\t\tdata->width = curitem->qoperator.distance +\n\t\t\t\t\t\tLdata.width + Rdata.width;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For OP_AND, set output width and alignment like OP_OR (see\n\t\t\t\t * comment below)\n\t\t\t\t */\n\t\t\t\tmaxwidth = Max(Ldata.width, Rdata.width);\n\t\t\t\tLoffset = maxwidth - Ldata.width;\n\t\t\t\tRoffset = maxwidth - Rdata.width;\n\t\t\t\tif (data)\n\t\t\t\t\tdata->width = maxwidth;\n\t\t\t}\n\n\t\t\tif (Ldata.negate && Rdata.negate)\n\t\t\t{\n\t\t\t\t/* !L & !R: treat as !(L | R) */\n\t\t\t\t(void) TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_BOTH | TSPO_L_ONLY | TSPO_R_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tLdata.npos + Rdata.npos);\n\t\t\t\tif (data)\n\t\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (Ldata.negate)\n\t\t\t{\n\t\t\t\t/* !L & R */\n\t\t\t\treturn TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_R_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tRdata.npos);\n\t\t\t}\n\t\t\telse if (Rdata.negate)\n\t\t\t{\n\t\t\t\t/* L & !R */\n\t\t\t\treturn TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_L_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tLdata.npos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* straight AND */\n\t\t\t\treturn TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_BOTH,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tMin(Ldata.npos, Rdata.npos));\n\t\t\t}\n\n\t\tcase OP_OR:\n\t\t\tmemset(&Ldata, 0, sizeof(Ldata));\n\t\t\tmemset(&Rdata, 0, sizeof(Rdata));\n\n\t\t\tlmatch = TS_phrase_execute(curitem + curitem->qoperator.left,\n\t\t\t\t\t\t\t\t\t   arg, flags, chkcond, &Ldata);\n\t\t\trmatch = TS_phrase_execute(curitem + 1,\n\t\t\t\t\t\t\t\t\t   arg, flags, chkcond, &Rdata);\n\n\t\t\tif (!lmatch && !rmatch)\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * If a valid operand has no position information, then we can't\n\t\t\t * return position data, only a \"possible match\" result. \"Possible\n\t\t\t * match\" answers are only wanted when TS_EXEC_PHRASE_NO_POS flag\n\t\t\t * is set, otherwise return false.\n\t\t\t */\n\t\t\tif ((lmatch && Ldata.npos == 0 && !Ldata.negate) ||\n\t\t\t\t(rmatch && Rdata.npos == 0 && !Rdata.negate))\n\t\t\t\treturn (flags & TS_EXEC_PHRASE_NO_POS) ? true : false;\n\n\t\t\t/*\n\t\t\t * Cope with undefined output width from failed submatch.  (This\n\t\t\t * takes less code than trying to ensure that all failure returns\n\t\t\t * set data->width to zero.)\n\t\t\t */\n\t\t\tif (!lmatch)\n\t\t\t\tLdata.width = 0;\n\t\t\tif (!rmatch)\n\t\t\t\tRdata.width = 0;\n\n\t\t\t/*\n\t\t\t * For OP_AND and OP_OR, report the width of the wider of the two\n\t\t\t * inputs, and align the narrower input's positions to the right\n\t\t\t * end of that width.  This rule deals at least somewhat\n\t\t\t * reasonably with cases like \"x <-> (y | z <-> q)\".\n\t\t\t */\n\t\t\tmaxwidth = Max(Ldata.width, Rdata.width);\n\t\t\tLoffset = maxwidth - Ldata.width;\n\t\t\tRoffset = maxwidth - Rdata.width;\n\t\t\tdata->width = maxwidth;\n\n\t\t\tif (Ldata.negate && Rdata.negate)\n\t\t\t{\n\t\t\t\t/* !L | !R: treat as !(L & R) */\n\t\t\t\t(void) TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_BOTH,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tMin(Ldata.npos, Rdata.npos));\n\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (Ldata.negate)\n\t\t\t{\n\t\t\t\t/* !L | R: treat as !(L & !R) */\n\t\t\t\t(void) TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_L_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tLdata.npos);\n\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (Rdata.negate)\n\t\t\t{\n\t\t\t\t/* L | !R: treat as !(!L & R) */\n\t\t\t\t(void) TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_R_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tRdata.npos);\n\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* straight OR */\n\t\t\t\treturn TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_BOTH | TSPO_L_ONLY | TSPO_R_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tLdata.npos + Rdata.npos);\n\t\t\t}\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TS_execute",
          "args": [
            "curitem + 1",
            "arg",
            "flags",
            "chkcond"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "TS_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "1814-1854",
          "snippet": "bool\nTS_execute(QueryItem *curitem, void *arg, uint32 flags,\n\t\t   TSExecuteCallback chkcond)\n{\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn chkcond(arg, (QueryOperand *) curitem,\n\t\t\t\t\t   NULL /* we don't need position info */ );\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\t\t\tif (flags & TS_EXEC_CALC_NOT)\n\t\t\t\treturn !TS_execute(curitem + 1, arg, flags, chkcond);\n\t\t\telse\n\t\t\t\treturn true;\n\n\t\tcase OP_AND:\n\t\t\tif (TS_execute(curitem + curitem->qoperator.left, arg, flags, chkcond))\n\t\t\t\treturn TS_execute(curitem + 1, arg, flags, chkcond);\n\t\t\telse\n\t\t\t\treturn false;\n\n\t\tcase OP_OR:\n\t\t\tif (TS_execute(curitem + curitem->qoperator.left, arg, flags, chkcond))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn TS_execute(curitem + 1, arg, flags, chkcond);\n\n\t\tcase OP_PHRASE:\n\t\t\treturn TS_phrase_execute(curitem, arg, flags, chkcond, NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "chkcond",
          "args": [
            "arg",
            "(QueryOperand *) curitem",
            "NULL/* we don't need position info */"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nbool\nTS_execute(QueryItem *curitem, void *arg, uint32 flags,\n\t\t   TSExecuteCallback chkcond)\n{\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn chkcond(arg, (QueryOperand *) curitem,\n\t\t\t\t\t   NULL /* we don't need position info */ );\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\t\t\tif (flags & TS_EXEC_CALC_NOT)\n\t\t\t\treturn !TS_execute(curitem + 1, arg, flags, chkcond);\n\t\t\telse\n\t\t\t\treturn true;\n\n\t\tcase OP_AND:\n\t\t\tif (TS_execute(curitem + curitem->qoperator.left, arg, flags, chkcond))\n\t\t\t\treturn TS_execute(curitem + 1, arg, flags, chkcond);\n\t\t\telse\n\t\t\t\treturn false;\n\n\t\tcase OP_OR:\n\t\t\tif (TS_execute(curitem + curitem->qoperator.left, arg, flags, chkcond))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn TS_execute(curitem + 1, arg, flags, chkcond);\n\n\t\tcase OP_PHRASE:\n\t\t\treturn TS_phrase_execute(curitem, arg, flags, chkcond, NULL);\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}"
  },
  {
    "function_name": "TS_phrase_execute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "1571-1799",
    "snippet": "static bool\nTS_phrase_execute(QueryItem *curitem, void *arg, uint32 flags,\n\t\t\t\t  TSExecuteCallback chkcond,\n\t\t\t\t  ExecPhraseData *data)\n{\n\tExecPhraseData Ldata,\n\t\t\t\tRdata;\n\tbool\t\tlmatch,\n\t\t\t\trmatch;\n\tint\t\t\tLoffset,\n\t\t\t\tRoffset,\n\t\t\t\tmaxwidth;\n\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn chkcond(arg, (QueryOperand *) curitem, data);\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\n\t\t\t/*\n\t\t\t * Because a \"true\" result with no specific positions is taken as\n\t\t\t * uncertain, we need no special care here for !TS_EXEC_CALC_NOT.\n\t\t\t * If it's a false positive, the right things happen anyway.\n\t\t\t *\n\t\t\t * Also, we need not touch data->width, since a NOT operation does\n\t\t\t * not change the match width.\n\t\t\t */\n\t\t\tif (TS_phrase_execute(curitem + 1, arg, flags, chkcond, data))\n\t\t\t{\n\t\t\t\tif (data->npos > 0)\n\t\t\t\t{\n\t\t\t\t\t/* we have some positions, invert negate flag */\n\t\t\t\t\tdata->negate = !data->negate;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (data->negate)\n\t\t\t\t{\n\t\t\t\t\t/* change \"match everywhere\" to \"match nowhere\" */\n\t\t\t\t\tdata->negate = false;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/* match positions are, and remain, uncertain */\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* change \"match nowhere\" to \"match everywhere\" */\n\t\t\t\tAssert(data->npos == 0 && !data->negate);\n\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\tcase OP_PHRASE:\n\t\tcase OP_AND:\n\t\t\tmemset(&Ldata, 0, sizeof(Ldata));\n\t\t\tmemset(&Rdata, 0, sizeof(Rdata));\n\n\t\t\tif (!TS_phrase_execute(curitem + curitem->qoperator.left,\n\t\t\t\t\t\t\t\t   arg, flags, chkcond, &Ldata))\n\t\t\t\treturn false;\n\n\t\t\tif (!TS_phrase_execute(curitem + 1,\n\t\t\t\t\t\t\t\t   arg, flags, chkcond, &Rdata))\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * If either operand has no position information, then we can't\n\t\t\t * return position data, only a \"possible match\" result. \"Possible\n\t\t\t * match\" answers are only wanted when TS_EXEC_PHRASE_NO_POS flag\n\t\t\t * is set, otherwise return false.\n\t\t\t */\n\t\t\tif ((Ldata.npos == 0 && !Ldata.negate) ||\n\t\t\t\t(Rdata.npos == 0 && !Rdata.negate))\n\t\t\t\treturn (flags & TS_EXEC_PHRASE_NO_POS) ? true : false;\n\n\t\t\tif (curitem->qoperator.oper == OP_PHRASE)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Compute Loffset and Roffset suitable for phrase match, and\n\t\t\t\t * compute overall width of whole phrase match.\n\t\t\t\t */\n\t\t\t\tLoffset = curitem->qoperator.distance + Rdata.width;\n\t\t\t\tRoffset = 0;\n\t\t\t\tif (data)\n\t\t\t\t\tdata->width = curitem->qoperator.distance +\n\t\t\t\t\t\tLdata.width + Rdata.width;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For OP_AND, set output width and alignment like OP_OR (see\n\t\t\t\t * comment below)\n\t\t\t\t */\n\t\t\t\tmaxwidth = Max(Ldata.width, Rdata.width);\n\t\t\t\tLoffset = maxwidth - Ldata.width;\n\t\t\t\tRoffset = maxwidth - Rdata.width;\n\t\t\t\tif (data)\n\t\t\t\t\tdata->width = maxwidth;\n\t\t\t}\n\n\t\t\tif (Ldata.negate && Rdata.negate)\n\t\t\t{\n\t\t\t\t/* !L & !R: treat as !(L | R) */\n\t\t\t\t(void) TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_BOTH | TSPO_L_ONLY | TSPO_R_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tLdata.npos + Rdata.npos);\n\t\t\t\tif (data)\n\t\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (Ldata.negate)\n\t\t\t{\n\t\t\t\t/* !L & R */\n\t\t\t\treturn TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_R_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tRdata.npos);\n\t\t\t}\n\t\t\telse if (Rdata.negate)\n\t\t\t{\n\t\t\t\t/* L & !R */\n\t\t\t\treturn TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_L_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tLdata.npos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* straight AND */\n\t\t\t\treturn TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_BOTH,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tMin(Ldata.npos, Rdata.npos));\n\t\t\t}\n\n\t\tcase OP_OR:\n\t\t\tmemset(&Ldata, 0, sizeof(Ldata));\n\t\t\tmemset(&Rdata, 0, sizeof(Rdata));\n\n\t\t\tlmatch = TS_phrase_execute(curitem + curitem->qoperator.left,\n\t\t\t\t\t\t\t\t\t   arg, flags, chkcond, &Ldata);\n\t\t\trmatch = TS_phrase_execute(curitem + 1,\n\t\t\t\t\t\t\t\t\t   arg, flags, chkcond, &Rdata);\n\n\t\t\tif (!lmatch && !rmatch)\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * If a valid operand has no position information, then we can't\n\t\t\t * return position data, only a \"possible match\" result. \"Possible\n\t\t\t * match\" answers are only wanted when TS_EXEC_PHRASE_NO_POS flag\n\t\t\t * is set, otherwise return false.\n\t\t\t */\n\t\t\tif ((lmatch && Ldata.npos == 0 && !Ldata.negate) ||\n\t\t\t\t(rmatch && Rdata.npos == 0 && !Rdata.negate))\n\t\t\t\treturn (flags & TS_EXEC_PHRASE_NO_POS) ? true : false;\n\n\t\t\t/*\n\t\t\t * Cope with undefined output width from failed submatch.  (This\n\t\t\t * takes less code than trying to ensure that all failure returns\n\t\t\t * set data->width to zero.)\n\t\t\t */\n\t\t\tif (!lmatch)\n\t\t\t\tLdata.width = 0;\n\t\t\tif (!rmatch)\n\t\t\t\tRdata.width = 0;\n\n\t\t\t/*\n\t\t\t * For OP_AND and OP_OR, report the width of the wider of the two\n\t\t\t * inputs, and align the narrower input's positions to the right\n\t\t\t * end of that width.  This rule deals at least somewhat\n\t\t\t * reasonably with cases like \"x <-> (y | z <-> q)\".\n\t\t\t */\n\t\t\tmaxwidth = Max(Ldata.width, Rdata.width);\n\t\t\tLoffset = maxwidth - Ldata.width;\n\t\t\tRoffset = maxwidth - Rdata.width;\n\t\t\tdata->width = maxwidth;\n\n\t\t\tif (Ldata.negate && Rdata.negate)\n\t\t\t{\n\t\t\t\t/* !L | !R: treat as !(L & R) */\n\t\t\t\t(void) TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_BOTH,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tMin(Ldata.npos, Rdata.npos));\n\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (Ldata.negate)\n\t\t\t{\n\t\t\t\t/* !L | R: treat as !(L & !R) */\n\t\t\t\t(void) TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_L_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tLdata.npos);\n\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (Rdata.negate)\n\t\t\t{\n\t\t\t\t/* L | !R: treat as !(!L & R) */\n\t\t\t\t(void) TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_R_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tRdata.npos);\n\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* straight OR */\n\t\t\t\treturn TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_BOTH | TSPO_L_ONLY | TSPO_R_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tLdata.npos + Rdata.npos);\n\t\t\t}\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TSPO_BOTH\t\t0x04\t/* emit positions appearing in both L&R */",
      "#define TSPO_R_ONLY\t\t0x02\t/* emit positions appearing only in R */",
      "#define TSPO_L_ONLY\t\t0x01\t/* emit positions appearing only in L */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized operator: %d\"",
            "curitem->qoperator.oper"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TS_phrase_output",
          "args": [
            "data",
            "&Ldata",
            "&Rdata",
            "TSPO_BOTH | TSPO_L_ONLY | TSPO_R_ONLY",
            "Loffset",
            "Roffset",
            "Ldata.npos + Rdata.npos"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "TS_phrase_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "1433-1531",
          "snippet": "static bool\nTS_phrase_output(ExecPhraseData *data,\n\t\t\t\t ExecPhraseData *Ldata,\n\t\t\t\t ExecPhraseData *Rdata,\n\t\t\t\t int emit,\n\t\t\t\t int Loffset,\n\t\t\t\t int Roffset,\n\t\t\t\t int max_npos)\n{\n\tint\t\t\tLindex,\n\t\t\t\tRindex;\n\n\t/* Loop until both inputs are exhausted */\n\tLindex = Rindex = 0;\n\twhile (Lindex < Ldata->npos || Rindex < Rdata->npos)\n\t{\n\t\tint\t\t\tLpos,\n\t\t\t\t\tRpos;\n\t\tint\t\t\toutput_pos = 0;\n\n\t\t/*\n\t\t * Fetch current values to compare.  WEP_GETPOS() is needed because\n\t\t * ExecPhraseData->data can point to a tsvector's WordEntryPosVector.\n\t\t */\n\t\tif (Lindex < Ldata->npos)\n\t\t\tLpos = WEP_GETPOS(Ldata->pos[Lindex]) + Loffset;\n\t\telse\n\t\t{\n\t\t\t/* L array exhausted, so we're done if R_ONLY isn't set */\n\t\t\tif (!(emit & TSPO_R_ONLY))\n\t\t\t\tbreak;\n\t\t\tLpos = INT_MAX;\n\t\t}\n\t\tif (Rindex < Rdata->npos)\n\t\t\tRpos = WEP_GETPOS(Rdata->pos[Rindex]) + Roffset;\n\t\telse\n\t\t{\n\t\t\t/* R array exhausted, so we're done if L_ONLY isn't set */\n\t\t\tif (!(emit & TSPO_L_ONLY))\n\t\t\t\tbreak;\n\t\t\tRpos = INT_MAX;\n\t\t}\n\n\t\t/* Merge-join the two input lists */\n\t\tif (Lpos < Rpos)\n\t\t{\n\t\t\t/* Lpos is not matched in Rdata, should we output it? */\n\t\t\tif (emit & TSPO_L_ONLY)\n\t\t\t\toutput_pos = Lpos;\n\t\t\tLindex++;\n\t\t}\n\t\telse if (Lpos == Rpos)\n\t\t{\n\t\t\t/* Lpos and Rpos match ... should we output it? */\n\t\t\tif (emit & TSPO_BOTH)\n\t\t\t\toutput_pos = Rpos;\n\t\t\tLindex++;\n\t\t\tRindex++;\n\t\t}\n\t\telse\t\t\t\t\t/* Lpos > Rpos */\n\t\t{\n\t\t\t/* Rpos is not matched in Ldata, should we output it? */\n\t\t\tif (emit & TSPO_R_ONLY)\n\t\t\t\toutput_pos = Rpos;\n\t\t\tRindex++;\n\t\t}\n\n\t\tif (output_pos > 0)\n\t\t{\n\t\t\tif (data)\n\t\t\t{\n\t\t\t\t/* Store position, first allocating output array if needed */\n\t\t\t\tif (data->pos == NULL)\n\t\t\t\t{\n\t\t\t\t\tdata->pos = (WordEntryPos *)\n\t\t\t\t\t\tpalloc(max_npos * sizeof(WordEntryPos));\n\t\t\t\t\tdata->allocated = true;\n\t\t\t\t}\n\t\t\t\tdata->pos[data->npos++] = output_pos;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Exact positions not needed, so return true as soon as we\n\t\t\t\t * know there is at least one.\n\t\t\t\t */\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (data && data->npos > 0)\n\t{\n\t\t/* Let's assert we didn't overrun the array */\n\t\tAssert(data->npos <= max_npos);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define TSPO_BOTH\t\t0x04\t/* emit positions appearing in both L&R */",
            "#define TSPO_R_ONLY\t\t0x02\t/* emit positions appearing only in R */",
            "#define TSPO_L_ONLY\t\t0x01\t/* emit positions appearing only in L */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TSPO_BOTH\t\t0x04\t/* emit positions appearing in both L&R */\n#define TSPO_R_ONLY\t\t0x02\t/* emit positions appearing only in R */\n#define TSPO_L_ONLY\t\t0x01\t/* emit positions appearing only in L */\n\nstatic bool\nTS_phrase_output(ExecPhraseData *data,\n\t\t\t\t ExecPhraseData *Ldata,\n\t\t\t\t ExecPhraseData *Rdata,\n\t\t\t\t int emit,\n\t\t\t\t int Loffset,\n\t\t\t\t int Roffset,\n\t\t\t\t int max_npos)\n{\n\tint\t\t\tLindex,\n\t\t\t\tRindex;\n\n\t/* Loop until both inputs are exhausted */\n\tLindex = Rindex = 0;\n\twhile (Lindex < Ldata->npos || Rindex < Rdata->npos)\n\t{\n\t\tint\t\t\tLpos,\n\t\t\t\t\tRpos;\n\t\tint\t\t\toutput_pos = 0;\n\n\t\t/*\n\t\t * Fetch current values to compare.  WEP_GETPOS() is needed because\n\t\t * ExecPhraseData->data can point to a tsvector's WordEntryPosVector.\n\t\t */\n\t\tif (Lindex < Ldata->npos)\n\t\t\tLpos = WEP_GETPOS(Ldata->pos[Lindex]) + Loffset;\n\t\telse\n\t\t{\n\t\t\t/* L array exhausted, so we're done if R_ONLY isn't set */\n\t\t\tif (!(emit & TSPO_R_ONLY))\n\t\t\t\tbreak;\n\t\t\tLpos = INT_MAX;\n\t\t}\n\t\tif (Rindex < Rdata->npos)\n\t\t\tRpos = WEP_GETPOS(Rdata->pos[Rindex]) + Roffset;\n\t\telse\n\t\t{\n\t\t\t/* R array exhausted, so we're done if L_ONLY isn't set */\n\t\t\tif (!(emit & TSPO_L_ONLY))\n\t\t\t\tbreak;\n\t\t\tRpos = INT_MAX;\n\t\t}\n\n\t\t/* Merge-join the two input lists */\n\t\tif (Lpos < Rpos)\n\t\t{\n\t\t\t/* Lpos is not matched in Rdata, should we output it? */\n\t\t\tif (emit & TSPO_L_ONLY)\n\t\t\t\toutput_pos = Lpos;\n\t\t\tLindex++;\n\t\t}\n\t\telse if (Lpos == Rpos)\n\t\t{\n\t\t\t/* Lpos and Rpos match ... should we output it? */\n\t\t\tif (emit & TSPO_BOTH)\n\t\t\t\toutput_pos = Rpos;\n\t\t\tLindex++;\n\t\t\tRindex++;\n\t\t}\n\t\telse\t\t\t\t\t/* Lpos > Rpos */\n\t\t{\n\t\t\t/* Rpos is not matched in Ldata, should we output it? */\n\t\t\tif (emit & TSPO_R_ONLY)\n\t\t\t\toutput_pos = Rpos;\n\t\t\tRindex++;\n\t\t}\n\n\t\tif (output_pos > 0)\n\t\t{\n\t\t\tif (data)\n\t\t\t{\n\t\t\t\t/* Store position, first allocating output array if needed */\n\t\t\t\tif (data->pos == NULL)\n\t\t\t\t{\n\t\t\t\t\tdata->pos = (WordEntryPos *)\n\t\t\t\t\t\tpalloc(max_npos * sizeof(WordEntryPos));\n\t\t\t\t\tdata->allocated = true;\n\t\t\t\t}\n\t\t\t\tdata->pos[data->npos++] = output_pos;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Exact positions not needed, so return true as soon as we\n\t\t\t\t * know there is at least one.\n\t\t\t\t */\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (data && data->npos > 0)\n\t{\n\t\t/* Let's assert we didn't overrun the array */\n\t\tAssert(data->npos <= max_npos);\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "Ldata.npos",
            "Rdata.npos"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "Ldata.width",
            "Rdata.width"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TS_phrase_execute",
          "args": [
            "curitem + 1",
            "arg",
            "flags",
            "chkcond",
            "&Rdata"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "TS_phrase_execute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "1571-1799",
          "snippet": "static bool\nTS_phrase_execute(QueryItem *curitem, void *arg, uint32 flags,\n\t\t\t\t  TSExecuteCallback chkcond,\n\t\t\t\t  ExecPhraseData *data)\n{\n\tExecPhraseData Ldata,\n\t\t\t\tRdata;\n\tbool\t\tlmatch,\n\t\t\t\trmatch;\n\tint\t\t\tLoffset,\n\t\t\t\tRoffset,\n\t\t\t\tmaxwidth;\n\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn chkcond(arg, (QueryOperand *) curitem, data);\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\n\t\t\t/*\n\t\t\t * Because a \"true\" result with no specific positions is taken as\n\t\t\t * uncertain, we need no special care here for !TS_EXEC_CALC_NOT.\n\t\t\t * If it's a false positive, the right things happen anyway.\n\t\t\t *\n\t\t\t * Also, we need not touch data->width, since a NOT operation does\n\t\t\t * not change the match width.\n\t\t\t */\n\t\t\tif (TS_phrase_execute(curitem + 1, arg, flags, chkcond, data))\n\t\t\t{\n\t\t\t\tif (data->npos > 0)\n\t\t\t\t{\n\t\t\t\t\t/* we have some positions, invert negate flag */\n\t\t\t\t\tdata->negate = !data->negate;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (data->negate)\n\t\t\t\t{\n\t\t\t\t\t/* change \"match everywhere\" to \"match nowhere\" */\n\t\t\t\t\tdata->negate = false;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/* match positions are, and remain, uncertain */\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* change \"match nowhere\" to \"match everywhere\" */\n\t\t\t\tAssert(data->npos == 0 && !data->negate);\n\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\tcase OP_PHRASE:\n\t\tcase OP_AND:\n\t\t\tmemset(&Ldata, 0, sizeof(Ldata));\n\t\t\tmemset(&Rdata, 0, sizeof(Rdata));\n\n\t\t\tif (!TS_phrase_execute(curitem + curitem->qoperator.left,\n\t\t\t\t\t\t\t\t   arg, flags, chkcond, &Ldata))\n\t\t\t\treturn false;\n\n\t\t\tif (!TS_phrase_execute(curitem + 1,\n\t\t\t\t\t\t\t\t   arg, flags, chkcond, &Rdata))\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * If either operand has no position information, then we can't\n\t\t\t * return position data, only a \"possible match\" result. \"Possible\n\t\t\t * match\" answers are only wanted when TS_EXEC_PHRASE_NO_POS flag\n\t\t\t * is set, otherwise return false.\n\t\t\t */\n\t\t\tif ((Ldata.npos == 0 && !Ldata.negate) ||\n\t\t\t\t(Rdata.npos == 0 && !Rdata.negate))\n\t\t\t\treturn (flags & TS_EXEC_PHRASE_NO_POS) ? true : false;\n\n\t\t\tif (curitem->qoperator.oper == OP_PHRASE)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Compute Loffset and Roffset suitable for phrase match, and\n\t\t\t\t * compute overall width of whole phrase match.\n\t\t\t\t */\n\t\t\t\tLoffset = curitem->qoperator.distance + Rdata.width;\n\t\t\t\tRoffset = 0;\n\t\t\t\tif (data)\n\t\t\t\t\tdata->width = curitem->qoperator.distance +\n\t\t\t\t\t\tLdata.width + Rdata.width;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For OP_AND, set output width and alignment like OP_OR (see\n\t\t\t\t * comment below)\n\t\t\t\t */\n\t\t\t\tmaxwidth = Max(Ldata.width, Rdata.width);\n\t\t\t\tLoffset = maxwidth - Ldata.width;\n\t\t\t\tRoffset = maxwidth - Rdata.width;\n\t\t\t\tif (data)\n\t\t\t\t\tdata->width = maxwidth;\n\t\t\t}\n\n\t\t\tif (Ldata.negate && Rdata.negate)\n\t\t\t{\n\t\t\t\t/* !L & !R: treat as !(L | R) */\n\t\t\t\t(void) TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_BOTH | TSPO_L_ONLY | TSPO_R_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tLdata.npos + Rdata.npos);\n\t\t\t\tif (data)\n\t\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (Ldata.negate)\n\t\t\t{\n\t\t\t\t/* !L & R */\n\t\t\t\treturn TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_R_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tRdata.npos);\n\t\t\t}\n\t\t\telse if (Rdata.negate)\n\t\t\t{\n\t\t\t\t/* L & !R */\n\t\t\t\treturn TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_L_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tLdata.npos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* straight AND */\n\t\t\t\treturn TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_BOTH,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tMin(Ldata.npos, Rdata.npos));\n\t\t\t}\n\n\t\tcase OP_OR:\n\t\t\tmemset(&Ldata, 0, sizeof(Ldata));\n\t\t\tmemset(&Rdata, 0, sizeof(Rdata));\n\n\t\t\tlmatch = TS_phrase_execute(curitem + curitem->qoperator.left,\n\t\t\t\t\t\t\t\t\t   arg, flags, chkcond, &Ldata);\n\t\t\trmatch = TS_phrase_execute(curitem + 1,\n\t\t\t\t\t\t\t\t\t   arg, flags, chkcond, &Rdata);\n\n\t\t\tif (!lmatch && !rmatch)\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * If a valid operand has no position information, then we can't\n\t\t\t * return position data, only a \"possible match\" result. \"Possible\n\t\t\t * match\" answers are only wanted when TS_EXEC_PHRASE_NO_POS flag\n\t\t\t * is set, otherwise return false.\n\t\t\t */\n\t\t\tif ((lmatch && Ldata.npos == 0 && !Ldata.negate) ||\n\t\t\t\t(rmatch && Rdata.npos == 0 && !Rdata.negate))\n\t\t\t\treturn (flags & TS_EXEC_PHRASE_NO_POS) ? true : false;\n\n\t\t\t/*\n\t\t\t * Cope with undefined output width from failed submatch.  (This\n\t\t\t * takes less code than trying to ensure that all failure returns\n\t\t\t * set data->width to zero.)\n\t\t\t */\n\t\t\tif (!lmatch)\n\t\t\t\tLdata.width = 0;\n\t\t\tif (!rmatch)\n\t\t\t\tRdata.width = 0;\n\n\t\t\t/*\n\t\t\t * For OP_AND and OP_OR, report the width of the wider of the two\n\t\t\t * inputs, and align the narrower input's positions to the right\n\t\t\t * end of that width.  This rule deals at least somewhat\n\t\t\t * reasonably with cases like \"x <-> (y | z <-> q)\".\n\t\t\t */\n\t\t\tmaxwidth = Max(Ldata.width, Rdata.width);\n\t\t\tLoffset = maxwidth - Ldata.width;\n\t\t\tRoffset = maxwidth - Rdata.width;\n\t\t\tdata->width = maxwidth;\n\n\t\t\tif (Ldata.negate && Rdata.negate)\n\t\t\t{\n\t\t\t\t/* !L | !R: treat as !(L & R) */\n\t\t\t\t(void) TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_BOTH,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tMin(Ldata.npos, Rdata.npos));\n\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (Ldata.negate)\n\t\t\t{\n\t\t\t\t/* !L | R: treat as !(L & !R) */\n\t\t\t\t(void) TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_L_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tLdata.npos);\n\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (Rdata.negate)\n\t\t\t{\n\t\t\t\t/* L | !R: treat as !(!L & R) */\n\t\t\t\t(void) TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_R_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tRdata.npos);\n\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* straight OR */\n\t\t\t\treturn TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_BOTH | TSPO_L_ONLY | TSPO_R_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tLdata.npos + Rdata.npos);\n\t\t\t}\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&Rdata",
            "0",
            "sizeof(Rdata)"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&Ldata",
            "0",
            "sizeof(Ldata)"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "Ldata.npos",
            "Rdata.npos"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "Ldata.width",
            "Rdata.width"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&Rdata",
            "0",
            "sizeof(Rdata)"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&Ldata",
            "0",
            "sizeof(Ldata)"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "data->npos == 0 && !data->negate"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chkcond",
          "args": [
            "arg",
            "(QueryOperand *) curitem",
            "data"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_stack_depth",
          "args": [],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TSPO_BOTH\t\t0x04\t/* emit positions appearing in both L&R */\n#define TSPO_R_ONLY\t\t0x02\t/* emit positions appearing only in R */\n#define TSPO_L_ONLY\t\t0x01\t/* emit positions appearing only in L */\n\nstatic bool\nTS_phrase_execute(QueryItem *curitem, void *arg, uint32 flags,\n\t\t\t\t  TSExecuteCallback chkcond,\n\t\t\t\t  ExecPhraseData *data)\n{\n\tExecPhraseData Ldata,\n\t\t\t\tRdata;\n\tbool\t\tlmatch,\n\t\t\t\trmatch;\n\tint\t\t\tLoffset,\n\t\t\t\tRoffset,\n\t\t\t\tmaxwidth;\n\n\t/* since this function recurses, it could be driven to stack overflow */\n\tcheck_stack_depth();\n\n\tif (curitem->type == QI_VAL)\n\t\treturn chkcond(arg, (QueryOperand *) curitem, data);\n\n\tswitch (curitem->qoperator.oper)\n\t{\n\t\tcase OP_NOT:\n\n\t\t\t/*\n\t\t\t * Because a \"true\" result with no specific positions is taken as\n\t\t\t * uncertain, we need no special care here for !TS_EXEC_CALC_NOT.\n\t\t\t * If it's a false positive, the right things happen anyway.\n\t\t\t *\n\t\t\t * Also, we need not touch data->width, since a NOT operation does\n\t\t\t * not change the match width.\n\t\t\t */\n\t\t\tif (TS_phrase_execute(curitem + 1, arg, flags, chkcond, data))\n\t\t\t{\n\t\t\t\tif (data->npos > 0)\n\t\t\t\t{\n\t\t\t\t\t/* we have some positions, invert negate flag */\n\t\t\t\t\tdata->negate = !data->negate;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (data->negate)\n\t\t\t\t{\n\t\t\t\t\t/* change \"match everywhere\" to \"match nowhere\" */\n\t\t\t\t\tdata->negate = false;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t/* match positions are, and remain, uncertain */\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* change \"match nowhere\" to \"match everywhere\" */\n\t\t\t\tAssert(data->npos == 0 && !data->negate);\n\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\tcase OP_PHRASE:\n\t\tcase OP_AND:\n\t\t\tmemset(&Ldata, 0, sizeof(Ldata));\n\t\t\tmemset(&Rdata, 0, sizeof(Rdata));\n\n\t\t\tif (!TS_phrase_execute(curitem + curitem->qoperator.left,\n\t\t\t\t\t\t\t\t   arg, flags, chkcond, &Ldata))\n\t\t\t\treturn false;\n\n\t\t\tif (!TS_phrase_execute(curitem + 1,\n\t\t\t\t\t\t\t\t   arg, flags, chkcond, &Rdata))\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * If either operand has no position information, then we can't\n\t\t\t * return position data, only a \"possible match\" result. \"Possible\n\t\t\t * match\" answers are only wanted when TS_EXEC_PHRASE_NO_POS flag\n\t\t\t * is set, otherwise return false.\n\t\t\t */\n\t\t\tif ((Ldata.npos == 0 && !Ldata.negate) ||\n\t\t\t\t(Rdata.npos == 0 && !Rdata.negate))\n\t\t\t\treturn (flags & TS_EXEC_PHRASE_NO_POS) ? true : false;\n\n\t\t\tif (curitem->qoperator.oper == OP_PHRASE)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Compute Loffset and Roffset suitable for phrase match, and\n\t\t\t\t * compute overall width of whole phrase match.\n\t\t\t\t */\n\t\t\t\tLoffset = curitem->qoperator.distance + Rdata.width;\n\t\t\t\tRoffset = 0;\n\t\t\t\tif (data)\n\t\t\t\t\tdata->width = curitem->qoperator.distance +\n\t\t\t\t\t\tLdata.width + Rdata.width;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * For OP_AND, set output width and alignment like OP_OR (see\n\t\t\t\t * comment below)\n\t\t\t\t */\n\t\t\t\tmaxwidth = Max(Ldata.width, Rdata.width);\n\t\t\t\tLoffset = maxwidth - Ldata.width;\n\t\t\t\tRoffset = maxwidth - Rdata.width;\n\t\t\t\tif (data)\n\t\t\t\t\tdata->width = maxwidth;\n\t\t\t}\n\n\t\t\tif (Ldata.negate && Rdata.negate)\n\t\t\t{\n\t\t\t\t/* !L & !R: treat as !(L | R) */\n\t\t\t\t(void) TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_BOTH | TSPO_L_ONLY | TSPO_R_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tLdata.npos + Rdata.npos);\n\t\t\t\tif (data)\n\t\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (Ldata.negate)\n\t\t\t{\n\t\t\t\t/* !L & R */\n\t\t\t\treturn TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_R_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tRdata.npos);\n\t\t\t}\n\t\t\telse if (Rdata.negate)\n\t\t\t{\n\t\t\t\t/* L & !R */\n\t\t\t\treturn TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_L_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tLdata.npos);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* straight AND */\n\t\t\t\treturn TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_BOTH,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tMin(Ldata.npos, Rdata.npos));\n\t\t\t}\n\n\t\tcase OP_OR:\n\t\t\tmemset(&Ldata, 0, sizeof(Ldata));\n\t\t\tmemset(&Rdata, 0, sizeof(Rdata));\n\n\t\t\tlmatch = TS_phrase_execute(curitem + curitem->qoperator.left,\n\t\t\t\t\t\t\t\t\t   arg, flags, chkcond, &Ldata);\n\t\t\trmatch = TS_phrase_execute(curitem + 1,\n\t\t\t\t\t\t\t\t\t   arg, flags, chkcond, &Rdata);\n\n\t\t\tif (!lmatch && !rmatch)\n\t\t\t\treturn false;\n\n\t\t\t/*\n\t\t\t * If a valid operand has no position information, then we can't\n\t\t\t * return position data, only a \"possible match\" result. \"Possible\n\t\t\t * match\" answers are only wanted when TS_EXEC_PHRASE_NO_POS flag\n\t\t\t * is set, otherwise return false.\n\t\t\t */\n\t\t\tif ((lmatch && Ldata.npos == 0 && !Ldata.negate) ||\n\t\t\t\t(rmatch && Rdata.npos == 0 && !Rdata.negate))\n\t\t\t\treturn (flags & TS_EXEC_PHRASE_NO_POS) ? true : false;\n\n\t\t\t/*\n\t\t\t * Cope with undefined output width from failed submatch.  (This\n\t\t\t * takes less code than trying to ensure that all failure returns\n\t\t\t * set data->width to zero.)\n\t\t\t */\n\t\t\tif (!lmatch)\n\t\t\t\tLdata.width = 0;\n\t\t\tif (!rmatch)\n\t\t\t\tRdata.width = 0;\n\n\t\t\t/*\n\t\t\t * For OP_AND and OP_OR, report the width of the wider of the two\n\t\t\t * inputs, and align the narrower input's positions to the right\n\t\t\t * end of that width.  This rule deals at least somewhat\n\t\t\t * reasonably with cases like \"x <-> (y | z <-> q)\".\n\t\t\t */\n\t\t\tmaxwidth = Max(Ldata.width, Rdata.width);\n\t\t\tLoffset = maxwidth - Ldata.width;\n\t\t\tRoffset = maxwidth - Rdata.width;\n\t\t\tdata->width = maxwidth;\n\n\t\t\tif (Ldata.negate && Rdata.negate)\n\t\t\t{\n\t\t\t\t/* !L | !R: treat as !(L & R) */\n\t\t\t\t(void) TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_BOTH,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tMin(Ldata.npos, Rdata.npos));\n\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (Ldata.negate)\n\t\t\t{\n\t\t\t\t/* !L | R: treat as !(L & !R) */\n\t\t\t\t(void) TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_L_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tLdata.npos);\n\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (Rdata.negate)\n\t\t\t{\n\t\t\t\t/* L | !R: treat as !(!L & R) */\n\t\t\t\t(void) TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_R_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tRdata.npos);\n\t\t\t\tdata->negate = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* straight OR */\n\t\t\t\treturn TS_phrase_output(data, &Ldata, &Rdata,\n\t\t\t\t\t\t\t\t\t\tTSPO_BOTH | TSPO_L_ONLY | TSPO_R_ONLY,\n\t\t\t\t\t\t\t\t\t\tLoffset, Roffset,\n\t\t\t\t\t\t\t\t\t\tLdata.npos + Rdata.npos);\n\t\t\t}\n\n\t\tdefault:\n\t\t\telog(ERROR, \"unrecognized operator: %d\", curitem->qoperator.oper);\n\t}\n\n\t/* not reachable, but keep compiler quiet */\n\treturn false;\n}"
  },
  {
    "function_name": "TS_phrase_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "1433-1531",
    "snippet": "static bool\nTS_phrase_output(ExecPhraseData *data,\n\t\t\t\t ExecPhraseData *Ldata,\n\t\t\t\t ExecPhraseData *Rdata,\n\t\t\t\t int emit,\n\t\t\t\t int Loffset,\n\t\t\t\t int Roffset,\n\t\t\t\t int max_npos)\n{\n\tint\t\t\tLindex,\n\t\t\t\tRindex;\n\n\t/* Loop until both inputs are exhausted */\n\tLindex = Rindex = 0;\n\twhile (Lindex < Ldata->npos || Rindex < Rdata->npos)\n\t{\n\t\tint\t\t\tLpos,\n\t\t\t\t\tRpos;\n\t\tint\t\t\toutput_pos = 0;\n\n\t\t/*\n\t\t * Fetch current values to compare.  WEP_GETPOS() is needed because\n\t\t * ExecPhraseData->data can point to a tsvector's WordEntryPosVector.\n\t\t */\n\t\tif (Lindex < Ldata->npos)\n\t\t\tLpos = WEP_GETPOS(Ldata->pos[Lindex]) + Loffset;\n\t\telse\n\t\t{\n\t\t\t/* L array exhausted, so we're done if R_ONLY isn't set */\n\t\t\tif (!(emit & TSPO_R_ONLY))\n\t\t\t\tbreak;\n\t\t\tLpos = INT_MAX;\n\t\t}\n\t\tif (Rindex < Rdata->npos)\n\t\t\tRpos = WEP_GETPOS(Rdata->pos[Rindex]) + Roffset;\n\t\telse\n\t\t{\n\t\t\t/* R array exhausted, so we're done if L_ONLY isn't set */\n\t\t\tif (!(emit & TSPO_L_ONLY))\n\t\t\t\tbreak;\n\t\t\tRpos = INT_MAX;\n\t\t}\n\n\t\t/* Merge-join the two input lists */\n\t\tif (Lpos < Rpos)\n\t\t{\n\t\t\t/* Lpos is not matched in Rdata, should we output it? */\n\t\t\tif (emit & TSPO_L_ONLY)\n\t\t\t\toutput_pos = Lpos;\n\t\t\tLindex++;\n\t\t}\n\t\telse if (Lpos == Rpos)\n\t\t{\n\t\t\t/* Lpos and Rpos match ... should we output it? */\n\t\t\tif (emit & TSPO_BOTH)\n\t\t\t\toutput_pos = Rpos;\n\t\t\tLindex++;\n\t\t\tRindex++;\n\t\t}\n\t\telse\t\t\t\t\t/* Lpos > Rpos */\n\t\t{\n\t\t\t/* Rpos is not matched in Ldata, should we output it? */\n\t\t\tif (emit & TSPO_R_ONLY)\n\t\t\t\toutput_pos = Rpos;\n\t\t\tRindex++;\n\t\t}\n\n\t\tif (output_pos > 0)\n\t\t{\n\t\t\tif (data)\n\t\t\t{\n\t\t\t\t/* Store position, first allocating output array if needed */\n\t\t\t\tif (data->pos == NULL)\n\t\t\t\t{\n\t\t\t\t\tdata->pos = (WordEntryPos *)\n\t\t\t\t\t\tpalloc(max_npos * sizeof(WordEntryPos));\n\t\t\t\t\tdata->allocated = true;\n\t\t\t\t}\n\t\t\t\tdata->pos[data->npos++] = output_pos;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Exact positions not needed, so return true as soon as we\n\t\t\t\t * know there is at least one.\n\t\t\t\t */\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (data && data->npos > 0)\n\t{\n\t\t/* Let's assert we didn't overrun the array */\n\t\tAssert(data->npos <= max_npos);\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define TSPO_BOTH\t\t0x04\t/* emit positions appearing in both L&R */",
      "#define TSPO_R_ONLY\t\t0x02\t/* emit positions appearing only in R */",
      "#define TSPO_L_ONLY\t\t0x01\t/* emit positions appearing only in L */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "data->npos <= max_npos"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "max_npos * sizeof(WordEntryPos)"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "Rdata->pos[Rindex]"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "Ldata->pos[Lindex]"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\n#define TSPO_BOTH\t\t0x04\t/* emit positions appearing in both L&R */\n#define TSPO_R_ONLY\t\t0x02\t/* emit positions appearing only in R */\n#define TSPO_L_ONLY\t\t0x01\t/* emit positions appearing only in L */\n\nstatic bool\nTS_phrase_output(ExecPhraseData *data,\n\t\t\t\t ExecPhraseData *Ldata,\n\t\t\t\t ExecPhraseData *Rdata,\n\t\t\t\t int emit,\n\t\t\t\t int Loffset,\n\t\t\t\t int Roffset,\n\t\t\t\t int max_npos)\n{\n\tint\t\t\tLindex,\n\t\t\t\tRindex;\n\n\t/* Loop until both inputs are exhausted */\n\tLindex = Rindex = 0;\n\twhile (Lindex < Ldata->npos || Rindex < Rdata->npos)\n\t{\n\t\tint\t\t\tLpos,\n\t\t\t\t\tRpos;\n\t\tint\t\t\toutput_pos = 0;\n\n\t\t/*\n\t\t * Fetch current values to compare.  WEP_GETPOS() is needed because\n\t\t * ExecPhraseData->data can point to a tsvector's WordEntryPosVector.\n\t\t */\n\t\tif (Lindex < Ldata->npos)\n\t\t\tLpos = WEP_GETPOS(Ldata->pos[Lindex]) + Loffset;\n\t\telse\n\t\t{\n\t\t\t/* L array exhausted, so we're done if R_ONLY isn't set */\n\t\t\tif (!(emit & TSPO_R_ONLY))\n\t\t\t\tbreak;\n\t\t\tLpos = INT_MAX;\n\t\t}\n\t\tif (Rindex < Rdata->npos)\n\t\t\tRpos = WEP_GETPOS(Rdata->pos[Rindex]) + Roffset;\n\t\telse\n\t\t{\n\t\t\t/* R array exhausted, so we're done if L_ONLY isn't set */\n\t\t\tif (!(emit & TSPO_L_ONLY))\n\t\t\t\tbreak;\n\t\t\tRpos = INT_MAX;\n\t\t}\n\n\t\t/* Merge-join the two input lists */\n\t\tif (Lpos < Rpos)\n\t\t{\n\t\t\t/* Lpos is not matched in Rdata, should we output it? */\n\t\t\tif (emit & TSPO_L_ONLY)\n\t\t\t\toutput_pos = Lpos;\n\t\t\tLindex++;\n\t\t}\n\t\telse if (Lpos == Rpos)\n\t\t{\n\t\t\t/* Lpos and Rpos match ... should we output it? */\n\t\t\tif (emit & TSPO_BOTH)\n\t\t\t\toutput_pos = Rpos;\n\t\t\tLindex++;\n\t\t\tRindex++;\n\t\t}\n\t\telse\t\t\t\t\t/* Lpos > Rpos */\n\t\t{\n\t\t\t/* Rpos is not matched in Ldata, should we output it? */\n\t\t\tif (emit & TSPO_R_ONLY)\n\t\t\t\toutput_pos = Rpos;\n\t\t\tRindex++;\n\t\t}\n\n\t\tif (output_pos > 0)\n\t\t{\n\t\t\tif (data)\n\t\t\t{\n\t\t\t\t/* Store position, first allocating output array if needed */\n\t\t\t\tif (data->pos == NULL)\n\t\t\t\t{\n\t\t\t\t\tdata->pos = (WordEntryPos *)\n\t\t\t\t\t\tpalloc(max_npos * sizeof(WordEntryPos));\n\t\t\t\t\tdata->allocated = true;\n\t\t\t\t}\n\t\t\t\tdata->pos[data->npos++] = output_pos;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Exact positions not needed, so return true as soon as we\n\t\t\t\t * know there is at least one.\n\t\t\t\t */\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (data && data->npos > 0)\n\t{\n\t\t/* Let's assert we didn't overrun the array */\n\t\tAssert(data->npos <= max_npos);\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "checkcondition_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "1310-1407",
    "snippet": "static bool\ncheckcondition_str(void *checkval, QueryOperand *val, ExecPhraseData *data)\n{\n\tCHKVAL\t   *chkval = (CHKVAL *) checkval;\n\tWordEntry  *StopLow = chkval->arrb;\n\tWordEntry  *StopHigh = chkval->arre;\n\tWordEntry  *StopMiddle = StopHigh;\n\tint\t\t\tdifference = -1;\n\tbool\t\tres = false;\n\n\t/* Loop invariant: StopLow <= val < StopHigh */\n\twhile (StopLow < StopHigh)\n\t{\n\t\tStopMiddle = StopLow + (StopHigh - StopLow) / 2;\n\t\tdifference = tsCompareString(chkval->operand + val->distance,\n\t\t\t\t\t\t\t\t\t val->length,\n\t\t\t\t\t\t\t\t\t chkval->values + StopMiddle->pos,\n\t\t\t\t\t\t\t\t\t StopMiddle->len,\n\t\t\t\t\t\t\t\t\t false);\n\n\t\tif (difference == 0)\n\t\t{\n\t\t\t/* Check weight info & fill 'data' with positions */\n\t\t\tres = checkclass_str(chkval, StopMiddle, val, data);\n\t\t\tbreak;\n\t\t}\n\t\telse if (difference > 0)\n\t\t\tStopLow = StopMiddle + 1;\n\t\telse\n\t\t\tStopHigh = StopMiddle;\n\t}\n\n\tif ((!res || data) && val->prefix)\n\t{\n\t\tWordEntryPos *allpos = NULL;\n\t\tint\t\t\tnpos = 0,\n\t\t\t\t\ttotalpos = 0;\n\n\t\t/*\n\t\t * there was a failed exact search, so we should scan further to find\n\t\t * a prefix match. We also need to do so if caller needs position info\n\t\t */\n\t\tif (StopLow >= StopHigh)\n\t\t\tStopMiddle = StopHigh;\n\n\t\twhile ((!res || data) && StopMiddle < chkval->arre &&\n\t\t\t   tsCompareString(chkval->operand + val->distance,\n\t\t\t\t\t\t\t   val->length,\n\t\t\t\t\t\t\t   chkval->values + StopMiddle->pos,\n\t\t\t\t\t\t\t   StopMiddle->len,\n\t\t\t\t\t\t\t   true) == 0)\n\t\t{\n\t\t\tif (data)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We need to join position information\n\t\t\t\t */\n\t\t\t\tres = checkclass_str(chkval, StopMiddle, val, data);\n\n\t\t\t\tif (res)\n\t\t\t\t{\n\t\t\t\t\twhile (npos + data->npos >= totalpos)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (totalpos == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttotalpos = 256;\n\t\t\t\t\t\t\tallpos = palloc(sizeof(WordEntryPos) * totalpos);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttotalpos *= 2;\n\t\t\t\t\t\t\tallpos = repalloc(allpos, sizeof(WordEntryPos) * totalpos);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tmemcpy(allpos + npos, data->pos, sizeof(WordEntryPos) * data->npos);\n\t\t\t\t\tnpos += data->npos;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres = checkclass_str(chkval, StopMiddle, val, NULL);\n\t\t\t}\n\n\t\t\tStopMiddle++;\n\t\t}\n\n\t\tif (res && data)\n\t\t{\n\t\t\t/* Sort and make unique array of found positions */\n\t\t\tdata->pos = allpos;\n\t\t\tdata->npos = uniqueLongPos(allpos, npos);\n\t\t\tdata->allocated = true;\n\t\t}\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uniqueLongPos",
          "args": [
            "allpos",
            "npos"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "uniqueLongPos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "1280-1305",
          "snippet": "static int\nuniqueLongPos(WordEntryPos *pos, int npos)\n{\n\tWordEntryPos *pos_iter,\n\t\t\t   *result;\n\n\tif (npos <= 1)\n\t\treturn npos;\n\n\tqsort((void *) pos, npos, sizeof(WordEntryPos), compareWordEntryPos);\n\n\tresult = pos;\n\tpos_iter = pos + 1;\n\twhile (pos_iter < pos + npos)\n\t{\n\t\tif (WEP_GETPOS(*pos_iter) != WEP_GETPOS(*result))\n\t\t{\n\t\t\tresult++;\n\t\t\t*result = WEP_GETPOS(*pos_iter);\n\t\t}\n\n\t\tpos_iter++;\n\t}\n\n\treturn result + 1 - pos;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\nuniqueLongPos(WordEntryPos *pos, int npos)\n{\n\tWordEntryPos *pos_iter,\n\t\t\t   *result;\n\n\tif (npos <= 1)\n\t\treturn npos;\n\n\tqsort((void *) pos, npos, sizeof(WordEntryPos), compareWordEntryPos);\n\n\tresult = pos;\n\tpos_iter = pos + 1;\n\twhile (pos_iter < pos + npos)\n\t{\n\t\tif (WEP_GETPOS(*pos_iter) != WEP_GETPOS(*result))\n\t\t{\n\t\t\tresult++;\n\t\t\t*result = WEP_GETPOS(*pos_iter);\n\t\t}\n\n\t\tpos_iter++;\n\t}\n\n\treturn result + 1 - pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkclass_str",
          "args": [
            "chkval",
            "StopMiddle",
            "val",
            "NULL"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "checkclass_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "1196-1272",
          "snippet": "static bool\ncheckclass_str(CHKVAL *chkval, WordEntry *entry, QueryOperand *val,\n\t\t\t   ExecPhraseData *data)\n{\n\tbool\t\tresult = false;\n\n\tif (entry->haspos && (val->weight || data))\n\t{\n\t\tWordEntryPosVector *posvec;\n\n\t\t/*\n\t\t * We can't use the _POSVECPTR macro here because the pointer to the\n\t\t * tsvector's lexeme storage is already contained in chkval->values.\n\t\t */\n\t\tposvec = (WordEntryPosVector *)\n\t\t\t(chkval->values + SHORTALIGN(entry->pos + entry->len));\n\n\t\tif (val->weight && data)\n\t\t{\n\t\t\tWordEntryPos *posvec_iter = posvec->pos;\n\t\t\tWordEntryPos *dptr;\n\n\t\t\t/*\n\t\t\t * Filter position information by weights\n\t\t\t */\n\t\t\tdptr = data->pos = palloc(sizeof(WordEntryPos) * posvec->npos);\n\t\t\tdata->allocated = true;\n\n\t\t\t/* Is there a position with a matching weight? */\n\t\t\twhile (posvec_iter < posvec->pos + posvec->npos)\n\t\t\t{\n\t\t\t\t/* If true, append this position to the data->pos */\n\t\t\t\tif (val->weight & (1 << WEP_GETWEIGHT(*posvec_iter)))\n\t\t\t\t{\n\t\t\t\t\t*dptr = WEP_GETPOS(*posvec_iter);\n\t\t\t\t\tdptr++;\n\t\t\t\t}\n\n\t\t\t\tposvec_iter++;\n\t\t\t}\n\n\t\t\tdata->npos = dptr - data->pos;\n\n\t\t\tif (data->npos > 0)\n\t\t\t\tresult = true;\n\t\t}\n\t\telse if (val->weight)\n\t\t{\n\t\t\tWordEntryPos *posvec_iter = posvec->pos;\n\n\t\t\t/* Is there a position with a matching weight? */\n\t\t\twhile (posvec_iter < posvec->pos + posvec->npos)\n\t\t\t{\n\t\t\t\tif (val->weight & (1 << WEP_GETWEIGHT(*posvec_iter)))\n\t\t\t\t{\n\t\t\t\t\tresult = true;\n\t\t\t\t\tbreak;\t\t/* no need to go further */\n\t\t\t\t}\n\n\t\t\t\tposvec_iter++;\n\t\t\t}\n\t\t}\n\t\telse\t\t\t\t\t/* data != NULL */\n\t\t{\n\t\t\tdata->npos = posvec->npos;\n\t\t\tdata->pos = posvec->pos;\n\t\t\tdata->allocated = false;\n\t\t\tresult = true;\n\t\t}\n\t}\n\telse\n\t{\n\t\tresult = true;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool\ncheckclass_str(CHKVAL *chkval, WordEntry *entry, QueryOperand *val,\n\t\t\t   ExecPhraseData *data)\n{\n\tbool\t\tresult = false;\n\n\tif (entry->haspos && (val->weight || data))\n\t{\n\t\tWordEntryPosVector *posvec;\n\n\t\t/*\n\t\t * We can't use the _POSVECPTR macro here because the pointer to the\n\t\t * tsvector's lexeme storage is already contained in chkval->values.\n\t\t */\n\t\tposvec = (WordEntryPosVector *)\n\t\t\t(chkval->values + SHORTALIGN(entry->pos + entry->len));\n\n\t\tif (val->weight && data)\n\t\t{\n\t\t\tWordEntryPos *posvec_iter = posvec->pos;\n\t\t\tWordEntryPos *dptr;\n\n\t\t\t/*\n\t\t\t * Filter position information by weights\n\t\t\t */\n\t\t\tdptr = data->pos = palloc(sizeof(WordEntryPos) * posvec->npos);\n\t\t\tdata->allocated = true;\n\n\t\t\t/* Is there a position with a matching weight? */\n\t\t\twhile (posvec_iter < posvec->pos + posvec->npos)\n\t\t\t{\n\t\t\t\t/* If true, append this position to the data->pos */\n\t\t\t\tif (val->weight & (1 << WEP_GETWEIGHT(*posvec_iter)))\n\t\t\t\t{\n\t\t\t\t\t*dptr = WEP_GETPOS(*posvec_iter);\n\t\t\t\t\tdptr++;\n\t\t\t\t}\n\n\t\t\t\tposvec_iter++;\n\t\t\t}\n\n\t\t\tdata->npos = dptr - data->pos;\n\n\t\t\tif (data->npos > 0)\n\t\t\t\tresult = true;\n\t\t}\n\t\telse if (val->weight)\n\t\t{\n\t\t\tWordEntryPos *posvec_iter = posvec->pos;\n\n\t\t\t/* Is there a position with a matching weight? */\n\t\t\twhile (posvec_iter < posvec->pos + posvec->npos)\n\t\t\t{\n\t\t\t\tif (val->weight & (1 << WEP_GETWEIGHT(*posvec_iter)))\n\t\t\t\t{\n\t\t\t\t\tresult = true;\n\t\t\t\t\tbreak;\t\t/* no need to go further */\n\t\t\t\t}\n\n\t\t\t\tposvec_iter++;\n\t\t\t}\n\t\t}\n\t\telse\t\t\t\t\t/* data != NULL */\n\t\t{\n\t\t\tdata->npos = posvec->npos;\n\t\t\tdata->pos = posvec->pos;\n\t\t\tdata->allocated = false;\n\t\t\tresult = true;\n\t\t}\n\t}\n\telse\n\t{\n\t\tresult = true;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "allpos + npos",
            "data->pos",
            "sizeof(WordEntryPos) * data->npos"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repalloc",
          "args": [
            "allpos",
            "sizeof(WordEntryPos) * totalpos"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "xml_repalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1642-1646",
          "snippet": "static void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_repalloc(void *ptr, size_t size)\n{\n\treturn repalloc(ptr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(WordEntryPos) * totalpos"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsCompareString",
          "args": [
            "chkval->operand + val->distance",
            "val->length",
            "chkval->values + StopMiddle->pos",
            "StopMiddle->len",
            "true"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "tsCompareString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "1159-1191",
          "snippet": "int32\ntsCompareString(char *a, int lena, char *b, int lenb, bool prefix)\n{\n\tint\t\t\tcmp;\n\n\tif (lena == 0)\n\t{\n\t\tif (prefix)\n\t\t\tcmp = 0;\t\t\t/* empty string is prefix of anything */\n\t\telse\n\t\t\tcmp = (lenb > 0) ? -1 : 0;\n\t}\n\telse if (lenb == 0)\n\t{\n\t\tcmp = (lena > 0) ? 1 : 0;\n\t}\n\telse\n\t{\n\t\tcmp = memcmp(a, b, Min(lena, lenb));\n\n\t\tif (prefix)\n\t\t{\n\t\t\tif (cmp == 0 && lena > lenb)\n\t\t\t\tcmp = 1;\t\t/* a is longer, so not a prefix of b */\n\t\t}\n\t\telse if (cmp == 0 && lena != lenb)\n\t\t{\n\t\t\tcmp = (lena < lenb) ? -1 : 1;\n\t\t}\n\t}\n\n\treturn cmp;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nint32\ntsCompareString(char *a, int lena, char *b, int lenb, bool prefix)\n{\n\tint\t\t\tcmp;\n\n\tif (lena == 0)\n\t{\n\t\tif (prefix)\n\t\t\tcmp = 0;\t\t\t/* empty string is prefix of anything */\n\t\telse\n\t\t\tcmp = (lenb > 0) ? -1 : 0;\n\t}\n\telse if (lenb == 0)\n\t{\n\t\tcmp = (lena > 0) ? 1 : 0;\n\t}\n\telse\n\t{\n\t\tcmp = memcmp(a, b, Min(lena, lenb));\n\n\t\tif (prefix)\n\t\t{\n\t\t\tif (cmp == 0 && lena > lenb)\n\t\t\t\tcmp = 1;\t\t/* a is longer, so not a prefix of b */\n\t\t}\n\t\telse if (cmp == 0 && lena != lenb)\n\t\t{\n\t\t\tcmp = (lena < lenb) ? -1 : 1;\n\t\t}\n\t}\n\n\treturn cmp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool\ncheckcondition_str(void *checkval, QueryOperand *val, ExecPhraseData *data)\n{\n\tCHKVAL\t   *chkval = (CHKVAL *) checkval;\n\tWordEntry  *StopLow = chkval->arrb;\n\tWordEntry  *StopHigh = chkval->arre;\n\tWordEntry  *StopMiddle = StopHigh;\n\tint\t\t\tdifference = -1;\n\tbool\t\tres = false;\n\n\t/* Loop invariant: StopLow <= val < StopHigh */\n\twhile (StopLow < StopHigh)\n\t{\n\t\tStopMiddle = StopLow + (StopHigh - StopLow) / 2;\n\t\tdifference = tsCompareString(chkval->operand + val->distance,\n\t\t\t\t\t\t\t\t\t val->length,\n\t\t\t\t\t\t\t\t\t chkval->values + StopMiddle->pos,\n\t\t\t\t\t\t\t\t\t StopMiddle->len,\n\t\t\t\t\t\t\t\t\t false);\n\n\t\tif (difference == 0)\n\t\t{\n\t\t\t/* Check weight info & fill 'data' with positions */\n\t\t\tres = checkclass_str(chkval, StopMiddle, val, data);\n\t\t\tbreak;\n\t\t}\n\t\telse if (difference > 0)\n\t\t\tStopLow = StopMiddle + 1;\n\t\telse\n\t\t\tStopHigh = StopMiddle;\n\t}\n\n\tif ((!res || data) && val->prefix)\n\t{\n\t\tWordEntryPos *allpos = NULL;\n\t\tint\t\t\tnpos = 0,\n\t\t\t\t\ttotalpos = 0;\n\n\t\t/*\n\t\t * there was a failed exact search, so we should scan further to find\n\t\t * a prefix match. We also need to do so if caller needs position info\n\t\t */\n\t\tif (StopLow >= StopHigh)\n\t\t\tStopMiddle = StopHigh;\n\n\t\twhile ((!res || data) && StopMiddle < chkval->arre &&\n\t\t\t   tsCompareString(chkval->operand + val->distance,\n\t\t\t\t\t\t\t   val->length,\n\t\t\t\t\t\t\t   chkval->values + StopMiddle->pos,\n\t\t\t\t\t\t\t   StopMiddle->len,\n\t\t\t\t\t\t\t   true) == 0)\n\t\t{\n\t\t\tif (data)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * We need to join position information\n\t\t\t\t */\n\t\t\t\tres = checkclass_str(chkval, StopMiddle, val, data);\n\n\t\t\t\tif (res)\n\t\t\t\t{\n\t\t\t\t\twhile (npos + data->npos >= totalpos)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (totalpos == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttotalpos = 256;\n\t\t\t\t\t\t\tallpos = palloc(sizeof(WordEntryPos) * totalpos);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttotalpos *= 2;\n\t\t\t\t\t\t\tallpos = repalloc(allpos, sizeof(WordEntryPos) * totalpos);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tmemcpy(allpos + npos, data->pos, sizeof(WordEntryPos) * data->npos);\n\t\t\t\t\tnpos += data->npos;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres = checkclass_str(chkval, StopMiddle, val, NULL);\n\t\t\t}\n\n\t\t\tStopMiddle++;\n\t\t}\n\n\t\tif (res && data)\n\t\t{\n\t\t\t/* Sort and make unique array of found positions */\n\t\t\tdata->pos = allpos;\n\t\t\tdata->npos = uniqueLongPos(allpos, npos);\n\t\t\tdata->allocated = true;\n\t\t}\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "uniqueLongPos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "1280-1305",
    "snippet": "static int\nuniqueLongPos(WordEntryPos *pos, int npos)\n{\n\tWordEntryPos *pos_iter,\n\t\t\t   *result;\n\n\tif (npos <= 1)\n\t\treturn npos;\n\n\tqsort((void *) pos, npos, sizeof(WordEntryPos), compareWordEntryPos);\n\n\tresult = pos;\n\tpos_iter = pos + 1;\n\twhile (pos_iter < pos + npos)\n\t{\n\t\tif (WEP_GETPOS(*pos_iter) != WEP_GETPOS(*result))\n\t\t{\n\t\t\tresult++;\n\t\t\t*result = WEP_GETPOS(*pos_iter);\n\t\t}\n\n\t\tpos_iter++;\n\t}\n\n\treturn result + 1 - pos;\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "*pos_iter"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "*result"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "*pos_iter"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "(void *) pos",
            "npos",
            "sizeof(WordEntryPos)",
            "compareWordEntryPos"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\nuniqueLongPos(WordEntryPos *pos, int npos)\n{\n\tWordEntryPos *pos_iter,\n\t\t\t   *result;\n\n\tif (npos <= 1)\n\t\treturn npos;\n\n\tqsort((void *) pos, npos, sizeof(WordEntryPos), compareWordEntryPos);\n\n\tresult = pos;\n\tpos_iter = pos + 1;\n\twhile (pos_iter < pos + npos)\n\t{\n\t\tif (WEP_GETPOS(*pos_iter) != WEP_GETPOS(*result))\n\t\t{\n\t\t\tresult++;\n\t\t\t*result = WEP_GETPOS(*pos_iter);\n\t\t}\n\n\t\tpos_iter++;\n\t}\n\n\treturn result + 1 - pos;\n}"
  },
  {
    "function_name": "checkclass_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "1196-1272",
    "snippet": "static bool\ncheckclass_str(CHKVAL *chkval, WordEntry *entry, QueryOperand *val,\n\t\t\t   ExecPhraseData *data)\n{\n\tbool\t\tresult = false;\n\n\tif (entry->haspos && (val->weight || data))\n\t{\n\t\tWordEntryPosVector *posvec;\n\n\t\t/*\n\t\t * We can't use the _POSVECPTR macro here because the pointer to the\n\t\t * tsvector's lexeme storage is already contained in chkval->values.\n\t\t */\n\t\tposvec = (WordEntryPosVector *)\n\t\t\t(chkval->values + SHORTALIGN(entry->pos + entry->len));\n\n\t\tif (val->weight && data)\n\t\t{\n\t\t\tWordEntryPos *posvec_iter = posvec->pos;\n\t\t\tWordEntryPos *dptr;\n\n\t\t\t/*\n\t\t\t * Filter position information by weights\n\t\t\t */\n\t\t\tdptr = data->pos = palloc(sizeof(WordEntryPos) * posvec->npos);\n\t\t\tdata->allocated = true;\n\n\t\t\t/* Is there a position with a matching weight? */\n\t\t\twhile (posvec_iter < posvec->pos + posvec->npos)\n\t\t\t{\n\t\t\t\t/* If true, append this position to the data->pos */\n\t\t\t\tif (val->weight & (1 << WEP_GETWEIGHT(*posvec_iter)))\n\t\t\t\t{\n\t\t\t\t\t*dptr = WEP_GETPOS(*posvec_iter);\n\t\t\t\t\tdptr++;\n\t\t\t\t}\n\n\t\t\t\tposvec_iter++;\n\t\t\t}\n\n\t\t\tdata->npos = dptr - data->pos;\n\n\t\t\tif (data->npos > 0)\n\t\t\t\tresult = true;\n\t\t}\n\t\telse if (val->weight)\n\t\t{\n\t\t\tWordEntryPos *posvec_iter = posvec->pos;\n\n\t\t\t/* Is there a position with a matching weight? */\n\t\t\twhile (posvec_iter < posvec->pos + posvec->npos)\n\t\t\t{\n\t\t\t\tif (val->weight & (1 << WEP_GETWEIGHT(*posvec_iter)))\n\t\t\t\t{\n\t\t\t\t\tresult = true;\n\t\t\t\t\tbreak;\t\t/* no need to go further */\n\t\t\t\t}\n\n\t\t\t\tposvec_iter++;\n\t\t\t}\n\t\t}\n\t\telse\t\t\t\t\t/* data != NULL */\n\t\t{\n\t\t\tdata->npos = posvec->npos;\n\t\t\tdata->pos = posvec->pos;\n\t\t\tdata->allocated = false;\n\t\t\tresult = true;\n\t\t}\n\t}\n\telse\n\t{\n\t\tresult = true;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "*posvec_iter"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "*posvec_iter"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "*posvec_iter"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(WordEntryPos) * posvec->npos"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SHORTALIGN",
          "args": [
            "entry->pos + entry->len"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic bool\ncheckclass_str(CHKVAL *chkval, WordEntry *entry, QueryOperand *val,\n\t\t\t   ExecPhraseData *data)\n{\n\tbool\t\tresult = false;\n\n\tif (entry->haspos && (val->weight || data))\n\t{\n\t\tWordEntryPosVector *posvec;\n\n\t\t/*\n\t\t * We can't use the _POSVECPTR macro here because the pointer to the\n\t\t * tsvector's lexeme storage is already contained in chkval->values.\n\t\t */\n\t\tposvec = (WordEntryPosVector *)\n\t\t\t(chkval->values + SHORTALIGN(entry->pos + entry->len));\n\n\t\tif (val->weight && data)\n\t\t{\n\t\t\tWordEntryPos *posvec_iter = posvec->pos;\n\t\t\tWordEntryPos *dptr;\n\n\t\t\t/*\n\t\t\t * Filter position information by weights\n\t\t\t */\n\t\t\tdptr = data->pos = palloc(sizeof(WordEntryPos) * posvec->npos);\n\t\t\tdata->allocated = true;\n\n\t\t\t/* Is there a position with a matching weight? */\n\t\t\twhile (posvec_iter < posvec->pos + posvec->npos)\n\t\t\t{\n\t\t\t\t/* If true, append this position to the data->pos */\n\t\t\t\tif (val->weight & (1 << WEP_GETWEIGHT(*posvec_iter)))\n\t\t\t\t{\n\t\t\t\t\t*dptr = WEP_GETPOS(*posvec_iter);\n\t\t\t\t\tdptr++;\n\t\t\t\t}\n\n\t\t\t\tposvec_iter++;\n\t\t\t}\n\n\t\t\tdata->npos = dptr - data->pos;\n\n\t\t\tif (data->npos > 0)\n\t\t\t\tresult = true;\n\t\t}\n\t\telse if (val->weight)\n\t\t{\n\t\t\tWordEntryPos *posvec_iter = posvec->pos;\n\n\t\t\t/* Is there a position with a matching weight? */\n\t\t\twhile (posvec_iter < posvec->pos + posvec->npos)\n\t\t\t{\n\t\t\t\tif (val->weight & (1 << WEP_GETWEIGHT(*posvec_iter)))\n\t\t\t\t{\n\t\t\t\t\tresult = true;\n\t\t\t\t\tbreak;\t\t/* no need to go further */\n\t\t\t\t}\n\n\t\t\t\tposvec_iter++;\n\t\t\t}\n\t\t}\n\t\telse\t\t\t\t\t/* data != NULL */\n\t\t{\n\t\t\tdata->npos = posvec->npos;\n\t\t\tdata->pos = posvec->pos;\n\t\t\tdata->allocated = false;\n\t\t\tresult = true;\n\t\t}\n\t}\n\telse\n\t{\n\t\tresult = true;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "tsCompareString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "1159-1191",
    "snippet": "int32\ntsCompareString(char *a, int lena, char *b, int lenb, bool prefix)\n{\n\tint\t\t\tcmp;\n\n\tif (lena == 0)\n\t{\n\t\tif (prefix)\n\t\t\tcmp = 0;\t\t\t/* empty string is prefix of anything */\n\t\telse\n\t\t\tcmp = (lenb > 0) ? -1 : 0;\n\t}\n\telse if (lenb == 0)\n\t{\n\t\tcmp = (lena > 0) ? 1 : 0;\n\t}\n\telse\n\t{\n\t\tcmp = memcmp(a, b, Min(lena, lenb));\n\n\t\tif (prefix)\n\t\t{\n\t\t\tif (cmp == 0 && lena > lenb)\n\t\t\t\tcmp = 1;\t\t/* a is longer, so not a prefix of b */\n\t\t}\n\t\telse if (cmp == 0 && lena != lenb)\n\t\t{\n\t\t\tcmp = (lena < lenb) ? -1 : 1;\n\t\t}\n\t}\n\n\treturn cmp;\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "a",
            "b",
            "Min(lena, lenb)"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "lena",
            "lenb"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nint32\ntsCompareString(char *a, int lena, char *b, int lenb, bool prefix)\n{\n\tint\t\t\tcmp;\n\n\tif (lena == 0)\n\t{\n\t\tif (prefix)\n\t\t\tcmp = 0;\t\t\t/* empty string is prefix of anything */\n\t\telse\n\t\t\tcmp = (lenb > 0) ? -1 : 0;\n\t}\n\telse if (lenb == 0)\n\t{\n\t\tcmp = (lena > 0) ? 1 : 0;\n\t}\n\telse\n\t{\n\t\tcmp = memcmp(a, b, Min(lena, lenb));\n\n\t\tif (prefix)\n\t\t{\n\t\t\tif (cmp == 0 && lena > lenb)\n\t\t\t\tcmp = 1;\t\t/* a is longer, so not a prefix of b */\n\t\t}\n\t\telse if (cmp == 0 && lena != lenb)\n\t\t{\n\t\t\tcmp = (lena < lenb) ? -1 : 1;\n\t\t}\n\t}\n\n\treturn cmp;\n}"
  },
  {
    "function_name": "tsvector_concat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "932-1152",
    "snippet": "Datum\ntsvector_concat(PG_FUNCTION_ARGS)\n{\n\tTSVector\tin1 = PG_GETARG_TSVECTOR(0);\n\tTSVector\tin2 = PG_GETARG_TSVECTOR(1);\n\tTSVector\tout;\n\tWordEntry  *ptr;\n\tWordEntry  *ptr1,\n\t\t\t   *ptr2;\n\tWordEntryPos *p;\n\tint\t\t\tmaxpos = 0,\n\t\t\t\ti,\n\t\t\t\tj,\n\t\t\t\ti1,\n\t\t\t\ti2,\n\t\t\t\tdataoff,\n\t\t\t\toutput_bytes,\n\t\t\t\toutput_size;\n\tchar\t   *data,\n\t\t\t   *data1,\n\t\t\t   *data2;\n\n\t/* Get max position in in1; we'll need this to offset in2's positions */\n\tptr = ARRPTR(in1);\n\ti = in1->size;\n\twhile (i--)\n\t{\n\t\tif ((j = POSDATALEN(in1, ptr)) != 0)\n\t\t{\n\t\t\tp = POSDATAPTR(in1, ptr);\n\t\t\twhile (j--)\n\t\t\t{\n\t\t\t\tif (WEP_GETPOS(*p) > maxpos)\n\t\t\t\t\tmaxpos = WEP_GETPOS(*p);\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tptr++;\n\t}\n\n\tptr1 = ARRPTR(in1);\n\tptr2 = ARRPTR(in2);\n\tdata1 = STRPTR(in1);\n\tdata2 = STRPTR(in2);\n\ti1 = in1->size;\n\ti2 = in2->size;\n\n\t/*\n\t * Conservative estimate of space needed.  We might need all the data in\n\t * both inputs, and conceivably add a pad byte before position data for\n\t * each item where there was none before.\n\t */\n\toutput_bytes = VARSIZE(in1) + VARSIZE(in2) + i1 + i2;\n\n\tout = (TSVector) palloc0(output_bytes);\n\tSET_VARSIZE(out, output_bytes);\n\n\t/*\n\t * We must make out->size valid so that STRPTR(out) is sensible.  We'll\n\t * collapse out any unused space at the end.\n\t */\n\tout->size = in1->size + in2->size;\n\n\tptr = ARRPTR(out);\n\tdata = STRPTR(out);\n\tdataoff = 0;\n\twhile (i1 && i2)\n\t{\n\t\tint\t\t\tcmp = compareEntry(data1, ptr1, data2, ptr2);\n\n\t\tif (cmp < 0)\n\t\t{\t\t\t\t\t\t/* in1 first */\n\t\t\tptr->haspos = ptr1->haspos;\n\t\t\tptr->len = ptr1->len;\n\t\t\tmemcpy(data + dataoff, data1 + ptr1->pos, ptr1->len);\n\t\t\tptr->pos = dataoff;\n\t\t\tdataoff += ptr1->len;\n\t\t\tif (ptr->haspos)\n\t\t\t{\n\t\t\t\tdataoff = SHORTALIGN(dataoff);\n\t\t\t\tmemcpy(data + dataoff, _POSVECPTR(in1, ptr1), POSDATALEN(in1, ptr1) * sizeof(WordEntryPos) + sizeof(uint16));\n\t\t\t\tdataoff += POSDATALEN(in1, ptr1) * sizeof(WordEntryPos) + sizeof(uint16);\n\t\t\t}\n\n\t\t\tptr++;\n\t\t\tptr1++;\n\t\t\ti1--;\n\t\t}\n\t\telse if (cmp > 0)\n\t\t{\t\t\t\t\t\t/* in2 first */\n\t\t\tptr->haspos = ptr2->haspos;\n\t\t\tptr->len = ptr2->len;\n\t\t\tmemcpy(data + dataoff, data2 + ptr2->pos, ptr2->len);\n\t\t\tptr->pos = dataoff;\n\t\t\tdataoff += ptr2->len;\n\t\t\tif (ptr->haspos)\n\t\t\t{\n\t\t\t\tint\t\t\taddlen = add_pos(in2, ptr2, out, ptr, maxpos);\n\n\t\t\t\tif (addlen == 0)\n\t\t\t\t\tptr->haspos = 0;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdataoff = SHORTALIGN(dataoff);\n\t\t\t\t\tdataoff += addlen * sizeof(WordEntryPos) + sizeof(uint16);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tptr++;\n\t\t\tptr2++;\n\t\t\ti2--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tptr->haspos = ptr1->haspos | ptr2->haspos;\n\t\t\tptr->len = ptr1->len;\n\t\t\tmemcpy(data + dataoff, data1 + ptr1->pos, ptr1->len);\n\t\t\tptr->pos = dataoff;\n\t\t\tdataoff += ptr1->len;\n\t\t\tif (ptr->haspos)\n\t\t\t{\n\t\t\t\tif (ptr1->haspos)\n\t\t\t\t{\n\t\t\t\t\tdataoff = SHORTALIGN(dataoff);\n\t\t\t\t\tmemcpy(data + dataoff, _POSVECPTR(in1, ptr1), POSDATALEN(in1, ptr1) * sizeof(WordEntryPos) + sizeof(uint16));\n\t\t\t\t\tdataoff += POSDATALEN(in1, ptr1) * sizeof(WordEntryPos) + sizeof(uint16);\n\t\t\t\t\tif (ptr2->haspos)\n\t\t\t\t\t\tdataoff += add_pos(in2, ptr2, out, ptr, maxpos) * sizeof(WordEntryPos);\n\t\t\t\t}\n\t\t\t\telse\t\t\t/* must have ptr2->haspos */\n\t\t\t\t{\n\t\t\t\t\tint\t\t\taddlen = add_pos(in2, ptr2, out, ptr, maxpos);\n\n\t\t\t\t\tif (addlen == 0)\n\t\t\t\t\t\tptr->haspos = 0;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdataoff = SHORTALIGN(dataoff);\n\t\t\t\t\t\tdataoff += addlen * sizeof(WordEntryPos) + sizeof(uint16);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tptr++;\n\t\t\tptr1++;\n\t\t\tptr2++;\n\t\t\ti1--;\n\t\t\ti2--;\n\t\t}\n\t}\n\n\twhile (i1)\n\t{\n\t\tptr->haspos = ptr1->haspos;\n\t\tptr->len = ptr1->len;\n\t\tmemcpy(data + dataoff, data1 + ptr1->pos, ptr1->len);\n\t\tptr->pos = dataoff;\n\t\tdataoff += ptr1->len;\n\t\tif (ptr->haspos)\n\t\t{\n\t\t\tdataoff = SHORTALIGN(dataoff);\n\t\t\tmemcpy(data + dataoff, _POSVECPTR(in1, ptr1), POSDATALEN(in1, ptr1) * sizeof(WordEntryPos) + sizeof(uint16));\n\t\t\tdataoff += POSDATALEN(in1, ptr1) * sizeof(WordEntryPos) + sizeof(uint16);\n\t\t}\n\n\t\tptr++;\n\t\tptr1++;\n\t\ti1--;\n\t}\n\n\twhile (i2)\n\t{\n\t\tptr->haspos = ptr2->haspos;\n\t\tptr->len = ptr2->len;\n\t\tmemcpy(data + dataoff, data2 + ptr2->pos, ptr2->len);\n\t\tptr->pos = dataoff;\n\t\tdataoff += ptr2->len;\n\t\tif (ptr->haspos)\n\t\t{\n\t\t\tint\t\t\taddlen = add_pos(in2, ptr2, out, ptr, maxpos);\n\n\t\t\tif (addlen == 0)\n\t\t\t\tptr->haspos = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tdataoff = SHORTALIGN(dataoff);\n\t\t\t\tdataoff += addlen * sizeof(WordEntryPos) + sizeof(uint16);\n\t\t\t}\n\t\t}\n\n\t\tptr++;\n\t\tptr2++;\n\t\ti2--;\n\t}\n\n\t/*\n\t * Instead of checking each offset individually, we check for overflow of\n\t * pos fields once at the end.\n\t */\n\tif (dataoff > MAXSTRPOS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"string is too long for tsvector (%d bytes, max %d bytes)\", dataoff, MAXSTRPOS)));\n\n\t/*\n\t * Adjust sizes (asserting that we didn't overrun the original estimates)\n\t * and collapse out any unused array entries.\n\t */\n\toutput_size = ptr - ARRPTR(out);\n\tAssert(output_size <= out->size);\n\tout->size = output_size;\n\tif (data != STRPTR(out))\n\t\tmemmove(STRPTR(out), data, dataoff);\n\toutput_bytes = CALCDATASIZE(out->size, dataoff);\n\tAssert(output_bytes <= VARSIZE(out));\n\tSET_VARSIZE(out, output_bytes);\n\n\tPG_FREE_IF_COPY(in1, 0);\n\tPG_FREE_IF_COPY(in2, 1);\n\tPG_RETURN_POINTER(out);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "out"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "in2",
            "1"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "in1",
            "0"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "out",
            "output_bytes"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "output_bytes <= VARSIZE(out)"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "out"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CALCDATASIZE",
          "args": [
            "out->size",
            "dataoff"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "STRPTR(out)",
            "data",
            "dataoff"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "out"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "out"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "output_size <= out->size"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "out"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"string is too long for tsvector (%d bytes, max %d bytes)\", dataoff, MAXSTRPOS))"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"string is too long for tsvector (%d bytes, max %d bytes)\"",
            "dataoff",
            "MAXSTRPOS"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_PROGRAM_LIMIT_EXCEEDED"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "SHORTALIGN",
          "args": [
            "dataoff"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_pos",
          "args": [
            "in2",
            "ptr2",
            "out",
            "ptr",
            "maxpos"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "add_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "356-385",
          "snippet": "static int32\nadd_pos(TSVector src, WordEntry *srcptr,\n\t\tTSVector dest, WordEntry *destptr,\n\t\tint32 maxpos)\n{\n\tuint16\t   *clen = &_POSVECPTR(dest, destptr)->npos;\n\tint\t\t\ti;\n\tuint16\t\tslen = POSDATALEN(src, srcptr),\n\t\t\t\tstartlen;\n\tWordEntryPos *spos = POSDATAPTR(src, srcptr),\n\t\t\t   *dpos = POSDATAPTR(dest, destptr);\n\n\tif (!destptr->haspos)\n\t\t*clen = 0;\n\n\tstartlen = *clen;\n\tfor (i = 0;\n\t\t i < slen && *clen < MAXNUMPOS &&\n\t\t (*clen == 0 || WEP_GETPOS(dpos[*clen - 1]) != MAXENTRYPOS - 1);\n\t\t i++)\n\t{\n\t\tWEP_SETWEIGHT(dpos[*clen], WEP_GETWEIGHT(spos[i]));\n\t\tWEP_SETPOS(dpos[*clen], LIMITPOS(WEP_GETPOS(spos[i]) + maxpos));\n\t\t(*clen)++;\n\t}\n\n\tif (*clen != startlen)\n\t\tdestptr->haspos = 1;\n\treturn *clen - startlen;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int32\nadd_pos(TSVector src, WordEntry *srcptr,\n\t\tTSVector dest, WordEntry *destptr,\n\t\tint32 maxpos)\n{\n\tuint16\t   *clen = &_POSVECPTR(dest, destptr)->npos;\n\tint\t\t\ti;\n\tuint16\t\tslen = POSDATALEN(src, srcptr),\n\t\t\t\tstartlen;\n\tWordEntryPos *spos = POSDATAPTR(src, srcptr),\n\t\t\t   *dpos = POSDATAPTR(dest, destptr);\n\n\tif (!destptr->haspos)\n\t\t*clen = 0;\n\n\tstartlen = *clen;\n\tfor (i = 0;\n\t\t i < slen && *clen < MAXNUMPOS &&\n\t\t (*clen == 0 || WEP_GETPOS(dpos[*clen - 1]) != MAXENTRYPOS - 1);\n\t\t i++)\n\t{\n\t\tWEP_SETWEIGHT(dpos[*clen], WEP_GETWEIGHT(spos[i]));\n\t\tWEP_SETPOS(dpos[*clen], LIMITPOS(WEP_GETPOS(spos[i]) + maxpos));\n\t\t(*clen)++;\n\t}\n\n\tif (*clen != startlen)\n\t\tdestptr->haspos = 1;\n\treturn *clen - startlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + dataoff",
            "data2 + ptr2->pos",
            "ptr2->len"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "in1",
            "ptr1"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + dataoff",
            "_POSVECPTR(in1, ptr1)",
            "POSDATALEN(in1, ptr1) * sizeof(WordEntryPos) + sizeof(uint16)"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "in1",
            "ptr1"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_POSVECPTR",
          "args": [
            "in1",
            "ptr1"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHORTALIGN",
          "args": [
            "dataoff"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + dataoff",
            "data1 + ptr1->pos",
            "ptr1->len"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHORTALIGN",
          "args": [
            "dataoff"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "in1",
            "ptr1"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + dataoff",
            "_POSVECPTR(in1, ptr1)",
            "POSDATALEN(in1, ptr1) * sizeof(WordEntryPos) + sizeof(uint16)"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "in1",
            "ptr1"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_POSVECPTR",
          "args": [
            "in1",
            "ptr1"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHORTALIGN",
          "args": [
            "dataoff"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + dataoff",
            "data1 + ptr1->pos",
            "ptr1->len"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHORTALIGN",
          "args": [
            "dataoff"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + dataoff",
            "data2 + ptr2->pos",
            "ptr2->len"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "in1",
            "ptr1"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + dataoff",
            "_POSVECPTR(in1, ptr1)",
            "POSDATALEN(in1, ptr1) * sizeof(WordEntryPos) + sizeof(uint16)"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "in1",
            "ptr1"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_POSVECPTR",
          "args": [
            "in1",
            "ptr1"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHORTALIGN",
          "args": [
            "dataoff"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + dataoff",
            "data1 + ptr1->pos",
            "ptr1->len"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compareEntry",
          "args": [
            "data1",
            "ptr1",
            "data2",
            "ptr2"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "out"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "out"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "out",
            "output_bytes"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "output_bytes"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "in2"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "in1"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "in2"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "in1"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "in2"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "in1"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "*p"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "*p"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATAPTR",
          "args": [
            "in1",
            "ptr"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "in1",
            "ptr"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "in1"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "1"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "0"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ntsvector_concat(PG_FUNCTION_ARGS)\n{\n\tTSVector\tin1 = PG_GETARG_TSVECTOR(0);\n\tTSVector\tin2 = PG_GETARG_TSVECTOR(1);\n\tTSVector\tout;\n\tWordEntry  *ptr;\n\tWordEntry  *ptr1,\n\t\t\t   *ptr2;\n\tWordEntryPos *p;\n\tint\t\t\tmaxpos = 0,\n\t\t\t\ti,\n\t\t\t\tj,\n\t\t\t\ti1,\n\t\t\t\ti2,\n\t\t\t\tdataoff,\n\t\t\t\toutput_bytes,\n\t\t\t\toutput_size;\n\tchar\t   *data,\n\t\t\t   *data1,\n\t\t\t   *data2;\n\n\t/* Get max position in in1; we'll need this to offset in2's positions */\n\tptr = ARRPTR(in1);\n\ti = in1->size;\n\twhile (i--)\n\t{\n\t\tif ((j = POSDATALEN(in1, ptr)) != 0)\n\t\t{\n\t\t\tp = POSDATAPTR(in1, ptr);\n\t\t\twhile (j--)\n\t\t\t{\n\t\t\t\tif (WEP_GETPOS(*p) > maxpos)\n\t\t\t\t\tmaxpos = WEP_GETPOS(*p);\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tptr++;\n\t}\n\n\tptr1 = ARRPTR(in1);\n\tptr2 = ARRPTR(in2);\n\tdata1 = STRPTR(in1);\n\tdata2 = STRPTR(in2);\n\ti1 = in1->size;\n\ti2 = in2->size;\n\n\t/*\n\t * Conservative estimate of space needed.  We might need all the data in\n\t * both inputs, and conceivably add a pad byte before position data for\n\t * each item where there was none before.\n\t */\n\toutput_bytes = VARSIZE(in1) + VARSIZE(in2) + i1 + i2;\n\n\tout = (TSVector) palloc0(output_bytes);\n\tSET_VARSIZE(out, output_bytes);\n\n\t/*\n\t * We must make out->size valid so that STRPTR(out) is sensible.  We'll\n\t * collapse out any unused space at the end.\n\t */\n\tout->size = in1->size + in2->size;\n\n\tptr = ARRPTR(out);\n\tdata = STRPTR(out);\n\tdataoff = 0;\n\twhile (i1 && i2)\n\t{\n\t\tint\t\t\tcmp = compareEntry(data1, ptr1, data2, ptr2);\n\n\t\tif (cmp < 0)\n\t\t{\t\t\t\t\t\t/* in1 first */\n\t\t\tptr->haspos = ptr1->haspos;\n\t\t\tptr->len = ptr1->len;\n\t\t\tmemcpy(data + dataoff, data1 + ptr1->pos, ptr1->len);\n\t\t\tptr->pos = dataoff;\n\t\t\tdataoff += ptr1->len;\n\t\t\tif (ptr->haspos)\n\t\t\t{\n\t\t\t\tdataoff = SHORTALIGN(dataoff);\n\t\t\t\tmemcpy(data + dataoff, _POSVECPTR(in1, ptr1), POSDATALEN(in1, ptr1) * sizeof(WordEntryPos) + sizeof(uint16));\n\t\t\t\tdataoff += POSDATALEN(in1, ptr1) * sizeof(WordEntryPos) + sizeof(uint16);\n\t\t\t}\n\n\t\t\tptr++;\n\t\t\tptr1++;\n\t\t\ti1--;\n\t\t}\n\t\telse if (cmp > 0)\n\t\t{\t\t\t\t\t\t/* in2 first */\n\t\t\tptr->haspos = ptr2->haspos;\n\t\t\tptr->len = ptr2->len;\n\t\t\tmemcpy(data + dataoff, data2 + ptr2->pos, ptr2->len);\n\t\t\tptr->pos = dataoff;\n\t\t\tdataoff += ptr2->len;\n\t\t\tif (ptr->haspos)\n\t\t\t{\n\t\t\t\tint\t\t\taddlen = add_pos(in2, ptr2, out, ptr, maxpos);\n\n\t\t\t\tif (addlen == 0)\n\t\t\t\t\tptr->haspos = 0;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdataoff = SHORTALIGN(dataoff);\n\t\t\t\t\tdataoff += addlen * sizeof(WordEntryPos) + sizeof(uint16);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tptr++;\n\t\t\tptr2++;\n\t\t\ti2--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tptr->haspos = ptr1->haspos | ptr2->haspos;\n\t\t\tptr->len = ptr1->len;\n\t\t\tmemcpy(data + dataoff, data1 + ptr1->pos, ptr1->len);\n\t\t\tptr->pos = dataoff;\n\t\t\tdataoff += ptr1->len;\n\t\t\tif (ptr->haspos)\n\t\t\t{\n\t\t\t\tif (ptr1->haspos)\n\t\t\t\t{\n\t\t\t\t\tdataoff = SHORTALIGN(dataoff);\n\t\t\t\t\tmemcpy(data + dataoff, _POSVECPTR(in1, ptr1), POSDATALEN(in1, ptr1) * sizeof(WordEntryPos) + sizeof(uint16));\n\t\t\t\t\tdataoff += POSDATALEN(in1, ptr1) * sizeof(WordEntryPos) + sizeof(uint16);\n\t\t\t\t\tif (ptr2->haspos)\n\t\t\t\t\t\tdataoff += add_pos(in2, ptr2, out, ptr, maxpos) * sizeof(WordEntryPos);\n\t\t\t\t}\n\t\t\t\telse\t\t\t/* must have ptr2->haspos */\n\t\t\t\t{\n\t\t\t\t\tint\t\t\taddlen = add_pos(in2, ptr2, out, ptr, maxpos);\n\n\t\t\t\t\tif (addlen == 0)\n\t\t\t\t\t\tptr->haspos = 0;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tdataoff = SHORTALIGN(dataoff);\n\t\t\t\t\t\tdataoff += addlen * sizeof(WordEntryPos) + sizeof(uint16);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tptr++;\n\t\t\tptr1++;\n\t\t\tptr2++;\n\t\t\ti1--;\n\t\t\ti2--;\n\t\t}\n\t}\n\n\twhile (i1)\n\t{\n\t\tptr->haspos = ptr1->haspos;\n\t\tptr->len = ptr1->len;\n\t\tmemcpy(data + dataoff, data1 + ptr1->pos, ptr1->len);\n\t\tptr->pos = dataoff;\n\t\tdataoff += ptr1->len;\n\t\tif (ptr->haspos)\n\t\t{\n\t\t\tdataoff = SHORTALIGN(dataoff);\n\t\t\tmemcpy(data + dataoff, _POSVECPTR(in1, ptr1), POSDATALEN(in1, ptr1) * sizeof(WordEntryPos) + sizeof(uint16));\n\t\t\tdataoff += POSDATALEN(in1, ptr1) * sizeof(WordEntryPos) + sizeof(uint16);\n\t\t}\n\n\t\tptr++;\n\t\tptr1++;\n\t\ti1--;\n\t}\n\n\twhile (i2)\n\t{\n\t\tptr->haspos = ptr2->haspos;\n\t\tptr->len = ptr2->len;\n\t\tmemcpy(data + dataoff, data2 + ptr2->pos, ptr2->len);\n\t\tptr->pos = dataoff;\n\t\tdataoff += ptr2->len;\n\t\tif (ptr->haspos)\n\t\t{\n\t\t\tint\t\t\taddlen = add_pos(in2, ptr2, out, ptr, maxpos);\n\n\t\t\tif (addlen == 0)\n\t\t\t\tptr->haspos = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tdataoff = SHORTALIGN(dataoff);\n\t\t\t\tdataoff += addlen * sizeof(WordEntryPos) + sizeof(uint16);\n\t\t\t}\n\t\t}\n\n\t\tptr++;\n\t\tptr2++;\n\t\ti2--;\n\t}\n\n\t/*\n\t * Instead of checking each offset individually, we check for overflow of\n\t * pos fields once at the end.\n\t */\n\tif (dataoff > MAXSTRPOS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"string is too long for tsvector (%d bytes, max %d bytes)\", dataoff, MAXSTRPOS)));\n\n\t/*\n\t * Adjust sizes (asserting that we didn't overrun the original estimates)\n\t * and collapse out any unused array entries.\n\t */\n\toutput_size = ptr - ARRPTR(out);\n\tAssert(output_size <= out->size);\n\tout->size = output_size;\n\tif (data != STRPTR(out))\n\t\tmemmove(STRPTR(out), data, dataoff);\n\toutput_bytes = CALCDATASIZE(out->size, dataoff);\n\tAssert(output_bytes <= VARSIZE(out));\n\tSET_VARSIZE(out, output_bytes);\n\n\tPG_FREE_IF_COPY(in1, 0);\n\tPG_FREE_IF_COPY(in2, 1);\n\tPG_RETURN_POINTER(out);\n}"
  },
  {
    "function_name": "tsvector_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "825-930",
    "snippet": "Datum\ntsvector_filter(PG_FUNCTION_ARGS)\n{\n\tTSVector\ttsin = PG_GETARG_TSVECTOR(0),\n\t\t\t\ttsout;\n\tArrayType  *weights = PG_GETARG_ARRAYTYPE_P(1);\n\tWordEntry  *arrin = ARRPTR(tsin),\n\t\t\t   *arrout;\n\tchar\t   *datain = STRPTR(tsin),\n\t\t\t   *dataout;\n\tDatum\t   *dweights;\n\tbool\t   *nulls;\n\tint\t\t\tnweights;\n\tint\t\t\ti,\n\t\t\t\tj;\n\tint\t\t\tcur_pos = 0;\n\tchar\t\tmask = 0;\n\n\tdeconstruct_array(weights, CHAROID, 1, true, 'c',\n\t\t\t\t\t  &dweights, &nulls, &nweights);\n\n\tfor (i = 0; i < nweights; i++)\n\t{\n\t\tchar\t\tchar_weight;\n\n\t\tif (nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"weight array may not contain nulls\")));\n\n\t\tchar_weight = DatumGetChar(dweights[i]);\n\t\tswitch (char_weight)\n\t\t{\n\t\t\tcase 'A':\n\t\t\tcase 'a':\n\t\t\t\tmask = mask | 8;\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\tcase 'b':\n\t\t\t\tmask = mask | 4;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\tcase 'c':\n\t\t\t\tmask = mask | 2;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\tcase 'd':\n\t\t\t\tmask = mask | 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"unrecognized weight: \\\"%c\\\"\", char_weight)));\n\t\t}\n\t}\n\n\ttsout = (TSVector) palloc0(VARSIZE(tsin));\n\ttsout->size = tsin->size;\n\tarrout = ARRPTR(tsout);\n\tdataout = STRPTR(tsout);\n\n\tfor (i = j = 0; i < tsin->size; i++)\n\t{\n\t\tWordEntryPosVector *posvin,\n\t\t\t\t   *posvout;\n\t\tint\t\t\tnpos = 0;\n\t\tint\t\t\tk;\n\n\t\tif (!arrin[i].haspos)\n\t\t\tcontinue;\n\n\t\tposvin = _POSVECPTR(tsin, arrin + i);\n\t\tposvout = (WordEntryPosVector *)\n\t\t\t(dataout + SHORTALIGN(cur_pos + arrin[i].len));\n\n\t\tfor (k = 0; k < posvin->npos; k++)\n\t\t{\n\t\t\tif (mask & (1 << WEP_GETWEIGHT(posvin->pos[k])))\n\t\t\t\tposvout->pos[npos++] = posvin->pos[k];\n\t\t}\n\n\t\t/* if no satisfactory positions found, skip lexeme */\n\t\tif (!npos)\n\t\t\tcontinue;\n\n\t\tarrout[j].haspos = true;\n\t\tarrout[j].len = arrin[i].len;\n\t\tarrout[j].pos = cur_pos;\n\n\t\tmemcpy(dataout + cur_pos, datain + arrin[i].pos, arrin[i].len);\n\t\tposvout->npos = npos;\n\t\tcur_pos += SHORTALIGN(arrin[i].len);\n\t\tcur_pos += POSDATALEN(tsout, arrout + j) * sizeof(WordEntryPos) +\n\t\t\tsizeof(uint16);\n\t\tj++;\n\t}\n\n\ttsout->size = j;\n\tif (dataout != STRPTR(tsout))\n\t\tmemmove(STRPTR(tsout), dataout, cur_pos);\n\n\tSET_VARSIZE(tsout, CALCDATASIZE(tsout->size, cur_pos));\n\n\tPG_FREE_IF_COPY(tsin, 0);\n\tPG_RETURN_POINTER(tsout);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "tsout"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "tsin",
            "0"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "tsout",
            "CALCDATASIZE(tsout->size, cur_pos)"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CALCDATASIZE",
          "args": [
            "tsout->size",
            "cur_pos"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "STRPTR(tsout)",
            "dataout",
            "cur_pos"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "tsout"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "tsout"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "tsout",
            "arrout + j"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHORTALIGN",
          "args": [
            "arrin[i].len"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dataout + cur_pos",
            "datain + arrin[i].pos",
            "arrin[i].len"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "posvin->pos[k]"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHORTALIGN",
          "args": [
            "cur_pos + arrin[i].len"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_POSVECPTR",
          "args": [
            "tsin",
            "arrin + i"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "tsout"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "tsout"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "VARSIZE(tsin)"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "tsin"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"unrecognized weight: \\\"%c\\\"\", char_weight))"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"unrecognized weight: \\\"%c\\\"\"",
            "char_weight"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_INVALID_PARAMETER_VALUE"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DatumGetChar",
          "args": [
            "dweights[i]"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"weight array may not contain nulls\"))"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "weights",
            "CHAROID",
            "1",
            "true",
            "'c'",
            "&dweights",
            "&nulls",
            "&nweights"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "tsin"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "tsin"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "0"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ntsvector_filter(PG_FUNCTION_ARGS)\n{\n\tTSVector\ttsin = PG_GETARG_TSVECTOR(0),\n\t\t\t\ttsout;\n\tArrayType  *weights = PG_GETARG_ARRAYTYPE_P(1);\n\tWordEntry  *arrin = ARRPTR(tsin),\n\t\t\t   *arrout;\n\tchar\t   *datain = STRPTR(tsin),\n\t\t\t   *dataout;\n\tDatum\t   *dweights;\n\tbool\t   *nulls;\n\tint\t\t\tnweights;\n\tint\t\t\ti,\n\t\t\t\tj;\n\tint\t\t\tcur_pos = 0;\n\tchar\t\tmask = 0;\n\n\tdeconstruct_array(weights, CHAROID, 1, true, 'c',\n\t\t\t\t\t  &dweights, &nulls, &nweights);\n\n\tfor (i = 0; i < nweights; i++)\n\t{\n\t\tchar\t\tchar_weight;\n\n\t\tif (nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"weight array may not contain nulls\")));\n\n\t\tchar_weight = DatumGetChar(dweights[i]);\n\t\tswitch (char_weight)\n\t\t{\n\t\t\tcase 'A':\n\t\t\tcase 'a':\n\t\t\t\tmask = mask | 8;\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\tcase 'b':\n\t\t\t\tmask = mask | 4;\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\tcase 'c':\n\t\t\t\tmask = mask | 2;\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\tcase 'd':\n\t\t\t\tmask = mask | 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t\t\t errmsg(\"unrecognized weight: \\\"%c\\\"\", char_weight)));\n\t\t}\n\t}\n\n\ttsout = (TSVector) palloc0(VARSIZE(tsin));\n\ttsout->size = tsin->size;\n\tarrout = ARRPTR(tsout);\n\tdataout = STRPTR(tsout);\n\n\tfor (i = j = 0; i < tsin->size; i++)\n\t{\n\t\tWordEntryPosVector *posvin,\n\t\t\t\t   *posvout;\n\t\tint\t\t\tnpos = 0;\n\t\tint\t\t\tk;\n\n\t\tif (!arrin[i].haspos)\n\t\t\tcontinue;\n\n\t\tposvin = _POSVECPTR(tsin, arrin + i);\n\t\tposvout = (WordEntryPosVector *)\n\t\t\t(dataout + SHORTALIGN(cur_pos + arrin[i].len));\n\n\t\tfor (k = 0; k < posvin->npos; k++)\n\t\t{\n\t\t\tif (mask & (1 << WEP_GETWEIGHT(posvin->pos[k])))\n\t\t\t\tposvout->pos[npos++] = posvin->pos[k];\n\t\t}\n\n\t\t/* if no satisfactory positions found, skip lexeme */\n\t\tif (!npos)\n\t\t\tcontinue;\n\n\t\tarrout[j].haspos = true;\n\t\tarrout[j].len = arrin[i].len;\n\t\tarrout[j].pos = cur_pos;\n\n\t\tmemcpy(dataout + cur_pos, datain + arrin[i].pos, arrin[i].len);\n\t\tposvout->npos = npos;\n\t\tcur_pos += SHORTALIGN(arrin[i].len);\n\t\tcur_pos += POSDATALEN(tsout, arrout + j) * sizeof(WordEntryPos) +\n\t\t\tsizeof(uint16);\n\t\tj++;\n\t}\n\n\ttsout->size = j;\n\tif (dataout != STRPTR(tsout))\n\t\tmemmove(STRPTR(tsout), dataout, cur_pos);\n\n\tSET_VARSIZE(tsout, CALCDATASIZE(tsout->size, cur_pos));\n\n\tPG_FREE_IF_COPY(tsin, 0);\n\tPG_RETURN_POINTER(tsout);\n}"
  },
  {
    "function_name": "array_to_tsvector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "755-820",
    "snippet": "Datum\narray_to_tsvector(PG_FUNCTION_ARGS)\n{\n\tArrayType  *v = PG_GETARG_ARRAYTYPE_P(0);\n\tTSVector\ttsout;\n\tDatum\t   *dlexemes;\n\tWordEntry  *arrout;\n\tbool\t   *nulls;\n\tint\t\t\tnitems,\n\t\t\t\ti,\n\t\t\t\tj,\n\t\t\t\ttslen,\n\t\t\t\tdatalen = 0;\n\tchar\t   *cur;\n\n\tdeconstruct_array(v, TEXTOID, -1, false, 'i', &dlexemes, &nulls, &nitems);\n\n\t/* Reject nulls (maybe we should just ignore them, instead?) */\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"lexeme array may not contain nulls\")));\n\t}\n\n\t/* Sort and de-dup, because this is required for a valid tsvector. */\n\tif (nitems > 1)\n\t{\n\t\tqsort(dlexemes, nitems, sizeof(Datum), compare_text_lexemes);\n\t\tj = 0;\n\t\tfor (i = 1; i < nitems; i++)\n\t\t{\n\t\t\tif (compare_text_lexemes(&dlexemes[j], &dlexemes[i]) < 0)\n\t\t\t\tdlexemes[++j] = dlexemes[i];\n\t\t}\n\t\tnitems = ++j;\n\t}\n\n\t/* Calculate space needed for surviving lexemes. */\n\tfor (i = 0; i < nitems; i++)\n\t\tdatalen += VARSIZE(dlexemes[i]) - VARHDRSZ;\n\ttslen = CALCDATASIZE(nitems, datalen);\n\n\t/* Allocate and fill tsvector. */\n\ttsout = (TSVector) palloc0(tslen);\n\tSET_VARSIZE(tsout, tslen);\n\ttsout->size = nitems;\n\n\tarrout = ARRPTR(tsout);\n\tcur = STRPTR(tsout);\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tchar\t   *lex = VARDATA(dlexemes[i]);\n\t\tint\t\t\tlex_len = VARSIZE(dlexemes[i]) - VARHDRSZ;\n\n\t\tmemcpy(cur, lex, lex_len);\n\t\tarrout[i].haspos = 0;\n\t\tarrout[i].len = lex_len;\n\t\tarrout[i].pos = cur - STRPTR(tsout);\n\t\tcur += lex_len;\n\t}\n\n\tPG_FREE_IF_COPY(v, 0);\n\tPG_RETURN_POINTER(tsout);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "tsout"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "v",
            "0"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "tsout"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cur",
            "lex",
            "lex_len"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "dlexemes[i]"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "dlexemes[i]"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "tsout"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "tsout"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "tsout",
            "tslen"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "tslen"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CALCDATASIZE",
          "args": [
            "nitems",
            "datalen"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "dlexemes[i]"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compare_text_lexemes",
          "args": [
            "&dlexemes[j]",
            "&dlexemes[i]"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "compare_text_lexemes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "436-447",
          "snippet": "static int\ncompare_text_lexemes(const void *va, const void *vb)\n{\n\tDatum\t\ta = *((const Datum *) va);\n\tDatum\t\tb = *((const Datum *) vb);\n\tchar\t   *alex = VARDATA_ANY(a);\n\tint\t\t\talex_len = VARSIZE_ANY_EXHDR(a);\n\tchar\t   *blex = VARDATA_ANY(b);\n\tint\t\t\tblex_len = VARSIZE_ANY_EXHDR(b);\n\n\treturn tsCompareString(alex, alex_len, blex, blex_len, false);\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\ncompare_text_lexemes(const void *va, const void *vb)\n{\n\tDatum\t\ta = *((const Datum *) va);\n\tDatum\t\tb = *((const Datum *) vb);\n\tchar\t   *alex = VARDATA_ANY(a);\n\tint\t\t\talex_len = VARSIZE_ANY_EXHDR(a);\n\tchar\t   *blex = VARDATA_ANY(b);\n\tint\t\t\tblex_len = VARSIZE_ANY_EXHDR(b);\n\n\treturn tsCompareString(alex, alex_len, blex, blex_len, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "dlexemes",
            "nitems",
            "sizeof(Datum)",
            "compare_text_lexemes"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"lexeme array may not contain nulls\"))"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"lexeme array may not contain nulls\""
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NULL_VALUE_NOT_ALLOWED"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "v",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&dlexemes",
            "&nulls",
            "&nitems"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "0"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\narray_to_tsvector(PG_FUNCTION_ARGS)\n{\n\tArrayType  *v = PG_GETARG_ARRAYTYPE_P(0);\n\tTSVector\ttsout;\n\tDatum\t   *dlexemes;\n\tWordEntry  *arrout;\n\tbool\t   *nulls;\n\tint\t\t\tnitems,\n\t\t\t\ti,\n\t\t\t\tj,\n\t\t\t\ttslen,\n\t\t\t\tdatalen = 0;\n\tchar\t   *cur;\n\n\tdeconstruct_array(v, TEXTOID, -1, false, 'i', &dlexemes, &nulls, &nitems);\n\n\t/* Reject nulls (maybe we should just ignore them, instead?) */\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tif (nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"lexeme array may not contain nulls\")));\n\t}\n\n\t/* Sort and de-dup, because this is required for a valid tsvector. */\n\tif (nitems > 1)\n\t{\n\t\tqsort(dlexemes, nitems, sizeof(Datum), compare_text_lexemes);\n\t\tj = 0;\n\t\tfor (i = 1; i < nitems; i++)\n\t\t{\n\t\t\tif (compare_text_lexemes(&dlexemes[j], &dlexemes[i]) < 0)\n\t\t\t\tdlexemes[++j] = dlexemes[i];\n\t\t}\n\t\tnitems = ++j;\n\t}\n\n\t/* Calculate space needed for surviving lexemes. */\n\tfor (i = 0; i < nitems; i++)\n\t\tdatalen += VARSIZE(dlexemes[i]) - VARHDRSZ;\n\ttslen = CALCDATASIZE(nitems, datalen);\n\n\t/* Allocate and fill tsvector. */\n\ttsout = (TSVector) palloc0(tslen);\n\tSET_VARSIZE(tsout, tslen);\n\ttsout->size = nitems;\n\n\tarrout = ARRPTR(tsout);\n\tcur = STRPTR(tsout);\n\tfor (i = 0; i < nitems; i++)\n\t{\n\t\tchar\t   *lex = VARDATA(dlexemes[i]);\n\t\tint\t\t\tlex_len = VARSIZE(dlexemes[i]) - VARHDRSZ;\n\n\t\tmemcpy(cur, lex, lex_len);\n\t\tarrout[i].haspos = 0;\n\t\tarrout[i].len = lex_len;\n\t\tarrout[i].pos = cur - STRPTR(tsout);\n\t\tcur += lex_len;\n\t}\n\n\tPG_FREE_IF_COPY(v, 0);\n\tPG_RETURN_POINTER(tsout);\n}"
  },
  {
    "function_name": "tsvector_to_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "727-750",
    "snippet": "Datum\ntsvector_to_array(PG_FUNCTION_ARGS)\n{\n\tTSVector\ttsin = PG_GETARG_TSVECTOR(0);\n\tWordEntry  *arrin = ARRPTR(tsin);\n\tDatum\t   *elements;\n\tint\t\t\ti;\n\tArrayType  *array;\n\n\telements = palloc(tsin->size * sizeof(Datum));\n\n\tfor (i = 0; i < tsin->size; i++)\n\t{\n\t\telements[i] = PointerGetDatum(\n\t\t\t\t\t\t\t\t\t  cstring_to_text_with_len(STRPTR(tsin) + arrin[i].pos, arrin[i].len)\n\t\t\t);\n\t}\n\n\tarray = construct_array(elements, tsin->size, TEXTOID, -1, false, 'i');\n\n\tpfree(elements);\n\tPG_FREE_IF_COPY(tsin, 0);\n\tPG_RETURN_POINTER(array);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "array"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "tsin",
            "0"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "elements"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "construct_array",
          "args": [
            "elements",
            "tsin->size",
            "TEXTOID",
            "-1",
            "false",
            "'i'"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "construct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3290-3303",
          "snippet": "ArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "cstring_to_text_with_len(STRPTR(tsin) + arrin[i].pos, arrin[i].len)"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "STRPTR(tsin) + arrin[i].pos",
            "arrin[i].len"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "tsin"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "tsin->size * sizeof(Datum)"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "tsin"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "0"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ntsvector_to_array(PG_FUNCTION_ARGS)\n{\n\tTSVector\ttsin = PG_GETARG_TSVECTOR(0);\n\tWordEntry  *arrin = ARRPTR(tsin);\n\tDatum\t   *elements;\n\tint\t\t\ti;\n\tArrayType  *array;\n\n\telements = palloc(tsin->size * sizeof(Datum));\n\n\tfor (i = 0; i < tsin->size; i++)\n\t{\n\t\telements[i] = PointerGetDatum(\n\t\t\t\t\t\t\t\t\t  cstring_to_text_with_len(STRPTR(tsin) + arrin[i].pos, arrin[i].len)\n\t\t\t);\n\t}\n\n\tarray = construct_array(elements, tsin->size, TEXTOID, -1, false, 'i');\n\n\tpfree(elements);\n\tPG_FREE_IF_COPY(tsin, 0);\n\tPG_RETURN_POINTER(array);\n}"
  },
  {
    "function_name": "tsvector_unnest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "635-722",
    "snippet": "Datum\ntsvector_unnest(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tTSVector\ttsin;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tMemoryContext oldcontext;\n\t\tTupleDesc\ttupdesc;\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\ttupdesc = CreateTemplateTupleDesc(3, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"lexeme\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"positions\",\n\t\t\t\t\t\t   INT2ARRAYOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"weights\",\n\t\t\t\t\t\t   TEXTARRAYOID, -1, 0);\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\n\t\tfuncctx->user_fctx = PG_GETARG_TSVECTOR_COPY(0);\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\ttsin = (TSVector) funcctx->user_fctx;\n\n\tif (funcctx->call_cntr < tsin->size)\n\t{\n\t\tWordEntry  *arrin = ARRPTR(tsin);\n\t\tchar\t   *data = STRPTR(tsin);\n\t\tHeapTuple\ttuple;\n\t\tint\t\t\tj,\n\t\t\t\t\ti = funcctx->call_cntr;\n\t\tbool\t\tnulls[] = {false, false, false};\n\t\tDatum\t\tvalues[3];\n\n\t\tvalues[0] = PointerGetDatum(\n\t\t\t\t\t\t\t\t\tcstring_to_text_with_len(data + arrin[i].pos, arrin[i].len)\n\t\t\t);\n\n\t\tif (arrin[i].haspos)\n\t\t{\n\t\t\tWordEntryPosVector *posv;\n\t\t\tDatum\t   *positions;\n\t\t\tDatum\t   *weights;\n\t\t\tchar\t\tweight;\n\n\t\t\t/*\n\t\t\t * Internally tsvector stores position and weight in the same\n\t\t\t * uint16 (2 bits for weight, 14 for position). Here we extract\n\t\t\t * that in two separate arrays.\n\t\t\t */\n\t\t\tposv = _POSVECPTR(tsin, arrin + i);\n\t\t\tpositions = palloc(posv->npos * sizeof(Datum));\n\t\t\tweights = palloc(posv->npos * sizeof(Datum));\n\t\t\tfor (j = 0; j < posv->npos; j++)\n\t\t\t{\n\t\t\t\tpositions[j] = Int16GetDatum(WEP_GETPOS(posv->pos[j]));\n\t\t\t\tweight = 'D' - WEP_GETWEIGHT(posv->pos[j]);\n\t\t\t\tweights[j] = PointerGetDatum(\n\t\t\t\t\t\t\t\t\t\t\t cstring_to_text_with_len(&weight, 1)\n\t\t\t\t\t);\n\t\t\t}\n\n\t\t\tvalues[1] = PointerGetDatum(\n\t\t\t\t\t\t\t\t\t\tconstruct_array(positions, posv->npos, INT2OID, 2, true, 's'));\n\t\t\tvalues[2] = PointerGetDatum(\n\t\t\t\t\t\t\t\t\t\tconstruct_array(weights, posv->npos, TEXTOID, -1, false, 'i'));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnulls[1] = nulls[2] = true;\n\t\t}\n\n\t\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\t\tSRF_RETURN_NEXT(funcctx, HeapTupleGetDatum(tuple));\n\t}\n\telse\n\t{\n\t\tpfree(tsin);\n\t\tSRF_RETURN_DONE(funcctx);\n\t}\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SRF_RETURN_DONE",
          "args": [
            "funcctx"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "tsin"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SRF_RETURN_NEXT",
          "args": [
            "funcctx",
            "HeapTupleGetDatum(tuple)"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HeapTupleGetDatum",
          "args": [
            "tuple"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heap_form_tuple",
          "args": [
            "funcctx->tuple_desc",
            "values",
            "nulls"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "construct_array(weights, posv->npos, TEXTOID, -1, false, 'i')"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "construct_array",
          "args": [
            "weights",
            "posv->npos",
            "TEXTOID",
            "-1",
            "false",
            "'i'"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "construct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3290-3303",
          "snippet": "ArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nArrayType *\nconstruct_array(Datum *elems, int nelems,\n\t\t\t\tOid elmtype,\n\t\t\t\tint elmlen, bool elmbyval, char elmalign)\n{\n\tint\t\t\tdims[1];\n\tint\t\t\tlbs[1];\n\n\tdims[0] = nelems;\n\tlbs[0] = 1;\n\n\treturn construct_md_array(elems, NULL, 1, dims, lbs,\n\t\t\t\t\t\t\t  elmtype, elmlen, elmbyval, elmalign);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "construct_array(positions, posv->npos, INT2OID, 2, true, 's')"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "cstring_to_text_with_len(&weight, 1)"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cstring_to_text_with_len",
          "args": [
            "&weight",
            "1"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "cstring_to_text_with_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "160-169",
          "snippet": "text *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\ntext *\ncstring_to_text_with_len(const char *s, int len)\n{\n\ttext\t   *result = (text *) palloc(len + VARHDRSZ);\n\n\tSET_VARSIZE(result, len + VARHDRSZ);\n\tmemcpy(VARDATA(result), s, len);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "posv->pos[j]"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Int16GetDatum",
          "args": [
            "WEP_GETPOS(posv->pos[j])"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "posv->pos[j]"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "posv->npos * sizeof(Datum)"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_POSVECPTR",
          "args": [
            "tsin",
            "arrin + i"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PointerGetDatum",
          "args": [
            "cstring_to_text_with_len(data + arrin[i].pos, arrin[i].len)"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "tsin"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "tsin"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_PERCALL_SETUP",
          "args": [],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR_COPY",
          "args": [
            "0"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BlessTupleDesc",
          "args": [
            "tupdesc"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 3",
            "\"weights\"",
            "TEXTARRAYOID",
            "-1",
            "0"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 2",
            "\"positions\"",
            "INT2ARRAYOID",
            "-1",
            "0"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TupleDescInitEntry",
          "args": [
            "tupdesc",
            "(AttrNumber) 1",
            "\"lexeme\"",
            "TEXTOID",
            "-1",
            "0"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateTemplateTupleDesc",
          "args": [
            "3",
            "false"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "funcctx->multi_call_memory_ctx"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_FIRSTCALL_INIT",
          "args": [],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SRF_IS_FIRSTCALL",
          "args": [],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ntsvector_unnest(PG_FUNCTION_ARGS)\n{\n\tFuncCallContext *funcctx;\n\tTSVector\ttsin;\n\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tMemoryContext oldcontext;\n\t\tTupleDesc\ttupdesc;\n\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\ttupdesc = CreateTemplateTupleDesc(3, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"lexeme\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"positions\",\n\t\t\t\t\t\t   INT2ARRAYOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"weights\",\n\t\t\t\t\t\t   TEXTARRAYOID, -1, 0);\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\n\t\tfuncctx->user_fctx = PG_GETARG_TSVECTOR_COPY(0);\n\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\tfuncctx = SRF_PERCALL_SETUP();\n\ttsin = (TSVector) funcctx->user_fctx;\n\n\tif (funcctx->call_cntr < tsin->size)\n\t{\n\t\tWordEntry  *arrin = ARRPTR(tsin);\n\t\tchar\t   *data = STRPTR(tsin);\n\t\tHeapTuple\ttuple;\n\t\tint\t\t\tj,\n\t\t\t\t\ti = funcctx->call_cntr;\n\t\tbool\t\tnulls[] = {false, false, false};\n\t\tDatum\t\tvalues[3];\n\n\t\tvalues[0] = PointerGetDatum(\n\t\t\t\t\t\t\t\t\tcstring_to_text_with_len(data + arrin[i].pos, arrin[i].len)\n\t\t\t);\n\n\t\tif (arrin[i].haspos)\n\t\t{\n\t\t\tWordEntryPosVector *posv;\n\t\t\tDatum\t   *positions;\n\t\t\tDatum\t   *weights;\n\t\t\tchar\t\tweight;\n\n\t\t\t/*\n\t\t\t * Internally tsvector stores position and weight in the same\n\t\t\t * uint16 (2 bits for weight, 14 for position). Here we extract\n\t\t\t * that in two separate arrays.\n\t\t\t */\n\t\t\tposv = _POSVECPTR(tsin, arrin + i);\n\t\t\tpositions = palloc(posv->npos * sizeof(Datum));\n\t\t\tweights = palloc(posv->npos * sizeof(Datum));\n\t\t\tfor (j = 0; j < posv->npos; j++)\n\t\t\t{\n\t\t\t\tpositions[j] = Int16GetDatum(WEP_GETPOS(posv->pos[j]));\n\t\t\t\tweight = 'D' - WEP_GETWEIGHT(posv->pos[j]);\n\t\t\t\tweights[j] = PointerGetDatum(\n\t\t\t\t\t\t\t\t\t\t\t cstring_to_text_with_len(&weight, 1)\n\t\t\t\t\t);\n\t\t\t}\n\n\t\t\tvalues[1] = PointerGetDatum(\n\t\t\t\t\t\t\t\t\t\tconstruct_array(positions, posv->npos, INT2OID, 2, true, 's'));\n\t\t\tvalues[2] = PointerGetDatum(\n\t\t\t\t\t\t\t\t\t\tconstruct_array(weights, posv->npos, TEXTOID, -1, false, 'i'));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnulls[1] = nulls[2] = true;\n\t\t}\n\n\t\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\t\tSRF_RETURN_NEXT(funcctx, HeapTupleGetDatum(tuple));\n\t}\n\telse\n\t{\n\t\tpfree(tsin);\n\t\tSRF_RETURN_DONE(funcctx);\n\t}\n}"
  },
  {
    "function_name": "tsvector_delete_arr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "579-627",
    "snippet": "Datum\ntsvector_delete_arr(PG_FUNCTION_ARGS)\n{\n\tTSVector\ttsin = PG_GETARG_TSVECTOR(0),\n\t\t\t\ttsout;\n\tArrayType  *lexemes = PG_GETARG_ARRAYTYPE_P(1);\n\tint\t\t\ti,\n\t\t\t\tnlex,\n\t\t\t\tskip_count,\n\t\t\t   *skip_indices;\n\tDatum\t   *dlexemes;\n\tbool\t   *nulls;\n\n\tdeconstruct_array(lexemes, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &dlexemes, &nulls, &nlex);\n\n\t/*\n\t * In typical use case array of lexemes to delete is relatively small. So\n\t * here we optimize things for that scenario: iterate through lexarr\n\t * performing binary search of each lexeme from lexarr in tsvector.\n\t */\n\tskip_indices = palloc0(nlex * sizeof(int));\n\tfor (i = skip_count = 0; i < nlex; i++)\n\t{\n\t\tchar\t   *lex;\n\t\tint\t\t\tlex_len,\n\t\t\t\t\tlex_pos;\n\n\t\tif (nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"lexeme array may not contain nulls\")));\n\n\t\tlex = VARDATA(dlexemes[i]);\n\t\tlex_len = VARSIZE(dlexemes[i]) - VARHDRSZ;\n\t\tlex_pos = tsvector_bsearch(tsin, lex, lex_len);\n\n\t\tif (lex_pos >= 0)\n\t\t\tskip_indices[skip_count++] = lex_pos;\n\t}\n\n\ttsout = tsvector_delete_by_indices(tsin, skip_indices, skip_count);\n\n\tpfree(skip_indices);\n\tPG_FREE_IF_COPY(tsin, 0);\n\tPG_FREE_IF_COPY(lexemes, 1);\n\n\tPG_RETURN_POINTER(tsout);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "tsout"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "lexemes",
            "1"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "tsin",
            "0"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "skip_indices"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "xml_pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1649-1655",
          "snippet": "static void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void\nxml_pfree(void *ptr)\n{\n\t/* At least some parts of libxml assume xmlFree(NULL) is allowed */\n\tif (ptr)\n\t\tpfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsvector_delete_by_indices",
          "args": [
            "tsin",
            "skip_indices",
            "skip_count"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "tsvector_delete_by_indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "458-549",
          "snippet": "static TSVector\ntsvector_delete_by_indices(TSVector tsv, int *indices_to_delete,\n\t\t\t\t\t\t   int indices_count)\n{\n\tTSVector\ttsout;\n\tWordEntry  *arrin = ARRPTR(tsv),\n\t\t\t   *arrout;\n\tchar\t   *data = STRPTR(tsv),\n\t\t\t   *dataout;\n\tint\t\t\ti,\t\t\t\t/* index in arrin */\n\t\t\t\tj,\t\t\t\t/* index in arrout */\n\t\t\t\tk,\t\t\t\t/* index in indices_to_delete */\n\t\t\t\tcuroff;\t\t\t/* index in dataout area */\n\n\t/*\n\t * Sort the filter array to simplify membership checks below.  Also, get\n\t * rid of any duplicate entries, so that we can assume that indices_count\n\t * is exactly equal to the number of lexemes that will be removed.\n\t */\n\tif (indices_count > 1)\n\t{\n\t\tint\t\t\tkp;\n\n\t\tqsort(indices_to_delete, indices_count, sizeof(int), compare_int);\n\t\tkp = 0;\n\t\tfor (k = 1; k < indices_count; k++)\n\t\t{\n\t\t\tif (indices_to_delete[k] != indices_to_delete[kp])\n\t\t\t\tindices_to_delete[++kp] = indices_to_delete[k];\n\t\t}\n\t\tindices_count = ++kp;\n\t}\n\n\t/*\n\t * Here we overestimate tsout size, since we don't know how much space is\n\t * used by the deleted lexeme(s).  We will set exact size below.\n\t */\n\ttsout = (TSVector) palloc0(VARSIZE(tsv));\n\n\t/* This count must be correct because STRPTR(tsout) relies on it. */\n\ttsout->size = tsv->size - indices_count;\n\n\t/*\n\t * Copy tsv to tsout, skipping lexemes listed in indices_to_delete.\n\t */\n\tarrout = ARRPTR(tsout);\n\tdataout = STRPTR(tsout);\n\tcuroff = 0;\n\tfor (i = j = k = 0; i < tsv->size; i++)\n\t{\n\t\t/*\n\t\t * If current i is present in indices_to_delete, skip this lexeme.\n\t\t * Since indices_to_delete is already sorted, we only need to check\n\t\t * the current (k'th) entry.\n\t\t */\n\t\tif (k < indices_count && i == indices_to_delete[k])\n\t\t{\n\t\t\tk++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Copy lexeme and its positions and weights */\n\t\tmemcpy(dataout + curoff, data + arrin[i].pos, arrin[i].len);\n\t\tarrout[j].haspos = arrin[i].haspos;\n\t\tarrout[j].len = arrin[i].len;\n\t\tarrout[j].pos = curoff;\n\t\tcuroff += arrin[i].len;\n\t\tif (arrin[i].haspos)\n\t\t{\n\t\t\tint\t\t\tlen = POSDATALEN(tsv, arrin + i) * sizeof(WordEntryPos)\n\t\t\t+ sizeof(uint16);\n\n\t\t\tcuroff = SHORTALIGN(curoff);\n\t\t\tmemcpy(dataout + curoff,\n\t\t\t\t   STRPTR(tsv) + SHORTALIGN(arrin[i].pos + arrin[i].len),\n\t\t\t\t   len);\n\t\t\tcuroff += len;\n\t\t}\n\n\t\tj++;\n\t}\n\n\t/*\n\t * k should now be exactly equal to indices_count. If it isn't then the\n\t * caller provided us with indices outside of [0, tsv->size) range and\n\t * estimation of tsout's size is wrong.\n\t */\n\tAssert(k == indices_count);\n\n\tSET_VARSIZE(tsout, CALCDATASIZE(tsout->size, curoff));\n\treturn tsout;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TSVector\ntsvector_delete_by_indices(TSVector tsv, int *indices_to_delete,\n\t\t\t\t\t\t   int indices_count)\n{\n\tTSVector\ttsout;\n\tWordEntry  *arrin = ARRPTR(tsv),\n\t\t\t   *arrout;\n\tchar\t   *data = STRPTR(tsv),\n\t\t\t   *dataout;\n\tint\t\t\ti,\t\t\t\t/* index in arrin */\n\t\t\t\tj,\t\t\t\t/* index in arrout */\n\t\t\t\tk,\t\t\t\t/* index in indices_to_delete */\n\t\t\t\tcuroff;\t\t\t/* index in dataout area */\n\n\t/*\n\t * Sort the filter array to simplify membership checks below.  Also, get\n\t * rid of any duplicate entries, so that we can assume that indices_count\n\t * is exactly equal to the number of lexemes that will be removed.\n\t */\n\tif (indices_count > 1)\n\t{\n\t\tint\t\t\tkp;\n\n\t\tqsort(indices_to_delete, indices_count, sizeof(int), compare_int);\n\t\tkp = 0;\n\t\tfor (k = 1; k < indices_count; k++)\n\t\t{\n\t\t\tif (indices_to_delete[k] != indices_to_delete[kp])\n\t\t\t\tindices_to_delete[++kp] = indices_to_delete[k];\n\t\t}\n\t\tindices_count = ++kp;\n\t}\n\n\t/*\n\t * Here we overestimate tsout size, since we don't know how much space is\n\t * used by the deleted lexeme(s).  We will set exact size below.\n\t */\n\ttsout = (TSVector) palloc0(VARSIZE(tsv));\n\n\t/* This count must be correct because STRPTR(tsout) relies on it. */\n\ttsout->size = tsv->size - indices_count;\n\n\t/*\n\t * Copy tsv to tsout, skipping lexemes listed in indices_to_delete.\n\t */\n\tarrout = ARRPTR(tsout);\n\tdataout = STRPTR(tsout);\n\tcuroff = 0;\n\tfor (i = j = k = 0; i < tsv->size; i++)\n\t{\n\t\t/*\n\t\t * If current i is present in indices_to_delete, skip this lexeme.\n\t\t * Since indices_to_delete is already sorted, we only need to check\n\t\t * the current (k'th) entry.\n\t\t */\n\t\tif (k < indices_count && i == indices_to_delete[k])\n\t\t{\n\t\t\tk++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Copy lexeme and its positions and weights */\n\t\tmemcpy(dataout + curoff, data + arrin[i].pos, arrin[i].len);\n\t\tarrout[j].haspos = arrin[i].haspos;\n\t\tarrout[j].len = arrin[i].len;\n\t\tarrout[j].pos = curoff;\n\t\tcuroff += arrin[i].len;\n\t\tif (arrin[i].haspos)\n\t\t{\n\t\t\tint\t\t\tlen = POSDATALEN(tsv, arrin + i) * sizeof(WordEntryPos)\n\t\t\t+ sizeof(uint16);\n\n\t\t\tcuroff = SHORTALIGN(curoff);\n\t\t\tmemcpy(dataout + curoff,\n\t\t\t\t   STRPTR(tsv) + SHORTALIGN(arrin[i].pos + arrin[i].len),\n\t\t\t\t   len);\n\t\t\tcuroff += len;\n\t\t}\n\n\t\tj++;\n\t}\n\n\t/*\n\t * k should now be exactly equal to indices_count. If it isn't then the\n\t * caller provided us with indices outside of [0, tsv->size) range and\n\t * estimation of tsout's size is wrong.\n\t */\n\tAssert(k == indices_count);\n\n\tSET_VARSIZE(tsout, CALCDATASIZE(tsout->size, curoff));\n\treturn tsout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsvector_bsearch",
          "args": [
            "tsin",
            "lex",
            "lex_len"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "tsvector_bsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "392-419",
          "snippet": "static int\ntsvector_bsearch(const TSVector tsv, char *lexeme, int lexeme_len)\n{\n\tWordEntry  *arrin = ARRPTR(tsv);\n\tint\t\t\tStopLow = 0,\n\t\t\t\tStopHigh = tsv->size,\n\t\t\t\tStopMiddle,\n\t\t\t\tcmp;\n\n\twhile (StopLow < StopHigh)\n\t{\n\t\tStopMiddle = (StopLow + StopHigh) / 2;\n\n\t\tcmp = tsCompareString(lexeme, lexeme_len,\n\t\t\t\t\t\t\t  STRPTR(tsv) + arrin[StopMiddle].pos,\n\t\t\t\t\t\t\t  arrin[StopMiddle].len,\n\t\t\t\t\t\t\t  false);\n\n\t\tif (cmp < 0)\n\t\t\tStopHigh = StopMiddle;\n\t\telse if (cmp > 0)\n\t\t\tStopLow = StopMiddle + 1;\n\t\telse\t\t\t\t\t/* found it */\n\t\t\treturn StopMiddle;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttsvector_bsearch(const TSVector tsv, char *lexeme, int lexeme_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\ttsvector_bsearch(const TSVector tsv, char *lexeme, int lexeme_len);\n\nstatic int\ntsvector_bsearch(const TSVector tsv, char *lexeme, int lexeme_len)\n{\n\tWordEntry  *arrin = ARRPTR(tsv);\n\tint\t\t\tStopLow = 0,\n\t\t\t\tStopHigh = tsv->size,\n\t\t\t\tStopMiddle,\n\t\t\t\tcmp;\n\n\twhile (StopLow < StopHigh)\n\t{\n\t\tStopMiddle = (StopLow + StopHigh) / 2;\n\n\t\tcmp = tsCompareString(lexeme, lexeme_len,\n\t\t\t\t\t\t\t  STRPTR(tsv) + arrin[StopMiddle].pos,\n\t\t\t\t\t\t\t  arrin[StopMiddle].len,\n\t\t\t\t\t\t\t  false);\n\n\t\tif (cmp < 0)\n\t\t\tStopHigh = StopMiddle;\n\t\telse if (cmp > 0)\n\t\t\tStopLow = StopMiddle + 1;\n\t\telse\t\t\t\t\t/* found it */\n\t\t\treturn StopMiddle;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "dlexemes[i]"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "dlexemes[i]"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"lexeme array may not contain nulls\"))"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"lexeme array may not contain nulls\""
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NULL_VALUE_NOT_ALLOWED"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "nlex * sizeof(int)"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "lexemes",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&dlexemes",
            "&nulls",
            "&nlex"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "1"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "0"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ntsvector_delete_arr(PG_FUNCTION_ARGS)\n{\n\tTSVector\ttsin = PG_GETARG_TSVECTOR(0),\n\t\t\t\ttsout;\n\tArrayType  *lexemes = PG_GETARG_ARRAYTYPE_P(1);\n\tint\t\t\ti,\n\t\t\t\tnlex,\n\t\t\t\tskip_count,\n\t\t\t   *skip_indices;\n\tDatum\t   *dlexemes;\n\tbool\t   *nulls;\n\n\tdeconstruct_array(lexemes, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &dlexemes, &nulls, &nlex);\n\n\t/*\n\t * In typical use case array of lexemes to delete is relatively small. So\n\t * here we optimize things for that scenario: iterate through lexarr\n\t * performing binary search of each lexeme from lexarr in tsvector.\n\t */\n\tskip_indices = palloc0(nlex * sizeof(int));\n\tfor (i = skip_count = 0; i < nlex; i++)\n\t{\n\t\tchar\t   *lex;\n\t\tint\t\t\tlex_len,\n\t\t\t\t\tlex_pos;\n\n\t\tif (nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"lexeme array may not contain nulls\")));\n\n\t\tlex = VARDATA(dlexemes[i]);\n\t\tlex_len = VARSIZE(dlexemes[i]) - VARHDRSZ;\n\t\tlex_pos = tsvector_bsearch(tsin, lex, lex_len);\n\n\t\tif (lex_pos >= 0)\n\t\t\tskip_indices[skip_count++] = lex_pos;\n\t}\n\n\ttsout = tsvector_delete_by_indices(tsin, skip_indices, skip_count);\n\n\tpfree(skip_indices);\n\tPG_FREE_IF_COPY(tsin, 0);\n\tPG_FREE_IF_COPY(lexemes, 1);\n\n\tPG_RETURN_POINTER(tsout);\n}"
  },
  {
    "function_name": "tsvector_delete_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "555-573",
    "snippet": "Datum\ntsvector_delete_str(PG_FUNCTION_ARGS)\n{\n\tTSVector\ttsin = PG_GETARG_TSVECTOR(0),\n\t\t\t\ttsout;\n\ttext\t   *tlexeme = PG_GETARG_TEXT_PP(1);\n\tchar\t   *lexeme = VARDATA_ANY(tlexeme);\n\tint\t\t\tlexeme_len = VARSIZE_ANY_EXHDR(tlexeme),\n\t\t\t\tskip_index;\n\n\tif ((skip_index = tsvector_bsearch(tsin, lexeme, lexeme_len)) == -1)\n\t\tPG_RETURN_POINTER(tsin);\n\n\ttsout = tsvector_delete_by_indices(tsin, &skip_index, 1);\n\n\tPG_FREE_IF_COPY(tsin, 0);\n\tPG_FREE_IF_COPY(tlexeme, 1);\n\tPG_RETURN_POINTER(tsout);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttsvector_bsearch(const TSVector tsv, char *lexeme, int lexeme_len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "tsout"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "tlexeme",
            "1"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "tsin",
            "0"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsvector_delete_by_indices",
          "args": [
            "tsin",
            "&skip_index",
            "1"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "tsvector_delete_by_indices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "458-549",
          "snippet": "static TSVector\ntsvector_delete_by_indices(TSVector tsv, int *indices_to_delete,\n\t\t\t\t\t\t   int indices_count)\n{\n\tTSVector\ttsout;\n\tWordEntry  *arrin = ARRPTR(tsv),\n\t\t\t   *arrout;\n\tchar\t   *data = STRPTR(tsv),\n\t\t\t   *dataout;\n\tint\t\t\ti,\t\t\t\t/* index in arrin */\n\t\t\t\tj,\t\t\t\t/* index in arrout */\n\t\t\t\tk,\t\t\t\t/* index in indices_to_delete */\n\t\t\t\tcuroff;\t\t\t/* index in dataout area */\n\n\t/*\n\t * Sort the filter array to simplify membership checks below.  Also, get\n\t * rid of any duplicate entries, so that we can assume that indices_count\n\t * is exactly equal to the number of lexemes that will be removed.\n\t */\n\tif (indices_count > 1)\n\t{\n\t\tint\t\t\tkp;\n\n\t\tqsort(indices_to_delete, indices_count, sizeof(int), compare_int);\n\t\tkp = 0;\n\t\tfor (k = 1; k < indices_count; k++)\n\t\t{\n\t\t\tif (indices_to_delete[k] != indices_to_delete[kp])\n\t\t\t\tindices_to_delete[++kp] = indices_to_delete[k];\n\t\t}\n\t\tindices_count = ++kp;\n\t}\n\n\t/*\n\t * Here we overestimate tsout size, since we don't know how much space is\n\t * used by the deleted lexeme(s).  We will set exact size below.\n\t */\n\ttsout = (TSVector) palloc0(VARSIZE(tsv));\n\n\t/* This count must be correct because STRPTR(tsout) relies on it. */\n\ttsout->size = tsv->size - indices_count;\n\n\t/*\n\t * Copy tsv to tsout, skipping lexemes listed in indices_to_delete.\n\t */\n\tarrout = ARRPTR(tsout);\n\tdataout = STRPTR(tsout);\n\tcuroff = 0;\n\tfor (i = j = k = 0; i < tsv->size; i++)\n\t{\n\t\t/*\n\t\t * If current i is present in indices_to_delete, skip this lexeme.\n\t\t * Since indices_to_delete is already sorted, we only need to check\n\t\t * the current (k'th) entry.\n\t\t */\n\t\tif (k < indices_count && i == indices_to_delete[k])\n\t\t{\n\t\t\tk++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Copy lexeme and its positions and weights */\n\t\tmemcpy(dataout + curoff, data + arrin[i].pos, arrin[i].len);\n\t\tarrout[j].haspos = arrin[i].haspos;\n\t\tarrout[j].len = arrin[i].len;\n\t\tarrout[j].pos = curoff;\n\t\tcuroff += arrin[i].len;\n\t\tif (arrin[i].haspos)\n\t\t{\n\t\t\tint\t\t\tlen = POSDATALEN(tsv, arrin + i) * sizeof(WordEntryPos)\n\t\t\t+ sizeof(uint16);\n\n\t\t\tcuroff = SHORTALIGN(curoff);\n\t\t\tmemcpy(dataout + curoff,\n\t\t\t\t   STRPTR(tsv) + SHORTALIGN(arrin[i].pos + arrin[i].len),\n\t\t\t\t   len);\n\t\t\tcuroff += len;\n\t\t}\n\n\t\tj++;\n\t}\n\n\t/*\n\t * k should now be exactly equal to indices_count. If it isn't then the\n\t * caller provided us with indices outside of [0, tsv->size) range and\n\t * estimation of tsout's size is wrong.\n\t */\n\tAssert(k == indices_count);\n\n\tSET_VARSIZE(tsout, CALCDATASIZE(tsout->size, curoff));\n\treturn tsout;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TSVector\ntsvector_delete_by_indices(TSVector tsv, int *indices_to_delete,\n\t\t\t\t\t\t   int indices_count)\n{\n\tTSVector\ttsout;\n\tWordEntry  *arrin = ARRPTR(tsv),\n\t\t\t   *arrout;\n\tchar\t   *data = STRPTR(tsv),\n\t\t\t   *dataout;\n\tint\t\t\ti,\t\t\t\t/* index in arrin */\n\t\t\t\tj,\t\t\t\t/* index in arrout */\n\t\t\t\tk,\t\t\t\t/* index in indices_to_delete */\n\t\t\t\tcuroff;\t\t\t/* index in dataout area */\n\n\t/*\n\t * Sort the filter array to simplify membership checks below.  Also, get\n\t * rid of any duplicate entries, so that we can assume that indices_count\n\t * is exactly equal to the number of lexemes that will be removed.\n\t */\n\tif (indices_count > 1)\n\t{\n\t\tint\t\t\tkp;\n\n\t\tqsort(indices_to_delete, indices_count, sizeof(int), compare_int);\n\t\tkp = 0;\n\t\tfor (k = 1; k < indices_count; k++)\n\t\t{\n\t\t\tif (indices_to_delete[k] != indices_to_delete[kp])\n\t\t\t\tindices_to_delete[++kp] = indices_to_delete[k];\n\t\t}\n\t\tindices_count = ++kp;\n\t}\n\n\t/*\n\t * Here we overestimate tsout size, since we don't know how much space is\n\t * used by the deleted lexeme(s).  We will set exact size below.\n\t */\n\ttsout = (TSVector) palloc0(VARSIZE(tsv));\n\n\t/* This count must be correct because STRPTR(tsout) relies on it. */\n\ttsout->size = tsv->size - indices_count;\n\n\t/*\n\t * Copy tsv to tsout, skipping lexemes listed in indices_to_delete.\n\t */\n\tarrout = ARRPTR(tsout);\n\tdataout = STRPTR(tsout);\n\tcuroff = 0;\n\tfor (i = j = k = 0; i < tsv->size; i++)\n\t{\n\t\t/*\n\t\t * If current i is present in indices_to_delete, skip this lexeme.\n\t\t * Since indices_to_delete is already sorted, we only need to check\n\t\t * the current (k'th) entry.\n\t\t */\n\t\tif (k < indices_count && i == indices_to_delete[k])\n\t\t{\n\t\t\tk++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Copy lexeme and its positions and weights */\n\t\tmemcpy(dataout + curoff, data + arrin[i].pos, arrin[i].len);\n\t\tarrout[j].haspos = arrin[i].haspos;\n\t\tarrout[j].len = arrin[i].len;\n\t\tarrout[j].pos = curoff;\n\t\tcuroff += arrin[i].len;\n\t\tif (arrin[i].haspos)\n\t\t{\n\t\t\tint\t\t\tlen = POSDATALEN(tsv, arrin + i) * sizeof(WordEntryPos)\n\t\t\t+ sizeof(uint16);\n\n\t\t\tcuroff = SHORTALIGN(curoff);\n\t\t\tmemcpy(dataout + curoff,\n\t\t\t\t   STRPTR(tsv) + SHORTALIGN(arrin[i].pos + arrin[i].len),\n\t\t\t\t   len);\n\t\t\tcuroff += len;\n\t\t}\n\n\t\tj++;\n\t}\n\n\t/*\n\t * k should now be exactly equal to indices_count. If it isn't then the\n\t * caller provided us with indices outside of [0, tsv->size) range and\n\t * estimation of tsout's size is wrong.\n\t */\n\tAssert(k == indices_count);\n\n\tSET_VARSIZE(tsout, CALCDATASIZE(tsout->size, curoff));\n\treturn tsout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "tsin"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsvector_bsearch",
          "args": [
            "tsin",
            "lexeme",
            "lexeme_len"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "tsvector_bsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "392-419",
          "snippet": "static int\ntsvector_bsearch(const TSVector tsv, char *lexeme, int lexeme_len)\n{\n\tWordEntry  *arrin = ARRPTR(tsv);\n\tint\t\t\tStopLow = 0,\n\t\t\t\tStopHigh = tsv->size,\n\t\t\t\tStopMiddle,\n\t\t\t\tcmp;\n\n\twhile (StopLow < StopHigh)\n\t{\n\t\tStopMiddle = (StopLow + StopHigh) / 2;\n\n\t\tcmp = tsCompareString(lexeme, lexeme_len,\n\t\t\t\t\t\t\t  STRPTR(tsv) + arrin[StopMiddle].pos,\n\t\t\t\t\t\t\t  arrin[StopMiddle].len,\n\t\t\t\t\t\t\t  false);\n\n\t\tif (cmp < 0)\n\t\t\tStopHigh = StopMiddle;\n\t\telse if (cmp > 0)\n\t\t\tStopLow = StopMiddle + 1;\n\t\telse\t\t\t\t\t/* found it */\n\t\t\treturn StopMiddle;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttsvector_bsearch(const TSVector tsv, char *lexeme, int lexeme_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\ttsvector_bsearch(const TSVector tsv, char *lexeme, int lexeme_len);\n\nstatic int\ntsvector_bsearch(const TSVector tsv, char *lexeme, int lexeme_len)\n{\n\tWordEntry  *arrin = ARRPTR(tsv);\n\tint\t\t\tStopLow = 0,\n\t\t\t\tStopHigh = tsv->size,\n\t\t\t\tStopMiddle,\n\t\t\t\tcmp;\n\n\twhile (StopLow < StopHigh)\n\t{\n\t\tStopMiddle = (StopLow + StopHigh) / 2;\n\n\t\tcmp = tsCompareString(lexeme, lexeme_len,\n\t\t\t\t\t\t\t  STRPTR(tsv) + arrin[StopMiddle].pos,\n\t\t\t\t\t\t\t  arrin[StopMiddle].len,\n\t\t\t\t\t\t\t  false);\n\n\t\tif (cmp < 0)\n\t\t\tStopHigh = StopMiddle;\n\t\telse if (cmp > 0)\n\t\t\tStopLow = StopMiddle + 1;\n\t\telse\t\t\t\t\t/* found it */\n\t\t\treturn StopMiddle;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "tlexeme"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "tlexeme"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TEXT_PP",
          "args": [
            "1"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "0"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\ttsvector_bsearch(const TSVector tsv, char *lexeme, int lexeme_len);\n\nDatum\ntsvector_delete_str(PG_FUNCTION_ARGS)\n{\n\tTSVector\ttsin = PG_GETARG_TSVECTOR(0),\n\t\t\t\ttsout;\n\ttext\t   *tlexeme = PG_GETARG_TEXT_PP(1);\n\tchar\t   *lexeme = VARDATA_ANY(tlexeme);\n\tint\t\t\tlexeme_len = VARSIZE_ANY_EXHDR(tlexeme),\n\t\t\t\tskip_index;\n\n\tif ((skip_index = tsvector_bsearch(tsin, lexeme, lexeme_len)) == -1)\n\t\tPG_RETURN_POINTER(tsin);\n\n\ttsout = tsvector_delete_by_indices(tsin, &skip_index, 1);\n\n\tPG_FREE_IF_COPY(tsin, 0);\n\tPG_FREE_IF_COPY(tlexeme, 1);\n\tPG_RETURN_POINTER(tsout);\n}"
  },
  {
    "function_name": "tsvector_delete_by_indices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "458-549",
    "snippet": "static TSVector\ntsvector_delete_by_indices(TSVector tsv, int *indices_to_delete,\n\t\t\t\t\t\t   int indices_count)\n{\n\tTSVector\ttsout;\n\tWordEntry  *arrin = ARRPTR(tsv),\n\t\t\t   *arrout;\n\tchar\t   *data = STRPTR(tsv),\n\t\t\t   *dataout;\n\tint\t\t\ti,\t\t\t\t/* index in arrin */\n\t\t\t\tj,\t\t\t\t/* index in arrout */\n\t\t\t\tk,\t\t\t\t/* index in indices_to_delete */\n\t\t\t\tcuroff;\t\t\t/* index in dataout area */\n\n\t/*\n\t * Sort the filter array to simplify membership checks below.  Also, get\n\t * rid of any duplicate entries, so that we can assume that indices_count\n\t * is exactly equal to the number of lexemes that will be removed.\n\t */\n\tif (indices_count > 1)\n\t{\n\t\tint\t\t\tkp;\n\n\t\tqsort(indices_to_delete, indices_count, sizeof(int), compare_int);\n\t\tkp = 0;\n\t\tfor (k = 1; k < indices_count; k++)\n\t\t{\n\t\t\tif (indices_to_delete[k] != indices_to_delete[kp])\n\t\t\t\tindices_to_delete[++kp] = indices_to_delete[k];\n\t\t}\n\t\tindices_count = ++kp;\n\t}\n\n\t/*\n\t * Here we overestimate tsout size, since we don't know how much space is\n\t * used by the deleted lexeme(s).  We will set exact size below.\n\t */\n\ttsout = (TSVector) palloc0(VARSIZE(tsv));\n\n\t/* This count must be correct because STRPTR(tsout) relies on it. */\n\ttsout->size = tsv->size - indices_count;\n\n\t/*\n\t * Copy tsv to tsout, skipping lexemes listed in indices_to_delete.\n\t */\n\tarrout = ARRPTR(tsout);\n\tdataout = STRPTR(tsout);\n\tcuroff = 0;\n\tfor (i = j = k = 0; i < tsv->size; i++)\n\t{\n\t\t/*\n\t\t * If current i is present in indices_to_delete, skip this lexeme.\n\t\t * Since indices_to_delete is already sorted, we only need to check\n\t\t * the current (k'th) entry.\n\t\t */\n\t\tif (k < indices_count && i == indices_to_delete[k])\n\t\t{\n\t\t\tk++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Copy lexeme and its positions and weights */\n\t\tmemcpy(dataout + curoff, data + arrin[i].pos, arrin[i].len);\n\t\tarrout[j].haspos = arrin[i].haspos;\n\t\tarrout[j].len = arrin[i].len;\n\t\tarrout[j].pos = curoff;\n\t\tcuroff += arrin[i].len;\n\t\tif (arrin[i].haspos)\n\t\t{\n\t\t\tint\t\t\tlen = POSDATALEN(tsv, arrin + i) * sizeof(WordEntryPos)\n\t\t\t+ sizeof(uint16);\n\n\t\t\tcuroff = SHORTALIGN(curoff);\n\t\t\tmemcpy(dataout + curoff,\n\t\t\t\t   STRPTR(tsv) + SHORTALIGN(arrin[i].pos + arrin[i].len),\n\t\t\t\t   len);\n\t\t\tcuroff += len;\n\t\t}\n\n\t\tj++;\n\t}\n\n\t/*\n\t * k should now be exactly equal to indices_count. If it isn't then the\n\t * caller provided us with indices outside of [0, tsv->size) range and\n\t * estimation of tsout's size is wrong.\n\t */\n\tAssert(k == indices_count);\n\n\tSET_VARSIZE(tsout, CALCDATASIZE(tsout->size, curoff));\n\treturn tsout;\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "tsout",
            "CALCDATASIZE(tsout->size, curoff)"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CALCDATASIZE",
          "args": [
            "tsout->size",
            "curoff"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "k == indices_count"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dataout + curoff",
            "STRPTR(tsv) + SHORTALIGN(arrin[i].pos + arrin[i].len)",
            "len"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHORTALIGN",
          "args": [
            "arrin[i].pos + arrin[i].len"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "tsv"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHORTALIGN",
          "args": [
            "curoff"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "tsv",
            "arrin + i"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dataout + curoff",
            "data + arrin[i].pos",
            "arrin[i].len"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "tsout"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "tsout"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "VARSIZE(tsv)"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "tsv"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "indices_to_delete",
            "indices_count",
            "sizeof(int)",
            "compare_int"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "tsv"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "tsv"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic TSVector\ntsvector_delete_by_indices(TSVector tsv, int *indices_to_delete,\n\t\t\t\t\t\t   int indices_count)\n{\n\tTSVector\ttsout;\n\tWordEntry  *arrin = ARRPTR(tsv),\n\t\t\t   *arrout;\n\tchar\t   *data = STRPTR(tsv),\n\t\t\t   *dataout;\n\tint\t\t\ti,\t\t\t\t/* index in arrin */\n\t\t\t\tj,\t\t\t\t/* index in arrout */\n\t\t\t\tk,\t\t\t\t/* index in indices_to_delete */\n\t\t\t\tcuroff;\t\t\t/* index in dataout area */\n\n\t/*\n\t * Sort the filter array to simplify membership checks below.  Also, get\n\t * rid of any duplicate entries, so that we can assume that indices_count\n\t * is exactly equal to the number of lexemes that will be removed.\n\t */\n\tif (indices_count > 1)\n\t{\n\t\tint\t\t\tkp;\n\n\t\tqsort(indices_to_delete, indices_count, sizeof(int), compare_int);\n\t\tkp = 0;\n\t\tfor (k = 1; k < indices_count; k++)\n\t\t{\n\t\t\tif (indices_to_delete[k] != indices_to_delete[kp])\n\t\t\t\tindices_to_delete[++kp] = indices_to_delete[k];\n\t\t}\n\t\tindices_count = ++kp;\n\t}\n\n\t/*\n\t * Here we overestimate tsout size, since we don't know how much space is\n\t * used by the deleted lexeme(s).  We will set exact size below.\n\t */\n\ttsout = (TSVector) palloc0(VARSIZE(tsv));\n\n\t/* This count must be correct because STRPTR(tsout) relies on it. */\n\ttsout->size = tsv->size - indices_count;\n\n\t/*\n\t * Copy tsv to tsout, skipping lexemes listed in indices_to_delete.\n\t */\n\tarrout = ARRPTR(tsout);\n\tdataout = STRPTR(tsout);\n\tcuroff = 0;\n\tfor (i = j = k = 0; i < tsv->size; i++)\n\t{\n\t\t/*\n\t\t * If current i is present in indices_to_delete, skip this lexeme.\n\t\t * Since indices_to_delete is already sorted, we only need to check\n\t\t * the current (k'th) entry.\n\t\t */\n\t\tif (k < indices_count && i == indices_to_delete[k])\n\t\t{\n\t\t\tk++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Copy lexeme and its positions and weights */\n\t\tmemcpy(dataout + curoff, data + arrin[i].pos, arrin[i].len);\n\t\tarrout[j].haspos = arrin[i].haspos;\n\t\tarrout[j].len = arrin[i].len;\n\t\tarrout[j].pos = curoff;\n\t\tcuroff += arrin[i].len;\n\t\tif (arrin[i].haspos)\n\t\t{\n\t\t\tint\t\t\tlen = POSDATALEN(tsv, arrin + i) * sizeof(WordEntryPos)\n\t\t\t+ sizeof(uint16);\n\n\t\t\tcuroff = SHORTALIGN(curoff);\n\t\t\tmemcpy(dataout + curoff,\n\t\t\t\t   STRPTR(tsv) + SHORTALIGN(arrin[i].pos + arrin[i].len),\n\t\t\t\t   len);\n\t\t\tcuroff += len;\n\t\t}\n\n\t\tj++;\n\t}\n\n\t/*\n\t * k should now be exactly equal to indices_count. If it isn't then the\n\t * caller provided us with indices outside of [0, tsv->size) range and\n\t * estimation of tsout's size is wrong.\n\t */\n\tAssert(k == indices_count);\n\n\tSET_VARSIZE(tsout, CALCDATASIZE(tsout->size, curoff));\n\treturn tsout;\n}"
  },
  {
    "function_name": "compare_text_lexemes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "436-447",
    "snippet": "static int\ncompare_text_lexemes(const void *va, const void *vb)\n{\n\tDatum\t\ta = *((const Datum *) va);\n\tDatum\t\tb = *((const Datum *) vb);\n\tchar\t   *alex = VARDATA_ANY(a);\n\tint\t\t\talex_len = VARSIZE_ANY_EXHDR(a);\n\tchar\t   *blex = VARDATA_ANY(b);\n\tint\t\t\tblex_len = VARSIZE_ANY_EXHDR(b);\n\n\treturn tsCompareString(alex, alex_len, blex, blex_len, false);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tsCompareString",
          "args": [
            "alex",
            "alex_len",
            "blex",
            "blex_len",
            "false"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "tsCompareString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "1159-1191",
          "snippet": "int32\ntsCompareString(char *a, int lena, char *b, int lenb, bool prefix)\n{\n\tint\t\t\tcmp;\n\n\tif (lena == 0)\n\t{\n\t\tif (prefix)\n\t\t\tcmp = 0;\t\t\t/* empty string is prefix of anything */\n\t\telse\n\t\t\tcmp = (lenb > 0) ? -1 : 0;\n\t}\n\telse if (lenb == 0)\n\t{\n\t\tcmp = (lena > 0) ? 1 : 0;\n\t}\n\telse\n\t{\n\t\tcmp = memcmp(a, b, Min(lena, lenb));\n\n\t\tif (prefix)\n\t\t{\n\t\t\tif (cmp == 0 && lena > lenb)\n\t\t\t\tcmp = 1;\t\t/* a is longer, so not a prefix of b */\n\t\t}\n\t\telse if (cmp == 0 && lena != lenb)\n\t\t{\n\t\t\tcmp = (lena < lenb) ? -1 : 1;\n\t\t}\n\t}\n\n\treturn cmp;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nint32\ntsCompareString(char *a, int lena, char *b, int lenb, bool prefix)\n{\n\tint\t\t\tcmp;\n\n\tif (lena == 0)\n\t{\n\t\tif (prefix)\n\t\t\tcmp = 0;\t\t\t/* empty string is prefix of anything */\n\t\telse\n\t\t\tcmp = (lenb > 0) ? -1 : 0;\n\t}\n\telse if (lenb == 0)\n\t{\n\t\tcmp = (lena > 0) ? 1 : 0;\n\t}\n\telse\n\t{\n\t\tcmp = memcmp(a, b, Min(lena, lenb));\n\n\t\tif (prefix)\n\t\t{\n\t\t\tif (cmp == 0 && lena > lenb)\n\t\t\t\tcmp = 1;\t\t/* a is longer, so not a prefix of b */\n\t\t}\n\t\telse if (cmp == 0 && lena != lenb)\n\t\t{\n\t\t\tcmp = (lena < lenb) ? -1 : 1;\n\t\t}\n\t}\n\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "b"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "b"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE_ANY_EXHDR",
          "args": [
            "a"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA_ANY",
          "args": [
            "a"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\ncompare_text_lexemes(const void *va, const void *vb)\n{\n\tDatum\t\ta = *((const Datum *) va);\n\tDatum\t\tb = *((const Datum *) vb);\n\tchar\t   *alex = VARDATA_ANY(a);\n\tint\t\t\talex_len = VARSIZE_ANY_EXHDR(a);\n\tchar\t   *blex = VARDATA_ANY(b);\n\tint\t\t\tblex_len = VARSIZE_ANY_EXHDR(b);\n\n\treturn tsCompareString(alex, alex_len, blex, blex_len, false);\n}"
  },
  {
    "function_name": "compare_int",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "425-434",
    "snippet": "static int\ncompare_int(const void *va, const void *vb)\n{\n\tint\t\t\ta = *((const int *) va);\n\tint\t\t\tb = *((const int *) vb);\n\n\tif (a == b)\n\t\treturn 0;\n\treturn (a > b) ? 1 : -1;\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\ncompare_int(const void *va, const void *vb)\n{\n\tint\t\t\ta = *((const int *) va);\n\tint\t\t\tb = *((const int *) vb);\n\n\tif (a == b)\n\t\treturn 0;\n\treturn (a > b) ? 1 : -1;\n}"
  },
  {
    "function_name": "tsvector_bsearch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "392-419",
    "snippet": "static int\ntsvector_bsearch(const TSVector tsv, char *lexeme, int lexeme_len)\n{\n\tWordEntry  *arrin = ARRPTR(tsv);\n\tint\t\t\tStopLow = 0,\n\t\t\t\tStopHigh = tsv->size,\n\t\t\t\tStopMiddle,\n\t\t\t\tcmp;\n\n\twhile (StopLow < StopHigh)\n\t{\n\t\tStopMiddle = (StopLow + StopHigh) / 2;\n\n\t\tcmp = tsCompareString(lexeme, lexeme_len,\n\t\t\t\t\t\t\t  STRPTR(tsv) + arrin[StopMiddle].pos,\n\t\t\t\t\t\t\t  arrin[StopMiddle].len,\n\t\t\t\t\t\t\t  false);\n\n\t\tif (cmp < 0)\n\t\t\tStopHigh = StopMiddle;\n\t\telse if (cmp > 0)\n\t\t\tStopLow = StopMiddle + 1;\n\t\telse\t\t\t\t\t/* found it */\n\t\t\treturn StopMiddle;\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\ttsvector_bsearch(const TSVector tsv, char *lexeme, int lexeme_len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tsCompareString",
          "args": [
            "lexeme",
            "lexeme_len",
            "STRPTR(tsv) + arrin[StopMiddle].pos",
            "arrin[StopMiddle].len",
            "false"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "tsCompareString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "1159-1191",
          "snippet": "int32\ntsCompareString(char *a, int lena, char *b, int lenb, bool prefix)\n{\n\tint\t\t\tcmp;\n\n\tif (lena == 0)\n\t{\n\t\tif (prefix)\n\t\t\tcmp = 0;\t\t\t/* empty string is prefix of anything */\n\t\telse\n\t\t\tcmp = (lenb > 0) ? -1 : 0;\n\t}\n\telse if (lenb == 0)\n\t{\n\t\tcmp = (lena > 0) ? 1 : 0;\n\t}\n\telse\n\t{\n\t\tcmp = memcmp(a, b, Min(lena, lenb));\n\n\t\tif (prefix)\n\t\t{\n\t\t\tif (cmp == 0 && lena > lenb)\n\t\t\t\tcmp = 1;\t\t/* a is longer, so not a prefix of b */\n\t\t}\n\t\telse if (cmp == 0 && lena != lenb)\n\t\t{\n\t\t\tcmp = (lena < lenb) ? -1 : 1;\n\t\t}\n\t}\n\n\treturn cmp;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nint32\ntsCompareString(char *a, int lena, char *b, int lenb, bool prefix)\n{\n\tint\t\t\tcmp;\n\n\tif (lena == 0)\n\t{\n\t\tif (prefix)\n\t\t\tcmp = 0;\t\t\t/* empty string is prefix of anything */\n\t\telse\n\t\t\tcmp = (lenb > 0) ? -1 : 0;\n\t}\n\telse if (lenb == 0)\n\t{\n\t\tcmp = (lena > 0) ? 1 : 0;\n\t}\n\telse\n\t{\n\t\tcmp = memcmp(a, b, Min(lena, lenb));\n\n\t\tif (prefix)\n\t\t{\n\t\t\tif (cmp == 0 && lena > lenb)\n\t\t\t\tcmp = 1;\t\t/* a is longer, so not a prefix of b */\n\t\t}\n\t\telse if (cmp == 0 && lena != lenb)\n\t\t{\n\t\t\tcmp = (lena < lenb) ? -1 : 1;\n\t\t}\n\t}\n\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "tsv"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "tsv"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\ttsvector_bsearch(const TSVector tsv, char *lexeme, int lexeme_len);\n\nstatic int\ntsvector_bsearch(const TSVector tsv, char *lexeme, int lexeme_len)\n{\n\tWordEntry  *arrin = ARRPTR(tsv);\n\tint\t\t\tStopLow = 0,\n\t\t\t\tStopHigh = tsv->size,\n\t\t\t\tStopMiddle,\n\t\t\t\tcmp;\n\n\twhile (StopLow < StopHigh)\n\t{\n\t\tStopMiddle = (StopLow + StopHigh) / 2;\n\n\t\tcmp = tsCompareString(lexeme, lexeme_len,\n\t\t\t\t\t\t\t  STRPTR(tsv) + arrin[StopMiddle].pos,\n\t\t\t\t\t\t\t  arrin[StopMiddle].len,\n\t\t\t\t\t\t\t  false);\n\n\t\tif (cmp < 0)\n\t\t\tStopHigh = StopMiddle;\n\t\telse if (cmp > 0)\n\t\t\tStopLow = StopMiddle + 1;\n\t\telse\t\t\t\t\t/* found it */\n\t\t\treturn StopMiddle;\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "add_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "356-385",
    "snippet": "static int32\nadd_pos(TSVector src, WordEntry *srcptr,\n\t\tTSVector dest, WordEntry *destptr,\n\t\tint32 maxpos)\n{\n\tuint16\t   *clen = &_POSVECPTR(dest, destptr)->npos;\n\tint\t\t\ti;\n\tuint16\t\tslen = POSDATALEN(src, srcptr),\n\t\t\t\tstartlen;\n\tWordEntryPos *spos = POSDATAPTR(src, srcptr),\n\t\t\t   *dpos = POSDATAPTR(dest, destptr);\n\n\tif (!destptr->haspos)\n\t\t*clen = 0;\n\n\tstartlen = *clen;\n\tfor (i = 0;\n\t\t i < slen && *clen < MAXNUMPOS &&\n\t\t (*clen == 0 || WEP_GETPOS(dpos[*clen - 1]) != MAXENTRYPOS - 1);\n\t\t i++)\n\t{\n\t\tWEP_SETWEIGHT(dpos[*clen], WEP_GETWEIGHT(spos[i]));\n\t\tWEP_SETPOS(dpos[*clen], LIMITPOS(WEP_GETPOS(spos[i]) + maxpos));\n\t\t(*clen)++;\n\t}\n\n\tif (*clen != startlen)\n\t\tdestptr->haspos = 1;\n\treturn *clen - startlen;\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WEP_SETPOS",
          "args": [
            "dpos[*clen]",
            "LIMITPOS(WEP_GETPOS(spos[i]) + maxpos)"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIMITPOS",
          "args": [
            "WEP_GETPOS(spos[i]) + maxpos"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "spos[i]"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_SETWEIGHT",
          "args": [
            "dpos[*clen]",
            "WEP_GETWEIGHT(spos[i])"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "spos[i]"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "dpos[*clen - 1]"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATAPTR",
          "args": [
            "dest",
            "destptr"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATAPTR",
          "args": [
            "src",
            "srcptr"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "src",
            "srcptr"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_POSVECPTR",
          "args": [
            "dest",
            "destptr"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int32\nadd_pos(TSVector src, WordEntry *srcptr,\n\t\tTSVector dest, WordEntry *destptr,\n\t\tint32 maxpos)\n{\n\tuint16\t   *clen = &_POSVECPTR(dest, destptr)->npos;\n\tint\t\t\ti;\n\tuint16\t\tslen = POSDATALEN(src, srcptr),\n\t\t\t\tstartlen;\n\tWordEntryPos *spos = POSDATAPTR(src, srcptr),\n\t\t\t   *dpos = POSDATAPTR(dest, destptr);\n\n\tif (!destptr->haspos)\n\t\t*clen = 0;\n\n\tstartlen = *clen;\n\tfor (i = 0;\n\t\t i < slen && *clen < MAXNUMPOS &&\n\t\t (*clen == 0 || WEP_GETPOS(dpos[*clen - 1]) != MAXENTRYPOS - 1);\n\t\t i++)\n\t{\n\t\tWEP_SETWEIGHT(dpos[*clen], WEP_GETWEIGHT(spos[i]));\n\t\tWEP_SETPOS(dpos[*clen], LIMITPOS(WEP_GETPOS(spos[i]) + maxpos));\n\t\t(*clen)++;\n\t}\n\n\tif (*clen != startlen)\n\t\tdestptr->haspos = 1;\n\treturn *clen - startlen;\n}"
  },
  {
    "function_name": "tsvector_setweight_by_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "263-345",
    "snippet": "Datum\ntsvector_setweight_by_filter(PG_FUNCTION_ARGS)\n{\n\tTSVector\ttsin = PG_GETARG_TSVECTOR(0);\n\tchar\t\tchar_weight = PG_GETARG_CHAR(1);\n\tArrayType  *lexemes = PG_GETARG_ARRAYTYPE_P(2);\n\n\tTSVector\ttsout;\n\tint\t\t\ti,\n\t\t\t\tj,\n\t\t\t\tnlexemes,\n\t\t\t\tweight;\n\tWordEntry  *entry;\n\tDatum\t   *dlexemes;\n\tbool\t   *nulls;\n\n\tswitch (char_weight)\n\t{\n\t\tcase 'A':\n\t\tcase 'a':\n\t\t\tweight = 3;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\tcase 'b':\n\t\t\tweight = 2;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\tcase 'c':\n\t\t\tweight = 1;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\tcase 'd':\n\t\t\tweight = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* internal error */\n\t\t\telog(ERROR, \"unrecognized weight: %c\", char_weight);\n\t}\n\n\ttsout = (TSVector) palloc(VARSIZE(tsin));\n\tmemcpy(tsout, tsin, VARSIZE(tsin));\n\tentry = ARRPTR(tsout);\n\n\tdeconstruct_array(lexemes, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &dlexemes, &nulls, &nlexemes);\n\n\t/*\n\t * Assuming that lexemes array is significantly shorter than tsvector we\n\t * can iterate through lexemes performing binary search of each lexeme\n\t * from lexemes in tsvector.\n\t */\n\tfor (i = 0; i < nlexemes; i++)\n\t{\n\t\tchar\t   *lex;\n\t\tint\t\t\tlex_len,\n\t\t\t\t\tlex_pos;\n\n\t\tif (nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"lexeme array may not contain nulls\")));\n\n\t\tlex = VARDATA(dlexemes[i]);\n\t\tlex_len = VARSIZE(dlexemes[i]) - VARHDRSZ;\n\t\tlex_pos = tsvector_bsearch(tsout, lex, lex_len);\n\n\t\tif (lex_pos >= 0 && (j = POSDATALEN(tsout, entry + lex_pos)) != 0)\n\t\t{\n\t\t\tWordEntryPos *p = POSDATAPTR(tsout, entry + lex_pos);\n\n\t\t\twhile (j--)\n\t\t\t{\n\t\t\t\tWEP_SETWEIGHT(*p, weight);\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t}\n\n\tPG_FREE_IF_COPY(tsin, 0);\n\tPG_FREE_IF_COPY(lexemes, 2);\n\n\tPG_RETURN_POINTER(tsout);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "tsout"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "lexemes",
            "2"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "tsin",
            "0"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_SETWEIGHT",
          "args": [
            "*p",
            "weight"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATAPTR",
          "args": [
            "tsout",
            "entry + lex_pos"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "tsout",
            "entry + lex_pos"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsvector_bsearch",
          "args": [
            "tsout",
            "lex",
            "lex_len"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "tsvector_bsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "392-419",
          "snippet": "static int\ntsvector_bsearch(const TSVector tsv, char *lexeme, int lexeme_len)\n{\n\tWordEntry  *arrin = ARRPTR(tsv);\n\tint\t\t\tStopLow = 0,\n\t\t\t\tStopHigh = tsv->size,\n\t\t\t\tStopMiddle,\n\t\t\t\tcmp;\n\n\twhile (StopLow < StopHigh)\n\t{\n\t\tStopMiddle = (StopLow + StopHigh) / 2;\n\n\t\tcmp = tsCompareString(lexeme, lexeme_len,\n\t\t\t\t\t\t\t  STRPTR(tsv) + arrin[StopMiddle].pos,\n\t\t\t\t\t\t\t  arrin[StopMiddle].len,\n\t\t\t\t\t\t\t  false);\n\n\t\tif (cmp < 0)\n\t\t\tStopHigh = StopMiddle;\n\t\telse if (cmp > 0)\n\t\t\tStopLow = StopMiddle + 1;\n\t\telse\t\t\t\t\t/* found it */\n\t\t\treturn StopMiddle;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\ttsvector_bsearch(const TSVector tsv, char *lexeme, int lexeme_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\ttsvector_bsearch(const TSVector tsv, char *lexeme, int lexeme_len);\n\nstatic int\ntsvector_bsearch(const TSVector tsv, char *lexeme, int lexeme_len)\n{\n\tWordEntry  *arrin = ARRPTR(tsv);\n\tint\t\t\tStopLow = 0,\n\t\t\t\tStopHigh = tsv->size,\n\t\t\t\tStopMiddle,\n\t\t\t\tcmp;\n\n\twhile (StopLow < StopHigh)\n\t{\n\t\tStopMiddle = (StopLow + StopHigh) / 2;\n\n\t\tcmp = tsCompareString(lexeme, lexeme_len,\n\t\t\t\t\t\t\t  STRPTR(tsv) + arrin[StopMiddle].pos,\n\t\t\t\t\t\t\t  arrin[StopMiddle].len,\n\t\t\t\t\t\t\t  false);\n\n\t\tif (cmp < 0)\n\t\t\tStopHigh = StopMiddle;\n\t\telse if (cmp > 0)\n\t\t\tStopLow = StopMiddle + 1;\n\t\telse\t\t\t\t\t/* found it */\n\t\t\treturn StopMiddle;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "dlexemes[i]"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARDATA",
          "args": [
            "dlexemes[i]"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "ERROR",
            "(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"lexeme array may not contain nulls\"))"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"lexeme array may not contain nulls\""
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode",
          "args": [
            "ERRCODE_NULL_VALUE_NOT_ALLOWED"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "errcode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "572-583",
          "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "deconstruct_array",
          "args": [
            "lexemes",
            "TEXTOID",
            "-1",
            "false",
            "'i'",
            "&dlexemes",
            "&nulls",
            "&nlexemes"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "deconstruct_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "3460-3519",
          "snippet": "void\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic Datum array_set_element_expanded(Datum arraydatum,\n\t\t\t\t\t\t   int nSubscripts, int *indx,\n\t\t\t\t\t\t   Datum dataValue, bool isNull,\n\t\t\t\t\t\t   int arraytyplen,\n\t\t\t\t\t\t   int elmlen, bool elmbyval, char elmalign);\n\nvoid\ndeconstruct_array(ArrayType *array,\n\t\t\t\t  Oid elmtype,\n\t\t\t\t  int elmlen, bool elmbyval, char elmalign,\n\t\t\t\t  Datum **elemsp, bool **nullsp, int *nelemsp)\n{\n\tDatum\t   *elems;\n\tbool\t   *nulls;\n\tint\t\t\tnelems;\n\tchar\t   *p;\n\tbits8\t   *bitmap;\n\tint\t\t\tbitmask;\n\tint\t\t\ti;\n\n\tAssert(ARR_ELEMTYPE(array) == elmtype);\n\n\tnelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));\n\t*elemsp = elems = (Datum *) palloc(nelems * sizeof(Datum));\n\tif (nullsp)\n\t\t*nullsp = nulls = (bool *) palloc0(nelems * sizeof(bool));\n\telse\n\t\tnulls = NULL;\n\t*nelemsp = nelems;\n\n\tp = ARR_DATA_PTR(array);\n\tbitmap = ARR_NULLBITMAP(array);\n\tbitmask = 1;\n\n\tfor (i = 0; i < nelems; i++)\n\t{\n\t\t/* Get source element, checking for NULL */\n\t\tif (bitmap && (*bitmap & bitmask) == 0)\n\t\t{\n\t\t\telems[i] = (Datum) 0;\n\t\t\tif (nulls)\n\t\t\t\tnulls[i] = true;\n\t\t\telse\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t\t errmsg(\"null array element not allowed in this context\")));\n\t\t}\n\t\telse\n\t\t{\n\t\t\telems[i] = fetch_att(p, elmbyval, elmlen);\n\t\t\tp = att_addlength_pointer(p, elmlen, p);\n\t\t\tp = (char *) att_align_nominal(p, elmalign);\n\t\t}\n\n\t\t/* advance bitmap pointer if any */\n\t\tif (bitmap)\n\t\t{\n\t\t\tbitmask <<= 1;\n\t\t\tif (bitmask == 0x100)\n\t\t\t{\n\t\t\t\tbitmap++;\n\t\t\t\tbitmask = 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "tsout"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tsout",
            "tsin",
            "VARSIZE(tsin)"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "tsin"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "VARSIZE(tsin)"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "tsin"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized weight: %c\"",
            "char_weight"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_ARRAYTYPE_P",
          "args": [
            "2"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CHAR",
          "args": [
            "1"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "0"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ntsvector_setweight_by_filter(PG_FUNCTION_ARGS)\n{\n\tTSVector\ttsin = PG_GETARG_TSVECTOR(0);\n\tchar\t\tchar_weight = PG_GETARG_CHAR(1);\n\tArrayType  *lexemes = PG_GETARG_ARRAYTYPE_P(2);\n\n\tTSVector\ttsout;\n\tint\t\t\ti,\n\t\t\t\tj,\n\t\t\t\tnlexemes,\n\t\t\t\tweight;\n\tWordEntry  *entry;\n\tDatum\t   *dlexemes;\n\tbool\t   *nulls;\n\n\tswitch (char_weight)\n\t{\n\t\tcase 'A':\n\t\tcase 'a':\n\t\t\tweight = 3;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\tcase 'b':\n\t\t\tweight = 2;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\tcase 'c':\n\t\t\tweight = 1;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\tcase 'd':\n\t\t\tweight = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* internal error */\n\t\t\telog(ERROR, \"unrecognized weight: %c\", char_weight);\n\t}\n\n\ttsout = (TSVector) palloc(VARSIZE(tsin));\n\tmemcpy(tsout, tsin, VARSIZE(tsin));\n\tentry = ARRPTR(tsout);\n\n\tdeconstruct_array(lexemes, TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &dlexemes, &nulls, &nlexemes);\n\n\t/*\n\t * Assuming that lexemes array is significantly shorter than tsvector we\n\t * can iterate through lexemes performing binary search of each lexeme\n\t * from lexemes in tsvector.\n\t */\n\tfor (i = 0; i < nlexemes; i++)\n\t{\n\t\tchar\t   *lex;\n\t\tint\t\t\tlex_len,\n\t\t\t\t\tlex_pos;\n\n\t\tif (nulls[i])\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"lexeme array may not contain nulls\")));\n\n\t\tlex = VARDATA(dlexemes[i]);\n\t\tlex_len = VARSIZE(dlexemes[i]) - VARHDRSZ;\n\t\tlex_pos = tsvector_bsearch(tsout, lex, lex_len);\n\n\t\tif (lex_pos >= 0 && (j = POSDATALEN(tsout, entry + lex_pos)) != 0)\n\t\t{\n\t\t\tWordEntryPos *p = POSDATAPTR(tsout, entry + lex_pos);\n\n\t\t\twhile (j--)\n\t\t\t{\n\t\t\t\tWEP_SETWEIGHT(*p, weight);\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t}\n\n\tPG_FREE_IF_COPY(tsin, 0);\n\tPG_FREE_IF_COPY(lexemes, 2);\n\n\tPG_RETURN_POINTER(tsout);\n}"
  },
  {
    "function_name": "tsvector_setweight",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "201-256",
    "snippet": "Datum\ntsvector_setweight(PG_FUNCTION_ARGS)\n{\n\tTSVector\tin = PG_GETARG_TSVECTOR(0);\n\tchar\t\tcw = PG_GETARG_CHAR(1);\n\tTSVector\tout;\n\tint\t\t\ti,\n\t\t\t\tj;\n\tWordEntry  *entry;\n\tWordEntryPos *p;\n\tint\t\t\tw = 0;\n\n\tswitch (cw)\n\t{\n\t\tcase 'A':\n\t\tcase 'a':\n\t\t\tw = 3;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\tcase 'b':\n\t\t\tw = 2;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\tcase 'c':\n\t\t\tw = 1;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\tcase 'd':\n\t\t\tw = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* internal error */\n\t\t\telog(ERROR, \"unrecognized weight: %d\", cw);\n\t}\n\n\tout = (TSVector) palloc(VARSIZE(in));\n\tmemcpy(out, in, VARSIZE(in));\n\tentry = ARRPTR(out);\n\ti = out->size;\n\twhile (i--)\n\t{\n\t\tif ((j = POSDATALEN(out, entry)) != 0)\n\t\t{\n\t\t\tp = POSDATAPTR(out, entry);\n\t\t\twhile (j--)\n\t\t\t{\n\t\t\t\tWEP_SETWEIGHT(*p, w);\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tentry++;\n\t}\n\n\tPG_FREE_IF_COPY(in, 0);\n\tPG_RETURN_POINTER(out);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "out"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "in",
            "0"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_SETWEIGHT",
          "args": [
            "*p",
            "w"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATAPTR",
          "args": [
            "out",
            "entry"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "out",
            "entry"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "out"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "out",
            "in",
            "VARSIZE(in)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "in"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "VARSIZE(in)"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "xml_palloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/xml.c",
          "lines": "1635-1639",
          "snippet": "static void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}",
          "includes": [
            "#include \"utils/xml.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"nodes/execnodes.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/stringinfo.h\"",
            "#include \"fmgr.h\"",
            "#include \"executor/tablefunc.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_class.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/xmlwriter.h>",
            "#include <libxml/xmlversion.h>",
            "#include <libxml/xmlerror.h>",
            "#include <libxml/uri.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parserInternals.h>",
            "#include <libxml/parser.h>",
            "#include <libxml/chvalid.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/xml.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/execnodes.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/stringinfo.h\"\n#include \"fmgr.h\"\n#include \"executor/tablefunc.h\"\n#include \"executor/spi.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_class.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/xpath.h>\n#include <libxml/xmlwriter.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xmlerror.h>\n#include <libxml/uri.h>\n#include <libxml/tree.h>\n#include <libxml/parserInternals.h>\n#include <libxml/parser.h>\n#include <libxml/chvalid.h>\n#include \"postgres.h\"\n\nstatic void *\nxml_palloc(size_t size)\n{\n\treturn MemoryContextAlloc(LibxmlContext, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "in"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unrecognized weight: %d\"",
            "cw"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PG_GETARG_CHAR",
          "args": [
            "1"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "0"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ntsvector_setweight(PG_FUNCTION_ARGS)\n{\n\tTSVector\tin = PG_GETARG_TSVECTOR(0);\n\tchar\t\tcw = PG_GETARG_CHAR(1);\n\tTSVector\tout;\n\tint\t\t\ti,\n\t\t\t\tj;\n\tWordEntry  *entry;\n\tWordEntryPos *p;\n\tint\t\t\tw = 0;\n\n\tswitch (cw)\n\t{\n\t\tcase 'A':\n\t\tcase 'a':\n\t\t\tw = 3;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\tcase 'b':\n\t\t\tw = 2;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\tcase 'c':\n\t\t\tw = 1;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\tcase 'd':\n\t\t\tw = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* internal error */\n\t\t\telog(ERROR, \"unrecognized weight: %d\", cw);\n\t}\n\n\tout = (TSVector) palloc(VARSIZE(in));\n\tmemcpy(out, in, VARSIZE(in));\n\tentry = ARRPTR(out);\n\ti = out->size;\n\twhile (i--)\n\t{\n\t\tif ((j = POSDATALEN(out, entry)) != 0)\n\t\t{\n\t\t\tp = POSDATAPTR(out, entry);\n\t\t\twhile (j--)\n\t\t\t{\n\t\t\t\tWEP_SETWEIGHT(*p, w);\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tentry++;\n\t}\n\n\tPG_FREE_IF_COPY(in, 0);\n\tPG_RETURN_POINTER(out);\n}"
  },
  {
    "function_name": "tsvector_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "191-199",
    "snippet": "Datum\ntsvector_length(PG_FUNCTION_ARGS)\n{\n\tTSVector\tin = PG_GETARG_TSVECTOR(0);\n\tint32\t\tret = in->size;\n\n\tPG_FREE_IF_COPY(in, 0);\n\tPG_RETURN_INT32(ret);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_INT32",
          "args": [
            "ret"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "in",
            "0"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "0"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ntsvector_length(PG_FUNCTION_ARGS)\n{\n\tTSVector\tin = PG_GETARG_TSVECTOR(0);\n\tint32\t\tret = in->size;\n\n\tPG_FREE_IF_COPY(in, 0);\n\tPG_RETURN_INT32(ret);\n}"
  },
  {
    "function_name": "tsvector_strip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "158-189",
    "snippet": "Datum\ntsvector_strip(PG_FUNCTION_ARGS)\n{\n\tTSVector\tin = PG_GETARG_TSVECTOR(0);\n\tTSVector\tout;\n\tint\t\t\ti,\n\t\t\t\tlen = 0;\n\tWordEntry  *arrin = ARRPTR(in),\n\t\t\t   *arrout;\n\tchar\t   *cur;\n\n\tfor (i = 0; i < in->size; i++)\n\t\tlen += arrin[i].len;\n\n\tlen = CALCDATASIZE(in->size, len);\n\tout = (TSVector) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = in->size;\n\tarrout = ARRPTR(out);\n\tcur = STRPTR(out);\n\tfor (i = 0; i < in->size; i++)\n\t{\n\t\tmemcpy(cur, STRPTR(in) + arrin[i].pos, arrin[i].len);\n\t\tarrout[i].haspos = 0;\n\t\tarrout[i].len = arrin[i].len;\n\t\tarrout[i].pos = cur - STRPTR(out);\n\t\tcur += arrout[i].len;\n\t}\n\n\tPG_FREE_IF_COPY(in, 0);\n\tPG_RETURN_POINTER(out);\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RETURN_POINTER",
          "args": [
            "out"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_FREE_IF_COPY",
          "args": [
            "in",
            "0"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "out"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cur",
            "STRPTR(in) + arrin[i].pos",
            "arrin[i].len"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "in"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "out"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "out"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_VARSIZE",
          "args": [
            "out",
            "len"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc0",
          "args": [
            "len"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CALCDATASIZE",
          "args": [
            "in->size",
            "len"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "in"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_GETARG_TSVECTOR",
          "args": [
            "0"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nDatum\ntsvector_strip(PG_FUNCTION_ARGS)\n{\n\tTSVector\tin = PG_GETARG_TSVECTOR(0);\n\tTSVector\tout;\n\tint\t\t\ti,\n\t\t\t\tlen = 0;\n\tWordEntry  *arrin = ARRPTR(in),\n\t\t\t   *arrout;\n\tchar\t   *cur;\n\n\tfor (i = 0; i < in->size; i++)\n\t\tlen += arrin[i].len;\n\n\tlen = CALCDATASIZE(in->size, len);\n\tout = (TSVector) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = in->size;\n\tarrout = ARRPTR(out);\n\tcur = STRPTR(out);\n\tfor (i = 0; i < in->size; i++)\n\t{\n\t\tmemcpy(cur, STRPTR(in) + arrin[i].pos, arrin[i].len);\n\t\tarrout[i].haspos = 0;\n\t\tarrout[i].len = arrin[i].len;\n\t\tarrout[i].pos = cur - STRPTR(out);\n\t\tcur += arrout[i].len;\n\t}\n\n\tPG_FREE_IF_COPY(in, 0);\n\tPG_RETURN_POINTER(out);\n}"
  },
  {
    "function_name": "silly_cmp_tsvector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
    "lines": "76-134",
    "snippet": "static int\nsilly_cmp_tsvector(const TSVector a, const TSVector b)\n{\n\tif (VARSIZE(a) < VARSIZE(b))\n\t\treturn -1;\n\telse if (VARSIZE(a) > VARSIZE(b))\n\t\treturn 1;\n\telse if (a->size < b->size)\n\t\treturn -1;\n\telse if (a->size > b->size)\n\t\treturn 1;\n\telse\n\t{\n\t\tWordEntry  *aptr = ARRPTR(a);\n\t\tWordEntry  *bptr = ARRPTR(b);\n\t\tint\t\t\ti = 0;\n\t\tint\t\t\tres;\n\n\n\t\tfor (i = 0; i < a->size; i++)\n\t\t{\n\t\t\tif (aptr->haspos != bptr->haspos)\n\t\t\t{\n\t\t\t\treturn (aptr->haspos > bptr->haspos) ? -1 : 1;\n\t\t\t}\n\t\t\telse if ((res = tsCompareString(STRPTR(a) + aptr->pos, aptr->len, STRPTR(b) + bptr->pos, bptr->len, false)) != 0)\n\t\t\t{\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\telse if (aptr->haspos)\n\t\t\t{\n\t\t\t\tWordEntryPos *ap = POSDATAPTR(a, aptr);\n\t\t\t\tWordEntryPos *bp = POSDATAPTR(b, bptr);\n\t\t\t\tint\t\t\tj;\n\n\t\t\t\tif (POSDATALEN(a, aptr) != POSDATALEN(b, bptr))\n\t\t\t\t\treturn (POSDATALEN(a, aptr) > POSDATALEN(b, bptr)) ? -1 : 1;\n\n\t\t\t\tfor (j = 0; j < POSDATALEN(a, aptr); j++)\n\t\t\t\t{\n\t\t\t\t\tif (WEP_GETPOS(*ap) != WEP_GETPOS(*bp))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn (WEP_GETPOS(*ap) > WEP_GETPOS(*bp)) ? -1 : 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (WEP_GETWEIGHT(*ap) != WEP_GETWEIGHT(*bp))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn (WEP_GETWEIGHT(*ap) > WEP_GETWEIGHT(*bp)) ? -1 : 1;\n\t\t\t\t\t}\n\t\t\t\t\tap++, bp++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\taptr++;\n\t\t\tbptr++;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"utils/rel.h\"",
      "#include \"utils/regproc.h\"",
      "#include \"utils/lsyscache.h\"",
      "#include \"utils/builtins.h\"",
      "#include \"tsearch/ts_utils.h\"",
      "#include \"parser/parse_coerce.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"funcapi.h\"",
      "#include \"executor/spi.h\"",
      "#include \"commands/trigger.h\"",
      "#include \"catalog/pg_type.h\"",
      "#include \"catalog/namespace.h\"",
      "#include \"access/htup_details.h\"",
      "#include <limits.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "*bp"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "*ap"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "*bp"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETWEIGHT",
          "args": [
            "*ap"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "*bp"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "*ap"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "*bp"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEP_GETPOS",
          "args": [
            "*ap"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "a",
            "aptr"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "b",
            "bptr"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "a",
            "aptr"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "b",
            "bptr"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATALEN",
          "args": [
            "a",
            "aptr"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATAPTR",
          "args": [
            "b",
            "bptr"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POSDATAPTR",
          "args": [
            "a",
            "aptr"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsCompareString",
          "args": [
            "STRPTR(a) + aptr->pos",
            "aptr->len",
            "STRPTR(b) + bptr->pos",
            "bptr->len",
            "false"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "tsCompareString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsvector_op.c",
          "lines": "1159-1191",
          "snippet": "int32\ntsCompareString(char *a, int lena, char *b, int lenb, bool prefix)\n{\n\tint\t\t\tcmp;\n\n\tif (lena == 0)\n\t{\n\t\tif (prefix)\n\t\t\tcmp = 0;\t\t\t/* empty string is prefix of anything */\n\t\telse\n\t\t\tcmp = (lenb > 0) ? -1 : 0;\n\t}\n\telse if (lenb == 0)\n\t{\n\t\tcmp = (lena > 0) ? 1 : 0;\n\t}\n\telse\n\t{\n\t\tcmp = memcmp(a, b, Min(lena, lenb));\n\n\t\tif (prefix)\n\t\t{\n\t\t\tif (cmp == 0 && lena > lenb)\n\t\t\t\tcmp = 1;\t\t/* a is longer, so not a prefix of b */\n\t\t}\n\t\telse if (cmp == 0 && lena != lenb)\n\t\t{\n\t\t\tcmp = (lena < lenb) ? -1 : 1;\n\t\t}\n\t}\n\n\treturn cmp;\n}",
          "includes": [
            "#include \"utils/rel.h\"",
            "#include \"utils/regproc.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"parser/parse_coerce.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"funcapi.h\"",
            "#include \"executor/spi.h\"",
            "#include \"commands/trigger.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/htup_details.h\"",
            "#include <limits.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nint32\ntsCompareString(char *a, int lena, char *b, int lenb, bool prefix)\n{\n\tint\t\t\tcmp;\n\n\tif (lena == 0)\n\t{\n\t\tif (prefix)\n\t\t\tcmp = 0;\t\t\t/* empty string is prefix of anything */\n\t\telse\n\t\t\tcmp = (lenb > 0) ? -1 : 0;\n\t}\n\telse if (lenb == 0)\n\t{\n\t\tcmp = (lena > 0) ? 1 : 0;\n\t}\n\telse\n\t{\n\t\tcmp = memcmp(a, b, Min(lena, lenb));\n\n\t\tif (prefix)\n\t\t{\n\t\t\tif (cmp == 0 && lena > lenb)\n\t\t\t\tcmp = 1;\t\t/* a is longer, so not a prefix of b */\n\t\t}\n\t\telse if (cmp == 0 && lena != lenb)\n\t\t{\n\t\t\tcmp = (lena < lenb) ? -1 : 1;\n\t\t}\n\t}\n\n\treturn cmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "b"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPTR",
          "args": [
            "a"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "b"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRPTR",
          "args": [
            "a"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "b"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "a"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "b"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VARSIZE",
          "args": [
            "a"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/rel.h\"\n#include \"utils/regproc.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"parser/parse_coerce.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"funcapi.h\"\n#include \"executor/spi.h\"\n#include \"commands/trigger.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"access/htup_details.h\"\n#include <limits.h>\n#include \"postgres.h\"\n\nstatic int\nsilly_cmp_tsvector(const TSVector a, const TSVector b)\n{\n\tif (VARSIZE(a) < VARSIZE(b))\n\t\treturn -1;\n\telse if (VARSIZE(a) > VARSIZE(b))\n\t\treturn 1;\n\telse if (a->size < b->size)\n\t\treturn -1;\n\telse if (a->size > b->size)\n\t\treturn 1;\n\telse\n\t{\n\t\tWordEntry  *aptr = ARRPTR(a);\n\t\tWordEntry  *bptr = ARRPTR(b);\n\t\tint\t\t\ti = 0;\n\t\tint\t\t\tres;\n\n\n\t\tfor (i = 0; i < a->size; i++)\n\t\t{\n\t\t\tif (aptr->haspos != bptr->haspos)\n\t\t\t{\n\t\t\t\treturn (aptr->haspos > bptr->haspos) ? -1 : 1;\n\t\t\t}\n\t\t\telse if ((res = tsCompareString(STRPTR(a) + aptr->pos, aptr->len, STRPTR(b) + bptr->pos, bptr->len, false)) != 0)\n\t\t\t{\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\telse if (aptr->haspos)\n\t\t\t{\n\t\t\t\tWordEntryPos *ap = POSDATAPTR(a, aptr);\n\t\t\t\tWordEntryPos *bp = POSDATAPTR(b, bptr);\n\t\t\t\tint\t\t\tj;\n\n\t\t\t\tif (POSDATALEN(a, aptr) != POSDATALEN(b, bptr))\n\t\t\t\t\treturn (POSDATALEN(a, aptr) > POSDATALEN(b, bptr)) ? -1 : 1;\n\n\t\t\t\tfor (j = 0; j < POSDATALEN(a, aptr); j++)\n\t\t\t\t{\n\t\t\t\t\tif (WEP_GETPOS(*ap) != WEP_GETPOS(*bp))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn (WEP_GETPOS(*ap) > WEP_GETPOS(*bp)) ? -1 : 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (WEP_GETWEIGHT(*ap) != WEP_GETWEIGHT(*bp))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn (WEP_GETWEIGHT(*ap) > WEP_GETWEIGHT(*bp)) ? -1 : 1;\n\t\t\t\t\t}\n\t\t\t\t\tap++, bp++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\taptr++;\n\t\t\tbptr++;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  }
]